<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0b06da9d5d4edede8590235c6dcae64?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Radosław Smogura</string> &lt;rsmogura at icloud.com&gt;<p>December 26, 2015 at 12:00:00pm</p></header><div class="content"><p>Hello Swift Team,<br></p><p>As it’s my first post on this mailing list, let me introduce my self. My name is Radek Smogura, and for 10 year I work as developer, mainly Java and I know C and C++. I would like to join Swift community and work on Swift language. Previously for hobby I  added properties syntax to it and full closure support (you can find it here https://bitbucket.org/radoslaw_smogura/java-closures-silver-jdk9-langtools/wiki/Home).<br></p><p>I would like to propose custom attributes support, as it would make Swift more robust language, by allowing dependency injection and managed objects (ie. for Core Data or some trivial example like defining JSON structures for REST). I would as well to contribute to this feature to Swift language if possible as fork or branch.<br></p><p>My general high level plan is as follow:<br>- add experimental feature switch to add parsing custom attributes,<br>- define and implement attribute syntax,<br>- compile attributes and store those,<br>- add validation and compilation to attribute declarations<br>- - (optionally) refactor current code<br>- enjoy.<br></p><p>Waiting for your thoughts,<br>Radek<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 26, 2015 at 01:00:00pm</p></header><div class="content"><p>On Sat, Dec 26, 2015 at 12:55 PM, Radosław Smogura<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift Team,<br>&gt;<br>&gt; As it’s my first post on this mailing list, let me introduce my self. My name is Radek Smogura, and for 10 year I work as developer, mainly Java and I know C and C++. I would like to join Swift community and work on Swift language. Previously for hobby I  added properties syntax to it and full closure support (you can find it here https://bitbucket.org/radoslaw_smogura/java-closures-silver-jdk9-langtools/wiki/Home).<br>&gt;<br>&gt; I would like to propose custom attributes support, as it would make Swift more robust language, by allowing dependency injection and managed objects (ie. for Core Data or some trivial example like defining JSON structures for REST). I would as well to contribute to this feature to Swift language if possible as fork or branch.<br></p><p>Custom attributes are an interesting direction that already came up on<br>this list, but there was no concrete proposal with syntax and<br>semantics.  Before you spend time implementing something extensive, I<br>would strongly recommend you to float the idea on swift-evolution, and<br>follow-up with a formal proposal if there is consensus.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0b06da9d5d4edede8590235c6dcae64?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Radosław Smogura</string> &lt;rsmogura at icloud.com&gt;<p>December 26, 2015 at 03:00:00pm</p></header><div class="content"><p>So,<br></p><p>What do you think about syntax like this:<br></p><p>// Declaration<br>@AttributeUsage(RUNTIME) //Can be SOURCE - attribute not emitted into binary<br>@AttributeTarget(PROPERTY) //Other CLASS, ENUM, METHOD, INIT<br>@attribute JSONProperty {<br>var name:String!;<br>var serializable:Bool? = true;<br>var deserializable:Bool? = true;<br>}<br></p><p>// Usage<br>@JSONProperty(name=“id”)<br>var id:Int;<br></p><p><br>Attributes should be module aware (actual attributes should be redefined as Swift attribute, for beginning still can be hardcoded).<br></p><p>The attribute’s name have to be unique in module. It’s compile time error if attribute, class, enum, struct, etc has same name. <br></p><p>Attribute’s properties are read only and can’t be assigned - so during reflection no-one would change ‘shared’ values.<br></p><p>Attribute’s properties can only support basic types: primitives, strings, types, and other attributes (optional). <br></p><p>When declaring attributes, properties can be set to constant values (static let) or enum values, however the final value is stored in binary, not a reference to it.<br></p><p>The compiler has build in support for core attributes, which can affect code generation. Compiler may perform additional checks on core attributes.<br></p><p>Attributes on attributes (optional).<br></p><p>Best regards,<br>Radek<br></p><p>&gt; On 26 Dec 2015, at 13:35, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sat, Dec 26, 2015 at 12:55 PM, Radosław Smogura<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello Swift Team,<br>&gt;&gt; <br>&gt;&gt; As it’s my first post on this mailing list, let me introduce my self. My name is Radek Smogura, and for 10 year I work as developer, mainly Java and I know C and C++. I would like to join Swift community and work on Swift language. Previously for hobby I  added properties syntax to it and full closure support (you can find it here https://bitbucket.org/radoslaw_smogura/java-closures-silver-jdk9-langtools/wiki/Home).<br>&gt;&gt; <br>&gt;&gt; I would like to propose custom attributes support, as it would make Swift more robust language, by allowing dependency injection and managed objects (ie. for Core Data or some trivial example like defining JSON structures for REST). I would as well to contribute to this feature to Swift language if possible as fork or branch.<br>&gt; <br>&gt; Custom attributes are an interesting direction that already came up on<br>&gt; this list, but there was no concrete proposal with syntax and<br>&gt; semantics.  Before you spend time implementing something extensive, I<br>&gt; would strongly recommend you to float the idea on swift-evolution, and<br>&gt; follow-up with a formal proposal if there is consensus.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 26, 2015 at 04:00:00pm</p></header><div class="content"><p>On Sat, Dec 26, 2015 at 3:59 PM, Radosław Smogura &lt;rsmogura at icloud.com&gt; wrote:<br>&gt; So,<br>&gt;<br>&gt; What do you think about syntax like this:<br>&gt;<br>&gt; // Declaration<br>&gt; @AttributeUsage(RUNTIME) //Can be SOURCE - attribute not emitted into binary<br>&gt; @AttributeTarget(PROPERTY) //Other CLASS, ENUM, METHOD, INIT<br>&gt; @attribute JSONProperty {<br>&gt; var name:String!;<br>&gt; var serializable:Bool? = true;<br>&gt; var deserializable:Bool? = true;<br>&gt; }<br></p><p>Is this a new declaration kind?  Do you think we could make it work<br>with existing language constructs instead, like structs?  Any<br>downsides to that?<br></p><p>&gt; // Usage<br>&gt; @JSONProperty(name=“id”)<br>&gt; var id:Int;<br>&gt;<br>&gt;<br>&gt; Attributes should be module aware (actual attributes should be redefined as Swift attribute, for beginning still can be hardcoded).<br></p><p>Sorry, I&#39;m not sure what this means.<br></p><p>&gt; The attribute’s name have to be unique in module. It’s compile time error if attribute, class, enum, struct, etc has same name.<br>&gt;<br>&gt; Attribute’s properties are read only and can’t be assigned - so during reflection no-one would change ‘shared’ values.<br></p><p>I think using structs and requiring that attributes are value types<br>would solve both issues.<br></p><p>&gt; Attribute’s properties can only support basic types: primitives, strings, types, and other attributes (optional).<br></p><p>Well, there is no such thing as &quot;basic types&quot; in Swift.  Strings,<br>integers etc. are defined in the standard library and the compiler<br>does not know anything special about them.<br></p><p>&gt; When declaring attributes, properties can be set to constant values (static let) or enum values, however the final value is stored in binary, not a reference to it.<br></p><p>Again, given that strings are defined in the standard library, and<br>that the language does not have a notion of a constant expression, I&#39;m<br>not sure how this would work.  I&#39;m not saying it can&#39;t, I&#39;m just<br>saying you need to introduce a lot of new language concepts and<br>compiler machinery.<br></p><p>&gt; The compiler has build in support for core attributes, which can affect code generation. Compiler may perform additional checks on core attributes.<br></p><p>OK.<br></p><p>Another question is, how would you inspect attributes at runtime?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Adding custom attributes</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 26, 2015 at 03:00:00pm</p></header><div class="content"><p>Maybe we could implement a template system like C++<br></p><p>On Sat, Dec 26, 2015 at 3:20 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Sat, Dec 26, 2015 at 3:59 PM, Radosław Smogura &lt;rsmogura at icloud.com&gt;<br>&gt; wrote:<br>&gt; &gt; So,<br>&gt; &gt;<br>&gt; &gt; What do you think about syntax like this:<br>&gt; &gt;<br>&gt; &gt; // Declaration<br>&gt; &gt; @AttributeUsage(RUNTIME) //Can be SOURCE - attribute not emitted into<br>&gt; binary<br>&gt; &gt; @AttributeTarget(PROPERTY) //Other CLASS, ENUM, METHOD, INIT<br>&gt; &gt; @attribute JSONProperty {<br>&gt; &gt; var name:String!;<br>&gt; &gt; var serializable:Bool? = true;<br>&gt; &gt; var deserializable:Bool? = true;<br>&gt; &gt; }<br>&gt;<br>&gt; Is this a new declaration kind?  Do you think we could make it work<br>&gt; with existing language constructs instead, like structs?  Any<br>&gt; downsides to that?<br>&gt;<br>&gt; &gt; // Usage<br>&gt; &gt; @JSONProperty(name=“id”)<br>&gt; &gt; var id:Int;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Attributes should be module aware (actual attributes should be redefined<br>&gt; as Swift attribute, for beginning still can be hardcoded).<br>&gt;<br>&gt; Sorry, I&#39;m not sure what this means.<br>&gt;<br>&gt; &gt; The attribute’s name have to be unique in module. It’s compile time<br>&gt; error if attribute, class, enum, struct, etc has same name.<br>&gt; &gt;<br>&gt; &gt; Attribute’s properties are read only and can’t be assigned - so during<br>&gt; reflection no-one would change ‘shared’ values.<br>&gt;<br>&gt; I think using structs and requiring that attributes are value types<br>&gt; would solve both issues.<br>&gt;<br>&gt; &gt; Attribute’s properties can only support basic types: primitives,<br>&gt; strings, types, and other attributes (optional).<br>&gt;<br>&gt; Well, there is no such thing as &quot;basic types&quot; in Swift.  Strings,<br>&gt; integers etc. are defined in the standard library and the compiler<br>&gt; does not know anything special about them.<br>&gt;<br>&gt; &gt; When declaring attributes, properties can be set to constant values<br>&gt; (static let) or enum values, however the final value is stored in binary,<br>&gt; not a reference to it.<br>&gt;<br>&gt; Again, given that strings are defined in the standard library, and<br>&gt; that the language does not have a notion of a constant expression, I&#39;m<br>&gt; not sure how this would work.  I&#39;m not saying it can&#39;t, I&#39;m just<br>&gt; saying you need to introduce a lot of new language concepts and<br>&gt; compiler machinery.<br>&gt;<br>&gt; &gt; The compiler has build in support for core attributes, which can affect<br>&gt; code generation. Compiler may perform additional checks on core attributes.<br>&gt;<br>&gt; OK.<br>&gt;<br>&gt; Another question is, how would you inspect attributes at runtime?<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/74338c36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 26, 2015 at 04:00:00pm</p></header><div class="content"><p>On Sat, Dec 26, 2015 at 4:24 PM, James Campbell &lt;james at supmenow.com&gt; wrote:<br>&gt; Maybe we could implement a template system like C++<br></p><p>Sorry, it is not clear what you&#39;re hinting at, please elaborate.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0b06da9d5d4edede8590235c6dcae64?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Radosław Smogura</string> &lt;rsmogura at icloud.com&gt;<p>December 26, 2015 at 07:00:00pm</p></header><div class="content"><p>Hi Dimitir,<br></p><p>Thanks for your questions, as you pointed me to deeper considerations and better description of idea.<br></p><p>&gt; On 26 Dec 2015, at 16:20, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sat, Dec 26, 2015 at 3:59 PM, Radosław Smogura &lt;rsmogura at icloud.com&gt; wrote:<br>&gt;&gt; So,<br>&gt;&gt; <br>&gt;&gt; What do you think about syntax like this:<br>&gt;&gt; <br>&gt;&gt; // Declaration<br>&gt;&gt; @AttributeUsage(RUNTIME) //Can be SOURCE - attribute not emitted into binary<br>&gt;&gt; @AttributeTarget(PROPERTY) //Other CLASS, ENUM, METHOD, INIT<br>&gt;&gt; @attribute JSONProperty {<br>&gt;&gt; var name:String!;<br>&gt;&gt; var serializable:Bool? = true;<br>&gt;&gt; var deserializable:Bool? = true;<br>&gt;&gt; }<br>&gt; <br>&gt; Is this a new declaration kind?  Do you think we could make it work<br>&gt; with existing language constructs instead, like structs?  Any<br>&gt; downsides to that?<br>It’s really good concern and I have to describe attribute concept in more details. The _implementation_ of attributes would and should use existing constructs like structs or classes - I prefer classes as it will allow attributes to subclass some common class (Attribute?), so in future new functionality can be added.<br></p><p>Let’s consider attributes, and marking struct with @Attrbute.<br></p><p>On runtime attributes will be passed as references or value objects (just to keep contract programming) and assignment to attribute properties should be prohibited:<br>- if attribute is bound to type, than attribute would be nothing more than extension of static context of that type,<br>- it’s error prone for developers, as someone could change i.e. JSON property name.<br></p><p>Attributes are metadata, and do not require methods (however methods could be interesting and innovative addition). So attribute’s properties should be declared with let, instead of var, to prevent modification of those, but from other hand we would like to set default values for some properties, I just think that declaration like this would be confusing:<br>@Attribute<br>struct JSONProperty {<br>/* … */<br>let deserializable:Bool? = true;<br>}<br></p><p>Additionally having attributes as a new construct will give us more flexibility on changing syntax and adding new features in future.<br></p><p>I think this implies that attribute can’t be considered as struct (on language level), and should be treated as new language construct.<br></p><p>&gt;&gt; // Usage<br>&gt;&gt; @JSONProperty(name=“id”)<br>&gt;&gt; var id:Int;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Attributes should be module aware (actual attributes should be redefined as Swift attribute, for beginning still can be hardcoded).<br>&gt; <br>&gt; Sorry, I&#39;m not sure what this means.<br>Attributes should be in module. So modules can define attributes with same name. Right now attributes are global.<br>&gt; <br>&gt;&gt; The attribute’s name have to be unique in module. It’s compile time error if attribute, class, enum, struct, etc has same name.<br>&gt;&gt; <br>&gt;&gt; Attribute’s properties are read only and can’t be assigned - so during reflection no-one would change ‘shared’ values.<br>&gt; <br>&gt; I think using structs and requiring that attributes are value types<br>&gt; would solve both issues.<br>I think attributes should be treated as new language construct, regardless how those will be implemented on runtime - it can be struct or class.<br></p><p>&gt;&gt; Attribute’s properties can only support basic types: primitives, strings, types, and other attributes (optional).<br>&gt; <br>&gt; Well, there is no such thing as &quot;basic types&quot; in Swift.  Strings,<br>&gt; integers etc. are defined in the standard library and the compiler<br>&gt; does not know anything special about them.<br>By basic type I meant a types which can be serialised to format which will not change in future. Numbers, strings, type names, arrays of those can be stored in binaries without risks of backward incompatibility, objects and structs are more fragile. I think next answer will clarify more.<br></p><p>&gt;&gt; When declaring attributes, properties can be set to constant values (static let) or enum values, however the final value is stored in binary, not a reference to it.<br>&gt; <br>&gt; Again, given that strings are defined in the standard library, and<br>&gt; that the language does not have a notion of a constant expression, I&#39;m<br>&gt; not sure how this would work.  I&#39;m not saying it can&#39;t, I&#39;m just<br>&gt; saying you need to introduce a lot of new language concepts and<br>&gt; compiler machinery.<br>It’s another good question. By const I mean virtual concept of static let declaration. My motivation is to keep attributes as static metadata.<br></p><p>Let’s consider three levels of attributes:<br>- source - those attributes are present only in source file and are not put in binary, such attributes can be used to mark pieces of code for external tools like visual UI designers, UMLs, etc<br>- compile - those attributes are present in output binary, but have not meaning on runtime - ie. @Deprecated,<br>- runtime - those attributes are present on runtime, and can be inspected by libraries to affect execution, ie.: @JSONProperty, @NSManaged<br></p><p>My other concern is related to attribute storage (let’s skip implementation of this). Suppose you want to centralise some values, ie. messages with following pice of code<br>CommonMessages {<br>	static var genericError = “Something went wrong :(“<br>}<br></p><p>And you want to bound a property to message when validation fails.<br>@ValidationMessage(message=CommonMessages.genericError)<br>var id:Int;<br></p><p>- For runtime referencing variables can be confusing, as some one seeing above notion can think that changing genericError will change message on runtime (annotations are static, so it will not work),<br>- For compilation level attributes compiler has limited possibilities to evaluate what genericMessage is, as there is no application runtime (it will be compiled), so only simple traversals through source can be performed. Even for const it can be hard right now.<br></p><p>The other question arises here, suppose CommonMessages are in external library,. What should happen if it changes, should a genericError be referenced or it’s value copied and stored in binary? Referencing could be quite interesting topic.<br></p><p>We can consider allowing simple or more complicated expressions in attribute properties<br>@Size(width=20+50+sqrt(12))<br>As long as those refer static context.<br></p><p>&gt;&gt; The compiler has build in support for core attributes, which can affect code generation. Compiler may perform additional checks on core attributes.<br>&gt; <br>&gt; OK.<br>&gt; <br>&gt; Another question is, how would you inspect attributes at runtime?<br>I would like to focus on syntax, semantic and parsing. This will require answering question how to store attributes (and I would like to move this to separate chain, as it will be long discussion). From the other hand, some questions still should be answered, ie.<br></p><p>How attribute should behave in such a case:<br>@ValidationMessage(message=CommonMessages.genericError)<br>var id:Int;<br></p><p>Should genericValue be copied or referenced (see above consideration), this implies what and how to store.<br></p><p>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e87ccf25bba85b734471a74329b2ae8c?s=50"></div><header><strong>Adding custom attributes</strong> from <string>JOSE MARIA GOMEZ CAMA</string> &lt;jm.gomez at ub.edu&gt;<p>December 26, 2015 at 06:00:00pm</p></header><div class="content"><p>Dear all,<br></p><p>Let me answer inlined.<br></p><p>&gt; El 26/12/2015, a las 19:15, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br>&gt;<br>&gt; Hi Dimitir,<br>&gt;<br>&gt; Thanks for your questions, as you pointed me to deeper considerations and better description of idea.<br>&gt;<br>&gt;&gt; On 26 Dec 2015, at 16:20, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Sat, Dec 26, 2015 at 3:59 PM, Radosław Smogura &lt;rsmogura at icloud.com&gt; wrote:<br>&gt;&gt;&gt; So,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What do you think about syntax like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Declaration<br>&gt;&gt;&gt; @AttributeUsage(RUNTIME) //Can be SOURCE - attribute not emitted into binary<br>&gt;&gt;&gt; @AttributeTarget(PROPERTY) //Other CLASS, ENUM, METHOD, INIT<br>&gt;&gt;&gt; @attribute JSONProperty {<br>&gt;&gt;&gt; var name:String!;<br>&gt;&gt;&gt; var serializable:Bool? = true;<br>&gt;&gt;&gt; var deserializable:Bool? = true;<br>&gt;&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Is this a new declaration kind?  Do you think we could make it work<br>&gt;&gt; with existing language constructs instead, like structs?  Any<br>&gt;&gt; downsides to that?<br>&gt; It’s really good concern and I have to describe attribute concept in more details. The _implementation_ of attributes would and should use existing constructs like structs or classes - I prefer classes as it will allow attributes to subclass some common class (Attribute?), so in future new functionality can be added.<br>&gt;<br>&gt; Let’s consider attributes, and marking struct with @Attrbute.<br>&gt;<br>&gt; On runtime attributes will be passed as references or value objects (just to keep contract programming) and assignment to attribute properties should be prohibited:<br>&gt; - if attribute is bound to type, than attribute would be nothing more than extension of static context of that type,<br>&gt; - it’s error prone for developers, as someone could change i.e. JSON property name.<br>&gt;<br>&gt; Attributes are metadata, and do not require methods (however methods could be interesting and innovative addition). So attribute’s properties should be declared with let, instead of var, to prevent modification of those, but from other hand we would like to set default values for some properties, I just think that declaration like this would be confusing:<br>&gt; @Attribute<br>&gt; struct JSONProperty {<br>&gt; /* … */<br>&gt; let deserializable:Bool? = true;<br>&gt; }<br>&gt;<br>&gt; Additionally having attributes as a new construct will give us more flexibility on changing syntax and adding new features in future.<br>&gt;<br>&gt; I think this implies that attribute can’t be considered as struct (on language level), and should be treated as new language construct.<br></p><p>I do not agree that attributes should only provide metadata. I think they shall also provide means, like in Java or Python, to modify the behavior in runtime. For this, mirroring would be needed.<br></p><p>&gt;&gt;&gt; // Usage<br>&gt;&gt;&gt; @JSONProperty(name=“id”)<br>&gt;&gt;&gt; var id:Int;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Attributes should be module aware (actual attributes should be redefined as Swift attribute, for beginning still can be hardcoded).<br>&gt;&gt;<br>&gt;&gt; Sorry, I&#39;m not sure what this means.<br>&gt; Attributes should be in module. So modules can define attributes with same name. Right now attributes are global.<br>&gt;&gt;<br>&gt;&gt;&gt; The attribute’s name have to be unique in module. It’s compile time error if attribute, class, enum, struct, etc has same name.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Attribute’s properties are read only and can’t be assigned - so during reflection no-one would change ‘shared’ values.<br>&gt;&gt;<br>&gt;&gt; I think using structs and requiring that attributes are value types<br>&gt;&gt; would solve both issues.<br>&gt; I think attributes should be treated as new language construct, regardless how those will be implemented on runtime - it can be struct or class.<br></p><p>I do not see why it should be a new construct, in Java it is, but in case of Python it is not. Another option would be to define the attribute @attribute that would identify a class or a struct as an attribute.<br></p><p>&gt;&gt;&gt; Attribute’s properties can only support basic types: primitives, strings, types, and other attributes (optional).<br>&gt;&gt;<br>&gt;&gt; Well, there is no such thing as &quot;basic types&quot; in Swift.  Strings,<br>&gt;&gt; integers etc. are defined in the standard library and the compiler<br>&gt;&gt; does not know anything special about them.<br>&gt; By basic type I meant a types which can be serialised to format which will not change in future. Numbers, strings, type names, arrays of those can be stored in binaries without risks of backward incompatibility, objects and structs are more fragile. I think next answer will clarify more.<br></p><p>I think this is always the case when you have a compiled language, you always store information as a binary when you have a library.<br></p><p>&gt;&gt;&gt; When declaring attributes, properties can be set to constant values (static let) or enum values, however the final value is stored in binary, not a reference to it.<br>&gt;&gt;<br>&gt;&gt; Again, given that strings are defined in the standard library, and<br>&gt;&gt; that the language does not have a notion of a constant expression, I&#39;m<br>&gt;&gt; not sure how this would work.  I&#39;m not saying it can&#39;t, I&#39;m just<br>&gt;&gt; saying you need to introduce a lot of new language concepts and<br>&gt;&gt; compiler machinery.<br>&gt; It’s another good question. By const I mean virtual concept of static let declaration. My motivation is to keep attributes as static metadata.<br>&gt;<br>&gt; Let’s consider three levels of attributes:<br>&gt; - source - those attributes are present only in source file and are not put in binary, such attributes can be used to mark pieces of code for external tools like visual UI designers, UMLs, etc<br>&gt; - compile - those attributes are present in output binary, but have not meaning on runtime - ie. @Deprecated,<br>&gt; - runtime - those attributes are present on runtime, and can be inspected by libraries to affect execution, ie.: @JSONProperty, @NSManaged<br>&gt;<br>&gt; My other concern is related to attribute storage (let’s skip implementation of this). Suppose you want to centralise some values, ie. messages with following pice of code<br>&gt; CommonMessages {<br>&gt;       static var genericError = “Something went wrong :(“<br>&gt; }<br>&gt;<br>&gt; And you want to bound a property to message when validation fails.<br>&gt; @ValidationMessage(message=CommonMessages.genericError)<br>&gt; var id:Int;<br>&gt;<br>&gt; - For runtime referencing variables can be confusing, as some one seeing above notion can think that changing genericError will change message on runtime (annotations are static, so it will not work),<br>&gt; - For compilation level attributes compiler has limited possibilities to evaluate what genericMessage is, as there is no application runtime (it will be compiled), so only simple traversals through source can be performed. Even for const it can be hard right now.<br>&gt;<br>&gt; The other question arises here, suppose CommonMessages are in external library,. What should happen if it changes, should a genericError be referenced or it’s value copied and stored in binary? Referencing could be quite interesting topic.<br>&gt;<br>&gt; We can consider allowing simple or more complicated expressions in attribute properties<br>&gt; @Size(width=20+50+sqrt(12))<br>&gt; As long as those refer static context.<br>&gt;<br>&gt;&gt;&gt; The compiler has build in support for core attributes, which can affect code generation. Compiler may perform additional checks on core attributes.<br>&gt;&gt;<br>&gt;&gt; OK.<br>&gt;&gt;<br>&gt;&gt; Another question is, how would you inspect attributes at runtime?<br>&gt; I would like to focus on syntax, semantic and parsing. This will require answering question how to store attributes (and I would like to move this to separate chain, as it will be long discussion). From the other hand, some questions still should be answered, ie.<br>&gt;<br>&gt; How attribute should behave in such a case:<br>&gt; @ValidationMessage(message=CommonMessages.genericError)<br>&gt; var id:Int;<br>&gt;<br>&gt; Should genericValue be copied or referenced (see above consideration), this implies what and how to store.<br></p><p>Probably, in this case it would be good to have a look on Java annotations. This can provide some hints on how to store the compiled information.<br></p><p>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Aquest correu electrònic i els annexos poden contenir informació confidencial o protegida legalment i està adreçat exclusivament a la persona o entitat destinatària. Si no sou el destinatari final o la persona encarregada de rebre’l, no esteu autoritzat a llegir-lo, retenir-lo, modificar-lo, distribuir-lo, copiar-lo ni a revelar-ne el contingut. Si heu rebut aquest correu electrònic per error, us preguem que n’informeu al remitent i que elimineu del sistema el missatge i el material annex que pugui contenir. Gràcies per la vostra col·laboració.<br></p><p>Este correo electrónico y sus anexos pueden contener información confidencial o legalmente protegida y está exclusivamente dirigido a la persona o entidad destinataria. Si usted no es el destinatario final o la persona encargada de recibirlo, no está autorizado a leerlo, retenerlo, modificarlo, distribuirlo, copiarlo ni a revelar su contenido. Si ha recibido este mensaje electrónico por error, le rogamos que informe al remitente y elimine del sistema el mensaje y el material anexo que pueda contener. Gracias por su colaboración.<br></p><p>This email message and any documents attached to it may contain confidential or legally protected material and are intended solely for the use of the individual or organization to whom they are addressed. We remind you that if you are not the intended recipient of this email message or the person responsible for processing it, then you are not authorized to read, save, modify, send, copy or disclose any of its contents. If you have received this email message by mistake, we kindly ask you to inform the sender of this and to eliminate both the message and any attachments it carries from your account. Thank you for your collaboration.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 26, 2015 at 02:00:00pm</p></header><div class="content"><p>Consider reading the Property Behaviors &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003148.html&gt; proposal, as attributes overlap with it. (Warning: loooooooong thread)<br></p><p>Félix<br></p><p>&gt; Le 26 déc. 2015 à 13:57:04, JOSE MARIA GOMEZ CAMA via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Dear all,<br>&gt; <br>&gt; Let me answer inlined.<br>&gt; <br>&gt;&gt; El 26/12/2015, a las 19:15, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br>&gt;&gt; <br>&gt;&gt; Hi Dimitir,<br>&gt;&gt; <br>&gt;&gt; Thanks for your questions, as you pointed me to deeper considerations and better description of idea.<br>&gt;&gt; <br>&gt;&gt;&gt; On 26 Dec 2015, at 16:20, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Dec 26, 2015 at 3:59 PM, Radosław Smogura &lt;rsmogura at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; So,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think about syntax like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Declaration<br>&gt;&gt;&gt;&gt; @AttributeUsage(RUNTIME) //Can be SOURCE - attribute not emitted into binary<br>&gt;&gt;&gt;&gt; @AttributeTarget(PROPERTY) //Other CLASS, ENUM, METHOD, INIT<br>&gt;&gt;&gt;&gt; @attribute JSONProperty {<br>&gt;&gt;&gt;&gt; var name:String!;<br>&gt;&gt;&gt;&gt; var serializable:Bool? = true;<br>&gt;&gt;&gt;&gt; var deserializable:Bool? = true;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this a new declaration kind?  Do you think we could make it work<br>&gt;&gt;&gt; with existing language constructs instead, like structs?  Any<br>&gt;&gt;&gt; downsides to that?<br>&gt;&gt; It’s really good concern and I have to describe attribute concept in more details. The _implementation_ of attributes would and should use existing constructs like structs or classes - I prefer classes as it will allow attributes to subclass some common class (Attribute?), so in future new functionality can be added.<br>&gt;&gt; <br>&gt;&gt; Let’s consider attributes, and marking struct with @Attrbute.<br>&gt;&gt; <br>&gt;&gt; On runtime attributes will be passed as references or value objects (just to keep contract programming) and assignment to attribute properties should be prohibited:<br>&gt;&gt; - if attribute is bound to type, than attribute would be nothing more than extension of static context of that type,<br>&gt;&gt; - it’s error prone for developers, as someone could change i.e. JSON property name.<br>&gt;&gt; <br>&gt;&gt; Attributes are metadata, and do not require methods (however methods could be interesting and innovative addition). So attribute’s properties should be declared with let, instead of var, to prevent modification of those, but from other hand we would like to set default values for some properties, I just think that declaration like this would be confusing:<br>&gt;&gt; @Attribute<br>&gt;&gt; struct JSONProperty {<br>&gt;&gt; /* … */<br>&gt;&gt; let deserializable:Bool? = true;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Additionally having attributes as a new construct will give us more flexibility on changing syntax and adding new features in future.<br>&gt;&gt; <br>&gt;&gt; I think this implies that attribute can’t be considered as struct (on language level), and should be treated as new language construct.<br>&gt; <br>&gt; I do not agree that attributes should only provide metadata. I think they shall also provide means, like in Java or Python, to modify the behavior in runtime. For this, mirroring would be needed.<br>&gt; <br>&gt;&gt;&gt;&gt; // Usage<br>&gt;&gt;&gt;&gt; @JSONProperty(name=“id”)<br>&gt;&gt;&gt;&gt; var id:Int;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Attributes should be module aware (actual attributes should be redefined as Swift attribute, for beginning still can be hardcoded).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I&#39;m not sure what this means.<br>&gt;&gt; Attributes should be in module. So modules can define attributes with same name. Right now attributes are global.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The attribute’s name have to be unique in module. It’s compile time error if attribute, class, enum, struct, etc has same name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Attribute’s properties are read only and can’t be assigned - so during reflection no-one would change ‘shared’ values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think using structs and requiring that attributes are value types<br>&gt;&gt;&gt; would solve both issues.<br>&gt;&gt; I think attributes should be treated as new language construct, regardless how those will be implemented on runtime - it can be struct or class.<br>&gt; <br>&gt; I do not see why it should be a new construct, in Java it is, but in case of Python it is not. Another option would be to define the attribute @attribute that would identify a class or a struct as an attribute.<br>&gt; <br>&gt;&gt;&gt;&gt; Attribute’s properties can only support basic types: primitives, strings, types, and other attributes (optional).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, there is no such thing as &quot;basic types&quot; in Swift.  Strings,<br>&gt;&gt;&gt; integers etc. are defined in the standard library and the compiler<br>&gt;&gt;&gt; does not know anything special about them.<br>&gt;&gt; By basic type I meant a types which can be serialised to format which will not change in future. Numbers, strings, type names, arrays of those can be stored in binaries without risks of backward incompatibility, objects and structs are more fragile. I think next answer will clarify more.<br>&gt; <br>&gt; I think this is always the case when you have a compiled language, you always store information as a binary when you have a library.<br>&gt; <br>&gt;&gt;&gt;&gt; When declaring attributes, properties can be set to constant values (static let) or enum values, however the final value is stored in binary, not a reference to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, given that strings are defined in the standard library, and<br>&gt;&gt;&gt; that the language does not have a notion of a constant expression, I&#39;m<br>&gt;&gt;&gt; not sure how this would work.  I&#39;m not saying it can&#39;t, I&#39;m just<br>&gt;&gt;&gt; saying you need to introduce a lot of new language concepts and<br>&gt;&gt;&gt; compiler machinery.<br>&gt;&gt; It’s another good question. By const I mean virtual concept of static let declaration. My motivation is to keep attributes as static metadata.<br>&gt;&gt; <br>&gt;&gt; Let’s consider three levels of attributes:<br>&gt;&gt; - source - those attributes are present only in source file and are not put in binary, such attributes can be used to mark pieces of code for external tools like visual UI designers, UMLs, etc<br>&gt;&gt; - compile - those attributes are present in output binary, but have not meaning on runtime - ie. @Deprecated,<br>&gt;&gt; - runtime - those attributes are present on runtime, and can be inspected by libraries to affect execution, ie.: @JSONProperty, @NSManaged<br>&gt;&gt; <br>&gt;&gt; My other concern is related to attribute storage (let’s skip implementation of this). Suppose you want to centralise some values, ie. messages with following pice of code<br>&gt;&gt; CommonMessages {<br>&gt;&gt;      static var genericError = “Something went wrong :(“<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And you want to bound a property to message when validation fails.<br>&gt;&gt; @ValidationMessage(message=CommonMessages.genericError)<br>&gt;&gt; var id:Int;<br>&gt;&gt; <br>&gt;&gt; - For runtime referencing variables can be confusing, as some one seeing above notion can think that changing genericError will change message on runtime (annotations are static, so it will not work),<br>&gt;&gt; - For compilation level attributes compiler has limited possibilities to evaluate what genericMessage is, as there is no application runtime (it will be compiled), so only simple traversals through source can be performed. Even for const it can be hard right now.<br>&gt;&gt; <br>&gt;&gt; The other question arises here, suppose CommonMessages are in external library,. What should happen if it changes, should a genericError be referenced or it’s value copied and stored in binary? Referencing could be quite interesting topic.<br>&gt;&gt; <br>&gt;&gt; We can consider allowing simple or more complicated expressions in attribute properties<br>&gt;&gt; @Size(width=20+50+sqrt(12))<br>&gt;&gt; As long as those refer static context.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler has build in support for core attributes, which can affect code generation. Compiler may perform additional checks on core attributes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; OK.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another question is, how would you inspect attributes at runtime?<br>&gt;&gt; I would like to focus on syntax, semantic and parsing. This will require answering question how to store attributes (and I would like to move this to separate chain, as it will be long discussion). From the other hand, some questions still should be answered, ie.<br>&gt;&gt; <br>&gt;&gt; How attribute should behave in such a case:<br>&gt;&gt; @ValidationMessage(message=CommonMessages.genericError)<br>&gt;&gt; var id:Int;<br>&gt;&gt; <br>&gt;&gt; Should genericValue be copied or referenced (see above consideration), this implies what and how to store.<br>&gt; <br>&gt; Probably, in this case it would be good to have a look on Java annotations. This can provide some hints on how to store the compiled information.<br>&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; Aquest correu electrònic i els annexos poden contenir informació confidencial o protegida legalment i està adreçat exclusivament a la persona o entitat destinatària. Si no sou el destinatari final o la persona encarregada de rebre’l, no esteu autoritzat a llegir-lo, retenir-lo, modificar-lo, distribuir-lo, copiar-lo ni a revelar-ne el contingut. Si heu rebut aquest correu electrònic per error, us preguem que n’informeu al remitent i que elimineu del sistema el missatge i el material annex que pugui contenir. Gràcies per la vostra col·laboració.<br>&gt; <br>&gt; Este correo electrónico y sus anexos pueden contener información confidencial o legalmente protegida y está exclusivamente dirigido a la persona o entidad destinataria. Si usted no es el destinatario final o la persona encargada de recibirlo, no está autorizado a leerlo, retenerlo, modificarlo, distribuirlo, copiarlo ni a revelar su contenido. Si ha recibido este mensaje electrónico por error, le rogamos que informe al remitente y elimine del sistema el mensaje y el material anexo que pueda contener. Gracias por su colaboración.<br>&gt; <br>&gt; This email message and any documents attached to it may contain confidential or legally protected material and are intended solely for the use of the individual or organization to whom they are addressed. We remind you that if you are not the intended recipient of this email message or the person responsible for processing it, then you are not authorized to read, save, modify, send, copy or disclose any of its contents. If you have received this email message by mistake, we kindly ask you to inform the sender of this and to eliminate both the message and any attachments it carries from your account. Thank you for your collaboration.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/86432cb3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0b06da9d5d4edede8590235c6dcae64?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Radosław Smogura</string> &lt;rsmogura at icloud.com&gt;<p>December 26, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On 26 Dec 2015, at 19:57, JOSE MARIA GOMEZ CAMA &lt;jm.gomez at ub.edu&gt; wrote:<br>&gt; <br>&gt; Dear all,<br>&gt; <br>&gt; Let me answer inlined.<br>&gt; <br>&gt;&gt; El 26/12/2015, a las 19:15, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br>&gt;&gt; <br>&gt;&gt; Hi Dimitir,<br>&gt;&gt; <br>&gt;&gt; Thanks for your questions, as you pointed me to deeper considerations and better description of idea.<br>&gt;&gt; <br>&gt;&gt;&gt; On 26 Dec 2015, at 16:20, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Dec 26, 2015 at 3:59 PM, Radosław Smogura &lt;rsmogura at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; So,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think about syntax like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Declaration<br>&gt;&gt;&gt;&gt; @AttributeUsage(RUNTIME) //Can be SOURCE - attribute not emitted into binary<br>&gt;&gt;&gt;&gt; @AttributeTarget(PROPERTY) //Other CLASS, ENUM, METHOD, INIT<br>&gt;&gt;&gt;&gt; @attribute JSONProperty {<br>&gt;&gt;&gt;&gt; var name:String!;<br>&gt;&gt;&gt;&gt; var serializable:Bool? = true;<br>&gt;&gt;&gt;&gt; var deserializable:Bool? = true;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this a new declaration kind?  Do you think we could make it work<br>&gt;&gt;&gt; with existing language constructs instead, like structs?  Any<br>&gt;&gt;&gt; downsides to that?<br>&gt;&gt; It’s really good concern and I have to describe attribute concept in more details. The _implementation_ of attributes would and should use existing constructs like structs or classes - I prefer classes as it will allow attributes to subclass some common class (Attribute?), so in future new functionality can be added.<br>&gt;&gt; <br>&gt;&gt; Let’s consider attributes, and marking struct with @Attrbute.<br>&gt;&gt; <br>&gt;&gt; On runtime attributes will be passed as references or value objects (just to keep contract programming) and assignment to attribute properties should be prohibited:<br>&gt;&gt; - if attribute is bound to type, than attribute would be nothing more than extension of static context of that type,<br>&gt;&gt; - it’s error prone for developers, as someone could change i.e. JSON property name.<br>&gt;&gt; <br>&gt;&gt; Attributes are metadata, and do not require methods (however methods could be interesting and innovative addition). So attribute’s properties should be declared with let, instead of var, to prevent modification of those, but from other hand we would like to set default values for some properties, I just think that declaration like this would be confusing:<br>&gt;&gt; @Attribute<br>&gt;&gt; struct JSONProperty {<br>&gt;&gt; /* … */<br>&gt;&gt; let deserializable:Bool? = true;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Additionally having attributes as a new construct will give us more flexibility on changing syntax and adding new features in future.<br>&gt;&gt; <br>&gt;&gt; I think this implies that attribute can’t be considered as struct (on language level), and should be treated as new language construct.<br>&gt; <br>&gt; I do not agree that attributes should only provide metadata. I think they shall also provide means, like in Java or Python, to modify the behavior in runtime. For this, mirroring would be needed.<br>My bad, I think I unnesessary  used a word ‘metadata’ word. It may be confusing.<br></p><p>You are right it is something we would like to achieve, but attribute alone is disconnected from mean. Mean (with some exceptions), similar like in Java, should be defined by library / container which inspects annotations on given object. <br></p><p>&gt; <br>&gt;&gt;&gt;&gt; // Usage<br>&gt;&gt;&gt;&gt; @JSONProperty(name=“id”)<br>&gt;&gt;&gt;&gt; var id:Int;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Attributes should be module aware (actual attributes should be redefined as Swift attribute, for beginning still can be hardcoded).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I&#39;m not sure what this means.<br>&gt;&gt; Attributes should be in module. So modules can define attributes with same name. Right now attributes are global.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The attribute’s name have to be unique in module. It’s compile time error if attribute, class, enum, struct, etc has same name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Attribute’s properties are read only and can’t be assigned - so during reflection no-one would change ‘shared’ values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think using structs and requiring that attributes are value types<br>&gt;&gt;&gt; would solve both issues.<br>&gt;&gt; I think attributes should be treated as new language construct, regardless how those will be implemented on runtime - it can be struct or class.<br>&gt; <br>&gt; I do not see why it should be a new construct, in Java it is, but in case of Python it is not. Another option would be to define the attribute @attribute that would identify a class or a struct as an attribute.<br>&gt; <br>&gt;&gt;&gt;&gt; Attribute’s properties can only support basic types: primitives, strings, types, and other attributes (optional).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, there is no such thing as &quot;basic types&quot; in Swift.  Strings,<br>&gt;&gt;&gt; integers etc. are defined in the standard library and the compiler<br>&gt;&gt;&gt; does not know anything special about them.<br>&gt;&gt; By basic type I meant a types which can be serialised to format which will not change in future. Numbers, strings, type names, arrays of those can be stored in binaries without risks of backward incompatibility, objects and structs are more fragile. I think next answer will clarify more.<br>&gt; <br>&gt; I think this is always the case when you have a compiled language, you always store information as a binary when you have a library.<br>I wanted to explain different topic here. In generally representation of primitive types do not change over time, which is in oposition to composite types where properties can be added or removed or it order can be changed. <br></p><p>&gt;&gt;&gt;&gt; When declaring attributes, properties can be set to constant values (static let) or enum values, however the final value is stored in binary, not a reference to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, given that strings are defined in the standard library, and<br>&gt;&gt;&gt; that the language does not have a notion of a constant expression, I&#39;m<br>&gt;&gt;&gt; not sure how this would work.  I&#39;m not saying it can&#39;t, I&#39;m just<br>&gt;&gt;&gt; saying you need to introduce a lot of new language concepts and<br>&gt;&gt;&gt; compiler machinery.<br>&gt;&gt; It’s another good question. By const I mean virtual concept of static let declaration. My motivation is to keep attributes as static metadata.<br>&gt;&gt; <br>&gt;&gt; Let’s consider three levels of attributes:<br>&gt;&gt; - source - those attributes are present only in source file and are not put in binary, such attributes can be used to mark pieces of code for external tools like visual UI designers, UMLs, etc<br>&gt;&gt; - compile - those attributes are present in output binary, but have not meaning on runtime - ie. @Deprecated,<br>&gt;&gt; - runtime - those attributes are present on runtime, and can be inspected by libraries to affect execution, ie.: @JSONProperty, @NSManaged<br>&gt;&gt; <br>&gt;&gt; My other concern is related to attribute storage (let’s skip implementation of this). Suppose you want to centralise some values, ie. messages with following pice of code<br>&gt;&gt; CommonMessages {<br>&gt;&gt;      static var genericError = “Something went wrong :(“<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And you want to bound a property to message when validation fails.<br>&gt;&gt; @ValidationMessage(message=CommonMessages.genericError)<br>&gt;&gt; var id:Int;<br>&gt;&gt; <br>&gt;&gt; - For runtime referencing variables can be confusing, as some one seeing above notion can think that changing genericError will change message on runtime (annotations are static, so it will not work),<br>&gt;&gt; - For compilation level attributes compiler has limited possibilities to evaluate what genericMessage is, as there is no application runtime (it will be compiled), so only simple traversals through source can be performed. Even for const it can be hard right now.<br>&gt;&gt; <br>&gt;&gt; The other question arises here, suppose CommonMessages are in external library,. What should happen if it changes, should a genericError be referenced or it’s value copied and stored in binary? Referencing could be quite interesting topic.<br>&gt;&gt; <br>&gt;&gt; We can consider allowing simple or more complicated expressions in attribute properties<br>&gt;&gt; @Size(width=20+50+sqrt(12))<br>&gt;&gt; As long as those refer static context.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler has build in support for core attributes, which can affect code generation. Compiler may perform additional checks on core attributes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; OK.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another question is, how would you inspect attributes at runtime?<br>&gt;&gt; I would like to focus on syntax, semantic and parsing. This will require answering question how to store attributes (and I would like to move this to separate chain, as it will be long discussion). From the other hand, some questions still should be answered, ie.<br>&gt;&gt; <br>&gt;&gt; How attribute should behave in such a case:<br>&gt;&gt; @ValidationMessage(message=CommonMessages.genericError)<br>&gt;&gt; var id:Int;<br>&gt;&gt; <br>&gt;&gt; Should genericValue be copied or referenced (see above consideration), this implies what and how to store.<br>&gt; Probably, in this case it would be good to have a look on Java annotations. This can provide some hints on how to store the compiled information.<br>In Java compiler traverses references and stores copy of calculated values. The types of value is limited. The internal representation of annotation element value can be found here :) <br>https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.16.1 &lt;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.16.1&gt;<br></p><p>And we can create something more. I like Java, but I have to admit that some concepts could be improved.<br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; Aquest correu electrònic i els annexos poden contenir informació confidencial o protegida legalment i està adreçat exclusivament a la persona o entitat destinatària. Si no sou el destinatari final o la persona encarregada de rebre’l, no esteu autoritzat a llegir-lo, retenir-lo, modificar-lo, distribuir-lo, copiar-lo ni a revelar-ne el contingut. Si heu rebut aquest correu electrònic per error, us preguem que n’informeu al remitent i que elimineu del sistema el missatge i el material annex que pugui contenir. Gràcies per la vostra col·laboració.<br>&gt; <br>&gt; Este correo electrónico y sus anexos pueden contener información confidencial o legalmente protegida y está exclusivamente dirigido a la persona o entidad destinataria. Si usted no es el destinatario final o la persona encargada de recibirlo, no está autorizado a leerlo, retenerlo, modificarlo, distribuirlo, copiarlo ni a revelar su contenido. Si ha recibido este mensaje electrónico por error, le rogamos que informe al remitente y elimine del sistema el mensaje y el material anexo que pueda contener. Gracias por su colaboración.<br>&gt; <br>&gt; This email message and any documents attached to it may contain confidential or legally protected material and are intended solely for the use of the individual or organization to whom they are addressed. We remind you that if you are not the intended recipient of this email message or the person responsible for processing it, then you are not authorized to read, save, modify, send, copy or disclose any of its contents. If you have received this email message by mistake, we kindly ask you to inform the sender of this and to eliminate both the message and any attachments it carries from your account. Thank you for your collaboration.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/5af69088/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0b06da9d5d4edede8590235c6dcae64?s=50"></div><header><strong>Adding custom attributes</strong> from <string>Radosław Smogura</string> &lt;rsmogura at icloud.com&gt;<p>December 28, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I tried to create some MVP for syntax, and put in on Wiki (as Akiva suggested). Everything is on table and can be discussed. Here please find link to it https://github.com/rsmogura/swift/wiki/Attributes-Proposal and below there is a copy of page<br></p><p>What do you think about defining for MVP, which outcome should be minimal consensus about syntax, as follow:<br>- parsing minimised attribute declaration, enabled by command line feature switch<br>- producing some AST<br>- validate attribute tree<br></p><p>After this we can start thinking how use attributes, store those and mirror (I believe there is a plenty of options)?<br></p><p>Best regards,<br>Radek<br></p><p>PS. I noticed we switched thread<br></p><p>Attribute Declaration Syntax<br></p><p>Attribute can be declared similar to class or struct, however as attribute is not class, nor struct and it&#39;s differently treated on runtime, it&#39;s a separate language construction. The example attribute is presented below:<br></p><p>@target(AttributeTarget.PROPERTY)<br>@available(AttributeAvailibility.RUNTIME)<br>@attribute JSONProperty {<br>    var name:String?;<br>    var readable:Bool? = true;<br>    var writeable:Bool? = true;<br>}<br> &lt;https://github.com/rsmogura/swift/wiki/Attributes-Proposal/_edit#formal-syntax&gt;Formal syntax<br></p><p>TBD Formal syntax description<br></p><p> &lt;https://github.com/rsmogura/swift/wiki/Attributes-Proposal/_edit#attribute-types-properties&gt;Attribute types properties<br></p><p>The attribute supports following types for its properties:<br></p><p>Int<br>Double<br>Bool<br>String<br>Enum values<br>Arrays of above<br>Later, when there will be consensus how to store attributes, and how the set properties, list of supported types can be extended<br></p><p> &lt;https://github.com/rsmogura/swift/wiki/Attributes-Proposal/_edit#attribute-target&gt;Attribute target<br></p><p>Attribute can be described with specifier determining on which language elements attribute can be used. Following enum defines possible target<br></p><p>enum AttributeTarget {<br> case ATTRIBUTE<br> case CLASS<br> case STRUCT<br> case INITIALIZER<br> case METHOD<br> case ENUM<br> case ENUM_VALUE<br> case PROPERTY<br>}<br>It&#39;s compile time error if attribute is used on different elements than it was declared.<br></p><p> &lt;https://github.com/rsmogura/swift/wiki/Attributes-Proposal/_edit#attribute-destination&gt;Attribute destination<br></p><p>Attribute destination describes where attribute will be available - if it&#39;s should be present in source, during compilation or during runtime. Some attributes do not have to be visible on runtime, ie. external tools can mark specific pieces of code to find those faster. The deprecated or availability attributes should be available during compilation time, so compiler can report appropriate warnings or error, but have no meaning on runtime.<br></p><p>Attribute destination is described by following enum:<br></p><p>enum AttributeAvailibility {<br>   case SOURCE<br>   case COMPILE<br>   case RUNTIME<br>}<br></p><p>&gt; On 26 Dec 2015, at 20:31, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 26 Dec 2015, at 19:57, JOSE MARIA GOMEZ CAMA &lt;jm.gomez at ub.edu &lt;mailto:jm.gomez at ub.edu&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dear all,<br>&gt;&gt; <br>&gt;&gt; Let me answer inlined.<br>&gt;&gt; <br>&gt;&gt;&gt; El 26/12/2015, a las 19:15, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escribió:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Dimitir,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for your questions, as you pointed me to deeper considerations and better description of idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26 Dec 2015, at 16:20, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Dec 26, 2015 at 3:59 PM, Radosław Smogura &lt;rsmogura at icloud.com &lt;mailto:rsmogura at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; So,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you think about syntax like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Declaration<br>&gt;&gt;&gt;&gt;&gt; @AttributeUsage(RUNTIME) //Can be SOURCE - attribute not emitted into binary<br>&gt;&gt;&gt;&gt;&gt; @AttributeTarget(PROPERTY) //Other CLASS, ENUM, METHOD, INIT<br>&gt;&gt;&gt;&gt;&gt; @attribute JSONProperty {<br>&gt;&gt;&gt;&gt;&gt; var name:String!;<br>&gt;&gt;&gt;&gt;&gt; var serializable:Bool? = true;<br>&gt;&gt;&gt;&gt;&gt; var deserializable:Bool? = true;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is this a new declaration kind?  Do you think we could make it work<br>&gt;&gt;&gt;&gt; with existing language constructs instead, like structs?  Any<br>&gt;&gt;&gt;&gt; downsides to that?<br>&gt;&gt;&gt; It’s really good concern and I have to describe attribute concept in more details. The _implementation_ of attributes would and should use existing constructs like structs or classes - I prefer classes as it will allow attributes to subclass some common class (Attribute?), so in future new functionality can be added.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s consider attributes, and marking struct with @Attrbute.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On runtime attributes will be passed as references or value objects (just to keep contract programming) and assignment to attribute properties should be prohibited:<br>&gt;&gt;&gt; - if attribute is bound to type, than attribute would be nothing more than extension of static context of that type,<br>&gt;&gt;&gt; - it’s error prone for developers, as someone could change i.e. JSON property name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Attributes are metadata, and do not require methods (however methods could be interesting and innovative addition). So attribute’s properties should be declared with let, instead of var, to prevent modification of those, but from other hand we would like to set default values for some properties, I just think that declaration like this would be confusing:<br>&gt;&gt;&gt; @Attribute<br>&gt;&gt;&gt; struct JSONProperty {<br>&gt;&gt;&gt; /* … */<br>&gt;&gt;&gt; let deserializable:Bool? = true;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Additionally having attributes as a new construct will give us more flexibility on changing syntax and adding new features in future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this implies that attribute can’t be considered as struct (on language level), and should be treated as new language construct.<br>&gt;&gt; <br>&gt;&gt; I do not agree that attributes should only provide metadata. I think they shall also provide means, like in Java or Python, to modify the behavior in runtime. For this, mirroring would be needed.<br>&gt; My bad, I think I unnesessary  used a word ‘metadata’ word. It may be confusing.<br>&gt; <br>&gt; You are right it is something we would like to achieve, but attribute alone is disconnected from mean. Mean (with some exceptions), similar like in Java, should be defined by library / container which inspects annotations on given object. <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Usage<br>&gt;&gt;&gt;&gt;&gt; @JSONProperty(name=“id”)<br>&gt;&gt;&gt;&gt;&gt; var id:Int;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Attributes should be module aware (actual attributes should be redefined as Swift attribute, for beginning still can be hardcoded).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I&#39;m not sure what this means.<br>&gt;&gt;&gt; Attributes should be in module. So modules can define attributes with same name. Right now attributes are global.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The attribute’s name have to be unique in module. It’s compile time error if attribute, class, enum, struct, etc has same name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Attribute’s properties are read only and can’t be assigned - so during reflection no-one would change ‘shared’ values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think using structs and requiring that attributes are value types<br>&gt;&gt;&gt;&gt; would solve both issues.<br>&gt;&gt;&gt; I think attributes should be treated as new language construct, regardless how those will be implemented on runtime - it can be struct or class.<br>&gt;&gt; <br>&gt;&gt; I do not see why it should be a new construct, in Java it is, but in case of Python it is not. Another option would be to define the attribute @attribute that would identify a class or a struct as an attribute.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Attribute’s properties can only support basic types: primitives, strings, types, and other attributes (optional).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, there is no such thing as &quot;basic types&quot; in Swift.  Strings,<br>&gt;&gt;&gt;&gt; integers etc. are defined in the standard library and the compiler<br>&gt;&gt;&gt;&gt; does not know anything special about them.<br>&gt;&gt;&gt; By basic type I meant a types which can be serialised to format which will not change in future. Numbers, strings, type names, arrays of those can be stored in binaries without risks of backward incompatibility, objects and structs are more fragile. I think next answer will clarify more.<br>&gt;&gt; <br>&gt;&gt; I think this is always the case when you have a compiled language, you always store information as a binary when you have a library.<br>&gt; I wanted to explain different topic here. In generally representation of primitive types do not change over time, which is in oposition to composite types where properties can be added or removed or it order can be changed. <br>&gt; <br>&gt;&gt;&gt;&gt;&gt; When declaring attributes, properties can be set to constant values (static let) or enum values, however the final value is stored in binary, not a reference to it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Again, given that strings are defined in the standard library, and<br>&gt;&gt;&gt;&gt; that the language does not have a notion of a constant expression, I&#39;m<br>&gt;&gt;&gt;&gt; not sure how this would work.  I&#39;m not saying it can&#39;t, I&#39;m just<br>&gt;&gt;&gt;&gt; saying you need to introduce a lot of new language concepts and<br>&gt;&gt;&gt;&gt; compiler machinery.<br>&gt;&gt;&gt; It’s another good question. By const I mean virtual concept of static let declaration. My motivation is to keep attributes as static metadata.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s consider three levels of attributes:<br>&gt;&gt;&gt; - source - those attributes are present only in source file and are not put in binary, such attributes can be used to mark pieces of code for external tools like visual UI designers, UMLs, etc<br>&gt;&gt;&gt; - compile - those attributes are present in output binary, but have not meaning on runtime - ie. @Deprecated,<br>&gt;&gt;&gt; - runtime - those attributes are present on runtime, and can be inspected by libraries to affect execution, ie.: @JSONProperty, @NSManaged<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My other concern is related to attribute storage (let’s skip implementation of this). Suppose you want to centralise some values, ie. messages with following pice of code<br>&gt;&gt;&gt; CommonMessages {<br>&gt;&gt;&gt;      static var genericError = “Something went wrong :(“<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And you want to bound a property to message when validation fails.<br>&gt;&gt;&gt; @ValidationMessage(message=CommonMessages.genericError)<br>&gt;&gt;&gt; var id:Int;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - For runtime referencing variables can be confusing, as some one seeing above notion can think that changing genericError will change message on runtime (annotations are static, so it will not work),<br>&gt;&gt;&gt; - For compilation level attributes compiler has limited possibilities to evaluate what genericMessage is, as there is no application runtime (it will be compiled), so only simple traversals through source can be performed. Even for const it can be hard right now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other question arises here, suppose CommonMessages are in external library,. What should happen if it changes, should a genericError be referenced or it’s value copied and stored in binary? Referencing could be quite interesting topic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can consider allowing simple or more complicated expressions in attribute properties<br>&gt;&gt;&gt; @Size(width=20+50+sqrt(12))<br>&gt;&gt;&gt; As long as those refer static context.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The compiler has build in support for core attributes, which can affect code generation. Compiler may perform additional checks on core attributes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; OK.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another question is, how would you inspect attributes at runtime?<br>&gt;&gt;&gt; I would like to focus on syntax, semantic and parsing. This will require answering question how to store attributes (and I would like to move this to separate chain, as it will be long discussion). From the other hand, some questions still should be answered, ie.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How attribute should behave in such a case:<br>&gt;&gt;&gt; @ValidationMessage(message=CommonMessages.genericError)<br>&gt;&gt;&gt; var id:Int;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should genericValue be copied or referenced (see above consideration), this implies what and how to store.<br>&gt;&gt; Probably, in this case it would be good to have a look on Java annotations. This can provide some hints on how to store the compiled information.<br>&gt; In Java compiler traverses references and stores copy of calculated values. The types of value is limited. The internal representation of annotation element value can be found here :) <br>&gt; https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.16.1 &lt;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.16.1&gt;<br>&gt; <br>&gt; And we can create something more. I like Java, but I have to admit that some concepts could be improved.<br>&gt;&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Aquest correu electrònic i els annexos poden contenir informació confidencial o protegida legalment i està adreçat exclusivament a la persona o entitat destinatària. Si no sou el destinatari final o la persona encarregada de rebre’l, no esteu autoritzat a llegir-lo, retenir-lo, modificar-lo, distribuir-lo, copiar-lo ni a revelar-ne el contingut. Si heu rebut aquest correu electrònic per error, us preguem que n’informeu al remitent i que elimineu del sistema el missatge i el material annex que pugui contenir. Gràcies per la vostra col·laboració.<br>&gt;&gt; <br>&gt;&gt; Este correo electrónico y sus anexos pueden contener información confidencial o legalmente protegida y está exclusivamente dirigido a la persona o entidad destinataria. Si usted no es el destinatario final o la persona encargada de recibirlo, no está autorizado a leerlo, retenerlo, modificarlo, distribuirlo, copiarlo ni a revelar su contenido. Si ha recibido este mensaje electrónico por error, le rogamos que informe al remitente y elimine del sistema el mensaje y el material anexo que pueda contener. Gracias por su colaboración.<br>&gt;&gt; <br>&gt;&gt; This email message and any documents attached to it may contain confidential or legally protected material and are intended solely for the use of the individual or organization to whom they are addressed. We remind you that if you are not the intended recipient of this email message or the person responsible for processing it, then you are not authorized to read, save, modify, send, copy or disclose any of its contents. If you have received this email message by mistake, we kindly ask you to inform the sender of this and to eliminate both the message and any attachments it carries from your account. Thank you for your collaboration.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/7b638ff9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
