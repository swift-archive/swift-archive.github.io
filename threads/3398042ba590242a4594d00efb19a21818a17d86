<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 19, 2016 at 06:00:00pm</p></header><div class="content"><p>on Tue Apr 19 2016, Karl Wagner &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I understand what you’re saying about API bloat, but I still think this is a fair proposal:<br>&gt;<br>&gt; 1. It’s not a very outlandish thing. <br></p><p>No, of course it isn&#39;t.  That doesn&#39;t mean we should add it, either.<br></p><p>Note: I&#39;m not predisposed against these particular algorithms; not at<br>all.  At the same time, I want to be sure we understand why each<br>algorithm we add is being added, and where the limits are.<br></p><p>&gt; We already have min/max. Adding a function for the mean would probably<br>&gt; be too much. Collection is a bit of a special API; it should be<br>&gt; reasonably comprehensive to allow developers to keep working at the<br>&gt; most abstract level possible, but you’re right, of course, that there<br>&gt; must be limits.<br>&gt;<br>&gt; 2. Many complex collections will probably decide to cache their<br>&gt; min/max indexes and invalidate them on insertion/removal. <br></p><p>Many?  I&#39;ve never heard of a general purpose data structure that did<br>this, (other than sorted collections, which sort of need to do it by<br>definition, in order to produce startIndex and endIndex).<br></p><p>&gt; With this API, we could grab those indexes from a stored property;<br>&gt; without it, we’d have to get the min/max elements (which internally<br>&gt; will probably just look up those cached indexes) and work backwards to<br>&gt; find the indexes.<br></p><p>Only in generic code that doesn&#39;t know it&#39;s handling this particular<br>collection.  The concrete collection is free to expose whatever it wants<br>to.<br></p><p>&gt; I’d rather remove min() and max() and replace them with<br>&gt; collection[collection.indexOfMaxElement].<br></p><p>That is certainly an interesting direction to consider.  One might say<br>that no standard library algorithm should ever return an element of the<br>collection unless it is being removed; instead we should always and only<br>return an index to the element.<br></p><p>&gt; As far as naming goes, you’re right. “minIndex&quot; and “maxIndex&quot; are far<br>&gt; too similar to “startIndex&quot; and “endIndex”.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt;&gt; on Sat Apr 16 2016, Nate Cook&lt;swift-evolution at swift.org&gt;wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Hello all,<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Attached is a draft of a proposal to expand the min and max sequence APIs to<br>&gt;&gt; &gt; better handle collections and to support future sorted sequences/collections.<br>&gt;&gt; &gt; The proposal is in a gist here and inlined below—would love to hear any comments<br>&gt;&gt; &gt; or feedback before submitting the proposal.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Nate<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Proposal: Expanded min/max algorithms<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; This proposal would expand on the min() and max() sequence methods to add<br>&gt;&gt; &gt; methods that return the corresponding index for a collection, efficiently find<br>&gt;&gt; &gt; the minimum and maximum elements or indices at the same time, and provide<br>&gt;&gt; &gt; extension points for sorted collections to provide all these results more<br>&gt;&gt; &gt; efficiently.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Related Bugs: SR-889 and SR-890<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Motivation<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; The Sequence protocol currently offers min() and max() methods that return the<br>&gt;&gt; &gt; minimum and maximum elements of a sequence or collection. Unfortunately, there<br>&gt;&gt; &gt; are applications where these methods do not provide enough flexibility to be<br>&gt;&gt; &gt; useful.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; First, if the user of a collection wants not just to get the minimum value but<br>&gt;&gt; &gt; also to operate on it in some way (e.g., mutation or just accessing it multiple<br>&gt;&gt; &gt; times), she would need the index of the minimum element. The current APIs don&#39;t<br>&gt;&gt; &gt; support that, so she would need to write her own.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Second, the writer of a sorted collection is currently unable to provide<br>&gt;&gt; &gt; efficient responses to the min() and max() methods when used in a generic<br>&gt;&gt; &gt; context, even though these should be O(1) operations. Just like Set can respond<br>&gt;&gt; &gt; quickly to contains(_:) even in a generic context, so too should new sorted<br>&gt;&gt; &gt; collections be able to optimize their responses.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Finally, getting the minimum and maximum elements (or indices) of a collection<br>&gt;&gt; &gt; or sequence currently requires calling both min() and max(). With two calls,<br>&gt;&gt; &gt; every element is iterated and compared twice. When you need both results,<br>&gt;&gt; &gt; finding both the minimum and the maximum at the same time is more efficient,<br>&gt;&gt; &gt; requiring only a single pass and 25% fewer comparisons.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Proposed solution<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; This proposal has three parts:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; 1 Adding minIndex() and maxIndex() methods to Collection that return the index<br>&gt;&gt; &gt; of the minimum and maximum elements, respectively.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; let numbers = [30, 40, 10, 20, 60, 50]<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; if let i = numbers.minIndex() {<br>&gt;&gt; &gt; print(&quot;\(i): \(numbers[i])&quot;) // 2: 10<br>&gt;&gt; &gt; }<br>&gt;&gt; Just with regard to naming, I don&#39;t think these work. I read “minIndex”<br>&gt;&gt; as “the minimum index,” and since we expect all indices to be<br>&gt;&gt; comparable, that clearly implies c.minIndex() == c.startIndex. I think<br>&gt;&gt; you&#39;d need “c.indexOfMin()”<br>&gt;&gt; <br>&gt;&gt; I am also really reluctant to add specialized algorithms for things<br>&gt;&gt; that can be trivially composed out of existing parts, e.g.<br>&gt;&gt; <br>&gt;&gt; c.indices.min { c[$0]&lt;c[$1] }<br>&gt;&gt; <br>&gt;&gt; Once we start down this road, we very quickly end up with mapValues,<br>&gt;&gt; mapKeys, indexOfMinimumKey, etc.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
