<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0131: Add AnyHashable to the standard library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0131: Add AnyHashable to the standard library&quot; begins now and runs through July 25.  This proposal is a bit unusual, since it is a late additive proposal.  The reason we need to do something here is as a critical part of &quot;SE-0116: Import Objective-C id as Swift Any type”, enabling importing untyped NSDictionary&#39;s and NSSet’s properly.  The core team considers this already conceptually approved for Swift 3 as part of SE-0116, but would greatly appreciate feedback on the details of the proposed design.<br></p><p>The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0131-anyhashable.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0131: Add AnyHashable to the standard library</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>July 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0131-anyhashable.md<br></p><p>+1!<br></p><p>This proposal looks great to me. I only have one nitpick: it looks like there&#39;s a &#39;_Hashable&#39; protocol used in the Dictionary extension to get around the limit on generic subscripts. Swift has managed to remove most (all?) underscored protocols from public APIs, so I would just suggest that the implementation consider an alternate name that isn&#39;t underscored. Something like &#39;HashableBase&#39; would still imply that the protocol is more of an implementation detail than a useful protocol on its own.<br></p><p>Nate<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0131: Add AnyHashable to the standard library</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 25, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mon, Jul 25, 2016 at 1:12 PM, Nate Cook via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0131-anyhashable.md<br>&gt;<br>&gt; +1!<br>&gt;<br>&gt; This proposal looks great to me. I only have one nitpick: it looks like there&#39;s a &#39;_Hashable&#39; protocol used in the Dictionary extension to get around the limit on generic subscripts. Swift has managed to remove most (all?) underscored protocols from public APIs, so I would just suggest that the implementation consider an alternate name that isn&#39;t underscored. Something like &#39;HashableBase&#39; would still imply that the protocol is more of an implementation detail than a useful protocol on its own.<br></p><p>Hi Nate,<br></p><p>I don&#39;t see a benefit for this.  Nobody should be using _Hashable.<br>Adding it as a non-underscored protocol increases API surface for no<br>benefit.  _Hashable is slated for removal as soon as we get the<br>necessary compiler features.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0131: Add AnyHashable to the standard library</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 24 Jul 2016, at 01:26, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0131: Add AnyHashable to the standard library&quot; begins now and runs through July 25.  This proposal is a bit unusual, since it is a late additive proposal.  The reason we need to do something here is as a critical part of &quot;SE-0116: Import Objective-C id as Swift Any type”, enabling importing untyped NSDictionary&#39;s and NSSet’s properly.  The core team considers this already conceptually approved for Swift 3 as part of SE-0116, but would greatly appreciate feedback on the details of the proposed design.<br>&gt; <br>&gt; The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0131-anyhashable.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1, this is a nice addition, and useful at times.<br></p><p>There&#39;s one very obscure gotcha &lt;https://swiftlang.ng.bluemix.net/#/repl/c1ddd24113169ab82df118660c8e0de6ea24e48d32997c327638a88dc686e91f&gt; with AnyHashable that subclass instances of a Hashable base class should be cast to the base type before wrapping into AnyHashable, otherwise such wrapped values may break the equivalence law of symmetry (`a == b` iff `b == a`).<br></p><p>But now that most of Foundation&#39;s class clusters are bridged into value types, that problem is unlikely to occur to anyone anymore.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>So and so.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. Maybe it will also help us gain more experience when designing real existential types.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>A bit of a hack compared to real existentials. But a good one.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/ee037d67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0131: Add AnyHashable to the standard library</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 25, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mon, Jul 25, 2016 at 1:34 PM, Pyry Jahkola via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On 24 Jul 2016, at 01:26, Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0131: Add AnyHashable to the standard library&quot; begins now<br>&gt; and runs through July 25.  This proposal is a bit unusual, since it is a<br>&gt; late additive proposal.  The reason we need to do something here is as a<br>&gt; critical part of &quot;SE-0116: Import Objective-C id as Swift Any type”,<br>&gt; enabling importing untyped NSDictionary&#39;s and NSSet’s properly.  The core<br>&gt; team considers this already conceptually approved for Swift 3 as part of<br>&gt; SE-0116, but would greatly appreciate feedback on the details of the<br>&gt; proposed design.<br>&gt;<br>&gt; The proposal is available here:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0131-anyhashable.md<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt;<br>&gt;<br>&gt; +1, this is a nice addition, and useful at times.<br>&gt;<br>&gt; There&#39;s one very obscure gotcha with AnyHashable that subclass instances of<br>&gt; a Hashable base class should be cast to the base type before wrapping into<br>&gt; AnyHashable, otherwise such wrapped values may break the equivalence law of<br>&gt; symmetry (`a == b` iff `b == a`).<br></p><p>The implementation that I have does not suffer from this issue.  (The<br>initializer of AnyHashable walks the superclass chain and upcasts the<br>value to the correct type.)<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0131: Add AnyHashable to the standard library</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 26, 2016 at 08:00:00am</p></header><div class="content"><p>Dmitri Gribenko wrote:<br></p><p>&gt;&gt; There&#39;s one very obscure gotcha with AnyHashable that subclass instances of<br>&gt;&gt; a Hashable base class should be cast to the base type before wrapping into<br>&gt;&gt; AnyHashable, otherwise such wrapped values may break the equivalence law of<br>&gt;&gt; symmetry (`a == b` iff `b == a`).<br>&gt; <br>&gt; The implementation that I have does not suffer from this issue.  (The<br>&gt; initializer of AnyHashable walks the superclass chain and upcasts the<br>&gt; value to the correct type.)<br></p><p>Brilliant! Glad that you found a resolution!<br></p><p>— Pyry<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Review] SE-0131: Add AnyHashable to the standard library</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 26, 2016 at 07:00:00am</p></header><div class="content"><p>I’d only +1 this proposal if we can perform an implicit conversion. From SE-0116:<br></p><p>&gt; The user model for this type would ideally align with our long-term goal of supporting Hashable existentials directly, so the type deserves some short-term compiler support to help us get there.<br></p><p><br>I read that as meaning that the interface should look as close as possible to what using a raw “Hashable” would look like, and that some short-term complier magic to achieve that would be acceptable. As far as that goes:<br></p><p>- unwrapping is functionally equivalent (upcasting from Any today, in the future from Hashable, but when upcasting all that matters is the destination type so NFC)<br>- wrapping is too verbose:<br></p><p>&gt; ///     let descriptions: [AnyHashable : Any] = [<br>&gt; ///         AnyHashable(&quot;😄&quot;): &quot;emoji&quot;,<br>&gt; ///         AnyHashable(42): &quot;an Int&quot;,<br>&gt; ///         AnyHashable(Int8(43)): &quot;an Int8&quot;,<br>&gt; ///         AnyHashable(Set([&quot;a&quot;, &quot;b&quot;])): &quot;a set of strings&quot;<br>&gt; ///     ]<br></p><p>That would be a big regression in readability, IMO. Previously, you could declare those keys without the “AnyHashable” wrapper, and the bridging magic would turn Int -&gt; NSNumber because that’s the way to make an Int conform to NSObject. It should be possible to teach the compiler how to turn a Hashable in to an AnyHashable implicitly.<br></p><p>But yeah, if we can do an implicit conversion, it’s a 👍 from me<br></p><p>Karl<br></p><p>&gt; On 24 Jul 2016, at 00:26, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0131: Add AnyHashable to the standard library&quot; begins now and runs through July 25.  This proposal is a bit unusual, since it is a late additive proposal.  The reason we need to do something here is as a critical part of &quot;SE-0116: Import Objective-C id as Swift Any type”, enabling importing untyped NSDictionary&#39;s and NSSet’s properly.  The core team considers this already conceptually approved for Swift 3 as part of SE-0116, but would greatly appreciate feedback on the details of the proposed design.<br>&gt; <br>&gt; The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0131-anyhashable.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/ba2d9f5a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0131: Add AnyHashable to the standard library</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 26, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jul 23, 2016, at 3:26 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; The review of &quot;SE-0131: Add AnyHashable to the standard library&quot; begins now and runs through July 25.  This proposal is a bit unusual, since it is a late additive proposal.  The reason we need to do something here is as a critical part of &quot;SE-0116: Import Objective-C id as Swift Any type”, enabling importing untyped NSDictionary&#39;s and NSSet’s properly.  The core team considers this already conceptually approved for Swift 3 as part of SE-0116, but would greatly appreciate feedback on the details of the proposed design.<br></p><p>Skipping the usual rigamarole:<br></p><p>Looks great, and quite aside from its use in bridged dictionaries, I&#39;m sure users will happily abuse it for heterogeneous comparisons.<br></p><p>My only comment is this: Is the `base` property following some convention established by other type-erased wrappers? If not, I would suggest either `any`, `value`, or `wrapped`; `base` seems to suggest something like a base class, which is not what&#39;s going on here.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
