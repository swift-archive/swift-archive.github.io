<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c6fa15749be30ec7c60986b1a2349b9b?s=50"></div><header><strong>[Proposal/Pitch] Function decorators</strong> from <string>apetrovic@outlook.com</string> &lt;apetrovic at outlook.com&gt;<p>May  3, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi swift-evolution,<br></p><p>I want to apologize in advance for my clumsy English. It&#39;s (obviously) not my first language.<br></p><p>Recent discussion about property behaviours reminded me of function decorators in Python. I think decorators can nicely fit in Swift, too.<br></p><p>First, a bit of explanation for the uninitiated. Decorator is a function that transform other function - it receives some function and returns a function of the same signature. Lets make some dead simple decorator:<br></p><p>typealias Decorated = (Double, Double) -&gt; Double<br></p><p>func hiDecorator(fn: Decorated) -&gt; Decorated {<br>    return { x, y in<br>        print(&quot;Hi from decorator!&quot;)<br>        return fn(x, y)<br>    }<br>} <br></p><p>func multiply(a: Double, _ b: Double) -&gt; Double {<br>   return a * b<br>}<br></p><p>let decoratedMultiply = hiDecorator(multiply)<br>print(&quot;Result: \(decoratedMultiply(2, 3))&quot;) <br></p><p><br>The above code should print:<br>Hi from decorator!<br>Result: 6<br></p><p>We can use decorators with the current Swift, but they&#39;re a bit cumbersome - either we need to store decorated function and remember to use it instead of the original one, or remember to do the decoration on every call.<br></p><p>Instead, we can write something like this:<br></p><p>[hiDecorator]<br>func multiply(a: Double, _ b: Double) -&gt; Double {<br>    return a * b<br>}<br></p><p>... and that code should be transformed into following during compilation:<br></p><p>func multiply(a: Double, _ b: Double) -&gt; Double {<br>     let fn: (Double, Double) -&gt; Double { _a, _b in<br>         return _a * _b<br>     }<br>     <br>     let decorated = hiDecorator(fn)     <br>     return decorated(a, b)<br>}<br></p><p>Outside, the function looks like before, so the change is compatible with virtual or interface extension functions.<br></p><p>Sometimes we&#39;ll need to pass some additional data to the decorator. That&#39;s fine, as long as the last argument is the target function:<br></p><p>func logUsage&lt;I, O&gt;(fnName: String, fn: (I) -&gt; O) -&gt; ((I) -&gt; O) {<br>    return { _i in<br>        print(&quot;Function \(fnName) enter&quot;)<br>        defer { print(&quot;Function \(fnName) exit&quot;) }<br>        return fn(_i)<br>    }<br>}<br></p><p>Let&#39;s use it:<br></p><p>[logUsage(&quot;increment&quot;)]<br>func increment(a: Int) -&gt; Int { return a + 1 }<br></p><p>[logUsage(&quot;justPrint&quot;)]<br>func justPrint(s: String) { print(s) }<br></p><p>In the above code, the compiler should generate internal decorator call by combining provided parameter and decorated function.<br></p><p><br>Why decorators?<br></p><p>It&#39;s important to say that proposed decorators change are pure syntactic sugar. Everything we can do with this change can be accomplished with the current Swift language. But, it gives to programmer a tool to express intentions more clearly and move repeating code away. <br></p><p>Sometimes decorators are just a convenient way to quickly add code. In the example above, logging is added with just one line of code and can be easily removed - the function body is not changed. <br></p><p>Sometimes decorators can be used as a poor man dependency injection mechanism, so we can write functions like this:<br></p><p>// if conn is nil, dbInit decorator will provide (global) one, and properly close it after doSomeDbWork exits<br>[dbInit]<br>func doSomeDbWork(conn: DbConnection? = nil) { ... } <br></p><p><br>We can use decorators in the standard library to, in a way, extend language:<br></p><p>[asyncMain]<br>func doSomething() { ... }  // this function will be posted to main queue<br></p><p>[synchronized]<br>func foo() { ... } // synchronized decorator uses either objc_sync_enter/exit or post on some queue to ensure mutual exclusion<br></p><p>Or to do some more exotic operations:<br></p><p>[repeatUntilDone(maxAttempt: 5)]<br>func connectToServer(url: String) -&gt; Bool { ... }<br></p><p>Abstract functions are frowned upon in Swift community, but if we can&#39;t live without it, we can signal our intent more clearly with decorator:<br></p><p>class T {<br>     [abstract] func bar() {} // abstract decorator will assert on call<br>}<br></p><p>Etc, etc. Sounds interesting?<br></p><p>Alex<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal/Pitch] Function decorators</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>May  8, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 4 May 2016, at 00:46, Aleksandar Petrovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift-evolution,<br>&gt; <br>&gt; I want to apologize in advance for my clumsy English. It&#39;s (obviously) not my first language.<br>&gt; <br>&gt; Recent discussion about property behaviours reminded me of function decorators in Python. I think decorators can nicely fit in Swift, too.<br>&gt; <br>&gt; First, a bit of explanation for the uninitiated. Decorator is a function that transform other function - it receives some function and returns a function of the same signature. Lets make some dead simple decorator:<br>&gt; <br>&gt; typealias Decorated = (Double, Double) -&gt; Double<br>&gt; <br>&gt; func hiDecorator(fn: Decorated) -&gt; Decorated {<br>&gt;     return { x, y in<br>&gt;         print(&quot;Hi from decorator!&quot;)<br>&gt;         return fn(x, y)<br>&gt;     }<br>&gt; } <br>&gt; <br>&gt; func multiply(a: Double, _ b: Double) -&gt; Double {<br>&gt;    return a * b<br>&gt; }<br>&gt; <br>&gt; let decoratedMultiply = hiDecorator(multiply)<br>&gt; print(&quot;Result: \(decoratedMultiply(2, 3))&quot;) <br>&gt; <br>&gt; <br>&gt; The above code should print:<br>&gt; Hi from decorator!<br>&gt; Result: 6<br>&gt; <br>&gt; We can use decorators with the current Swift, but they&#39;re a bit cumbersome - either we need to store decorated function and remember to use it instead of the original one, or remember to do the decoration on every call.<br>&gt; <br>&gt; Instead, we can write something like this:<br>&gt; <br>&gt; [hiDecorator]<br>&gt; func multiply(a: Double, _ b: Double) -&gt; Double {<br>&gt;     return a * b<br>&gt; }<br>&gt; <br>&gt; ... and that code should be transformed into following during compilation:<br>&gt; <br>&gt; func multiply(a: Double, _ b: Double) -&gt; Double {<br>&gt;      let fn: (Double, Double) -&gt; Double { _a, _b in<br>&gt;          return _a * _b<br>&gt;      }<br>&gt;      <br>&gt;      let decorated = hiDecorator(fn)     <br>&gt;      return decorated(a, b)<br>&gt; }<br>&gt; <br>&gt; Outside, the function looks like before, so the change is compatible with virtual or interface extension functions.<br>&gt; <br>&gt; Sometimes we&#39;ll need to pass some additional data to the decorator. That&#39;s fine, as long as the last argument is the target function:<br>&gt; <br>&gt; func logUsage&lt;I, O&gt;(fnName: String, fn: (I) -&gt; O) -&gt; ((I) -&gt; O) {<br>&gt;     return { _i in<br>&gt;         print(&quot;Function \(fnName) enter&quot;)<br>&gt;         defer { print(&quot;Function \(fnName) exit&quot;) }<br>&gt;         return fn(_i)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Let&#39;s use it:<br>&gt; <br>&gt; [logUsage(&quot;increment&quot;)]<br>&gt; func increment(a: Int) -&gt; Int { return a + 1 }<br>&gt; <br>&gt; [logUsage(&quot;justPrint&quot;)]<br>&gt; func justPrint(s: String) { print(s) }<br>&gt; <br>&gt; In the above code, the compiler should generate internal decorator call by combining provided parameter and decorated function.<br>&gt; <br>&gt; <br>&gt; Why decorators?<br>&gt; <br>&gt; It&#39;s important to say that proposed decorators change are pure syntactic sugar. Everything we can do with this change can be accomplished with the current Swift language. But, it gives to programmer a tool to express intentions more clearly and move repeating code away. <br>&gt; <br>&gt; Sometimes decorators are just a convenient way to quickly add code. In the example above, logging is added with just one line of code and can be easily removed - the function body is not changed. <br>&gt; <br>&gt; Sometimes decorators can be used as a poor man dependency injection mechanism, so we can write functions like this:<br>&gt; <br>&gt; // if conn is nil, dbInit decorator will provide (global) one, and properly close it after doSomeDbWork exits<br>&gt; [dbInit]<br>&gt; func doSomeDbWork(conn: DbConnection? = nil) { ... } <br>&gt; <br>&gt; <br>&gt; We can use decorators in the standard library to, in a way, extend language:<br>&gt; <br>&gt; [asyncMain]<br>&gt; func doSomething() { ... }  // this function will be posted to main queue<br>&gt; <br>&gt; [synchronized]<br>&gt; func foo() { ... } // synchronized decorator uses either objc_sync_enter/exit or post on some queue to ensure mutual exclusion<br>&gt; <br>&gt; Or to do some more exotic operations:<br>&gt; <br>&gt; [repeatUntilDone(maxAttempt: 5)]<br>&gt; func connectToServer(url: String) -&gt; Bool { ... }<br>&gt; <br>&gt; Abstract functions are frowned upon in Swift community, but if we can&#39;t live without it, we can signal our intent more clearly with decorator:<br>&gt; <br>&gt; class T {<br>&gt;      [abstract] func bar() {} // abstract decorator will assert on call<br>&gt; }<br>&gt; <br>&gt; Etc, etc. Sounds interesting?<br>&gt; <br>&gt; Alex 		 	   		  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>Given that we might be doing &quot;property behaviours” (https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt;), which are basically property decorators, it probably makes sense to look at how that could work for function decorators.<br></p><p>After all, you could create a property behaviour around a closure and use that as a kind of function decorator. It would just be messy.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/78f7989a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal/Pitch] Function decorators</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 16, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 8, 2016, at 10:33 AM, Karl Wagner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 4 May 2016, at 00:46, Aleksandar Petrovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt; <br>&gt;&gt; I want to apologize in advance for my clumsy English. It&#39;s (obviously) not my first language.<br>&gt;&gt; <br>&gt;&gt; Recent discussion about property behaviours reminded me of function decorators in Python. I think decorators can nicely fit in Swift, too.<br>&gt;&gt; <br>&gt;&gt; First, a bit of explanation for the uninitiated. Decorator is a function that transform other function - it receives some function and returns a function of the same signature. Lets make some dead simple decorator:<br></p><p><br>In Objective-C, you can add a category that will entirely replace an existing method. Could using decorators allow us to add behaviors to methods to extend their behavior without overwriting those methods? Here is an example of what I&#39;m thinking.<br></p><p>extension UIView {<br>   decorate func somethingElse(...) {<br>         // performs existing behavior of somethingElse<br>        ... adds new behavior ...<br>   }<br>}<br></p><p>Context: I was asking about whether this kind of &quot;extend rather than replace or subclass&quot; behavior were possible in Swift, and was told that &quot;decorators&quot; might be the right technology to implement it.<br></p><p>Thanks in advance for any insight.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/34b56fb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c6fa15749be30ec7c60986b1a2349b9b?s=50"></div><header><strong>[Proposal/Pitch] Function decorators</strong> from <string>apetrovic@outlook.com</string> &lt;apetrovic at outlook.com&gt;<p>May 16, 2016 at 04:00:00pm</p></header><div class="content"><p>Well, yes and no. A decorator receives a method and returns a new method, and it&#39;s up to implementation what will happen in the new method - it can perform some operations before calling the original method, or doing something after the original method is called, or not calling the original method at all. But a decorator must be applied to the function in compile time, so changing the behavior of functions from some library we don&#39;t have source (like UIView, in your example) wouldn&#39;t be possible.<br></p><p>At least according to my original proposal. The proposal can be changed, but we need to invent some new syntax for such decorators.<br></p><p>Alex<br></p><p><br>On May 16, 2016 at 16:25:08, Erica Sadun (erica at ericasadun.com) wrote:<br></p><p>On May 8, 2016, at 10:33 AM, Karl Wagner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>On 4 May 2016, at 00:46, Aleksandar Petrovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hi swift-evolution,<br></p><p>I want to apologize in advance for my clumsy English. It&#39;s (obviously) not my first language.<br></p><p>Recent discussion about property behaviours reminded me of function decorators in Python. I think decorators can nicely fit in Swift, too.<br></p><p>First, a bit of explanation for the uninitiated. Decorator is a function that transform other function - it receives some function and returns a function of the same signature. Lets make some dead simple decorator:<br></p><p><br>In Objective-C, you can add a category that will entirely replace an existing method. Could using decorators allow us to add behaviors to methods to extend their behavior without overwriting those methods? Here is an example of what I&#39;m thinking.<br></p><p>extension UIView {<br>   decorate func somethingElse(...) {<br>         // performs existing behavior of somethingElse<br>        ... adds new behavior ...<br>   }<br>}<br></p><p>Context: I was asking about whether this kind of &quot;extend rather than replace or subclass&quot; behavior were possible in Swift, and was told that &quot;decorators&quot; might be the right technology to implement it.<br></p><p>Thanks in advance for any insight.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/107d99d2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal/Pitch] Function decorators</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>May 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 16 May 2016, at 16:25, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 8, 2016, at 10:33 AM, Karl Wagner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 4 May 2016, at 00:46, Aleksandar Petrovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to apologize in advance for my clumsy English. It&#39;s (obviously) not my first language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Recent discussion about property behaviours reminded me of function decorators in Python. I think decorators can nicely fit in Swift, too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, a bit of explanation for the uninitiated. Decorator is a function that transform other function - it receives some function and returns a function of the same signature. Lets make some dead simple decorator:<br>&gt; <br>&gt; <br>&gt; In Objective-C, you can add a category that will entirely replace an existing method. Could using decorators allow us to add behaviors to methods to extend their behavior without overwriting those methods? Here is an example of what I&#39;m thinking.<br>&gt; <br>&gt; extension UIView {<br>&gt;    decorate func somethingElse(...) {<br>&gt;          // performs existing behavior of somethingElse<br>&gt;         ... adds new behavior ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Context: I was asking about whether this kind of &quot;extend rather than replace or subclass&quot; behavior were possible in Swift, and was told that &quot;decorators&quot; might be the right technology to implement it.<br>&gt; <br>&gt; Thanks in advance for any insight.<br>&gt; <br>&gt; -- E<br>&gt; <br></p><p>I was thinking more along the lines of property behaviours, which are specified at compile-time. Decorating an existing function inside an extension would only be possible for overridable functions in non-final types (otherwise the functions may have been inlined). But yeah, theoretically I think you could capture the existing function pointer and replace it in the vtable with a decorated one. That is basically what you’d do in Objective-C today (getting the IMP for a selector, making an IMP from a closure and switch them in the dispatch table, then call original IMP from your closure).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/0b063b55/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
