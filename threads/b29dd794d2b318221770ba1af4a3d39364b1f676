<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p># Introduction<br></p><p>Currently, cross-platform Swift programs that rely on symbols defined in<br>libc (`fputs`, `stderr`, etc.) must all write the same five lines of<br>boilerplate code:<br></p><p>    #if os(Linux) || os(FreeBSD)<br>        import Glibc<br>    #else<br>        import Darwin<br>    #endif<br></p><p>Instead, I propose the following, which will work on all platforms:<br></p><p>    import Libc<br></p><p># Motivation<br></p><p>Let&#39;s say we wanted to write a program that, on any platform, would print<br>&quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br></p><p>    #if os(Linux) || os(FreeBSD)<br>        import Glibc<br>    #else<br>        import Darwin<br>    #endif<br></p><p>    fputs(&quot;Hello world!&quot;, stderr)<br></p><p>The first five lines of this program are necessary to import the symbols<br>`fputs` and `stderr`. Five lines may not be much, but these come with<br>significant drawbacks:<br></p><p>- They must be written in each source file that relies on libc, which is<br>tedious.<br>- It is subject to frequent change. As Swift is ported to more platforms,<br>that initial check must change to `#if os(Linux) || os(FreeBSD) ||<br>os(Windows) || os(Android)`, and so on. End users of Swift may not be<br>actively involved in its development, and so may be surprised when the<br>latest release suddenly necessitates more `os()` conditions.<br>- These combined force users to make a conscious decision to write<br>cross-platform code--as opposed to simply writing Swift and have it work on<br>other platforms seamlessly.<br></p><p>It would be preferable if people writing Swift did not need to check for<br>the current `os()` in order to write code that works across platforms.<br></p><p># Proposed solution<br></p><p>Instead of conditionally importing Darwin or Glibc, I propose the following:<br></p><p>    import Libc<br></p><p>This would import whichever libc implementation Swift was compiled with.<br>For Ubuntu Linux releases, this would be Glibc. For OS X releases, this<br>would be Darwin. For Android (coming soon in<br>https://github.com/apple/swift/pull/1442), this would be Bionic.<br></p><p>This saves the end user from writing boilerplate code, and it isolates them<br>from the rapid expansion of platforms on which Swift is able to be executed.<br></p><p>This idea is not novel: the Swift package manager already defines a &quot;libc&quot;<br>package that is essentially the boilerplate `os()` check above:<br>https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift<br>.<br></p><p>However, rather than determining which libc implementation to use at<br>runtime (like SwiftPM does above), I propose we allow the Swift stdlib to<br>be compiled with any arbitrary implementation of libc.<br></p><p># Detailed design<br></p><p>It&#39;s my understanding that the majority of this change would take place in<br>the Swift build scripts and CMake modules. Similar to how those scripts<br>export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this<br>proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br></p><p>This would also be accompanied by a change to the Swift 3 migrator that<br>could automatically convert conditional imports of Darwin/Glibc to the new<br>`import Libc`.<br></p><p>We must also devise a strategy for the transient rollout period, when Swift<br>defines a Libc module, but we don&#39;t have an OS X SDK that uses that name in<br>the bundled module.map. We can add a compiler hack for that, to<br>transparently translate the name.<br></p><p># Alternatives considered<br></p><p>I believe there are two contentious points to this proposal:<br></p><p>1. Whether to unify the module name across platforms.<br>2. What to name the module.<br></p><p>Alternatives considered on point #1 (whether to unify) include:<br></p><p>1a. The status quo: I consider this to be undesirable for the reasons<br>stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go<br>out of their way to write cross-platform Swift code, as opposed to writing<br>code that &quot;just works&quot; everywhere.<br>1b. The current Darwin and Glibc modules are a combination of POSIX and the<br>C standard library. We could export *two* modules. However I believe this<br>introduces additional overhead for users, with only the marginal benefit of<br>clean separation between libc and POSIX.<br>1c. A special import statement, defined in the Swift stdlib, that would<br>automatically get preprocessed to the five lines of boilerplate shown<br>above. This has several downsides, most notably the added complexity to<br>Swift syntax.<br></p><p>On point #2 (what to name it), I have spoken with people that raised<br>concerns over the name &quot;Libc&quot;:<br></p><p>&gt; Another concern is about compatibility with the C++ modules proposal. If<br>we want this module name to mean something, it should agree with the C++<br>spec.<br></p><p>I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching<br>WG21 papers with no luck--any advice on how to find out would be<br>appreciated!<br></p><p>Aside from the above point, some concrete alternatives for point #2 (what<br>to name it) include:<br></p><p>- `import System`: This is better suited to the idea that the module<br>contains both POSIX and libc.<br>- `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (<br>https://www.youtube.com/watch?v=PEgk2v6KntY)<br></p><p>---<br></p><p>Thanks for taking the time to read this proposal draft! Feedback (on its<br>contents or on how to proceed with the evolution proposal process) is<br>greatly appreciated.<br></p><p>- Brian Gesiak<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/b29df676/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  8, 2016 at 11:00:00am</p></header><div class="content"><p>How much would `Libc` include? The standard C library? POSIX? Does it provide any abstraction over platform-specific differences? In my mind, the common &#39;Libc&#39; and/or &#39;POSIX&#39; module would provide a reasonably consistent interface to libc or POSIX, and you&#39;d still have library-specific modules for library-specific APIs.<br></p><p>-Joe<br></p><p>&gt; On Mar 8, 2016, at 11:13 AM, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; # Introduction<br>&gt; <br>&gt; Currently, cross-platform Swift programs that rely on symbols defined in libc (`fputs`, `stderr`, etc.) must all write the same five lines of boilerplate code:<br>&gt; <br>&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt; <br>&gt; Instead, I propose the following, which will work on all platforms:<br>&gt; <br>&gt;     import Libc<br>&gt; <br>&gt; # Motivation<br>&gt; <br>&gt; Let&#39;s say we wanted to write a program that, on any platform, would print &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt; <br>&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt; <br>&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt; <br>&gt; The first five lines of this program are necessary to import the symbols `fputs` and `stderr`. Five lines may not be much, but these come with significant drawbacks:<br>&gt; <br>&gt; - They must be written in each source file that relies on libc, which is tedious.<br>&gt; - It is subject to frequent change. As Swift is ported to more platforms, that initial check must change to `#if os(Linux) || os(FreeBSD) || os(Windows) || os(Android)`, and so on. End users of Swift may not be actively involved in its development, and so may be surprised when the latest release suddenly necessitates more `os()` conditions.<br>&gt; - These combined force users to make a conscious decision to write cross-platform code--as opposed to simply writing Swift and have it work on other platforms seamlessly.<br>&gt; <br>&gt; It would be preferable if people writing Swift did not need to check for the current `os()` in order to write code that works across platforms.<br>&gt; <br>&gt; # Proposed solution<br>&gt; <br>&gt; Instead of conditionally importing Darwin or Glibc, I propose the following:<br>&gt; <br>&gt;     import Libc<br>&gt; <br>&gt; This would import whichever libc implementation Swift was compiled with. For Ubuntu Linux releases, this would be Glibc. For OS X releases, this would be Darwin. For Android (coming soon in https://github.com/apple/swift/pull/1442 &lt;https://github.com/apple/swift/pull/1442&gt;), this would be Bionic.<br>&gt; <br>&gt; This saves the end user from writing boilerplate code, and it isolates them from the rapid expansion of platforms on which Swift is able to be executed.<br>&gt; <br>&gt; This idea is not novel: the Swift package manager already defines a &quot;libc&quot; package that is essentially the boilerplate `os()` check above: https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift &lt;https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift&gt;.<br>&gt; <br>&gt; However, rather than determining which libc implementation to use at runtime (like SwiftPM does above), I propose we allow the Swift stdlib to be compiled with any arbitrary implementation of libc.<br>&gt; <br>&gt; # Detailed design<br>&gt; <br>&gt; It&#39;s my understanding that the majority of this change would take place in the Swift build scripts and CMake modules. Similar to how those scripts export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt; <br>&gt; This would also be accompanied by a change to the Swift 3 migrator that could automatically convert conditional imports of Darwin/Glibc to the new `import Libc`.<br>&gt; <br>&gt; We must also devise a strategy for the transient rollout period, when Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that name in the bundled module.map. We can add a compiler hack for that, to transparently translate the name.<br>&gt; <br>&gt; # Alternatives considered<br>&gt; <br>&gt; I believe there are two contentious points to this proposal: <br>&gt; <br>&gt; 1. Whether to unify the module name across platforms.<br>&gt; 2. What to name the module.<br>&gt; <br>&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt; <br>&gt; 1a. The status quo: I consider this to be undesirable for the reasons stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go out of their way to write cross-platform Swift code, as opposed to writing code that &quot;just works&quot; everywhere.<br>&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and the C standard library. We could export *two* modules. However I believe this introduces additional overhead for users, with only the marginal benefit of clean separation between libc and POSIX.<br>&gt; 1c. A special import statement, defined in the Swift stdlib, that would automatically get preprocessed to the five lines of boilerplate shown above. This has several downsides, most notably the added complexity to Swift syntax.<br>&gt; <br>&gt; On point #2 (what to name it), I have spoken with people that raised concerns over the name &quot;Libc&quot;:<br>&gt; <br>&gt; &gt; Another concern is about compatibility with the C++ modules proposal. If we want this module name to mean something, it should agree with the C++ spec.<br>&gt; <br>&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching WG21 papers with no luck--any advice on how to find out would be appreciated!<br>&gt; <br>&gt; Aside from the above point, some concrete alternatives for point #2 (what to name it) include:<br>&gt; <br>&gt; - `import System`: This is better suited to the idea that the module contains both POSIX and libc.<br>&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (https://www.youtube.com/watch?v=PEgk2v6KntY &lt;https://www.youtube.com/watch?v=PEgk2v6KntY&gt;)<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Thanks for taking the time to read this proposal draft! Feedback (on its contents or on how to proceed with the evolution proposal process) is greatly appreciated.<br>&gt; <br>&gt; - Brian Gesiak<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/820418e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>March  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 11:21 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How much would `Libc` include? The standard C library? POSIX? Does it provide any abstraction over platform-specific differences? In my mind, the common &#39;Libc&#39; and/or &#39;POSIX&#39; module would provide a reasonably consistent interface to libc or POSIX, and you&#39;d still have library-specific modules for library-specific APIs.<br>&gt; <br></p><p>That would make sense to me, too.  I’m not sure where Brian would draw the line, but as a user, I would expect Libc to include things like stdlib, stdio, and stdint.<br></p><p>- Will<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>March  8, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m definitely a big +1 on this -- and pretty much any other suggestion<br>that makes Swift code more portable and sets up a simple interface so that<br>other platforms can be supported without the addition of more code.<br></p><p>A few thoughts to add:<br> - there are differences (minor, but still) between Glibc and Darwin. Those<br>should be either unified (if possible) or re-arranged so that the unified<br>library shares unified functionality and then each separate one can have<br>its own set of caveats.<br></p><p> - I like `import System` myself, for the reasons you mentioned (conveys<br>LibC+POSIX combo)<br></p><p> - down the line, what are thoughts on getting a more Swift-friendly libC<br>API? (I know Foundation plays this role already, but it&#39;d be nice to have a<br>nice API for system calls without having to worry about maintaining<br>interface with the more-proprietary CoreFoundation)<br></p><p>On Tue, Mar 8, 2016 at 1:13 PM, Brian Gesiak via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; # Introduction<br>&gt;<br>&gt; Currently, cross-platform Swift programs that rely on symbols defined in<br>&gt; libc (`fputs`, `stderr`, etc.) must all write the same five lines of<br>&gt; boilerplate code:<br>&gt;<br>&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt;<br>&gt; Instead, I propose the following, which will work on all platforms:<br>&gt;<br>&gt;     import Libc<br>&gt;<br>&gt; # Motivation<br>&gt;<br>&gt; Let&#39;s say we wanted to write a program that, on any platform, would print<br>&gt; &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt;<br>&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt;<br>&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt;<br>&gt; The first five lines of this program are necessary to import the symbols<br>&gt; `fputs` and `stderr`. Five lines may not be much, but these come with<br>&gt; significant drawbacks:<br>&gt;<br>&gt; - They must be written in each source file that relies on libc, which is<br>&gt; tedious.<br>&gt; - It is subject to frequent change. As Swift is ported to more platforms,<br>&gt; that initial check must change to `#if os(Linux) || os(FreeBSD) ||<br>&gt; os(Windows) || os(Android)`, and so on. End users of Swift may not be<br>&gt; actively involved in its development, and so may be surprised when the<br>&gt; latest release suddenly necessitates more `os()` conditions.<br>&gt; - These combined force users to make a conscious decision to write<br>&gt; cross-platform code--as opposed to simply writing Swift and have it work on<br>&gt; other platforms seamlessly.<br>&gt;<br>&gt; It would be preferable if people writing Swift did not need to check for<br>&gt; the current `os()` in order to write code that works across platforms.<br>&gt;<br>&gt; # Proposed solution<br>&gt;<br>&gt; Instead of conditionally importing Darwin or Glibc, I propose the<br>&gt; following:<br>&gt;<br>&gt;     import Libc<br>&gt;<br>&gt; This would import whichever libc implementation Swift was compiled with.<br>&gt; For Ubuntu Linux releases, this would be Glibc. For OS X releases, this<br>&gt; would be Darwin. For Android (coming soon in<br>&gt; https://github.com/apple/swift/pull/1442), this would be Bionic.<br>&gt;<br>&gt; This saves the end user from writing boilerplate code, and it isolates<br>&gt; them from the rapid expansion of platforms on which Swift is able to be<br>&gt; executed.<br>&gt;<br>&gt; This idea is not novel: the Swift package manager already defines a &quot;libc&quot;<br>&gt; package that is essentially the boilerplate `os()` check above:<br>&gt; https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift<br>&gt; .<br>&gt;<br>&gt; However, rather than determining which libc implementation to use at<br>&gt; runtime (like SwiftPM does above), I propose we allow the Swift stdlib to<br>&gt; be compiled with any arbitrary implementation of libc.<br>&gt;<br>&gt; # Detailed design<br>&gt;<br>&gt; It&#39;s my understanding that the majority of this change would take place in<br>&gt; the Swift build scripts and CMake modules. Similar to how those scripts<br>&gt; export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this<br>&gt; proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt;<br>&gt; This would also be accompanied by a change to the Swift 3 migrator that<br>&gt; could automatically convert conditional imports of Darwin/Glibc to the new<br>&gt; `import Libc`.<br>&gt;<br>&gt; We must also devise a strategy for the transient rollout period, when<br>&gt; Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that<br>&gt; name in the bundled module.map. We can add a compiler hack for that, to<br>&gt; transparently translate the name.<br>&gt;<br>&gt; # Alternatives considered<br>&gt;<br>&gt; I believe there are two contentious points to this proposal:<br>&gt;<br>&gt; 1. Whether to unify the module name across platforms.<br>&gt; 2. What to name the module.<br>&gt;<br>&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt;<br>&gt; 1a. The status quo: I consider this to be undesirable for the reasons<br>&gt; stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go<br>&gt; out of their way to write cross-platform Swift code, as opposed to writing<br>&gt; code that &quot;just works&quot; everywhere.<br>&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and<br>&gt; the C standard library. We could export *two* modules. However I believe<br>&gt; this introduces additional overhead for users, with only the marginal<br>&gt; benefit of clean separation between libc and POSIX.<br>&gt; 1c. A special import statement, defined in the Swift stdlib, that would<br>&gt; automatically get preprocessed to the five lines of boilerplate shown<br>&gt; above. This has several downsides, most notably the added complexity to<br>&gt; Swift syntax.<br>&gt;<br>&gt; On point #2 (what to name it), I have spoken with people that raised<br>&gt; concerns over the name &quot;Libc&quot;:<br>&gt;<br>&gt; &gt; Another concern is about compatibility with the C++ modules proposal. If<br>&gt; we want this module name to mean something, it should agree with the C++<br>&gt; spec.<br>&gt;<br>&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching<br>&gt; WG21 papers with no luck--any advice on how to find out would be<br>&gt; appreciated!<br>&gt;<br>&gt; Aside from the above point, some concrete alternatives for point #2 (what<br>&gt; to name it) include:<br>&gt;<br>&gt; - `import System`: This is better suited to the idea that the module<br>&gt; contains both POSIX and libc.<br>&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (<br>&gt; https://www.youtube.com/watch?v=PEgk2v6KntY)<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Thanks for taking the time to read this proposal draft! Feedback (on its<br>&gt; contents or on how to proceed with the evolution proposal process) is<br>&gt; greatly appreciated.<br>&gt;<br>&gt; - Brian Gesiak<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/6f83c4e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 11:33 AM, Brian Pratt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m definitely a big +1 on this -- and pretty much any other suggestion that makes Swift code more portable and sets up a simple interface so that other platforms can be supported without the addition of more code.<br>&gt; <br>&gt; A few thoughts to add:<br>&gt;  - there are differences (minor, but still) between Glibc and Darwin. Those should be either unified (if possible) or re-arranged so that the unified library shares unified functionality and then each separate one can have its own set of caveats.<br>&gt; <br>&gt;  - I like `import System` myself, for the reasons you mentioned (conveys LibC+POSIX combo)<br></p><p>This would be problematic for non-POSIX platforms, like Windows. (iOS and Android are also limited in POSIX-ness in various ways.)<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>March  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; This would be problematic for non-POSIX platforms, like Windows. (iOS and<br>Android are also limited in POSIX-ness in various ways.)<br></p><p>Definitely -- that&#39;s part of the reason I asked about the idea of creating<br>some sort of abstraction at a higher-level than libc (and a lower one than<br>Foundation), because it seems like it would enable a bit more flexibility<br>on the back-end.<br></p><p>On Tue, Mar 8, 2016 at 1:35 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 8, 2016, at 11:33 AM, Brian Pratt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;m definitely a big +1 on this -- and pretty much any other suggestion<br>&gt; that makes Swift code more portable and sets up a simple interface so that<br>&gt; other platforms can be supported without the addition of more code.<br>&gt; &gt;<br>&gt; &gt; A few thoughts to add:<br>&gt; &gt;  - there are differences (minor, but still) between Glibc and Darwin.<br>&gt; Those should be either unified (if possible) or re-arranged so that the<br>&gt; unified library shares unified functionality and then each separate one can<br>&gt; have its own set of caveats.<br>&gt; &gt;<br>&gt; &gt;  - I like `import System` myself, for the reasons you mentioned (conveys<br>&gt; LibC+POSIX combo)<br>&gt;<br>&gt; This would be problematic for non-POSIX platforms, like Windows. (iOS and<br>&gt; Android are also limited in POSIX-ness in various ways.)<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/67f781f6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  8, 2016 at 06:00:00pm</p></header><div class="content"><p>One of the reasons we haven&#39;t picked this particular name is if the C or C++ committees ever adopted modules. Given that they just got punted from C++17, though, maybe that shouldn&#39;t hold us back.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 8, 2016, at 11:13, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; # Introduction<br>&gt; <br>&gt; Currently, cross-platform Swift programs that rely on symbols defined in libc (`fputs`, `stderr`, etc.) must all write the same five lines of boilerplate code:<br>&gt; <br>&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt; <br>&gt; Instead, I propose the following, which will work on all platforms:<br>&gt; <br>&gt;     import Libc<br>&gt; <br>&gt; # Motivation<br>&gt; <br>&gt; Let&#39;s say we wanted to write a program that, on any platform, would print &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt; <br>&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt; <br>&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt; <br>&gt; The first five lines of this program are necessary to import the symbols `fputs` and `stderr`. Five lines may not be much, but these come with significant drawbacks:<br>&gt; <br>&gt; - They must be written in each source file that relies on libc, which is tedious.<br>&gt; - It is subject to frequent change. As Swift is ported to more platforms, that initial check must change to `#if os(Linux) || os(FreeBSD) || os(Windows) || os(Android)`, and so on. End users of Swift may not be actively involved in its development, and so may be surprised when the latest release suddenly necessitates more `os()` conditions.<br>&gt; - These combined force users to make a conscious decision to write cross-platform code--as opposed to simply writing Swift and have it work on other platforms seamlessly.<br>&gt; <br>&gt; It would be preferable if people writing Swift did not need to check for the current `os()` in order to write code that works across platforms.<br>&gt; <br>&gt; # Proposed solution<br>&gt; <br>&gt; Instead of conditionally importing Darwin or Glibc, I propose the following:<br>&gt; <br>&gt;     import Libc<br>&gt; <br>&gt; This would import whichever libc implementation Swift was compiled with. For Ubuntu Linux releases, this would be Glibc. For OS X releases, this would be Darwin. For Android (coming soon in https://github.com/apple/swift/pull/1442 &lt;https://github.com/apple/swift/pull/1442&gt;), this would be Bionic.<br>&gt; <br>&gt; This saves the end user from writing boilerplate code, and it isolates them from the rapid expansion of platforms on which Swift is able to be executed.<br>&gt; <br>&gt; This idea is not novel: the Swift package manager already defines a &quot;libc&quot; package that is essentially the boilerplate `os()` check above: https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift &lt;https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift&gt;.<br>&gt; <br>&gt; However, rather than determining which libc implementation to use at runtime (like SwiftPM does above), I propose we allow the Swift stdlib to be compiled with any arbitrary implementation of libc.<br>&gt; <br>&gt; # Detailed design<br>&gt; <br>&gt; It&#39;s my understanding that the majority of this change would take place in the Swift build scripts and CMake modules. Similar to how those scripts export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt; <br>&gt; This would also be accompanied by a change to the Swift 3 migrator that could automatically convert conditional imports of Darwin/Glibc to the new `import Libc`.<br>&gt; <br>&gt; We must also devise a strategy for the transient rollout period, when Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that name in the bundled module.map. We can add a compiler hack for that, to transparently translate the name.<br>&gt; <br>&gt; # Alternatives considered<br>&gt; <br>&gt; I believe there are two contentious points to this proposal: <br>&gt; <br>&gt; 1. Whether to unify the module name across platforms.<br>&gt; 2. What to name the module.<br>&gt; <br>&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt; <br>&gt; 1a. The status quo: I consider this to be undesirable for the reasons stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go out of their way to write cross-platform Swift code, as opposed to writing code that &quot;just works&quot; everywhere.<br>&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and the C standard library. We could export *two* modules. However I believe this introduces additional overhead for users, with only the marginal benefit of clean separation between libc and POSIX.<br>&gt; 1c. A special import statement, defined in the Swift stdlib, that would automatically get preprocessed to the five lines of boilerplate shown above. This has several downsides, most notably the added complexity to Swift syntax.<br>&gt; <br>&gt; On point #2 (what to name it), I have spoken with people that raised concerns over the name &quot;Libc&quot;:<br>&gt; <br>&gt; &gt; Another concern is about compatibility with the C++ modules proposal. If we want this module name to mean something, it should agree with the C++ spec.<br>&gt; <br>&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching WG21 papers with no luck--any advice on how to find out would be appreciated!<br>&gt; <br>&gt; Aside from the above point, some concrete alternatives for point #2 (what to name it) include:<br>&gt; <br>&gt; - `import System`: This is better suited to the idea that the module contains both POSIX and libc.<br>&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (https://www.youtube.com/watch?v=PEgk2v6KntY &lt;https://www.youtube.com/watch?v=PEgk2v6KntY&gt;)<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Thanks for taking the time to read this proposal draft! Feedback (on its contents or on how to proceed with the evolution proposal process) is greatly appreciated.<br>&gt; <br>&gt; - Brian Gesiak<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160308/ee212f52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27fb74253bf2cb9c8dcea56452f74006?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Honza Dvorsky</string> &lt;czechboy0 at gmail.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>A huge +1 on the proposal, I even have a code snippet to import the<br>platform-appropriate C library. I try to write every new Swift library<br>cross-platform-by-default now and this would definitely remove some<br>friction. Not to mention it would future-proof many libraries which won&#39;t<br>need to be updated when a new Swift platform is added.<br></p><p>Personally, I like &quot;import C&quot;, but at the end of the day I&#39;m happy to call<br>it whatever as long as it solves the problem. I agree with Brian that with<br>Swift scaling up to 4 or so platforms soon-ish, it&#39;s preferable to not put<br>any extra burden on Swift users if there is an almost-uniform C API which<br>can be used everywhere.<br></p><p>On Wed, Mar 9, 2016 at 2:03 AM Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One of the reasons we haven&#39;t picked this *particular* name is if the C<br>&gt; or C++ committees ever adopted modules. Given that they just got punted<br>&gt; from C++17, though, maybe that shouldn&#39;t hold us back.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Mar 8, 2016, at 11:13, Brian Gesiak via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; # Introduction<br>&gt;<br>&gt; Currently, cross-platform Swift programs that rely on symbols defined in<br>&gt; libc (`fputs`, `stderr`, etc.) must all write the same five lines of<br>&gt; boilerplate code:<br>&gt;<br>&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt;<br>&gt; Instead, I propose the following, which will work on all platforms:<br>&gt;<br>&gt;     import Libc<br>&gt;<br>&gt; # Motivation<br>&gt;<br>&gt; Let&#39;s say we wanted to write a program that, on any platform, would print<br>&gt; &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt;<br>&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt;<br>&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt;<br>&gt; The first five lines of this program are necessary to import the symbols<br>&gt; `fputs` and `stderr`. Five lines may not be much, but these come with<br>&gt; significant drawbacks:<br>&gt;<br>&gt; - They must be written in each source file that relies on libc, which is<br>&gt; tedious.<br>&gt; - It is subject to frequent change. As Swift is ported to more platforms,<br>&gt; that initial check must change to `#if os(Linux) || os(FreeBSD) ||<br>&gt; os(Windows) || os(Android)`, and so on. End users of Swift may not be<br>&gt; actively involved in its development, and so may be surprised when the<br>&gt; latest release suddenly necessitates more `os()` conditions.<br>&gt; - These combined force users to make a conscious decision to write<br>&gt; cross-platform code--as opposed to simply writing Swift and have it work on<br>&gt; other platforms seamlessly.<br>&gt;<br>&gt; It would be preferable if people writing Swift did not need to check for<br>&gt; the current `os()` in order to write code that works across platforms.<br>&gt;<br>&gt; # Proposed solution<br>&gt;<br>&gt; Instead of conditionally importing Darwin or Glibc, I propose the<br>&gt; following:<br>&gt;<br>&gt;     import Libc<br>&gt;<br>&gt; This would import whichever libc implementation Swift was compiled with.<br>&gt; For Ubuntu Linux releases, this would be Glibc. For OS X releases, this<br>&gt; would be Darwin. For Android (coming soon in<br>&gt; https://github.com/apple/swift/pull/1442), this would be Bionic.<br>&gt;<br>&gt; This saves the end user from writing boilerplate code, and it isolates<br>&gt; them from the rapid expansion of platforms on which Swift is able to be<br>&gt; executed.<br>&gt;<br>&gt; This idea is not novel: the Swift package manager already defines a &quot;libc&quot;<br>&gt; package that is essentially the boilerplate `os()` check above:<br>&gt; https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift<br>&gt; .<br>&gt;<br>&gt; However, rather than determining which libc implementation to use at<br>&gt; runtime (like SwiftPM does above), I propose we allow the Swift stdlib to<br>&gt; be compiled with any arbitrary implementation of libc.<br>&gt;<br>&gt; # Detailed design<br>&gt;<br>&gt; It&#39;s my understanding that the majority of this change would take place in<br>&gt; the Swift build scripts and CMake modules. Similar to how those scripts<br>&gt; export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this<br>&gt; proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt;<br>&gt; This would also be accompanied by a change to the Swift 3 migrator that<br>&gt; could automatically convert conditional imports of Darwin/Glibc to the new<br>&gt; `import Libc`.<br>&gt;<br>&gt; We must also devise a strategy for the transient rollout period, when<br>&gt; Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that<br>&gt; name in the bundled module.map. We can add a compiler hack for that, to<br>&gt; transparently translate the name.<br>&gt;<br>&gt; # Alternatives considered<br>&gt;<br>&gt; I believe there are two contentious points to this proposal:<br>&gt;<br>&gt; 1. Whether to unify the module name across platforms.<br>&gt; 2. What to name the module.<br>&gt;<br>&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt;<br>&gt; 1a. The status quo: I consider this to be undesirable for the reasons<br>&gt; stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go<br>&gt; out of their way to write cross-platform Swift code, as opposed to writing<br>&gt; code that &quot;just works&quot; everywhere.<br>&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and<br>&gt; the C standard library. We could export *two* modules. However I believe<br>&gt; this introduces additional overhead for users, with only the marginal<br>&gt; benefit of clean separation between libc and POSIX.<br>&gt; 1c. A special import statement, defined in the Swift stdlib, that would<br>&gt; automatically get preprocessed to the five lines of boilerplate shown<br>&gt; above. This has several downsides, most notably the added complexity to<br>&gt; Swift syntax.<br>&gt;<br>&gt; On point #2 (what to name it), I have spoken with people that raised<br>&gt; concerns over the name &quot;Libc&quot;:<br>&gt;<br>&gt; &gt; Another concern is about compatibility with the C++ modules proposal. If<br>&gt; we want this module name to mean something, it should agree with the C++<br>&gt; spec.<br>&gt;<br>&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching<br>&gt; WG21 papers with no luck--any advice on how to find out would be<br>&gt; appreciated!<br>&gt;<br>&gt; Aside from the above point, some concrete alternatives for point #2 (what<br>&gt; to name it) include:<br>&gt;<br>&gt; - `import System`: This is better suited to the idea that the module<br>&gt; contains both POSIX and libc.<br>&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (<br>&gt; https://www.youtube.com/watch?v=PEgk2v6KntY)<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Thanks for taking the time to read this proposal draft! Feedback (on its<br>&gt; contents or on how to proceed with the evolution proposal process) is<br>&gt; greatly appreciated.<br>&gt;<br>&gt; - Brian Gesiak<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/8d71e5a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>July  5, 2016 at 05:00:00pm</p></header><div class="content"><p>Sorry to resurrect such an old thread! I understand getting this in Swift<br>3.0 might not be realistic anymore, but this is still something I’d love to<br>see added to Swift. Could someone advise on whether it still makes sense to<br>spend time on this proposal? Or is this part of Swift too solidified to<br>change at this point?<br></p><p>How much would Libc include? The standard C library? POSIX?<br></p><p>Yes, I had originally anticipated this as including module C<br>&lt;https://github.com/apple/swift/blob/7b1a8dcf7fbcfd66f029cc5473edef5a08f86602/stdlib/public/Platform/glibc.modulemap.gyb#L29&gt;<br>and module POSIX<br>&lt;https://github.com/apple/swift/blob/7b1a8dcf7fbcfd66f029cc5473edef5a08f86602/stdlib/public/Platform/glibc.modulemap.gyb#L141&gt;.<br>I see that module CUUID was recently added as well<br>&lt;https://github.com/apple/swift/pull/3107&gt;, but I don’t think that should<br>be included.<br></p><p>there are differences (minor, but still) between Glibc and Darwin. Those<br>should be either unified (if possible) or re-arranged so that the unified<br>library shares unified functionality and then each separate one can have<br>its own set of caveats.<br></p><p>I don’t think the unified import C module should do anything besides<br>obviate the need to write the following:<br></p><p>#if os(Linux) || os(FreeBSD)<br>    import Glibc<br>#else<br>    import Darwin<br>#endif<br></p><p>If people feel strongly about unifying the overlay, perhaps we should<br>discuss that in future swift-evolution proposals.<br></p><p>Personally, I like “import C”, but at the end of the day I’m happy to call<br>it whatever as long as it solves the problem.<br></p><p>I couldn’t have said it better myself!<br></p><p>/cc Saleem, since he may have Windows opinions.<br></p><p>- Brian Gesiak<br>​<br></p><p>On Wed, Mar 9, 2016 at 6:35 AM, Honza Dvorsky &lt;czechboy0 at gmail.com&gt; wrote:<br></p><p>&gt; A huge +1 on the proposal, I even have a code snippet to import the<br>&gt; platform-appropriate C library. I try to write every new Swift library<br>&gt; cross-platform-by-default now and this would definitely remove some<br>&gt; friction. Not to mention it would future-proof many libraries which won&#39;t<br>&gt; need to be updated when a new Swift platform is added.<br>&gt;<br>&gt; Personally, I like &quot;import C&quot;, but at the end of the day I&#39;m happy to call<br>&gt; it whatever as long as it solves the problem. I agree with Brian that with<br>&gt; Swift scaling up to 4 or so platforms soon-ish, it&#39;s preferable to not put<br>&gt; any extra burden on Swift users if there is an almost-uniform C API which<br>&gt; can be used everywhere.<br>&gt;<br>&gt; On Wed, Mar 9, 2016 at 2:03 AM Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; One of the reasons we haven&#39;t picked this *particular* name is if the C<br>&gt;&gt; or C++ committees ever adopted modules. Given that they just got punted<br>&gt;&gt; from C++17, though, maybe that shouldn&#39;t hold us back.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 8, 2016, at 11:13, Brian Gesiak via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; # Introduction<br>&gt;&gt;<br>&gt;&gt; Currently, cross-platform Swift programs that rely on symbols defined in<br>&gt;&gt; libc (`fputs`, `stderr`, etc.) must all write the same five lines of<br>&gt;&gt; boilerplate code:<br>&gt;&gt;<br>&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;         import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;         import Darwin<br>&gt;&gt;     #endif<br>&gt;&gt;<br>&gt;&gt; Instead, I propose the following, which will work on all platforms:<br>&gt;&gt;<br>&gt;&gt;     import Libc<br>&gt;&gt;<br>&gt;&gt; # Motivation<br>&gt;&gt;<br>&gt;&gt; Let&#39;s say we wanted to write a program that, on any platform, would print<br>&gt;&gt; &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt;&gt;<br>&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;         import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;         import Darwin<br>&gt;&gt;     #endif<br>&gt;&gt;<br>&gt;&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt;&gt;<br>&gt;&gt; The first five lines of this program are necessary to import the symbols<br>&gt;&gt; `fputs` and `stderr`. Five lines may not be much, but these come with<br>&gt;&gt; significant drawbacks:<br>&gt;&gt;<br>&gt;&gt; - They must be written in each source file that relies on libc, which is<br>&gt;&gt; tedious.<br>&gt;&gt; - It is subject to frequent change. As Swift is ported to more platforms,<br>&gt;&gt; that initial check must change to `#if os(Linux) || os(FreeBSD) ||<br>&gt;&gt; os(Windows) || os(Android)`, and so on. End users of Swift may not be<br>&gt;&gt; actively involved in its development, and so may be surprised when the<br>&gt;&gt; latest release suddenly necessitates more `os()` conditions.<br>&gt;&gt; - These combined force users to make a conscious decision to write<br>&gt;&gt; cross-platform code--as opposed to simply writing Swift and have it work on<br>&gt;&gt; other platforms seamlessly.<br>&gt;&gt;<br>&gt;&gt; It would be preferable if people writing Swift did not need to check for<br>&gt;&gt; the current `os()` in order to write code that works across platforms.<br>&gt;&gt;<br>&gt;&gt; # Proposed solution<br>&gt;&gt;<br>&gt;&gt; Instead of conditionally importing Darwin or Glibc, I propose the<br>&gt;&gt; following:<br>&gt;&gt;<br>&gt;&gt;     import Libc<br>&gt;&gt;<br>&gt;&gt; This would import whichever libc implementation Swift was compiled with.<br>&gt;&gt; For Ubuntu Linux releases, this would be Glibc. For OS X releases, this<br>&gt;&gt; would be Darwin. For Android (coming soon in<br>&gt;&gt; https://github.com/apple/swift/pull/1442), this would be Bionic.<br>&gt;&gt;<br>&gt;&gt; This saves the end user from writing boilerplate code, and it isolates<br>&gt;&gt; them from the rapid expansion of platforms on which Swift is able to be<br>&gt;&gt; executed.<br>&gt;&gt;<br>&gt;&gt; This idea is not novel: the Swift package manager already defines a<br>&gt;&gt; &quot;libc&quot; package that is essentially the boilerplate `os()` check above:<br>&gt;&gt; https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift<br>&gt;&gt; .<br>&gt;&gt;<br>&gt;&gt; However, rather than determining which libc implementation to use at<br>&gt;&gt; runtime (like SwiftPM does above), I propose we allow the Swift stdlib to<br>&gt;&gt; be compiled with any arbitrary implementation of libc.<br>&gt;&gt;<br>&gt;&gt; # Detailed design<br>&gt;&gt;<br>&gt;&gt; It&#39;s my understanding that the majority of this change would take place<br>&gt;&gt; in the Swift build scripts and CMake modules. Similar to how those scripts<br>&gt;&gt; export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this<br>&gt;&gt; proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt;&gt;<br>&gt;&gt; This would also be accompanied by a change to the Swift 3 migrator that<br>&gt;&gt; could automatically convert conditional imports of Darwin/Glibc to the new<br>&gt;&gt; `import Libc`.<br>&gt;&gt;<br>&gt;&gt; We must also devise a strategy for the transient rollout period, when<br>&gt;&gt; Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that<br>&gt;&gt; name in the bundled module.map. We can add a compiler hack for that, to<br>&gt;&gt; transparently translate the name.<br>&gt;&gt;<br>&gt;&gt; # Alternatives considered<br>&gt;&gt;<br>&gt;&gt; I believe there are two contentious points to this proposal:<br>&gt;&gt;<br>&gt;&gt; 1. Whether to unify the module name across platforms.<br>&gt;&gt; 2. What to name the module.<br>&gt;&gt;<br>&gt;&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt;&gt;<br>&gt;&gt; 1a. The status quo: I consider this to be undesirable for the reasons<br>&gt;&gt; stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go<br>&gt;&gt; out of their way to write cross-platform Swift code, as opposed to writing<br>&gt;&gt; code that &quot;just works&quot; everywhere.<br>&gt;&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and<br>&gt;&gt; the C standard library. We could export *two* modules. However I believe<br>&gt;&gt; this introduces additional overhead for users, with only the marginal<br>&gt;&gt; benefit of clean separation between libc and POSIX.<br>&gt;&gt; 1c. A special import statement, defined in the Swift stdlib, that would<br>&gt;&gt; automatically get preprocessed to the five lines of boilerplate shown<br>&gt;&gt; above. This has several downsides, most notably the added complexity to<br>&gt;&gt; Swift syntax.<br>&gt;&gt;<br>&gt;&gt; On point #2 (what to name it), I have spoken with people that raised<br>&gt;&gt; concerns over the name &quot;Libc&quot;:<br>&gt;&gt;<br>&gt;&gt; &gt; Another concern is about compatibility with the C++ modules proposal.<br>&gt;&gt; If we want this module name to mean something, it should agree with the C++<br>&gt;&gt; spec.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching<br>&gt;&gt; WG21 papers with no luck--any advice on how to find out would be<br>&gt;&gt; appreciated!<br>&gt;&gt;<br>&gt;&gt; Aside from the above point, some concrete alternatives for point #2 (what<br>&gt;&gt; to name it) include:<br>&gt;&gt;<br>&gt;&gt; - `import System`: This is better suited to the idea that the module<br>&gt;&gt; contains both POSIX and libc.<br>&gt;&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (<br>&gt;&gt; https://www.youtube.com/watch?v=PEgk2v6KntY)<br>&gt;&gt;<br>&gt;&gt; ---<br>&gt;&gt;<br>&gt;&gt; Thanks for taking the time to read this proposal draft! Feedback (on its<br>&gt;&gt; contents or on how to proceed with the evolution proposal process) is<br>&gt;&gt; greatly appreciated.<br>&gt;&gt;<br>&gt;&gt; - Brian Gesiak<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/d22bba52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 2:59 PM, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry to resurrect such an old thread! I understand getting this in Swift 3.0 might not be realistic anymore, but this is still something I’d love to see added to Swift. Could someone advise on whether it still makes sense to spend time on this proposal? Or is this part of Swift too solidified to change at this point?<br>&gt; <br>It is definitely beyond Swift 3.0, but I’d love to see this happen at some point, we really need someone to drive the (surely to be contentious) design process.<br></p><p>-Chris<br></p><p><br>&gt; How much would Libc include? The standard C library? POSIX?<br>&gt; <br>&gt; Yes, I had originally anticipated this as including module C &lt;https://github.com/apple/swift/blob/7b1a8dcf7fbcfd66f029cc5473edef5a08f86602/stdlib/public/Platform/glibc.modulemap.gyb#L29&gt; and module POSIX &lt;https://github.com/apple/swift/blob/7b1a8dcf7fbcfd66f029cc5473edef5a08f86602/stdlib/public/Platform/glibc.modulemap.gyb#L141&gt;. I see that module CUUID was recently added as well &lt;https://github.com/apple/swift/pull/3107&gt;, but I don’t think that should be included.<br>&gt; <br>&gt; there are differences (minor, but still) between Glibc and Darwin. Those should be either unified (if possible) or re-arranged so that the unified library shares unified functionality and then each separate one can have its own set of caveats.<br>&gt; <br>&gt; I don’t think the unified import C module should do anything besides obviate the need to write the following:<br>&gt; <br>&gt; #if os(Linux) || os(FreeBSD)<br>&gt;     import Glibc<br>&gt; #else<br>&gt;     import Darwin<br>&gt; #endif<br>&gt; If people feel strongly about unifying the overlay, perhaps we should discuss that in future swift-evolution proposals.<br>&gt; <br>&gt; Personally, I like “import C”, but at the end of the day I’m happy to call it whatever as long as it solves the problem.<br>&gt; <br>&gt; I couldn’t have said it better myself!<br>&gt; <br>&gt; /cc Saleem, since he may have Windows opinions.<br>&gt; <br>&gt; - Brian Gesiak<br>&gt; <br>&gt; <br>&gt; On Wed, Mar 9, 2016 at 6:35 AM, Honza Dvorsky &lt;czechboy0 at gmail.com &lt;mailto:czechboy0 at gmail.com&gt;&gt; wrote:<br>&gt; A huge +1 on the proposal, I even have a code snippet to import the platform-appropriate C library. I try to write every new Swift library cross-platform-by-default now and this would definitely remove some friction. Not to mention it would future-proof many libraries which won&#39;t need to be updated when a new Swift platform is added.<br>&gt; <br>&gt; Personally, I like &quot;import C&quot;, but at the end of the day I&#39;m happy to call it whatever as long as it solves the problem. I agree with Brian that with Swift scaling up to 4 or so platforms soon-ish, it&#39;s preferable to not put any extra burden on Swift users if there is an almost-uniform C API which can be used everywhere.<br>&gt; <br>&gt; On Wed, Mar 9, 2016 at 2:03 AM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; One of the reasons we haven&#39;t picked this particular name is if the C or C++ committees ever adopted modules. Given that they just got punted from C++17, though, maybe that shouldn&#39;t hold us back.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 8, 2016, at 11:13, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; # Introduction<br>&gt;&gt; <br>&gt;&gt; Currently, cross-platform Swift programs that rely on symbols defined in libc (`fputs`, `stderr`, etc.) must all write the same five lines of boilerplate code:<br>&gt;&gt; <br>&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;         import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;         import Darwin<br>&gt;&gt;     #endif<br>&gt;&gt; <br>&gt;&gt; Instead, I propose the following, which will work on all platforms:<br>&gt;&gt; <br>&gt;&gt;     import Libc<br>&gt;&gt; <br>&gt;&gt; # Motivation<br>&gt;&gt; <br>&gt;&gt; Let&#39;s say we wanted to write a program that, on any platform, would print &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt;&gt; <br>&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;         import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;         import Darwin<br>&gt;&gt;     #endif<br>&gt;&gt; <br>&gt;&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt;&gt; <br>&gt;&gt; The first five lines of this program are necessary to import the symbols `fputs` and `stderr`. Five lines may not be much, but these come with significant drawbacks:<br>&gt;&gt; <br>&gt;&gt; - They must be written in each source file that relies on libc, which is tedious.<br>&gt;&gt; - It is subject to frequent change. As Swift is ported to more platforms, that initial check must change to `#if os(Linux) || os(FreeBSD) || os(Windows) || os(Android)`, and so on. End users of Swift may not be actively involved in its development, and so may be surprised when the latest release suddenly necessitates more `os()` conditions.<br>&gt;&gt; - These combined force users to make a conscious decision to write cross-platform code--as opposed to simply writing Swift and have it work on other platforms seamlessly.<br>&gt;&gt; <br>&gt;&gt; It would be preferable if people writing Swift did not need to check for the current `os()` in order to write code that works across platforms.<br>&gt;&gt; <br>&gt;&gt; # Proposed solution<br>&gt;&gt; <br>&gt;&gt; Instead of conditionally importing Darwin or Glibc, I propose the following:<br>&gt;&gt; <br>&gt;&gt;     import Libc<br>&gt;&gt; <br>&gt;&gt; This would import whichever libc implementation Swift was compiled with. For Ubuntu Linux releases, this would be Glibc. For OS X releases, this would be Darwin. For Android (coming soon in https://github.com/apple/swift/pull/1442 &lt;https://github.com/apple/swift/pull/1442&gt;), this would be Bionic.<br>&gt;&gt; <br>&gt;&gt; This saves the end user from writing boilerplate code, and it isolates them from the rapid expansion of platforms on which Swift is able to be executed.<br>&gt;&gt; <br>&gt;&gt; This idea is not novel: the Swift package manager already defines a &quot;libc&quot; package that is essentially the boilerplate `os()` check above: https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift &lt;https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift&gt;.<br>&gt;&gt; <br>&gt;&gt; However, rather than determining which libc implementation to use at runtime (like SwiftPM does above), I propose we allow the Swift stdlib to be compiled with any arbitrary implementation of libc.<br>&gt;&gt; <br>&gt;&gt; # Detailed design<br>&gt;&gt; <br>&gt;&gt; It&#39;s my understanding that the majority of this change would take place in the Swift build scripts and CMake modules. Similar to how those scripts export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt;&gt; <br>&gt;&gt; This would also be accompanied by a change to the Swift 3 migrator that could automatically convert conditional imports of Darwin/Glibc to the new `import Libc`.<br>&gt;&gt; <br>&gt;&gt; We must also devise a strategy for the transient rollout period, when Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that name in the bundled module.map. We can add a compiler hack for that, to transparently translate the name.<br>&gt;&gt; <br>&gt;&gt; # Alternatives considered<br>&gt;&gt; <br>&gt;&gt; I believe there are two contentious points to this proposal: <br>&gt;&gt; <br>&gt;&gt; 1. Whether to unify the module name across platforms.<br>&gt;&gt; 2. What to name the module.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt;&gt; <br>&gt;&gt; 1a. The status quo: I consider this to be undesirable for the reasons stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go out of their way to write cross-platform Swift code, as opposed to writing code that &quot;just works&quot; everywhere.<br>&gt;&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and the C standard library. We could export *two* modules. However I believe this introduces additional overhead for users, with only the marginal benefit of clean separation between libc and POSIX.<br>&gt;&gt; 1c. A special import statement, defined in the Swift stdlib, that would automatically get preprocessed to the five lines of boilerplate shown above. This has several downsides, most notably the added complexity to Swift syntax.<br>&gt;&gt; <br>&gt;&gt; On point #2 (what to name it), I have spoken with people that raised concerns over the name &quot;Libc&quot;:<br>&gt;&gt; <br>&gt;&gt; &gt; Another concern is about compatibility with the C++ modules proposal. If we want this module name to mean something, it should agree with the C++ spec.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching WG21 papers with no luck--any advice on how to find out would be appreciated!<br>&gt;&gt; <br>&gt;&gt; Aside from the above point, some concrete alternatives for point #2 (what to name it) include:<br>&gt;&gt; <br>&gt;&gt; - `import System`: This is better suited to the idea that the module contains both POSIX and libc.<br>&gt;&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (https://www.youtube.com/watch?v=PEgk2v6KntY &lt;https://www.youtube.com/watch?v=PEgk2v6KntY&gt;)<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; Thanks for taking the time to read this proposal draft! Feedback (on its contents or on how to proceed with the evolution proposal process) is greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; - Brian Gesiak<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/c778a596/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>July  5, 2016 at 05:00:00pm</p></header><div class="content"><p>On Tuesday, July 5, 2016, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 5, 2016, at 2:59 PM, Brian Gesiak via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Sorry to resurrect such an old thread! I understand getting this in Swift<br>&gt; 3.0 might not be realistic anymore, but this is still something I’d love to<br>&gt; see added to Swift. Could someone advise on whether it still makes sense to<br>&gt; spend time on this proposal? Or is this part of Swift too solidified to<br>&gt; change at this point?<br>&gt;<br>&gt; It is definitely beyond Swift 3.0, but I’d love to see this happen at some<br>&gt; point, we really need someone to drive the (surely to be contentious)<br>&gt; design process.<br>&gt;<br></p><p>I&#39;m probably going to regret this, but given that I had originally proposed<br>this to Brian and would really like to see this happen, what does this<br>entail?<br></p><p><br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; How much would Libc include? The standard C library? POSIX?<br>&gt;<br>&gt; Yes, I had originally anticipated this as including module C<br>&gt; &lt;https://github.com/apple/swift/blob/7b1a8dcf7fbcfd66f029cc5473edef5a08f86602/stdlib/public/Platform/glibc.modulemap.gyb#L29&gt;<br>&gt; and module POSIX<br>&gt; &lt;https://github.com/apple/swift/blob/7b1a8dcf7fbcfd66f029cc5473edef5a08f86602/stdlib/public/Platform/glibc.modulemap.gyb#L141&gt;.<br>&gt; I see that module CUUID was recently added as well<br>&gt; &lt;https://github.com/apple/swift/pull/3107&gt;, but I don’t think that should<br>&gt; be included.<br>&gt;<br>&gt; there are differences (minor, but still) between Glibc and Darwin. Those<br>&gt; should be either unified (if possible) or re-arranged so that the unified<br>&gt; library shares unified functionality and then each separate one can have<br>&gt; its own set of caveats.<br>&gt;<br>&gt; I don’t think the unified import C module should do anything besides<br>&gt; obviate the need to write the following:<br>&gt;<br>&gt; #if os(Linux) || os(FreeBSD)<br>&gt;     import Glibc<br>&gt; #else<br>&gt;     import Darwin<br>&gt; #endif<br>&gt;<br>&gt; This is about to me made worse with me trying to get Windows support.  How<br>does this look?<br></p><p> #if os(Linux) || os(FreeBSD) || os(PS4)<br>   import Glibc<br> #elseif os(macOS) || os(iOS) || os(tvOS) || os(watchOS)<br>  import Darwin<br> #elseif os(Windows) &amp;&amp; (_environment(msvc) || _environment(gnu))<br>  import msvc<br> #else<br>  import glibc<br> #endif<br></p><p>&gt;<br>&gt; If people feel strongly about unifying the overlay, perhaps we should<br>&gt; discuss that in future swift-evolution proposals.<br>&gt;<br>&gt; I would be interested in that as well.<br></p><p>&gt; Personally, I like “import C”, but at the end of the day I’m happy to call<br>&gt; it whatever as long as it solves the problem.<br>&gt;<br>&gt; I couldn’t have said it better myself!<br>&gt;<br>&gt; /cc Saleem, since he may have Windows opinions.<br>&gt;<br>&gt; - Brian Gesiak<br>&gt; ​<br>&gt;<br>&gt; On Wed, Mar 9, 2016 at 6:35 AM, Honza Dvorsky &lt;czechboy0 at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;czechboy0 at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; A huge +1 on the proposal, I even have a code snippet to import the<br>&gt;&gt; platform-appropriate C library. I try to write every new Swift library<br>&gt;&gt; cross-platform-by-default now and this would definitely remove some<br>&gt;&gt; friction. Not to mention it would future-proof many libraries which won&#39;t<br>&gt;&gt; need to be updated when a new Swift platform is added.<br>&gt;&gt;<br>&gt;&gt; Personally, I like &quot;import C&quot;, but at the end of the day I&#39;m happy to<br>&gt;&gt; call it whatever as long as it solves the problem. I agree with Brian that<br>&gt;&gt; with Swift scaling up to 4 or so platforms soon-ish, it&#39;s preferable to not<br>&gt;&gt; put any extra burden on Swift users if there is an almost-uniform C API<br>&gt;&gt; which can be used everywhere.<br>&gt;&gt;<br>&gt;&gt; On Wed, Mar 9, 2016 at 2:03 AM Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; One of the reasons we haven&#39;t picked this *particular* name is if the C<br>&gt;&gt;&gt; or C++ committees ever adopted modules. Given that they just got punted<br>&gt;&gt;&gt; from C++17, though, maybe that shouldn&#39;t hold us back.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 8, 2016, at 11:13, Brian Gesiak via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently, cross-platform Swift programs that rely on symbols defined in<br>&gt;&gt;&gt; libc (`fputs`, `stderr`, etc.) must all write the same five lines of<br>&gt;&gt;&gt; boilerplate code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;&gt;         import Glibc<br>&gt;&gt;&gt;     #else<br>&gt;&gt;&gt;         import Darwin<br>&gt;&gt;&gt;     #endif<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Instead, I propose the following, which will work on all platforms:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     import Libc<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let&#39;s say we wanted to write a program that, on any platform, would<br>&gt;&gt;&gt; print &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;&gt;         import Glibc<br>&gt;&gt;&gt;     #else<br>&gt;&gt;&gt;         import Darwin<br>&gt;&gt;&gt;     #endif<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The first five lines of this program are necessary to import the symbols<br>&gt;&gt;&gt; `fputs` and `stderr`. Five lines may not be much, but these come with<br>&gt;&gt;&gt; significant drawbacks:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - They must be written in each source file that relies on libc, which is<br>&gt;&gt;&gt; tedious.<br>&gt;&gt;&gt; - It is subject to frequent change. As Swift is ported to more<br>&gt;&gt;&gt; platforms, that initial check must change to `#if os(Linux) || os(FreeBSD)<br>&gt;&gt;&gt; || os(Windows) || os(Android)`, and so on. End users of Swift may not be<br>&gt;&gt;&gt; actively involved in its development, and so may be surprised when the<br>&gt;&gt;&gt; latest release suddenly necessitates more `os()` conditions.<br>&gt;&gt;&gt; - These combined force users to make a conscious decision to write<br>&gt;&gt;&gt; cross-platform code--as opposed to simply writing Swift and have it work on<br>&gt;&gt;&gt; other platforms seamlessly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It would be preferable if people writing Swift did not need to check for<br>&gt;&gt;&gt; the current `os()` in order to write code that works across platforms.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Proposed solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Instead of conditionally importing Darwin or Glibc, I propose the<br>&gt;&gt;&gt; following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     import Libc<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would import whichever libc implementation Swift was compiled with.<br>&gt;&gt;&gt; For Ubuntu Linux releases, this would be Glibc. For OS X releases, this<br>&gt;&gt;&gt; would be Darwin. For Android (coming soon in<br>&gt;&gt;&gt; https://github.com/apple/swift/pull/1442), this would be Bionic.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This saves the end user from writing boilerplate code, and it isolates<br>&gt;&gt;&gt; them from the rapid expansion of platforms on which Swift is able to be<br>&gt;&gt;&gt; executed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This idea is not novel: the Swift package manager already defines a<br>&gt;&gt;&gt; &quot;libc&quot; package that is essentially the boilerplate `os()` check above:<br>&gt;&gt;&gt; https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, rather than determining which libc implementation to use at<br>&gt;&gt;&gt; runtime (like SwiftPM does above), I propose we allow the Swift stdlib to<br>&gt;&gt;&gt; be compiled with any arbitrary implementation of libc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Detailed design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s my understanding that the majority of this change would take place<br>&gt;&gt;&gt; in the Swift build scripts and CMake modules. Similar to how those scripts<br>&gt;&gt;&gt; export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this<br>&gt;&gt;&gt; proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would also be accompanied by a change to the Swift 3 migrator that<br>&gt;&gt;&gt; could automatically convert conditional imports of Darwin/Glibc to the new<br>&gt;&gt;&gt; `import Libc`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We must also devise a strategy for the transient rollout period, when<br>&gt;&gt;&gt; Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that<br>&gt;&gt;&gt; name in the bundled module.map. We can add a compiler hack for that, to<br>&gt;&gt;&gt; transparently translate the name.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; # Alternatives considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I believe there are two contentious points to this proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Whether to unify the module name across platforms.<br>&gt;&gt;&gt; 2. What to name the module.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1a. The status quo: I consider this to be undesirable for the reasons<br>&gt;&gt;&gt; stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go<br>&gt;&gt;&gt; out of their way to write cross-platform Swift code, as opposed to writing<br>&gt;&gt;&gt; code that &quot;just works&quot; everywhere.<br>&gt;&gt;&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and<br>&gt;&gt;&gt; the C standard library. We could export *two* modules. However I believe<br>&gt;&gt;&gt; this introduces additional overhead for users, with only the marginal<br>&gt;&gt;&gt; benefit of clean separation between libc and POSIX.<br>&gt;&gt;&gt; 1c. A special import statement, defined in the Swift stdlib, that would<br>&gt;&gt;&gt; automatically get preprocessed to the five lines of boilerplate shown<br>&gt;&gt;&gt; above. This has several downsides, most notably the added complexity to<br>&gt;&gt;&gt; Swift syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On point #2 (what to name it), I have spoken with people that raised<br>&gt;&gt;&gt; concerns over the name &quot;Libc&quot;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; Another concern is about compatibility with the C++ modules proposal.<br>&gt;&gt;&gt; If we want this module name to mean something, it should agree with the C++<br>&gt;&gt;&gt; spec.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching<br>&gt;&gt;&gt; WG21 papers with no luck--any advice on how to find out would be<br>&gt;&gt;&gt; appreciated!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Aside from the above point, some concrete alternatives for point #2<br>&gt;&gt;&gt; (what to name it) include:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - `import System`: This is better suited to the idea that the module<br>&gt;&gt;&gt; contains both POSIX and libc.<br>&gt;&gt;&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=PEgk2v6KntY)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks for taking the time to read this proposal draft! Feedback (on its<br>&gt;&gt;&gt; contents or on how to proceed with the evolution proposal process) is<br>&gt;&gt;&gt; greatly appreciated.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Brian Gesiak<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/d177dc57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>I see two possible approaches:<br></p><p>1. A “import Libc” imports the platform libraries, whatever they may be, on the OS platform you are on.<br></p><p>2. The OS platform libraries are divided up, virtually if necessary, to expose the underlying standard interfaces without platform-specific extensions. I imagine that would look similar to https://gist.github.com/dwaite/c7125680def834e93ba1fae8873ce1f8:<br></p><p>                                                        ┌─────────────┐  <br>                               ┌────────────────────────│ Foundation  ├┐ <br>                               │      Platform-specific └┬────────────┘├┐<br>                               │      ┌──────────────┐   └┬────┬───────┘│<br>                               │      │    Linux     │    └────┼────────┘<br>                               │      │  ┌────────┐  │         │         <br>                               ├──────┼──│ GLibc  │  │         │         <br>                               │      │  └────────┘  │         │         <br>                               │      │              │         │         <br>             C Standard        │      ├──────────────┤         │         <br>               Library         ▼      │  Apple OSes  │         │         <br>┌────────┐   ┌────────┐   ┌────────┐  │  ┌────────┐  │         │         <br>│ Swift  │◀──│  Libc  │◀──│ Posix  │◀─┼──│ Darwin │◀─┼─────────┤         <br>└────────┘   └────────┘   └────────┘  │  └────────┘  │         │         <br>                  ▲                   │              │         │         <br>                  │                   ├──────────────┤         │         <br>                  │                   │   Windows    │         │         <br>                  │                   │  ┌────────┐  │         │         <br>                  └───────────────────┼──│ Win32  │◀─┼─────────┘         <br>                                      │  └────────┘  │                   <br>                                      │              │                   <br>                                      └──────────────┘                   <br></p><p><br>My feeling is that while dealing with imported code, it is understandable you will have API that differs per platform. Once you start adding object or protocol-oriented design on top, it is expected that the additional layer will abstract those differences away.<br></p><p>-DW<br>                <br>&gt; On Jul 5, 2016, at 6:28 PM, Saleem Abdulrasool via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tuesday, July 5, 2016, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 2:59 PM, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry to resurrect such an old thread! I understand getting this in Swift 3.0 might not be realistic anymore, but this is still something I’d love to see added to Swift. Could someone advise on whether it still makes sense to spend time on this proposal? Or is this part of Swift too solidified to change at this point?<br>&gt;&gt; <br>&gt; It is definitely beyond Swift 3.0, but I’d love to see this happen at some point, we really need someone to drive the (surely to be contentious) design process.<br>&gt; <br>&gt; I&#39;m probably going to regret this, but given that I had originally proposed this to Brian and would really like to see this happen, what does this entail?<br>&gt;  <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; How much would Libc include? The standard C library? POSIX?<br>&gt;&gt; <br>&gt;&gt; Yes, I had originally anticipated this as including module C and module POSIX. I see that module CUUID was recently added as well, but I don’t think that should be included.<br>&gt;&gt; <br>&gt;&gt; there are differences (minor, but still) between Glibc and Darwin. Those should be either unified (if possible) or re-arranged so that the unified library shares unified functionality and then each separate one can have its own set of caveats.<br>&gt;&gt; <br>&gt;&gt; I don’t think the unified import C module should do anything besides obviate the need to write the following:<br>&gt;&gt; <br>&gt;&gt; #if os(Linux) || os(FreeBSD<br>&gt;&gt; )<br>&gt;&gt;     <br>&gt;&gt; import Glibc<br>&gt;&gt; <br>&gt;&gt; #<br>&gt;&gt; else<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; import Darwin<br>&gt;&gt; <br>&gt;&gt; #endif<br>&gt;&gt; <br>&gt; This is about to me made worse with me trying to get Windows support.  How does this look?<br>&gt; <br>&gt;  #if os(Linux) || os(FreeBSD) || os(PS4)<br>&gt;    import Glibc<br>&gt;  #elseif os(macOS) || os(iOS) || os(tvOS) || os(watchOS)<br>&gt;   import Darwin<br>&gt;  #elseif os(Windows) &amp;&amp; (_environment(msvc) || _environment(gnu))<br>&gt;   import msvc<br>&gt;  #else<br>&gt;   import glibc<br>&gt;  #endif<br>&gt;&gt; <br>&gt;&gt; If people feel strongly about unifying the overlay, perhaps we should discuss that in future swift-evolution proposals.<br>&gt;&gt; <br>&gt; I would be interested in that as well. <br>&gt;&gt; Personally, I like “import C”, but at the end of the day I’m happy to call it whatever as long as it solves the problem.<br>&gt;&gt; <br>&gt;&gt; I couldn’t have said it better myself!<br>&gt;&gt; <br>&gt;&gt; /cc Saleem, since he may have Windows opinions.<br>&gt;&gt; <br>&gt;&gt; - Brian Gesiak<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Mar 9, 2016 at 6:35 AM, Honza Dvorsky &lt;czechboy0 at gmail.com&gt; wrote:<br>&gt;&gt; A huge +1 on the proposal, I even have a code snippet to import the platform-appropriate C library. I try to write every new Swift library cross-platform-by-default now and this would definitely remove some friction. Not to mention it would future-proof many libraries which won&#39;t need to be updated when a new Swift platform is added.<br>&gt;&gt; <br>&gt;&gt; Personally, I like &quot;import C&quot;, but at the end of the day I&#39;m happy to call it whatever as long as it solves the problem. I agree with Brian that with Swift scaling up to 4 or so platforms soon-ish, it&#39;s preferable to not put any extra burden on Swift users if there is an almost-uniform C API which can be used everywhere.<br>&gt;&gt; <br>&gt;&gt; On Wed, Mar 9, 2016 at 2:03 AM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; One of the reasons we haven&#39;t picked this particular name is if the C or C++ committees ever adopted modules. Given that they just got punted from C++17, though, maybe that shouldn&#39;t hold us back.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 8, 2016, at 11:13, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, cross-platform Swift programs that rely on symbols defined in libc (`fputs`, `stderr`, etc.) must all write the same five lines of boilerplate code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;&gt;         import Glibc<br>&gt;&gt;&gt;     #else<br>&gt;&gt;&gt;         import Darwin<br>&gt;&gt;&gt;     #endif<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead, I propose the following, which will work on all platforms:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import Libc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let&#39;s say we wanted to write a program that, on any platform, would print &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;&gt;         import Glibc<br>&gt;&gt;&gt;     #else<br>&gt;&gt;&gt;         import Darwin<br>&gt;&gt;&gt;     #endif<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The first five lines of this program are necessary to import the symbols `fputs` and `stderr`. Five lines may not be much, but these come with significant drawbacks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - They must be written in each source file that relies on libc, which is tedious.<br>&gt;&gt;&gt; - It is subject to frequent change. As Swift is ported to more platforms, that initial check must change to `#if os(Linux) || os(FreeBSD) || os(Windows) || os(Android)`, and so on. End users of Swift may not be actively involved in its development, and so may be surprised when the latest release suddenly necessitates more `os()` conditions.<br>&gt;&gt;&gt; - These combined force users to make a conscious decision to write cross-platform code--as opposed to simply writing Swift and have it work on other platforms seamlessly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be preferable if people writing Swift did not need to check for the current `os()` in order to write code that works across platforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead of conditionally importing Darwin or Glibc, I propose the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import Libc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would import whichever libc implementation Swift was compiled with. For Ubuntu Linux releases, this would be Glibc. For OS X releases, this would be Darwin. For Android (coming soon in https://github.com/apple/swift/pull/1442), this would be Bionic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This saves the end user from writing boilerplate code, and it isolates them from the rapid expansion of platforms on which Swift is able to be executed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This idea is not novel: the Swift package manager already defines a &quot;libc&quot; package that is essentially the boilerplate `os()` check above: https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, rather than determining which libc implementation to use at runtime (like SwiftPM does above), I propose we allow the Swift stdlib to be compiled with any arbitrary implementation of libc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s my understanding that the majority of this change would take place in the Swift build scripts and CMake modules. Similar to how those scripts export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would also be accompanied by a change to the Swift 3 migrator that could automatically convert conditional imports of Darwin/Glibc to the new `import Libc`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We must also devise a strategy for the transient rollout period, when Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that name in the bundled module.map. We can add a compiler hack for that, to transparently translate the name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe there are two contentious points to this proposal: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Whether to unify the module name across platforms.<br>&gt;&gt;&gt; 2. What to name the module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1a. The status quo: I consider this to be undesirable for the reasons stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go out of their way to write cross-platform Swift code, as opposed to writing code that &quot;just works&quot; everywhere.<br>&gt;&gt;&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and the C standard library. We could export *two* modules. However I believe this introduces additional overhead for users, with only the marginal benefit of clean separation between libc and POSIX.<br>&gt;&gt;&gt; 1c. A special import statement, defined in the Swift stdlib, that would automatically get preprocessed to the five lines of boilerplate shown above. This has several downsides, most notably the added complexity to Swift syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On point #2 (what to name it), I have spoken with people that raised concerns over the name &quot;Libc&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Another concern is about compatibility with the C++ modules proposal. If we want this module name to mean something, it should agree with the C++ spec.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching WG21 papers with no luck--any advice on how to find out would be appreciated!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aside from the above point, some concrete alternatives for point #2 (what to name it) include:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - `import System`: This is better suited to the idea that the module contains both POSIX and libc.<br>&gt;&gt;&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (https://www.youtube.com/watch?v=PEgk2v6KntY)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for taking the time to read this proposal draft! Feedback (on its contents or on how to proceed with the evolution proposal process) is greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Brian Gesiak<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/b8c7dd53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 4:35 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; I see two possible approaches:<br>&gt; <br>&gt; 1. A “import Libc” imports the platform libraries, whatever they may be, on the OS platform you are on.<br>&gt; <br>&gt; 2. The OS platform libraries are divided up, virtually if necessary, to expose the underlying standard interfaces without platform-specific extensions. I imagine that would look similar to https://gist.github.com/dwaite/c7125680def834e93ba1fae8873ce1f8: &lt;https://gist.github.com/dwaite/c7125680def834e93ba1fae8873ce1f8:&gt;<br>I think that it is also important to ask what the real goal here is.  Foundation is our cross platform compatibility layer, are there specific deficiencies in the Foundation API that cause a problem here, or is it just that not all of corelibs Foundation is “done” yet?<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/8bc482e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e1086eadc88de1e47fbffca9a73fd82?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Stuart Carnie</string> &lt;stuart.carnie at gmail.com&gt;<p>July  8, 2016 at 09:00:00am</p></header><div class="content"><p>I would like to add my vote for pushing Foundation as a cross-platform<br>compatibility layer, rather than exposing &quot;Libc&quot;. Naturally there is<br>flexibility in designing the APIs to be appropriately Swifty. I would also<br>like to see higher level concepts available via Foundation, like protocols<br>for streams (Readers, Writers, etc) and implementations for files, sockets,<br>compression, encryption, etc. Protocols oriented design will shine. I think<br>the Go standard library would serve as inspiration for some of the design,<br>such as the io package.<br></p><p>Cheers,<br></p><p>Stu<br></p><p><br>*Stuart Carnie*<br></p><p>On Thu, Jul 7, 2016 at 3:38 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 6, 2016, at 4:35 PM, David Waite &lt;david at alkaline-solutions.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I see two possible approaches:<br>&gt;<br>&gt; 1. A “import Libc” imports the platform libraries, whatever they may be,<br>&gt; on the OS platform you are on.<br>&gt;<br>&gt; 2. The OS platform libraries are divided up, virtually if necessary, to<br>&gt; expose the underlying standard interfaces without platform-specific<br>&gt; extensions. I imagine that would look similar to<br>&gt; https://gist.github.com/dwaite/c7125680def834e93ba1fae8873ce1f8:<br>&gt;<br>&gt;<br>&gt; I think that it is also important to ask what the real goal here is.<br>&gt; Foundation is our cross platform compatibility layer, are there specific<br>&gt; deficiencies in the Foundation API that cause a problem here, or is it just<br>&gt; that not all of corelibs Foundation is “done” yet?<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/a0e38427/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>September 13, 2016 at 03:00:00pm</p></header><div class="content"><p>Resurrecting this discussion since the question of &quot;why does Android import<br>Glibc?&quot; came up on this swift-corelibs-foundation pull request:<br>https://github.com/apple/swift-corelibs-foundation/pull/622#discussion_r77848100<br></p><p>I think that it is also important to ask what the real goal here is.<br>&gt; Foundation is our cross platform compatibility layer, are there specific<br>&gt; deficiencies in the Foundation API that cause a problem here, or is it just<br>&gt; that not all of corelibs Foundation is “done” yet?<br>&gt;<br></p><p>When I first proposed the idea, I simply wanted to turn these five lines:<br></p><p>    #if os(Linux) || os(FreeBSD) || os(Android) || os(PS4)<br>        import Glibc<br>    #else<br>        import Darwin<br>    #endif<br></p><p>Into this one line:<br></p><p>    import WhateverNameWeDecideUpon<br></p><p>After all, writing five lines of code for the import is painful, and the<br>list of `#if os(...) || os(...) || ...` is always expanding.<br></p><p>I hadn&#39;t thought about a unified overlay for POSIX. I think the simplified<br>import alone has benefit to warrant its own evolution proposal. Would it be<br>possible to have a separate discussion for the POSIX overlay idea? Or is<br>there a reason that I&#39;m missing that prevents the import from being viable<br>on its own? (Apologies in advance if there&#39;s an obvious answer to this<br>question!)<br></p><p>- Brian Gesiak<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160913/396feb5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>September 14, 2016 at 01:00:00pm</p></header><div class="content"><p>Vapor&#39;s Core package expresses a target called simply &#39;libc&#39;:<br></p><p>https://github.com/vapor/core/blob/master/Sources/libc/libc.swift &lt;https://github.com/vapor/core/blob/master/Sources/libc/libc.swift&gt;<br></p><p>As a result, their Swift files simply say &quot;import libc&quot;<br></p><p>https://github.com/vapor/core/blob/master/Sources/Core/Lock.swift<br></p><p>Alex<br></p><p>&gt; On 13 Sep 2016, at 20:29, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Resurrecting this discussion since the question of &quot;why does Android import Glibc?&quot; came up on this swift-corelibs-foundation pull request: https://github.com/apple/swift-corelibs-foundation/pull/622#discussion_r77848100 &lt;https://github.com/apple/swift-corelibs-foundation/pull/622#discussion_r77848100&gt;<br>&gt; <br>&gt; I think that it is also important to ask what the real goal here is.  Foundation is our cross platform compatibility layer, are there specific deficiencies in the Foundation API that cause a problem here, or is it just that not all of corelibs Foundation is “done” yet?<br>&gt; <br>&gt; When I first proposed the idea, I simply wanted to turn these five lines:<br>&gt; <br>&gt;     #if os(Linux) || os(FreeBSD) || os(Android) || os(PS4)<br>&gt;         import Glibc<br>&gt;     #else<br>&gt;         import Darwin<br>&gt;     #endif<br>&gt; <br>&gt; Into this one line:<br>&gt; <br>&gt;     import WhateverNameWeDecideUpon<br>&gt; <br>&gt; After all, writing five lines of code for the import is painful, and the list of `#if os(...) || os(...) || ...` is always expanding.<br>&gt; <br>&gt; I hadn&#39;t thought about a unified overlay for POSIX. I think the simplified import alone has benefit to warrant its own evolution proposal. Would it be possible to have a separate discussion for the POSIX overlay idea? Or is there a reason that I&#39;m missing that prevents the import from being viable on its own? (Apologies in advance if there&#39;s an obvious answer to this question!)<br>&gt; <br>&gt; - Brian Gesiak<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160914/9fd8c93c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>October  5, 2016 at 02:00:00pm</p></header><div class="content"><p>There is also a similar intent for Zewo’s POSIX:<br></p><p>https://github.com/Zewo/POSIX/blob/master/Sources/POSIX<br></p><p>It would be great to have something included with Swift.<br></p><p><br>&gt; On Sep 14, 2016, at 5:59 AM, Alex Blewitt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Vapor&#39;s Core package expresses a target called simply &#39;libc&#39;:<br>&gt; <br>&gt; https://github.com/vapor/core/blob/master/Sources/libc/libc.swift &lt;https://github.com/vapor/core/blob/master/Sources/libc/libc.swift&gt;<br>&gt; <br>&gt; As a result, their Swift files simply say &quot;import libc&quot;<br>&gt; <br>&gt; https://github.com/vapor/core/blob/master/Sources/Core/Lock.swift &lt;https://github.com/vapor/core/blob/master/Sources/Core/Lock.swift&gt;<br>&gt; <br>&gt; Alex<br>&gt; <br>&gt;&gt; On 13 Sep 2016, at 20:29, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Resurrecting this discussion since the question of &quot;why does Android import Glibc?&quot; came up on this swift-corelibs-foundation pull request: https://github.com/apple/swift-corelibs-foundation/pull/622#discussion_r77848100 &lt;https://github.com/apple/swift-corelibs-foundation/pull/622#discussion_r77848100&gt;<br>&gt;&gt; <br>&gt;&gt; I think that it is also important to ask what the real goal here is.  Foundation is our cross platform compatibility layer, are there specific deficiencies in the Foundation API that cause a problem here, or is it just that not all of corelibs Foundation is “done” yet?<br>&gt;&gt; <br>&gt;&gt; When I first proposed the idea, I simply wanted to turn these five lines:<br>&gt;&gt; <br>&gt;&gt;     #if os(Linux) || os(FreeBSD) || os(Android) || os(PS4)<br>&gt;&gt;         import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;         import Darwin<br>&gt;&gt;     #endif<br>&gt;&gt; <br>&gt;&gt; Into this one line:<br>&gt;&gt; <br>&gt;&gt;     import WhateverNameWeDecideUpon<br>&gt;&gt; <br>&gt;&gt; After all, writing five lines of code for the import is painful, and the list of `#if os(...) || os(...) || ...` is always expanding.<br>&gt;&gt; <br>&gt;&gt; I hadn&#39;t thought about a unified overlay for POSIX. I think the simplified import alone has benefit to warrant its own evolution proposal. Would it be possible to have a separate discussion for the POSIX overlay idea? Or is there a reason that I&#39;m missing that prevents the import from being viable on its own? (Apologies in advance if there&#39;s an obvious answer to this question!)<br>&gt;&gt; <br>&gt;&gt; - Brian Gesiak<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161005/8b1b9347/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 13, 2016, at 12:29 PM, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I hadn&#39;t thought about a unified overlay for POSIX. I think the simplified import alone has benefit to warrant its own evolution proposal. Would it be possible to have a separate discussion for the POSIX overlay idea? Or is there a reason that I&#39;m missing that prevents the import from being viable on its own? (Apologies in advance if there&#39;s an obvious answer to this question!)<br></p><p>I&#39;ve heard the argument before that we should do a full overlay, but I think this is becoming a case of the perfect being the enemy of the good. Having some sort of &quot;just import whatever the system libc is called&quot; module would be a significant improvement in practice over the state of the art, even if we don&#39;t do any other adaptation.<br></p><p>Here&#39;s what I would suggest. We have a convention for exposing &quot;raw&quot; imports of C libraries: you call them `C\(libraryName)`. So I would suggest we introduce a `CLibc` module which provides a raw import of the system&#39;s libc. If we later decide to do a full-featured overlay, that&#39;s great—we can call it `Libc`. But `CLibc` by itself would be an improvement over the status quo and a step in the right direction.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  5, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Oct 5, 2016 at 5:57 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Sep 13, 2016, at 12:29 PM, Brian Gesiak via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I hadn&#39;t thought about a unified overlay for POSIX. I think the<br>&gt; simplified import alone has benefit to warrant its own evolution proposal.<br>&gt; Would it be possible to have a separate discussion for the POSIX overlay<br>&gt; idea? Or is there a reason that I&#39;m missing that prevents the import from<br>&gt; being viable on its own? (Apologies in advance if there&#39;s an obvious answer<br>&gt; to this question!)<br>&gt;<br>&gt; I&#39;ve heard the argument before that we should do a full overlay, but I<br>&gt; think this is becoming a case of the perfect being the enemy of the good.<br>&gt; Having some sort of &quot;just import whatever the system libc is called&quot; module<br>&gt; would be a significant improvement in practice over the state of the art,<br>&gt; even if we don&#39;t do any other adaptation.<br>&gt;<br>&gt; Here&#39;s what I would suggest. We have a convention for exposing &quot;raw&quot;<br>&gt; imports of C libraries: you call them `C\(libraryName)`. So I would suggest<br>&gt; we introduce a `CLibc` module which provides a raw import of the system&#39;s<br>&gt; libc. If we later decide to do a full-featured overlay, that&#39;s great—we can<br>&gt; call it `Libc`. But `CLibc` by itself would be an improvement over the<br>&gt; status quo and a step in the right direction.<br>&gt;<br></p><p>I do believe that an even terser name has been suggested in the past for<br>libc, to avoid the repetition: just `C`.<br></p><p><br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161005/58732743/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>October  5, 2016 at 05:00:00pm</p></header><div class="content"><p>If we are pulling in functions/structures not defined by the C standard library or by POSIX, I’d be reluctant to support a standard name. It would be troublesome if someone thought that they were cross-platform but turned out to use strfry() heavily<br></p><p>I certainly wonder what people specifically want to bring the C standard library or POSIX libraries in for - is it compatibility with third party libraries? Functionality missing in Foundation?<br></p><p>-DW<br></p><p>&gt; On Oct 5, 2016, at 4:57 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 13, 2016, at 12:29 PM, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I hadn&#39;t thought about a unified overlay for POSIX. I think the simplified import alone has benefit to warrant its own evolution proposal. Would it be possible to have a separate discussion for the POSIX overlay idea? Or is there a reason that I&#39;m missing that prevents the import from being viable on its own? (Apologies in advance if there&#39;s an obvious answer to this question!)<br>&gt; <br>&gt; I&#39;ve heard the argument before that we should do a full overlay, but I think this is becoming a case of the perfect being the enemy of the good. Having some sort of &quot;just import whatever the system libc is called&quot; module would be a significant improvement in practice over the state of the art, even if we don&#39;t do any other adaptation.<br>&gt; <br>&gt; Here&#39;s what I would suggest. We have a convention for exposing &quot;raw&quot; imports of C libraries: you call them `C\(libraryName)`. So I would suggest we introduce a `CLibc` module which provides a raw import of the system&#39;s libc. If we later decide to do a full-featured overlay, that&#39;s great—we can call it `Libc`. But `CLibc` by itself would be an improvement over the status quo and a step in the right direction.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  5, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Oct 5, 2016 at 6:14 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If we are pulling in functions/structures not defined by the C standard<br>&gt; library or by POSIX, I’d be reluctant to support a standard name. It would<br>&gt; be troublesome if someone thought that they were cross-platform but turned<br>&gt; out to use strfry() heavily<br>&gt;<br>&gt; I certainly wonder what people specifically want to bring the C standard<br>&gt; library or POSIX libraries in for - is it compatibility with third party<br>&gt; libraries? Functionality missing in Foundation?<br>&gt;<br></p><p>To throw one use case out there, it&#39;s used extensively in<br>corelibs-foundation itself.<br></p><p><br>&gt; -DW<br>&gt;<br>&gt; &gt; On Oct 5, 2016, at 4:57 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Sep 13, 2016, at 12:29 PM, Brian Gesiak via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I hadn&#39;t thought about a unified overlay for POSIX. I think the<br>&gt; simplified import alone has benefit to warrant its own evolution proposal.<br>&gt; Would it be possible to have a separate discussion for the POSIX overlay<br>&gt; idea? Or is there a reason that I&#39;m missing that prevents the import from<br>&gt; being viable on its own? (Apologies in advance if there&#39;s an obvious answer<br>&gt; to this question!)<br>&gt; &gt;<br>&gt; &gt; I&#39;ve heard the argument before that we should do a full overlay, but I<br>&gt; think this is becoming a case of the perfect being the enemy of the good.<br>&gt; Having some sort of &quot;just import whatever the system libc is called&quot; module<br>&gt; would be a significant improvement in practice over the state of the art,<br>&gt; even if we don&#39;t do any other adaptation.<br>&gt; &gt;<br>&gt; &gt; Here&#39;s what I would suggest. We have a convention for exposing &quot;raw&quot;<br>&gt; imports of C libraries: you call them `C\(libraryName)`. So I would suggest<br>&gt; we introduce a `CLibc` module which provides a raw import of the system&#39;s<br>&gt; libc. If we later decide to do a full-featured overlay, that&#39;s great—we can<br>&gt; call it `Libc`. But `CLibc` by itself would be an improvement over the<br>&gt; status quo and a step in the right direction.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161005/ecad9e6f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 5, 2016, at 4:14 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; I certainly wonder what people specifically want to bring the C standard library or POSIX libraries in for - is it compatibility with third party libraries? Functionality missing in Foundation?<br></p><p>I see a number of reasons:<br></p><p>	1. Accessing functionality not present in Foundation.<br></p><p>		a. Using subsystems completely omitted in Foundation (e.g. C strings).<br></p><p>		b. Taking finer-grained control of features than Foundation permits.<br></p><p>		c. Using platform-specific features you can&#39;t expect Foundation to support (e.g. random ioctls).<br></p><p>	2. Avoiding overhead introduced by Foundation abstractions.<br></p><p>	3. Porting code currently written with libc.<br></p><p>	4. Interoperating with code that uses libc data types (e.g. an embedded HTTP server written in C which uses C-level sockets).<br></p><p>	5. Implementing Foundation itself, or implementing systems that are lower level than Foundation.<br></p><p>The bottom line is, there are a lot of reasons why you might want to work with a lower-level API instead of a higher-level one. Foundation is great, but it&#39;s not practical to say that if Foundation isn&#39;t doing the job for you, the answer is to improve Foundation—especially since Corelibs Foundation is trying to match a proprietary Apple Foundation which is entirely outside community control.<br></p><p>A CLibc module (or whatever you want to call it) is a simple and practical solution that doesn&#39;t preclude future improvements in Foundation or in presenting libc in a more Swifty form in the future. In fact, I believe Foundation and Swift-style libc modules would end up using CLibc.<br></p><p>Now, as for naming: I like using the leading &quot;C&quot; convention because it leaves us room for introducing an overlaid version of the module in the future without breaking source compatibility. Because of this, I wouldn&#39;t want to name the module just `C`, because it wouldn&#39;t leave room for a Swifty version later.<br></p><p>If we don&#39;t want to use words like `Libc` or `POSIX` because the module will import nonstandard APIs too, then I would suggest using `Platform`, or more specifically `CPlatform` for the non-overlaid version. This would make it clear that you&#39;re importing platform-provided capabilities, not something provided by Swift. It also implies that some APIs might be platform-specific, so you have at least a hint that you may be below the layers where libraries will abstract away platform differences for you. And the word `Platform` is vague about layering, whereas a name like `OS` might sometimes be inaccurate (&quot;but this call isn&#39;t in the OS, it&#39;s in the C library!&quot;).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>October  5, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Oct 5, 2016, at 6:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Now, as for naming: I like using the leading &quot;C&quot; convention (&quot;CLibc&quot;) because it leaves us room for introducing an overlaid version of the module in the future without breaking source compatibility. Because of this, I wouldn&#39;t want to name the module just `C`, because it wouldn&#39;t leave room for a Swifty version later.<br></p><p>I don&#39;t think separating the raw C library translation from the pretty Swift wrapper works, at least not for everybody. The problem is that the raw translation is going to have functions that the pretty wrapper does not. (Perhaps the pretty wrapper is new and incomplete. Perhaps an OS has added functions and the pretty wrapper has not caught up yet.)  If you try to import both then you end up with the same problems of name collisions today and source incompatibility in the future when the pretty wrapper grows.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161005/c503811e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Oct 5, 2016, at 7:08 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; Now, as for naming: I like using the leading &quot;C&quot; convention (&quot;CLibc&quot;) because it leaves us room for introducing an overlaid version of the module in the future without breaking source compatibility. Because of this, I wouldn&#39;t want to name the module just `C`, because it wouldn&#39;t leave room for a Swifty version later.<br>&gt; <br>&gt; I don&#39;t think separating the raw C library translation from the pretty Swift wrapper works, at least not for everybody. The problem is that the raw translation is going to have functions that the pretty wrapper does not. (Perhaps the pretty wrapper is new and incomplete. Perhaps an OS has added functions and the pretty wrapper has not caught up yet.)  If you try to import both then you end up with the same problems of name collisions today and source incompatibility in the future when the pretty wrapper grows.<br></p><p>I didn&#39;t mean that you could import both—merely that, if you used CLibc (or CPlatform) today, the introduction of the pretty Libc or Platform in a future version of Swift wouldn&#39;t affect your existing code.<br></p><p>As for handing unsupported features, I&#39;d like you to be able to say something like (using a version of today&#39;s syntax):<br></p><p>	import Platform<br>	import func CPlatform.newfunc(_:_:)<br></p><p>Which would hopefully mean that, if a future version of Libc added newfunc(_:_:), the CLibc version—which is the one we explicitly requested—would shadow it. (Perhaps when you rebuilt against the newer version of Libc, you&#39;d get a shadowing warning that would hint to you that you don&#39;t need to pull that function in from CLibc anymore.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  5, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, Oct 5, 2016 at 10:47 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Oct 5, 2016, at 7:08 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; Now, as for naming: I like using the leading &quot;C&quot; convention (&quot;CLibc&quot;)<br>&gt; because it leaves us room for introducing an overlaid version of the module<br>&gt; in the future without breaking source compatibility. Because of this, I<br>&gt; wouldn&#39;t want to name the module just `C`, because it wouldn&#39;t leave room<br>&gt; for a Swifty version later.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t think separating the raw C library translation from the pretty<br>&gt; Swift wrapper works, at least not for everybody. The problem is that the<br>&gt; raw translation is going to have functions that the pretty wrapper does<br>&gt; not. (Perhaps the pretty wrapper is new and incomplete. Perhaps an OS has<br>&gt; added functions and the pretty wrapper has not caught up yet.)  If you try<br>&gt; to import both then you end up with the same problems of name collisions<br>&gt; today and source incompatibility in the future when the pretty wrapper<br>&gt; grows.<br>&gt;<br>&gt; I didn&#39;t mean that you could import both—merely that, if you used CLibc<br>&gt; (or CPlatform) today, the introduction of the pretty Libc or Platform in a<br>&gt; future version of Swift wouldn&#39;t affect your existing code.<br>&gt;<br>&gt; As for handing unsupported features, I&#39;d like you to be able to say<br>&gt; something like (using a version of today&#39;s syntax):<br>&gt;<br>&gt;         import Platform<br>&gt;         import func CPlatform.newfunc(_:_:)<br>&gt;<br>&gt; Which would hopefully mean that, if a future version of Libc added<br>&gt; newfunc(_:_:), the CLibc version—which is the one we explicitly<br>&gt; requested—would shadow it. (Perhaps when you rebuilt against the newer<br>&gt; version of Libc, you&#39;d get a shadowing warning that would hint to you that<br>&gt; you don&#39;t need to pull that function in from CLibc anymore.)<br>&gt;<br></p><p>See, I&#39;d assumed that the &quot;unified&quot; Darwin/Glibc would simply be what you<br>call Platform. And if we&#39;re going to have that overlay, what&#39;s the point of<br>also renaming Darwin/Glibc to CPlatform, given that it&#39;s going to be<br>different between platforms, and given that what&#39;s not going to be in the<br>Platform overlay is much more likely to be the divergent bits?<br></p><p><br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161005/fd940ddb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 5, 2016, at 8:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; See, I&#39;d assumed that the &quot;unified&quot; Darwin/Glibc would simply be what you call Platform. And if we&#39;re going to have that overlay, what&#39;s the point of also renaming Darwin/Glibc to CPlatform, given that it&#39;s going to be different between platforms, and given that what&#39;s not going to be in the Platform overlay is much more likely to be the divergent bits?<br></p><p>The difference I imagine between `Platform` and `CPlatform` is that `Platform` would do things like:<br></p><p>* Convert `errno`-setting functions to throwing functions.<br>* Convert many returns by pointer parameter into tuple returns.<br>* Encapsulate certain structures, like `FILE` and `sockaddr`, which are really awkward to use in Swift.<br>* Organize free-floating constants into enums.<br>* Possibly move some operations from free functions to methods.<br></p><p>Whereas `CPlatform` would be basically a straight import of the C libraries, warts and all.<br></p><p>I don&#39;t actually imagine that `Platform` would do much platform abstraction except in trivial cases, like the ones currently in stdlib/public/Platform/Misc.c.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>October  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 6 Oct 2016, at 03:08, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 5, 2016, at 6:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Now, as for naming: I like using the leading &quot;C&quot; convention (&quot;CLibc&quot;) because it leaves us room for introducing an overlaid version of the module in the future without breaking source compatibility. Because of this, I wouldn&#39;t want to name the module just `C`, because it wouldn&#39;t leave room for a Swifty version later.<br>&gt; <br>&gt; I don&#39;t think separating the raw C library translation from the pretty Swift wrapper works, at least not for everybody. The problem is that the raw translation is going to have functions that the pretty wrapper does not.<br>&gt; (Perhaps the pretty wrapper is new and incomplete. Perhaps an OS has added functions and the pretty wrapper has not caught up yet.)<br></p><p>Surely you have just outlined the reason why the ability to import the raw C library is absolutely essential.<br></p><p><br>&gt;  If you try to import both then you end up with the same problems of name collisions today and source incompatibility in the future when the pretty wrapper grows.<br></p><p>To me this reads like you are claiming we can’t have the full capability of a C library now because one day in the future it *might* cause a problem.<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October  5, 2016 at 10:00:00pm</p></header><div class="content"><p>On Oct 5, 2016, at 3:57 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; On Sep 13, 2016, at 12:29 PM, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I hadn&#39;t thought about a unified overlay for POSIX. I think the simplified import alone has benefit to warrant its own evolution proposal. Would it be possible to have a separate discussion for the POSIX overlay idea? Or is there a reason that I&#39;m missing that prevents the import from being viable on its own? (Apologies in advance if there&#39;s an obvious answer to this question!)<br>&gt; <br>&gt; I&#39;ve heard the argument before that we should do a full overlay, but I think this is becoming a case of the perfect being the enemy of the good. Having some sort of &quot;just import whatever the system libc is called&quot; module would be a significant improvement in practice over the state of the art, even if we don&#39;t do any other adaptation.<br></p><p>I’ve come around to agree with this position.  I think it makes sense to have a cross platform “libc” which is an alias for darwin, glibc, or whatever, and just leave it at that.<br></p><p>Other proposals for a “POSIX” module have gotten bogged down because inevitably the idea comes up to make the resultant API nicer in various ways: rename creat, handle errno more nicely, make use of multiple return values, … etc.  The problem with this approach is that we don’t *want* people using these layer of APIs, we want higher level Foundation-like APIs to be used.<br></p><p>That’s why I think the best way to split the difference is to do as you suggest.  This allows the implementation of Foundation (and similar level of APIs) to be nicer, but not get bogged down trying to figure out how to clean up POSIX.<br></p><p>&gt; Here&#39;s what I would suggest. We have a convention for exposing &quot;raw&quot; imports of C libraries: you call them `C\(libraryName)`. So I would suggest we introduce a `CLibc` module which provides a raw import of the system&#39;s libc. If we later decide to do a full-featured overlay, that&#39;s great—we can call it `Libc`. But `CLibc` by itself would be an improvement over the status quo and a step in the right direction.<br></p><p>I think we should formally decide that a “nice” wrapper for libc is a non-goal.  There is too much that doesn’t make sense to wrap at this level - the only Swift code that should be using this is the implementation of higher level API, and such extremely narrow cases that we can live with them having to handle the problems of dealing with the raw APIs directly.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Unify &quot;import Darwin/Glibc&quot; to simply &quot;Libc&quot;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  7, 2016 at 08:00:00am</p></header><div class="content"><p>It looks like there are 2 views being discussed<br></p><p>Import System : just masks the difference in platform specific names<br>Import Libc : a true attempt at a swift specific view of credible c runtime equivalent<br></p><p>The first one would be easy to do now and would alleviate all the mindless #if...#endif we have today.<br></p><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jul 6, 2016, at 1:13 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 2:59 PM, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry to resurrect such an old thread! I understand getting this in Swift 3.0 might not be realistic anymore, but this is still something I’d love to see added to Swift. Could someone advise on whether it still makes sense to spend time on this proposal? Or is this part of Swift too solidified to change at this point?<br>&gt;&gt; <br>&gt; It is definitely beyond Swift 3.0, but I’d love to see this happen at some point, we really need someone to drive the (surely to be contentious) design process.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; How much would Libc include? The standard C library? POSIX?<br>&gt;&gt; <br>&gt;&gt; Yes, I had originally anticipated this as including module C and module POSIX. I see that module CUUID was recently added as well, but I don’t think that should be included.<br>&gt;&gt; <br>&gt;&gt; there are differences (minor, but still) between Glibc and Darwin. Those should be either unified (if possible) or re-arranged so that the unified library shares unified functionality and then each separate one can have its own set of caveats.<br>&gt;&gt; <br>&gt;&gt; I don’t think the unified import C module should do anything besides obviate the need to write the following:<br>&gt;&gt; <br>&gt;&gt; #if os(Linux) || os(FreeBSD)<br>&gt;&gt;     import Glibc<br>&gt;&gt; #else<br>&gt;&gt;     import Darwin<br>&gt;&gt; #endif<br>&gt;&gt; If people feel strongly about unifying the overlay, perhaps we should discuss that in future swift-evolution proposals.<br>&gt;&gt; <br>&gt;&gt; Personally, I like “import C”, but at the end of the day I’m happy to call it whatever as long as it solves the problem.<br>&gt;&gt; <br>&gt;&gt; I couldn’t have said it better myself!<br>&gt;&gt; <br>&gt;&gt; /cc Saleem, since he may have Windows opinions.<br>&gt;&gt; <br>&gt;&gt; - Brian Gesiak<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Mar 9, 2016 at 6:35 AM, Honza Dvorsky &lt;czechboy0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; A huge +1 on the proposal, I even have a code snippet to import the platform-appropriate C library. I try to write every new Swift library cross-platform-by-default now and this would definitely remove some friction. Not to mention it would future-proof many libraries which won&#39;t need to be updated when a new Swift platform is added.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I like &quot;import C&quot;, but at the end of the day I&#39;m happy to call it whatever as long as it solves the problem. I agree with Brian that with Swift scaling up to 4 or so platforms soon-ish, it&#39;s preferable to not put any extra burden on Swift users if there is an almost-uniform C API which can be used everywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Mar 9, 2016 at 2:03 AM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; One of the reasons we haven&#39;t picked this particular name is if the C or C++ committees ever adopted modules. Given that they just got punted from C++17, though, maybe that shouldn&#39;t hold us back.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 8, 2016, at 11:13, Brian Gesiak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Currently, cross-platform Swift programs that rely on symbols defined in libc (`fputs`, `stderr`, etc.) must all write the same five lines of boilerplate code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;&gt;&gt;&gt;         import Glibc<br>&gt;&gt;&gt;&gt;&gt;     #else<br>&gt;&gt;&gt;&gt;&gt;         import Darwin<br>&gt;&gt;&gt;&gt;&gt;     #endif<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Instead, I propose the following, which will work on all platforms:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     import Libc<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let&#39;s say we wanted to write a program that, on any platform, would print &quot;Hello world!&quot; to stderr. We&#39;d probably come up with this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     #if os(Linux) || os(FreeBSD)<br>&gt;&gt;&gt;&gt;&gt;         import Glibc<br>&gt;&gt;&gt;&gt;&gt;     #else<br>&gt;&gt;&gt;&gt;&gt;         import Darwin<br>&gt;&gt;&gt;&gt;&gt;     #endif<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     fputs(&quot;Hello world!&quot;, stderr)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The first five lines of this program are necessary to import the symbols `fputs` and `stderr`. Five lines may not be much, but these come with significant drawbacks:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - They must be written in each source file that relies on libc, which is tedious.<br>&gt;&gt;&gt;&gt;&gt; - It is subject to frequent change. As Swift is ported to more platforms, that initial check must change to `#if os(Linux) || os(FreeBSD) || os(Windows) || os(Android)`, and so on. End users of Swift may not be actively involved in its development, and so may be surprised when the latest release suddenly necessitates more `os()` conditions.<br>&gt;&gt;&gt;&gt;&gt; - These combined force users to make a conscious decision to write cross-platform code--as opposed to simply writing Swift and have it work on other platforms seamlessly.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be preferable if people writing Swift did not need to check for the current `os()` in order to write code that works across platforms.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Instead of conditionally importing Darwin or Glibc, I propose the following:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     import Libc<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would import whichever libc implementation Swift was compiled with. For Ubuntu Linux releases, this would be Glibc. For OS X releases, this would be Darwin. For Android (coming soon in https://github.com/apple/swift/pull/1442), this would be Bionic.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This saves the end user from writing boilerplate code, and it isolates them from the rapid expansion of platforms on which Swift is able to be executed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This idea is not novel: the Swift package manager already defines a &quot;libc&quot; package that is essentially the boilerplate `os()` check above: https://github.com/apple/swift-package-manager/blob/master/Sources/libc/libc.swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, rather than determining which libc implementation to use at runtime (like SwiftPM does above), I propose we allow the Swift stdlib to be compiled with any arbitrary implementation of libc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s my understanding that the majority of this change would take place in the Swift build scripts and CMake modules. Similar to how those scripts export a module named &quot;Glibc&quot; on Linux (see stdlib/public/core/Glibc), this proposal could be implementing by exporting a &quot;Libc&quot; on all platforms.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would also be accompanied by a change to the Swift 3 migrator that could automatically convert conditional imports of Darwin/Glibc to the new `import Libc`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We must also devise a strategy for the transient rollout period, when Swift defines a Libc module, but we don&#39;t have an OS X SDK that uses that name in the bundled module.map. We can add a compiler hack for that, to transparently translate the name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I believe there are two contentious points to this proposal: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Whether to unify the module name across platforms.<br>&gt;&gt;&gt;&gt;&gt; 2. What to name the module.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives considered on point #1 (whether to unify) include:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1a. The status quo: I consider this to be undesirable for the reasons stated in &quot;Motivation&quot;. To reiterate: the current system forces users to go out of their way to write cross-platform Swift code, as opposed to writing code that &quot;just works&quot; everywhere.<br>&gt;&gt;&gt;&gt;&gt; 1b. The current Darwin and Glibc modules are a combination of POSIX and the C standard library. We could export *two* modules. However I believe this introduces additional overhead for users, with only the marginal benefit of clean separation between libc and POSIX.<br>&gt;&gt;&gt;&gt;&gt; 1c. A special import statement, defined in the Swift stdlib, that would automatically get preprocessed to the five lines of boilerplate shown above. This has several downsides, most notably the added complexity to Swift syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On point #2 (what to name it), I have spoken with people that raised concerns over the name &quot;Libc&quot;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; Another concern is about compatibility with the C++ modules proposal. If we want this module name to mean something, it should agree with the C++ spec.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know which name was chosen in the C++ spec. I&#39;ve been searching WG21 papers with no luck--any advice on how to find out would be appreciated!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Aside from the above point, some concrete alternatives for point #2 (what to name it) include:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - `import System`: This is better suited to the idea that the module contains both POSIX and libc.<br>&gt;&gt;&gt;&gt;&gt; - `import C`: Drop the &quot;Lib&quot;--just &quot;C&quot;. It&#39;s cleaner. (https://www.youtube.com/watch?v=PEgk2v6KntY)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for taking the time to read this proposal draft! Feedback (on its contents or on how to proceed with the evolution proposal process) is greatly appreciated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Brian Gesiak<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/fda14b22/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
