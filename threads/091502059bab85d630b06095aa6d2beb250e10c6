<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1.  This proposal looks really great to me.  I think it will add a lot of clarity to code that needs to work with unsafe pointers.  This is really important.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very much.  We should strive for clarity and prevent as much accidental misuse of unsafe constructs as possible while still enabling code that needs to work at low levels.  This proposal does a great job of this.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>This proposal introduces important distinctions in the type system that I haven’t seen elsewhere.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In depth study of the proposal and participation in the discussion.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt;&gt; * What is your evaluation of the proposal?<br></p><p>This is an excellent proposal, and a step forward in balancing safety and un-safety in an understandable way.<br></p><p>I have no issues about the substance, but two documentation issues:<br></p><p>- the compiler’s strict aliasing rules: not clearly defined in this document.<br>I *think* I know mostly what that means, but I’m not completely sure.<br></p><p>- so-called “trivial” types:<br>Coming from physics, where trivial means “not worthy of consideration” (an English dictionary concurs.)<br>It made me wonder why integers deserved such a putdown; the word “simple” would be just fine.<br>[y’ = y has solutions y(x) = e^x and y = 0; the latter is trivial as it generally isn’t interesting, despite being valid.]<br>It’s probably meant as “easily proven”, but since no proofs are shown, it feels like an inappropriate use.<br></p><p>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Absolutely.<br></p><p>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>I think so.<br></p><p>&gt;&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I’ve only done the kind of things enabled by this in C/C++, where it just feels like gambling. [feels like testing can only show that something works on one particular C/C++ compiler]. Clarity is good.<br></p><p>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve followed this discussion from the start, and asked questions. My interest was informed by experimental attempts to push the memory model; those attempts would have been covered by this document.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks for reviewing!<br></p><p>&gt; On Jun 30, 2016, at 9:37 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; This is an excellent proposal, and a step forward in balancing safety and un-safety in an understandable way.<br>&gt; <br>&gt; I have no issues about the substance, but two documentation issues:<br>&gt; <br>&gt; - the compiler’s strict aliasing rules: not clearly defined in this document.<br>&gt; I *think* I know mostly what that means, but I’m not completely sure.<br></p><p>That’s punted to a separate doc:<br></p><p>  For details of the compiler&#39;s rules for memory aliasing, see proposed Type Safe Memory Access documentation.<br>  https://github.com/atrick/swift/blob/type-safe-mem-docs/docs/TypeSafeMemory.rst<br></p><p>That document needs to be rewritten now, but should be good enough for discussion. It’s important to focus on the source-breaking aspect of the proposal now. The memory model spec will be rewritten and clarified as we go. There’s just a limited bandwidth for people to review these kind of specs, and there are actually no changes to the strict aliasing rules being proposed here!<br></p><p>I did recently add a simplified discussion about strict aliasing to the revised proposal, but it’s buried here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#initializing-memory-with-a-typed-pointer<br></p><p>I should create a link at the top.<br></p><p>&gt; - so-called “trivial” types:<br>&gt; Coming from physics, where trivial means “not worthy of consideration” (an English dictionary concurs.)<br>&gt; It made me wonder why integers deserved such a putdown; the word “simple” would be just fine.<br>&gt; [y’ = y has solutions y(x) = e^x and y = 0; the latter is trivial as it generally isn’t interesting, despite being valid.]<br>&gt; It’s probably meant as “easily proven”, but since no proofs are shown, it feels like an inappropriate use.<br></p><p>Point taken. That term is used throughout the implementation and was first officially documented here:<br>https://github.com/apple/swift/blob/master/docs/SIL.rst#properties-of-types<br></p><p>and again here:<br>https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#other-promises-about-types<br></p><p>-Andy<br></p><p>&gt; <br>&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Absolutely.<br>&gt; <br>&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; I think so.<br>&gt; <br>&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I’ve only done the kind of things enabled by this in C/C++, where it just feels like gambling. [feels like testing can only show that something works on one particular C/C++ compiler]. Clarity is good.<br>&gt; <br>&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I’ve followed this discussion from the start, and asked questions. My interest was informed by experimental attempts to push the memory model; those attempts would have been covered by this document.<br>&gt; <br>&gt; Cheers,<br>&gt; Guillaume Lessard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 This is an excellent change to make a fragile and tricky part of the language more explicit and correct by design.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Raw memory access in languages with strong static type systems has typically come with some kind of marshalling framework or there is a virtual machine in place to ensure some measure of consistency with foreign pointers.  Because we can make no such guarantees, this proposal provides an excellent middle ground:  A new type to encapsulate and mark old semantics plus new typed means of access if desired.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal a few times.<br></p><p>&gt; On Jun 28, 2016, at 9:05 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  2, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think this is basically a good design, but I have lots and lots of comments.<br></p><p>* * *<br></p><p>I have a pile of naming quibbles; rather than describe them all in prose (which turned into a mess), I&#39;ve annotated parts of the &quot;Full UnsafeRawPointer API&quot; section in a gist: &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;.<br></p><p>* * *<br></p><p>More concrete issues:<br></p><p>* Is there a reason there&#39;s a `load` that takes a byte offset, but not a `storeRaw`?<br></p><p>* I&#39;m also a little nervous about the fact that `storeRaw` (and `load`?) is documented to only work properly on &quot;trivial types&quot;, but it doesn&#39;t have any sort of constraints to ensure it&#39;s used correctly. (One could imagine, for instance, the compiler automatically conforming trivial types to a `Trivial` protocol.)<br></p><p>* I don&#39;t think I understand `initialize(toContiguous:atIndex:with:)`. Does it return a typed pointer to the whole buffer, or just the one instance it initialized? In the `stringFromBytes` example, shouldn&#39;t we either subscript the typed pointer from the previous `initialize(_:with:count:)` call, or call `storeRaw(toContiguous:atIndex:with:)`, rather than initializing memory twice? If this isn&#39;t a good use case for `initialize(toContiguous:atIndex:with:)`, what would be?<br></p><p>* * *<br></p><p>I&#39;m quite concerned by the &quot;moveInitialize should be more elegant&quot; section at the bottom.<br></p><p>Since the types are so close, `moveInitialize` could require mutating arguments and actually swap the pointers. For instance:<br></p><p>	func grow(buffer: UnsafePointer&lt;Int&gt;, count: Int, toNewCapacity capacity: Int) -&gt; UnsafeBuffer&lt;Int&gt; {<br>		var buffer = buffer<br>		var uninitializedBuffer = UnsafeRawPointer.allocate(capacity: capacity, of: Int.self)<br>		<br>		uninitializedBuffer.swapPointersAfterMoving(from: &amp;buffer, count: count)<br>		// `buffer` now points to the new allocation, filled in with the Ints.<br>		// `uninitializedBuffer` now points to the old allocation, which is deinitialized.<br>		<br>		uninitializedBuffer.deallocate()<br>		return buffer<br>	}<br></p><p>This is *such* a strange semantic, however, that I&#39;m not at all sure how to name this function.<br></p><p>`moveAssign(from:count:)` could do something much simpler, returning a raw version of `from`:<br></p><p>	target.moveAssign(from: source).deallocate()<br></p><p>`move()`, on the other hand, I don&#39;t see a good way to fix like this.<br></p><p>One ridiculous thing we could do for `moveAssign(from:count:)` and perhaps `move()` is to deliberately make `self` invalid by setting it to address 0. If it were `Optional`, this would nil `self`. If it weren&#39;t...well, something would probably fail eventually.<br></p><p>* * *<br></p><p>I notice that many APIs require type parameters merely to force the user to explicitly state the types involved. I wonder if we could instead introduce an attribute which you could place on a parameter or return type indicating that there must be an explicit `as` cast specifying its type:<br></p><p>	func storeRaw&lt;T&gt;(_: @explicit T)<br>	func load&lt;T&gt;() -&gt; @explicit T<br>	func cast&lt;T&gt;() -&gt; @explicit UnsafePointer&lt;T&gt;<br>	<br>	rawPointer.storeRaw(3 as Int)<br>	rawPointer.load() as Int<br>	rawPointer.cast() as UnsafePointer&lt;Int&gt;<br></p><p>This would also be useful on `unsafeBitCast`, and on user APIs which are prone to type inference issues.<br></p><p>* * * <br></p><p>In the long run, however, I wonder if we might end up removing `UnsafeRawPointer`. If `Never` becomes a subtype-of-all-types, then `UnsafePointer&lt;Never&gt;` would gain the basic properties of an `UnsafeRawPointer`:<br></p><p>* Because `Never` is a subtype of all types, `UnsafePointer&lt;Never&gt;` could alias any other pointer.<br></p><p>* Accessing `pointee` would be inherently invalid (it would either take or return a `Never`), and APIs which initialize or set `pointee` would be inherently uncallable.<br></p><p>* `Never` has no intrinsic size, so it could be treated as having a one-byte size, allowing APIs which normally allocate, deallocate, or do pointer arithmetic by instance size to automatically do so by byte size instead.<br></p><p>* APIs for casting an `UnsafePointer&lt;T&gt;` to `UnsafePointer&lt;supertype of T&gt;` or `&lt;subtype of T&gt;` would do the right thing with `UnsafePointer&lt;Never&gt;`.<br></p><p>Thus, I could imagine `Unsafe[Mutable]RawPointer` becoming `Unsafe[Mutable]Pointer&lt;Never&gt;` in the future, with some APIs being generalized and moving to all `UnsafePointer`s while others are in extensions on `UnsafePointer where Pointee == Never`.<br></p><p>It might be worth taking a look at the current API designs and thinking about how they would look in that world:<br></p><p>* Is `nsStringPtr.casting(to: UnsafePointer&lt;NSObject&gt;)` how you would want to write a pointee upcast? How about `UnsafePointer&lt;NSString&gt;(nsObjectPtr)` for a pointee downcast?<br></p><p>* Would you want `initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;` in the `Never` extension, or (with a supertype-of-Pointee constraint on `T`) would it be something you&#39;d put on other `UnsafeMutablePointer`s too? What does that mean for `UnsafeMutablePointer.initialize(with:)`?<br></p><p>* Are `load` or `storeRaw` things that might make sense on any `UnsafeMutablePointer` if they were constrained to supertypes only?<br></p><p>* Are there APIs which are basically the same on `Unsafe[Mutable]Pointer`s and their `Raw` equivalents, except that the `Raw` versions are &quot;dumb&quot; because they don&#39;t know what type they&#39;re operating on? If so, should they be given the same name?<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Even in the realm of Unsafe types, we don&#39;t want undefined behavior with no way to define it.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. Nailing things down is important.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Need I mention how bizarre and arbitrary C pointers are?<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve put in a fair few hours on this post, but even so, there are parts of the proposal that I really haven&#39;t looked at very deeply; I will admit I rarely work at such a low level and don&#39;t fully understand all of the technicalities involved.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  3, 2016 at 12:00:00am</p></header><div class="content"><p>Brent,<br></p><p>This is excellent feedback. I can tell that you paid close attention to the API details.<br></p><p>I’m in the middle of working on a revision to the proposal. I&#39;ll address your questions after I finish writing it up so that my answers make more sense. I’ll include most of your naming improvements in a separate revision that we can bikeshed on the list.<br></p><p>-Andy<br></p><p>&gt; On Jul 2, 2016, at 8:10 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I think this is basically a good design, but I have lots and lots of comments.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; I have a pile of naming quibbles; rather than describe them all in prose (which turned into a mess), I&#39;ve annotated parts of the &quot;Full UnsafeRawPointer API&quot; section in a gist: &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; More concrete issues:<br>&gt; <br>&gt; * Is there a reason there&#39;s a `load` that takes a byte offset, but not a `storeRaw`?<br>&gt; <br>&gt; * I&#39;m also a little nervous about the fact that `storeRaw` (and `load`?) is documented to only work properly on &quot;trivial types&quot;, but it doesn&#39;t have any sort of constraints to ensure it&#39;s used correctly. (One could imagine, for instance, the compiler automatically conforming trivial types to a `Trivial` protocol.)<br>&gt; <br>&gt; * I don&#39;t think I understand `initialize(toContiguous:atIndex:with:)`. Does it return a typed pointer to the whole buffer, or just the one instance it initialized? In the `stringFromBytes` example, shouldn&#39;t we either subscript the typed pointer from the previous `initialize(_:with:count:)` call, or call `storeRaw(toContiguous:atIndex:with:)`, rather than initializing memory twice? If this isn&#39;t a good use case for `initialize(toContiguous:atIndex:with:)`, what would be?<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; I&#39;m quite concerned by the &quot;moveInitialize should be more elegant&quot; section at the bottom.<br>&gt; <br>&gt; Since the types are so close, `moveInitialize` could require mutating arguments and actually swap the pointers. For instance:<br>&gt; <br>&gt; 	func grow(buffer: UnsafePointer&lt;Int&gt;, count: Int, toNewCapacity capacity: Int) -&gt; UnsafeBuffer&lt;Int&gt; {<br>&gt; 		var buffer = buffer<br>&gt; 		var uninitializedBuffer = UnsafeRawPointer.allocate(capacity: capacity, of: Int.self)<br>&gt; 		<br>&gt; 		uninitializedBuffer.swapPointersAfterMoving(from: &amp;buffer, count: count)<br>&gt; 		// `buffer` now points to the new allocation, filled in with the Ints.<br>&gt; 		// `uninitializedBuffer` now points to the old allocation, which is deinitialized.<br>&gt; 		<br>&gt; 		uninitializedBuffer.deallocate()<br>&gt; 		return buffer<br>&gt; 	}<br>&gt; <br>&gt; This is *such* a strange semantic, however, that I&#39;m not at all sure how to name this function.<br>&gt; <br>&gt; `moveAssign(from:count:)` could do something much simpler, returning a raw version of `from`:<br>&gt; <br>&gt; 	target.moveAssign(from: source).deallocate()<br>&gt; <br>&gt; `move()`, on the other hand, I don&#39;t see a good way to fix like this.<br>&gt; <br>&gt; One ridiculous thing we could do for `moveAssign(from:count:)` and perhaps `move()` is to deliberately make `self` invalid by setting it to address 0. If it were `Optional`, this would nil `self`. If it weren&#39;t...well, something would probably fail eventually.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; I notice that many APIs require type parameters merely to force the user to explicitly state the types involved. I wonder if we could instead introduce an attribute which you could place on a parameter or return type indicating that there must be an explicit `as` cast specifying its type:<br>&gt; <br>&gt; 	func storeRaw&lt;T&gt;(_: @explicit T)<br>&gt; 	func load&lt;T&gt;() -&gt; @explicit T<br>&gt; 	func cast&lt;T&gt;() -&gt; @explicit UnsafePointer&lt;T&gt;<br>&gt; 	<br>&gt; 	rawPointer.storeRaw(3 as Int)<br>&gt; 	rawPointer.load() as Int<br>&gt; 	rawPointer.cast() as UnsafePointer&lt;Int&gt;<br>&gt; <br>&gt; This would also be useful on `unsafeBitCast`, and on user APIs which are prone to type inference issues.<br>&gt; <br>&gt; * * * <br>&gt; <br>&gt; In the long run, however, I wonder if we might end up removing `UnsafeRawPointer`. If `Never` becomes a subtype-of-all-types, then `UnsafePointer&lt;Never&gt;` would gain the basic properties of an `UnsafeRawPointer`:<br>&gt; <br>&gt; * Because `Never` is a subtype of all types, `UnsafePointer&lt;Never&gt;` could alias any other pointer.<br>&gt; <br>&gt; * Accessing `pointee` would be inherently invalid (it would either take or return a `Never`), and APIs which initialize or set `pointee` would be inherently uncallable.<br>&gt; <br>&gt; * `Never` has no intrinsic size, so it could be treated as having a one-byte size, allowing APIs which normally allocate, deallocate, or do pointer arithmetic by instance size to automatically do so by byte size instead.<br>&gt; <br>&gt; * APIs for casting an `UnsafePointer&lt;T&gt;` to `UnsafePointer&lt;supertype of T&gt;` or `&lt;subtype of T&gt;` would do the right thing with `UnsafePointer&lt;Never&gt;`.<br>&gt; <br>&gt; Thus, I could imagine `Unsafe[Mutable]RawPointer` becoming `Unsafe[Mutable]Pointer&lt;Never&gt;` in the future, with some APIs being generalized and moving to all `UnsafePointer`s while others are in extensions on `UnsafePointer where Pointee == Never`.<br>&gt; <br>&gt; It might be worth taking a look at the current API designs and thinking about how they would look in that world:<br>&gt; <br>&gt; * Is `nsStringPtr.casting(to: UnsafePointer&lt;NSObject&gt;)` how you would want to write a pointee upcast? How about `UnsafePointer&lt;NSString&gt;(nsObjectPtr)` for a pointee downcast?<br>&gt; <br>&gt; * Would you want `initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;` in the `Never` extension, or (with a supertype-of-Pointee constraint on `T`) would it be something you&#39;d put on other `UnsafeMutablePointer`s too? What does that mean for `UnsafeMutablePointer.initialize(with:)`?<br>&gt; <br>&gt; * Are `load` or `storeRaw` things that might make sense on any `UnsafeMutablePointer` if they were constrained to supertypes only?<br>&gt; <br>&gt; * Are there APIs which are basically the same on `Unsafe[Mutable]Pointer`s and their `Raw` equivalents, except that the `Raw` versions are &quot;dumb&quot; because they don&#39;t know what type they&#39;re operating on? If so, should they be given the same name?<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes. Even in the realm of Unsafe types, we don&#39;t want undefined behavior with no way to define it.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes. Nailing things down is important.<br>&gt; <br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Need I mention how bizarre and arbitrary C pointers are?<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I&#39;ve put in a fair few hours on this post, but even so, there are parts of the proposal that I really haven&#39;t looked at very deeply; I will admit I rarely work at such a low level and don&#39;t fully understand all of the technicalities involved.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (initialize:with:)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  3, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 8:10 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have a pile of naming quibbles; rather than describe them all in prose (which turned into a mess), I&#39;ve annotated parts of the &quot;Full UnsafeRawPointer API&quot; section in a gist: &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;&gt;.<br>&gt; <br></p><p><br>Let&#39;s bikeshed this easy one now... I’m curious what others think:<br></p><p>  // In general, I think you &quot;initialize to&quot; a value, not <br>  // &quot;initialize with&quot; a value. &quot;with&quot; is needlessly vacuous.<br>  // <br>  // func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1)<br>  //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>  func initialize&lt;T&gt;(_: T.Type, to: T, count: Int = 1)<br>    -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>`initialize` was recently renamed to `initialized(with:)`.<br></p><p>commit d96b051d28b6042adcc8b8692a918abddf211aec<br>Author: Dave Abrahams &lt;dabrahams at apple.com&gt;<br>Date:   Tue Feb 23 15:12:24 2016 -0800<br></p><p>    stdlib: initializePointee(_) =&gt; initialize(with:)<br>    <br>    Tacking &quot;Pointee&quot; on just for unary operations (and especially<br>    operations with an optional count) created inconsistency.<br></p><p>So Swift 3 users have already migrated to this “better” name.<br></p><p>I agree that initialize(to:) is consistent with the language we use for assigning values. But grammatically, I think initialize(with:) also makes perfect sense and is just as common.<br></p><p>In general, if there’s controversy, I’ll stick with the existing conventions because there’s already enough to debate in this proposal.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160703/229a9541/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (initialize:with:)</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Being consistent with existing convention is good; I also agree it happens<br>to make perfect sense anyway.<br></p><p>On Sun, Jul 3, 2016 at 03:18 Andrew Trick via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 2, 2016, at 8:10 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have a pile of naming quibbles; rather than describe them all in prose<br>&gt; (which turned into a mess), I&#39;ve annotated parts of the &quot;Full<br>&gt; UnsafeRawPointer API&quot; section in a gist: &lt;<br>&gt; https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;.<br>&gt;<br>&gt;<br>&gt; Let&#39;s bikeshed this easy one now... I’m curious what others think:<br>&gt;<br>&gt;   // In general, I think you &quot;initialize to&quot; a value, not<br>&gt;   // &quot;initialize with&quot; a value. &quot;with&quot; is needlessly vacuous.<br>&gt;   //<br>&gt;   // func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1)<br>&gt;   //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   func initialize&lt;T&gt;(_: T.Type, to: T, count: Int = 1)<br>&gt;     -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;<br>&gt; `initialize` was recently renamed to `initialized(with:)`.<br>&gt;<br>&gt; commit d96b051d28b6042adcc8b8692a918abddf211aec<br>&gt; Author: Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; Date:   Tue Feb 23 15:12:24 2016 -0800<br>&gt;<br>&gt;     stdlib: initializePointee(_) =&gt; initialize(with:)<br>&gt;<br>&gt;<br>&gt;     Tacking &quot;Pointee&quot; on just for unary operations (and especially<br>&gt;     operations with an optional count) created inconsistency.<br>&gt;<br>&gt; So Swift 3 users have already migrated to this “better” name.<br>&gt;<br>&gt; I agree that initialize(to:) is consistent with the language we use for<br>&gt; assigning values. But grammatically, I think initialize(with:) also makes<br>&gt; perfect sense and is just as common.<br>&gt;<br>&gt; In general, if there’s controversy, I’ll stick with the existing<br>&gt; conventions because there’s already enough to debate in this proposal.<br>&gt;<br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160703/4036e74d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (initialize:with:)</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  5, 2016 at 05:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 3, 2016, at 10:18 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 2, 2016, at 8:10 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have a pile of naming quibbles; rather than describe them all in prose (which turned into a mess), I&#39;ve annotated parts of the &quot;Full UnsafeRawPointer API&quot; section in a gist: &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; Let&#39;s bikeshed this easy one now... I’m curious what others think:<br>&gt; <br>&gt;   // In general, I think you &quot;initialize to&quot; a value, not <br>&gt;   // &quot;initialize with&quot; a value. &quot;with&quot; is needlessly vacuous.<br>&gt;   // <br>&gt;   // func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1)<br>&gt;   //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   func initialize&lt;T&gt;(_: T.Type, to: T, count: Int = 1)<br>&gt;     -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt; <br>&gt; `initialize` was recently renamed to `initialized(with:)`.<br>&gt; <br>&gt; commit d96b051d28b6042adcc8b8692a918abddf211aec<br>&gt; Author: Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; Date:   Tue Feb 23 15:12:24 2016 -0800<br>&gt; <br>&gt;     stdlib: initializePointee(_) =&gt; initialize(with:)<br>&gt;     <br>&gt;     Tacking &quot;Pointee&quot; on just for unary operations (and especially<br>&gt;     operations with an optional count) created inconsistency.<br>&gt; <br>&gt; So Swift 3 users have already migrated to this “better” name.<br>&gt; <br>&gt; I agree that initialize(to:) is consistent with the language we use for assigning values. But grammatically, I think initialize(with:) also makes perfect sense and is just as common.<br></p><p>+1<br></p><p>&gt; <br>&gt; In general, if there’s controversy, I’ll stick with the existing conventions because there’s already enough to debate in this proposal.<br>&gt; <br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/f8abb0f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (initialize:with:)</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July  5, 2016 at 01:00:00pm</p></header><div class="content"><p>func initialize&lt;T&gt;(_: T.Type, to: T, count: Int = 1)<br>    -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>I wonder why the first parameter is needed. If one is passing literals,<br>it&#39;s always more Swift&#39;y to use &#39;as&#39;.<br></p><p>2016-07-05 6:00 GMT+03:00 L. Mihalkovic via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt;<br>&gt;<br>&gt; Regards<br>&gt; (From mobile)<br>&gt;<br>&gt; On Jul 3, 2016, at 10:18 AM, Andrew Trick via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 2, 2016, at 8:10 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have a pile of naming quibbles; rather than describe them all in prose<br>&gt; (which turned into a mess), I&#39;ve annotated parts of the &quot;Full<br>&gt; UnsafeRawPointer API&quot; section in a gist: &lt;<br>&gt; https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;.<br>&gt;<br>&gt;<br>&gt; Let&#39;s bikeshed this easy one now... I’m curious what others think:<br>&gt;<br>&gt;   // In general, I think you &quot;initialize to&quot; a value, not<br>&gt;   // &quot;initialize with&quot; a value. &quot;with&quot; is needlessly vacuous.<br>&gt;   //<br>&gt;   // func initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1)<br>&gt;   //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   func initialize&lt;T&gt;(_: T.Type, to: T, count: Int = 1)<br>&gt;     -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;<br>&gt; `initialize` was recently renamed to `initialized(with:)`.<br>&gt;<br>&gt; commit d96b051d28b6042adcc8b8692a918abddf211aec<br>&gt; Author: Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; Date:   Tue Feb 23 15:12:24 2016 -0800<br>&gt;<br>&gt;     stdlib: initializePointee(_) =&gt; initialize(with:)<br>&gt;<br>&gt;<br>&gt;     Tacking &quot;Pointee&quot; on just for unary operations (and especially<br>&gt;     operations with an optional count) created inconsistency.<br>&gt;<br>&gt; So Swift 3 users have already migrated to this “better” name.<br>&gt;<br>&gt; I agree that initialize(to:) is consistent with the language we use for<br>&gt; assigning values. But grammatically, I think initialize(with:) also makes<br>&gt; perfect sense and is just as common.<br>&gt;<br>&gt;<br>&gt; +1<br>&gt;<br>&gt;<br>&gt; In general, if there’s controversy, I’ll stick with the existing<br>&gt; conventions because there’s already enough to debate in this proposal.<br>&gt;<br>&gt; -Andy<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/44870fe4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (initialize:with:)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 5:26 AM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; func initialize&lt;T&gt;(_: T.Type, to: T, count: Int = 1)<br>&gt;     -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt; <br>&gt; I wonder why the first parameter is needed. If one is passing literals, it&#39;s always more Swift&#39;y to use &#39;as&#39;.<br></p><p><br>From the proposal:<br></p><p>---<br>The type parameter `T` passed to `initialize` is an explicit argument<br>because the user must reason about the type&#39;s size and alignment at<br>the point of initialization. Inferring the type from the value passed<br>to the second argument could result in miscompilation if the inferred<br>type ever deviates from the user&#39;s original expectations.<br>—<br></p><p>You can think of this as the “raw” API. With the latest proposal, it will be more common for users to initialize with a typed pointer anyway:<br></p><p>ptrToA.initialize(to: A())<br></p><p>-Andy<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API &quot;initialize(from:forwardToCount:)&quot;</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 10:10 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have a pile of naming quibbles; rather than describe them all in prose (which turned into a mess), I&#39;ve annotated parts of the &quot;Full UnsafeRawPointer API&quot; section in a gist: &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;&gt;.<br></p><p>I want to call this out separately because it’s not specific to my proposal and changes the existing UnsafePointer API.<br></p><p>Brent’s suggestion is to change `initialize(from:count:)` to `initialize(from:forwardToCount:)` for symmetry with the backward operations. It makes perfect sense to me, and it does a better job of conveying that a sequence of elements will be read out of “from”.<br></p><p>Any objections?<br></p><p>  // I&#39;m not happy with the asymmetry of these forwards/backwards <br>  // pairs.<br>  // <br>  // func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int)<br>  //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>  // func initializeBackward&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int)<br>  //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>  func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, forwardToCount: Int)<br>    -&gt; UnsafeMutablePointer&lt;T&gt;<br>  func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, backwardFromCount: Int)<br>    -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>  // More detailed thoughts on redesigining `move` methods in the <br>  // email, but for now:<br>  // <br>  // func moveInitialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int)<br>  //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>  // func moveInitializeBackward&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int)<br>  //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>  func moveInitialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, forwardToCount: Int)<br>    -&gt; UnsafeMutablePointer&lt;T&gt;<br>  func moveInitialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, backwardFromCount: Int)<br>    -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/12faa9c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API &quot;initialize(from:forwardToCount:)&quot;</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>I don&#39;t mind `initialize(from:forwardToCount:)`, but I do have trouble with<br>Brent&#39;s suggestion of `initialize(from:backwardFromCount:)`. It adds<br>ambiguity as to whether the pointer in the first argument points to the 0th<br>element or the (count - 1)th element from which initializing is proceeding<br>backward, a problem that does not exist with the currently proposed version<br>`initializeBackward(from:count:)`. I don&#39;t find the symmetry wins<br>compelling enough to overcome that additional ambiguity.<br></p><p><br>On Tue, Jul 5, 2016 at 10:23 Andrew Trick via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 2, 2016, at 10:10 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have a pile of naming quibbles; rather than describe them all in prose<br>&gt; (which turned into a mess), I&#39;ve annotated parts of the &quot;Full<br>&gt; UnsafeRawPointer API&quot; section in a gist: &lt;<br>&gt; https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;.<br>&gt;<br>&gt;<br>&gt; I want to call this out separately because it’s not specific to my<br>&gt; proposal and changes the existing UnsafePointer API.<br>&gt;<br>&gt; Brent’s suggestion is to change `initialize(from:count:)` to<br>&gt; `initialize(from:forwardToCount:)` for symmetry with the backward<br>&gt; operations. It makes perfect sense to me, and it does a better job of<br>&gt; conveying that a sequence of elements will be read out of “from”.<br>&gt;<br>&gt; Any objections?<br>&gt;<br>&gt;   // I&#39;m not happy with the asymmetry of these forwards/backwards<br>&gt;   // pairs.<br>&gt;   //<br>&gt;   // func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;   //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   // func initializeBackward&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;   //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, forwardToCount: Int)<br>&gt;     -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   func initialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, backwardFromCount: Int)<br>&gt;     -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;<br>&gt;   // More detailed thoughts on redesigining `move` methods in the<br>&gt;   // email, but for now:<br>&gt;   //<br>&gt;   // func moveInitialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;   //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   // func moveInitializeBackward&lt;T&gt;(from: UnsafePointer&lt;T&gt;, count: Int)<br>&gt;   //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   func moveInitialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, forwardToCount: Int)<br>&gt;     -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;   func moveInitialize&lt;T&gt;(from: UnsafePointer&lt;T&gt;, backwardFromCount: Int)<br>&gt;     -&gt; UnsafeMutablePointer&lt;T&gt;<br>&gt;<br>&gt; Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/1cb943f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API &quot;initialize(from:forwardToCount:)&quot;</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 11:05 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t mind `initialize(from:forwardToCount:)`, but I do have trouble with Brent&#39;s suggestion of `initialize(from:backwardFromCount:)`. It adds ambiguity as to whether the pointer in the first argument points to the 0th element or the (count - 1)th element from which initializing is proceeding backward, a problem that does not exist with the currently proposed version `initializeBackward(from:count:)`. I don&#39;t find the symmetry wins compelling enough to overcome that additional ambiguity.<br></p><p>That’s a good point, but I think both forms are equally ambiguous.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/0d150d70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API &quot;initialize(from:forwardToCount:)&quot;</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m not sure about that. &quot;Initialize backward from x, count y&quot; is<br>unambiguous as to how initialization starts and iterates (the first<br>argument), and it is clear that `count` is an end condition dissociated<br>from anything to do with how initialization starts and iterates.<br></p><p>By contrast, &quot;Initialize from x, backward from y&quot; associates the direction<br>of movement with y instead of x. Thus, y becomes the start condition (the<br>end condition being implicitly &quot;to zero&quot;), thus raising the question of<br>what position x is in relative to the count y.<br>On Tue, Jul 5, 2016 at 11:10 Andrew Trick &lt;atrick at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 5, 2016, at 11:05 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; I don&#39;t mind `initialize(from:forwardToCount:)`, but I do have trouble<br>&gt; with Brent&#39;s suggestion of `initialize(from:backwardFromCount:)`. It adds<br>&gt; ambiguity as to whether the pointer in the first argument points to the 0th<br>&gt; element or the (count - 1)th element from which initializing is proceeding<br>&gt; backward, a problem that does not exist with the currently proposed version<br>&gt; `initializeBackward(from:count:)`. I don&#39;t find the symmetry wins<br>&gt; compelling enough to overcome that additional ambiguity.<br>&gt;<br>&gt;<br>&gt; That’s a good point, but I think both forms are equally ambiguous.<br>&gt;<br>&gt; -Andy<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/a1647b7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API &quot;initialize(from:forwardToCount:)&quot;</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 11:27 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure about that. &quot;Initialize backward from x, count y&quot; is unambiguous as to how initialization starts and iterates (the first argument), and it is clear that `count` is an end condition dissociated from anything to do with how initialization starts and iterates.<br>&gt; <br>&gt; By contrast, &quot;Initialize from x, backward from y&quot; associates the direction of movement with y instead of x. Thus, y becomes the start condition (the end condition being implicitly &quot;to zero&quot;), thus raising the question of what position x is in relative to the count y.<br></p><p>&quot;Initialize backward from x&quot; literally tells me that ‘x’ is the starting point, which is incorrect. Honestly, users will need to check the doc comments which are very precise.<br></p><p>-Andy<br></p><p>&gt; On Tue, Jul 5, 2016 at 11:10 Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 11:05 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t mind `initialize(from:forwardToCount:)`, but I do have trouble with Brent&#39;s suggestion of `initialize(from:backwardFromCount:)`. It adds ambiguity as to whether the pointer in the first argument points to the 0th element or the (count - 1)th element from which initializing is proceeding backward, a problem that does not exist with the currently proposed version `initializeBackward(from:count:)`. I don&#39;t find the symmetry wins compelling enough to overcome that additional ambiguity.<br>&gt; <br>&gt; That’s a good point, but I think both forms are equally ambiguous.<br>&gt; <br>&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/c397c780/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 10:10 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have a pile of naming quibbles; rather than describe them all in prose (which turned into a mess), I&#39;ve annotated parts of the &quot;Full UnsafeRawPointer API&quot; section in a gist: &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe &lt;https://gist.github.com/brentdax/8f4ed4decafc1d18c4441092baa13cfe&gt;&gt;.<br>&gt; <br></p><p>I mostly agree with Brent&#39;s naming suggestions below. Anyone else want to weigh in?<br>https://github.com/apple/swift-evolution/pull/410<br></p><p>&gt; it&#39;s not clear that these operations are <br>&gt; nonmutating. I prefer `casting` because it&#39;s clearer about that.<br></p><p>Now we have:<br></p><p>  func bindMemory&lt;T&gt;(to: T.Type, capacity: Int) -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>  func assumingMemoryBound&lt;T&gt;(to: T.Type) -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>  func withMemoryRebound&lt;T&gt;(to: T.Type, capacity count: Int,<br>    _ body: @noescape (UnsafeMutablePointer&lt;T&gt;) throws -&gt; ()) rethrows<br></p><p><br>&quot;bind&quot; is active. It has important side effects.<br>&quot;assuming&quot; is passive; it&#39;s just a &quot;cast&quot;.<br>&quot;withMemoryRebound&quot; temporarily rebinds the type, but leaves it in its original state. &quot;with&quot; is sufficient to imply that the closure may mutate state.<br></p><p>---<br></p><p>  // In addition to the above point, I don&#39;t think &quot;to&quot; belongs in <br>  // front of &quot;contiguous&quot; here. It makes sense with the verbs in <br>  // `load` and `storeRaw` below, but not with this verb.<br>  // <br>  // I also think `contiguous` basically implies `Index`, so we can <br>  // just use `at`. Yes, I know about the `load` method with <br>  // `atByteOffset`.<br>  // <br>  // func initialize&lt;T&gt;(toContiguous: T.Type, atIndex: Int, with: T)<br>  //   -&gt; UnsafeMutablePointer&lt;T&gt;<br>  func initialize&lt;T&gt;(contiguous: T.Type, at: Int, to: T)<br>    -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>This is a purely additive API that I&#39;m personally in favor of dropping if it&#39;s confusing, but it was requested as a convenience...<br></p><p>The &quot;toContiguous&quot; was to avoid implying that a sequence of elements is being initialized, as opposed to a single element. &quot;atIndex&quot; was also suggested as a clarification. In hindsight I don&#39;t think either are likely to improve clarity in practice. I&#39;m inclined to go with your suggestion, and if anyone thinks it&#39;s confusing we should drop the API for now:<br></p><p>  func initialize&lt;T&gt;(contiguous: T.Type, at: Int, to: T)<br>    -&gt; UnsafeMutablePointer&lt;T&gt;<br></p><p>---<br></p><p>  // A little backwards, but `as` here is to support a more fluent <br>  // `storeRaw` equivalent.<br>  //<br>  // func load&lt;T&gt;(_: T.Type) -&gt; T<br>  // func load&lt;T&gt;(_: T.Type, atByteOffset: Int) -&gt; T<br>  func load&lt;T&gt;(as: T.Type) -&gt; T<br>  func load&lt;T&gt;(fromByteOffset: Int, as: T.Type) -&gt; T<br>  // func load&lt;T&gt;(fromContiguous: T.Type, atIndex: Int) -&gt; T<br>  func load&lt;T&gt;(fromContiguous: T.Type, at: Int) -&gt; T<br></p><p>  // I&#39;m reversing the arguments here because the thing being stored is <br>  // the obvious direct object of the verb &quot;store&quot;.<br>  // <br>  // func storeRaw&lt;T&gt;(_: T.Type, with: T)<br>  // func storeRaw&lt;T&gt;(toContiguous: T.Type, at: Int, with: T)<br>  func storeRaw&lt;T&gt;(_: T, as: T.Type)<br>  func storeRaw&lt;T&gt;(_: T, toContiguous: T.Type, at: Int)<br></p><p>I agree. Giving `load` and &quot;as&quot; label makes sense because the in-memory type may be different than the loaded type.<br></p><p>I strongly prefer your version of &quot;storeRaw&quot;.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/7a44b42b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 10:10 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; More concrete issues:<br>&gt; <br>&gt; * Is there a reason there&#39;s a `load` that takes a byte offset, but not a `storeRaw`?<br></p><p>A couple of those methods were added by request, but I was reluctant to add more methods just because they looked like they should be there.<br>But since you mention it, if we decide keep the purely additive `load(fromByteOffset:as)` method, then I’ll also add this for symmetry:<br></p><p>  func storeRaw&lt;T&gt;(_: T, toByteOffset: Int)<br></p><p>Should it be &quot;toByteOffset&quot; or &quot;atByteOffset”?<br></p><p>https://github.com/apple/swift-evolution/pull/410/files<br></p><p>&gt; * I&#39;m also a little nervous about the fact that `storeRaw` (and `load`?) is documented to only work properly on &quot;trivial types&quot;, but it doesn&#39;t have any sort of constraints to ensure it&#39;s used correctly. (One could imagine, for instance, the compiler automatically conforming trivial types to a `Trivial` protocol.)<br></p><p>Noted. There&#39;s absolutely no way to enforce that any overwritten value is trivial, but a sanitizer could catch it. When we have a &quot;trivial&quot; protocol we can add a debugPrecondition on the destination type.<br></p><p>`load` simply does not need to take a trivial type. Although it reads from raw memory, it is not a &quot;raw&quot; operation. It knows how to retain things.<br></p><p>I&#39;d rather not introduce a symmetric `store` that handles nontrivial types, until we really need it, because of the serious potential for misuse. People should try to use typed pointers for assignment semantics.<br></p><p>There&#39;s a discussion on this in the proposal now:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#raw-memory-access<br></p><p>&gt; * I don&#39;t think I understand `initialize(toContiguous:atIndex:with:)`. Does it return a typed pointer to the whole buffer, or just the one instance it initialized? In the `stringFromBytes` example, shouldn&#39;t we either subscript the typed pointer from the previous `initialize(_:with:count:)` call, or call `storeRaw(toContiguous:atIndex:with:)`, rather than initializing memory twice? If this isn&#39;t a good use case for `initialize(toContiguous:atIndex:with:)`, what would be?<br></p><p>The latest proposal has this example, which actually ignores the returned value:<br></p><p>  let rawBuffer = UnsafeMutableRawPointer.allocate(bytes: size + 1)<br>  rawBuffer.initialize(UInt8.self, with: value, count: size)<br>  rawBuffer.initialize(toContiguous: UInt8.self, atIndex: size, with: 0)<br></p><p>This was requested as a convenience. As mentioned in a previous email, I&#39;m happy to drop it for now.<br></p><p>`initialize(toContiguous:with:count:)` returns a typed pointer to all the initialized elements.<br></p><p>Subscripting the typed pointer to write the null terminator would be wrong because that memory has never been bound to a type.<br></p><p>I do agree that the example should just be:<br></p><p>  let rawBuffer = UnsafeMutableRawPointer.allocate(bytes: size + 1)<br>  rawBuffer.initialize(UInt8.self, with: value, count: size)<br>  rawBuffer.initialize(contiguous: UInt8.self, at: size, to: 0)<br></p><p>But the easy, common way to initialize a C string will simply be:<br></p><p>  let cstr = UnsafeMutablePointer&lt;CChar&gt;.allocate(capacity: size + 1)<br>  // The whole string is now bound to CChar<br>  for i in 0..&lt;size { cstr[i] = … }<br>  cstr[size] = 0<br></p><p>&gt; I&#39;m quite concerned by the &quot;moveInitialize should be more elegant&quot; section at the bottom.<br>&gt; <br>&gt; Since the types are so close, `moveInitialize` could require mutating arguments and actually swap the pointers. For instance:<br>&gt; <br>&gt; 	func grow(buffer: UnsafePointer&lt;Int&gt;, count: Int, toNewCapacity capacity: Int) -&gt; UnsafeBuffer&lt;Int&gt; {<br>&gt; 		var buffer = buffer<br>&gt; 		var uninitializedBuffer = UnsafeRawPointer.allocate(capacity: capacity, of: Int.self)<br>&gt; 		<br>&gt; 		uninitializedBuffer.swapPointersAfterMoving(from: &amp;buffer, count: count)<br>&gt; 		// `buffer` now points to the new allocation, filled in with the Ints.<br>&gt; 		// `uninitializedBuffer` now points to the old allocation, which is deinitialized.<br>&gt; 		<br>&gt; 		uninitializedBuffer.deallocate()<br>&gt; 		return buffer<br>&gt; 	}<br>&gt; <br>&gt; This is *such* a strange semantic, however, that I&#39;m not at all sure how to name this function.<br>&gt; <br>&gt; `moveAssign(from:count:)` could do something much simpler, returning a raw version of `from`:<br>&gt; <br>&gt; 	target.moveAssign(from: source).deallocate()<br>&gt; <br>&gt; `move()`, on the other hand, I don&#39;t see a good way to fix like this.<br>&gt; <br>&gt; One ridiculous thing we could do for `moveAssign(from:count:)` and perhaps `move()` is to deliberately make `self` invalid by setting it to address 0. If it were `Optional`, this would nil `self`. If it weren&#39;t...well, something would probably fail eventually.<br></p><p>For a while, I was trying to force a convention where deinitialization always returned a raw pointer because it&#39;s safer to initialize that<br>raw pointer. With the latest proposal I&#39;m not as concerned about that. The majority of the time, it will be fine to reinitialize using the typed pointer. If the user wants a raw pointer back after the move, it is trivial just to cast the typed pointer into a raw pointer.<br></p><p>So, while move-semantics would be cool, I really don’t think it’s necessary or even desired in this case. Clear doc comments should be sufficient.<br></p><p>&gt; * * *<br>&gt; <br>&gt; I notice that many APIs require type parameters merely to force the user to explicitly state the types involved. I wonder if we could instead introduce an attribute which you could place on a parameter or return type indicating that there must be an explicit `as` cast specifying its type:<br>&gt; <br>&gt; 	func storeRaw&lt;T&gt;(_: @explicit T)<br>&gt; 	func load&lt;T&gt;() -&gt; @explicit T<br>&gt; 	func cast&lt;T&gt;() -&gt; @explicit UnsafePointer&lt;T&gt;<br>&gt; 	<br>&gt; 	rawPointer.storeRaw(3 as Int)<br>&gt; 	rawPointer.load() as Int<br>&gt; 	rawPointer.cast() as UnsafePointer&lt;Int&gt;<br>&gt; <br>&gt; This would also be useful on `unsafeBitCast`, and on user APIs which are prone to type inference issues.<br></p><p>I&#39;m not as irrated by explicit type arguments as some, but the feeling I get is that we really want a language feature that forces certain<br>generic paramters to be explicit. When that happens, we&#39;ll likely phase out the old-style type arguments in favor of angle brackets, and<br>I&#39;ll be sad because I dislike angle brackets.<br></p><p>&gt; * * * <br>&gt; <br>&gt; In the long run, however, I wonder if we might end up removing `UnsafeRawPointer`. If `Never` becomes a subtype-of-all-types, then `UnsafePointer&lt;Never&gt;` would gain the basic properties of an `UnsafeRawPointer`:<br>&gt; <br>&gt; * Because `Never` is a subtype of all types, `UnsafePointer&lt;Never&gt;` could alias any other pointer.<br>&gt; <br>&gt; * Accessing `pointee` would be inherently invalid (it would either take or return a `Never`), and APIs which initialize or set `pointee` would be inherently uncallable.<br>&gt; <br>&gt; * `Never` has no intrinsic size, so it could be treated as having a one-byte size, allowing APIs which normally allocate, deallocate, or do pointer arithmetic by instance size to automatically do so by byte size instead.<br>&gt; <br>&gt; * APIs for casting an `UnsafePointer&lt;T&gt;` to `UnsafePointer&lt;supertype of T&gt;` or `&lt;subtype of T&gt;` would do the right thing with `UnsafePointer&lt;Never&gt;`.<br>&gt; <br>&gt; Thus, I could imagine `Unsafe[Mutable]RawPointer` becoming `Unsafe[Mutable]Pointer&lt;Never&gt;` in the future, with some APIs being generalized and moving to all `UnsafePointer`s while others are in extensions on `UnsafePointer where Pointee == Never`.<br>&gt; <br>&gt; It might be worth taking a look at the current API designs and thinking about how they would look in that world:<br>&gt; <br>&gt; * Is `nsStringPtr.casting(to: UnsafePointer&lt;NSObject&gt;)` how you would want to write a pointee upcast? How about `UnsafePointer&lt;NSString&gt;(nsObjectPtr)` for a pointee downcast?<br>&gt; <br>&gt; * Would you want `initialize&lt;T&gt;(_: T.Type, with: T, count: Int = 1) -&gt; UnsafeMutablePointer&lt;T&gt;` in the `Never` extension, or (with a supertype-of-Pointee constraint on `T`) would it be something you&#39;d put on other `UnsafeMutablePointer`s too? What does that mean for `UnsafeMutablePointer.initialize(with:)`?<br>&gt; <br>&gt; * Are `load` or `storeRaw` things that might make sense on any `UnsafeMutablePointer` if they were constrained to supertypes only?<br>&gt; <br>&gt; * Are there APIs which are basically the same on `Unsafe[Mutable]Pointer`s and their `Raw` equivalents, except that the `Raw` versions are &quot;dumb&quot; because they don&#39;t know what type they&#39;re operating on? If so, should they be given the same name?<br></p><p>Very early on I considered  a special `Never` element type for all of the excellent reasons that you laid out (nice job explaining that), but the pointer conversion rules that we want are not implementable.<br></p><p>Since then, the proposal has evolved so much that it makes sense to have a nominal raw pointer type. The pointer type itself is distinctly different, not just the element type, and the type system needs to be aware of that. It&#39;s also critical that the raw and typed pointers have a distinct API. Moving both of their functionality into extensions would just be a workaround. In reality, since the semantics are different, there&#39;s almost no shared implementation.<br></p><p>In short, raw pointers are deliberately a different types and we want developers and APIs to be cognizant of that.<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/d45a37ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0107: UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 2:06 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; * I don&#39;t think I understand `initialize(toContiguous:atIndex:with:)`. Does it return a typed pointer to the whole buffer, or just the one instance it initialized? <br></p><p><br>Typed pointers are returned only for the memory that was initialized. In this case, a single element:<br></p><p>  /// Initialize the memory location at `index` with `newValue` as if this<br>  /// memory holds at least `index` + 1 contiguous values of type `T`.<br>  ///<br>  /// Returns an `UnsafeMutablePointer&lt;T&gt;` the single intialized<br>  /// in-memory element.<br>  ///<br>  /// - Precondition: The memory at `index` is not initialized.<br>  ///<br>  /// - Precondition: The underlying pointer is properly aligned for<br>  ///                 accessing `T`.<br>  ///<br>  /// - Postcondition: The memory is initialized; the value should eventually<br>  ///   be destroyed or moved from to avoid leaks.<br>  @discardableResult<br>  public func initialize&lt;T&gt;(toContiguous _: T.Type, atIndex index: Int,<br>    with value: T)<br>    -&gt; UnsafeMutablePointer&lt;T&gt; {<br>    return (self + strideof(T.self) * index).initialize(T.self, with: value)<br>  }<br></p><p>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/a3cf76ec/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 11:05 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md<br></p><p><br>I&#39;ve revised the proposal again based on extremely helpful feedback from DaveA and Jordan.<br></p><p>This revision expands on the concept of formally binding the memory type that I was recently working on with Dmitri. Now we can clearly define pre and post conditions on memory operations and pointer casts that can be used to prove the type safety. The model is now simpler, more complete, and easy to reason about locally. This will help developers reason about correctness and make it easy to implement a sanitizer that verifies the type safety of UnsafePointer operations.<br></p><p>Adding safety to pointer &quot;casts&quot; made it possible for me to actually simplify the allocation and initialization APIs. I think both camps, convenience and safety, will be happy.<br></p><p>You can see what changed in this pull request:<br>https://github.com/apple/swift-evolution/pull/408 &lt;https://github.com/apple/swift-evolution/pull/408&gt;<br></p><p>Brief summary:<br></p><p>- Memory is dynamically bound to a single type.<br></p><p>- All typed access to memory, whether via a typed pointer or regular<br>  language construct, must be consistent with the memory&#39;s bound type<br>  (the access type must be related to the bound type). Typed access<br>  includes initialization, assignment, or deinitialization via a typed<br>  pointer.<br></p><p>- Memory remains bound after being deinitialized.<br></p><p>- Memory is implicitly bound or rebound to a type by initializing it<br>  via a raw pointer.<br></p><p>- A separate API now exists for explicity binding or rebinding memory<br>  to a type. This allows binding to be decoupled from initialization<br>  for convenience and efficiency. It also supports safe<br>  interoperability between APIs that used different, but layout<br>  compatible types.<br></p><p>- Using an API that accesses memory as a different type can now be<br>  accomplished by rebinding the memory. This effectively changes the<br>  type of any initialized values in memory. The compiler is still<br>  permitted to assume strict aliasing for accesses on either side of<br>  the operation that rebinds memory.<br></p><p>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160704/68afea3c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  4, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 4, 2016, at 3:32 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 11:05 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;<br>&gt; <br>&gt; <br>&gt; I&#39;ve revised the proposal again based on extremely helpful feedback from DaveA and Jordan.<br></p><p>FYI, I extended the review period to be through July 10 to allow extra discussion time on this revised proposal,<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160704/a630040e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July  4, 2016 at 05:00:00pm</p></header><div class="content"><p>This is the first version of this proposal which I&#39;ve had time to read. I<br>like it a lot overall. If I have some more time, I may try pulling the<br>branch and writing some code with it to see how it feels. (If we could get<br>a toolchain built from the branch, that might help others review it.)<br></p><p>Here are a handful of minor comments:<br></p><p>- Naming: &quot;bindMemory(to:capacity:)&quot;, being &quot;verb-ish&quot;, seems incongruous<br>with &quot;assumingMemoryBound(to:)&quot; and &quot;withMemoryRebound(to:capacity:_:)&quot;.<br>How about &quot;bindingMemory(to:capacity:)&quot; ?<br></p><p>- Would it be possible for &quot;+(UnsafeRawPointer, Int) -&gt; UnsafeRawPointer&quot;<br>to accept any Integer or FixedWidthInteger, rather than only Int?<br></p><p>- Why allow/encourage multiple calls to bindMemory on the same RawPointer?<br>These APIs do a good job of making aliasing explicit by introducing data<br>dependencies between pointers (you can only use a typed pointer after<br>obtaining it from a raw pointer, and you can recover the raw pointer for<br>later use by deinitializing the typed pointer). So, I would think the<br>guidelines should prefer bindMemory to be used only once on a particular<br>RawPointer value.<br></p><p>And minor notes about the proposal itself:<br></p><p>- strideof(Int.self) is used in most examples, but sizeof(Int.self) appears<br>in one of them (the &quot;normalLifetime()&quot; example).<br></p><p>- I think there must be a mistake in this example, because pA is already<br>bound and bindMemory was only defined for untyped RawPointers:<br></p><p>    func testInitAB() {<br>      // Get a raw pointer to (A, B).<br>      let p = initAB()<br></p><p>      let pA = p.bindMemory(to: A.self, capacity: 1)<br>      printA(pA)<br></p><p>      printB((pA + 1).bindMemory(to: B.self, capacity: 1))   //&lt;&lt;&lt; should<br>this be (p+1) rather than (pA+1)?<br>    }<br></p><p>Jacob<br></p><p>On Mon, Jul 4, 2016 at 3:32 PM, Andrew Trick via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 28, 2016, at 11:05 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through<br>&gt; July 4, 2016. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md<br>&gt;<br>&gt;<br>&gt; I&#39;ve revised the proposal again based on extremely helpful feedback from<br>&gt; DaveA and Jordan.<br>&gt;<br>&gt; This revision expands on the concept of formally binding the memory type<br>&gt; that I was recently working on with Dmitri. Now we can clearly define pre<br>&gt; and post conditions on memory operations and pointer casts that can be used<br>&gt; to prove the type safety. The model is now simpler, more complete, and easy<br>&gt; to reason about locally. This will help developers reason about correctness<br>&gt; and make it easy to implement a sanitizer that verifies the type safety of<br>&gt; UnsafePointer operations.<br>&gt;<br>&gt; Adding safety to pointer &quot;casts&quot; made it possible for me to actually<br>&gt; simplify the allocation and initialization APIs. I think both camps,<br>&gt; convenience and safety, will be happy.<br>&gt;<br>&gt; You can see what changed in this pull request:<br>&gt; https://github.com/apple/swift-evolution/pull/408<br>&gt;<br>&gt; Brief summary:<br>&gt;<br>&gt; - Memory is dynamically bound to a single type.<br>&gt;<br>&gt; - All typed access to memory, whether via a typed pointer or regular<br>&gt;   language construct, must be consistent with the memory&#39;s bound type<br>&gt;   (the access type must be related to the bound type). Typed access<br>&gt;   includes initialization, assignment, or deinitialization via a typed<br>&gt;   pointer.<br>&gt;<br>&gt; - Memory remains bound after being deinitialized.<br>&gt;<br>&gt; - Memory is implicitly bound or rebound to a type by initializing it<br>&gt;   via a raw pointer.<br>&gt;<br>&gt; - A separate API now exists for explicity binding or rebinding memory<br>&gt;   to a type. This allows binding to be decoupled from initialization<br>&gt;   for convenience and efficiency. It also supports safe<br>&gt;   interoperability between APIs that used different, but layout<br>&gt;   compatible types.<br>&gt;<br>&gt; - Using an API that accesses memory as a different type can now be<br>&gt;   accomplished by rebinding the memory. This effectively changes the<br>&gt;   type of any initialized values in memory. The compiler is still<br>&gt;   permitted to assume strict aliasing for accesses on either side of<br>&gt;   the operation that rebinds memory.<br>&gt;<br>&gt; Andy<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160704/b4ecff52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 4, 2016, at 7:52 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is the first version of this proposal which I&#39;ve had time to read. I like it a lot overall. If I have some more time, I may try pulling the branch and writing some code with it to see how it feels. (If we could get a toolchain built from the branch, that might help others review it.)<br></p><p>The latest UnsafeRawPointer definition is on this branch:<br>https://github.com/atrick/swift/tree/rawptr<br></p><p>I plan to update it with the latest round of feedback soonish and send out a PR.<br>Unfortunately, the type system/stdlib changes are not on that branch, so you won&#39;t get any implicit conversions.<br></p><p>&gt; Here are a handful of minor comments:<br>&gt; <br>&gt; - Naming: &quot;bindMemory(to:capacity:)&quot;, being &quot;verb-ish&quot;, seems incongruous with &quot;assumingMemoryBound(to:)&quot; and &quot;withMemoryRebound(to:capacity:_:)&quot;. How about &quot;bindingMemory(to:capacity:)” ?<br></p><p>DaveA is right, &quot;bind&quot; is active, &quot;assumingMemoryBound&quot; is passive. &quot;withMemoryRebound&quot; temporarily rebinds the type and implies that the closure may mutate state.<br></p><p>&gt; - Would it be possible for &quot;+(UnsafeRawPointer, Int) -&gt; UnsafeRawPointer&quot; to accept any Integer or FixedWidthInteger, rather than only Int?<br></p><p>I&#39;m not sure what all the tradeoffs are, but I don&#39;t think we want to index memory with non-Int sized integers. I think the user should be required to convert, which may trap.<br></p><p>&gt; - Why allow/encourage multiple calls to bindMemory on the same RawPointer? These APIs do a good job of making aliasing explicit by introducing data dependencies between pointers (you can only use a typed pointer after obtaining it from a raw pointer, and you can recover the raw pointer for later use by deinitializing the typed pointer). So, I would think the guidelines should prefer bindMemory to be used only once on a particular RawPointer value.<br></p><p>DaveA&#39;s answer was good. &quot;bindMemory&quot; is not really encouraged by the API. It&#39;s just mentioned a lot in the proposal because the semantics are interesting.<br></p><p>&quot;bindMemory&quot; is important because it&#39;s the only safe way to reinterpret in-memory values. So you need to use it to pass a UInt8 array off as a CChar, and so forth, which is actually quite common.<br></p><p>It is certainly encouraged more than unsafeBitCast(ptr, to: ...) because `bindMemory` is actually safe as long as you know the layout of the types and don&#39;t reuse your old typed pointers.<br></p><p>&gt; And minor notes about the proposal itself:<br>&gt; <br>&gt; - strideof(Int.self) is used in most examples, but sizeof(Int.self) appears in one of them (the &quot;normalLifetime()&quot; example).<br></p><p>That example is actually allocating memory for a single value. Should it be changed to `strideof`? If so, then what&#39;s the point of `sizeof`?<br></p><p>&gt; - I think there must be a mistake in this example, because pA is already bound and bindMemory was only defined for untyped RawPointers:<br>&gt; <br>&gt;     func testInitAB() {<br>&gt;       // Get a raw pointer to (A, B).<br>&gt;       let p = initAB()<br>&gt; <br>&gt;       let pA = p.bindMemory(to: A.self, capacity: 1)<br>&gt;       printA(pA)<br>&gt; <br>&gt;       printB((pA + 1).bindMemory(to: B.self, capacity: 1))   //&lt;&lt;&lt; should this be (p+1) rather than (pA+1)?<br>&gt;     }<br></p><p>Thanks. That was supposed to be cast to raw pointer like the other examples:<br></p><p>  // Knowing the `B` has the same alignment as `A`...<br>  printB(UnsafeRawPointer(pA + 1).bindMemory(to: B.self, capacity: 1))<br></p><p>-Andy<br></p><p>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Mon, Jul 4, 2016 at 3:32 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 11:05 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;<br>&gt; <br>&gt; <br>&gt; I&#39;ve revised the proposal again based on extremely helpful feedback from DaveA and Jordan.<br>&gt; <br>&gt; This revision expands on the concept of formally binding the memory type that I was recently working on with Dmitri. Now we can clearly define pre and post conditions on memory operations and pointer casts that can be used to prove the type safety. The model is now simpler, more complete, and easy to reason about locally. This will help developers reason about correctness and make it easy to implement a sanitizer that verifies the type safety of UnsafePointer operations.<br>&gt; <br>&gt; Adding safety to pointer &quot;casts&quot; made it possible for me to actually simplify the allocation and initialization APIs. I think both camps, convenience and safety, will be happy.<br>&gt; <br>&gt; You can see what changed in this pull request:<br>&gt; https://github.com/apple/swift-evolution/pull/408 &lt;https://github.com/apple/swift-evolution/pull/408&gt;<br>&gt; <br>&gt; Brief summary:<br>&gt; <br>&gt; - Memory is dynamically bound to a single type.<br>&gt; <br>&gt; - All typed access to memory, whether via a typed pointer or regular<br>&gt;   language construct, must be consistent with the memory&#39;s bound type<br>&gt;   (the access type must be related to the bound type). Typed access<br>&gt;   includes initialization, assignment, or deinitialization via a typed<br>&gt;   pointer.<br>&gt; <br>&gt; - Memory remains bound after being deinitialized.<br>&gt; <br>&gt; - Memory is implicitly bound or rebound to a type by initializing it<br>&gt;   via a raw pointer.<br>&gt; <br>&gt; - A separate API now exists for explicity binding or rebinding memory<br>&gt;   to a type. This allows binding to be decoupled from initialization<br>&gt;   for convenience and efficiency. It also supports safe<br>&gt;   interoperability between APIs that used different, but layout<br>&gt;   compatible types.<br>&gt; <br>&gt; - Using an API that accesses memory as a different type can now be<br>&gt;   accomplished by rebinding the memory. This effectively changes the<br>&gt;   type of any initialized values in memory. The compiler is still<br>&gt;   permitted to assume strict aliasing for accesses on either side of<br>&gt;   the operation that rebinds memory.<br>&gt; <br>&gt; Andy<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/6366f230/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 10, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 4, 2016, at 5:32 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 11:05 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;<br>&gt; <br>&gt; <br></p><p>I&#39;m revising this proposal based on last week&#39;s feedback. A few of the<br>additive APIs are removed and a number of UnsafePointer and<br>UnsafeRawPointer methods are renamed.<br></p><p>Here is a PR for the revision. Note that the examples in the proposal<br>text still need to be updated:<br>https://github.com/apple/swift-evolution/pull/420<br></p><p>I updated the short-form summary of the API:<br>https://github.com/atrick/swift-evolution/blob/3122ace9d2fb55072ebd7395c7353fcbf497318a/proposals/0107-unsaferawpointer.md#full-unsaferawpointer-api<br></p><p>The full UnsafeRawPointer API with doc comments is here:<br>https://github.com/atrick/swift/blob/22e3a2885e4236888ec447a7148acf633d8544f5/stdlib/public/core/UnsafeRawPointer.swift.gyb<br></p><p>The UnsafePointer and UnsafeRawPointer changes are on this branch:<br>https://github.com/atrick/swift/commits/rawptr<br></p><p>If you wish to comment line-by-line on the detailed docs or<br>implementation, you can do so here:<br>https://github.com/apple/swift/pull/3437<br></p><p>--- <br>I should preemptively answer the question &quot;why do UnsafeRawPointer<br>methods take an explicit type argument when it can be inferred?&quot;. Such<br>as:<br></p><p>  rawPtr.initializeMemory(as: Int.self, ...)<br></p><p>These methods don&#39;t simply operate on values of some type, they<br>actively bind memory to that type. At the point of use, that type<br>needs to be explicit to convey that fact. It&#39;s important for<br>readability, comprehension, and correctness. We cannot rely on type<br>inferrence on some expression which can change without the original<br>author&#39;s intervention resulting in subtle miscompiles.<br></p><p>---<br>The only concern I have about this version of the proposal is this method name: <br></p><p>  func copyBytes(from: UnsafeRawPointer, count: Int)<br></p><p>because `count` usually refers to a number of values. I think it should be:<br></p><p>  func copy(bytes: Int, from: UnsafeRawPointer)<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/ff0f23e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July 11, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 10 Jul 2016, at 14:41, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m revising this proposal based on last week&#39;s feedback. A few of the<br>&gt; additive APIs are removed and a number of UnsafePointer and<br>&gt; UnsafeRawPointer methods are renamed.<br>&gt; <br>&gt; Here is a PR for the revision. Note that the examples in the proposal<br>&gt; text still need to be updated:<br>&gt; https://github.com/apple/swift-evolution/pull/420<br>&gt; <br>&gt; I updated the short-form summary of the API:<br>&gt; https://github.com/atrick/swift-evolution/blob/3122ace9d2fb55072ebd7395c7353fcbf497318a/proposals/0107-unsaferawpointer.md#full-unsaferawpointer-api<br>&gt; <br>&gt; The full UnsafeRawPointer API with doc comments is here:<br>&gt; https://github.com/atrick/swift/blob/22e3a2885e4236888ec447a7148acf633d8544f5/stdlib/public/core/UnsafeRawPointer.swift.gyb<br>&gt; <br>&gt; The UnsafePointer and UnsafeRawPointer changes are on this branch:<br>&gt; https://github.com/atrick/swift/commits/rawptr<br>&gt; <br>&gt; If you wish to comment line-by-line on the detailed docs or<br>&gt; implementation, you can do so here:<br>&gt; https://github.com/apple/swift/pull/3437<br>&gt; <br>&gt; ---<br>&gt; The only concern I have about this version of the proposal is this method name: <br>&gt; <br>&gt;   func copyBytes(from: UnsafeRawPointer, count: Int)<br>&gt; <br>&gt; because `count` usually refers to a number of values. I think it should be:<br>&gt; <br>&gt;   func copy(bytes: Int, from: UnsafeRawPointer)<br></p><p>Using `bytes` to label the count / length / size would be inconsistent with:<br></p><p>	Foundation.Data.init(bytes:count:)<br>	&lt;https://developer.apple.com/reference/foundation/data/1780158-init&gt;<br></p><p>	Foundation.Data.copyBytes(to:count:)<br>	&lt;https://developer.apple.com/reference/foundation/data/1780297-copybytes&gt;<br></p><p>UnsafeMutableRawPointer could use a `size` or `sizeInBytes` label.<br>(This also applies to the `allocate` and `deallocate` methods).<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 12:50 AM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 10 Jul 2016, at 14:41, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m revising this proposal based on last week&#39;s feedback. A few of the<br>&gt;&gt; additive APIs are removed and a number of UnsafePointer and<br>&gt;&gt; UnsafeRawPointer methods are renamed.<br>&gt;&gt; <br>&gt;&gt; Here is a PR for the revision. Note that the examples in the proposal<br>&gt;&gt; text still need to be updated:<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/420<br>&gt;&gt; <br>&gt;&gt; I updated the short-form summary of the API:<br>&gt;&gt; https://github.com/atrick/swift-evolution/blob/3122ace9d2fb55072ebd7395c7353fcbf497318a/proposals/0107-unsaferawpointer.md#full-unsaferawpointer-api<br>&gt;&gt; <br>&gt;&gt; The full UnsafeRawPointer API with doc comments is here:<br>&gt;&gt; https://github.com/atrick/swift/blob/22e3a2885e4236888ec447a7148acf633d8544f5/stdlib/public/core/UnsafeRawPointer.swift.gyb<br>&gt;&gt; <br>&gt;&gt; The UnsafePointer and UnsafeRawPointer changes are on this branch:<br>&gt;&gt; https://github.com/atrick/swift/commits/rawptr<br>&gt;&gt; <br>&gt;&gt; If you wish to comment line-by-line on the detailed docs or<br>&gt;&gt; implementation, you can do so here:<br>&gt;&gt; https://github.com/apple/swift/pull/3437<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; The only concern I have about this version of the proposal is this method name: <br>&gt;&gt; <br>&gt;&gt;  func copyBytes(from: UnsafeRawPointer, count: Int)<br>&gt;&gt; <br>&gt;&gt; because `count` usually refers to a number of values. I think it should be:<br>&gt;&gt; <br>&gt;&gt;  func copy(bytes: Int, from: UnsafeRawPointer)<br>&gt; <br>&gt; Using `bytes` to label the count / length / size would be inconsistent with:<br>&gt; <br>&gt; 	Foundation.Data.init(bytes:count:)<br>&gt; 	&lt;https://developer.apple.com/reference/foundation/data/1780158-init&gt;<br>&gt; <br>&gt; 	Foundation.Data.copyBytes(to:count:)<br>&gt; 	&lt;https://developer.apple.com/reference/foundation/data/1780297-copybytes&gt;<br>&gt; <br>&gt; UnsafeMutableRawPointer could use a `size` or `sizeInBytes` label.<br>&gt; (This also applies to the `allocate` and `deallocate` methods).<br>&gt; <br>&gt; — Ben<br></p><p>Thanks for pointing that out.<br></p><p>My concern is code like:<br></p><p>  let ptrToInt: UnsafePointer&lt;Int32&gt; = …<br>  rawPtr.copyBytes(from: ptrToInt, count: 4)<br></p><p>which looks a lot like 4 Int32s will be copied when only 1 Int32 will actually be copied.<br></p><p>Anyone care to vote on this?<br></p><p>Current:<br></p><p>  let rawPtr = UnsafeMutableRawPointer.allocate(bytes: 24)<br>  rawPtr.copyBytes(from: ptrToInt, count: 24)<br>  rawPtr.deallocate(bytes: 24)<br></p><p>Proposed:<br></p><p>  let rawPtr = UnsafeMutableRawPointer.allocate(sizeInBytes: 24)<br>  rawPtr.copyBytes(from: ptrToInt, sizeInBytes: 24)<br>  rawPtr.deallocate(sizeInBytes: 24)<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 11, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon Jul 11 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 11, 2016, at 12:50 AM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 10 Jul 2016, at 14:41, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; I&#39;m revising this proposal based on last week&#39;s feedback. A few of the<br>&gt;&gt;&gt; additive APIs are removed and a number of UnsafePointer and<br>&gt;&gt;&gt; UnsafeRawPointer methods are renamed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a PR for the revision. Note that the examples in the proposal<br>&gt;&gt;&gt; text still need to be updated:<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/420<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I updated the short-form summary of the API:<br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/3122ace9d2fb55072ebd7395c7353fcbf497318a/proposals/0107-unsaferawpointer.md#full-unsaferawpointer-api<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The full UnsafeRawPointer API with doc comments is here:<br>&gt;&gt;&gt; https://github.com/atrick/swift/blob/22e3a2885e4236888ec447a7148acf633d8544f5/stdlib/public/core/UnsafeRawPointer.swift.gyb<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The UnsafePointer and UnsafeRawPointer changes are on this branch:<br>&gt;&gt;&gt; https://github.com/atrick/swift/commits/rawptr<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you wish to comment line-by-line on the detailed docs or<br>&gt;&gt;&gt; implementation, you can do so here:<br>&gt;&gt;&gt; https://github.com/apple/swift/pull/3437<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; The only concern I have about this version of the proposal is this method name: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func copyBytes(from: UnsafeRawPointer, count: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; because `count` usually refers to a number of values. I think it should be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func copy(bytes: Int, from: UnsafeRawPointer)<br>&gt;&gt; <br>&gt;&gt; Using `bytes` to label the count / length / size would be inconsistent with:<br>&gt;&gt; <br>&gt;&gt; 	Foundation.Data.init(bytes:count:)<br>&gt;&gt; 	&lt;https://developer.apple.com/reference/foundation/data/1780158-init&gt;<br>&gt;&gt; <br>&gt;&gt; 	Foundation.Data.copyBytes(to:count:)<br>&gt;&gt; 	&lt;https://developer.apple.com/reference/foundation/data/1780297-copybytes&gt;<br>&gt;&gt; <br>&gt;&gt; UnsafeMutableRawPointer could use a `size` or `sizeInBytes` label.<br>&gt;&gt; (This also applies to the `allocate` and `deallocate` methods).<br>&gt;&gt; <br>&gt;&gt; — Ben<br>&gt;<br>&gt; Thanks for pointing that out.<br>&gt;<br>&gt; My concern is code like:<br>&gt;<br>&gt;   let ptrToInt: UnsafePointer&lt;Int32&gt; = …<br>&gt;   rawPtr.copyBytes(from: ptrToInt, count: 4)<br>&gt;<br>&gt; which looks a lot like 4 Int32s will be copied when only 1 Int32 will actually be copied.<br>&gt;<br>&gt; Anyone care to vote on this?<br></p><p>I think you&#39;re being overly fussy.  The name clearly says we&#39;re copying<br>bytes.  count says how many.  But if you want to avoid any possibility<br>of confusion, only support source pointers that are UnsafeRawPointer.<br></p><p>&gt;<br>&gt;<br>&gt; Current:<br>&gt;<br>&gt;   let rawPtr = UnsafeMutableRawPointer.allocate(bytes: 24)<br>&gt;   rawPtr.copyBytes(from: ptrToInt, count: 24)<br>&gt;   rawPtr.deallocate(bytes: 24)<br>&gt;<br>&gt; Proposed:<br>&gt;<br>&gt;   let rawPtr = UnsafeMutableRawPointer.allocate(sizeInBytes: 24)<br>&gt;   rawPtr.copyBytes(from: ptrToInt, sizeInBytes: 24)<br>&gt;   rawPtr.deallocate(sizeInBytes: 24)<br>&gt;<br>&gt; -Andy<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 10:22 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jul 11 2016, Andrew Trick &lt;atrick-AT-apple.com &lt;http://atrick-at-apple.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 11, 2016, at 12:50 AM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 10 Jul 2016, at 14:41, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m revising this proposal based on last week&#39;s feedback. A few of the<br>&gt;&gt;&gt;&gt; additive APIs are removed and a number of UnsafePointer and<br>&gt;&gt;&gt;&gt; UnsafeRawPointer methods are renamed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is a PR for the revision. Note that the examples in the proposal<br>&gt;&gt;&gt;&gt; text still need to be updated:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/420<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I updated the short-form summary of the API:<br>&gt;&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/3122ace9d2fb55072ebd7395c7353fcbf497318a/proposals/0107-unsaferawpointer.md#full-unsaferawpointer-api<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The full UnsafeRawPointer API with doc comments is here:<br>&gt;&gt;&gt;&gt; https://github.com/atrick/swift/blob/22e3a2885e4236888ec447a7148acf633d8544f5/stdlib/public/core/UnsafeRawPointer.swift.gyb<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The UnsafePointer and UnsafeRawPointer changes are on this branch:<br>&gt;&gt;&gt;&gt; https://github.com/atrick/swift/commits/rawptr<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you wish to comment line-by-line on the detailed docs or<br>&gt;&gt;&gt;&gt; implementation, you can do so here:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift/pull/3437<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; The only concern I have about this version of the proposal is this method name: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func copyBytes(from: UnsafeRawPointer, count: Int)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; because `count` usually refers to a number of values. I think it should be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func copy(bytes: Int, from: UnsafeRawPointer)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using `bytes` to label the count / length / size would be inconsistent with:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	Foundation.Data.init(bytes:count:)<br>&gt;&gt;&gt; 	&lt;https://developer.apple.com/reference/foundation/data/1780158-init&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	Foundation.Data.copyBytes(to:count:)<br>&gt;&gt;&gt; 	&lt;https://developer.apple.com/reference/foundation/data/1780297-copybytes&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UnsafeMutableRawPointer could use a `size` or `sizeInBytes` label.<br>&gt;&gt;&gt; (This also applies to the `allocate` and `deallocate` methods).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Ben<br>&gt;&gt; <br>&gt;&gt; Thanks for pointing that out.<br>&gt;&gt; <br>&gt;&gt; My concern is code like:<br>&gt;&gt; <br>&gt;&gt;  let ptrToInt: UnsafePointer&lt;Int32&gt; = …<br>&gt;&gt;  rawPtr.copyBytes(from: ptrToInt, count: 4)<br>&gt;&gt; <br>&gt;&gt; which looks a lot like 4 Int32s will be copied when only 1 Int32 will actually be copied.<br>&gt;&gt; <br>&gt;&gt; Anyone care to vote on this?<br>&gt; <br>&gt; I think you&#39;re being overly fussy.  The name clearly says we&#39;re copying<br>&gt; bytes.  count says how many.  But if you want to avoid any possibility<br>&gt; of confusion, only support source pointers that are UnsafeRawPointer.<br></p><p><br>Thanks. I’ll take that as a +1 for the current form.<br></p><p>We support implicit argument conversion from UnsafePointer&lt;T&gt; to UnsafeRawPointer primarily so that UnsafePointers can be passed as `void*` arguments.<br></p><p>-Andy<br></p><p>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Current:<br>&gt;&gt; <br>&gt;&gt;  let rawPtr = UnsafeMutableRawPointer.allocate(bytes: 24)<br>&gt;&gt;  rawPtr.copyBytes(from: ptrToInt, count: 24)<br>&gt;&gt;  rawPtr.deallocate(bytes: 24)<br>&gt;&gt; <br>&gt;&gt; Proposed:<br>&gt;&gt; <br>&gt;&gt;  let rawPtr = UnsafeMutableRawPointer.allocate(sizeInBytes: 24)<br>&gt;&gt;  rawPtr.copyBytes(from: ptrToInt, sizeInBytes: 24)<br>&gt;&gt;  rawPtr.deallocate(sizeInBytes: 24)<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/da3ac415/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API (binding memory to type)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 11, 2016 at 11:00:00pm</p></header><div class="content"><p>I merged the last of my edits to this proposal (see the PR below), if anyone it interested in seeing where things ended up and doing last minute reviews.<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md<br></p><p>-Andy<br></p><p>&gt; On Jul 10, 2016, at 6:41 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 4, 2016, at 5:32 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 11:05 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; I&#39;m revising this proposal based on last week&#39;s feedback. A few of the<br>&gt; additive APIs are removed and a number of UnsafePointer and<br>&gt; UnsafeRawPointer methods are renamed.<br>&gt; <br>&gt; Here is a PR for the revision. Note that the examples in the proposal<br>&gt; text still need to be updated:<br>&gt; https://github.com/apple/swift-evolution/pull/420 &lt;https://github.com/apple/swift-evolution/pull/420&gt;<br>&gt; <br>&gt; I updated the short-form summary of the API:<br>&gt; https://github.com/atrick/swift-evolution/blob/3122ace9d2fb55072ebd7395c7353fcbf497318a/proposals/0107-unsaferawpointer.md#full-unsaferawpointer-api &lt;https://github.com/atrick/swift-evolution/blob/3122ace9d2fb55072ebd7395c7353fcbf497318a/proposals/0107-unsaferawpointer.md#full-unsaferawpointer-api&gt;<br>&gt; <br>&gt; The full UnsafeRawPointer API with doc comments is here:<br>&gt; https://github.com/atrick/swift/blob/22e3a2885e4236888ec447a7148acf633d8544f5/stdlib/public/core/UnsafeRawPointer.swift.gyb &lt;https://github.com/atrick/swift/blob/22e3a2885e4236888ec447a7148acf633d8544f5/stdlib/public/core/UnsafeRawPointer.swift.gyb&gt;<br>&gt; <br>&gt; The UnsafePointer and UnsafeRawPointer changes are on this branch:<br>&gt; https://github.com/atrick/swift/commits/rawptr &lt;https://github.com/atrick/swift/commits/rawptr&gt;<br>&gt; <br>&gt; If you wish to comment line-by-line on the detailed docs or<br>&gt; implementation, you can do so here:<br>&gt; https://github.com/apple/swift/pull/3437 &lt;https://github.com/apple/swift/pull/3437&gt;<br>&gt; <br>&gt; --- <br>&gt; I should preemptively answer the question &quot;why do UnsafeRawPointer<br>&gt; methods take an explicit type argument when it can be inferred?&quot;. Such<br>&gt; as:<br>&gt; <br>&gt;   rawPtr.initializeMemory(as: Int.self, ...)<br>&gt; <br>&gt; These methods don&#39;t simply operate on values of some type, they<br>&gt; actively bind memory to that type. At the point of use, that type<br>&gt; needs to be explicit to convey that fact. It&#39;s important for<br>&gt; readability, comprehension, and correctness. We cannot rely on type<br>&gt; inferrence on some expression which can change without the original<br>&gt; author&#39;s intervention resulting in subtle miscompiles.<br>&gt; <br>&gt; ---<br>&gt; The only concern I have about this version of the proposal is this method name: <br>&gt; <br>&gt;   func copyBytes(from: UnsafeRawPointer, count: Int)<br>&gt; <br>&gt; because `count` usually refers to a number of values. I think it should be:<br>&gt; <br>&gt;   func copy(bytes: Int, from: UnsafeRawPointer)<br>&gt; <br>&gt; -Andy<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/26267eac/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/42eca71033ece251f2f194b7e343c2ec?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API</strong> from <string>Magnus Ahltorp</string> &lt;map at kth.se&gt;<p>July  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md<br></p><p>I have not had time for a full review, but I have a question about the proposal:<br></p><p>When glancing at the examples, they strike me as mostly being marshalling, which in my opinion would be better served by a safe marshalling API followed by unsafe handling of the resulting buffer, and vice versa for unmarshalling. I think it is very important (in the long run) that code that doesn&#39;t interact with C directly has safe ways of doing inherently safe operations, and not take the unsafe route just because that is the only API available.<br></p><p>My question is, how does this API fit into the bigger picture of marshalling, and what are the benefits of using this API instead of marshalling with safe buffers?<br></p><p>I would consider &quot;we don&#39;t have time, we have to do this for now&quot; a perfectly valid answer.<br></p><p>/Magnus<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Review] SE-0107: UnsafeRawPointer API</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 10:09 AM, Magnus Ahltorp via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The review of “SE-0107: UnsafeRawPointer API” begins now and runs through July 4, 2016. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md<br>&gt; <br>&gt; I have not had time for a full review, but I have a question about the proposal:<br>&gt; <br>&gt; When glancing at the examples, they strike me as mostly being marshalling, which in my opinion would be better served by a safe marshalling API followed by unsafe handling of the resulting buffer, and vice versa for unmarshalling. I think it is very important (in the long run) that code that doesn&#39;t interact with C directly has safe ways of doing inherently safe operations, and not take the unsafe route just because that is the only API available.<br>&gt; <br>&gt; My question is, how does this API fit into the bigger picture of marshalling, and what are the benefits of using this API instead of marshalling with safe buffers?<br>&gt; <br>&gt; I would consider &quot;we don&#39;t have time, we have to do this for now&quot; a perfectly valid answer.<br>&gt; <br>&gt; /Magnus<br></p><p><br>I think that&#39;s a good point.<br></p><p>The examples in the &quot;Motivation&quot; section are contrived to demonstrate safety holes as tersely as possible. The examples in &quot;Expected use<br>cases&quot; are prototypical use cases that I expect most uses to fall under.<br></p><p>I think APIs for marshalling should evolve toward higher abstraction and safety. For starters, they should probably use UnsafeBufferPointer more often than UnsafePointer. But those APIs need time to evolve. The important thing for this release is to settle on the source-breaking changes to UnsafePointer and establish clear, verifiable rules for safety at the lowest level of the API.<br></p><p>One of the conundrums of this proposal is that well designed APIs should not need to use UnsafeRawPointer, but it does need to exist as the sanctioned way to work around limitations of UnsafePointer. If UnsafePointer is the *only* way to directly access a memory buffer, then it&#39;s natural for users to assume that they can use it as a valid workaround for all the messy interoperability, marshalling, and low-level buffer access problem that they face in practice. The situation today is that the UnsafePointer API encourages that misuse, and we possibly miscompile the code without warning.<br></p><p>-Andy<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
