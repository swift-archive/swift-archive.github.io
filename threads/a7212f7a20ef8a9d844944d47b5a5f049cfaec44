<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>November  8, 2016 at 11:00:00pm</p></header><div class="content"><p>Gist link &lt;https://gist.github.com/Anton3/ba56a29986c59e9595368be3cb02fb1b&gt;<br>Introduction<br></p><p>Change nil literal type from () to Nil.<br>Before:<br></p><p>public protocol ExpressibleByNilLiteral {<br>  init(nilLiteral: ())<br>}<br></p><p>After:<br></p><p>public struct Nil {<br>  init()<br>}<br>public protocol ExpressibleByNilLiteral {<br>  associatedtype NilLiteralType = Nil<br>  init(nilLiteral: NilLiteralType)<br>}<br></p><p>Motivation<br></p><p>Currently, nil differs from other literals: it doesn’t have its own type.<br>But in some cases we want to deal directly with it, without creating any<br>instances.<br></p><p>The most important use case is comparison of an Optional to nil.<br>Currently, this operation is implemented using a hidden struct<br>_OptionalNilComparisonType,<br>which is needed precisely because because nil does not have its own type.<br>Removal of such underscored types is one of the goals stated in Generics<br>manifesto.<br></p><p>Additionally, declaration of ExpressibleByNilLiteral differs from all other<br>Expressibles,<br>because it doesn’t have a Literal type. It is generally beneficial to<br>eliminate special cases.<br>Proposed solution<br></p><p>Introduce a struct Nil, which becomes the default type for nil literals:<br></p><p>public struct Nil : ExpressibleByNilLiteral {<br>  init()<br>  init(nilLiteral: NilLiteralType)<br>}<br>let a = nilprint(type(of: a))   //=&gt; Nil<br></p><p>Rewrite ExpressibleByNilLiteral:<br></p><p>public protocol ExpressibleByNilLiteral {<br>  associatedtype NilLiteralType = Nil<br>  init(nilLiteral: NilLiteralType)<br>}<br></p><p>Make use of Nil in the standard library:<br></p><p>public func == &lt;T&gt;(left: T?, right: Nil)public func == &lt;T&gt;(left: Nil,<br>right: T?)public func != &lt;T&gt;(left: T?, right: Nil)public func !=<br>&lt;T&gt;(left: Nil, right: T?)public func ~= &lt;T&gt;(left: Nil, right: T?)<br></p><p>Source compatibility<br></p><p>Nil identifier is taken, therefore applications that already use it will<br>stop compiling.<br>Automatic migration is somewhat possible by renaming of the old entity;<br>manual migration is recommended.<br></p><p>Applications that use declare ExpressibleByNilLiteral conformances will<br>stop compiling.<br>Automatic migration is possible.<br>Effect on ABI stability<br></p><p>Applications that use Nil identifier will have to make ABI-breaking changes.<br></p><p>Otherwise, the change can mostly be applied in an ABI-compatible manner.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/a721ec44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>November  8, 2016 at 12:00:00pm</p></header><div class="content"><p>Thank for thinking of this. I am not sure on the advantage of having nil as a concrete type. <br></p><p>Have you seen this talk?<br></p><p>https://realm.io/news/swift-summit-al-skipp-monads/<br></p><p>&quot;The concept of “nil” does not exist in Swift (despite the existence of the keyword nil!)&quot;<br></p><p>Does that talk change your mind about this pitch? <br></p><p><br></p><p><br></p><p>&gt; On Nov 8, 2016, at 12:30 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Gist link<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; Change nil literal type from () to Nil.<br>&gt; Before:<br>&gt; <br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt;   init(nilLiteral: ())<br>&gt; }<br>&gt; After:<br>&gt; <br>&gt; public struct Nil {<br>&gt;   init()<br>&gt; }<br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt;   associatedtype NilLiteralType = Nil<br>&gt;   init(nilLiteral: NilLiteralType)<br>&gt; }<br>&gt; Motivation<br>&gt; <br>&gt; Currently, nil differs from other literals: it doesn’t have its own type.<br>&gt; But in some cases we want to deal directly with it, without creating any instances.<br>&gt; <br>&gt; The most important use case is comparison of an Optional to nil.<br>&gt; Currently, this operation is implemented using a hidden struct _OptionalNilComparisonType,<br>&gt; which is needed precisely because because nil does not have its own type.<br>&gt; Removal of such underscored types is one of the goals stated in Generics manifesto.<br>&gt; <br>&gt; Additionally, declaration of ExpressibleByNilLiteral differs from all other Expressibles,<br>&gt; because it doesn’t have a Literal type. It is generally beneficial to eliminate special cases.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Introduce a struct Nil, which becomes the default type for nil literals:<br>&gt; <br>&gt; public struct Nil : ExpressibleByNilLiteral {<br>&gt;   init()<br>&gt;   init(nilLiteral: NilLiteralType)<br>&gt; }<br>&gt; <br>&gt; let a = nil<br>&gt; print(type(of: a))   //=&gt; Nil<br>&gt; Rewrite ExpressibleByNilLiteral:<br>&gt; <br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt;   associatedtype NilLiteralType = Nil<br>&gt;   init(nilLiteral: NilLiteralType)<br>&gt; }<br>&gt; Make use of Nil in the standard library:<br>&gt; <br>&gt; public func == &lt;T&gt;(left: T?, right: Nil)<br>&gt; public func == &lt;T&gt;(left: Nil, right: T?)<br>&gt; public func != &lt;T&gt;(left: T?, right: Nil)<br>&gt; public func != &lt;T&gt;(left: Nil, right: T?)<br>&gt; public func ~= &lt;T&gt;(left: Nil, right: T?)<br>&gt; Source compatibility<br>&gt; <br>&gt; Nil identifier is taken, therefore applications that already use it will stop compiling.<br>&gt; Automatic migration is somewhat possible by renaming of the old entity; manual migration is recommended.<br>&gt; <br>&gt; Applications that use declare ExpressibleByNilLiteral conformances will stop compiling.<br>&gt; Automatic migration is possible.<br>&gt; <br>&gt; Effect on ABI stability<br>&gt; <br>&gt; Applications that use Nil identifier will have to make ABI-breaking changes.<br>&gt; <br>&gt; Otherwise, the change can mostly be applied in an ABI-compatible manner.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/db61d6f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>November  9, 2016 at 12:00:00am</p></header><div class="content"><p>2016-11-08 23:43 GMT+03:00 Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;:<br></p><p>Thank for thinking of this. I am not sure on the advantage of having nil as<br>&gt; a concrete type.<br>&gt;<br>&gt; Have you seen this talk?<br>&gt;<br>&gt; https://realm.io/news/swift-summit-al-skipp-monads/<br>&gt;<br>&gt; &quot;The concept of “nil” does not exist in Swift (despite the existence of<br>&gt; the keyword nil!)&quot;<br>&gt;<br>&gt; Does that talk change your mind about this pitch?<br>&gt;<br>Not much. We can talk about Swift literals being untyped as much as we<br>want, but still all of them, except for nil, have an internal storage type,<br>which is also picked by default.<br>For example, integer literals are Builtin.Int2048, if I’m not mistaken. But<br>we just can’t store nil without creating an instance of a potentially<br>complex type.<br></p><p>And this proposal is not about adding nil to all types. You can do this now<br>with Any, in any case:<br></p><p>let optionalInt1: Any = 42let optionalInt2: Any = ()   // ewww<br></p><p>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/e6ce962f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>November  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Nov 8, 2016, at 1:05 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; 2016-11-08 23:43 GMT+03:00 Jose Cheyo Jimenez &lt;cheyo at masters3d.com&gt;:<br>&gt; <br>&gt;&gt; Thank for thinking of this. I am not sure on the advantage of having nil as a concrete type. <br>&gt;&gt; <br>&gt;&gt; Have you seen this talk?<br>&gt;&gt; <br>&gt;&gt; https://realm.io/news/swift-summit-al-skipp-monads/<br>&gt;&gt; <br>&gt;&gt; &quot;The concept of “nil” does not exist in Swift (despite the existence of the keyword nil!)&quot;<br>&gt;&gt; <br>&gt;&gt; Does that talk change your mind about this pitch?<br>&gt; <br>&gt; Not much. We can talk about Swift literals being untyped as much as we want, but still all of them, except for nil, have an internal storage type, which is also picked by default.<br>&gt; <br>Having nil be a concrete type would be extremely confusing to me. I believe currently nil gets stripped out during compilation and it gets replaced with their respective Optional&lt;Type&gt;.none<br> nil is just a convenient way to work with optionals. The same goes to implicit unwrap optionals !<br></p><p>I guess I don&#39;t see a reason why nil should be a concrete at all.  <br></p><p>&gt; For example, integer literals are Builtin.Int2048, if I’m not mistaken. But we just can’t store nil without creating an instance of a potentially complex type.<br>&gt; <br>&gt; And this proposal is not about adding nil to all types. You can do this now with Any, in any case:<br>&gt; <br>&gt; let optionalInt1: Any = 42<br>&gt; let optionalInt2: Any = ()   // ewww<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/8645f38b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>November  8, 2016 at 09:00:00pm</p></header><div class="content"><p>At first glance this doesn’t make any sense to me:<br></p><p>public protocol ExpressibleByNilLiteral {<br>  associatedtype NilLiteralType = Nil<br>  init(nilLiteral: NilLiteralType)<br>}<br>What’s the need for associatedtype there?<br></p><p>Shouldn’t it be just like this:<br></p><p>public protocol ExpressibleByNilLiteral {<br></p><p>  init(nilLiteral: Nil)<br>}<br>I actually would appreciate this change, because of one thing I run into a few days ago.<br></p><p>I’m building a library for BSON (Binary JSON) where I have a struct Document which conforms to ExpressibleByDictionaryLiteral. Than I have a protocol which can convert any type to a value type my document can store.<br></p><p>Now I would have to choose how to implement ExpressibleByDictionaryLiteral:<br></p><p>public init(dictionaryLiteral elements: (String, Element.Value)...)<br></p><p>public init(dictionaryLiteral elements: (String, ElementValueConvertible)…)<br></p><p>If I would go for the second version, I’d lose the ExpressibleByNilLiteral from my value type but I could use every other type naturally.<br></p><p>With the proposed change I could extend Nil with my protocol and make the conversion naturally again.<br></p><p>That is the only advantage I would gain from such a change in the language.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. November 2016 um 21:30:26, Anton Zhilin via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Gist link<br></p><p>Introduction<br></p><p>Change  <br>nil literal type from  <br>() to  <br>Nil.<br>Before:<br></p><p>public protocol ExpressibleByNilLiteral {<br>  init(nilLiteral: ())<br>}<br>After:<br></p><p>public struct Nil {<br>  init()<br>}<br>public protocol ExpressibleByNilLiteral {<br>  associatedtype NilLiteralType = Nil<br>  init(nilLiteral: NilLiteralType)<br>}<br>Motivation<br></p><p>Currently,  <br>nil differs from other literals: it doesn’t have its own type.<br>But in some cases we want to deal directly with it, without creating any instances.<br></p><p>The most important use case is comparison of an  <br>Optional to  <br>nil.<br>Currently, this operation is implemented using a hidden struct  <br>_OptionalNilComparisonType,<br>which is needed precisely because because  <br>nil does not have its own type.<br>Removal of such underscored types is one of the goals stated in Generics manifesto.<br></p><p>Additionally, declaration of  <br>ExpressibleByNilLiteral differs from all other  <br>Expressibles,<br>because it doesn’t have a  <br>Literal type. It is generally beneficial to eliminate special cases.<br></p><p>Proposed solution<br></p><p>Introduce a struct  <br>Nil, which becomes the default type for  <br>nil literals:<br></p><p>public struct Nil : ExpressibleByNilLiteral {<br>  init()<br>  init(nilLiteral: NilLiteralType)<br>}<br></p><p>let a = nil<br>print(type(of: a))   //=&gt; Nil<br>Rewrite  <br>ExpressibleByNilLiteral:<br></p><p>public protocol ExpressibleByNilLiteral {<br>  associatedtype NilLiteralType = Nil<br>  init(nilLiteral: NilLiteralType)<br>}<br>Make use of  <br>Nil in the standard library:<br></p><p>public func == &lt;T&gt;(left: T?, right: Nil)<br>public func == &lt;T&gt;(left: Nil, right: T?)<br>public func != &lt;T&gt;(left: T?, right: Nil)<br>public func != &lt;T&gt;(left: Nil, right: T?)<br>public func ~= &lt;T&gt;(left: Nil, right: T?)<br>Source compatibility<br></p><p><br>Nil identifier is taken, therefore applications that already use it will stop compiling.<br>Automatic migration is somewhat possible by renaming of the old entity; manual migration is recommended.<br></p><p>Applications that use declare  <br>ExpressibleByNilLiteral conformances will stop compiling.<br>Automatic migration is possible.<br></p><p>Effect on ABI stability<br></p><p>Applications that use  <br>Nil identifier will have to make ABI-breaking changes.<br></p><p>Otherwise, the change can mostly be applied in an ABI-compatible manner.<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/5b7ea081/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>November  8, 2016 at 10:00:00pm</p></header><div class="content"><p>If we start from this thought…<br></p><p>&gt; Adrian Zubarev wrote:<br>&gt; Shouldn’t it be just like this:<br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt; <br>&gt;   init(nilLiteral: Nil)<br>&gt; }<br></p><p>Then why not just:<br></p><p>    public protocol ExpressibleByIntLiteral {<br>      static var `nil`: Self<br>    }<br></p><p>…such that Foo.nil creates your nil value of type Foo?<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/512ee306/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>November  8, 2016 at 10:00:00pm</p></header><div class="content"><p>This is a clean approach but that would not solve the example I mentioned.<br></p><p>let document: Document = [<br>    &quot;key&quot; = nil // won&#39;t work for the second version of the implementation I mentioned<br>]<br>Do solve this problem here, I’d need a real Nil type I could extend.<br></p><p>extension Nil : MyProtocol { … }<br>Than the above example will work correctly.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. November 2016 um 21:53:44, Pyry Jahkola (pyry.jahkola at iki.fi) schrieb:<br></p><p>If we start from this thought…<br></p><p>Adrian Zubarev wrote:<br>Shouldn’t it be just like this:<br>public protocol ExpressibleByNilLiteral {<br></p><p>  init(nilLiteral: Nil)<br>}<br></p><p>Then why not just:<br></p><p>    public protocol ExpressibleByIntLiteral {<br>      static var `nil`: Self<br>    }<br></p><p>…such that Foo.nil creates your nil value of type Foo?<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/c6876be6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>November  9, 2016 at 12:00:00am</p></header><div class="content"><p>2016-11-08 23:53 GMT+03:00 Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;:<br></p><p>Then why not just:<br>&gt;<br>&gt;     public protocol ExpressibleByIntLiteral {<br>&gt;       static var `nil`: Self<br>&gt;     }<br>&gt;<br>&gt; …such that Foo.nil creates your nil value of type Foo?<br>&gt;<br>This proposal is not about creating an alternate syntax for nil as<br>Optional&lt;Foo&gt;. It’s about granting nil literal its own type:<br></p><p>let a = nilprint(type(of: a))  //=&gt; Nil<br></p><p>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/a237623f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>November  8, 2016 at 10:00:00pm</p></header><div class="content"><p>Could you elaborate an implementation for one of these functions:<br></p><p>func == &lt;T&gt;(left: T?, right: Nil)<br>…<br>I’m a little confused how these would work, because the types are different and the optional is either .none or .some(T) of type Optional&lt;T&gt; where the other side is Nil.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 8. November 2016 um 22:07:53, Anton Zhilin (antonyzhilin at gmail.com) schrieb:<br></p><p>2016-11-08 23:53 GMT+03:00 Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;:<br></p><p>Then why not just:<br></p><p>    public protocol ExpressibleByIntLiteral {<br>      static var `nil`: Self<br>    }<br></p><p>…such that Foo.nil creates your nil value of type Foo?<br>This proposal is not about creating an alternate syntax for  <br>nil as Optional&lt;Foo&gt;. It’s about granting  <br>nil literal its own type:<br></p><p>let a = nil<br>print(type(of: a))  //=&gt; Nil<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/ab234d2c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>November  9, 2016 at 12:00:00am</p></header><div class="content"><p>2016-11-09 0:12 GMT+03:00 Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;:<br></p><p>Could you elaborate an implementation for one of these functions:<br>&gt;<br>func == &lt;T&gt;(left: T?, right: Nil) {<br>    switch left {<br>        case .some(_): return false<br>        case .none: return true<br>    }<br>}<br></p><p>The implementation is basically the same as of now, except that instead of<br>Nil, there is _OptionalNilComparisonType.<br></p><p>Main use case of Nil would essentially be partial specialization of<br>functions.<br>See example with optional comparison: there exists a generic version that<br>takes a proper ExpressibleByNilLiteral (in this case Optional&lt;T&gt;), but we<br>can apply simpler logic in case we see nil.<br></p><p>Frankly speaking, I’m not sure myself this feature would find any use<br>except for the mentioned optional comparison operators.<br>So I will probably stop pushing this forward.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/0a3c0fcd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>November  8, 2016 at 04:00:00pm</p></header><div class="content"><p>-1.  This type is isomorphic to () from a language-internal perspective and will introduce an extra name for which no useful algorithms can be written against from an external one - which makes the proposal isomorphic to one that introduces a keyword without significant justification.<br></p><p>~Robert Widmann<br></p><p>2016/11/08 16:07、Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; 2016-11-08 23:53 GMT+03:00 Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt;:<br>&gt; <br>&gt;&gt; Then why not just:<br>&gt;&gt; <br>&gt;&gt;     public protocol ExpressibleByIntLiteral {<br>&gt;&gt;       static var `nil`: Self<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; …such that Foo.nil creates your nil value of type Foo?<br>&gt; <br>&gt; This proposal is not about creating an alternate syntax for nil as Optional&lt;Foo&gt;. It’s about granting nil literal its own type:<br>&gt; <br>&gt; let a = nil<br>&gt; print(type(of: a))  //=&gt; Nil<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/5d31ad2c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 8, 2016, at 1:07 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2016-11-08 23:53 GMT+03:00 Pyry Jahkola &lt;pyry.jahkola at iki.fi &lt;mailto:pyry.jahkola at iki.fi&gt;&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Then why not just:<br>&gt; <br>&gt;     public protocol ExpressibleByIntLiteral {<br>&gt;       static var `nil`: Self<br>&gt;     }<br>&gt; <br>&gt; …such that Foo.nil creates your nil value of type Foo?<br>&gt; <br>&gt; <br>&gt; This proposal is not about creating an alternate syntax for nil as Optional&lt;Foo&gt;. It’s about granting nil literal its own type:<br>&gt; <br>&gt; let a = nil<br>&gt; print(type(of: a))  //=&gt; Nil<br></p><p>Is this desirable?<br></p><p>John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/41ef1d34/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>November  9, 2016 at 12:00:00am</p></header><div class="content"><p>2016-11-08 23:44 GMT+03:00 Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt;:<br></p><p>At first glance this doesn’t make any sense to me:<br>&gt;<br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt;   associatedtype NilLiteralType = Nil<br>&gt;   init(nilLiteral: NilLiteralType)<br>&gt; }<br>&gt;<br>&gt; What’s the need for associatedtype there?<br>&gt;<br>&gt; Shouldn’t it be just like this:<br>&gt;<br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt;<br>&gt;   init(nilLiteral: Nil)<br>&gt; }<br>&gt;<br>&gt; Probably. I just looked at ExpressibleByBooleanLiteral, and it contained<br>BooleanLiteralType, which should always be Bool by convention.<br>If someone knows, why this associatedtype is needed in<br>ExpressibleByBooleanLiteral, please explain.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/f7900f37/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November  9, 2016 at 04:00:00pm</p></header><div class="content"><p>-1<br></p><p>Personally, I don’t like writing “nil” at all. In my understanding of Swift, “nil” is simply a C-like shorthand for &quot;Optional&lt;T&gt;.none”. <br>If the compiler can’t infer T (such as “let a = nil”), it should fall-back to Optional&lt;Any&gt;.none; I’m very surprised that this isn’t the case currently.<br></p><p>There is a bug where the type-checker can’t always infer the type when you just write “.none”, but outside of that I think it’s a swiftier way of doing things: https://bugs.swift.org/browse/SR-2302 &lt;https://bugs.swift.org/browse/SR-2302&gt;<br></p><p>I would be more likely to support the opposite proposal - to eliminate the “nil” literal altogether and replace it with “.none”.<br></p><p>- Karl<br></p><p><br></p><p>&gt; On 8 Nov 2016, at 21:30, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Gist link &lt;https://gist.github.com/Anton3/ba56a29986c59e9595368be3cb02fb1b&gt;<br>&gt; Introduction<br>&gt; <br>&gt; Change nil literal type from () to Nil.<br>&gt; Before:<br>&gt; <br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt;   init(nilLiteral: ())<br>&gt; }<br>&gt; After:<br>&gt; <br>&gt; public struct Nil {<br>&gt;   init()<br>&gt; }<br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt;   associatedtype NilLiteralType = Nil<br>&gt;   init(nilLiteral: NilLiteralType)<br>&gt; }<br>&gt; Motivation<br>&gt; <br>&gt; Currently, nil differs from other literals: it doesn’t have its own type.<br>&gt; But in some cases we want to deal directly with it, without creating any instances.<br>&gt; <br>&gt; The most important use case is comparison of an Optional to nil.<br>&gt; Currently, this operation is implemented using a hidden struct _OptionalNilComparisonType,<br>&gt; which is needed precisely because because nil does not have its own type.<br>&gt; Removal of such underscored types is one of the goals stated in Generics manifesto.<br>&gt; <br>&gt; Additionally, declaration of ExpressibleByNilLiteral differs from all other Expressibles,<br>&gt; because it doesn’t have a Literal type. It is generally beneficial to eliminate special cases.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Introduce a struct Nil, which becomes the default type for nil literals:<br>&gt; <br>&gt; public struct Nil : ExpressibleByNilLiteral {<br>&gt;   init()<br>&gt;   init(nilLiteral: NilLiteralType)<br>&gt; }<br>&gt; <br>&gt; let a = nil<br>&gt; print(type(of: a))   //=&gt; Nil<br>&gt; Rewrite ExpressibleByNilLiteral:<br>&gt; <br>&gt; public protocol ExpressibleByNilLiteral {<br>&gt;   associatedtype NilLiteralType = Nil<br>&gt;   init(nilLiteral: NilLiteralType)<br>&gt; }<br>&gt; Make use of Nil in the standard library:<br>&gt; <br>&gt; public func == &lt;T&gt;(left: T?, right: Nil)<br>&gt; public func == &lt;T&gt;(left: Nil, right: T?)<br>&gt; public func != &lt;T&gt;(left: T?, right: Nil)<br>&gt; public func != &lt;T&gt;(left: Nil, right: T?)<br>&gt; public func ~= &lt;T&gt;(left: Nil, right: T?)<br>&gt; Source compatibility<br>&gt; <br>&gt; Nil identifier is taken, therefore applications that already use it will stop compiling.<br>&gt; Automatic migration is somewhat possible by renaming of the old entity; manual migration is recommended.<br>&gt; <br>&gt; Applications that use declare ExpressibleByNilLiteral conformances will stop compiling.<br>&gt; Automatic migration is possible.<br>&gt; <br>&gt; Effect on ABI stability<br>&gt; <br>&gt; Applications that use Nil identifier will have to make ABI-breaking changes.<br>&gt; <br>&gt; Otherwise, the change can mostly be applied in an ABI-compatible manner.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/44f8fbf0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nil struct</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 9 Nov 2016, at 16:55, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; If the compiler can’t infer T (such as “let a = nil”), it should fall-back to Optional&lt;Any&gt;.none; I’m very surprised that this isn’t the case currently.<br>&gt; <br></p><p>Oh, it is the case currently:<br></p><p>let a = nil<br>error: repl.swift:1:9: error: &#39;nil&#39; requires a contextual type<br></p><p>I’m not familiar with why the compiler needs _OptionalNilComparisonType in order to compare to “nil”, but I would guess it could be improved to recognise the literal natively if removing this protocol is a significant concern.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/73681eb6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
