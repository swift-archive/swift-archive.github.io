<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9d9d4c769b20cd12b15f4e5b991b4ca5?s=50"></div><header><strong>Swift *less* safe than C for imported API that uses opaque struct pointers</strong> from <string>Timothy J. Wood</string> &lt;tjw at omnigroup.com&gt;<p>June 22, 2016 at 11:00:00am</p></header><div class="content"><p>Currently, APIs that get imported with COpaquePointer make Swift *less* safe than C. Fixing this seems like a breaking change, since it would change the meaning of existing code that uses COpaquePointer. <br></p><p>As a motivating example consider:<br></p><p>import Darwin<br></p><p>var state = copyfile_state_alloc()<br>print(&quot;state = \(state.dynamicType) \(state)&quot;)<br></p><p>let acl = acl_init(1)<br>print(&quot;acl = \(acl.dynamicType) \(acl)&quot;)<br></p><p>state = acl<br>print(&quot;state = \(state.dynamicType) \(state)&quot;)<br></p><p>I’m just using these types since they use opaque structs and are easy to create in this sample, but this pattern is fairly common in other C APIs that try to encapsulate their implementation.<br></p><p>This compiles and builds, silently accepting the bogus code:<br></p><p>DEVELOPER_DIR=/Applications/Xcode-8.0b1.app/Contents/Developer  swift c-unsafety.swift<br>state = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db481b3d0)<br>acl = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db2944c00)<br>state = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db2944c00)<br></p><p>The equivalent C version:<br></p><p>copyfile_state_t state = state = copyfile_state_alloc();<br>acl_t acl = acl_init(1);<br>state = acl;<br></p><p>produces a warning:<br></p><p>c-unsafety.c:10:8: warning: incompatible pointer types assigning to &#39;copyfile_state_t&#39; (aka &#39;struct _copyfile_state *&#39;) from &#39;acl_t&#39; (aka &#39;struct _acl *&#39;)<br></p><p><br>Would it be feasible to import these sorts of pointers in a safe(r) way by making COpaquePointer generic and faking up a struct tag type? So, these might get imported with something equivalent to:<br></p><p>struct _acl {}<br>typealias acl_t = COpaquePointer&lt;_acl&gt;<br></p><p>A further problem, though, is that other examples of this use `const` to form a very basic `isa` relationship between two types. For example:<br></p><p>typedef const struct OpaqueJSContext* JSContextRef;<br>typedef struct OpaqueJSContext* JSGlobalContextRef;<br> <br>so this approach wouldn’t solve casting between these two C types, but perhaps the name of tagging struct could indicate the `const` (“Const_ OpaqueJSContext”?) or maybe COpaquePointer could be used for `const` and a MutableCOpaquePointer type could be added for the non-const case?<br></p><p>There would also be issues if one Swift module tried to pass one of these to another; the made-up struct tag would need to be in some global namespace to avoid errors passing A.COpaquePointer&lt;OpaqueFoo&gt; to B.COpaquePointer&lt;OpaqueFoo&gt; (though really I don’t consider this to be a big problem -- the surface level API of a Swift module using C libraries that deal with C API should mostly try to hide that internally).<br></p><p>In my “real” cases, I’ve been trying to *immediately* wrap the COpaquePointer in a struct of my own, but this doesn’t handle the ‘isa-like’ relationship between a const/non-const variant of an opaque struct pointer, is much more verbose, and it is easy to mess it up and accidentally cross the streams. And of course, with all the contortions Swift goes to try to be safe, this regression in safety from C is puzzling.<br></p><p>Thanks!<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/79444a8b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Swift *less* safe than C for imported API that uses opaque struct pointers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 11:20 AM, Timothy J. Wood via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Currently, APIs that get imported with COpaquePointer make Swift *less* safe than C. Fixing this seems like a breaking change, since it would change the meaning of existing code that uses COpaquePointer. <br>&gt; <br>&gt; As a motivating example consider:<br>&gt; <br>&gt; import Darwin<br>&gt; <br>&gt; var state = copyfile_state_alloc()<br>&gt; print(&quot;state = \(state.dynamicType) \(state)&quot;)<br>&gt; <br>&gt; let acl = acl_init(1)<br>&gt; print(&quot;acl = \(acl.dynamicType) \(acl)&quot;)<br>&gt; <br>&gt; state = acl<br>&gt; print(&quot;state = \(state.dynamicType) \(state)&quot;)<br>&gt; <br>&gt; I’m just using these types since they use opaque structs and are easy to create in this sample, but this pattern is fairly common in other C APIs that try to encapsulate their implementation.<br>&gt; <br>&gt; This compiles and builds, silently accepting the bogus code:<br>&gt; <br>&gt; DEVELOPER_DIR=/Applications/Xcode-8.0b1.app/Contents/Developer  swift c-unsafety.swift<br>&gt; state = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db481b3d0)<br>&gt; acl = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db2944c00)<br>&gt; state = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db2944c00)<br>&gt; <br>&gt; The equivalent C version:<br>&gt; <br>&gt; copyfile_state_t state = state = copyfile_state_alloc();<br>&gt; acl_t acl = acl_init(1);<br>&gt; state = acl;<br>&gt; <br>&gt; produces a warning:<br>&gt; <br>&gt; c-unsafety.c:10:8: warning: incompatible pointer types assigning to &#39;copyfile_state_t&#39; (aka &#39;struct _copyfile_state *&#39;) from &#39;acl_t&#39; (aka &#39;struct _acl *&#39;)<br>&gt; <br>&gt; <br>&gt; Would it be feasible to import these sorts of pointers in a safe(r) way by making COpaquePointer generic and faking up a struct tag type? So, these might get imported with something equivalent to:<br>&gt; <br>&gt; struct _acl {}<br>&gt; typealias acl_t = COpaquePointer&lt;_acl&gt;<br></p><p>We should be able to synthesize opaque types as structs with inaccessible initializers, and use the existing UnsafePointer types. That would work better in situations where you have some modules that can see the implementation of &#39;_acl&#39;, and some that can&#39;t.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Swift *less* safe than C for imported API that uses opaque struct pointers</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 12:58, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 22, 2016, at 11:20 AM, Timothy J. Wood via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Currently, APIs that get imported with COpaquePointer make Swift *less* safe than C. Fixing this seems like a breaking change, since it would change the meaning of existing code that uses COpaquePointer. <br>&gt;&gt; <br>&gt;&gt; As a motivating example consider:<br>&gt;&gt; <br>&gt;&gt; import Darwin<br>&gt;&gt; <br>&gt;&gt; var state = copyfile_state_alloc()<br>&gt;&gt; print(&quot;state = \(state.dynamicType) \(state)&quot;)<br>&gt;&gt; <br>&gt;&gt; let acl = acl_init(1)<br>&gt;&gt; print(&quot;acl = \(acl.dynamicType) \(acl)&quot;)<br>&gt;&gt; <br>&gt;&gt; state = acl<br>&gt;&gt; print(&quot;state = \(state.dynamicType) \(state)&quot;)<br>&gt;&gt; <br>&gt;&gt; I’m just using these types since they use opaque structs and are easy to create in this sample, but this pattern is fairly common in other C APIs that try to encapsulate their implementation.<br>&gt;&gt; <br>&gt;&gt; This compiles and builds, silently accepting the bogus code:<br>&gt;&gt; <br>&gt;&gt; DEVELOPER_DIR=/Applications/Xcode-8.0b1.app/Contents/Developer  swift c-unsafety.swift<br>&gt;&gt; state = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db481b3d0)<br>&gt;&gt; acl = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db2944c00)<br>&gt;&gt; state = Optional&lt;OpaquePointer&gt; Optional(0x00007f9db2944c00)<br>&gt;&gt; <br>&gt;&gt; The equivalent C version:<br>&gt;&gt; <br>&gt;&gt; copyfile_state_t state = state = copyfile_state_alloc();<br>&gt;&gt; acl_t acl = acl_init(1);<br>&gt;&gt; state = acl;<br>&gt;&gt; <br>&gt;&gt; produces a warning:<br>&gt;&gt; <br>&gt;&gt; c-unsafety.c:10:8: warning: incompatible pointer types assigning to &#39;copyfile_state_t&#39; (aka &#39;struct _copyfile_state *&#39;) from &#39;acl_t&#39; (aka &#39;struct _acl *&#39;)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Would it be feasible to import these sorts of pointers in a safe(r) way by making COpaquePointer generic and faking up a struct tag type? So, these might get imported with something equivalent to:<br>&gt;&gt; <br>&gt;&gt; struct _acl {}<br>&gt;&gt; typealias acl_t = COpaquePointer&lt;_acl&gt;<br>&gt; <br>&gt; We should be able to synthesize opaque types as structs with inaccessible initializers, and use the existing UnsafePointer types. That would work better in situations where you have some modules that can see the implementation of &#39;_acl&#39;, and some that can’t.<br></p><p>Right. The concern we’ve had here is that you’ll start off with an opaque struct and then import something else that does have the definition. I think this only comes up in the REPL, though, and maybe it’s rare enough that we could just ignore it or disallow using the type as a value in that case.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/6da8c535/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
