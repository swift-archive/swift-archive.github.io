<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Requiring special keyword to mark protocol implementation methods</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 18, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;d like to discuss declaration of protocol implementation in types.<br></p><p>Ideas of this pitch is partially based on Erica Sadun&#39;s thread:<br>[Pitch] Requiring proactive overrides for default protocol implementations.<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496<br>And on this draft of proposal:<br>https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br></p><p>I had read &quot;Winding down the Swift 3 release&quot; message, but feel like this <br>proposal makes &quot;improvements to the consistency and feel of the language&quot;<br>and supports the &quot;goal of making Swift 4 as source compatible with Swift 3 <br>as we can reasonably accomplish&quot;. Or this can be discussed as &#39;after Swift <br>3.0&#39; feature.<br></p><p><br>The main idea of my proposal<br></p><p>Swift should help us to be explicit about what methods were defined in type <br>specifically to fulfill a protocol requirements. And so we will have more <br>understandable and self-documented code that is explicit regarding the fact <br>of protocol implementation(for reader of our code and for compiler).<br></p><p>Additionally this can help to reduce potential <br>problems/error/misunderstanding in case some protocol requirement(method) <br>were *removed* - in this case (currently) our type will still have a method <br>as implementation but no such requirement in conformed protocol yet.<br></p><p><br>Details<br></p><p>I propose to introduce *implement* keyword to &#39;mark&#39; the methods(in type) <br>that were defined in order to conform to protocol.<br>Also, *reimplement* keyword is proposed to reflect the fact that method is <br>declared in *both* : in the type and in protocol extension (only in <br>extension, no definition of the method in protocol itself)<br></p><p><br>Rules<br></p><p>* Each method in type defined to fulfill the protocol conformance should be <br>marked with `implement` keyword:<br>implement func protocolRequirement() {..}<br></p><p>* Compiler produces *warning* if the same function is declared in type and <br>in protocol extension in case class conformed to that protocol. To &#39;fix&#39; <br>the warning, `reimplement` should be used.<br>reimplement func f() {..} // we aware that the same method in protocol <br>extension<br></p><p>* don&#39;t need to mark methods for type if conformance to protocol defined by <br>separate type extension<br></p><p>* `reimplement` can be placed in defining type or as special declaration in <br>type extension anywhere in source code:<br>extension Type {<br>   reimplement methodDeclaredInBothTypeAndInProtocolExtension(..); // no <br>body here. probably `;` is required - to be discussed<br>}<br>(I don&#39;t really like this requirement, but right now don&#39;t know if we can <br>do the same by using any other method )<br></p><p><br>Current behavior of protocol extension<br></p><p>When method is declared in protocol extension(*only. no in protocol <br>itself*) and in type that is conformed to the protocol, there is a <br>possibility for confusion about which method will be called. Example:<br></p><p>protocol A { func a() }<br>extension A { func b() {print(&quot;Hello from b() in extension A&quot;)} }<br></p><p>class B : A {<br>     func a() {}<br>     func b() {print(&quot;Hello from b() in B&quot;)}<br>}<br></p><p>let instance1 = B()<br>instance1.b() // Hello from b() in B<br></p><p>let instance2 : A = B()<br>instance2.b() // Hello from b() in extension A<br></p><p>func f&lt;T:A&gt;(t: T) { t.b() }<br>f(instance1) // Hello from b() in extension A<br></p><p>In this proposal I suggest compiler will generate a *warning* in this <br>case(not error). This warning can be fixed with `reimplement` keyword for <br>b() in class B.<br></p><p><br>`Override` keyword alternative<br></p><p>I think that `override` keyword can not be used instead of new `implement`, <br>as the first clearly means now that method overrides one of the methods <br>from base class. Such method already has implementation in base class(in <br>compare with protocol requirement) and &#39;belongs&#39; to `class` not to <br>`protocol`. So, in case of `override` keyword for protocol implementation <br>we&#39;ll have questions if super.method() should be called inside.<br>Also, usually declaration of `override` method is not required, in opposite <br>to implementation of protocol requirement.<br></p><p><br>Questions to discuss<br></p><p>* Should `reimplement` be used only when exactly the same method <br>declared(arguments+return type the same) or even if just method name is the <br>same(in extension there is f(v: Float) in type f(v:Double)) ? I&#39;d prefer <br>the second, but I don&#39;t feel this will be supported by community.<br></p><p><br>Code Examples:<br></p><p>A) ------------------------------------------------<br></p><p>1. We have some protocol:<br></p><p>protocol A {<br>     func a()<br>     func b()<br>     func c()<br>}<br></p><p>2. Then extension is defined for it:<br></p><p>extension A {<br>     implement func a() {} // Correct, `a` was declared in `A`<br></p><p>     //func b() {}<br>     // Incorrect: `b` was declared in `A`, `implement` is required<br>     // Compiler says: add `implement` keyword or remove implementation<br></p><p>     func d() {} // Correct, new method in extension<br></p><p>     //implement func e() {}<br>     // Incorrect: `e` was not declared in `A`, `implement` should be removed<br>     // Compiler says: remove `implement` keyword or remove implementation<br>}<br></p><p>3. *We* are writting the type S that conforms to A protocol:<br></p><p>struct S: A {<br>     implement func a() {} // Correct. We implemented A&#39;s requirement<br></p><p>     //func b() {}<br>     // Incorrect: add `implement` keyword or rename the method<br></p><p>     implement func b() {} // Correct<br>     implement func c() {} // Correct<br></p><p>     //implement func f() {}<br>     // Incorrect: No `f` declaration in protocol. Compiler: rename method <br>or drop `implement` keyword<br></p><p>     //func d() {}<br>     // Incorrect: Possible accidental name match.<br>     // Compiler: rename method or add `reimplement` keyword<br></p><p>     reimplement func d() {} // Correct. We are explicit about the fact <br>that our type has the same function as in extension of conformed protocol<br>}<br></p><p><br>B) ------------------------------------------------<br></p><p>1. Having declared protocol:<br></p><p>protocol A {<br>     func a()<br>     func b()<br>     func c()<br>}<br></p><p>2. Have defined extension<br></p><p>extension A {<br>     implement func a() {} // Correct, `a` was declared in `A`<br></p><p>     //func b() {}<br>     // Incorrect: `b` was declared in `A`, `implement` is required<br>     // Compiler says: add `implement` keyword or remove implementation<br></p><p>     func d() {} // Correct, new method in extension<br></p><p>     //implement func e() {}<br>     // Incorrect: `e` was not declared in `A`, `implement` should be removed<br>     // Compiler says: remove `implement` keyword or remove implementation<br>}<br></p><p>3. Have a type that we can&#39;t/don&#39;t want to change<br></p><p>struct S { // at this moment S don&#39;t care about any protocol<br>     func a() {}<br>     func b() {}<br>     func c() {}<br>     func d() {}<br>}<br></p><p>4. *We* need (for some task) to conform the S type to protocol A in our own <br>code. So we do:<br></p><p>extension S : A {<br>     // no need of any special steps for a(), b(), c()<br>     // as we just said &quot;we sure S conforms to A&quot;<br></p><p>     // but we need to care about special case - d() method, which is <br>defined in S type and in extension of A protocol<br>     reimplement d();  // probably `;` is required here<br>}<br></p><p><br>C) ------------------------------------------------<br></p><p>1. Have protocol<br></p><p>protocol A {<br>     func a()<br>     func b()<br>     func c()<br>}<br></p><p>2. Have a Type<br></p><p>struct S { // at this moment S don&#39;t care about any protocol<br>     func a() {}<br>     func b() {}<br>     func c() {}<br>     func d() {}<br>}<br></p><p>3. Conforms to protocol<br></p><p>extension S : A {<br>     // no need of any special steps for a(), b(), c()<br>     // as we just said &quot;we sure S conforms to A&quot;<br>     // here(at the moment of *writing*) S don&#39;t know about any extension of A<br>}<br></p><p>4. Now protocol extension is defined:<br></p><p>extension A {<br>     implement func a() {} // Correct, `a` was declared in `A`<br></p><p>     //func b() {}<br>     // Incorrect: `b` was declared in `A`, `implement` is required<br>     // Compiler says: add `implement` keyword or remove implementation<br></p><p>     func d() {} // Correct, new method in extension<br>}<br></p><p>5. But now we have a problem : same d() method in S and in A extension<br>Compiler will raise a warning : Possible accidental name match of d() in S, <br>also defined in extension of A. Change method name or add `reimplement` keyword<br></p><p>In case we can&#39;t or don&#39;t want to change the method name(in type or in <br>protocol) - the only solution is to say &quot;it&#39;s OK&quot; to the compiler anywhere <br>in our code:<br></p><p>extension S {<br>     reimplement d();  // notify the compiler that we are aware of the same <br>names<br>}<br></p><p>Thank you for your opinions on this.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Requiring special keyword to mark protocol implementation methods</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 18, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Vladmir!<br></p><p>There is something very similar to this in C#. I like this but I&#39;d<br>like to enhance it a little bit. I don&#39;t think it&#39;s necessary to<br>decorate protocol methods any further but some warnings by the<br>compiler would be welcome, like when pushing a type to adopt a<br>protocol through an extension when the type already implements a<br>protocol method (we should need an annotation to tell the compiler we<br>understand this). This would be my version of the proposal:<br></p><p>    protocol IX {<br>       func somethingA()<br>       func somethingB()<br>    }<br></p><p>    class X {<br>       func somethingA() { ... }<br>    }<br></p><p>    @warn_implemented(IX.somethingA)  // any better ideas?<br>    extension X : IX {<br>       func something() implements IX.somethingB { ... }<br>    }<br></p><p>My issue here is: what if I need to adopt two protocols (from<br>different vendors, I suppose) which require the same method and<br>signature but for each interface you&#39;re expected to have a different<br>outcome? I think better than just saying a method is an implementation<br>required by a protocol is to say explicitly which protocol required<br>that implementation. I&#39;d also suggest a syntax for declaring a method<br>that is not visible but through a cast to the protocol if that makes<br>any sense to you.<br></p><p>A method implementation can have a different name if you remember two<br>different protocols could use the same name and signature; a new name<br>would disambiguate them to us, the implements part would disambiguate<br>for the compiler.<br></p><p>What do you think?<br></p><p>On 18 May 2016 at 04:28, Vladimir.S via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I&#39;d like to discuss declaration of protocol implementation in types.<br>&gt;<br>&gt; Ideas of this pitch is partially based on Erica Sadun&#39;s thread:<br>&gt; [Pitch] Requiring proactive overrides for default protocol implementations.<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496<br>&gt; And on this draft of proposal:<br>&gt; https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br>&gt;<br>&gt; I had read &quot;Winding down the Swift 3 release&quot; message, but feel like this<br>&gt; proposal makes &quot;improvements to the consistency and feel of the language&quot;<br>&gt; and supports the &quot;goal of making Swift 4 as source compatible with Swift 3<br>&gt; as we can reasonably accomplish&quot;. Or this can be discussed as &#39;after Swift<br>&gt; 3.0&#39; feature.<br>&gt;<br>&gt;<br>&gt; The main idea of my proposal<br>&gt;<br>&gt; Swift should help us to be explicit about what methods were defined in type<br>&gt; specifically to fulfill a protocol requirements. And so we will have more<br>&gt; understandable and self-documented code that is explicit regarding the fact<br>&gt; of protocol implementation(for reader of our code and for compiler).<br>&gt;<br>&gt; Additionally this can help to reduce potential<br>&gt; problems/error/misunderstanding in case some protocol requirement(method)<br>&gt; were *removed* - in this case (currently) our type will still have a method<br>&gt; as implementation but no such requirement in conformed protocol yet.<br>&gt;<br>&gt;<br>&gt; Details<br>&gt;<br>&gt; I propose to introduce *implement* keyword to &#39;mark&#39; the methods(in type)<br>&gt; that were defined in order to conform to protocol.<br>&gt; Also, *reimplement* keyword is proposed to reflect the fact that method is<br>&gt; declared in *both* : in the type and in protocol extension (only in<br>&gt; extension, no definition of the method in protocol itself)<br>&gt;<br>&gt;<br>&gt; Rules<br>&gt;<br>&gt; * Each method in type defined to fulfill the protocol conformance should be<br>&gt; marked with `implement` keyword:<br>&gt; implement func protocolRequirement() {..}<br>&gt;<br>&gt; * Compiler produces *warning* if the same function is declared in type and<br>&gt; in protocol extension in case class conformed to that protocol. To &#39;fix&#39; the<br>&gt; warning, `reimplement` should be used.<br>&gt; reimplement func f() {..} // we aware that the same method in protocol<br>&gt; extension<br>&gt;<br>&gt; * don&#39;t need to mark methods for type if conformance to protocol defined by<br>&gt; separate type extension<br>&gt;<br>&gt; * `reimplement` can be placed in defining type or as special declaration in<br>&gt; type extension anywhere in source code:<br>&gt; extension Type {<br>&gt;   reimplement methodDeclaredInBothTypeAndInProtocolExtension(..); // no body<br>&gt; here. probably `;` is required - to be discussed<br>&gt; }<br>&gt; (I don&#39;t really like this requirement, but right now don&#39;t know if we can do<br>&gt; the same by using any other method )<br>&gt;<br>&gt;<br>&gt; Current behavior of protocol extension<br>&gt;<br>&gt; When method is declared in protocol extension(*only. no in protocol itself*)<br>&gt; and in type that is conformed to the protocol, there is a possibility for<br>&gt; confusion about which method will be called. Example:<br>&gt;<br>&gt; protocol A { func a() }<br>&gt; extension A { func b() {print(&quot;Hello from b() in extension A&quot;)} }<br>&gt;<br>&gt; class B : A {<br>&gt;     func a() {}<br>&gt;     func b() {print(&quot;Hello from b() in B&quot;)}<br>&gt; }<br>&gt;<br>&gt; let instance1 = B()<br>&gt; instance1.b() // Hello from b() in B<br>&gt;<br>&gt; let instance2 : A = B()<br>&gt; instance2.b() // Hello from b() in extension A<br>&gt;<br>&gt; func f&lt;T:A&gt;(t: T) { t.b() }<br>&gt; f(instance1) // Hello from b() in extension A<br>&gt;<br>&gt; In this proposal I suggest compiler will generate a *warning* in this<br>&gt; case(not error). This warning can be fixed with `reimplement` keyword for<br>&gt; b() in class B.<br>&gt;<br>&gt;<br>&gt; `Override` keyword alternative<br>&gt;<br>&gt; I think that `override` keyword can not be used instead of new `implement`,<br>&gt; as the first clearly means now that method overrides one of the methods from<br>&gt; base class. Such method already has implementation in base class(in compare<br>&gt; with protocol requirement) and &#39;belongs&#39; to `class` not to `protocol`. So,<br>&gt; in case of `override` keyword for protocol implementation we&#39;ll have<br>&gt; questions if super.method() should be called inside.<br>&gt; Also, usually declaration of `override` method is not required, in opposite<br>&gt; to implementation of protocol requirement.<br>&gt;<br>&gt;<br>&gt; Questions to discuss<br>&gt;<br>&gt; * Should `reimplement` be used only when exactly the same method<br>&gt; declared(arguments+return type the same) or even if just method name is the<br>&gt; same(in extension there is f(v: Float) in type f(v:Double)) ? I&#39;d prefer the<br>&gt; second, but I don&#39;t feel this will be supported by community.<br>&gt;<br>&gt;<br>&gt; Code Examples:<br>&gt;<br>&gt; A) ------------------------------------------------<br>&gt;<br>&gt; 1. We have some protocol:<br>&gt;<br>&gt; protocol A {<br>&gt;     func a()<br>&gt;     func b()<br>&gt;     func c()<br>&gt; }<br>&gt;<br>&gt; 2. Then extension is defined for it:<br>&gt;<br>&gt; extension A {<br>&gt;     implement func a() {} // Correct, `a` was declared in `A`<br>&gt;<br>&gt;     //func b() {}<br>&gt;     // Incorrect: `b` was declared in `A`, `implement` is required<br>&gt;     // Compiler says: add `implement` keyword or remove implementation<br>&gt;<br>&gt;     func d() {} // Correct, new method in extension<br>&gt;<br>&gt;     //implement func e() {}<br>&gt;     // Incorrect: `e` was not declared in `A`, `implement` should be removed<br>&gt;     // Compiler says: remove `implement` keyword or remove implementation<br>&gt; }<br>&gt;<br>&gt; 3. *We* are writting the type S that conforms to A protocol:<br>&gt;<br>&gt; struct S: A {<br>&gt;     implement func a() {} // Correct. We implemented A&#39;s requirement<br>&gt;<br>&gt;     //func b() {}<br>&gt;     // Incorrect: add `implement` keyword or rename the method<br>&gt;<br>&gt;     implement func b() {} // Correct<br>&gt;     implement func c() {} // Correct<br>&gt;<br>&gt;     //implement func f() {}<br>&gt;     // Incorrect: No `f` declaration in protocol. Compiler: rename method or<br>&gt; drop `implement` keyword<br>&gt;<br>&gt;     //func d() {}<br>&gt;     // Incorrect: Possible accidental name match.<br>&gt;     // Compiler: rename method or add `reimplement` keyword<br>&gt;<br>&gt;     reimplement func d() {} // Correct. We are explicit about the fact that<br>&gt; our type has the same function as in extension of conformed protocol<br>&gt; }<br>&gt;<br>&gt;<br>&gt; B) ------------------------------------------------<br>&gt;<br>&gt; 1. Having declared protocol:<br>&gt;<br>&gt; protocol A {<br>&gt;     func a()<br>&gt;     func b()<br>&gt;     func c()<br>&gt; }<br>&gt;<br>&gt; 2. Have defined extension<br>&gt;<br>&gt; extension A {<br>&gt;     implement func a() {} // Correct, `a` was declared in `A`<br>&gt;<br>&gt;     //func b() {}<br>&gt;     // Incorrect: `b` was declared in `A`, `implement` is required<br>&gt;     // Compiler says: add `implement` keyword or remove implementation<br>&gt;<br>&gt;     func d() {} // Correct, new method in extension<br>&gt;<br>&gt;     //implement func e() {}<br>&gt;     // Incorrect: `e` was not declared in `A`, `implement` should be removed<br>&gt;     // Compiler says: remove `implement` keyword or remove implementation<br>&gt; }<br>&gt;<br>&gt; 3. Have a type that we can&#39;t/don&#39;t want to change<br>&gt;<br>&gt; struct S { // at this moment S don&#39;t care about any protocol<br>&gt;     func a() {}<br>&gt;     func b() {}<br>&gt;     func c() {}<br>&gt;     func d() {}<br>&gt; }<br>&gt;<br>&gt; 4. *We* need (for some task) to conform the S type to protocol A in our own<br>&gt; code. So we do:<br>&gt;<br>&gt; extension S : A {<br>&gt;     // no need of any special steps for a(), b(), c()<br>&gt;     // as we just said &quot;we sure S conforms to A&quot;<br>&gt;<br>&gt;     // but we need to care about special case - d() method, which is defined<br>&gt; in S type and in extension of A protocol<br>&gt;     reimplement d();  // probably `;` is required here<br>&gt; }<br>&gt;<br>&gt;<br>&gt; C) ------------------------------------------------<br>&gt;<br>&gt; 1. Have protocol<br>&gt;<br>&gt; protocol A {<br>&gt;     func a()<br>&gt;     func b()<br>&gt;     func c()<br>&gt; }<br>&gt;<br>&gt; 2. Have a Type<br>&gt;<br>&gt; struct S { // at this moment S don&#39;t care about any protocol<br>&gt;     func a() {}<br>&gt;     func b() {}<br>&gt;     func c() {}<br>&gt;     func d() {}<br>&gt; }<br>&gt;<br>&gt; 3. Conforms to protocol<br>&gt;<br>&gt; extension S : A {<br>&gt;     // no need of any special steps for a(), b(), c()<br>&gt;     // as we just said &quot;we sure S conforms to A&quot;<br>&gt;     // here(at the moment of *writing*) S don&#39;t know about any extension of<br>&gt; A<br>&gt; }<br>&gt;<br>&gt; 4. Now protocol extension is defined:<br>&gt;<br>&gt; extension A {<br>&gt;     implement func a() {} // Correct, `a` was declared in `A`<br>&gt;<br>&gt;     //func b() {}<br>&gt;     // Incorrect: `b` was declared in `A`, `implement` is required<br>&gt;     // Compiler says: add `implement` keyword or remove implementation<br>&gt;<br>&gt;     func d() {} // Correct, new method in extension<br>&gt; }<br>&gt;<br>&gt; 5. But now we have a problem : same d() method in S and in A extension<br>&gt; Compiler will raise a warning : Possible accidental name match of d() in S,<br>&gt; also defined in extension of A. Change method name or add `reimplement`<br>&gt; keyword<br>&gt;<br>&gt; In case we can&#39;t or don&#39;t want to change the method name(in type or in<br>&gt; protocol) - the only solution is to say &quot;it&#39;s OK&quot; to the compiler anywhere<br>&gt; in our code:<br>&gt;<br>&gt; extension S {<br>&gt;     reimplement d();  // notify the compiler that we are aware of the same<br>&gt; names<br>&gt; }<br>&gt;<br>&gt; Thank you for your opinions on this.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Requiring special keyword to mark protocol implementation methods</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 07:00:00pm</p></header><div class="content"><p>Leonardo,<br>Based on the discussion for similar subject, I feel like community and core <br>team does not support the idea of more verbose decoration of protocol <br>implementation in type.<br>So, my initial proposal is trying to add the minimum of changes to the <br>current state to increase the level of clarity and self-documentation of <br>code, this will help the compiler to help us, plus my proposal can prevent <br>some kind of problems.<br></p><p>As for my initial proposal. Probably the better idea to &#39;fix&#39; the warning <br>regarding the same name in type and in protocol extension(when there is no <br>such method in protocol itself) will be not<br>extension S : A { reimplement d(); }<br>but some kind of<br>@warn_reimplement(S.d)<br></p><p><br>You are introducing more verbose decoration, and personally I probably <br>support it, but don&#39;t feel like the discussion of it will produce any <br>positive result. So I try to discuss at least this : small decoration of <br>methods that were declared specifically to fulfill the protocol requirements.<br></p><p>On 18.05.2016 23:10, Leonardo Pessoa wrote:<br>&gt; Hi Vladmir!<br>&gt;<br>&gt; There is something very similar to this in C#. I like this but I&#39;d<br>&gt; like to enhance it a little bit. I don&#39;t think it&#39;s necessary to<br>&gt; decorate protocol methods any further but some warnings by the<br>&gt; compiler would be welcome, like when pushing a type to adopt a<br>&gt; protocol through an extension when the type already implements a<br>&gt; protocol method (we should need an annotation to tell the compiler we<br>&gt; understand this). This would be my version of the proposal:<br>&gt;<br>&gt;     protocol IX {<br>&gt;        func somethingA()<br>&gt;        func somethingB()<br>&gt;     }<br>&gt;<br>&gt;     class X {<br>&gt;        func somethingA() { ... }<br>&gt;     }<br>&gt;<br>&gt;     @warn_implemented(IX.somethingA)  // any better ideas?<br>&gt;     extension X : IX {<br>&gt;        func something() implements IX.somethingB { ... }<br>&gt;     }<br>&gt;<br>&gt; My issue here is: what if I need to adopt two protocols (from<br>&gt; different vendors, I suppose) which require the same method and<br>&gt; signature but for each interface you&#39;re expected to have a different<br>&gt; outcome? I think better than just saying a method is an implementation<br>&gt; required by a protocol is to say explicitly which protocol required<br>&gt; that implementation. I&#39;d also suggest a syntax for declaring a method<br>&gt; that is not visible but through a cast to the protocol if that makes<br>&gt; any sense to you.<br>&gt;<br>&gt; A method implementation can have a different name if you remember two<br>&gt; different protocols could use the same name and signature; a new name<br>&gt; would disambiguate them to us, the implements part would disambiguate<br>&gt; for the compiler.<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; On 18 May 2016 at 04:28, Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I&#39;d like to discuss declaration of protocol implementation in types.<br>&gt;&gt;<br>&gt;&gt; Ideas of this pitch is partially based on Erica Sadun&#39;s thread:<br>&gt;&gt; [Pitch] Requiring proactive overrides for default protocol implementations.<br>&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496<br>&gt;&gt; And on this draft of proposal:<br>&gt;&gt; https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br>&gt;&gt;<br>&gt;&gt; I had read &quot;Winding down the Swift 3 release&quot; message, but feel like this<br>&gt;&gt; proposal makes &quot;improvements to the consistency and feel of the language&quot;<br>&gt;&gt; and supports the &quot;goal of making Swift 4 as source compatible with Swift 3<br>&gt;&gt; as we can reasonably accomplish&quot;. Or this can be discussed as &#39;after Swift<br>&gt;&gt; 3.0&#39; feature.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The main idea of my proposal<br>&gt;&gt;<br>&gt;&gt; Swift should help us to be explicit about what methods were defined in type<br>&gt;&gt; specifically to fulfill a protocol requirements. And so we will have more<br>&gt;&gt; understandable and self-documented code that is explicit regarding the fact<br>&gt;&gt; of protocol implementation(for reader of our code and for compiler).<br>&gt;&gt;<br>&gt;&gt; Additionally this can help to reduce potential<br>&gt;&gt; problems/error/misunderstanding in case some protocol requirement(method)<br>&gt;&gt; were *removed* - in this case (currently) our type will still have a method<br>&gt;&gt; as implementation but no such requirement in conformed protocol yet.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Details<br>&gt;&gt;<br>&gt;&gt; I propose to introduce *implement* keyword to &#39;mark&#39; the methods(in type)<br>&gt;&gt; that were defined in order to conform to protocol.<br>&gt;&gt; Also, *reimplement* keyword is proposed to reflect the fact that method is<br>&gt;&gt; declared in *both* : in the type and in protocol extension (only in<br>&gt;&gt; extension, no definition of the method in protocol itself)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Rules<br>&gt;&gt;<br>&gt;&gt; * Each method in type defined to fulfill the protocol conformance should be<br>&gt;&gt; marked with `implement` keyword:<br>&gt;&gt; implement func protocolRequirement() {..}<br>&gt;&gt;<br>&gt;&gt; * Compiler produces *warning* if the same function is declared in type and<br>&gt;&gt; in protocol extension in case class conformed to that protocol. To &#39;fix&#39; the<br>&gt;&gt; warning, `reimplement` should be used.<br>&gt;&gt; reimplement func f() {..} // we aware that the same method in protocol<br>&gt;&gt; extension<br>&gt;&gt;<br>&gt;&gt; * don&#39;t need to mark methods for type if conformance to protocol defined by<br>&gt;&gt; separate type extension<br>&gt;&gt;<br>&gt;&gt; * `reimplement` can be placed in defining type or as special declaration in<br>&gt;&gt; type extension anywhere in source code:<br>&gt;&gt; extension Type {<br>&gt;&gt;   reimplement methodDeclaredInBothTypeAndInProtocolExtension(..); // no body<br>&gt;&gt; here. probably `;` is required - to be discussed<br>&gt;&gt; }<br>&gt;&gt; (I don&#39;t really like this requirement, but right now don&#39;t know if we can do<br>&gt;&gt; the same by using any other method )<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Current behavior of protocol extension<br>&gt;&gt;<br>&gt;&gt; When method is declared in protocol extension(*only. no in protocol itself*)<br>&gt;&gt; and in type that is conformed to the protocol, there is a possibility for<br>&gt;&gt; confusion about which method will be called. Example:<br>&gt;&gt;<br>&gt;&gt; protocol A { func a() }<br>&gt;&gt; extension A { func b() {print(&quot;Hello from b() in extension A&quot;)} }<br>&gt;&gt;<br>&gt;&gt; class B : A {<br>&gt;&gt;     func a() {}<br>&gt;&gt;     func b() {print(&quot;Hello from b() in B&quot;)}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let instance1 = B()<br>&gt;&gt; instance1.b() // Hello from b() in B<br>&gt;&gt;<br>&gt;&gt; let instance2 : A = B()<br>&gt;&gt; instance2.b() // Hello from b() in extension A<br>&gt;&gt;<br>&gt;&gt; func f&lt;T:A&gt;(t: T) { t.b() }<br>&gt;&gt; f(instance1) // Hello from b() in extension A<br>&gt;&gt;<br>&gt;&gt; In this proposal I suggest compiler will generate a *warning* in this<br>&gt;&gt; case(not error). This warning can be fixed with `reimplement` keyword for<br>&gt;&gt; b() in class B.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; `Override` keyword alternative<br>&gt;&gt;<br>&gt;&gt; I think that `override` keyword can not be used instead of new `implement`,<br>&gt;&gt; as the first clearly means now that method overrides one of the methods from<br>&gt;&gt; base class. Such method already has implementation in base class(in compare<br>&gt;&gt; with protocol requirement) and &#39;belongs&#39; to `class` not to `protocol`. So,<br>&gt;&gt; in case of `override` keyword for protocol implementation we&#39;ll have<br>&gt;&gt; questions if super.method() should be called inside.<br>&gt;&gt; Also, usually declaration of `override` method is not required, in opposite<br>&gt;&gt; to implementation of protocol requirement.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Questions to discuss<br>&gt;&gt;<br>&gt;&gt; * Should `reimplement` be used only when exactly the same method<br>&gt;&gt; declared(arguments+return type the same) or even if just method name is the<br>&gt;&gt; same(in extension there is f(v: Float) in type f(v:Double)) ? I&#39;d prefer the<br>&gt;&gt; second, but I don&#39;t feel this will be supported by community.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Code Examples:<br>&gt;&gt;<br>&gt;&gt; A) ------------------------------------------------<br>&gt;&gt;<br>&gt;&gt; 1. We have some protocol:<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;     func a()<br>&gt;&gt;     func b()<br>&gt;&gt;     func c()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 2. Then extension is defined for it:<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;     implement func a() {} // Correct, `a` was declared in `A`<br>&gt;&gt;<br>&gt;&gt;     //func b() {}<br>&gt;&gt;     // Incorrect: `b` was declared in `A`, `implement` is required<br>&gt;&gt;     // Compiler says: add `implement` keyword or remove implementation<br>&gt;&gt;<br>&gt;&gt;     func d() {} // Correct, new method in extension<br>&gt;&gt;<br>&gt;&gt;     //implement func e() {}<br>&gt;&gt;     // Incorrect: `e` was not declared in `A`, `implement` should be removed<br>&gt;&gt;     // Compiler says: remove `implement` keyword or remove implementation<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 3. *We* are writting the type S that conforms to A protocol:<br>&gt;&gt;<br>&gt;&gt; struct S: A {<br>&gt;&gt;     implement func a() {} // Correct. We implemented A&#39;s requirement<br>&gt;&gt;<br>&gt;&gt;     //func b() {}<br>&gt;&gt;     // Incorrect: add `implement` keyword or rename the method<br>&gt;&gt;<br>&gt;&gt;     implement func b() {} // Correct<br>&gt;&gt;     implement func c() {} // Correct<br>&gt;&gt;<br>&gt;&gt;     //implement func f() {}<br>&gt;&gt;     // Incorrect: No `f` declaration in protocol. Compiler: rename method or<br>&gt;&gt; drop `implement` keyword<br>&gt;&gt;<br>&gt;&gt;     //func d() {}<br>&gt;&gt;     // Incorrect: Possible accidental name match.<br>&gt;&gt;     // Compiler: rename method or add `reimplement` keyword<br>&gt;&gt;<br>&gt;&gt;     reimplement func d() {} // Correct. We are explicit about the fact that<br>&gt;&gt; our type has the same function as in extension of conformed protocol<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; B) ------------------------------------------------<br>&gt;&gt;<br>&gt;&gt; 1. Having declared protocol:<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;     func a()<br>&gt;&gt;     func b()<br>&gt;&gt;     func c()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 2. Have defined extension<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;     implement func a() {} // Correct, `a` was declared in `A`<br>&gt;&gt;<br>&gt;&gt;     //func b() {}<br>&gt;&gt;     // Incorrect: `b` was declared in `A`, `implement` is required<br>&gt;&gt;     // Compiler says: add `implement` keyword or remove implementation<br>&gt;&gt;<br>&gt;&gt;     func d() {} // Correct, new method in extension<br>&gt;&gt;<br>&gt;&gt;     //implement func e() {}<br>&gt;&gt;     // Incorrect: `e` was not declared in `A`, `implement` should be removed<br>&gt;&gt;     // Compiler says: remove `implement` keyword or remove implementation<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 3. Have a type that we can&#39;t/don&#39;t want to change<br>&gt;&gt;<br>&gt;&gt; struct S { // at this moment S don&#39;t care about any protocol<br>&gt;&gt;     func a() {}<br>&gt;&gt;     func b() {}<br>&gt;&gt;     func c() {}<br>&gt;&gt;     func d() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 4. *We* need (for some task) to conform the S type to protocol A in our own<br>&gt;&gt; code. So we do:<br>&gt;&gt;<br>&gt;&gt; extension S : A {<br>&gt;&gt;     // no need of any special steps for a(), b(), c()<br>&gt;&gt;     // as we just said &quot;we sure S conforms to A&quot;<br>&gt;&gt;<br>&gt;&gt;     // but we need to care about special case - d() method, which is defined<br>&gt;&gt; in S type and in extension of A protocol<br>&gt;&gt;     reimplement d();  // probably `;` is required here<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; C) ------------------------------------------------<br>&gt;&gt;<br>&gt;&gt; 1. Have protocol<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;     func a()<br>&gt;&gt;     func b()<br>&gt;&gt;     func c()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 2. Have a Type<br>&gt;&gt;<br>&gt;&gt; struct S { // at this moment S don&#39;t care about any protocol<br>&gt;&gt;     func a() {}<br>&gt;&gt;     func b() {}<br>&gt;&gt;     func c() {}<br>&gt;&gt;     func d() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 3. Conforms to protocol<br>&gt;&gt;<br>&gt;&gt; extension S : A {<br>&gt;&gt;     // no need of any special steps for a(), b(), c()<br>&gt;&gt;     // as we just said &quot;we sure S conforms to A&quot;<br>&gt;&gt;     // here(at the moment of *writing*) S don&#39;t know about any extension of<br>&gt;&gt; A<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 4. Now protocol extension is defined:<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;     implement func a() {} // Correct, `a` was declared in `A`<br>&gt;&gt;<br>&gt;&gt;     //func b() {}<br>&gt;&gt;     // Incorrect: `b` was declared in `A`, `implement` is required<br>&gt;&gt;     // Compiler says: add `implement` keyword or remove implementation<br>&gt;&gt;<br>&gt;&gt;     func d() {} // Correct, new method in extension<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; 5. But now we have a problem : same d() method in S and in A extension<br>&gt;&gt; Compiler will raise a warning : Possible accidental name match of d() in S,<br>&gt;&gt; also defined in extension of A. Change method name or add `reimplement`<br>&gt;&gt; keyword<br>&gt;&gt;<br>&gt;&gt; In case we can&#39;t or don&#39;t want to change the method name(in type or in<br>&gt;&gt; protocol) - the only solution is to say &quot;it&#39;s OK&quot; to the compiler anywhere<br>&gt;&gt; in our code:<br>&gt;&gt;<br>&gt;&gt; extension S {<br>&gt;&gt;     reimplement d();  // notify the compiler that we are aware of the same<br>&gt;&gt; names<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Thank you for your opinions on this.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Requiring special keyword to mark protocol implementation methods</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>May 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 12:28 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to discuss declaration of protocol implementation in types.<br>&gt; <br>&gt; Ideas of this pitch is partially based on Erica Sadun&#39;s thread:<br>&gt; [Pitch] Requiring proactive overrides for default protocol implementations.<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496<br>&gt; And on this draft of proposal:<br>&gt; https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br>&gt; <br>&gt; I had read &quot;Winding down the Swift 3 release&quot; message, but feel like this proposal makes &quot;improvements to the consistency and feel of the language&quot;<br>&gt; and supports the &quot;goal of making Swift 4 as source compatible with Swift 3 as we can reasonably accomplish&quot;. Or this can be discussed as &#39;after Swift 3.0&#39; feature.<br>&gt; <br>&gt; <br>&gt; The main idea of my proposal<br>&gt; <br>&gt; Swift should help us to be explicit about what methods were defined in type specifically to fulfill a protocol requirements. And so we will have more understandable and self-documented code that is explicit regarding the fact of protocol implementation(for reader of our code and for compiler).<br>&gt; <br>&gt; Additionally this can help to reduce potential problems/error/misunderstanding in case some protocol requirement(method) were *removed* - in this case (currently) our type will still have a method as implementation but no such requirement in conformed protocol yet.<br>&gt; <br>&gt; <br>&gt; Details<br>&gt; <br>&gt; I propose to introduce *implement* keyword to &#39;mark&#39; the methods(in type) that were defined in order to conform to protocol.<br></p><p>I like this better than using the “override” or “required” keywprds.<br></p><p>&gt; Also, *reimplement* keyword is proposed to reflect the fact that method is declared in *both* : in the type and in protocol extension (only in extension, no definition of the method in protocol itself)<br></p><p>I (personally) still don’t feel like the cases handled by “reimplement” are important to distinguish from “implement”.<br></p><p>Without digging deeply into your rules, I’d like to reiterate my own (personal!) perspective on why I don’t think we need a keyword here. With a few exceptions, one can freely break up a type’s definition into a number of different extensions. A fairly common style I’ve seen it to use a unique extension for each protocol conformance, because it’s great for readability: this is the functionality that is associated with a particular protocol conformance. This style conveys essentially what the “implements” keyword conveys: that the programmer intends to implement the protocol, but it does so without any extra syntax. Moreover, if we assume that this is good style and widely practiced, the compiler can use it as a cue: non-private declarations that are within an extension that states conformance to P, that are similar to some requirement in P but aren’t used to satisfy any require, are suspicious and should produce a warning.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Requiring special keyword to mark protocol implementation methods</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 23, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On May 23, 2016, at 6:53 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 12:28 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to discuss declaration of protocol implementation in types.<br>&gt;&gt; <br>&gt;&gt; Ideas of this pitch is partially based on Erica Sadun&#39;s thread:<br>&gt;&gt; [Pitch] Requiring proactive overrides for default protocol implementations.<br>&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496<br>&gt;&gt; And on this draft of proposal:<br>&gt;&gt; https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br>&gt;&gt; <br>&gt;&gt; I had read &quot;Winding down the Swift 3 release&quot; message, but feel like this proposal makes &quot;improvements to the consistency and feel of the language&quot;<br>&gt;&gt; and supports the &quot;goal of making Swift 4 as source compatible with Swift 3 as we can reasonably accomplish&quot;. Or this can be discussed as &#39;after Swift 3.0&#39; feature.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The main idea of my proposal<br>&gt;&gt; <br>&gt;&gt; Swift should help us to be explicit about what methods were defined in type specifically to fulfill a protocol requirements. And so we will have more understandable and self-documented code that is explicit regarding the fact of protocol implementation(for reader of our code and for compiler).<br>&gt;&gt; <br>&gt;&gt; Additionally this can help to reduce potential problems/error/misunderstanding in case some protocol requirement(method) were *removed* - in this case (currently) our type will still have a method as implementation but no such requirement in conformed protocol yet.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Details<br>&gt;&gt; <br>&gt;&gt; I propose to introduce *implement* keyword to &#39;mark&#39; the methods(in type) that were defined in order to conform to protocol.<br>&gt; <br>&gt; I like this better than using the “override” or “required” keywprds.<br>&gt; <br>&gt;&gt; Also, *reimplement* keyword is proposed to reflect the fact that method is declared in *both* : in the type and in protocol extension (only in extension, no definition of the method in protocol itself)<br>&gt; <br>&gt; I (personally) still don’t feel like the cases handled by “reimplement” are important to distinguish from “implement”.<br>&gt; <br>&gt; Without digging deeply into your rules, I’d like to reiterate my own (personal!) perspective on why I don’t think we need a keyword here. With a few exceptions, one can freely break up a type’s definition into a number of different extensions. A fairly common style I’ve seen it to use a unique extension for each protocol conformance, because it’s great for readability: this is the functionality that is associated with a particular protocol conformance. This style conveys essentially what the “implements” keyword conveys: that the programmer intends to implement the protocol, but it does so without any extra syntax. Moreover, if we assume that this is good style and widely practiced, the compiler can use it as a cue: non-private declarations that are within an extension that states conformance to P, that are similar to some requirement in P but aren’t used to satisfy any require, are suspicious and should produce a warning.<br>&gt; <br></p><p>Warning on non-private non-conformance yielding methods (helpers) is likely a good thing that would cleanly address some of the issues listed here:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br></p><p>Depending on where things go with protocols, you might still end-up having override creeping its nose, but it could simply be the result of applying current swift rules.<br></p><p><br>&gt;    - Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Requiring special keyword to mark protocol implementation methods</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 23, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; I (personally) still don’t feel like the cases handled by “reimplement” <br>are important to distinguish from “implement”.<br></p><p>The main idea was to decorate *type method* that is same as *method in <br>protocol extension* if that method was *not declared in protocol* itself.<br></p><p>So, with very high _possibility_ developer *forgot* (or don&#39;t know yet) the <br>rule of static dispatch for such method and *thinks* right now that type&#39;s <br>method will be called if type of reference is protocol.<br></p><p>In contrast: implemented methods *declared* in protocol definition, will <br>be(in most cases, yes) dispatched dynamically and so type&#39;s methods will be <br>called if reference is a protocol.<br></p><p>Probably &#39;reimpements&#39; not the best name here, probably &#39;overload&#39; can be <br>used here.. Or some other to show &quot;Yes, I know this is not the protocol <br>requirement method, I&#39;m aware of its behavior and know that the same method <br>exists in protocol extension only(no in protocol itself)&quot;<br></p><p><br> &gt;This style conveys essentially what the “implements” keyword conveys: <br>that the programmer intends to implement the protocol, but it does so <br>without any extra syntax.<br> &gt; Moreover, if we assume that this is good style and widely practiced, the <br>compiler can use it as a cue: non-private declarations that are within an <br>extension that states conformance to P, that are similar to some <br>requirement in P but aren’t used to satisfy any require, are suspicious and <br>should produce a warning.<br></p><p>The idea of proposal is that Swift should help us in situation of protocol <br>conformance:<br>1. To self-document the code : clearly see which method was implemented <br>specially to fulfill the protocol requirements<br>2. Raise error/warning if conformed protocol did change: let&#39;s consider <br>removed requirement in protocol - with my proposal Swift will flag out that <br>some method decorated with &#39;implements&#39; didn&#39;t declared in protocol. Even <br>important if protocol requirement changed and such requirement has *defailt <br>implmementation* - i.e. without &#39;implements&#39; keyword, our type, previously <br>implemented all needed methods, will still have them, assuming all is ok, <br>no errors, but protocol&#39;s requirement will call the default implementation <br>and &#39;old&#39; implemented methods will never be called.<br></p><p>But I also support your suggestion regarding public methods of type <br>extension that conforms to protocol.<br>This way or another IMO we need a way to show(for reader *and* for <br>compiler) that some methods were implemented just to satisfy the protocol.<br></p><p><br>On 23.05.2016 7:53, Douglas Gregor wrote:<br>&gt;<br>&gt;&gt; On May 18, 2016, at 12:28 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to discuss declaration of protocol implementation in types.<br>&gt;&gt;<br>&gt;&gt; Ideas of this pitch is partially based on Erica Sadun&#39;s thread:<br>&gt;&gt; [Pitch] Requiring proactive overrides for default protocol implementations.<br>&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496<br>&gt;&gt; And on this draft of proposal:<br>&gt;&gt; https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br>&gt;&gt;<br>&gt;&gt; I had read &quot;Winding down the Swift 3 release&quot; message, but feel like this proposal makes &quot;improvements to the consistency and feel of the language&quot;<br>&gt;&gt; and supports the &quot;goal of making Swift 4 as source compatible with Swift 3 as we can reasonably accomplish&quot;. Or this can be discussed as &#39;after Swift 3.0&#39; feature.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The main idea of my proposal<br>&gt;&gt;<br>&gt;&gt; Swift should help us to be explicit about what methods were defined in type specifically to fulfill a protocol requirements. And so we will have more understandable and self-documented code that is explicit regarding the fact of protocol implementation(for reader of our code and for compiler).<br>&gt;&gt;<br>&gt;&gt; Additionally this can help to reduce potential problems/error/misunderstanding in case some protocol requirement(method) were *removed* - in this case (currently) our type will still have a method as implementation but no such requirement in conformed protocol yet.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Details<br>&gt;&gt;<br>&gt;&gt; I propose to introduce *implement* keyword to &#39;mark&#39; the methods(in type) that were defined in order to conform to protocol.<br>&gt;<br>&gt; I like this better than using the “override” or “required” keywprds.<br>&gt;<br>&gt;&gt; Also, *reimplement* keyword is proposed to reflect the fact that method is declared in *both* : in the type and in protocol extension (only in extension, no definition of the method in protocol itself)<br>&gt;<br>&gt; I (personally) still don’t feel like the cases handled by “reimplement” are important to distinguish from “implement”.<br>&gt;<br>&gt; Without digging deeply into your rules, I’d like to reiterate my own (personal!) perspective on why I don’t think we need a keyword here. With a few exceptions, one can freely break up a type’s definition into a number of different extensions. A fairly common style I’ve seen it to use a unique extension for each protocol conformance, because it’s great for readability: this is the functionality that is associated with a particular protocol conformance. This style conveys essentially what the “implements” keyword conveys: that the programmer intends to implement the protocol, but it does so without any extra syntax. Moreover, if we assume that this is good style and widely practiced, the compiler can use it as a cue: non-private declarations that are within an extension that states conformance to P, that are similar to some requirement in P but aren’t used to satisfy any require, are suspicious and should produce a warning.<br>&gt;<br>&gt; 	- Doug<br>&gt;<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
