<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;ve updated my pull request with a much more conservative set of<br>changes that preserves/restores label-free-ness for all “term of art”<br>functional methods such as filter and reduce.<br></p><p>https://github.com/apple/swift/pull/2981<br></p><p>My current thoughts are that many of the `by:` labels are awkward and<br>not adding much.  Perhaps they all ought to be omitted.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 29, 2016, at 1:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I&#39;ve updated my pull request with a much more conservative set of<br>&gt; changes that preserves/restores label-free-ness for all “term of art”<br>&gt; functional methods such as filter and reduce.<br>&gt; <br>&gt; https://github.com/apple/swift/pull/2981<br></p><p>I didn&#39;t participate in this discussion but want to say that I am pleased with where it ended up.  IMO this looks much better than the earlier version as well as some of the alternative that were discussed.  I think brevity is important for the common functional operators and was previously concerned with the length of some of the names.<br></p><p>&gt; <br>&gt; My current thoughts are that many of the `by:` labels are awkward and<br>&gt; not adding much.  Perhaps they all ought to be omitted.<br></p><p>Some cases are more awkward than others.  The value added by a label is also greater in some cases than others.  Unfortunately I think these tend to coincide.  <br></p><p>That said, I do think the value of a label outweighs the awkwardness in cases like min and max.<br></p><p>One change you might consider is to use different labels for comparison and equivalence relations.  &#39;by&#39; feels more natural in the context of comparisons and brevity feels more important in the methods that use a comparator.  On the other hand, I think dropping the use of the word equivalent for &#39;starts&#39; and &#39;elementsEqual&#39; feels like a step back in clarity.  Maybe we use &#39;equivalentBy&#39; in these cases.<br></p><p>A suggestion for the future enhancements - rename elementsEqual to elementsEquivalent.  If we make that change the shorter &#39;by&#39; label would feel much less awkward to me in this method.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Jun 29 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt; A suggestion for the future enhancements - rename elementsEqual to<br>&gt; elementsEquivalent.  If we make that change the shorter &#39;by&#39; label<br>&gt; would feel much less awkward to me in this method.<br></p><p>Well, <br></p><p>  x.elementsEquivalent(y, by: areSameExceptForCase)<br></p><p>is more ungrammatical than <br></p><p>  x.elementsEqual(y, by: areSameExceptForCase)<br></p><p>and breaks the connection with <br></p><p>  x.elementsEqual(y) <br></p><p>somewhat.<br></p><p>Maybe changing the closure parameter name to “areEqual” would be a<br>better choice.<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 12:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I&#39;ve updated my pull request with a much more conservative set of<br>&gt; changes that preserves/restores label-free-ness for all “term of art”<br>&gt; functional methods such as filter and reduce.<br>&gt; <br>&gt; https://github.com/apple/swift/pull/2981<br>&gt; <br>&gt; My current thoughts are that many of the `by:` labels are awkward and<br>&gt; not adding much.  Perhaps they all ought to be omitted.<br></p><p><br>I&#39;d be happy to see `by` labels go away, whether first or trailing. I&#39;m not sure why Swift 3 wants <br>to have so many extra labels when a very simple phrase is understandable on its own <br>(e.g. max, min, sort, sorted).<br></p><p>Is it possible under the Swift umbrella to do the same for split since it has the rarely used<br>maxSplits, and omittingEmptySubsequences params? It would give you `split({$0 == &quot; &quot;})` <br>and `split(atWhitespace)`.<br></p><p>Speaking of isAllWhitespace, would this be a prebuilt enumeration or is it a placeholder?<br>If the former, I have opinions (new lines, new lines and whitespace)<br></p><p>The managed buffer, are you &quot;makingValueWith&quot; instead of &quot;makingHeaderWith&quot; intentionally?<br>If so, no worries. If not, helpful ping.<br></p><p>Future Extensions:<br></p><p>* reduce(_:, combine:)  // way simpler<br></p><p>* &quot;The argument against changing other names to be more consistent with API guidelines <br>is weakened. &quot;<br></p><p> I think Sean Heber&#39;s `@termOfArt(name)` is a great way to have both worlds, where <br>`select(where:)` or `where()` is the Swifty name and `@termOfArt(filter)` offers<br>a substitutable alias for fp aficionados. <br></p><p>This approach is not anything I&#39;ve ever seen previously in a programming language but <br>its something that jumps out as a way to satisfy two distinct audiences of users<br>that would have limited impact but a decided advantage.<br></p><p>That said, I don&#39;t like `mapping` and `flattened`. If they&#39;re going to be Swiftized, go with<br>names that aren&#39;t standing in the &quot;term of art&quot; rubble: transform, squeeze, whatever.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:13 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 12:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;ve updated my pull request with a much more conservative set of<br>&gt;&gt; changes that preserves/restores label-free-ness for all “term of art”<br>&gt;&gt; functional methods such as filter and reduce.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift/pull/2981<br>&gt;&gt; <br>&gt;&gt; My current thoughts are that many of the `by:` labels are awkward and<br>&gt;&gt; not adding much.  Perhaps they all ought to be omitted.<br>&gt; <br>&gt; <br>&gt; I&#39;d be happy to see `by` labels go away, whether first or trailing. I&#39;m not sure why Swift 3 wants <br>&gt; to have so many extra labels when a very simple phrase is understandable on its own <br>&gt; (e.g. max, min, sort, sorted).<br>&gt; <br>&gt; Is it possible under the Swift umbrella to do the same for split since it has the rarely used<br>&gt; maxSplits, and omittingEmptySubsequences params? It would give you `split({$0 == &quot; &quot;})` <br>&gt; and `split(atWhitespace)`.<br>&gt; <br>&gt; Speaking of isAllWhitespace, would this be a prebuilt enumeration or is it a placeholder?<br>&gt; If the former, I have opinions (new lines, new lines and whitespace)<br>&gt; <br>&gt; The managed buffer, are you &quot;makingValueWith&quot; instead of &quot;makingHeaderWith&quot; intentionally?<br>&gt; If so, no worries. If not, helpful ping.<br>&gt; <br>&gt; Future Extensions:<br>&gt; <br>&gt; * reduce(_:, combine:)  // way simpler<br>&gt; <br>&gt; * &quot;The argument against changing other names to be more consistent with API guidelines <br>&gt; is weakened. &quot;<br>&gt; <br>&gt; I think Sean Heber&#39;s `@termOfArt(name)` is a great way to have both worlds, where <br>&gt; `select(where:)` or `where()` is the Swifty name and `@termOfArt(filter)` offers<br>&gt; a substitutable alias for fp aficionados. <br>&gt; This approach is not anything I&#39;ve ever seen previously in a programming language but <br>&gt; its something that jumps out as a way to satisfy two distinct audiences of users<br>&gt; that would have limited impact but a decided advantage.<br></p><p>Aliasing methods is pretty common in Ruby.  The advantage is that you can select the alias that reads best at a specific call site.  The disadvantage is that everyone has to learn more than one name for the same thing.<br></p><p>If we’re going to allow aliases I think it should be in support of clarity at specific call sites.  I think the hurdle for this is pretty high and I’m not sure we would find the benefits to outweigh the drawbacks, but it is a discussion we could have.  I would want to see concrete examples (which could be drawn from Ruby code).<br></p><p>I don’t think we should do this just to support term-of-art aliases where we believe we have a different name that fits Swift better.  This creates “dialects” which I believe is a stated anti-goal of Swift.  <br></p><p>It may turn out that existing terms of art provide enhanced clarity in some contexts and more Swifty names in others, in which case the alias may make sense.  But it if we add them it should be done on the grounds of clarity and be accompanied by guidelines regarding which name to choose.<br></p><p>But my hunch is that this introduces more complexity than value.<br></p><p>&gt; <br>&gt; That said, I don&#39;t like `mapping` and `flattened`. If they&#39;re going to be Swiftized, go with<br>&gt; names that aren&#39;t standing in the &quot;term of art&quot; rubble: transform, squeeze, whatever.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 10:37 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jun 29, 2016, at 10:13 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 29, 2016, at 12:39 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;ve updated my pull request with a much more conservative set of<br>&gt; &gt;&gt; changes that preserves/restores label-free-ness for all “term of art”<br>&gt; &gt;&gt; functional methods such as filter and reduce.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; https://github.com/apple/swift/pull/2981<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My current thoughts are that many of the `by:` labels are awkward and<br>&gt; &gt;&gt; not adding much.  Perhaps they all ought to be omitted.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;d be happy to see `by` labels go away, whether first or trailing. I&#39;m<br>&gt; not sure why Swift 3 wants<br>&gt; &gt; to have so many extra labels when a very simple phrase is understandable<br>&gt; on its own<br>&gt; &gt; (e.g. max, min, sort, sorted).<br>&gt; &gt;<br>&gt; &gt; Is it possible under the Swift umbrella to do the same for split since<br>&gt; it has the rarely used<br>&gt; &gt; maxSplits, and omittingEmptySubsequences params? It would give you<br>&gt; `split({$0 == &quot; &quot;})`<br>&gt; &gt; and `split(atWhitespace)`.<br>&gt; &gt;<br>&gt; &gt; Speaking of isAllWhitespace, would this be a prebuilt enumeration or is<br>&gt; it a placeholder?<br>&gt; &gt; If the former, I have opinions (new lines, new lines and whitespace)<br>&gt; &gt;<br>&gt; &gt; The managed buffer, are you &quot;makingValueWith&quot; instead of<br>&gt; &quot;makingHeaderWith&quot; intentionally?<br>&gt; &gt; If so, no worries. If not, helpful ping.<br>&gt; &gt;<br>&gt; &gt; Future Extensions:<br>&gt; &gt;<br>&gt; &gt; * reduce(_:, combine:)  // way simpler<br>&gt; &gt;<br>&gt; &gt; * &quot;The argument against changing other names to be more consistent with<br>&gt; API guidelines<br>&gt; &gt; is weakened. &quot;<br>&gt; &gt;<br>&gt; &gt; I think Sean Heber&#39;s `@termOfArt(name)` is a great way to have both<br>&gt; worlds, where<br>&gt; &gt; `select(where:)` or `where()` is the Swifty name and<br>&gt; `@termOfArt(filter)` offers<br>&gt; &gt; a substitutable alias for fp aficionados.<br>&gt; &gt; This approach is not anything I&#39;ve ever seen previously in a programming<br>&gt; language but<br>&gt; &gt; its something that jumps out as a way to satisfy two distinct audiences<br>&gt; of users<br>&gt; &gt; that would have limited impact but a decided advantage.<br>&gt;<br>&gt; Aliasing methods is pretty common in Ruby.  The advantage is that you can<br>&gt; select the alias that reads best at a specific call site.  The disadvantage<br>&gt; is that everyone has to learn more than one name for the same thing.<br>&gt;<br>&gt; If we’re going to allow aliases I think it should be in support of clarity<br>&gt; at specific call sites.  I think the hurdle for this is pretty high and I’m<br>&gt; not sure we would find the benefits to outweigh the drawbacks, but it is a<br>&gt; discussion we could have.  I would want to see concrete examples (which<br>&gt; could be drawn from Ruby code).<br>&gt;<br>&gt; I don’t think we should do this just to support term-of-art aliases where<br>&gt; we believe we have a different name that fits Swift better.  This creates<br>&gt; “dialects” which I believe is a stated anti-goal of Swift.<br>&gt;<br>&gt; It may turn out that existing terms of art provide enhanced clarity in<br>&gt; some contexts and more Swifty names in others, in which case the alias may<br>&gt; make sense.  But it if we add them it should be done on the grounds of<br>&gt; clarity and be accompanied by guidelines regarding which name to choose.<br>&gt;<br>&gt; But my hunch is that this introduces more complexity than value.<br>&gt;<br></p><p>Agreed. I&#39;d have to be convinced that having aliases provide overwhelming<br>wins at the call site that could not be achieved through renaming. Although<br>aliasing could be very neat in certain circumstances, I fear that admitting<br>such a facility to the language is an &quot;out&quot; that would discourage<br>exploration of the most appropriate method names and consensus-building in<br>favor of &quot;you&#39;ll have yours and I&#39;ll have mine,&quot; which would be fatal for<br>building a coherent set of APIs.<br></p><p><br>&gt; &gt;<br>&gt; &gt; That said, I don&#39;t like `mapping` and `flattened`. If they&#39;re going to<br>&gt; be Swiftized, go with<br>&gt; &gt; names that aren&#39;t standing in the &quot;term of art&quot; rubble: transform,<br>&gt; squeeze, whatever.<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/9510f1a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 11:01 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 10:37 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;wrote:<br>&gt; <br>&gt; &gt; On Jun 29, 2016, at 10:13 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 29, 2016, at 12:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;ve updated my pull request with a much more conservative set of<br>&gt; &gt;&gt; changes that preserves/restores label-free-ness for all “term of art”<br>&gt; &gt;&gt; functional methods such as filter and reduce.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; https://github.com/apple/swift/pull/2981 &lt;https://github.com/apple/swift/pull/2981&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My current thoughts are that many of the `by:` labels are awkward and<br>&gt; &gt;&gt; not adding much.  Perhaps they all ought to be omitted.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;d be happy to see `by` labels go away, whether first or trailing. I&#39;m not sure why Swift 3 wants<br>&gt; &gt; to have so many extra labels when a very simple phrase is understandable on its own<br>&gt; &gt; (e.g. max, min, sort, sorted).<br>&gt; &gt;<br>&gt; &gt; Is it possible under the Swift umbrella to do the same for split since it has the rarely used<br>&gt; &gt; maxSplits, and omittingEmptySubsequences params? It would give you `split({$0 == &quot; &quot;})`<br>&gt; &gt; and `split(atWhitespace)`.<br>&gt; &gt;<br>&gt; &gt; Speaking of isAllWhitespace, would this be a prebuilt enumeration or is it a placeholder?<br>&gt; &gt; If the former, I have opinions (new lines, new lines and whitespace)<br>&gt; &gt;<br>&gt; &gt; The managed buffer, are you &quot;makingValueWith&quot; instead of &quot;makingHeaderWith&quot; intentionally?<br>&gt; &gt; If so, no worries. If not, helpful ping.<br>&gt; &gt;<br>&gt; &gt; Future Extensions:<br>&gt; &gt;<br>&gt; &gt; * reduce(_:, combine:)  // way simpler<br>&gt; &gt;<br>&gt; &gt; * &quot;The argument against changing other names to be more consistent with API guidelines<br>&gt; &gt; is weakened. &quot;<br>&gt; &gt;<br>&gt; &gt; I think Sean Heber&#39;s `@termOfArt(name)` is a great way to have both worlds, where<br>&gt; &gt; `select(where:)` or `where()` is the Swifty name and `@termOfArt(filter)` offers<br>&gt; &gt; a substitutable alias for fp aficionados.<br>&gt; &gt; This approach is not anything I&#39;ve ever seen previously in a programming language but<br>&gt; &gt; its something that jumps out as a way to satisfy two distinct audiences of users<br>&gt; &gt; that would have limited impact but a decided advantage.<br>&gt; <br>&gt; Aliasing methods is pretty common in Ruby.  The advantage is that you can select the alias that reads best at a specific call site.  The disadvantage is that everyone has to learn more than one name for the same thing.<br>&gt; <br>&gt; If we’re going to allow aliases I think it should be in support of clarity at specific call sites.  I think the hurdle for this is pretty high and I’m not sure we would find the benefits to outweigh the drawbacks, but it is a discussion we could have.  I would want to see concrete examples (which could be drawn from Ruby code).<br>&gt; <br>&gt; I don’t think we should do this just to support term-of-art aliases where we believe we have a different name that fits Swift better.  This creates “dialects” which I believe is a stated anti-goal of Swift.<br>&gt; <br>&gt; It may turn out that existing terms of art provide enhanced clarity in some contexts and more Swifty names in others, in which case the alias may make sense.  But it if we add them it should be done on the grounds of clarity and be accompanied by guidelines regarding which name to choose.<br>&gt; <br>&gt; But my hunch is that this introduces more complexity than value.<br>&gt; <br>&gt; Agreed. I&#39;d have to be convinced that having aliases provide overwhelming wins at the call site that could not be achieved through renaming. Although aliasing could be very neat in certain circumstances, I fear that admitting such a facility to the language is an &quot;out&quot; that would discourage exploration of the most appropriate method names and consensus-building in favor of &quot;you&#39;ll have yours and I&#39;ll have mine,&quot; which would be fatal for building a coherent set of APIs.<br></p><p>My experience with Ruby has been primarily writing scripts for my own use.  If we’re going to consider aliases it would be great to hear about how this has impacted larger teams and the broader Ruby community.  I’m not sure whether it is viewed as a net win or a source of confusion.  I don’t think the situation is quite as dire as you fear, but it is a very valid concern.<br></p><p>&gt; <br>&gt; <br>&gt; &gt;<br>&gt; &gt; That said, I don&#39;t like `mapping` and `flattened`. If they&#39;re going to be Swiftized, go with<br>&gt; &gt; names that aren&#39;t standing in the &quot;term of art&quot; rubble: transform, squeeze, whatever.<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/d6f8b2fc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Agreed. I&#39;d have to be convinced that having aliases provide overwhelming wins at the call site that could not be achieved through renaming. Although aliasing could be very neat in certain circumstances, I fear that admitting such a facility to the language is an &quot;out&quot; that would discourage exploration of the most appropriate method names and consensus-building in favor of &quot;you&#39;ll have yours and I&#39;ll have mine,&quot; which would be fatal for building a coherent set of APIs.<br></p><p>It would probably be quite difficult to prove (although that doesn’t mean it isn’t worth trying) that aliases would be an overwhelming win because everyone has different tolerances for impedance mismatches. In many ways, it is that difference of tolerance that is the issue here (and in a few other threads).<br></p><p>I personally have no desire to fragment things more than necessary, but I also really want code to read fluently. These goals seem to be at odds and, I speculate, they are at odds in ways that are impossible to solve with a single solution. Human languages have a lot of redundancy and variety for a reason, and we’ve taken the stance that Swift should read with a kind of “flow” that we usually only associate with human languages. This means that there are likely going to have to be concessions made to Swift that one might not ordinarily see in a programming language. (IMO)<br></p><p>The argument that aliases would be “fatal” for building coherent API doesn’t seem to tell the whole story to me. After all, every program ultimately has it’s own “language” of sorts that is built up from the building blocks of the standard library and other included frameworks. There’s a unique mix of the usage of certain words, constructs, names in each program that is a reflection of the programmers who have built the program and each one reads differently no matter how hard we might try to have only “one true way” to express a thing.<br></p><p>To me, one of the nicer aspects of having aliases encoded in the API as function attributes is that, in the case of the standard libraries, they would be decided and bikeshedded by the usual suspects and then effectively locked into place. There’s still control on the extent of use of this feature. You cannot add an alias by way of an extension in your own code, for example, and I think that’s a fine tradeoff. It would be surgically used and, mostly, only by the core team/standard lib API designers and by those who wish to experiment. I don’t know if that’s a big win or not. To me, this feels like mostly untested territory.<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 11:19 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; &gt; Agreed. I&#39;d have to be convinced that having aliases provide<br>&gt; overwhelming wins at the call site that could not be achieved through<br>&gt; renaming. Although aliasing could be very neat in certain circumstances, I<br>&gt; fear that admitting such a facility to the language is an &quot;out&quot; that would<br>&gt; discourage exploration of the most appropriate method names and<br>&gt; consensus-building in favor of &quot;you&#39;ll have yours and I&#39;ll have mine,&quot;<br>&gt; which would be fatal for building a coherent set of APIs.<br>&gt;<br>&gt; It would probably be quite difficult to prove (although that doesn’t mean<br>&gt; it isn’t worth trying) that aliases would be an overwhelming win because<br>&gt; everyone has different tolerances for impedance mismatches. In many ways,<br>&gt; it is that difference of tolerance that is the issue here (and in a few<br>&gt; other threads).<br>&gt;<br>&gt; I personally have no desire to fragment things more than necessary, but I<br>&gt; also really want code to read fluently. These goals seem to be at odds and,<br>&gt; I speculate, they are at odds in ways that are impossible to solve with a<br>&gt; single solution. Human languages have a lot of redundancy and variety for a<br>&gt; reason, and we’ve taken the stance that Swift should read with a kind of<br>&gt; “flow” that we usually only associate with human languages. This means that<br>&gt; there are likely going to have to be concessions made to Swift that one<br>&gt; might not ordinarily see in a programming language. (IMO)<br>&gt;<br></p><p>I disagree with your interpretation of &quot;Swifty&quot; here. I understand the<br>supreme aim for Swift naming to be clarity, especially at the call site. In<br>some places, that would require Obj-C/Cocoa-like verbosity; in others it<br>calls for terseness. In some places, it should read more &quot;fluently&quot;, in<br>others not as much (e.g. arguments inside `init()` omit the classic<br>preposition &quot;with&quot;). So I would disagree that we should make concessions to<br>&quot;fluency&quot; but rather to clarity. And as for clarity, two names for the same<br>thing are, ipso facto, less clear than one, which is why I argue that the<br>wins would have to be &quot;overwhelming&quot;.<br></p><p><br>&gt; The argument that aliases would be “fatal” for building coherent API<br>&gt; doesn’t seem to tell the whole story to me. After all, every program<br>&gt; ultimately has it’s own “language” of sorts that is built up from the<br>&gt; building blocks of the standard library and other included frameworks.<br>&gt; There’s a unique mix of the usage of certain words, constructs, names in<br>&gt; each program that is a reflection of the programmers who have built the<br>&gt; program and each one reads differently no matter how hard we might try to<br>&gt; have only “one true way” to express a thing.<br>&gt;<br></p><p>I was more writing in relation to the topics discussed here--i.e. stdlib<br>and corelibs naming--and not so much in relation to user code. Within an<br>API, I&#39;d argue there should very much be only one &quot;language&quot;, especially<br>given that any particular program may ultimately use many frameworks, since<br>one &quot;language&quot; from each framework could already be a lot to handle.<br></p><p><br>&gt;<br>&gt; To me, one of the nicer aspects of having aliases encoded in the API as<br>&gt; function attributes is that, in the case of the standard libraries, they<br>&gt; would be decided and bikeshedded by the usual suspects and then effectively<br>&gt; locked into place. There’s still control on the extent of use of this<br>&gt; feature. You cannot add an alias by way of an extension in your own code,<br>&gt; for example, and I think that’s a fine tradeoff. It would be surgically<br>&gt; used and, mostly, only by the core team/standard lib API designers and by<br>&gt; those who wish to experiment. I don’t know if that’s a big win or not. To<br>&gt; me, this feels like mostly untested territory.<br>&gt;<br></p><p>See, here I would be precisely against that use for aliasing. For your own<br>code and as an extension, maybe. But as I argue above, definitely not for<br>stdlib and definitely not at the point of declaration.<br></p><p><br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/4de22bd9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 29, 2016 at 07:00:00pm</p></header><div class="content"><p>I have experience using aliases in Ruby and they are one of the aspects of the language I hated with a passion. They can be very confusing, and increase the difficulty of learning the APIs and QuickHelp is not always there to help. To me, they sound like a convenience for the code writer but a nuisance of the reader. And Swift has always tried to improve its readability over its writability.<br></p><p>On 29 Jun 2016, at 18:19, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Agreed. I&#39;d have to be convinced that having aliases provide overwhelming wins at the call site that could not be achieved through renaming. Although aliasing could be very neat in certain circumstances, I fear that admitting such a facility to the language is an &quot;out&quot; that would discourage exploration of the most appropriate method names and consensus-building in favor of &quot;you&#39;ll have yours and I&#39;ll have mine,&quot; which would be fatal for building a coherent set of APIs.<br>&gt; <br>&gt; It would probably be quite difficult to prove (although that doesn’t mean it isn’t worth trying) that aliases would be an overwhelming win because everyone has different tolerances for impedance mismatches. In many ways, it is that difference of tolerance that is the issue here (and in a few other threads).<br>&gt; <br>&gt; I personally have no desire to fragment things more than necessary, but I also really want code to read fluently. These goals seem to be at odds and, I speculate, they are at odds in ways that are impossible to solve with a single solution. Human languages have a lot of redundancy and variety for a reason, and we’ve taken the stance that Swift should read with a kind of “flow” that we usually only associate with human languages. This means that there are likely going to have to be concessions made to Swift that one might not ordinarily see in a programming language. (IMO)<br>&gt; <br>&gt; The argument that aliases would be “fatal” for building coherent API doesn’t seem to tell the whole story to me. After all, every program ultimately has it’s own “language” of sorts that is built up from the building blocks of the standard library and other included frameworks. There’s a unique mix of the usage of certain words, constructs, names in each program that is a reflection of the programmers who have built the program and each one reads differently no matter how hard we might try to have only “one true way” to express a thing.<br>&gt; <br>&gt; To me, one of the nicer aspects of having aliases encoded in the API as function attributes is that, in the case of the standard libraries, they would be decided and bikeshedded by the usual suspects and then effectively locked into place. There’s still control on the extent of use of this feature. You cannot add an alias by way of an extension in your own code, for example, and I think that’s a fine tradeoff. It would be surgically used and, mostly, only by the core team/standard lib API designers and by those who wish to experiment. I don’t know if that’s a big win or not. To me, this feels like mostly untested territory.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>I wasn’t aware of this being a thing in Ruby - interesting! Perhaps it is not so untested territory after all. :) Would be interesting to see if whatever prompted your hatred of it there is due to how it works in Ruby vs. the idea itself or not, though. Not sure how one would go about determining that, though. Or if that’d even be a useful result.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 29, 2016, at 12:14 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; I have experience using aliases in Ruby and they are one of the aspects of the language I hated with a passion. They can be very confusing, and increase the difficulty of learning the APIs and QuickHelp is not always there to help. To me, they sound like a convenience for the code writer but a nuisance of the reader. And Swift has always tried to improve its readability over its writability.<br>&gt; <br>&gt; On 29 Jun 2016, at 18:19, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Agreed. I&#39;d have to be convinced that having aliases provide overwhelming wins at the call site that could not be achieved through renaming. Although aliasing could be very neat in certain circumstances, I fear that admitting such a facility to the language is an &quot;out&quot; that would discourage exploration of the most appropriate method names and consensus-building in favor of &quot;you&#39;ll have yours and I&#39;ll have mine,&quot; which would be fatal for building a coherent set of APIs.<br>&gt;&gt; <br>&gt;&gt; It would probably be quite difficult to prove (although that doesn’t mean it isn’t worth trying) that aliases would be an overwhelming win because everyone has different tolerances for impedance mismatches. In many ways, it is that difference of tolerance that is the issue here (and in a few other threads).<br>&gt;&gt; <br>&gt;&gt; I personally have no desire to fragment things more than necessary, but I also really want code to read fluently. These goals seem to be at odds and, I speculate, they are at odds in ways that are impossible to solve with a single solution. Human languages have a lot of redundancy and variety for a reason, and we’ve taken the stance that Swift should read with a kind of “flow” that we usually only associate with human languages. This means that there are likely going to have to be concessions made to Swift that one might not ordinarily see in a programming language. (IMO)<br>&gt;&gt; <br>&gt;&gt; The argument that aliases would be “fatal” for building coherent API doesn’t seem to tell the whole story to me. After all, every program ultimately has it’s own “language” of sorts that is built up from the building blocks of the standard library and other included frameworks. There’s a unique mix of the usage of certain words, constructs, names in each program that is a reflection of the programmers who have built the program and each one reads differently no matter how hard we might try to have only “one true way” to express a thing.<br>&gt;&gt; <br>&gt;&gt; To me, one of the nicer aspects of having aliases encoded in the API as function attributes is that, in the case of the standard libraries, they would be decided and bikeshedded by the usual suspects and then effectively locked into place. There’s still control on the extent of use of this feature. You cannot add an alias by way of an extension in your own code, for example, and I think that’s a fine tradeoff. It would be surgically used and, mostly, only by the core team/standard lib API designers and by those who wish to experiment. I don’t know if that’s a big win or not. To me, this feels like mostly untested territory.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 9:37 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:13 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I think Sean Heber&#39;s `@termOfArt(name)` is a great way to have both worlds, where <br>&gt;&gt; `select(where:)` or `where()` is the Swifty name and `@termOfArt(filter)` offers<br>&gt;&gt; a substitutable alias for fp aficionados. <br>&gt;&gt; This approach is not anything I&#39;ve ever seen previously in a programming language but <br>&gt;&gt; its something that jumps out as a way to satisfy two distinct audiences of users<br>&gt;&gt; that would have limited impact but a decided advantage.<br>&gt; <br>&gt; Aliasing methods is pretty common in Ruby.  The advantage is that you can select the alias that reads best at a specific call site.  The disadvantage is that everyone has to learn more than one name for the same thing.<br>&gt; <br>&gt; If we’re going to allow aliases I think it should be in support of clarity at specific call sites.  I think the hurdle for this is pretty high and I’m not sure we would find the benefits to outweigh the drawbacks, but it is a discussion we could have.  I would want to see concrete examples (which could be drawn from Ruby code).<br>&gt; <br>&gt; I don’t think we should do this just to support term-of-art aliases where we believe we have a different name that fits Swift better.  This creates “dialects” which I believe is a stated anti-goal of Swift.  <br>&gt; <br>&gt; It may turn out that existing terms of art provide enhanced clarity in some contexts and more Swifty names in others, in which case the alias may make sense.  But it if we add them it should be done on the grounds of clarity and be accompanied by guidelines regarding which name to choose.<br>&gt; <br>&gt; But my hunch is that this introduces more complexity than value.<br></p><p>Don&#39;t forget QuickHelp and module interfaces, which automatically list attributes along with the declaration.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/ef15be0d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Jun 29 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 29, 2016, at 10:13 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 12:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve updated my pull request with a much more conservative set of<br>&gt;&gt;&gt; changes that preserves/restores label-free-ness for all “term of art”<br>&gt;&gt;&gt; functional methods such as filter and reduce.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift/pull/2981<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My current thoughts are that many of the `by:` labels are awkward and<br>&gt;&gt;&gt; not adding much.  Perhaps they all ought to be omitted.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;d be happy to see `by` labels go away, whether first or trailing. I&#39;m not sure why Swift 3 wants <br>&gt;&gt; to have so many extra labels when a very simple phrase is understandable on its own <br>&gt;&gt; (e.g. max, min, sort, sorted).<br>&gt;&gt; <br>&gt;&gt; Is it possible under the Swift umbrella to do the same for split since it has the rarely used<br>&gt;&gt; maxSplits, and omittingEmptySubsequences params? It would give you `split({$0 == &quot; &quot;})` <br>&gt;&gt; and `split(atWhitespace)`.<br>&gt;&gt; <br>&gt;&gt; Speaking of isAllWhitespace, would this be a prebuilt enumeration or is it a placeholder?<br>&gt;&gt; If the former, I have opinions (new lines, new lines and whitespace)<br>&gt;&gt; <br>&gt;&gt; The managed buffer, are you &quot;makingValueWith&quot; instead of &quot;makingHeaderWith&quot; intentionally?<br>&gt;&gt; If so, no worries. If not, helpful ping.<br>&gt;&gt; <br>&gt;&gt; Future Extensions:<br>&gt;&gt; <br>&gt;&gt; * reduce(_:, combine:)  // way simpler<br>&gt;&gt; <br>&gt;&gt; * &quot;The argument against changing other names to be more consistent with API guidelines <br>&gt;&gt; is weakened. &quot;<br>&gt;&gt; <br>&gt;&gt; I think Sean Heber&#39;s `@termOfArt(name)` is a great way to have both worlds, where <br>&gt;&gt; `select(where:)` or `where()` is the Swifty name and `@termOfArt(filter)` offers<br>&gt;&gt; a substitutable alias for fp aficionados. <br>&gt;&gt; This approach is not anything I&#39;ve ever seen previously in a programming language but <br>&gt;&gt; its something that jumps out as a way to satisfy two distinct audiences of users<br>&gt;&gt; that would have limited impact but a decided advantage.<br>&gt;<br>&gt; Aliasing methods is pretty common in Ruby.  The advantage is that you<br>&gt; can select the alias that reads best at a specific call site.  The<br>&gt; disadvantage is that everyone has to learn more than one name for the<br>&gt; same thing.<br></p><p>Yeah, I&#39;d rather not do that.  <br></p><p>&gt; If we’re going to allow aliases I think it should be in support of<br>&gt; clarity at specific call sites.  I think the hurdle for this is pretty<br>&gt; high and I’m not sure we would find the benefits to outweigh the<br>&gt; drawbacks, but it is a discussion we could have.  I would want to see<br>&gt; concrete examples (which could be drawn from Ruby code).<br>&gt;<br>&gt; I don’t think we should do this just to support term-of-art aliases<br>&gt; where we believe we have a different name that fits Swift better.<br>&gt; This creates “dialects” which I believe is a stated anti-goal of<br>&gt; Swift.<br></p><p>+1<br></p><p>&gt; It may turn out that existing terms of art provide enhanced clarity in<br>&gt; some contexts and more Swifty names in others, in which case the alias<br>&gt; may make sense.  But it if we add them it should be done on the<br>&gt; grounds of clarity and be accompanied by guidelines regarding which<br>&gt; name to choose.<br>&gt;<br>&gt; But my hunch is that this introduces more complexity than value.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; That said, I don&#39;t like `mapping` and `flattened`. If they&#39;re going to be Swiftized, go with<br>&gt;&gt; names that aren&#39;t standing in the &quot;term of art&quot; rubble: transform, squeeze, whatever.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>Could we please take all the discussion of aliasing and the future<br>extensions bit of this PR into a different thread?  I&#39;d like to keep<br>this discussion focused.<br></p><p>Thanks,<br>Dave<br></p><p>on Wed Jun 29 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 29, 2016, at 10:13 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 12:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve updated my pull request with a much more conservative set of<br>&gt;&gt;&gt; changes that preserves/restores label-free-ness for all “term of art”<br>&gt;&gt;&gt; functional methods such as filter and reduce.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift/pull/2981<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My current thoughts are that many of the `by:` labels are awkward and<br>&gt;&gt;&gt; not adding much.  Perhaps they all ought to be omitted.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;d be happy to see `by` labels go away, whether first or trailing. I&#39;m not sure why Swift 3 wants <br>&gt;&gt; to have so many extra labels when a very simple phrase is understandable on its own <br>&gt;&gt; (e.g. max, min, sort, sorted).<br>&gt;&gt; <br>&gt;&gt; Is it possible under the Swift umbrella to do the same for split since it has the rarely used<br>&gt;&gt; maxSplits, and omittingEmptySubsequences params? It would give you `split({$0 == &quot; &quot;})` <br>&gt;&gt; and `split(atWhitespace)`.<br>&gt;&gt; <br>&gt;&gt; Speaking of isAllWhitespace, would this be a prebuilt enumeration or is it a placeholder?<br>&gt;&gt; If the former, I have opinions (new lines, new lines and whitespace)<br>&gt;&gt; <br>&gt;&gt; The managed buffer, are you &quot;makingValueWith&quot; instead of &quot;makingHeaderWith&quot; intentionally?<br>&gt;&gt; If so, no worries. If not, helpful ping.<br>&gt;&gt; <br>&gt;&gt; Future Extensions:<br>&gt;&gt; <br>&gt;&gt; * reduce(_:, combine:)  // way simpler<br>&gt;&gt; <br>&gt;&gt; * &quot;The argument against changing other names to be more consistent with API guidelines <br>&gt;&gt; is weakened. &quot;<br>&gt;&gt; <br>&gt;&gt; I think Sean Heber&#39;s `@termOfArt(name)` is a great way to have both worlds, where <br>&gt;&gt; `select(where:)` or `where()` is the Swifty name and `@termOfArt(filter)` offers<br>&gt;&gt; a substitutable alias for fp aficionados. <br>&gt;&gt; This approach is not anything I&#39;ve ever seen previously in a programming language but <br>&gt;&gt; its something that jumps out as a way to satisfy two distinct audiences of users<br>&gt;&gt; that would have limited impact but a decided advantage.<br>&gt;<br>&gt; Aliasing methods is pretty common in Ruby.  The advantage is that you<br>&gt; can select the alias that reads best at a specific call site.  The<br>&gt; disadvantage is that everyone has to learn more than one name for the<br>&gt; same thing.<br>&gt;<br>&gt; If we’re going to allow aliases I think it should be in support of<br>&gt; clarity at specific call sites.  I think the hurdle for this is pretty<br>&gt; high and I’m not sure we would find the benefits to outweigh the<br>&gt; drawbacks, but it is a discussion we could have.  I would want to see<br>&gt; concrete examples (which could be drawn from Ruby code).<br>&gt;<br>&gt; I don’t think we should do this just to support term-of-art aliases<br>&gt; where we believe we have a different name that fits Swift better.<br>&gt; This creates “dialects” which I believe is a stated anti-goal of<br>&gt; Swift.<br>&gt;<br>&gt; It may turn out that existing terms of art provide enhanced clarity in<br>&gt; some contexts and more Swifty names in others, in which case the alias<br>&gt; may make sense.  But it if we add them it should be done on the<br>&gt; grounds of clarity and be accompanied by guidelines regarding which<br>&gt; name to choose.<br>&gt;<br>&gt; But my hunch is that this introduces more complexity than value.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; That said, I don&#39;t like `mapping` and `flattened`. If they&#39;re going to be Swiftized, go with<br>&gt;&gt; names that aren&#39;t standing in the &quot;term of art&quot; rubble: transform, squeeze, whatever.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Take 2: Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>on Wed Jun 29 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 29, 2016, at 12:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;ve updated my pull request with a much more conservative set of<br>&gt;&gt; changes that preserves/restores label-free-ness for all “term of art”<br>&gt;&gt; functional methods such as filter and reduce.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift/pull/2981<br>&gt;&gt; <br>&gt;&gt; My current thoughts are that many of the `by:` labels are awkward and<br>&gt;&gt; not adding much.  Perhaps they all ought to be omitted.<br>&gt;<br>&gt; I&#39;d be happy to see `by` labels go away, whether first or<br>&gt; trailing. I&#39;m not sure why Swift 3 wants to have so many extra labels<br>&gt; when a very simple phrase is understandable on its own (e.g. max, min,<br>&gt; sort, sorted).<br></p><p>Well, it&#39;s simple: the labels aren&#39;t extra because x.sort(y) sounds like<br>x is sorting y.<br></p><p>&gt; Is it possible under the Swift umbrella to do the same for split since<br>&gt; it has the rarely used maxSplits, and omittingEmptySubsequences<br>&gt; params? <br></p><p>? AFAICT a decision about dropping the label has nothing to do with<br>those other parameters<br></p><p>&gt; It would give you `split({$0 == &quot; &quot;})` and `split(atWhitespace)`.<br></p><p>It wouldn&#39;t, because your predicate that identifies whitespace is not<br>going to be called, “atWhitespace”<br></p><p>&gt; Speaking of isAllWhitespace, would this be a prebuilt enumeration or<br>&gt; is it a placeholder?<br></p><p>It&#39;s not an enumeration; we&#39;re talking about closure parameters,<br>remember?  It&#39;s a hypothetical predicate:<br></p><p>   func isAllWhitespace(_: String) -&gt; Bool<br></p><p>&gt; If the former, I have opinions (new lines, new lines and whitespace)<br>&gt;<br>&gt; The managed buffer, are you &quot;makingValueWith&quot; instead of<br>&gt; &quot;makingHeaderWith&quot; intentionally?<br></p><p>Yes, because the change from “Value” to “Header” is a separate proposal<br>that you have kindly written up for me.<br></p><p>&gt; If so, no worries. If not, helpful ping.<br>&gt;<br>&gt; Future Extensions:<br>&gt;<br>&gt; * reduce(_:, combine:)  // way simpler<br>&gt;<br>&gt; * &quot;The argument against changing other names to be more consistent with API guidelines <br>&gt; is weakened. &quot;<br>&gt;<br>&gt;  I think Sean Heber&#39;s `@termOfArt(name)` is a great way to have both worlds, where <br>&gt; `select(where:)` or `where()` is the Swifty name and `@termOfArt(filter)` offers<br>&gt; a substitutable alias for fp aficionados. <br>&gt;<br>&gt; This approach is not anything I&#39;ve ever seen previously in a programming language but <br>&gt; its something that jumps out as a way to satisfy two distinct audiences of users<br>&gt; that would have limited impact but a decided advantage.<br>&gt;<br>&gt; That said, I don&#39;t like `mapping` and `flattened`. If they&#39;re going to be Swiftized, go with<br>&gt; names that aren&#39;t standing in the &quot;term of art&quot; rubble: transform, squeeze, whatever.<br></p><p>Separate discussion, but thanks for the input.  Let&#39;s handle that stuff<br>in a separate review.  I should probably strip it out of the pull<br>request text.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
