<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Proposal] Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May  2, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;ve written a proposal to formalize some of the discussion that was had<br>over in the thread for the `FloatingPoint` protocol proposal regarding<br>improvements to operator requirements in protocols that do not require<br>named methods be added to the protocol and conforming types. Thanks to<br>everyone who was participating in that discussion!<br></p><p>The proposal can be viewed in this pull request<br>&lt;https://github.com/apple/swift-evolution/pull/283&gt; and is pasted below.<br></p><p><br>Improving operator requirements in protocols<br></p><p>   - Proposal: SE-NNNN<br>   &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-improving-operators-in-protocols.md&gt;<br>   - Author(s): Tony Allevato &lt;https://github.com/allevato&gt;<br>   - Status: TBD<br>   - Review manager: TBD<br></p><p>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#introduction&gt;<br>Introduction<br></p><p>When a type conforms to a protocol that declares an operator as a<br>requirement, that operator must be implemented as a global function defined<br>outside of the conforming type. This can lead both to user confusion and to<br>poor type checker performance since the global namespace is overcrowded<br>with a large number of operator overloads. This proposal mitigates both of<br>those issues by proposing that operators in protocols be declared<br>statically (to change and clarify where the conforming type implements it)<br>and use generic global trampoline operators (to reduce the global overload<br>set that the type checker must search).<br></p><p>Swift-evolution thread: Discussion about operators and protocols in the<br>context of FloatingPoint<br>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015807.html&gt;<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#motivation&gt;<br>Motivation<br></p><p>The proposal came about as a result of discussion about SE-0067: Enhanced<br>Floating Point Protocols<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md&gt;.<br>To implement the numerous arithmetic and comparison operators, this<br>protocol defined named instance methods for them and then implemented the<br>global operator functions to delegate to them. For example,<br></p><p>public protocol FloatingPoint {<br>  func adding(rhs: Self) -&gt; Self<br>  // and others<br>}<br>public func + &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; T {<br>  return lhs.adding(rhs)<br>}<br></p><p>One of the motivating factors for these named methods was to make the<br>operators generic and reduce the number of concrete global overloads, which<br>would improve the type checker&#39;s performance compared to individual<br>concrete overloads for each conforming type. Some concerns were raised<br>about the use of named methods:<br></p><p>   - They bloat the public interface. Every floating point type would<br>   expose mutating and non-mutating methods for each arithmetic operation, as<br>   well as non-mutating methods for the comparisons. We don&#39;t expect users to<br>   actually call these methods directly but they must be present in the public<br>   interface because they are requirements of the protocol. Therefore, they<br>   would clutter API documentation and auto-complete lists and make the<br>   properties and methods users actually want to use less discoverable.<br>   - Swift&#39;s naming guidelines encourage the use of &quot;terms of art&quot; for<br>   naming when it is appropriate. In this case, the operator itself is the<br>   term of art. It feels odd to elevate (2.0).adding(2.0).isEqual(to: 4.0) to<br>   the same first-class status as 2.0 + 2.0 == 4.0; this is the situation<br>   that overloaded operators were made to prevent.<br>   - Devising good names for the operators is tricky; the swift-evolution<br>   list had a fair amount of bikeshedding about the naming and preposition<br>   placement of isLessThanOrEqual(to:) in order to satisfy API guidelines,<br>   for example.<br>   - Having both an adding method and a + operator provides two ways for<br>   the user to do the same thing. This may lead to confusion if users think<br>   that the two ways of adding have slightly different semantics.<br></p><p>Some contributors to the discussion list have expressed concerns about<br>operators being members of protocols at all. I feel that removing them<br>entirely would be a step backwards for the Swift language; a protocol is<br>not simply a list of properties and methods that a type must implement, but<br>rather a higher-level set of requirements. Just as properties, methods, and<br>associated types are part of that requirement set, it makes sense that an<br>arithmetic type, for example, would declare arithmetic operators among its<br>requirements as well.<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#inconsistency-in-the-current-operator-design-with-protocols&gt;Inconsistency<br>in the current operator design with protocols<br></p><p>When a protocol declares an operator as a requirement, that requirement is<br>located *inside* the protocol definition. For example, consider Equatable:<br></p><p>protocol Equatable {<br>  func ==(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>However, since operators are global functions, the actual implementation of<br>that operator for a conforming type must be made *outside* the type<br>definition. This can look particularly odd when extending an existing type<br>to conform to an operator-only protocol:<br></p><p>extension Foo: Equatable {}<br>func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>  // Implementation goes here<br>}<br></p><p>This is an odd inconsistency in the Swift language, driven by the fact that<br>operators must be global functions. What&#39;s worse is that every concrete<br>type that conforms to Equatable must provide the operator function at<br>global scope. As the number of types conforming to this protocol increases,<br>so does the workload of the compiler to perform type checking.<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#proposed-solution&gt;Proposed<br>solution<br></p><p>The solution described below is an *addition* to the Swift language. This<br>document does *not* propose that the current way of defining operators be<br>removed or changed at this time. Rather, we describe an addition that<br>specifically provides improvements for protocol operator requirements.<br></p><p>When a protocol wishes to declare operators that conforming types must<br>implement, we propose adding the ability to declare operator requirements<br>as static members of the protocol:<br></p><p>protocol Equatable {<br>  static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>Then, the protocol author is responsible for providing a generic global<br>*trampoline* operator that is constrained by the protocol type and<br>delegates to the static operator on that type:<br></p><p>func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>  return T.==(lhs, rhs)<br>}<br></p><p>Types conforming to a protocol that contains static operators would<br>implement the operators as static methods defined*within* the type:<br></p><p>struct Foo: Equatable {<br>  let value: Int<br></p><p>  static func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>    return lhs.value == rhs.value<br>  }<br>}<br>let f1 = Foo(value: 5)let f2 = Foo(value: 10)let eq = (f1 == f2)<br></p><p>When the compiler sees an equality expression between two Foos like the one<br>above, it will call the global == &lt;T: Equatable&gt; function. Since T is bound<br>to the type Foo in this case, that function simply delegates to the static<br>methodFoo.==, which performs the actual comparison.<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#benefits-of-this-approach&gt;Benefits<br>of this approach<br></p><p>By using the name of the operator itself as the method, this approach<br>avoids bloating the public interfaces of protocols and conforming types<br>with additional named methods, reducing user confusion. This also will lead<br>to better consistency going forward, as various authors of such protocols<br>will not be providing their own method names.<br></p><p>For a particular operator, this approach also reduces the number of global<br>instances of that operator. Instead of there being one instance per<br>concrete type conforming to that protocol, there is a single generic one<br>per protocol. This should have a positive impact on type checker<br>performance by splitting the lookup of an operator&#39;s implementation from<br>searching through a very large set to searching through a much smaller set<br>to find the generic trampoline and then using the bound type to quickly<br>resolve the actual implementation.<br></p><p>Similarly, this behavior allows users to be more explicit when referring to<br>operator functions as first-class operations. Passing an operator function<br>like + to a generic algorithm will still work with the trampoline<br>operators, but in situations where type inference fails and the user needs<br>to be more explicit about the types, being able to write T.+ is a cleaner<br>and unambiguous shorthand compared to casting the global + to the<br>appropriate function signature type.<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#other-kinds-of-operators-prefix-postfix-assignment&gt;Other<br>kinds of operators (prefix, postfix, assignment)<br></p><p>Static operator methods have the same signatures as their global<br>counterparts. So, for example, prefix and postfix operators as well as<br>assignment operators would be defined the way one would expect:<br></p><p>protocol SomeProtocol {<br>  static func +=(lhs: inout Self, rhs: Self)<br>  static prefix func ~(value: Self) -&gt; Self<br></p><p>  // This one is deprecated, of course, but used here just to serve as an<br>  // example.<br>  static postfix func ++(value: inout Self) -&gt; Self<br>}<br>// Trampolinesfunc += &lt;T: SomeProtocol&gt;(lhs: inout T, rhs T) {<br>  T.+=(&amp;lhs, rhs)<br>}prefix func ~ &lt;T: SomeProtocol&gt;(value: T) -&gt; T {<br>  return T.~(value)<br>}postfix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>  return T.++(&amp;value)<br>}<br></p><p>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#open-issue-class-types-and-inheritance&gt;Open<br>issue: Class types and inheritance<br></p><p>While this approach works well for value types, these static operators may<br>not work as expected for class types when inheritance is involved, and more<br>work may be needed here.<br></p><p>We can currently model the behavior we&#39;d like to achieve by using a<br>named eq method<br>instead of the operator itself. (Note that we are *not* proposing that the<br>function be named eq in the final design; this was done simply to perform<br>the experiment with today&#39;s compiler.) Then we implement both the new<br>method and the current == operator and compare their behaviors. For example:<br></p><p>protocol ProposedEquatable {<br>  static func eq(lhs: Self, _ rhs: Self) -&gt; Bool<br>}<br>class Base: ProposedEquatable, Equatable {<br>  static func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>    print(&quot;Base.eq&quot;)<br>    return true<br>  }<br>}func ==(lhs: Base, rhs: Base) -&gt; Bool {<br>  print(&quot;==(Base, Base)&quot;)<br>  return true<br>}<br>class Subclass: Base {<br>  static func eq(lhs: Subclass, _ rhs: Subclass) -&gt; Bool {<br>    print(&quot;Subclass.eq(Subclass, Subclass)&quot;)<br>    return true<br>  }<br>}func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool {<br>  print(&quot;==(Subclass, Subclass)&quot;)<br>  return true<br>}<br>func eq&lt;T: ProposedEquatable&gt;(lhs: T, _ rhs: T) -&gt; Bool {<br>  return T.eq(lhs, rhs)<br>}<br>let x = Subclass()let y = Subclass()let z = y as Base<br></p><p>eq(x, y)  // prints &quot;Base.eq&quot;<br>eq(x, z)  // prints &quot;Base.eq&quot;<br></p><p>x == y    // prints &quot;==(Subclass, Subclass)&quot;<br>x == z    // prints &quot;==(Base, Base)&quot;<br></p><p>The result of eq(x, y) was a bit surprising, since the generic argument T is<br>bound to Subclass and there should be no dynamic dispatch at play there.<br>(Is the issue that since Base is the class explicitly conforming to<br>ProposedEquatable, this is locking in Self being bound as Base, causing<br>that overload to be found in the compiler&#39;s search? Or is this a bug?)<br></p><p>An attempt was also made to fix this using dynamic dispatch, by<br>implementing eq as a class method instead of astatic method:<br></p><p>protocol ProposedEquatable {<br>  static func eq(lhs: Self, _ rhs: Self) -&gt; Bool<br>}<br>class Base: ProposedEquatable, Equatable {<br>  class func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>    print(&quot;Base.eq&quot;)<br>    return true<br>  }<br>}func ==(lhs: Base, rhs: Base) -&gt; Bool {<br>  print(&quot;==(Base, Base)&quot;)<br>  return true<br>}<br>class Subclass: Base {<br>  override class func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>    print(&quot;Subclass.eq(Base, Base)&quot;)<br>    return true<br>  }<br>  class func eq(lhs: Subclass, _ rhs: Subclass) -&gt; Bool {<br>    print(&quot;Subclass.eq(Subclass, Subclass)&quot;)<br>    return true<br>  }<br>}func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool {<br>  print(&quot;==(Subclass, Subclass)&quot;)<br>  return true<br>}<br>func eq&lt;T: ProposedEquatable&gt;(lhs: T, _ rhs: T) -&gt; Bool {<br>  return T.eq(lhs, rhs)<br>}<br>let x = Subclass()let y = Subclass()let z = y as Base<br></p><p>eq(x, y)  // prints &quot;Subclass.eq(Base, Base)&quot;<br>eq(x, z)  // prints &quot;Base.eq&quot;<br></p><p>x == y    // prints &quot;==(Subclass, Subclass)&quot;<br>x == z    // prints &quot;==(Base, Base)&quot;<br></p><p>This helped slightly, since at least it resulting in a method on the<br>expected subclass being called, but this still means that anyone<br>implementing this operator on subclasses would have to do some casting, and<br>it&#39;s awkward that subclasses would be expected to write its operator in<br>terms of the conforming base class.<br></p><p>It should also be noted (code not provided here) that using instance<br>methods does not solve this problem, presumably for the same<br>dispatch-related reasons that the class methods called the version with Base<br> arguments.<br></p><p>However, the lack of multiple dispatch in Swift means that the operators we<br>have today don&#39;t necessarily work the way a user would expect (for example,<br>the x == z expression above), so it&#39;s debatable whether this is a<br>significant concern.<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#stretch-goal-automatically-generating-trampolines&gt;Stretch<br>goal: Automatically generating trampolines<br></p><p>To further ease the use of protocol-defined operators, the compiler could<br>automatically define the trampoline operator function at global scope. For<br>example, a protocol and operator of the form<br></p><p>protocol SomethingAddable {<br>  static func +(lhs: Self, rhs: Self) -&gt; Self<br>}<br></p><p>could automatically produce a generic global trampoline operator<br>constrained by the protocol type (by substituting forSelf), with the same<br>visibility as the protocol. The body of this would simply delegate to the<br>static/class operator of the concrete type:<br></p><p>func + &lt;τ_0: SomethingAddable&gt;(lhs: τ_0, rhs: τ_0) -&gt; τ_0 {<br>  return τ_0.+(lhs, rhs)<br>}<br></p><p>This approach could be extended for heterogeneous parameter lists:<br></p><p>protocol IntegerAddable {<br>  static func +(lhs: Self, rhs: Int) -&gt; Self<br>}<br>// Auto-generated by the compilerfunc + &lt;τ_0: IntegerAddable&gt;(lhs:<br>τ_0, rhs: Int) -&gt; τ_0 {<br>  return τ_0.+(lhs, rhs)<br>}<br></p><p>Additional generic constraints could even be propagated to the trampoline<br>operator:<br></p><p>protocol GenericAddable {<br>  static func + &lt;Arg: AnotherProtocol&gt;(lhs: Self, rhs: Arg) -&gt; Self<br>}<br>// Auto-generated by the compilerfunc + &lt;τ_0: GenericAddable, τ_1:<br>AnotherProtocol&gt;(lhs: τ_0, rhs: τ_1) -&gt; τ_0 {<br>  return τ_0.+(lhs, rhs)<br>}<br></p><p>One major benefit of this is that neither the protocol author nor<br>developers writing types conforming to that protocol would have to write<br>*any* code that lives outside the protocol. This feels clean and consistent.<br></p><p>This feature, however, may be more controversial, because:<br></p><p>   - It involves the compiler implicitly generating glue code behind the<br>   scenes, which is less discoverable and may be considered &quot;magic&quot;.<br>   - It raises the question of whether users should be allowed to define<br>   their own trampolines that match the signatures of the auto-generated ones,<br>   and if so, how the conflict is resolved.<br>   - Defining the trampoline operator manually requires a trivial amount of<br>   effort, and that effort is a one-time exercise by the protocol author.<br></p><p>In addition, automatic trampoline generation is a much deeper change that<br>would likely not be implementable in the Swift 3 timeline, so we will defer<br>this for a future proposal and deeper discussion later.<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#detailed-design&gt;Detailed<br>design<br></p><p>Currently, the Swift language allows the use of operators as the names of<br>global functions and of functions in protocols. This proposal is<br>essentially asking to extend that list to include static/class methods of<br>protocols and concrete types and to support referencing them in expressions<br>using the . operator.<br></p><p>Interestingly, the production rules themselves of the Swift grammar for<br>function declarations *already* appear to support declaring static<br>functions inside a protocol or other type with names that are operators. In<br>fact, declaring a static operator function in a protocol works today (that<br>is, the static modifier is ignored).<br></p><p>However, defining such a function in a concrete type fails with the<br>error operators<br>are only allowed at global scope.This area<br>&lt;https://github.com/apple/swift/blob/797260939e1f9e453ab49a5cc6e0a7b40be61ec9/lib/Parse/ParseDecl.cpp#L4444&gt;<br> of Parser::parseDeclFunc appears to be the likely place to make a change<br>to allow this.<br></p><p>In order to support *calling* a static operator using its name, the<br>production rules for *explicit-member-expression* would need to be updated<br>to support operators where they currently only support identifiers:<br></p><p>*explicit-member-expression* → *postfix-expression* ­. *identifier*<br>*­generic-argument-clause­**opt*­<br>*explicit-member-expression* → *postfix-expression* ­­. *operator*<br>*­generic-argument-clause­**opt*­<br>*explicit-member-expression* → *postfix-expression* ­­. *­identifier* ­(<br>*­argument-names­* )­<br>*explicit-member-expression* → *postfix-expression* ­­. *­operator* ­(<br>*­argument-names­* )­<br></p><p>For consistency with other static members, we could consider modifying<br>*implicit-member-expression* as well, but referring to an operator function<br>with only a dot preceding it might look awkward:<br></p><p>*implicit-member-expression* → . *­identifier­*<br>*implicit-member-expression* → . *operator­*<br></p><p>Open question: Are there any potential ambiguities between the dot in the<br>member expression and dots in operators?<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#impact-on-existing-code&gt;Impact<br>on existing code<br></p><p>The ability to declare operators as static/class functions inside a type is<br>a new feature and would not affect existing code. Likewise, the ability to<br>explicitly reference the operator function of a type (e.g., Int.+ or Int.+(5,<br>7) would not affect existing code.<br></p><p>Changing the way operators are declared in protocols (static instead of<br>non-static) would be a breaking change. However, since the syntax forms are<br>mutually exclusive, we may wish to let them coëxist for the time being.<br>That is, protocols that declare non-static operators would have them<br>satisfied by global functions, and protocols that declare static operators<br>would have them satisfied by static methods. While this provides two ways<br>for developers to do the same thing, reducing breakage is a greater goal.<br>We can consider deprecating non-static operators in protocols to lead<br>developers to the new syntax and then remove it in a later version of Swift.<br></p><p>Applying this change to the protocols already in the Swift standard library<br>(such as Equatable) would be a breaking change, because it would change the<br>way by which subtypes conform to that protocol. It might be possible to<br>implement a quick fix that hoists a global operator function into the<br>subtype&#39;s definition, either by making it static and moving the code itself<br>or by wrapping it in an extension.<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#alternatives-considered&gt;Alternatives<br>considered<br></p><p>One alternative would be to do nothing. This would leave us with the<br>problems cited above:<br></p><p>   - Concrete types either provide their own global operator overloads,<br>   increasing the workload of the type checker...<br>   - ...*or* they define generic operators that delegate to named methods,<br>   but those named methods bloat the public interface of the type.<br>   - Furthermore, there is no consistency required for these named methods<br>   among different types; each can define its own, and subtle differences in<br>   naming can lead to user confusion.<br></p><p>Another alternative would be that instead of using static methods,<br>operators could be defined as instance methods on a type. For example,<br></p><p>protocol SomeProtocol {<br>  func +(rhs: Self) -&gt; Self<br>}<br>struct SomeType: SomeProtocol {<br>  func +(rhs: SomeType) -&gt; SomeType { ... }<br>}<br>func + &lt;T: SomeProtocol&gt;(lhs: T, rhs: T) -&gt; T {<br>  return lhs.+(rhs)<br>}<br></p><p>There is not much to be gained by doing this, however. It does not solve<br>the dynamic dispatch problem for classes described above, and it would<br>require writing operator method signatures that differ from those of the<br>global operators because the first argument instead becomes the implicit<br>self. As a matter of style, when it doesn&#39;t necessarily seem appropriate to<br>elevate one argument of an infix operator—especially one that is<br>commutative—to the special status of &quot;receiver&quot; while the other remains an<br>argument.<br></p><p>Likewise, commutative operators with heterogeneous arguments are more<br>awkward to implement if operators are instance methods. Consider a<br>contrived example of a CustomStringProtocol type that supports<br>concatenation with Characterusing the + operator, commutatively. With<br>static operators and generic trampolines, both versions of the operator are<br>declared in CustomStringProtocol, as one would expect:<br></p><p>protocol CustomStringProtocol {<br>  static func +(lhs: Self, rhs: Character) -&gt; Self<br>  static func +(lhs: Character, rhs: Self) -&gt; Self<br>}<br>func + &lt;T: CustomStringProtocol&gt;(lhs: T, rhs: Character) -&gt; T {<br>  return T.+(lhs, rhs)<br>}func + &lt;T: CustomStringProtocol&gt;(lhs: Character, rhs: T) -&gt; T {<br>  return T.+(lhs, rhs)<br>}<br></p><p>Likewise, the implementation of both operators would be contained entirely<br>within the conforming types. If these were instance methods, it&#39;s unclear<br>how the version that has the Character argument on the left-hand side would<br>be expressed in the protocol, or how it would be implemented if an instance<br>of Character were the receiver. Would it be an extension on the Character type?<br>This would split the implementation of an operation that logically belongs<br>to CustomStringProtocolacross two different locations in the code, which is<br>something we&#39;re trying to avoid.<br>&lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#acknowledgments&gt;<br>Acknowledgments<br></p><p>Thanks to Chris Lattner and Dave Abrahams for contributing to the early<br>discussions, particularly regarding the need to improve type checker<br>performance by genericizing protocol-based operators.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/b1cabbb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Improving operator requirements in protocols</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>May  2, 2016 at 11:00:00pm</p></header><div class="content"><p>I like the direction this takes things! Thanks for hammering out a proposal<br>to get the ball rolling.<br></p><p>-Shawn<br></p><p>On Mon, May 2, 2016 at 9:51 AM Tony Allevato via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;ve written a proposal to formalize some of the discussion that was had<br>&gt; over in the thread for the `FloatingPoint` protocol proposal regarding<br>&gt; improvements to operator requirements in protocols that do not require<br>&gt; named methods be added to the protocol and conforming types. Thanks to<br>&gt; everyone who was participating in that discussion!<br>&gt;<br>&gt; The proposal can be viewed in this pull request<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/283&gt; and is pasted below.<br>&gt;<br>&gt;<br>&gt; Improving operator requirements in protocols<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-improving-operators-in-protocols.md&gt;<br>&gt;    - Author(s): Tony Allevato &lt;https://github.com/allevato&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; When a type conforms to a protocol that declares an operator as a<br>&gt; requirement, that operator must be implemented as a global function defined<br>&gt; outside of the conforming type. This can lead both to user confusion and to<br>&gt; poor type checker performance since the global namespace is overcrowded<br>&gt; with a large number of operator overloads. This proposal mitigates both of<br>&gt; those issues by proposing that operators in protocols be declared<br>&gt; statically (to change and clarify where the conforming type implements it)<br>&gt; and use generic global trampoline operators (to reduce the global overload<br>&gt; set that the type checker must search).<br>&gt;<br>&gt; Swift-evolution thread: Discussion about operators and protocols in the<br>&gt; context of FloatingPoint<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/015807.html&gt;<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The proposal came about as a result of discussion about SE-0067: Enhanced<br>&gt; Floating Point Protocols<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md&gt;.<br>&gt; To implement the numerous arithmetic and comparison operators, this<br>&gt; protocol defined named instance methods for them and then implemented the<br>&gt; global operator functions to delegate to them. For example,<br>&gt;<br>&gt; public protocol FloatingPoint {<br>&gt;   func adding(rhs: Self) -&gt; Self<br>&gt;   // and others<br>&gt; }<br>&gt; public func + &lt;T: FloatingPoint&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;   return lhs.adding(rhs)<br>&gt; }<br>&gt;<br>&gt; One of the motivating factors for these named methods was to make the<br>&gt; operators generic and reduce the number of concrete global overloads, which<br>&gt; would improve the type checker&#39;s performance compared to individual<br>&gt; concrete overloads for each conforming type. Some concerns were raised<br>&gt; about the use of named methods:<br>&gt;<br>&gt;    - They bloat the public interface. Every floating point type would<br>&gt;    expose mutating and non-mutating methods for each arithmetic operation, as<br>&gt;    well as non-mutating methods for the comparisons. We don&#39;t expect users to<br>&gt;    actually call these methods directly but they must be present in the public<br>&gt;    interface because they are requirements of the protocol. Therefore, they<br>&gt;    would clutter API documentation and auto-complete lists and make the<br>&gt;    properties and methods users actually want to use less discoverable.<br>&gt;    - Swift&#39;s naming guidelines encourage the use of &quot;terms of art&quot; for<br>&gt;    naming when it is appropriate. In this case, the operator itself is the<br>&gt;    term of art. It feels odd to elevate (2.0).adding(2.0).isEqual(to: 4.0) to<br>&gt;    the same first-class status as 2.0 + 2.0 == 4.0; this is the situation<br>&gt;    that overloaded operators were made to prevent.<br>&gt;    - Devising good names for the operators is tricky; the swift-evolution<br>&gt;    list had a fair amount of bikeshedding about the naming and preposition<br>&gt;    placement of isLessThanOrEqual(to:) in order to satisfy API<br>&gt;    guidelines, for example.<br>&gt;    - Having both an adding method and a + operator provides two ways for<br>&gt;    the user to do the same thing. This may lead to confusion if users think<br>&gt;    that the two ways of adding have slightly different semantics.<br>&gt;<br>&gt; Some contributors to the discussion list have expressed concerns about<br>&gt; operators being members of protocols at all. I feel that removing them<br>&gt; entirely would be a step backwards for the Swift language; a protocol is<br>&gt; not simply a list of properties and methods that a type must implement, but<br>&gt; rather a higher-level set of requirements. Just as properties, methods, and<br>&gt; associated types are part of that requirement set, it makes sense that an<br>&gt; arithmetic type, for example, would declare arithmetic operators among its<br>&gt; requirements as well.<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#inconsistency-in-the-current-operator-design-with-protocols&gt;Inconsistency<br>&gt; in the current operator design with protocols<br>&gt;<br>&gt; When a protocol declares an operator as a requirement, that requirement is<br>&gt; located *inside* the protocol definition. For example, consider Equatable:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;   func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; However, since operators are global functions, the actual implementation<br>&gt; of that operator for a conforming type must be made *outside* the type<br>&gt; definition. This can look particularly odd when extending an existing type<br>&gt; to conform to an operator-only protocol:<br>&gt;<br>&gt; extension Foo: Equatable {}<br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;   // Implementation goes here<br>&gt; }<br>&gt;<br>&gt; This is an odd inconsistency in the Swift language, driven by the fact<br>&gt; that operators must be global functions. What&#39;s worse is that every<br>&gt; concrete type that conforms to Equatable must provide the operator<br>&gt; function at global scope. As the number of types conforming to this<br>&gt; protocol increases, so does the workload of the compiler to perform type<br>&gt; checking.<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The solution described below is an *addition* to the Swift language. This<br>&gt; document does *not* propose that the current way of defining operators be<br>&gt; removed or changed at this time. Rather, we describe an addition that<br>&gt; specifically provides improvements for protocol operator requirements.<br>&gt;<br>&gt; When a protocol wishes to declare operators that conforming types must<br>&gt; implement, we propose adding the ability to declare operator requirements<br>&gt; as static members of the protocol:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; Then, the protocol author is responsible for providing a generic global<br>&gt; *trampoline* operator that is constrained by the protocol type and<br>&gt; delegates to the static operator on that type:<br>&gt;<br>&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;   return T.==(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; Types conforming to a protocol that contains static operators would<br>&gt; implement the operators as static methods defined*within* the type:<br>&gt;<br>&gt; struct Foo: Equatable {<br>&gt;   let value: Int<br>&gt;<br>&gt;   static func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;     return lhs.value == rhs.value<br>&gt;   }<br>&gt; }<br>&gt; let f1 = Foo(value: 5)let f2 = Foo(value: 10)let eq = (f1 == f2)<br>&gt;<br>&gt; When the compiler sees an equality expression between two Foos like the<br>&gt; one above, it will call the global == &lt;T: Equatable&gt; function. Since T is<br>&gt; bound to the type Foo in this case, that function simply delegates to the<br>&gt; static methodFoo.==, which performs the actual comparison.<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#benefits-of-this-approach&gt;Benefits<br>&gt; of this approach<br>&gt;<br>&gt; By using the name of the operator itself as the method, this approach<br>&gt; avoids bloating the public interfaces of protocols and conforming types<br>&gt; with additional named methods, reducing user confusion. This also will lead<br>&gt; to better consistency going forward, as various authors of such protocols<br>&gt; will not be providing their own method names.<br>&gt;<br>&gt; For a particular operator, this approach also reduces the number of global<br>&gt; instances of that operator. Instead of there being one instance per<br>&gt; concrete type conforming to that protocol, there is a single generic one<br>&gt; per protocol. This should have a positive impact on type checker<br>&gt; performance by splitting the lookup of an operator&#39;s implementation from<br>&gt; searching through a very large set to searching through a much smaller set<br>&gt; to find the generic trampoline and then using the bound type to quickly<br>&gt; resolve the actual implementation.<br>&gt;<br>&gt; Similarly, this behavior allows users to be more explicit when referring<br>&gt; to operator functions as first-class operations. Passing an operator<br>&gt; function like + to a generic algorithm will still work with the<br>&gt; trampoline operators, but in situations where type inference fails and the<br>&gt; user needs to be more explicit about the types, being able to write T.+ is<br>&gt; a cleaner and unambiguous shorthand compared to casting the global + to<br>&gt; the appropriate function signature type.<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#other-kinds-of-operators-prefix-postfix-assignment&gt;Other<br>&gt; kinds of operators (prefix, postfix, assignment)<br>&gt;<br>&gt; Static operator methods have the same signatures as their global<br>&gt; counterparts. So, for example, prefix and postfix operators as well as<br>&gt; assignment operators would be defined the way one would expect:<br>&gt;<br>&gt; protocol SomeProtocol {<br>&gt;   static func +=(lhs: inout Self, rhs: Self)<br>&gt;   static prefix func ~(value: Self) -&gt; Self<br>&gt;<br>&gt;   // This one is deprecated, of course, but used here just to serve as an<br>&gt;   // example.<br>&gt;   static postfix func ++(value: inout Self) -&gt; Self<br>&gt; }<br>&gt; // Trampolinesfunc += &lt;T: SomeProtocol&gt;(lhs: inout T, rhs T) {<br>&gt;   T.+=(&amp;lhs, rhs)<br>&gt; }prefix func ~ &lt;T: SomeProtocol&gt;(value: T) -&gt; T {<br>&gt;   return T.~(value)<br>&gt; }postfix func ++ &lt;T: SomeProtocol&gt;(value: inout T) -&gt; T {<br>&gt;   return T.++(&amp;value)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#open-issue-class-types-and-inheritance&gt;Open<br>&gt; issue: Class types and inheritance<br>&gt;<br>&gt; While this approach works well for value types, these static operators may<br>&gt; not work as expected for class types when inheritance is involved, and more<br>&gt; work may be needed here.<br>&gt;<br>&gt; We can currently model the behavior we&#39;d like to achieve by using a named<br>&gt; eq method instead of the operator itself. (Note that we are *not* proposing<br>&gt; that the function be named eq in the final design; this was done simply<br>&gt; to perform the experiment with today&#39;s compiler.) Then we implement both<br>&gt; the new method and the current == operator and compare their behaviors.<br>&gt; For example:<br>&gt;<br>&gt; protocol ProposedEquatable {<br>&gt;   static func eq(lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; class Base: ProposedEquatable, Equatable {<br>&gt;   static func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt;     print(&quot;Base.eq&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt; }func ==(lhs: Base, rhs: Base) -&gt; Bool {<br>&gt;   print(&quot;==(Base, Base)&quot;)<br>&gt;   return true<br>&gt; }<br>&gt; class Subclass: Base {<br>&gt;   static func eq(lhs: Subclass, _ rhs: Subclass) -&gt; Bool {<br>&gt;     print(&quot;Subclass.eq(Subclass, Subclass)&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt; }func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool {<br>&gt;   print(&quot;==(Subclass, Subclass)&quot;)<br>&gt;   return true<br>&gt; }<br>&gt; func eq&lt;T: ProposedEquatable&gt;(lhs: T, _ rhs: T) -&gt; Bool {<br>&gt;   return T.eq(lhs, rhs)<br>&gt; }<br>&gt; let x = Subclass()let y = Subclass()let z = y as Base<br>&gt;<br>&gt; eq(x, y)  // prints &quot;Base.eq&quot;<br>&gt; eq(x, z)  // prints &quot;Base.eq&quot;<br>&gt;<br>&gt; x == y    // prints &quot;==(Subclass, Subclass)&quot;<br>&gt; x == z    // prints &quot;==(Base, Base)&quot;<br>&gt;<br>&gt; The result of eq(x, y) was a bit surprising, since the generic argument T is<br>&gt; bound to Subclass and there should be no dynamic dispatch at play there.<br>&gt; (Is the issue that since Base is the class explicitly conforming to<br>&gt; ProposedEquatable, this is locking in Self being bound as Base, causing<br>&gt; that overload to be found in the compiler&#39;s search? Or is this a bug?)<br>&gt;<br>&gt; An attempt was also made to fix this using dynamic dispatch, by<br>&gt; implementing eq as a class method instead of astatic method:<br>&gt;<br>&gt; protocol ProposedEquatable {<br>&gt;   static func eq(lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; class Base: ProposedEquatable, Equatable {<br>&gt;   class func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt;     print(&quot;Base.eq&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt; }func ==(lhs: Base, rhs: Base) -&gt; Bool {<br>&gt;   print(&quot;==(Base, Base)&quot;)<br>&gt;   return true<br>&gt; }<br>&gt; class Subclass: Base {<br>&gt;   override class func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt;     print(&quot;Subclass.eq(Base, Base)&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt;   class func eq(lhs: Subclass, _ rhs: Subclass) -&gt; Bool {<br>&gt;     print(&quot;Subclass.eq(Subclass, Subclass)&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt; }func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool {<br>&gt;   print(&quot;==(Subclass, Subclass)&quot;)<br>&gt;   return true<br>&gt; }<br>&gt; func eq&lt;T: ProposedEquatable&gt;(lhs: T, _ rhs: T) -&gt; Bool {<br>&gt;   return T.eq(lhs, rhs)<br>&gt; }<br>&gt; let x = Subclass()let y = Subclass()let z = y as Base<br>&gt;<br>&gt; eq(x, y)  // prints &quot;Subclass.eq(Base, Base)&quot;<br>&gt; eq(x, z)  // prints &quot;Base.eq&quot;<br>&gt;<br>&gt; x == y    // prints &quot;==(Subclass, Subclass)&quot;<br>&gt; x == z    // prints &quot;==(Base, Base)&quot;<br>&gt;<br>&gt; This helped slightly, since at least it resulting in a method on the<br>&gt; expected subclass being called, but this still means that anyone<br>&gt; implementing this operator on subclasses would have to do some casting, and<br>&gt; it&#39;s awkward that subclasses would be expected to write its operator in<br>&gt; terms of the conforming base class.<br>&gt;<br>&gt; It should also be noted (code not provided here) that using instance<br>&gt; methods does not solve this problem, presumably for the same<br>&gt; dispatch-related reasons that the class methods called the version with<br>&gt; Base arguments.<br>&gt;<br>&gt; However, the lack of multiple dispatch in Swift means that the operators<br>&gt; we have today don&#39;t necessarily work the way a user would expect (for<br>&gt; example, the x == z expression above), so it&#39;s debatable whether this is<br>&gt; a significant concern.<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#stretch-goal-automatically-generating-trampolines&gt;Stretch<br>&gt; goal: Automatically generating trampolines<br>&gt;<br>&gt; To further ease the use of protocol-defined operators, the compiler could<br>&gt; automatically define the trampoline operator function at global scope. For<br>&gt; example, a protocol and operator of the form<br>&gt;<br>&gt; protocol SomethingAddable {<br>&gt;   static func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt;<br>&gt; could automatically produce a generic global trampoline operator<br>&gt; constrained by the protocol type (by substituting forSelf), with the same<br>&gt; visibility as the protocol. The body of this would simply delegate to the<br>&gt; static/class operator of the concrete type:<br>&gt;<br>&gt; func + &lt;τ_0: SomethingAddable&gt;(lhs: τ_0, rhs: τ_0) -&gt; τ_0 {<br>&gt;   return τ_0.+(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; This approach could be extended for heterogeneous parameter lists:<br>&gt;<br>&gt; protocol IntegerAddable {<br>&gt;   static func +(lhs: Self, rhs: Int) -&gt; Self<br>&gt; }<br>&gt; // Auto-generated by the compilerfunc + &lt;τ_0: IntegerAddable&gt;(lhs: τ_0, rhs: Int) -&gt; τ_0 {<br>&gt;   return τ_0.+(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; Additional generic constraints could even be propagated to the trampoline<br>&gt; operator:<br>&gt;<br>&gt; protocol GenericAddable {<br>&gt;   static func + &lt;Arg: AnotherProtocol&gt;(lhs: Self, rhs: Arg) -&gt; Self<br>&gt; }<br>&gt; // Auto-generated by the compilerfunc + &lt;τ_0: GenericAddable, τ_1: AnotherProtocol&gt;(lhs: τ_0, rhs: τ_1) -&gt; τ_0 {<br>&gt;   return τ_0.+(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; One major benefit of this is that neither the protocol author nor<br>&gt; developers writing types conforming to that protocol would have to write<br>&gt; *any* code that lives outside the protocol. This feels clean and<br>&gt; consistent.<br>&gt;<br>&gt; This feature, however, may be more controversial, because:<br>&gt;<br>&gt;    - It involves the compiler implicitly generating glue code behind the<br>&gt;    scenes, which is less discoverable and may be considered &quot;magic&quot;.<br>&gt;    - It raises the question of whether users should be allowed to define<br>&gt;    their own trampolines that match the signatures of the auto-generated ones,<br>&gt;    and if so, how the conflict is resolved.<br>&gt;    - Defining the trampoline operator manually requires a trivial amount<br>&gt;    of effort, and that effort is a one-time exercise by the protocol author.<br>&gt;<br>&gt; In addition, automatic trampoline generation is a much deeper change that<br>&gt; would likely not be implementable in the Swift 3 timeline, so we will defer<br>&gt; this for a future proposal and deeper discussion later.<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Currently, the Swift language allows the use of operators as the names of<br>&gt; global functions and of functions in protocols. This proposal is<br>&gt; essentially asking to extend that list to include static/class methods of<br>&gt; protocols and concrete types and to support referencing them in expressions<br>&gt; using the . operator.<br>&gt;<br>&gt; Interestingly, the production rules themselves of the Swift grammar for<br>&gt; function declarations *already* appear to support declaring static<br>&gt; functions inside a protocol or other type with names that are operators. In<br>&gt; fact, declaring a static operator function in a protocol works today (that<br>&gt; is, the static modifier is ignored).<br>&gt;<br>&gt; However, defining such a function in a concrete type fails with the error operators<br>&gt; are only allowed at global scope.This area<br>&gt; &lt;https://github.com/apple/swift/blob/797260939e1f9e453ab49a5cc6e0a7b40be61ec9/lib/Parse/ParseDecl.cpp#L4444&gt;<br>&gt;  of Parser::parseDeclFunc appears to be the likely place to make a change<br>&gt; to allow this.<br>&gt;<br>&gt; In order to support *calling* a static operator using its name, the<br>&gt; production rules for *explicit-member-expression* would need to be<br>&gt; updated to support operators where they currently only support identifiers:<br>&gt;<br>&gt; *explicit-member-expression* → *postfix-expression* ­. *identifier*<br>&gt; *­generic-argument-clause­**opt*­<br>&gt; *explicit-member-expression* → *postfix-expression* ­­. *operator*<br>&gt; *­generic-argument-clause­**opt*­<br>&gt; *explicit-member-expression* → *postfix-expression* ­­. *­identifier* ­(<br>&gt; *­argument-names­* )­<br>&gt; *explicit-member-expression* → *postfix-expression* ­­. *­operator* ­(<br>&gt; *­argument-names­* )­<br>&gt;<br>&gt; For consistency with other static members, we could consider modifying<br>&gt; *implicit-member-expression* as well, but referring to an operator<br>&gt; function with only a dot preceding it might look awkward:<br>&gt;<br>&gt; *implicit-member-expression* → . *­identifier­*<br>&gt; *implicit-member-expression* → . *operator­*<br>&gt;<br>&gt; Open question: Are there any potential ambiguities between the dot in the<br>&gt; member expression and dots in operators?<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The ability to declare operators as static/class functions inside a type<br>&gt; is a new feature and would not affect existing code. Likewise, the ability<br>&gt; to explicitly reference the operator function of a type (e.g., Int.+ or Int.+(5,<br>&gt; 7) would not affect existing code.<br>&gt;<br>&gt; Changing the way operators are declared in protocols (static instead of<br>&gt; non-static) would be a breaking change. However, since the syntax forms are<br>&gt; mutually exclusive, we may wish to let them coëxist for the time being.<br>&gt; That is, protocols that declare non-static operators would have them<br>&gt; satisfied by global functions, and protocols that declare static operators<br>&gt; would have them satisfied by static methods. While this provides two ways<br>&gt; for developers to do the same thing, reducing breakage is a greater goal.<br>&gt; We can consider deprecating non-static operators in protocols to lead<br>&gt; developers to the new syntax and then remove it in a later version of Swift.<br>&gt;<br>&gt; Applying this change to the protocols already in the Swift standard<br>&gt; library (such as Equatable) would be a breaking change, because it would<br>&gt; change the way by which subtypes conform to that protocol. It might be<br>&gt; possible to implement a quick fix that hoists a global operator function<br>&gt; into the subtype&#39;s definition, either by making it static and moving the<br>&gt; code itself or by wrapping it in an extension.<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; One alternative would be to do nothing. This would leave us with the<br>&gt; problems cited above:<br>&gt;<br>&gt;    - Concrete types either provide their own global operator overloads,<br>&gt;    increasing the workload of the type checker...<br>&gt;    - ...*or* they define generic operators that delegate to named<br>&gt;    methods, but those named methods bloat the public interface of the type.<br>&gt;    - Furthermore, there is no consistency required for these named<br>&gt;    methods among different types; each can define its own, and subtle<br>&gt;    differences in naming can lead to user confusion.<br>&gt;<br>&gt; Another alternative would be that instead of using static methods,<br>&gt; operators could be defined as instance methods on a type. For example,<br>&gt;<br>&gt; protocol SomeProtocol {<br>&gt;   func +(rhs: Self) -&gt; Self<br>&gt; }<br>&gt; struct SomeType: SomeProtocol {<br>&gt;   func +(rhs: SomeType) -&gt; SomeType { ... }<br>&gt; }<br>&gt; func + &lt;T: SomeProtocol&gt;(lhs: T, rhs: T) -&gt; T {<br>&gt;   return lhs.+(rhs)<br>&gt; }<br>&gt;<br>&gt; There is not much to be gained by doing this, however. It does not solve<br>&gt; the dynamic dispatch problem for classes described above, and it would<br>&gt; require writing operator method signatures that differ from those of the<br>&gt; global operators because the first argument instead becomes the implicit<br>&gt; self. As a matter of style, when it doesn&#39;t necessarily seem appropriate<br>&gt; to elevate one argument of an infix operator—especially one that is<br>&gt; commutative—to the special status of &quot;receiver&quot; while the other remains an<br>&gt; argument.<br>&gt;<br>&gt; Likewise, commutative operators with heterogeneous arguments are more<br>&gt; awkward to implement if operators are instance methods. Consider a<br>&gt; contrived example of a CustomStringProtocol type that supports<br>&gt; concatenation with Characterusing the + operator, commutatively. With<br>&gt; static operators and generic trampolines, both versions of the operator are<br>&gt; declared in CustomStringProtocol, as one would expect:<br>&gt;<br>&gt; protocol CustomStringProtocol {<br>&gt;   static func +(lhs: Self, rhs: Character) -&gt; Self<br>&gt;   static func +(lhs: Character, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; func + &lt;T: CustomStringProtocol&gt;(lhs: T, rhs: Character) -&gt; T {<br>&gt;   return T.+(lhs, rhs)<br>&gt; }func + &lt;T: CustomStringProtocol&gt;(lhs: Character, rhs: T) -&gt; T {<br>&gt;   return T.+(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; Likewise, the implementation of both operators would be contained entirely<br>&gt; within the conforming types. If these were instance methods, it&#39;s unclear<br>&gt; how the version that has the Character argument on the left-hand side<br>&gt; would be expressed in the protocol, or how it would be implemented if an<br>&gt; instance of Character were the receiver. Would it be an extension on the<br>&gt; Character type? This would split the implementation of an operation that<br>&gt; logically belongs to CustomStringProtocolacross two different locations<br>&gt; in the code, which is something we&#39;re trying to avoid.<br>&gt;<br>&gt; &lt;https://github.com/allevato/swift-evolution/blob/master/proposals/0000-improving-operators-in-protocols.md#acknowledgments&gt;<br>&gt; Acknowledgments<br>&gt;<br>&gt; Thanks to Chris Lattner and Dave Abrahams for contributing to the early<br>&gt; discussions, particularly regarding the need to improve type checker<br>&gt; performance by genericizing protocol-based operators.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/c12ea504/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Improving operator requirements in protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  2, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 2, 2016, at 9:44 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve written a proposal to formalize some of the discussion that was had over in the thread for the `FloatingPoint` protocol proposal regarding improvements to operator requirements in protocols that do not require named methods be added to the protocol and conforming types. Thanks to everyone who was participating in that discussion!<br></p><p>This is really great, thank you for pushing forward on this Tony!  I am really optimistic that this will allow us to finally put to rest the weirdness we have with protocols and operators.<br></p><p>&gt; When a protocol wishes to declare operators that conforming types must implement, we propose adding the ability to declare operator requirements as static members of the protocol:<br>&gt; protocol Equatable {<br>&gt;   static func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>This sounds great.  Operators are clearly “static&quot; members, and adding the keyword here is great for consistency when you end up *implementing* an operator inline in a class.  At that point, you want to see in the source where it is a “static” operator or a “class” operator (dynamic dispatch).<br></p><p>You don’t include it as part of your proposal, but I’d strongly suggest that we deprecate and/or remove the existing non-static operator requirement syntax.  I really don’t like ending up in a situation where we have both “instance” and “static” operators, where these two cases have different declaration and use syntax.<br></p><p>&gt; Then, the protocol author is responsible for providing a generic global trampoline operator that is constrained by the protocol type and delegates to the static operator on that type:<br>&gt; <br>&gt; func == &lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;   return T.==(lhs, rhs)<br>&gt; }<br>&gt; Types conforming to a protocol that contains static operators would implement the operators as static methods<br>&gt; <br>They can also be ‘class’ methods in a class.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/43403e27/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Improving operator requirements in protocols</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May  2, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, May 2, 2016 at 9:44 AM, Tony Allevato via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I&#39;ve written a proposal to formalize some of the discussion that was had<br>&gt; over in the thread for the `FloatingPoint` protocol proposal regarding<br>&gt; improvements to operator requirements in protocols that do not require named<br>&gt; methods be added to the protocol and conforming types. Thanks to everyone<br>&gt; who was participating in that discussion!<br>&gt;<br>&gt; The proposal can be viewed in this pull request and is pasted below.<br></p><p>Hi Tony,<br></p><p>I&#39;d like to post this feedback on behalf of Dave Abrahams, Maxim<br>Moiseev and myself.<br></p><p>We are in favor of your proposal, but we would like to request a few<br>modifications.<br></p><p>1.  Could you remove the section about the stretch goal to generate<br>the trampolines automatically?  We think that the proposal provides<br>enough value by itself, and we generating the trampolines will just<br>complicate the implementation, delaying the user model improvement.<br>This can come later.<br></p><p>2.  The section about the classes is written in a way that seems to<br>imply that the proposal regresses the way Equatable works with<br>classes.  We don&#39;t think this is the case.  Could you change to just<br>acknowledge the problem and say that we are not fixing it in this<br>proposal?<br></p><p>You wrote to Dave:<br></p><p>&gt; We do have some problems today, such as above where using `==` on a `(Base, Subclass as Base)` pair ends up calling `==(Base, Base)` because we lack multiple dispatch. What surprised me though was that the `eq` call between two `Subclass` instances passed to the trampoline operator ended up calling `Base.eq`. I would have expected `Subclass.eq` to be called there since the generic argument `T` was bound to `Subclass`. Today, a non-generic `==(Subclass, Subclass)` operator *does* do the right thing.<br></p><p>The reason why the trampoline calls the ==(Base,Base) overload in<br>Subclass is because it is a part of the override chain for the base<br>class method that introduces the conformance.<br></p><p>The reason why the non-generic ==(Subclass,Subclass) operator does the<br>right thing is because it is a better match for overload resolution of<br>== at the callsite.  But if you have a (Subclass as Base, Subclass as<br>Base) pair, even today it will call ==(Base,Base).<br></p><p>Therefore, we think that this section describes the exact problem that<br>we have today.<br></p><p>3.  Could you explain in more detail how the name lookup works in the<br>proposal?  In particular, it would be good to emphasize that regular<br>name lookup done when type checking an infix expression would not find<br>an operator defined as a type member.<br></p><p>4.  What do you think about adding a rule to disallow defining member<br>operators that don&#39;t satisfy a protocol requirement?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Improving operator requirements in protocols</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May  3, 2016 at 09:00:00am</p></header><div class="content"><p>FWIW, the problems with class inheritance and Equatable can be fixed by changing the definition of Equatable into using an associatedtype for the RHS:<br></p><p>protocol Equatable {<br>    typealias EqualSelf = Self<br>    func == (lhs: Self, rhs: EqualSelf) -&gt; Bool<br>    func != (lhs: Self, rhs: EqualSelf) -&gt; Bool<br>}<br>func != &lt;T : Equatable&gt;(lhs: T, rhs: T.EqualSelf) -&gt; Bool {<br>    return !(lhs == rhs)<br>}<br></p><p>This way, a generic function of type Subclass will expect a comparison of type `(Subclass, Subclass.EqualSelf) -&gt; Bool`, i.e. `(Subclass, Base) -&gt; Bool`, so it&#39;ll do the right comparison.<br></p><p>I&#39;m not proposing this change because I haven&#39;t found but contrived use for it. But if there&#39;s demand (and a real use case) for e.g. making an existential of Equatable (say, a struct AnyEquatable), then this could be the fix.<br></p><p>Value types will obviously keep working just like before, since T and T.EqualSelf are synonymous for them.<br></p><p>— Pyry<br></p><p>&gt;&gt; We do have some problems today, such as above where using `==` on a `(Base, Subclass as Base)` pair ends up calling `==(Base, Base)` because we lack multiple dispatch. What surprised me though was that the `eq` call between two `Subclass` instances passed to the trampoline operator ended up calling `Base.eq`. I would have expected `Subclass.eq` to be called there since the generic argument `T` was bound to `Subclass`. Today, a non-generic `==(Subclass, Subclass)` operator *does* do the right thing.<br>&gt; <br>&gt; The reason why the trampoline calls the ==(Base,Base) overload in<br>&gt; Subclass is because it is a part of the override chain for the base<br>&gt; class method that introduces the conformance.<br>&gt; <br>&gt; The reason why the non-generic ==(Subclass,Subclass) operator does the<br>&gt; right thing is because it is a better match for overload resolution of<br>&gt; == at the callsite.  But if you have a (Subclass as Base, Subclass as<br>&gt; Base) pair, even today it will call ==(Base,Base).<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Proposal] Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May  3, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Dmitri, thanks for the great feedback. I&#39;ve updated the pull request &lt;<br>https://github.com/apple/swift-evolution/pull/283&gt;.<br></p><p><br>On Mon, May 2, 2016 at 5:53 PM Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Mon, May 2, 2016 at 9:44 AM, Tony Allevato via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I&#39;ve written a proposal to formalize some of the discussion that was had<br>&gt; &gt; over in the thread for the `FloatingPoint` protocol proposal regarding<br>&gt; &gt; improvements to operator requirements in protocols that do not require<br>&gt; named<br>&gt; &gt; methods be added to the protocol and conforming types. Thanks to everyone<br>&gt; &gt; who was participating in that discussion!<br>&gt; &gt;<br>&gt; &gt; The proposal can be viewed in this pull request and is pasted below.<br>&gt;<br>&gt; Hi Tony,<br>&gt;<br>&gt; I&#39;d like to post this feedback on behalf of Dave Abrahams, Maxim<br>&gt; Moiseev and myself.<br>&gt;<br>&gt; We are in favor of your proposal, but we would like to request a few<br>&gt; modifications.<br>&gt;<br>&gt; 1.  Could you remove the section about the stretch goal to generate<br>&gt; the trampolines automatically?  We think that the proposal provides<br>&gt; enough value by itself, and we generating the trampolines will just<br>&gt; complicate the implementation, delaying the user model improvement.<br>&gt; This can come later.<br>&gt;<br></p><p>Done. I left a brief mention (once sentence) of it in &quot;Alternatives<br>Considered&quot; so that the history of it wasn&#39;t completely lost.<br></p><p>2.  The section about the classes is written in a way that seems to<br>&gt; imply that the proposal regresses the way Equatable works with<br>&gt; classes.  We don&#39;t think this is the case.  Could you change to just<br>&gt; acknowledge the problem and say that we are not fixing it in this<br>&gt; proposal?<br>&gt;<br></p><p>Done—I removed all of the code examples and tightened it up into a brief<br>discussion acknowledging the issue.<br></p><p>3.  Could you explain in more detail how the name lookup works in the<br>&gt; proposal?  In particular, it would be good to emphasize that regular<br>&gt; name lookup done when type checking an infix expression would not find<br>&gt; an operator defined as a type member.<br>&gt;<br></p><p>Done.<br></p><p><br>&gt; 4.  What do you think about adding a rule to disallow defining member<br>&gt; operators that don&#39;t satisfy a protocol requirement?<br>&gt;<br></p><p>Added. That seems like a reasonable and appropriate requirement, since the<br>feature is being proposed specifically to improve protocol-required<br>operators.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/6e84a5c4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
