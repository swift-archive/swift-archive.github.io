<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>associated objects</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>September 30, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; What it does is allow developers to extend the language to do things that it doesn&#39;t support. <br></p><p><br>Hitting boundaries... or so it seems... This is very interesting. <br>In spite of its very modern approach, wether we like it or not, Swift is <br>still a conventional Hard Coded Statical Programming Language,<br> (here further in this text referred to as HCSPL) <br>which means that, like in C++ or C# etc. its language <br>elements are essentially predefined, &quot;fixed&quot;, and that <br>it is therefore a daunting task to make the language as <br>versatile as possible and to satisfy everyone&#39;s requirements, <br>We can see that every day in swift-evolution and for that matter <br>all other HCSPL (C#, C++, Python, ObjC etc) related forums.<br></p><p>HCSPL are in a sense a traditional compromise to &quot;The Machine” <br>and enables us -within the limitations  of our current state of main <br>stream technology- to make highly optimised fast running compiled applications. <br>That we know is the virtue of hard coded static languages. <br>&quot;The Machine&quot; however gets more advanced and faster day by day <br>thereby diminishing the need for HCSPL in its course. <br></p><p>However, (as far as I know) , due to the nature of HCSPL, like Swift, <br>there is no (direct and supported and convenient) way supporting <br>meta-programming facilities, e.g. to generate define objects (classes), <br>and its instances on the fly, that is, at run time. <br></p><p>In most cases, one can live with this HCSPL &quot;compromise&quot;, especially with Swift, <br>which is very flexible and offers many convenient ways to solve a wide spectrum <br>of programming challenges. However, one could think of many applications like<br> in AI where applications can improve and extend themselves, learning to adjust <br>and adapt to their environment, thereby altering and tuning its performance, <br>like our brains do...naturally. <br>In contrast, a HCSPL forces one to match one&#39;s problem solving to the language <br>elements that are available in the HCSPL. In a sense it&#39;s like having a big box <br>with Lego bricks, that is predefined discrete elements, which allow one to build things <br>with it, however it still remains limited as Lego. <br>This is not the case with a dynamic language like Smalltalk.<br></p><p>Since ca 1980 I have a high interest in Smalltalk (and other OOP dynamic<br>programming languages too). Some would argue that Smalltalk is a <br>programming language, but take a closer look, (e.g. with Pharo).<br>It is just a relatively small set of mainly syntactic rules defining the <br>environment wherein the Smalltalk system lives (almost literally) as a <br>dynamic object hierarchy, were everything is an object, which as we know <br>is a completely different approach compared to HCSPLs.<br></p><p>Before Swift had arrived, my hope was that the successor of Objective C <br>would be Smalltalk, or at least Smalltalk  as a breeding environment for <br>developing macOS, iOS, tvOS and watchOS applications. In this role it would then<br>be desirable that the apps thus produced are &quot;closed apps&quot; so to speak, that is that <br>the development environment  is not available to the end-user. <br>The thought of a e.g. &quot;new Xcode/Smalltalk&quot; being the next Apple development <br>environment seemed reasonable, also because ObjectiveC had features <br>inspired by Smalltalk. (as all OOP languages have) <br>Alas, it didn&#39;t happen..but I keep dreaming... <br></p><p>Perhaps out of context, one then might ask how to interface that <br>Xcode/Smalltalk to all those existing libraries (Cocoa UIKit etc.) <br>This can be done by letting Smalltalk crawl through all API definitions,<br>generating its own interface classes dynamically. This sounds ambitious <br>but it can be done. Something  a HCSPL like Swift could never do as it is. <br></p><p>And now we don&#39;t have Smalltalk but instead Swift, not bad at all, currently <br>I find it the most advanced HCSPL now available.  <br></p><p>However, my verbose text here could be food for thoughts: <br></p><p>Is it possible to have best of (these completely different) both worlds? <br>Would it be possible in Swift to have facilities to generate objects <br>dynamically at runtime? and, if desirable, how can such be implemented?<br></p><p><br>Kind Regards<br>TedvG<br></p><p>&gt; On Sep 30, 2016, at 9:40 AM, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br></p><p>&gt; <br></p><p>&gt; Robert,<br></p><p>&gt; <br></p><p>&gt; What it does is allow developers to extend the language to do things that it doesn&#39;t support. Associated Objects is just a flexible way to allow developers to do that, and that&#39;s how I used it in Objective-C, so that&#39;s what I thought of in Swift when I found that &quot;I want to do &lt;x&gt; but the language doesn&#39;t support it&quot;. Maybe there&#39;s a completely different way to achieve the same thing - but I just went with what I know.<br></p><p><br>&quot;I want to do &lt;x&gt; but the language doesn&#39;t support it” is the whole reason for this list!  I want to know what “&lt;x&gt;” is in order to wrap my head around your proposal better. I’m not here to invalidate your work with a slew of criticisms, I’m just trying to understand your proposal by probing you about it.<br></p><p><br>&gt; So it&#39;s difficult to come up with concrete examples of &quot;things a developer might want to do but the language doesn&#39;t support&quot; because almost by definition they are unforeseen. I can only enumerate the things I have wanted to do in Obj-C and Swift and how I got around it.<br></p><p>&gt; - Dynamically add properties to a class (obc-c) / implement stored properties (swift).<br></p><p>&gt; - Add per-instance methods at run-time.<br></p><p>&gt; - Perform a function when some other object is deallocated (haven&#39;t solved this in Swift yet, but in obj-c associated object deallocation is well-defined so I used that).<br></p><p>&gt; - Other unforeseen things…<br></p><p><br>Again, these are features and I want motivations behind them.  Why should you be able to dynamically add stored properties and methods to any Swift class?  Why should you be able to observe deallocation if deallocation calls are not guaranteed (remember, Objective-C and Swift do not guarantee -dealloc/deinit calls in any order at any time - please don’t assume an RAII-like model because it will lead to memory leaks and malformed code).<br></p><p>I will say: Perhaps if you’re having trouble motivating the inclusion of this feature, you may want to step back and reevaluate its place in the language and why you wanted to write this library in the first place.  Often times, I find that really helps get the creative juices flowing.  Or, if I can’t come up with anything, it means I go back to step 1 and start over.  Proposals can be as much a learning process for us as it is for you.<br></p><p>&gt; <br></p><p>&gt; So maybe Associated Objects isn&#39;t the answer and I should have stated the problem better, instead of jumping to what I thought the answer might be... the problem I want to solve is this:<br></p><p>&gt; <br></p><p>&gt; As a developer I want to do &lt;x&gt; but the language doesn&#39;t support it... what helpful thing *can* I use right now that allows me to achieve this? I accept the disclaimer by ticking this box:<br></p><p>&gt; [ ] Yes, I understand that I&#39;m not using Swift anymore, but some custom run-time thing that I&#39;m building myself on top of Swift, so if I want type safety I have to implement it, if I want copy-on-write or other optimisations, I have to implement it, and I understand that performance might not be the best too.<br></p><p>&gt; <br></p><p><br>So from what I’ve gathered you’ve written a library to do this yourself.  You have a vision for how you want to use this library.  You think that vision is compatible with a language-level change.  From my perspective, your job now is to articulate that vision and motivate it to this list.  I don’t think associated objects and the other dynamic features you mention are fundamentally incompatible with Swift, I just think the design that I’ve seen so far may not be the best way of going about it and I’m voicing my concerns as much.  <br></p><p>&gt; If Swift can provide something to help developers go beyond the abilities the current version, isn&#39;t that a good idea?<br></p><p><br>No one disputes this.  We just want to see your rationale.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/71bdaa8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>associated objects</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>September 30, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Is it possible to have best of (these completely different) both worlds? <br></p><p>Yes, of course it is.  Your email spends a lot of words trying to form a false dichotomy.  Swift can definitely have both awesome dynamic features while still having performance, predictability and safety.<br></p><p>&gt; Would it be possible in Swift to have facilities to generate objects <br>&gt; dynamically at runtime? and, if desirable, how can such be implemented?<br></p><p>Here’s an extant implementation that you can use today:<br>https://github.com/Zewo/Reflection<br></p><p>I’m sure it isn’t ideal, but it proves that it can be done.  When we have bandwidth to reevaluate this area from first principles, I’m sure we can make improvements on it.<br></p><p>I will grant you that Smalltalk is a beautiful language in its simplicity, but for that simplicity it makes many tradeoffs that we’re not willing to make.  We are willing to make the internal implementation of Swift complex if that means that we get a beautiful model for programmers - one that preserves the virtues of safety-by-default, predictability, performance, and joy-to-develop-in.<br></p><p>The meme of “Swift can never (or will never) support dynamic features” is tired, and also wildly inaccurate.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October  3, 2016 at 03:00:00am</p></header><div class="content"><p>Are stored properties in extensions already being discussed elsewhere? Is<br>this one of those deferred-but-not-indexed-anywhere subjects?<br></p><p>I wonder how stored properties could potentially be implemented, I can only<br>think of two ways:<br></p><p>1. An extra pointer per instance (with resulting ABI compatability<br>implications) to hold a collection of the stored items.<br></p><p>2. A global lookup for any instance where stored properties have been set.<br></p><p>I&#39;m not a language implementation expert, or familiar with the swift<br>implementation, so there may be other/better ways - I&#39;d like to know if<br>there are?<br></p><p>If not, and option 2 was employed, a little foresight might enable the<br>mechanism to be overloaded in the future for other dynamic features too. A<br>bit flag (I&#39;m hoping there&#39;s a spare bit in an existing flags field<br>somewhere?) could indicate whether any feature had caused the object to be<br>added to this lookup and deinit could check this bit and make sure the<br>object is removed, thus any stored properties are nilled. The lookup value<br>could be a struct with one member (extensionStoredProperties), and<br>additional members can be added in future for new features.<br></p><p>I get the impression from the associated objects discussion that perhaps<br>there are much better, more optimal, more ingenious, more unknown-by-me<br>ways of doing such things, so apologies if this whole idea is way-off the<br>mark :D<br></p><p>Jay<br></p><p>P.S. Note that stored properties in extensions could enable developers to<br>implement their own dynamic features in Swift.. so such desires could be<br>satisfied in the short term until they could be done properly in the<br>language.<br></p><p>On Sat, 1 Oct 2016 at 00:49 Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Is it possible to have best of (these completely different) both worlds?<br>&gt;<br>&gt; Yes, of course it is.  Your email spends a lot of words trying to form a<br>&gt; false dichotomy.  Swift can definitely have both awesome dynamic features<br>&gt; while still having performance, predictability and safety.<br>&gt;<br>&gt; &gt; Would it be possible in Swift to have facilities to generate objects<br>&gt; &gt; dynamically at runtime? and, if desirable, how can such be implemented?<br>&gt;<br>&gt; Here’s an extant implementation that you can use today:<br>&gt; https://github.com/Zewo/Reflection<br>&gt;<br>&gt; I’m sure it isn’t ideal, but it proves that it can be done.  When we have<br>&gt; bandwidth to reevaluate this area from first principles, I’m sure we can<br>&gt; make improvements on it.<br>&gt;<br>&gt; I will grant you that Smalltalk is a beautiful language in its simplicity,<br>&gt; but for that simplicity it makes many tradeoffs that we’re not willing to<br>&gt; make.  We are willing to make the internal implementation of Swift complex<br>&gt; if that means that we get a beautiful model for programmers - one that<br>&gt; preserves the virtues of safety-by-default, predictability, performance,<br>&gt; and joy-to-develop-in.<br>&gt;<br>&gt; The meme of “Swift can never (or will never) support dynamic features” is<br>&gt; tired, and also wildly inaccurate.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161003/9bc76f98/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October  9, 2016 at 07:00:00pm</p></header><div class="content"><p>I have been thinking further on this and in addition to my previous two<br>thoughts about implementation, I have had another idea...<br></p><p>3. If there is a bit spare in the object header somewhere (that is<br>currently always zero), this could be used to signify the presence of an<br>additional struct that immediately follows after the existing object data.<br>I *think* that this method would allow binary compatibility with older<br>modules. Instances that have this bit set would allow stored properties in<br>extensions. The struct at the end would have one member, a pointer to a<br>table of additional objects/values, stored properties defined in extensions<br>could be stored in here, using a hash derived from the<br>module/protocol/extension/property name (or something better if it exists).<br></p><p>The struct could be very simple as described above or more complex, with<br>additional features, for example a list of deinit hooks, dynamically added<br>methods, etc. The struct itself may also be dynamic in size/layout if such<br>complexity is warranted by size or extensibility concerns. Perhaps it<br>should start with some flags and its size (size would be fixed and only<br>increase with revisions so this would double as a &#39;version&#39; number).<br></p><p>If viable - this would be a much better way to implement this feature than<br>my previous two ideas. It doesn&#39;t require global lookups or additional<br>levels of indirection beyond accessing the dynamic data/feature itself.<br></p><p><br>On Mon, 3 Oct 2016 at 04:13 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br></p><p>&gt; Are stored properties in extensions already being discussed elsewhere? Is<br>&gt; this one of those deferred-but-not-indexed-anywhere subjects?<br>&gt;<br>&gt; I wonder how stored properties could potentially be implemented, I can<br>&gt; only think of two ways:<br>&gt;<br>&gt; 1. An extra pointer per instance (with resulting ABI compatability<br>&gt; implications) to hold a collection of the stored items.<br>&gt;<br>&gt; 2. A global lookup for any instance where stored properties have been set.<br>&gt;<br>&gt; I&#39;m not a language implementation expert, or familiar with the swift<br>&gt; implementation, so there may be other/better ways - I&#39;d like to know if<br>&gt; there are?<br>&gt;<br>&gt; If not, and option 2 was employed, a little foresight might enable the<br>&gt; mechanism to be overloaded in the future for other dynamic features too. A<br>&gt; bit flag (I&#39;m hoping there&#39;s a spare bit in an existing flags field<br>&gt; somewhere?) could indicate whether any feature had caused the object to be<br>&gt; added to this lookup and deinit could check this bit and make sure the<br>&gt; object is removed, thus any stored properties are nilled. The lookup value<br>&gt; could be a struct with one member (extensionStoredProperties), and<br>&gt; additional members can be added in future for new features.<br>&gt;<br>&gt; I get the impression from the associated objects discussion that perhaps<br>&gt; there are much better, more optimal, more ingenious, more unknown-by-me<br>&gt; ways of doing such things, so apologies if this whole idea is way-off the<br>&gt; mark :D<br>&gt;<br>&gt; Jay<br>&gt;<br>&gt; P.S. Note that stored properties in extensions could enable developers to<br>&gt; implement their own dynamic features in Swift.. so such desires could be<br>&gt; satisfied in the short term until they could be done properly in the<br>&gt; language.<br>&gt;<br>&gt; On Sat, 1 Oct 2016 at 00:49 Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Is it possible to have best of (these completely different) both worlds?<br>&gt;<br>&gt; Yes, of course it is.  Your email spends a lot of words trying to form a<br>&gt; false dichotomy.  Swift can definitely have both awesome dynamic features<br>&gt; while still having performance, predictability and safety.<br>&gt;<br>&gt; &gt; Would it be possible in Swift to have facilities to generate objects<br>&gt; &gt; dynamically at runtime? and, if desirable, how can such be implemented?<br>&gt;<br>&gt; Here’s an extant implementation that you can use today:<br>&gt; https://github.com/Zewo/Reflection<br>&gt;<br>&gt; I’m sure it isn’t ideal, but it proves that it can be done.  When we have<br>&gt; bandwidth to reevaluate this area from first principles, I’m sure we can<br>&gt; make improvements on it.<br>&gt;<br>&gt; I will grant you that Smalltalk is a beautiful language in its simplicity,<br>&gt; but for that simplicity it makes many tradeoffs that we’re not willing to<br>&gt; make.  We are willing to make the internal implementation of Swift complex<br>&gt; if that means that we get a beautiful model for programmers - one that<br>&gt; preserves the virtues of safety-by-default, predictability, performance,<br>&gt; and joy-to-develop-in.<br>&gt;<br>&gt; The meme of “Swift can never (or will never) support dynamic features” is<br>&gt; tired, and also wildly inaccurate.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/8efa87a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October  9, 2016 at 09:00:00pm</p></header><div class="content"><p>There is a 4th way.<br></p><p>Introduce an internal protocol Associatable, which would tell the compiler to add an additional (hidden) field to the object which would include the &quot;dictionary&quot; of key -&gt; value associated values. (It would be off-limits to extensions, of course).<br></p><p>This way:<br></p><p>- it won&#39;t be a single dictionary containing all the associated values<br>- classes can opt-in to this<br>- the dictionary will be per-instance<br></p><p>This is a midway between the current implementation of ObjC associated objects and of what someone has suggested to have an extra space for each object for the AO...<br></p><p><br>&gt; On Oct 9, 2016, at 9:47 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have been thinking further on this and in addition to my previous two thoughts about implementation, I have had another idea...<br>&gt; <br>&gt; 3. If there is a bit spare in the object header somewhere (that is currently always zero), this could be used to signify the presence of an additional struct that immediately follows after the existing object data. I *think* that this method would allow binary compatibility with older modules. Instances that have this bit set would allow stored properties in extensions. The struct at the end would have one member, a pointer to a table of additional objects/values, stored properties defined in extensions could be stored in here, using a hash derived from the module/protocol/extension/property name (or something better if it exists).<br>&gt; <br>&gt; The struct could be very simple as described above or more complex, with additional features, for example a list of deinit hooks, dynamically added methods, etc. The struct itself may also be dynamic in size/layout if such complexity is warranted by size or extensibility concerns. Perhaps it should start with some flags and its size (size would be fixed and only increase with revisions so this would double as a &#39;version&#39; number).<br>&gt; <br>&gt; If viable - this would be a much better way to implement this feature than my previous two ideas. It doesn&#39;t require global lookups or additional levels of indirection beyond accessing the dynamic data/feature itself.<br>&gt; <br>&gt; <br>&gt; On Mon, 3 Oct 2016 at 04:13 Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt; Are stored properties in extensions already being discussed elsewhere? Is this one of those deferred-but-not-indexed-anywhere subjects?<br>&gt; <br>&gt; I wonder how stored properties could potentially be implemented, I can only think of two ways:<br>&gt; <br>&gt; 1. An extra pointer per instance (with resulting ABI compatability implications) to hold a collection of the stored items.<br>&gt; <br>&gt; 2. A global lookup for any instance where stored properties have been set.<br>&gt; <br>&gt; I&#39;m not a language implementation expert, or familiar with the swift implementation, so there may be other/better ways - I&#39;d like to know if there are?<br>&gt; <br>&gt; If not, and option 2 was employed, a little foresight might enable the mechanism to be overloaded in the future for other dynamic features too. A bit flag (I&#39;m hoping there&#39;s a spare bit in an existing flags field somewhere?) could indicate whether any feature had caused the object to be added to this lookup and deinit could check this bit and make sure the object is removed, thus any stored properties are nilled. The lookup value could be a struct with one member (extensionStoredProperties), and additional members can be added in future for new features.<br>&gt; <br>&gt; I get the impression from the associated objects discussion that perhaps there are much better, more optimal, more ingenious, more unknown-by-me ways of doing such things, so apologies if this whole idea is way-off the mark :D<br>&gt; <br>&gt; Jay<br>&gt; <br>&gt; P.S. Note that stored properties in extensions could enable developers to implement their own dynamic features in Swift.. so such desires could be satisfied in the short term until they could be done properly in the language.<br>&gt; <br>&gt; On Sat, 1 Oct 2016 at 00:49 Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Is it possible to have best of (these completely different) both worlds?<br>&gt; <br>&gt; Yes, of course it is.  Your email spends a lot of words trying to form a false dichotomy.  Swift can definitely have both awesome dynamic features while still having performance, predictability and safety.<br>&gt; <br>&gt; &gt; Would it be possible in Swift to have facilities to generate objects<br>&gt; &gt; dynamically at runtime? and, if desirable, how can such be implemented?<br>&gt; <br>&gt; Here’s an extant implementation that you can use today:<br>&gt; https://github.com/Zewo/Reflection &lt;https://github.com/Zewo/Reflection&gt;<br>&gt; <br>&gt; I’m sure it isn’t ideal, but it proves that it can be done.  When we have bandwidth to reevaluate this area from first principles, I’m sure we can make improvements on it.<br>&gt; <br>&gt; I will grant you that Smalltalk is a beautiful language in its simplicity, but for that simplicity it makes many tradeoffs that we’re not willing to make.  We are willing to make the internal implementation of Swift complex if that means that we get a beautiful model for programmers - one that preserves the virtues of safety-by-default, predictability, performance, and joy-to-develop-in.<br>&gt; <br>&gt; The meme of “Swift can never (or will never) support dynamic features” is tired, and also wildly inaccurate.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/a4a23f13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October  9, 2016 at 08:00:00pm</p></header><div class="content"><p>Charlie,<br></p><p>What you suggest defines how you would use it from your code, not how it<br>would be implemented in the language. If you look at my AO implementation<br>it does what you say:<br>https://github.com/j-h-a/AssociatedObjects/blob/develop/AssociatedObjects/AssociatedObjects.swift<br>i.e. has a protocol called &#39;Associable&#39; and you opt classes into it to get<br>the behaviour. This works and is usable, but the implementation leaves a<br>lot to be desired (it&#39;s not optimal and while the interface is clean the<br>implementation is not). Anyway - I was trying to steer the conversation<br>AWAY from AOs towards stored properties in extensions, since Robert Widmann<br>helped me to understand that AO was just a *means*, whereas stored<br>properties in extensions is the *end*.<br></p><p>In fact we don&#39;t need a solution to the problem of &quot;how to define/use<br>stored properties in extensions&quot; because the existing syntax for extensions<br>is perfectly fine. Currently you get an error if you try to define a stored<br>property in an extension, so no new syntax is needed, we just remove that<br>error and make it work.<br></p><p>Of course a runtime-check may be needed if there is doubt about whether a<br>dynamically linked module supported this feature - so this might invalidate<br>what I just said above, or it might still be possible if the runtime does<br>the check automatically when an extension is linked and puts a different<br>implementation in place for older modules.<br></p><p>I&#39;m just airing some thoughts at the moment to see what people think and<br>try to get some technical feedback on viability. So it&#39;s not all fully<br>thought through :D<br></p><p><br>On Sun, 9 Oct 2016 at 20:54 Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>wrote:<br></p><p>There is a 4th way.<br></p><p>Introduce an internal protocol Associatable, which would tell the compiler<br>to add an additional (hidden) field to the object which would include the<br>&quot;dictionary&quot; of key -&gt; value associated values. (It would be off-limits to<br>extensions, of course).<br></p><p>This way:<br></p><p>- it won&#39;t be a single dictionary containing all the associated values<br>- classes can opt-in to this<br>- the dictionary will be per-instance<br></p><p>This is a midway between the current implementation of ObjC associated<br>objects and of what someone has suggested to have an extra space for each<br>object for the AO...<br></p><p><br>On Oct 9, 2016, at 9:47 PM, Jay Abbott via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>I have been thinking further on this and in addition to my previous two<br>thoughts about implementation, I have had another idea...<br></p><p>3. If there is a bit spare in the object header somewhere (that is<br>currently always zero), this could be used to signify the presence of an<br>additional struct that immediately follows after the existing object data.<br>I *think* that this method would allow binary compatibility with older<br>modules. Instances that have this bit set would allow stored properties in<br>extensions. The struct at the end would have one member, a pointer to a<br>table of additional objects/values, stored properties defined in extensions<br>could be stored in here, using a hash derived from the<br>module/protocol/extension/property name (or something better if it exists).<br></p><p>The struct could be very simple as described above or more complex, with<br>additional features, for example a list of deinit hooks, dynamically added<br>methods, etc. The struct itself may also be dynamic in size/layout if such<br>complexity is warranted by size or extensibility concerns. Perhaps it<br>should start with some flags and its size (size would be fixed and only<br>increase with revisions so this would double as a &#39;version&#39; number).<br></p><p>If viable - this would be a much better way to implement this feature than<br>my previous two ideas. It doesn&#39;t require global lookups or additional<br>levels of indirection beyond accessing the dynamic data/feature itself.<br></p><p><br>On Mon, 3 Oct 2016 at 04:13 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br></p><p>Are stored properties in extensions already being discussed elsewhere? Is<br>this one of those deferred-but-not-indexed-anywhere subjects?<br></p><p>I wonder how stored properties could potentially be implemented, I can only<br>think of two ways:<br></p><p>1. An extra pointer per instance (with resulting ABI compatability<br>implications) to hold a collection of the stored items.<br></p><p>2. A global lookup for any instance where stored properties have been set.<br></p><p>I&#39;m not a language implementation expert, or familiar with the swift<br>implementation, so there may be other/better ways - I&#39;d like to know if<br>there are?<br></p><p>If not, and option 2 was employed, a little foresight might enable the<br>mechanism to be overloaded in the future for other dynamic features too. A<br>bit flag (I&#39;m hoping there&#39;s a spare bit in an existing flags field<br>somewhere?) could indicate whether any feature had caused the object to be<br>added to this lookup and deinit could check this bit and make sure the<br>object is removed, thus any stored properties are nilled. The lookup value<br>could be a struct with one member (extensionStoredProperties), and<br>additional members can be added in future for new features.<br></p><p>I get the impression from the associated objects discussion that perhaps<br>there are much better, more optimal, more ingenious, more unknown-by-me<br>ways of doing such things, so apologies if this whole idea is way-off the<br>mark :D<br></p><p>Jay<br></p><p>P.S. Note that stored properties in extensions could enable developers to<br>implement their own dynamic features in Swift.. so such desires could be<br>satisfied in the short term until they could be done properly in the<br>language.<br></p><p>On Sat, 1 Oct 2016 at 00:49 Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt; Is it possible to have best of (these completely different) both worlds?<br></p><p>Yes, of course it is.  Your email spends a lot of words trying to form a<br>false dichotomy.  Swift can definitely have both awesome dynamic features<br>while still having performance, predictability and safety.<br></p><p>&gt; Would it be possible in Swift to have facilities to generate objects<br>&gt; dynamically at runtime? and, if desirable, how can such be implemented?<br></p><p>Here’s an extant implementation that you can use today:<br>https://github.com/Zewo/Reflection<br></p><p>I’m sure it isn’t ideal, but it proves that it can be done.  When we have<br>bandwidth to reevaluate this area from first principles, I’m sure we can<br>make improvements on it.<br></p><p>I will grant you that Smalltalk is a beautiful language in its simplicity,<br>but for that simplicity it makes many tradeoffs that we’re not willing to<br>make.  We are willing to make the internal implementation of Swift complex<br>if that means that we get a beautiful model for programmers - one that<br>preserves the virtues of safety-by-default, predictability, performance,<br>and joy-to-develop-in.<br></p><p>The meme of “Swift can never (or will never) support dynamic features” is<br>tired, and also wildly inaccurate.<br></p><p>-Chris<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/c3cc22af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October 10, 2016 at 07:00:00am</p></header><div class="content"><p>No, I&#39;ve also suggested how it would be implemented. It would, as I&#39;ve described, require support from the compiler and runtime - the protocol conformance would tell the compiler to include an extra space in the instance layout for [AnyHashable : Any], which would get to be used by the runtime to store AO.<br></p><p>Note that the implementation noted below does not use any locks at all - unlike ObjC AO, it&#39;s not thread-safe.<br></p><p>With AO, the main bottleneck always was that everything was stored in one place - this way, each object would have its own AOs stored within itself. This way, instead of a single spin (!) lock (https://opensource.apple.com/source/objc4/objc4-680/runtime/objc-references.mm &lt;https://opensource.apple.com/source/objc4/objc4-680/runtime/objc-references.mm&gt;), you can use a lock pool - e.g. you have a dozen locks, depending on the hash of the object itself, you decide which lock to use - this lowers the contention a lot.<br></p><p>Try to run a few threads, read, write AO using the ObjC runtime - you&#39;ll see how painfully slow it is - this is not something that should be in Swift.<br></p><p><br>&gt; On Oct 9, 2016, at 10:15 PM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Charlie,<br>&gt; <br>&gt; What you suggest defines how you would use it from your code, not how it would be implemented in the language. If you look at my AO implementation it does what you say:<br>&gt; https://github.com/j-h-a/AssociatedObjects/blob/develop/AssociatedObjects/AssociatedObjects.swift &lt;https://github.com/j-h-a/AssociatedObjects/blob/develop/AssociatedObjects/AssociatedObjects.swift&gt;<br>&gt; i.e. has a protocol called &#39;Associable&#39; and you opt classes into it to get the behaviour. This works and is usable, but the implementation leaves a lot to be desired (it&#39;s not optimal and while the interface is clean the implementation is not). Anyway - I was trying to steer the conversation AWAY from AOs towards stored properties in extensions, since Robert Widmann helped me to understand that AO was just a *means*, whereas stored properties in extensions is the *end*.<br>&gt; <br>&gt; In fact we don&#39;t need a solution to the problem of &quot;how to define/use stored properties in extensions&quot; because the existing syntax for extensions is perfectly fine. Currently you get an error if you try to define a stored property in an extension, so no new syntax is needed, we just remove that error and make it work.<br>&gt; <br>&gt; Of course a runtime-check may be needed if there is doubt about whether a dynamically linked module supported this feature - so this might invalidate what I just said above, or it might still be possible if the runtime does the check automatically when an extension is linked and puts a different implementation in place for older modules.<br>&gt; <br>&gt; I&#39;m just airing some thoughts at the moment to see what people think and try to get some technical feedback on viability. So it&#39;s not all fully thought through :D<br>&gt; <br>&gt; <br>&gt; On Sun, 9 Oct 2016 at 20:54 Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt; There is a 4th way.<br>&gt; <br>&gt; Introduce an internal protocol Associatable, which would tell the compiler to add an additional (hidden) field to the object which would include the &quot;dictionary&quot; of key -&gt; value associated values. (It would be off-limits to extensions, of course).<br>&gt; <br>&gt; This way:<br>&gt; <br>&gt; - it won&#39;t be a single dictionary containing all the associated values<br>&gt; - classes can opt-in to this<br>&gt; - the dictionary will be per-instance<br>&gt; <br>&gt; This is a midway between the current implementation of ObjC associated objects and of what someone has suggested to have an extra space for each object for the AO...<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 9, 2016, at 9:47 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have been thinking further on this and in addition to my previous two thoughts about implementation, I have had another idea...<br>&gt;&gt; <br>&gt;&gt; 3. If there is a bit spare in the object header somewhere (that is currently always zero), this could be used to signify the presence of an additional struct that immediately follows after the existing object data. I *think* that this method would allow binary compatibility with older modules. Instances that have this bit set would allow stored properties in extensions. The struct at the end would have one member, a pointer to a table of additional objects/values, stored properties defined in extensions could be stored in here, using a hash derived from the module/protocol/extension/property name (or something better if it exists).<br>&gt;&gt; <br>&gt;&gt; The struct could be very simple as described above or more complex, with additional features, for example a list of deinit hooks, dynamically added methods, etc. The struct itself may also be dynamic in size/layout if such complexity is warranted by size or extensibility concerns. Perhaps it should start with some flags and its size (size would be fixed and only increase with revisions so this would double as a &#39;version&#39; number).<br>&gt;&gt; <br>&gt;&gt; If viable - this would be a much better way to implement this feature than my previous two ideas. It doesn&#39;t require global lookups or additional levels of indirection beyond accessing the dynamic data/feature itself.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, 3 Oct 2016 at 04:13 Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt; Are stored properties in extensions already being discussed elsewhere? Is this one of those deferred-but-not-indexed-anywhere subjects?<br>&gt;&gt; <br>&gt;&gt; I wonder how stored properties could potentially be implemented, I can only think of two ways:<br>&gt;&gt; <br>&gt;&gt; 1. An extra pointer per instance (with resulting ABI compatability implications) to hold a collection of the stored items.<br>&gt;&gt; <br>&gt;&gt; 2. A global lookup for any instance where stored properties have been set.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not a language implementation expert, or familiar with the swift implementation, so there may be other/better ways - I&#39;d like to know if there are?<br>&gt;&gt; <br>&gt;&gt; If not, and option 2 was employed, a little foresight might enable the mechanism to be overloaded in the future for other dynamic features too. A bit flag (I&#39;m hoping there&#39;s a spare bit in an existing flags field somewhere?) could indicate whether any feature had caused the object to be added to this lookup and deinit could check this bit and make sure the object is removed, thus any stored properties are nilled. The lookup value could be a struct with one member (extensionStoredProperties), and additional members can be added in future for new features.<br>&gt;&gt; <br>&gt;&gt; I get the impression from the associated objects discussion that perhaps there are much better, more optimal, more ingenious, more unknown-by-me ways of doing such things, so apologies if this whole idea is way-off the mark :D<br>&gt;&gt; <br>&gt;&gt; Jay<br>&gt;&gt; <br>&gt;&gt; P.S. Note that stored properties in extensions could enable developers to implement their own dynamic features in Swift.. so such desires could be satisfied in the short term until they could be done properly in the language.<br>&gt;&gt; <br>&gt;&gt; On Sat, 1 Oct 2016 at 00:49 Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; Is it possible to have best of (these completely different) both worlds?<br>&gt;&gt; <br>&gt;&gt; Yes, of course it is.  Your email spends a lot of words trying to form a false dichotomy.  Swift can definitely have both awesome dynamic features while still having performance, predictability and safety.<br>&gt;&gt; <br>&gt;&gt; &gt; Would it be possible in Swift to have facilities to generate objects<br>&gt;&gt; &gt; dynamically at runtime? and, if desirable, how can such be implemented?<br>&gt;&gt; <br>&gt;&gt; Here’s an extant implementation that you can use today:<br>&gt;&gt; https://github.com/Zewo/Reflection &lt;https://github.com/Zewo/Reflection&gt;<br>&gt;&gt; <br>&gt;&gt; I’m sure it isn’t ideal, but it proves that it can be done.  When we have bandwidth to reevaluate this area from first principles, I’m sure we can make improvements on it.<br>&gt;&gt; <br>&gt;&gt; I will grant you that Smalltalk is a beautiful language in its simplicity, but for that simplicity it makes many tradeoffs that we’re not willing to make.  We are willing to make the internal implementation of Swift complex if that means that we get a beautiful model for programmers - one that preserves the virtues of safety-by-default, predictability, performance, and joy-to-develop-in.<br>&gt;&gt; <br>&gt;&gt; The meme of “Swift can never (or will never) support dynamic features” is tired, and also wildly inaccurate.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/d3534a7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 10, 2016 at 11:00:00am</p></header><div class="content"><p>I understand Charlie. A few points though:<br>a) I&#39;m talking about pure Swift, this is absolutely nothing to do with<br>Objective-C;<br>b) If you read back on the AO thread you&#39;ll see that initially I was<br>thinking &quot;I want AO because it will give me stored properties in<br>extensions&quot; when really I should have been thinking &quot;I want stored<br>properties in extensions&quot;. So this discussion is no longer about AO at all,<br>hence the new subject.<br>c) Protocol conformance in an extension cannot tell the compiler to add<br>members to classes defined in other precompiled modules, as it is not<br>compiling them. When you do have the code and you are compiling it<br>yourself, you actually don&#39;t *need* stored properties in extensions because<br>you can work around it (although it would be nice), so the case where you<br>actually need it is where you want to extend someone else&#39;s precompiled<br>class.<br></p><p>On Mon, 10 Oct 2016 at 06:04 Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>wrote:<br></p><p>&gt; No, I&#39;ve also suggested how it would be implemented. It would, as I&#39;ve<br>&gt; described, require support from the compiler and runtime - the protocol<br>&gt; conformance would tell the compiler to include an extra space in the<br>&gt; instance layout for [AnyHashable : Any], which would get to be used by the<br>&gt; runtime to store AO.<br>&gt;<br>&gt; Note that the implementation noted below does not use any locks at all -<br>&gt; unlike ObjC AO, it&#39;s not thread-safe.<br>&gt;<br>&gt; With AO, the main bottleneck always was that everything was stored in one<br>&gt; place - this way, each object would have its own AOs stored within itself.<br>&gt; This way, instead of a single spin (!) lock (<br>&gt; https://opensource.apple.com/source/objc4/objc4-680/runtime/objc-references.mm),<br>&gt; you can use a lock pool - e.g. you have a dozen locks, depending on the<br>&gt; hash of the object itself, you decide which lock to use - this lowers the<br>&gt; contention a lot.<br>&gt;<br>&gt; Try to run a few threads, read, write AO using the ObjC runtime - you&#39;ll<br>&gt; see how painfully slow it is - this is not something that should be in<br>&gt; Swift.<br>&gt;<br>&gt;<br>&gt; On Oct 9, 2016, at 10:15 PM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;<br>&gt; Charlie,<br>&gt;<br>&gt; What you suggest defines how you would use it from your code, not how it<br>&gt; would be implemented in the language. If you look at my AO implementation<br>&gt; it does what you say:<br>&gt;<br>&gt; https://github.com/j-h-a/AssociatedObjects/blob/develop/AssociatedObjects/AssociatedObjects.swift<br>&gt; i.e. has a protocol called &#39;Associable&#39; and you opt classes into it to get<br>&gt; the behaviour. This works and is usable, but the implementation leaves a<br>&gt; lot to be desired (it&#39;s not optimal and while the interface is clean the<br>&gt; implementation is not). Anyway - I was trying to steer the conversation<br>&gt; AWAY from AOs towards stored properties in extensions, since Robert Widmann<br>&gt; helped me to understand that AO was just a *means*, whereas stored<br>&gt; properties in extensions is the *end*.<br>&gt;<br>&gt; In fact we don&#39;t need a solution to the problem of &quot;how to define/use<br>&gt; stored properties in extensions&quot; because the existing syntax for extensions<br>&gt; is perfectly fine. Currently you get an error if you try to define a stored<br>&gt; property in an extension, so no new syntax is needed, we just remove that<br>&gt; error and make it work.<br>&gt;<br>&gt; Of course a runtime-check may be needed if there is doubt about whether a<br>&gt; dynamically linked module supported this feature - so this might invalidate<br>&gt; what I just said above, or it might still be possible if the runtime does<br>&gt; the check automatically when an extension is linked and puts a different<br>&gt; implementation in place for older modules.<br>&gt;<br>&gt; I&#39;m just airing some thoughts at the moment to see what people think and<br>&gt; try to get some technical feedback on viability. So it&#39;s not all fully<br>&gt; thought through :D<br>&gt;<br>&gt;<br>&gt; On Sun, 9 Oct 2016 at 20:54 Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>&gt; wrote:<br>&gt;<br>&gt; There is a 4th way.<br>&gt;<br>&gt; Introduce an internal protocol Associatable, which would tell the compiler<br>&gt; to add an additional (hidden) field to the object which would include the<br>&gt; &quot;dictionary&quot; of key -&gt; value associated values. (It would be off-limits to<br>&gt; extensions, of course).<br>&gt;<br>&gt; This way:<br>&gt;<br>&gt; - it won&#39;t be a single dictionary containing all the associated values<br>&gt; - classes can opt-in to this<br>&gt; - the dictionary will be per-instance<br>&gt;<br>&gt; This is a midway between the current implementation of ObjC associated<br>&gt; objects and of what someone has suggested to have an extra space for each<br>&gt; object for the AO...<br>&gt;<br>&gt;<br>&gt; On Oct 9, 2016, at 9:47 PM, Jay Abbott via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have been thinking further on this and in addition to my previous two<br>&gt; thoughts about implementation, I have had another idea...<br>&gt;<br>&gt; 3. If there is a bit spare in the object header somewhere (that is<br>&gt; currently always zero), this could be used to signify the presence of an<br>&gt; additional struct that immediately follows after the existing object data.<br>&gt; I *think* that this method would allow binary compatibility with older<br>&gt; modules. Instances that have this bit set would allow stored properties in<br>&gt; extensions. The struct at the end would have one member, a pointer to a<br>&gt; table of additional objects/values, stored properties defined in extensions<br>&gt; could be stored in here, using a hash derived from the<br>&gt; module/protocol/extension/property name (or something better if it exists).<br>&gt;<br>&gt; The struct could be very simple as described above or more complex, with<br>&gt; additional features, for example a list of deinit hooks, dynamically added<br>&gt; methods, etc. The struct itself may also be dynamic in size/layout if such<br>&gt; complexity is warranted by size or extensibility concerns. Perhaps it<br>&gt; should start with some flags and its size (size would be fixed and only<br>&gt; increase with revisions so this would double as a &#39;version&#39; number).<br>&gt;<br>&gt; If viable - this would be a much better way to implement this feature than<br>&gt; my previous two ideas. It doesn&#39;t require global lookups or additional<br>&gt; levels of indirection beyond accessing the dynamic data/feature itself.<br>&gt;<br>&gt;<br>&gt; On Mon, 3 Oct 2016 at 04:13 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;<br>&gt; Are stored properties in extensions already being discussed elsewhere? Is<br>&gt; this one of those deferred-but-not-indexed-anywhere subjects?<br>&gt;<br>&gt; I wonder how stored properties could potentially be implemented, I can<br>&gt; only think of two ways:<br>&gt;<br>&gt; 1. An extra pointer per instance (with resulting ABI compatability<br>&gt; implications) to hold a collection of the stored items.<br>&gt;<br>&gt; 2. A global lookup for any instance where stored properties have been set.<br>&gt;<br>&gt; I&#39;m not a language implementation expert, or familiar with the swift<br>&gt; implementation, so there may be other/better ways - I&#39;d like to know if<br>&gt; there are?<br>&gt;<br>&gt; If not, and option 2 was employed, a little foresight might enable the<br>&gt; mechanism to be overloaded in the future for other dynamic features too. A<br>&gt; bit flag (I&#39;m hoping there&#39;s a spare bit in an existing flags field<br>&gt; somewhere?) could indicate whether any feature had caused the object to be<br>&gt; added to this lookup and deinit could check this bit and make sure the<br>&gt; object is removed, thus any stored properties are nilled. The lookup value<br>&gt; could be a struct with one member (extensionStoredProperties), and<br>&gt; additional members can be added in future for new features.<br>&gt;<br>&gt; I get the impression from the associated objects discussion that perhaps<br>&gt; there are much better, more optimal, more ingenious, more unknown-by-me<br>&gt; ways of doing such things, so apologies if this whole idea is way-off the<br>&gt; mark :D<br>&gt;<br>&gt; Jay<br>&gt;<br>&gt; P.S. Note that stored properties in extensions could enable developers to<br>&gt; implement their own dynamic features in Swift.. so such desires could be<br>&gt; satisfied in the short term until they could be done properly in the<br>&gt; language.<br>&gt;<br>&gt; On Sat, 1 Oct 2016 at 00:49 Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Is it possible to have best of (these completely different) both worlds?<br>&gt;<br>&gt; Yes, of course it is.  Your email spends a lot of words trying to form a<br>&gt; false dichotomy.  Swift can definitely have both awesome dynamic features<br>&gt; while still having performance, predictability and safety.<br>&gt;<br>&gt; &gt; Would it be possible in Swift to have facilities to generate objects<br>&gt; &gt; dynamically at runtime? and, if desirable, how can such be implemented?<br>&gt;<br>&gt; Here’s an extant implementation that you can use today:<br>&gt; https://github.com/Zewo/Reflection<br>&gt;<br>&gt; I’m sure it isn’t ideal, but it proves that it can be done.  When we have<br>&gt; bandwidth to reevaluate this area from first principles, I’m sure we can<br>&gt; make improvements on it.<br>&gt;<br>&gt; I will grant you that Smalltalk is a beautiful language in its simplicity,<br>&gt; but for that simplicity it makes many tradeoffs that we’re not willing to<br>&gt; make.  We are willing to make the internal implementation of Swift complex<br>&gt; if that means that we get a beautiful model for programmers - one that<br>&gt; preserves the virtues of safety-by-default, predictability, performance,<br>&gt; and joy-to-develop-in.<br>&gt;<br>&gt; The meme of “Swift can never (or will never) support dynamic features” is<br>&gt; tired, and also wildly inaccurate.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/2cc17fc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October 10, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 1:13 PM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; I understand Charlie. A few points though:<br>&gt; a) I&#39;m talking about pure Swift, this is absolutely nothing to do with Objective-C;<br></p><p>Sure, but in either case you will need to somehow solve locking of the structure holding the additional values.<br></p><p>&gt; b) If you read back on the AO thread you&#39;ll see that initially I was thinking &quot;I want AO because it will give me stored properties in extensions&quot; when really I should have been thinking &quot;I want stored properties in extensions&quot;. So this discussion is no longer about AO at all, hence the new subject.<br></p><p>Agreed, though the actual backing of the values won&#39;t be a lot different from the AO - it can be called differently, but the fact that it is likely to be stored in a dictionary brings resemblence to AO - and what I&#39;ve mentioned are a few downsides to how AO are implemented at this point.<br></p><p>&gt; c) Protocol conformance in an extension cannot tell the compiler to add members to classes defined in other precompiled modules, as it is not compiling them. When you do have the code and you are compiling it yourself, you actually don&#39;t *need* stored properties in extensions because you can work around it (although it would be nice), so the case where you actually need it is where you want to extend someone else&#39;s precompiled class.<br></p><p>This is why I mentioned that this &quot;magic protocol&quot; would be off limits to extensions. Perhaps the choice of a protocol to this was incorrect - better way would be to use an annotation like @allows_extension_properties or similar.<br></p><p>I bet you that in any case, there will be a lot of people on this list that will want explicit opt-in, or at least a way to opt-out.<br></p><p>&gt; <br>&gt; On Mon, 10 Oct 2016 at 06:04 Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt; No, I&#39;ve also suggested how it would be implemented. It would, as I&#39;ve described, require support from the compiler and runtime - the protocol conformance would tell the compiler to include an extra space in the instance layout for [AnyHashable : Any], which would get to be used by the runtime to store AO.<br>&gt; <br>&gt; Note that the implementation noted below does not use any locks at all - unlike ObjC AO, it&#39;s not thread-safe.<br>&gt; <br>&gt; With AO, the main bottleneck always was that everything was stored in one place - this way, each object would have its own AOs stored within itself. This way, instead of a single spin (!) lock (https://opensource.apple.com/source/objc4/objc4-680/runtime/objc-references.mm &lt;https://opensource.apple.com/source/objc4/objc4-680/runtime/objc-references.mm&gt;), you can use a lock pool - e.g. you have a dozen locks, depending on the hash of the object itself, you decide which lock to use - this lowers the contention a lot.<br>&gt; <br>&gt; Try to run a few threads, read, write AO using the ObjC runtime - you&#39;ll see how painfully slow it is - this is not something that should be in Swift.<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 9, 2016, at 10:15 PM, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Charlie,<br>&gt;&gt; <br>&gt;&gt; What you suggest defines how you would use it from your code, not how it would be implemented in the language. If you look at my AO implementation it does what you say:<br>&gt;&gt; https://github.com/j-h-a/AssociatedObjects/blob/develop/AssociatedObjects/AssociatedObjects.swift &lt;https://github.com/j-h-a/AssociatedObjects/blob/develop/AssociatedObjects/AssociatedObjects.swift&gt;<br>&gt;&gt; i.e. has a protocol called &#39;Associable&#39; and you opt classes into it to get the behaviour. This works and is usable, but the implementation leaves a lot to be desired (it&#39;s not optimal and while the interface is clean the implementation is not). Anyway - I was trying to steer the conversation AWAY from AOs towards stored properties in extensions, since Robert Widmann helped me to understand that AO was just a *means*, whereas stored properties in extensions is the *end*.<br>&gt;&gt; <br>&gt;&gt; In fact we don&#39;t need a solution to the problem of &quot;how to define/use stored properties in extensions&quot; because the existing syntax for extensions is perfectly fine. Currently you get an error if you try to define a stored property in an extension, so no new syntax is needed, we just remove that error and make it work.<br>&gt;&gt; <br>&gt;&gt; Of course a runtime-check may be needed if there is doubt about whether a dynamically linked module supported this feature - so this might invalidate what I just said above, or it might still be possible if the runtime does the check automatically when an extension is linked and puts a different implementation in place for older modules.<br>&gt;&gt; <br>&gt;&gt; I&#39;m just airing some thoughts at the moment to see what people think and try to get some technical feedback on viability. So it&#39;s not all fully thought through :D<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, 9 Oct 2016 at 20:54 Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt; There is a 4th way.<br>&gt;&gt; <br>&gt;&gt; Introduce an internal protocol Associatable, which would tell the compiler to add an additional (hidden) field to the object which would include the &quot;dictionary&quot; of key -&gt; value associated values. (It would be off-limits to extensions, of course).<br>&gt;&gt; <br>&gt;&gt; This way:<br>&gt;&gt; <br>&gt;&gt; - it won&#39;t be a single dictionary containing all the associated values<br>&gt;&gt; - classes can opt-in to this<br>&gt;&gt; - the dictionary will be per-instance<br>&gt;&gt; <br>&gt;&gt; This is a midway between the current implementation of ObjC associated objects and of what someone has suggested to have an extra space for each object for the AO...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 9, 2016, at 9:47 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have been thinking further on this and in addition to my previous two thoughts about implementation, I have had another idea...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. If there is a bit spare in the object header somewhere (that is currently always zero), this could be used to signify the presence of an additional struct that immediately follows after the existing object data. I *think* that this method would allow binary compatibility with older modules. Instances that have this bit set would allow stored properties in extensions. The struct at the end would have one member, a pointer to a table of additional objects/values, stored properties defined in extensions could be stored in here, using a hash derived from the module/protocol/extension/property name (or something better if it exists).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The struct could be very simple as described above or more complex, with additional features, for example a list of deinit hooks, dynamically added methods, etc. The struct itself may also be dynamic in size/layout if such complexity is warranted by size or extensibility concerns. Perhaps it should start with some flags and its size (size would be fixed and only increase with revisions so this would double as a &#39;version&#39; number).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If viable - this would be a much better way to implement this feature than my previous two ideas. It doesn&#39;t require global lookups or additional levels of indirection beyond accessing the dynamic data/feature itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, 3 Oct 2016 at 04:13 Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt;&gt; Are stored properties in extensions already being discussed elsewhere? Is this one of those deferred-but-not-indexed-anywhere subjects?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder how stored properties could potentially be implemented, I can only think of two ways:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. An extra pointer per instance (with resulting ABI compatability implications) to hold a collection of the stored items.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. A global lookup for any instance where stored properties have been set.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not a language implementation expert, or familiar with the swift implementation, so there may be other/better ways - I&#39;d like to know if there are?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If not, and option 2 was employed, a little foresight might enable the mechanism to be overloaded in the future for other dynamic features too. A bit flag (I&#39;m hoping there&#39;s a spare bit in an existing flags field somewhere?) could indicate whether any feature had caused the object to be added to this lookup and deinit could check this bit and make sure the object is removed, thus any stored properties are nilled. The lookup value could be a struct with one member (extensionStoredProperties), and additional members can be added in future for new features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I get the impression from the associated objects discussion that perhaps there are much better, more optimal, more ingenious, more unknown-by-me ways of doing such things, so apologies if this whole idea is way-off the mark :D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jay<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S. Note that stored properties in extensions could enable developers to implement their own dynamic features in Swift.. so such desires could be satisfied in the short term until they could be done properly in the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, 1 Oct 2016 at 00:49 Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; Is it possible to have best of (these completely different) both worlds?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, of course it is.  Your email spends a lot of words trying to form a false dichotomy.  Swift can definitely have both awesome dynamic features while still having performance, predictability and safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Would it be possible in Swift to have facilities to generate objects<br>&gt;&gt;&gt; &gt; dynamically at runtime? and, if desirable, how can such be implemented?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s an extant implementation that you can use today:<br>&gt;&gt;&gt; https://github.com/Zewo/Reflection &lt;https://github.com/Zewo/Reflection&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m sure it isn’t ideal, but it proves that it can be done.  When we have bandwidth to reevaluate this area from first principles, I’m sure we can make improvements on it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will grant you that Smalltalk is a beautiful language in its simplicity, but for that simplicity it makes many tradeoffs that we’re not willing to make.  We are willing to make the internal implementation of Swift complex if that means that we get a beautiful model for programmers - one that preserves the virtues of safety-by-default, predictability, performance, and joy-to-develop-in.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The meme of “Swift can never (or will never) support dynamic features” is tired, and also wildly inaccurate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/cbf5a285/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October  9, 2016 at 03:00:00pm</p></header><div class="content"><p>How about a 5th way?<br></p><p>5. Let extensions introduce stored properties, but only in the same module as the type’s definition. Then, the compiler can just take any extensions into consideration when it’s determining the size of the type, just as if the properties had been declared in the type. Declaring stored properties on an extension outside of the type’s module results in a compiler error, exactly as today. This would, without any performance drawbacks, solve one of the big problems that people are hoping to solve via stored properties in extensions—the ability to organize members by protocol conformance. So, instead of this:<br></p><p>protocol P {<br>	var foo: String { get }<br>	func bar()<br>}<br></p><p>protocol Q {<br>	var baz: Int { get }<br>	func qux()<br>}<br></p><p>class C: P {<br>	var foo: String // &lt;- what is this doing here?<br>	var baz: Int // &lt;- ditto<br>}<br></p><p>extension C: P {<br>	func bar() {}<br>}<br></p><p>extension C: Q {<br>	func qux() {}<br>}<br></p><p>we could simply:<br></p><p>protocol P {<br>	var foo: String { get }<br>	func bar()<br>}<br></p><p>class C: P {}<br></p><p>extension C: P {<br>	var foo: String<br>	func bar() {}<br>}<br></p><p>extension C: Q {<br>	var baz: Int<br>	func qux() {}<br>}<br></p><p>So much cleaner, and since the compiler will simply turn the latter into the former at compile time, works without sacrificing anything in terms of performance.<br></p><p>Also, if we really decide that we need to have stored properties on *all* extensions, this idea still leaves the door open for using one of the methods discussed in this thread, in the case where the extension is in a different module from the original type.<br></p><p>Charles<br></p><p>&gt; On Oct 9, 2016, at 2:53 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is a 4th way.<br>&gt; <br>&gt; Introduce an internal protocol Associatable, which would tell the compiler to add an additional (hidden) field to the object which would include the &quot;dictionary&quot; of key -&gt; value associated values. (It would be off-limits to extensions, of course).<br>&gt; <br>&gt; This way:<br>&gt; <br>&gt; - it won&#39;t be a single dictionary containing all the associated values<br>&gt; - classes can opt-in to this<br>&gt; - the dictionary will be per-instance<br>&gt; <br>&gt; This is a midway between the current implementation of ObjC associated objects and of what someone has suggested to have an extra space for each object for the AO...<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 9, 2016, at 9:47 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have been thinking further on this and in addition to my previous two thoughts about implementation, I have had another idea...<br>&gt;&gt; <br>&gt;&gt; 3. If there is a bit spare in the object header somewhere (that is currently always zero), this could be used to signify the presence of an additional struct that immediately follows after the existing object data. I *think* that this method would allow binary compatibility with older modules. Instances that have this bit set would allow stored properties in extensions. The struct at the end would have one member, a pointer to a table of additional objects/values, stored properties defined in extensions could be stored in here, using a hash derived from the module/protocol/extension/property name (or something better if it exists).<br>&gt;&gt; <br>&gt;&gt; The struct could be very simple as described above or more complex, with additional features, for example a list of deinit hooks, dynamically added methods, etc. The struct itself may also be dynamic in size/layout if such complexity is warranted by size or extensibility concerns. Perhaps it should start with some flags and its size (size would be fixed and only increase with revisions so this would double as a &#39;version&#39; number).<br>&gt;&gt; <br>&gt;&gt; If viable - this would be a much better way to implement this feature than my previous two ideas. It doesn&#39;t require global lookups or additional levels of indirection beyond accessing the dynamic data/feature itself.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, 3 Oct 2016 at 04:13 Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt; Are stored properties in extensions already being discussed elsewhere? Is this one of those deferred-but-not-indexed-anywhere subjects?<br>&gt;&gt; <br>&gt;&gt; I wonder how stored properties could potentially be implemented, I can only think of two ways:<br>&gt;&gt; <br>&gt;&gt; 1. An extra pointer per instance (with resulting ABI compatability implications) to hold a collection of the stored items.<br>&gt;&gt; <br>&gt;&gt; 2. A global lookup for any instance where stored properties have been set.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not a language implementation expert, or familiar with the swift implementation, so there may be other/better ways - I&#39;d like to know if there are?<br>&gt;&gt; <br>&gt;&gt; If not, and option 2 was employed, a little foresight might enable the mechanism to be overloaded in the future for other dynamic features too. A bit flag (I&#39;m hoping there&#39;s a spare bit in an existing flags field somewhere?) could indicate whether any feature had caused the object to be added to this lookup and deinit could check this bit and make sure the object is removed, thus any stored properties are nilled. The lookup value could be a struct with one member (extensionStoredProperties), and additional members can be added in future for new features.<br>&gt;&gt; <br>&gt;&gt; I get the impression from the associated objects discussion that perhaps there are much better, more optimal, more ingenious, more unknown-by-me ways of doing such things, so apologies if this whole idea is way-off the mark :D<br>&gt;&gt; <br>&gt;&gt; Jay<br>&gt;&gt; <br>&gt;&gt; P.S. Note that stored properties in extensions could enable developers to implement their own dynamic features in Swift.. so such desires could be satisfied in the short term until they could be done properly in the language.<br>&gt;&gt; <br>&gt;&gt; On Sat, 1 Oct 2016 at 00:49 Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; Is it possible to have best of (these completely different) both worlds?<br>&gt;&gt; <br>&gt;&gt; Yes, of course it is.  Your email spends a lot of words trying to form a false dichotomy.  Swift can definitely have both awesome dynamic features while still having performance, predictability and safety.<br>&gt;&gt; <br>&gt;&gt; &gt; Would it be possible in Swift to have facilities to generate objects<br>&gt;&gt; &gt; dynamically at runtime? and, if desirable, how can such be implemented?<br>&gt;&gt; <br>&gt;&gt; Here’s an extant implementation that you can use today:<br>&gt;&gt; https://github.com/Zewo/Reflection &lt;https://github.com/Zewo/Reflection&gt;<br>&gt;&gt; <br>&gt;&gt; I’m sure it isn’t ideal, but it proves that it can be done.  When we have bandwidth to reevaluate this area from first principles, I’m sure we can make improvements on it.<br>&gt;&gt; <br>&gt;&gt; I will grant you that Smalltalk is a beautiful language in its simplicity, but for that simplicity it makes many tradeoffs that we’re not willing to make.  We are willing to make the internal implementation of Swift complex if that means that we get a beautiful model for programmers - one that preserves the virtues of safety-by-default, predictability, performance, and joy-to-develop-in.<br>&gt;&gt; <br>&gt;&gt; The meme of “Swift can never (or will never) support dynamic features” is tired, and also wildly inaccurate.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/b16224d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October  9, 2016 at 03:00:00pm</p></header><div class="content"><p>*Replace both instances of “class C: P” with just “class C” since the conformance comes in the extension. That’s what I get for writing this quickly.<br></p><p>Charles<br></p><p>&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; protocol P {<br>&gt; 	var foo: String { get }<br>&gt; 	func bar()<br>&gt; }<br>&gt; <br>&gt; protocol Q {<br>&gt; 	var baz: Int { get }<br>&gt; 	func qux()<br>&gt; }<br>&gt; <br>&gt; class C: P {<br>&gt; 	var foo: String // &lt;- what is this doing here?<br>&gt; 	var baz: Int // &lt;- ditto<br>&gt; }<br>&gt; <br>&gt; extension C: P {<br>&gt; 	func bar() {}<br>&gt; }<br>&gt; <br>&gt; extension C: Q {<br>&gt; 	func qux() {}<br>&gt; }<br>&gt; <br>&gt; we could simply:<br>&gt; <br>&gt; protocol P {<br>&gt; 	var foo: String { get }<br>&gt; 	func bar()<br>&gt; }<br>&gt; <br>&gt; class C: P {}<br>&gt; <br>&gt; extension C: P {<br>&gt; 	var foo: String<br>&gt; 	func bar() {}<br>&gt; }<br>&gt; <br>&gt; extension C: Q {<br>&gt; 	var baz: Int<br>&gt; 	func qux() {}<br>&gt; }<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/8278fdde/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October  9, 2016 at 09:00:00pm</p></header><div class="content"><p>Charles,<br></p><p>That would be good. It is a nicer way to write what is already possible to<br>achieve, but it&#39;s not a way to &#39;implement&#39; stored properties in extensions.<br></p><p>On Sun, 9 Oct 2016 at 21:45 Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br></p><p>&gt; *Replace both instances of “class C: P” with just “class C” since the<br>&gt; conformance comes in the extension. That’s what I get for writing this<br>&gt; quickly.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; protocol P {<br>&gt; var foo: String { get }<br>&gt; func bar()<br>&gt; }<br>&gt;<br>&gt; protocol Q {<br>&gt; var baz: Int { get }<br>&gt; func qux()<br>&gt; }<br>&gt;<br>&gt; class C: P {<br>&gt; var foo: String // &lt;- what is this doing here?<br>&gt; var baz: Int // &lt;- ditto<br>&gt; }<br>&gt;<br>&gt; extension C: P {<br>&gt; func bar() {}<br>&gt; }<br>&gt;<br>&gt; extension C: Q {<br>&gt; func qux() {}<br>&gt; }<br>&gt;<br>&gt; we could simply:<br>&gt;<br>&gt; protocol P {<br>&gt; var foo: String { get }<br>&gt; func bar()<br>&gt; }<br>&gt;<br>&gt; class C: P {}<br>&gt;<br>&gt; extension C: P {<br>&gt; var foo: String<br>&gt; func bar() {}<br>&gt; }<br>&gt;<br>&gt; extension C: Q {<br>&gt; var baz: Int<br>&gt; func qux() {}<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/038ba2da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Right. The question is whether we *need* to add stored properties out-of-module, and what the use case for that is. To me it seems that adding them in-module is by far the more common use case, for the purposes of implementing protocols.<br></p><p>At any rate, the rewrite option would be a great addition to Swift regardless of what our answer to the first question is.<br></p><p>Charles<br></p><p>&gt; On Oct 9, 2016, at 4:32 PM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Charles,<br>&gt; <br>&gt; That would be good. It is a nicer way to write what is already possible to achieve, but it&#39;s not a way to &#39;implement&#39; stored properties in extensions.<br>&gt; <br>&gt; On Sun, 9 Oct 2016 at 21:45 Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt; *Replace both instances of “class C: P” with just “class C” since the conformance comes in the extension. That’s what I get for writing this quickly.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; 	var foo: String { get }<br>&gt;&gt; 	func bar()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Q {<br>&gt;&gt; 	var baz: Int { get }<br>&gt;&gt; 	func qux()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: P {<br>&gt;&gt; 	var foo: String // &lt;- what is this doing here?<br>&gt;&gt; 	var baz: Int // &lt;- ditto<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension C: P {<br>&gt;&gt; 	func bar() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension C: Q {<br>&gt;&gt; 	func qux() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; we could simply:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; 	var foo: String { get }<br>&gt;&gt; 	func bar()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: P {}<br>&gt;&gt; <br>&gt;&gt; extension C: P {<br>&gt;&gt; 	var foo: String<br>&gt;&gt; 	func bar() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension C: Q {<br>&gt;&gt; 	var baz: Int<br>&gt;&gt; 	func qux() {}<br>&gt;&gt; }<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/e289b5a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October 10, 2016 at 09:00:00pm</p></header><div class="content"><p>Yes, there are valid use cases. <br></p><p>For example, in case of many UI elements, you do not have control over their instantiation and need to associate a &quot;help description&quot; with them as an example. Which can be done by an additional property helpDescription added to NSView/UIView.<br></p><p>Another example that I&#39;ve used is with CoreData, where you can store additional information on the MOC - NSManagedObjectContext is strongly discouraged from being subclassed. Example of the additional information is a synchronization manager assigned to the MOC.<br></p><p>And since in Swift, classes can be final, there may not be a way to subclass the class to add your properties instead.<br></p><p>IMHO, it is a valid request to be able to add additional stored properties via extensions.<br></p><p>&gt; On Oct 10, 2016, at 9:15 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; Right. The question is whether we *need* to add stored properties out-of-module, and what the use case for that is. To me it seems that adding them in-module is by far the more common use case, for the purposes of implementing protocols.<br>&gt; <br>&gt; At any rate, the rewrite option would be a great addition to Swift regardless of what our answer to the first question is.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Oct 9, 2016, at 4:32 PM, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Charles,<br>&gt;&gt; <br>&gt;&gt; That would be good. It is a nicer way to write what is already possible to achieve, but it&#39;s not a way to &#39;implement&#39; stored properties in extensions.<br>&gt;&gt; <br>&gt;&gt; On Sun, 9 Oct 2016 at 21:45 Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; *Replace both instances of “class C: P” with just “class C” since the conformance comes in the extension. That’s what I get for writing this quickly.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt; 	var foo: String { get }<br>&gt;&gt;&gt; 	func bar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt; 	var baz: Int { get }<br>&gt;&gt;&gt; 	func qux()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt; 	var foo: String // &lt;- what is this doing here?<br>&gt;&gt;&gt; 	var baz: Int // &lt;- ditto<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension C: P {<br>&gt;&gt;&gt; 	func bar() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension C: Q {<br>&gt;&gt;&gt; 	func qux() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; we could simply:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt; 	var foo: String { get }<br>&gt;&gt;&gt; 	func bar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C: P {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension C: P {<br>&gt;&gt;&gt; 	var foo: String<br>&gt;&gt;&gt; 	func bar() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension C: Q {<br>&gt;&gt;&gt; 	var baz: Int<br>&gt;&gt;&gt; 	func qux() {}<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/4e140594/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 10 Oct 2016, at 21:15, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Right. The question is whether we *need* to add stored properties out-of-module, and what the use case for that is. To me it seems that adding them in-module is by far the more common use case, for the purposes of implementing protocols.<br>&gt; <br>&gt; At any rate, the rewrite option would be a great addition to Swift regardless of what our answer to the first question is.<br>&gt; <br>&gt; Charles<br></p><p>I actually think out-of-module is the more common and important case. If you’re using a types from an external framework, it’s strange that you can retroactively add functionality but not additional data. That limitation, AFAICT, is purely due to implementation. Some well-constructed frameworks will allow you to add stored data to the types being used by subclassing. Not all are so well constructed, and as we have more and more value-types subclassing is not going to be a solution.<br></p><p>You can add stored properties to objects in Python, which is one of the really great things about it. If you need to add a stored property to track some additional state you layer on top of a framework’s components, it’s staggering how easy it is - you don’t even need to define any new types.<br></p><p>I personally think it’s important for Swift as a scripting language to have this ability - for value-types as well as classes, by default. We could optimise it away completely for types which aren’t public, and you should be able to explicitly declare a type non-extendable (similar to declaring it non-subclassable with ‘final’) to opt-out. I’m sure it will never happen, but there you go.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 11, 2016 at 10:00:00pm</p></header><div class="content"><p>I agree Karl, especially the bit about the difficulty of implementation<br>being the limiting thing here.<br></p><p>I think the language devs must have some idea how this will work, but don&#39;t<br>seem to want to share/discuss it at the moment. I was hoping for some<br>feedback about my implementation ideas - whether they are along the right<br>lines, or way off, or not necessary (because the implementation strategy is<br>already known). Perhaps this the wrong list for that kind of discussion?<br></p><p>Anyway, I was thinking some more and I had another idea about<br>implementation. This could be very useful for maintaining binary<br>compatability in other areas too.<br></p><p>Implementation idea No. 4:<br></p><p>The basic concept is that the dynamic linker would fixup the offsets as<br>well as relocating the addersses, allowing the size of objects (and maybe<br>structs?) to change at link-time. The process might be something like this:<br></p><p>* References to members defined in extensions would compile to have an<br>offset symbol instead of a value - so they can be fixed up later<br>* The linker would scan all the shared objects that are referenced (and<br>thus might get linked)<br>* Build up a list of Stored Properties In ExtensionS (SPIES, muhahaha) for<br>each class.<br>* Append the extra fields (increase the size the class), decide where each<br>member goes in the extended layout and fixup the offsets<br>* Carry on with normal relocation<br></p><p>There are quite a few assumptions in the above, and probably quite a few<br>misunderstandings about how things work on my part too (I&#39;m not an expert<br>at this), however I think it should work in principle. Some questions about<br>my assumptions: Can linker know in advance all the potential modules that<br>could be linked, or is this done more lazily and it only knows about what<br>it&#39;s linking right now? Is it ok for the size to change - I don&#39;t know if<br>it&#39;s a static sizeof() or if it could be (or already is) stored in the isa?<br></p><p>Would love to hear back from anyone who is familiar with the code if this<br>sounds viable or not. I&#39;d love to go digging in there myself (I&#39;ve tried a<br>few times but got lost) but I don&#39;t have time at the moment.<br></p><p><br>On Tue, 11 Oct 2016 at 08:19 Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 10 Oct 2016, at 21:15, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Right. The question is whether we *need* to add stored properties<br>&gt; out-of-module, and what the use case for that is. To me it seems that<br>&gt; adding them in-module is by far the more common use case, for the purposes<br>&gt; of implementing protocols.<br>&gt; &gt;<br>&gt; &gt; At any rate, the rewrite option would be a great addition to Swift<br>&gt; regardless of what our answer to the first question is.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt;<br>&gt; I actually think out-of-module is the more common and important case. If<br>&gt; you’re using a types from an external framework, it’s strange that you can<br>&gt; retroactively add functionality but not additional data. That limitation,<br>&gt; AFAICT, is purely due to implementation. Some well-constructed frameworks<br>&gt; will allow you to add stored data to the types being used by subclassing.<br>&gt; Not all are so well constructed, and as we have more and more value-types<br>&gt; subclassing is not going to be a solution.<br>&gt;<br>&gt; You can add stored properties to objects in Python, which is one of the<br>&gt; really great things about it. If you need to add a stored property to track<br>&gt; some additional state you layer on top of a framework’s components, it’s<br>&gt; staggering how easy it is - you don’t even need to define any new types.<br>&gt;<br>&gt; I personally think it’s important for Swift as a scripting language to<br>&gt; have this ability - for value-types as well as classes, by default. We<br>&gt; could optimise it away completely for types which aren’t public, and you<br>&gt; should be able to explicitly declare a type non-extendable (similar to<br>&gt; declaring it non-subclassable with ‘final’) to opt-out. I’m sure it will<br>&gt; never happen, but there you go.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/7b70dca2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>stored properties in extensions</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>October 12, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; I think the language devs must have some idea how this will work, but<br> &gt; don&#39;t seem to want to share/discuss it at the moment. I was hoping for<br> &gt; some feedback about my implementation ideas - whether they are along the<br> &gt; right lines, or way off, or not necessary (because the implementation<br> &gt; strategy is already known). Perhaps this the wrong list for that kind of<br> &gt; discussion?<br></p><p>For what it&#39;s worth, Greg Parker (Cc&#39;ed) started a discussion back in <br>March that I think is relevant here: <br>https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160314/001424.html<br></p><p>Here&#39;s the relevant part:<br></p><p>&quot;I am considering a new representation for Swift refcounts and other <br>per-object data. This is an outline of the scheme. Comments and <br>suggestions welcome.<br></p><p>Today, each object stores 64-bits of refcounts and flags after the isa <br>field.<br></p><p>In this new system, each object would store a pointer-size field after <br>the isa field. This field would have two cases: it could store refcounts <br>and flags, or it could store a pointer to a side allocation that would <br>store refcounts and flags and additional per-object data.<br></p><p>Advantages:<br>…<br>* Allows inexpensive per-object storage for future features like <br>associated references or class extensions with instance variables.<br>…&quot;<br></p><p>I don&#39;t know the current status of this idea (implemented? planned? <br>abandoned?). Also, it&#39;s worth noting that this would only apply to <br>classes, not value types.<br></p><p>Ole<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Wow, that&#39;s a very interesting post. Sounds a lot simpler to implement than<br>my idea about fixing up offsets in the linker and preserves binary<br>compatability just the same.<br></p><p>I got some complaints when I first started talking about this that the<br>runtime would have to track extra pointers and performance would be<br>affected because of additional levels of indirection, which I didn&#39;t fully<br>understand because it seems fairly trivial to me. Perhaps this twin-purpose<br>refcount/side-table pointer also suffers the same concerns?<br></p><p>On Wed, 12 Oct 2016 at 00:21 Ole Begemann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p> &gt; I think the language devs must have some idea how this will work, but<br></p><p> &gt; don&#39;t seem to want to share/discuss it at the moment. I was hoping for<br></p><p> &gt; some feedback about my implementation ideas - whether they are along the<br></p><p> &gt; right lines, or way off, or not necessary (because the implementation<br></p><p> &gt; strategy is already known). Perhaps this the wrong list for that kind of<br></p><p> &gt; discussion?<br></p><p><br></p><p>For what it&#39;s worth, Greg Parker (Cc&#39;ed) started a discussion back in<br></p><p>March that I think is relevant here:<br></p><p>https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160314/001424.html<br></p><p><br></p><p>Here&#39;s the relevant part:<br></p><p><br></p><p>&quot;I am considering a new representation for Swift refcounts and other<br></p><p>per-object data. This is an outline of the scheme. Comments and<br></p><p>suggestions welcome.<br></p><p><br></p><p>Today, each object stores 64-bits of refcounts and flags after the isa<br></p><p>field.<br></p><p><br></p><p>In this new system, each object would store a pointer-size field after<br></p><p>the isa field. This field would have two cases: it could store refcounts<br></p><p>and flags, or it could store a pointer to a side allocation that would<br></p><p>store refcounts and flags and additional per-object data.<br></p><p><br></p><p>Advantages:<br></p><p>…<br></p><p>* Allows inexpensive per-object storage for future features like<br></p><p>associated references or class extensions with instance variables.<br></p><p>…&quot;<br></p><p><br></p><p>I don&#39;t know the current status of this idea (implemented? planned?<br></p><p>abandoned?). Also, it&#39;s worth noting that this would only apply to<br></p><p>classes, not value types.<br></p><p><br></p><p>Ole<br></p><p>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/059802b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 12, 2016 at 12:00:00am</p></header><div class="content"><p>Interestingly, if all the stored properties defined in extensions could be<br>determined at link-time, the size/layout of the side-table could include<br>them directly, removing the need for further indirection. The offsets would<br>still need to be fixed up, which would add some complexity to the<br>implementation.<br></p><p>On Wed, 12 Oct 2016 at 00:54 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br></p><p>&gt; Wow, that&#39;s a very interesting post. Sounds a lot simpler to implement<br>&gt; than my idea about fixing up offsets in the linker and preserves binary<br>&gt; compatability just the same.<br>&gt;<br>&gt; I got some complaints when I first started talking about this that the<br>&gt; runtime would have to track extra pointers and performance would be<br>&gt; affected because of additional levels of indirection, which I didn&#39;t fully<br>&gt; understand because it seems fairly trivial to me. Perhaps this twin-purpose<br>&gt; refcount/side-table pointer also suffers the same concerns?<br>&gt;<br>&gt; On Wed, 12 Oct 2016 at 00:21 Ole Begemann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;  &gt; I think the language devs must have some idea how this will work, but<br>&gt;<br>&gt;  &gt; don&#39;t seem to want to share/discuss it at the moment. I was hoping for<br>&gt;<br>&gt;  &gt; some feedback about my implementation ideas - whether they are along the<br>&gt;<br>&gt;  &gt; right lines, or way off, or not necessary (because the implementation<br>&gt;<br>&gt;  &gt; strategy is already known). Perhaps this the wrong list for that kind of<br>&gt;<br>&gt;  &gt; discussion?<br>&gt;<br>&gt;<br>&gt;<br>&gt; For what it&#39;s worth, Greg Parker (Cc&#39;ed) started a discussion back in<br>&gt;<br>&gt; March that I think is relevant here:<br>&gt;<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160314/001424.html<br>&gt;<br>&gt;<br>&gt;<br>&gt; Here&#39;s the relevant part:<br>&gt;<br>&gt;<br>&gt;<br>&gt; &quot;I am considering a new representation for Swift refcounts and other<br>&gt;<br>&gt; per-object data. This is an outline of the scheme. Comments and<br>&gt;<br>&gt; suggestions welcome.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Today, each object stores 64-bits of refcounts and flags after the isa<br>&gt;<br>&gt; field.<br>&gt;<br>&gt;<br>&gt;<br>&gt; In this new system, each object would store a pointer-size field after<br>&gt;<br>&gt; the isa field. This field would have two cases: it could store refcounts<br>&gt;<br>&gt; and flags, or it could store a pointer to a side allocation that would<br>&gt;<br>&gt; store refcounts and flags and additional per-object data.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Advantages:<br>&gt;<br>&gt; …<br>&gt;<br>&gt; * Allows inexpensive per-object storage for future features like<br>&gt;<br>&gt; associated references or class extensions with instance variables.<br>&gt;<br>&gt; …&quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt; I don&#39;t know the current status of this idea (implemented? planned?<br>&gt;<br>&gt; abandoned?). Also, it&#39;s worth noting that this would only apply to<br>&gt;<br>&gt; classes, not value types.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Ole<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt;<br>&gt; swift-evolution at swift.org<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/99e7ca7c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>October 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 3:02 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Implementation idea No. 4:<br>&gt; <br>&gt; The basic concept is that the dynamic linker would fixup the offsets as well as relocating the addersses, allowing the size of objects (and maybe structs?) to change at link-time. The process might be something like this:<br>&gt; <br>&gt; * References to members defined in extensions would compile to have an offset symbol instead of a value - so they can be fixed up later<br>&gt; * The linker would scan all the shared objects that are referenced (and thus might get linked)<br>&gt; * Build up a list of Stored Properties In ExtensionS (SPIES, muhahaha) for each class.<br>&gt; * Append the extra fields (increase the size the class), decide where each member goes in the extended layout and fixup the offsets<br>&gt; * Carry on with normal relocation<br>&gt; <br>&gt; There are quite a few assumptions in the above, and probably quite a few misunderstandings about how things work on my part too (I&#39;m not an expert at this), however I think it should work in principle. Some questions about my assumptions: Can linker know in advance all the potential modules that could be linked, or is this done more lazily and it only knows about what it&#39;s linking right now? Is it ok for the size to change - I don&#39;t know if it&#39;s a static sizeof() or if it could be (or already is) stored in the isa?<br></p><p>This sort of scheme isn&#39;t dynamic enough. The worst-case is a extension in a library that gets dlopen()ed at runtime on a class that is already loaded. The build-time linker can&#39;t know anything about it. The loader and the runtime will see it, but at that point the class may already be in use and may already have instances allocated. If you want to handle the dlopen() case then you need some way to add storage to arbitrary objects that have already been allocated.<br></p><p><br>&gt; Ole Begemann wrote:<br>&gt; <br>&gt; For what it&#39;s worth, Greg Parker (Cc&#39;ed) started a discussion back in March that I think is relevant here: https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160314/001424.html<br>&gt; <br>&gt; Here&#39;s the relevant part:<br>&gt; <br>&gt; &quot;I am considering a new representation for Swift refcounts and other per-object data. This is an outline of the scheme. Comments and suggestions welcome.<br>&gt; <br>&gt; Today, each object stores 64-bits of refcounts and flags after the isa field.<br>&gt; <br>&gt; In this new system, each object would store a pointer-size field after the isa field. This field would have two cases: it could store refcounts and flags, or it could store a pointer to a side allocation that would store refcounts and flags and additional per-object data.<br>&gt; <br>&gt; Advantages:<br>&gt; …<br>&gt; * Allows inexpensive per-object storage for future features like associated references or class extensions with instance variables.<br>&gt; …&quot;<br>&gt; <br>&gt; I don&#39;t know the current status of this idea (implemented? planned? abandoned?). Also, it&#39;s worth noting that this would only apply to classes, not value types.<br></p><p>I&#39;m working on this right now: https://github.com/gparker42/swift/tree/new-refcount-representation &lt;https://github.com/gparker42/swift/tree/new-refcount-representation&gt;<br></p><p>If it goes well it will provide the runtime implementation space needed for associated objects or stored properties in extensions. Such storage would be less efficient than &quot;real&quot; stored properties. Any object with that storage attached would also suffer additional performance penalties to refcounting and deallocation. On the plus side there is no memory penalty to objects that don&#39;t have additional storage, and there is no contention over a big global association table like there is in Objective-C&#39;s associated object implementation.<br></p><p>Note that the runtime implementation is not the only problem. The optimizer folks hate the fact that stored properties in extensions defeat the compiler&#39;s visibility into the deinit behavior of all types, even if most types are unaffected at runtime.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/51613313/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 13, 2016 at 05:00:00pm</p></header><div class="content"><p>That&#39;s great! I suppose the idea of allocating a bit of extra storage for similar data in value types is some sort of heresy?<br></p><p>Would there be a conceptual reason for that; which explains why it&#39;s okay for reference-types but not for values? Personally I feel like it&#39;s a kind of C legacy, due to performance and layout expectations that C sets about value-types ¯\_(ツ)_/¯<br></p><p>Karl<br></p><p><br>Sent from my iPad<br></p><p>&gt; On 12 Oct 2016, at 07:54, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 3:02 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Implementation idea No. 4:<br>&gt;&gt; <br>&gt;&gt; The basic concept is that the dynamic linker would fixup the offsets as well as relocating the addersses, allowing the size of objects (and maybe structs?) to change at link-time. The process might be something like this:<br>&gt;&gt; <br>&gt;&gt; * References to members defined in extensions would compile to have an offset symbol instead of a value - so they can be fixed up later<br>&gt;&gt; * The linker would scan all the shared objects that are referenced (and thus might get linked)<br>&gt;&gt; * Build up a list of Stored Properties In ExtensionS (SPIES, muhahaha) for each class.<br>&gt;&gt; * Append the extra fields (increase the size the class), decide where each member goes in the extended layout and fixup the offsets<br>&gt;&gt; * Carry on with normal relocation<br>&gt;&gt; <br>&gt;&gt; There are quite a few assumptions in the above, and probably quite a few misunderstandings about how things work on my part too (I&#39;m not an expert at this), however I think it should work in principle. Some questions about my assumptions: Can linker know in advance all the potential modules that could be linked, or is this done more lazily and it only knows about what it&#39;s linking right now? Is it ok for the size to change - I don&#39;t know if it&#39;s a static sizeof() or if it could be (or already is) stored in the isa?<br>&gt; <br>&gt; This sort of scheme isn&#39;t dynamic enough. The worst-case is a extension in a library that gets dlopen()ed at runtime on a class that is already loaded. The build-time linker can&#39;t know anything about it. The loader and the runtime will see it, but at that point the class may already be in use and may already have instances allocated. If you want to handle the dlopen() case then you need some way to add storage to arbitrary objects that have already been allocated.<br>&gt; <br>&gt; <br>&gt;&gt; Ole Begemann wrote:<br>&gt;&gt; <br>&gt;&gt; For what it&#39;s worth, Greg Parker (Cc&#39;ed) started a discussion back in March that I think is relevant here: https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160314/001424.html<br>&gt;&gt; <br>&gt;&gt; Here&#39;s the relevant part:<br>&gt;&gt; <br>&gt;&gt; &quot;I am considering a new representation for Swift refcounts and other per-object data. This is an outline of the scheme. Comments and suggestions welcome.<br>&gt;&gt; <br>&gt;&gt; Today, each object stores 64-bits of refcounts and flags after the isa field.<br>&gt;&gt; <br>&gt;&gt; In this new system, each object would store a pointer-size field after the isa field. This field would have two cases: it could store refcounts and flags, or it could store a pointer to a side allocation that would store refcounts and flags and additional per-object data.<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; …<br>&gt;&gt; * Allows inexpensive per-object storage for future features like associated references or class extensions with instance variables.<br>&gt;&gt; …&quot;<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know the current status of this idea (implemented? planned? abandoned?). Also, it&#39;s worth noting that this would only apply to classes, not value types.<br>&gt; <br>&gt; I&#39;m working on this right now: https://github.com/gparker42/swift/tree/new-refcount-representation<br>&gt; <br>&gt; If it goes well it will provide the runtime implementation space needed for associated objects or stored properties in extensions. Such storage would be less efficient than &quot;real&quot; stored properties. Any object with that storage attached would also suffer additional performance penalties to refcounting and deallocation. On the plus side there is no memory penalty to objects that don&#39;t have additional storage, and there is no contention over a big global association table like there is in Objective-C&#39;s associated object implementation.<br>&gt; <br>&gt; Note that the runtime implementation is not the only problem. The optimizer folks hate the fact that stored properties in extensions defeat the compiler&#39;s visibility into the deinit behavior of all types, even if most types are unaffected at runtime.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/fdd3c208/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 14, 2016 at 01:00:00am</p></header><div class="content"><p>Karl, interesting point... perhaps a similar scheme could work for value<br>types (using the COW refcount)?<br></p><p>On Thu, 13 Oct 2016 at 16:02 Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; That&#39;s great! I suppose the idea of allocating a bit of extra storage for<br>&gt; similar data in value types is some sort of heresy?<br>&gt;<br>&gt; Would there be a conceptual reason for that; which explains why it&#39;s okay<br>&gt; for reference-types but not for values? Personally I feel like it&#39;s a kind<br>&gt; of C legacy, due to performance and layout expectations that C sets about<br>&gt; value-types ¯\_(ツ)_/¯<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On 12 Oct 2016, at 07:54, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 11, 2016, at 3:02 PM, Jay Abbott via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Implementation idea No. 4:<br>&gt;<br>&gt;<br>&gt; The basic concept is that the dynamic linker would fixup the offsets as<br>&gt; well as relocating the addersses, allowing the size of objects (and maybe<br>&gt; structs?) to change at link-time. The process might be something like this:<br>&gt;<br>&gt; * References to members defined in extensions would compile to have an<br>&gt; offset symbol instead of a value - so they can be fixed up later<br>&gt; * The linker would scan all the shared objects that are referenced (and<br>&gt; thus might get linked)<br>&gt; * Build up a list of Stored Properties In ExtensionS (SPIES, muhahaha) for<br>&gt; each class.<br>&gt; * Append the extra fields (increase the size the class), decide where each<br>&gt; member goes in the extended layout and fixup the offsets<br>&gt; * Carry on with normal relocation<br>&gt;<br>&gt; There are quite a few assumptions in the above, and probably quite a few<br>&gt; misunderstandings about how things work on my part too (I&#39;m not an expert<br>&gt; at this), however I think it should work in principle. Some questions about<br>&gt; my assumptions: Can linker know in advance all the potential modules that<br>&gt; could be linked, or is this done more lazily and it only knows about what<br>&gt; it&#39;s linking right now? Is it ok for the size to change - I don&#39;t know if<br>&gt; it&#39;s a static sizeof() or if it could be (or already is) stored in the isa?<br>&gt;<br>&gt;<br>&gt; This sort of scheme isn&#39;t dynamic enough. The worst-case is a extension in<br>&gt; a library that gets dlopen()ed at runtime on a class that is already<br>&gt; loaded. The build-time linker can&#39;t know anything about it. The loader and<br>&gt; the runtime will see it, but at that point the class may already be in use<br>&gt; and may already have instances allocated. If you want to handle the<br>&gt; dlopen() case then you need some way to add storage to arbitrary objects<br>&gt; that have already been allocated.<br>&gt;<br>&gt;<br>&gt; Ole Begemann wrote:<br>&gt;<br>&gt;<br>&gt; For what it&#39;s worth, Greg Parker (Cc&#39;ed) started a discussion back in<br>&gt; March that I think is relevant here:<br>&gt; https://lists.swift.org/pipermail/swift-dev/Week-<br>&gt; of-Mon-20160314/001424.html<br>&gt;<br>&gt; Here&#39;s the relevant part:<br>&gt;<br>&gt; &quot;I am considering a new representation for Swift refcounts and other<br>&gt; per-object data. This is an outline of the scheme. Comments and suggestions<br>&gt; welcome.<br>&gt;<br>&gt; Today, each object stores 64-bits of refcounts and flags after the isa<br>&gt; field.<br>&gt;<br>&gt; In this new system, each object would store a pointer-size field after the<br>&gt; isa field. This field would have two cases: it could store refcounts and<br>&gt; flags, or it could store a pointer to a side allocation that would store<br>&gt; refcounts and flags and additional per-object data.<br>&gt;<br>&gt; Advantages:<br>&gt; …<br>&gt; * Allows inexpensive per-object storage for future features like<br>&gt; associated references or class extensions with instance variables.<br>&gt; …&quot;<br>&gt;<br>&gt; I don&#39;t know the current status of this idea (implemented? planned?<br>&gt; abandoned?). Also, it&#39;s worth noting that this would only apply to classes,<br>&gt; not value types.<br>&gt;<br>&gt;<br>&gt; I&#39;m working on this right now:<br>&gt; https://github.com/gparker42/swift/tree/new-refcount-representation<br>&gt;<br>&gt; If it goes well it will provide the runtime implementation space needed<br>&gt; for associated objects or stored properties in extensions. Such storage<br>&gt; would be less efficient than &quot;real&quot; stored properties. Any object with that<br>&gt; storage attached would also suffer additional performance penalties to<br>&gt; refcounting and deallocation. On the plus side there is no memory penalty<br>&gt; to objects that don&#39;t have additional storage, and there is no contention<br>&gt; over a big global association table like there is in Objective-C&#39;s<br>&gt; associated object implementation.<br>&gt;<br>&gt; Note that the runtime implementation is not the only problem. The<br>&gt; optimizer folks hate the fact that stored properties in extensions defeat<br>&gt; the compiler&#39;s visibility into the deinit behavior of all types, even if<br>&gt; most types are unaffected at runtime.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/efa67810/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Let extensions introduce stored properties, but only in the same module as the type’s definition. Then, the compiler can just take any extensions into consideration when it’s determining the size of the type, just as if the properties had been declared in the type. Declaring stored properties on an extension outside of the type’s module results in a compiler error, exactly as today. This would, without any performance drawbacks, solve one of the big problems that people are hoping to solve via stored properties in extensions—the ability to organize members by protocol conformance.<br></p><p>Yes please! A big strong +1 to this from me. I can think of several specific chunks of problem code that this would clean up immensely.<br></p><p>Contra Karl in another message, it’s _in-module_ stored property extensions that I want most frequently. By far.<br></p><p>It seems to me that Charles’s idea could be introduced as its own proposal. If out-of-module stored property extensions do eventually become feasible, then Charles’s proposal is a good stepping stone. If they never do, then his proposal has done no harm.<br></p><p>I realize this probably falls into the post-ABI stability bucket, but I’d love to help write/support the proposal when its time comes.<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>October 14, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 for me for &quot;in-module&quot; as a stop-gap, since I imagine it would be the<br>quickest, and least disruptive, way to make this happen.<br></p><p>I would add the caveat that if we do so, I really hope we commit to making<br>stored properties available *everywhere* later.<br></p><p>Even though it&#39;s more often than not &quot;in-module&quot; where I need this, the<br>fewer &quot;exceptions to the rule&quot; we have in Swift the better. It gets tricky<br>trying to plan things out when one has to juggle too many features that<br>work in one context, but not another.<br></p><p>So +1 with the hope that it doesn&#39;t stay &quot;in-module&quot; till the end of time.<br></p><p><br></p><p>On Fri, Oct 14, 2016 at 6:01 PM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Let extensions introduce stored properties, but only in the same module<br>&gt; as the type’s definition. Then, the compiler can just take any extensions<br>&gt; into consideration when it’s determining the size of the type, just as if<br>&gt; the properties had been declared in the type. Declaring stored properties<br>&gt; on an extension outside of the type’s module results in a compiler error,<br>&gt; exactly as today. This would, without any performance drawbacks, solve one<br>&gt; of the big problems that people are hoping to solve via stored properties<br>&gt; in extensions—the ability to organize members by protocol conformance.<br>&gt;<br>&gt; Yes please! A big strong +1 to this from me. I can think of several<br>&gt; specific chunks of problem code that this would clean up immensely.<br>&gt;<br>&gt; Contra Karl in another message, it’s _in-module_ stored property<br>&gt; extensions that I want most frequently. By far.<br>&gt;<br>&gt; It seems to me that Charles’s idea could be introduced as its own<br>&gt; proposal. If out-of-module stored property extensions do eventually become<br>&gt; feasible, then Charles’s proposal is a good stepping stone. If they never<br>&gt; do, then his proposal has done no harm.<br>&gt;<br>&gt; I realize this probably falls into the post-ABI stability bucket, but I’d<br>&gt; love to help write/support the proposal when its time comes.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/1c99440e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 15 Oct 2016, at 02:01, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Let extensions introduce stored properties, but only in the same module as the type’s definition. Then, the compiler can just take any extensions into consideration when it’s determining the size of the type, just as if the properties had been declared in the type. Declaring stored properties on an extension outside of the type’s module results in a compiler error, exactly as today. This would, without any performance drawbacks, solve one of the big problems that people are hoping to solve via stored properties in extensions—the ability to organize members by protocol conformance.<br>&gt; <br>&gt; Yes please! A big strong +1 to this from me. I can think of several specific chunks of problem code that this would clean up immensely.<br></p><p>+1 from me too for internal extensions; I think this is the logical place to start for now so we can see how many use cases this actually covers. Personally I don&#39;t try to add functionality to types from other libraries, and when I have to I try as much as possible to do it via wrapping; obviously this doesn&#39;t cover the async type cases and others where it&#39;d be hard to re-wrap the values, but I think I&#39;d like to know more about how common such cases actually are.<br></p><p>However, allowing stored properties in local extensions is an absolute must for a first step, and would be very useful as a first step.<br></p><p><br>The problem I have with doing it for external types is that I just don&#39;t see how it can be done efficiently; associated objects means looking up the object to find what its associated values are, which isn&#39;t a negligible cost if you&#39;re doing it frequently, and it makes me very uncomfortable to think of hiding what is actually happening, as developers may think they&#39;re just using a regular property without really appreciating the actual costs involved. At the very least they need to handled through a .associated property or whatever to make it much clearer that these aren&#39;t native properties in the normal sense.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October 15, 2016 at 05:00:00am</p></header><div class="content"><p>I’m haven’t read the implementation, but as I see it, “weak” has the effect of storing associated values.  Can that mechanism be made generic?<br></p><p>&gt; +1 from me too for internal extensions; I think this is the logical place to start for now so we can see how many use cases this actually covers. Personally I don&#39;t try to add functionality to types from other libraries, and when I have to I try as much as possible to do it via wrapping; obviously this doesn&#39;t cover the async type cases and others where it&#39;d be hard to re-wrap the values, but I think I&#39;d like to know more about how common such cases actually are.<br>&gt; <br>&gt; However, allowing stored properties in local extensions is an absolute must for a first step, and would be very useful as a first step.<br>&gt; <br>&gt; <br>&gt; The problem I have with doing it for external types is that I just don&#39;t see how it can be done efficiently; associated objects means looking up the object to find what its associated values are, which isn&#39;t a negligible cost if you&#39;re doing it frequently, and it makes me very uncomfortable to think of hiding what is actually happening, as developers may think they&#39;re just using a regular property without really appreciating the actual costs involved. At the very least they need to handled through a .associated property or whatever to make it much clearer that these aren&#39;t native properties in the normal sense.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>October 15, 2016 at 04:00:00pm</p></header><div class="content"><p>Currently, we can expect that fields of a type are all collected in the<br>same place. This expectation applies more for &quot;static&quot; and less for<br>&quot;dynamic&quot; types.<br>So I agree with the idea for @objc classes, strongly disagree for structs,<br>and disagree for regular classes.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161015/6dd444a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Greg:<br></p><p>I&#39;ve CCed you in case you want to respond to my comments below about<br>potentially optimising &quot;extensionIvar&quot; access without using a dictionary.<br>See my response to Haravikk below.<br></p><p>Benjamin:<br></p><p>Implementation wise, weak does *not* currently have the effect of storing<br>associated values. It does however mean that any object with weak<br>references stays allocated after being deinited, until all the weak<br>references are evaluated and zeroed (they are not zeroed when the object<br>deinits, zeroing is done lazily. See<br>https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html<br>for a detailed discussion).<br></p><p>However, this seems likely to change at some point when Greg&#39;s changes are<br>merged. Weakly referenced objects would cause a side-table to be allocated,<br>with the benefits that the object could be deallocated immediately after<br>deinit, and only the side-table would hang around (to service attempts to<br>access weak references, which would still be lazily zeroed). The small<br>disadvantage of this (which only applies to instances that actually have<br>had weak references) is that an extra pointer dereference is needed for<br>retain, release, and weak reference access (and some other things). But a<br>big advantage is that the side-allocation could be used for other things<br>too, like stored properties.<br></p><p>Haravikk:<br></p><p>It can be done efficiently using Greg&#39;s proposed changes. The current<br>implementation on his branch (<br>https://github.com/gparker42/swift/tree/new-refcount-representation) does<br>not have any extra space for stored properties, but he has discussed<br>&quot;extensionIvars&quot; before on swift-dev, and proposed that the side-table<br>structure contains a pointer to a dictionary for these. However, I think<br>with some dynamic loader magic this could be implemented as a dynamic<br>structure instead of a dictionary. Each time a module is loaded, the side<br>allocation for stored properties could be extended and the offsets to the<br>newly extended properties could be fixed-up based on the current size.<br>Existing instances could be handled by using the structure size as a<br>version number (stored at the beginning of this area), it would check if<br>the instance is at the current version and migrate/update the structure as<br>needed (realloc it and init the extended area to zero, updating the<br>size/version field). These checks would be less overhead than a<br>getter/setter function call, so using dot notation to access the properties<br>would not be deceiving programmers about the cost.<br></p><p>Anton:<br></p><p>Why should it matter where data is stored? Can you expand on any reasons<br>for wanting object data to be contiguous, or thinking that it shouldn&#39;t be<br>allowed for Swift classes?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/ec8d29f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>October 16, 2016 at 06:00:00pm</p></header><div class="content"><p>How much would convenient method forwarding when wrapping change how<br>desirable this feature is? I am hesitant to add storage to already<br>allocated instances if we can avoid it.<br></p><p>On Sun, Oct 16, 2016 at 5:02 PM, Jay Abbott via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Greg:<br>&gt;<br>&gt; I&#39;ve CCed you in case you want to respond to my comments below about<br>&gt; potentially optimising &quot;extensionIvar&quot; access without using a dictionary.<br>&gt; See my response to Haravikk below.<br>&gt;<br>&gt; Benjamin:<br>&gt;<br>&gt; Implementation wise, weak does *not* currently have the effect of storing<br>&gt; associated values. It does however mean that any object with weak<br>&gt; references stays allocated after being deinited, until all the weak<br>&gt; references are evaluated and zeroed (they are not zeroed when the object<br>&gt; deinits, zeroing is done lazily. See https://www.mikeash.com/<br>&gt; pyblog/friday-qa-2015-12-11-swift-weak-references.html for a detailed<br>&gt; discussion).<br>&gt;<br>&gt; However, this seems likely to change at some point when Greg&#39;s changes are<br>&gt; merged. Weakly referenced objects would cause a side-table to be allocated,<br>&gt; with the benefits that the object could be deallocated immediately after<br>&gt; deinit, and only the side-table would hang around (to service attempts to<br>&gt; access weak references, which would still be lazily zeroed). The small<br>&gt; disadvantage of this (which only applies to instances that actually have<br>&gt; had weak references) is that an extra pointer dereference is needed for<br>&gt; retain, release, and weak reference access (and some other things). But a<br>&gt; big advantage is that the side-allocation could be used for other things<br>&gt; too, like stored properties.<br>&gt;<br>&gt; Haravikk:<br>&gt;<br>&gt; It can be done efficiently using Greg&#39;s proposed changes. The current<br>&gt; implementation on his branch (https://github.com/gparker42/<br>&gt; swift/tree/new-refcount-representation) does not have any extra space for<br>&gt; stored properties, but he has discussed &quot;extensionIvars&quot; before on<br>&gt; swift-dev, and proposed that the side-table structure contains a pointer to<br>&gt; a dictionary for these. However, I think with some dynamic loader magic<br>&gt; this could be implemented as a dynamic structure instead of a dictionary.<br>&gt; Each time a module is loaded, the side allocation for stored properties<br>&gt; could be extended and the offsets to the newly extended properties could be<br>&gt; fixed-up based on the current size. Existing instances could be handled by<br>&gt; using the structure size as a version number (stored at the beginning of<br>&gt; this area), it would check if the instance is at the current version and<br>&gt; migrate/update the structure as needed (realloc it and init the extended<br>&gt; area to zero, updating the size/version field). These checks would be less<br>&gt; overhead than a getter/setter function call, so using dot notation to<br>&gt; access the properties would not be deceiving programmers about the cost.<br>&gt;<br>&gt; Anton:<br>&gt;<br>&gt; Why should it matter where data is stored? Can you expand on any reasons<br>&gt; for wanting object data to be contiguous, or thinking that it shouldn&#39;t be<br>&gt; allowed for Swift classes?<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/115754b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 16, 2016 at 11:00:00pm</p></header><div class="content"><p>T.J.: This would not replace the need for stored properties in extensions.<br>For example: Imagine adding a property to UIView in an extension, then<br>recursively traversing a view hierarchy and accessing the property. This<br>thought experiment should quickly show you why wrapping and adding<br>properties (or even subclassing and adding properties) simply won&#39;t work,<br>even if an easy forwarding mechanism were in place. You do not have control<br>of the creation of all those objects, so you can&#39;t make them your type, and<br>even if you could, you would have to provide a wrapper class for every<br>UIView subclass, and then what if another module also wants to do the same?<br></p><p>However, note that it would be possible to only add the extra storage to<br>instances where some additional properties are actually accessed/in-use.<br>The pointer for the stored property data in the side-table would simply be<br>nil if it has never been used.<br></p><p>On Sun, 16 Oct 2016 at 23:31 T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt; How much would convenient method forwarding when wrapping change how<br>&gt; desirable this feature is? I am hesitant to add storage to already<br>&gt; allocated instances if we can avoid it.<br>&gt;<br>&gt; On Sun, Oct 16, 2016 at 5:02 PM, Jay Abbott via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Greg:<br>&gt;<br>&gt; I&#39;ve CCed you in case you want to respond to my comments below about<br>&gt; potentially optimising &quot;extensionIvar&quot; access without using a dictionary.<br>&gt; See my response to Haravikk below.<br>&gt;<br>&gt; Benjamin:<br>&gt;<br>&gt; Implementation wise, weak does *not* currently have the effect of storing<br>&gt; associated values. It does however mean that any object with weak<br>&gt; references stays allocated after being deinited, until all the weak<br>&gt; references are evaluated and zeroed (they are not zeroed when the object<br>&gt; deinits, zeroing is done lazily. See<br>&gt; https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html<br>&gt; for a detailed discussion).<br>&gt;<br>&gt; However, this seems likely to change at some point when Greg&#39;s changes are<br>&gt; merged. Weakly referenced objects would cause a side-table to be allocated,<br>&gt; with the benefits that the object could be deallocated immediately after<br>&gt; deinit, and only the side-table would hang around (to service attempts to<br>&gt; access weak references, which would still be lazily zeroed). The small<br>&gt; disadvantage of this (which only applies to instances that actually have<br>&gt; had weak references) is that an extra pointer dereference is needed for<br>&gt; retain, release, and weak reference access (and some other things). But a<br>&gt; big advantage is that the side-allocation could be used for other things<br>&gt; too, like stored properties.<br>&gt;<br>&gt; Haravikk:<br>&gt;<br>&gt; It can be done efficiently using Greg&#39;s proposed changes. The current<br>&gt; implementation on his branch (<br>&gt; https://github.com/gparker42/swift/tree/new-refcount-representation) does<br>&gt; not have any extra space for stored properties, but he has discussed<br>&gt; &quot;extensionIvars&quot; before on swift-dev, and proposed that the side-table<br>&gt; structure contains a pointer to a dictionary for these. However, I think<br>&gt; with some dynamic loader magic this could be implemented as a dynamic<br>&gt; structure instead of a dictionary. Each time a module is loaded, the side<br>&gt; allocation for stored properties could be extended and the offsets to the<br>&gt; newly extended properties could be fixed-up based on the current size.<br>&gt; Existing instances could be handled by using the structure size as a<br>&gt; version number (stored at the beginning of this area), it would check if<br>&gt; the instance is at the current version and migrate/update the structure as<br>&gt; needed (realloc it and init the extended area to zero, updating the<br>&gt; size/version field). These checks would be less overhead than a<br>&gt; getter/setter function call, so using dot notation to access the properties<br>&gt; would not be deceiving programmers about the cost.<br>&gt;<br>&gt; Anton:<br>&gt;<br>&gt; Why should it matter where data is stored? Can you expand on any reasons<br>&gt; for wanting object data to be contiguous, or thinking that it shouldn&#39;t be<br>&gt; allowed for Swift classes?<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/e808aade/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; Benjamin:<br>&gt;&gt; <br>&gt;&gt; Implementation wise, weak does *not* currently have the effect of storing associated values. It does however mean that any object with weak references stays allocated after being deinited, until all the weak references are evaluated and zeroed (they are not zeroed when the object deinits, zeroing is done lazily. See https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html for a detailed discussion).<br>&gt;&gt; <br>&gt;&gt; However, this seems likely to change at some point when Greg&#39;s changes are merged. Weakly referenced objects would cause a side-table to be allocated, with the benefits that the object could be deallocated immediately after deinit, and only the side-table would hang around (to service attempts to access weak references, which would still be lazily zeroed). The small disadvantage of this (which only applies to instances that actually have had weak references) is that an extra pointer dereference is needed for retain, release, and weak reference access (and some other things). But a big advantage is that the side-allocation could be used for other things too, like stored properties.<br></p><p>Thanks for the reference to the article.  I always meant to take the time to do that bit spelunking, never actually had the time, and the non-code documentation I found claimed it was out of date so I didn&#39;t bother reading it.  Of all the possible implementations I conjectured after hearing about ARC when it was announced for Obj-C, this was not one of them.  And frankly, reading it makes me want to quit working as a software developer and take up writing psychological thrillers as my job.  :(<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/a423fdf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 16, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Oct 16, 2016, at 6:56 PM, Benjamin Spratling via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Benjamin:<br>&gt;&gt; <br>&gt;&gt; Implementation wise, weak does *not* currently have the effect of storing associated values. It does however mean that any object with weak references stays allocated after being deinited, until all the weak references are evaluated and zeroed (they are not zeroed when the object deinits, zeroing is done lazily. See https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html &lt;https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html&gt; for a detailed discussion).<br>&gt;&gt; <br>&gt;&gt; However, this seems likely to change at some point when Greg&#39;s changes are merged. Weakly referenced objects would cause a side-table to be allocated, with the benefits that the object could be deallocated immediately after deinit, and only the side-table would hang around (to service attempts to access weak references, which would still be lazily zeroed). The small disadvantage of this (which only applies to instances that actually have had weak references) is that an extra pointer dereference is needed for retain, release, and weak reference access (and some other things). But a big advantage is that the side-allocation could be used for other things too, like stored properties.<br>&gt; <br>&gt; Thanks for the reference to the article.  I always meant to take the time to do that bit spelunking, never actually had the time, and the non-code documentation I found claimed it was out of date so I didn&#39;t bother reading it.  Of all the possible implementations I conjectured after hearing about ARC when it was announced for Obj-C, this was not one of them.  And frankly, reading it makes me want to quit working as a software developer and take up writing psychological thrillers as my job.  :(<br></p><p>The implementation in Objective-C ARC was not the same as Swift&#39;s, IIRC. I believe that it zeroed the references out immediately at the time the object ran out of references, rather than doing it lazily the next time something tried to access the reference. I could be wrong, though.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/6d276ba4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>November  3, 2016 at 04:00:00pm</p></header><div class="content"><p>Has anybody thought about the semantic issues of out-of-module extensions with stored properties apart from the implementation issues?<br></p><p>Such properties could potentially wreak havoc with the semantics of the type being extended. How would these properties play nice with an existing definition of equality, for example? How can it be guaranteed that their value is consistent with the remaining state? And kept that way in case of mutability?<br></p><p>-Thorsten <br></p><p>&gt; Am 15.10.2016 um 03:01 schrieb Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Let extensions introduce stored properties, but only in the same module as the type’s definition. Then, the compiler can just take any extensions into consideration when it’s determining the size of the type, just as if the properties had been declared in the type. Declaring stored properties on an extension outside of the type’s module results in a compiler error, exactly as today. This would, without any performance drawbacks, solve one of the big problems that people are hoping to solve via stored properties in extensions—the ability to organize members by protocol conformance.<br>&gt; <br>&gt; Yes please! A big strong +1 to this from me. I can think of several specific chunks of problem code that this would clean up immensely.<br>&gt; <br>&gt; Contra Karl in another message, it’s _in-module_ stored property extensions that I want most frequently. By far.<br>&gt; <br>&gt; It seems to me that Charles’s idea could be introduced as its own proposal. If out-of-module stored property extensions do eventually become feasible, then Charles’s proposal is a good stepping stone. If they never do, then his proposal has done no harm.<br>&gt; <br>&gt; I realize this probably falls into the post-ABI stability bucket, but I’d love to help write/support the proposal when its time comes.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>November 10, 2016 at 10:00:00am</p></header><div class="content"><p>Perhaps some types don’t lend themselves to being extended?<br></p><p>Intuitively I would think any extensions should not affect the core<br>behaviour at all. So if I extended a type by adding a property x, two<br>instances with everything else the same and different values of x should<br>still be considered equal by a type-specific equality check. For example<br>you would agree that 1 + 1 = 2 but what if the numbers were coloured red,<br>blue, and yellow respectively, like fridge-magnets, should 1(red) + 1(blue)<br>= 2(yellow)? I think yes. The colour is an extension, it doesn’t change the<br>fundamental concept or behaviour of an integer number.<br></p><p>I see extensions as a way to add functionality (and potentially data), but<br>without affecting the core behaviour. If you wanted to change behaviour<br>then you should use inheritance or composition to create something new. You<br>can’t then use your own type for instances created by a library, unless it<br>gives you a way to do that, the library would expect its own types to<br>behave in a predictable way, similarly they should behave the same way when<br>extended.<br>​<br></p><p>On Thu, 3 Nov 2016 at 15:14 Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Has anybody thought about the semantic issues of out-of-module extensions<br>&gt; with stored properties apart from the implementation issues?<br>&gt;<br>&gt; Such properties could potentially wreak havoc with the semantics of the<br>&gt; type being extended. How would these properties play nice with an existing<br>&gt; definition of equality, for example? How can it be guaranteed that their<br>&gt; value is consistent with the remaining state? And kept that way in case of<br>&gt; mutability?<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; &gt; Am 15.10.2016 um 03:01 schrieb Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Let extensions introduce stored properties, but only in the same module<br>&gt; as the type’s definition. Then, the compiler can just take any extensions<br>&gt; into consideration when it’s determining the size of the type, just as if<br>&gt; the properties had been declared in the type. Declaring stored properties<br>&gt; on an extension outside of the type’s module results in a compiler error,<br>&gt; exactly as today. This would, without any performance drawbacks, solve one<br>&gt; of the big problems that people are hoping to solve via stored properties<br>&gt; in extensions—the ability to organize members by protocol conformance.<br>&gt; &gt;<br>&gt; &gt; Yes please! A big strong +1 to this from me. I can think of several<br>&gt; specific chunks of problem code that this would clean up immensely.<br>&gt; &gt;<br>&gt; &gt; Contra Karl in another message, it’s _in-module_ stored property<br>&gt; extensions that I want most frequently. By far.<br>&gt; &gt;<br>&gt; &gt; It seems to me that Charles’s idea could be introduced as its own<br>&gt; proposal. If out-of-module stored property extensions do eventually become<br>&gt; feasible, then Charles’s proposal is a good stepping stone. If they never<br>&gt; do, then his proposal has done no harm.<br>&gt; &gt;<br>&gt; &gt; I realize this probably falls into the post-ABI stability bucket, but<br>&gt; I’d love to help write/support the proposal when its time comes.<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt;<br>&gt; &gt; Paul<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/9be3adae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>November 10, 2016 at 10:00:00am</p></header><div class="content"><p>This line of thought suggests that allowing stored properties for same-module extensions is not only much more feasible to implement, but also makes more sense at the user level.<br></p><p>&gt; On Nov 10, 2016, at 4:36 AM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Perhaps some types don’t lend themselves to being extended?<br>&gt; <br>&gt; Intuitively I would think any extensions should not affect the core behaviour at all. So if I extended a type by adding a property x, two instances with everything else the same and different values of x should still be considered equal by a type-specific equality check. For example you would agree that 1 + 1 = 2 but what if the numbers were coloured red, blue, and yellow respectively, like fridge-magnets, should 1(red) + 1(blue) = 2(yellow)? I think yes. The colour is an extension, it doesn’t change the fundamental concept or behaviour of an integer number.<br>&gt; <br>&gt; I see extensions as a way to add functionality (and potentially data), but without affecting the core behaviour. If you wanted to change behaviour then you should use inheritance or composition to create something new. You can’t then use your own type for instances created by a library, unless it gives you a way to do that, the library would expect its own types to behave in a predictable way, similarly they should behave the same way when extended.<br>&gt; <br>&gt; <br>&gt; On Thu, 3 Nov 2016 at 15:14 Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Has anybody thought about the semantic issues of out-of-module extensions with stored properties apart from the implementation issues?<br>&gt; <br>&gt; Such properties could potentially wreak havoc with the semantics of the type being extended. How would these properties play nice with an existing definition of equality, for example? How can it be guaranteed that their value is consistent with the remaining state? And kept that way in case of mutability?<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; &gt; Am 15.10.2016 um 03:01 schrieb Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 9, 2016, at 3:43 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Let extensions introduce stored properties, but only in the same module as the type’s definition. Then, the compiler can just take any extensions into consideration when it’s determining the size of the type, just as if the properties had been declared in the type. Declaring stored properties on an extension outside of the type’s module results in a compiler error, exactly as today. This would, without any performance drawbacks, solve one of the big problems that people are hoping to solve via stored properties in extensions—the ability to organize members by protocol conformance.<br>&gt; &gt;<br>&gt; &gt; Yes please! A big strong +1 to this from me. I can think of several specific chunks of problem code that this would clean up immensely.<br>&gt; &gt;<br>&gt; &gt; Contra Karl in another message, it’s _in-module_ stored property extensions that I want most frequently. By far.<br>&gt; &gt;<br>&gt; &gt; It seems to me that Charles’s idea could be introduced as its own proposal. If out-of-module stored property extensions do eventually become feasible, then Charles’s proposal is a good stepping stone. If they never do, then his proposal has done no harm.<br>&gt; &gt;<br>&gt; &gt; I realize this probably falls into the post-ABI stability bucket, but I’d love to help write/support the proposal when its time comes.<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt;<br>&gt; &gt; Paul<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/440a83b4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>associated objects</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>October  6, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Chris<br>I am a bit slow to respond, please read inline, thanks.<br>&gt; On 1 Oct 2016, at 01:47, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Sep 30, 2016, at 2:51 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Is it possible to have best of (these completely different) both worlds? <br>&gt; <br></p><p>&gt; Yes, of course it is.  <br></p><p>&gt; Your email spends a lot of words<br>Does it? <br></p><p>&gt; trying to form a false dichotomy.<br>Well, sorry, thank you. but No, I don’t think so: <br>I am merely describing the advantages and <br>disadvantages of static programming languages. <br>It doesn’t mean it should be one or the other, just observing.<br>Just thinking about the future in years, not in weeks. <br>Even so, I still like Swift.<br></p><p>&gt; Swift can definitely have both awesome dynamic features while still having performance, predictability and safety.<br>Yes, I take it that it is possible to implement these. <br>Currently it is not possible to do meta programming in Swift, that is, create <br>arbitrary functions, properties and new classes<br>during run time. hypothetical along the lines as if it were so:<br></p><p>    // Warning! hypothetical as yet not compilable coding follows:<br></p><p>    let Monolith: Class?<br>    <br>    var classdefstring = &quot;parentclass: SpaceObject;&quot; +<br>            &quot;var l = 9.0; var h = 4.0; var  w = 1.0; &quot; +<br>            &quot;var color = &quot; + defaultMonolithColorStr   +<br>            &quot;;func volume() -&gt; Double { return l * w * h} “ +<br>            aStringWithAdditionalComponentDefinitions<br></p><p>    func defMonolithClass()<br>    {<br>        do  // try to define a class, NOT an instance.<br>        {<br>            try Monolith = Meta.defineClass(classdefstring)<br>        }<br>        catch Meta.classDefinitionError<br>        {<br>            // handle a possible class definition error<br>            // e.g. syntax errors. symbols not found etc.  <br>        }<br>        catch Meta.creationConflict<br>        {<br>            // class cannot be defined or redefined when instances of Monolith exist.<br>            // necessary?<br>        }<br></p><p>        do  // dynamically add components to the Monolith<br>        {<br>            try Meta.addPropertyTo( Monolith,&quot;mass&quot;,    3.4)<br>            try Meta.addPropertyTo( Monolith,&quot;physics&quot;, PhysicsBody)<br>            try Meta.addFunctionTo( Monolith, someFunctionDefinitionString)<br>        }<br>        catch Meta.ClassExtenderError<br>        {<br>            // handle the error<br>        }<br>        catch Meta.creationConflict<br>        {<br>            // class definition cannot be altered when instances of Monolith exist.<br>            // necessary? <br>        }<br>    }<br>    <br>    defMonolithClass()<br>    <br>    // Make an instance of the dynamically generated class<br>    public let mn = Monolith() <br>    <br>    let vol = mn.volume<br>    <br>    // One can remove after usage, normally ARC should take care of that.<br>    // unless one would wish to reinstate/redefine Monolith again.<br>    mn = nil       // remove instance<br></p><p>    Monolith = nil  // should throw an error when instances of Monolith are still around.<br></p><p>    defMonolithClass()  // again, possibly with other definition strings <br></p><p>    // Of course ARC should remove dynamic class defs automagically when no longer<br>    // needed. <br>    <br>There could be overloads of defining classes etc. using other methods than string wise declaration.. <br>Of course, Meta… for defining structs and other components could be made in a similar fashion.<br>I’d guess  that it might be very hard and complicated to implement meta creation similar to the above? <br>Probably needed the app to interact many times with a compiler present on the target OS/device? - <br>thereby making small pluggable “bricks”  <br>Just brainstorming here: I know nearly nothing of compiler construction.<br></p><p>&gt; <br>&gt;&gt; Would it be possible in Swift to have facilities to generate objects <br>&gt;&gt; dynamically at runtime? and, if desirable, how can such be implemented?<br>&gt; <br>&gt; Here’s an extant implementation that you can use today:<br>&gt; https://github.com/Zewo/Reflection &lt;https://github.com/Zewo/Reflection&gt;<br>Very complex code (to me, hard to read) . As far as I can see, it’s a clever hack but vulnerable because <br>depending completely on the underlying memory occupation and layout of an existing class definition?  <br>Totally new classes/structs etc. cannot be defined with it?<br>(like in the above hypothetical class def example)<br></p><p>&gt; <br>&gt; I’m sure it isn’t ideal, but it proves that it can be done.  When we have bandwidth to reevaluate this area from first principles, I’m sure we can make improvements on it.<br>Yeah, I guess it can be done, that would be great!<br>&gt; <br>&gt; I will grant you that Smalltalk is a beautiful language in its simplicity, but for that simplicity it makes many tradeoffs that we’re not willing to make.  <br>The only tradeoffs I can think of so far are:<br></p><p>  - Run time speed. in spite of precompiled methods etc Smalltalk is not so fast as compiled statical <br>programming language executables. However, the VMs are getting much better/ faster <br>these days. Dedicated hardware (processors) would really help too.<br></p><p> - Total freedom, but to me personally this is not a tradeoff at all…<br></p><p> - what else?  <br></p><p>&gt; We are willing to make the internal implementation of Swift complex if that means that we get a beautiful model for programmers -<br>&gt; one that preserves the virtues of safety-by-default,<br>Safety by default? to some extend, yes. However, my experience with many programming <br>languages is, that it almost doesn’t matter how much effort is given<br>to make a PL save. I am still traumatised by many [some words removed here]  <br>source code through all the years I had to work with <br>(of course only others are writing baaaaaaad code, naturally, I myself am perfect :o) <br></p><p>&gt; predictability, performance, and joy-to-develop-in.<br>Yes, I enjoy working with Swift very much as well, thank you (and others) for creating this language.<br>&gt; <br>&gt; The meme of “Swift can never (or will never) support dynamic features” is tired, and also wildly inaccurate.<br>That was a bit overcharged from me. I had that impression, being not too broadly informed in this meta stuff. <br>Met vriendelijke groeten, kind regards, one of your colleagues/friends from another time :o) <br>TedvG<br></p><p><br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161006/35103611/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
