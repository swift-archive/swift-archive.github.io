<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] Remove C-style for-loops with conditions and incrementers</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;Remove C-style for-loops with conditions and incrementers” begins now and runs through Thursday, December 10th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>	Cheers,<br>	Doug Gregor<br>	Review Manager<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20151207/fecb181d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] Remove C-style for-loops with conditions and incrementers</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>Review of SE-0007<br></p><p>* What is your evaluation of the proposal?<br></p><p>This is a sensible change. I am in favor of it.<br></p><p><br>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>In isolation, the problem appears too small to warrant a change — just a little cruft in the language, an unnecessary but mostly harmless remnant of Swift’s ancestry. The C-style for loop is not a common source of programmer error, and is easy for the compiler to implement.<br></p><p>However, in aggregate, cruft like this leads to language bloat and stagnation. In a garden, a single weed is not a problem, but never weeding is a significant problem.<br></p><p>We have a feature that is:<br></p><p>1. not widely used,<br>2. easily replaced with other languages features where it is used, and<br>3. inconsistent with the language’s general aesthetic.<br></p><p>Observation, theory, and taste agree. If this isn’t a feature to remove for the health of the language, then what is? If we do not pull this weed, then what weed would we ever pull?<br></p><p><br>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>1. Swift tends to favor concise language constructs over boilerplate code for common patterns (e.g. didSet, lazy, optional unwrapping conveniences). This makes the C-style for out of place for the two common cases, counting and collection iteration, both of which already have more Swift-like alternatives.<br></p><p>2. The ++ and — operators are already slated for removal, which makes the C-style for much less compelling.<br></p><p>3. Swift tends to encourage immutability. It’s a minor detail, but the fact that the C-style for rules out immutability for the index variable is particularly compelling to me:<br></p><p>    for i in 0..&lt;16   // i is immutable by default<br></p><p>    for let i = 0; i &lt; 16; i++  // doesn&#39;t work<br></p><p>4. The few cases raised on the list where C-style for might still be preferable over other loop constructs all involve subtle interaction between the iterator clause (third part of the “for”) and break/continue/return. When I’ve seen this kind of code in the wild, at least in my own experience, it (1) usually is brittle and in need of rewriting, and (2) tends to appear only in low-level system libraries and graphics-related bit-twiddling, neither of which seem like Swift’s areas of focus. (Swift’s favoring of explicit scalar type conversion and precision safety already make it ill-suited to low-level bit twiddling.)<br></p><p><br>* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Ruby does not have a C-style for loop. I’ve used Ruby extensively since 2007, and have not once felt that I wanted a C-style for.<br></p><p><br>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>An hour or two. I’ve followed the discussion on the mailing list. I did a programmatic search of all of my own Swift code; I’ve never used the C-style for in Swift.<br></p><p><br></p><p><br>&gt; On Dec 7, 2015, at 2:44 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Remove C-style for-loops with conditions and incrementers” begins now and runs through Thursday, December 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; 	Cheers,<br>&gt; 	Doug Gregor<br>&gt; 	Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/d842a05e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] Remove C-style for-loops with conditions and incrementers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December  9, 2015 at 09:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>Mild concern.  I am not opposed to removing C-style for loops, but I do think that it leaves a hole in the language that should be filled by some other means, and I would prefer to figure that out before removing a useful feature.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Not obviously so.  C-style for loops, while not particularly stylish, are “mostly harmless”.  That said, some of their functionality is duplicated in for … in loops, so there is some overlap that might be cleaned up.  Having a simpler language (if we can do so without compromising usability) is a good thing.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br></p><p>For … in loops are more Swifty, and we should encourage people to use them where appropriate.  However, they are significantly less versatile than C-style for loops.  My concerns, as a low-level library writer, are that:<br></p><p>- The loss of C-style for makes iterating backwards more complex than iterating forwards.  This asymmetry is unnatural.<br></p><p>- The loss of C-style for makes it significantly more complex to use strides that vary between iteration steps.<br></p><p>In particular, the available replacements for the second issue force one to split the “loop control” over multiple lines in e.g. a while loop:<br></p><p>	var i = initialValue<br>	// possible intermediate stuff<br>	while i &lt; terminalValue {<br>		// some loop contents<br>		i += update<br>	}<br></p><p>I have seen some proposals floated involving closures, but I don’t think any of these to pass the smell test.  One of the chief virtues of the C-style loop is that it lets one gather all of the loop control in one place, which makes reading complex code much, much easier (if we keep C-style for, I would strongly support something like &quot;for (let i = blah; … )” where i is immutable within the loop body for exactly this reason).<br></p><p>My biggest concern (the asymmetry of loops with stride -1) could be addressed by having a reasonable range operator for this case (&quot;N &gt;.. 0&quot; or similar).  I haven’t seen a really strong proposal yet for other loop structures, but I’m willing to write them off if we have a good story for -1 stride, which is the 99% case in my experience.<br></p><p>If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Every language I’ve used heavily either has a &quot;c-style-for” structure, or is so utterly foreign to Swift as to offer no practical guidance here.<br></p><p> How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve read all of the emails carefully, and spent a while looking for cases in my own code where I would really miss the current feature.<br></p><p>Thanks to everyone for taking time to contribute to this!<br>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/ba873f79/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>Review for SE-0007 Remove C-style for-loops with conditions and incrementers<br></p><p>https://github.com/apple/swift-evolution/blob/6e121f714bcbade5860aa74bdc3523a14a9cf0b8/proposals/0007-remove-c-style-for-loops.md<br></p><p><br># What is your evaluation of the proposal?<br></p><p>Even though I do not dislike the idea, I think the disappearance of the C-style for loop should at least be accompanied with decent migration measures. Nothing very convincing has been proposed in that regard. So I disagree with the proposal as it stands today.<br></p><p><br># Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>One of the argument is that this loop is rarely used. I tend to disagree: this loop exists in many other mainstream languages: code using it can be found everywhere. What would be a simple transliteration of an algorithm to port it to Swift can easily become a mess if you have to refactor the loop at the same time. This makes the delicate process more painful and error-prone.<br></p><p>Even if in theory it would make sense to refactor all C-style for loops with for-in or while loops, this is not always easy, or convenient, and most importantly it does not always result in more readable code.<br></p><p>I do agree the syntax is not great. It&#39;s not very intuitive and the readability is poor. It should ideally be replaced by something better. But using for-in and while, as they exist currently, does not cut it.<br></p><p><br># Does this proposal fit well with the feel and direction of Swift?<br></p><p>I would really like if the C-style for loop could be replaced with something more intuitive. And if it did, I would expect Swift to provide a migration path to remove C-style for loops and replace them by something equivalent. What kind of code is a migration tool going to generate for this proposal? This isn&#39;t addressed very clearly, and I suspect the results won&#39;t be so pretty.<br></p><p>You can&#39;t replace C-style for loops with for-in in the general case. Using a &quot;while&quot; loop will always be possible, but also much more verbose. For instance, take this loop iterating downward over i and j in lockstep:<br></p><p>	for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>		... loop body ...<br>	}<br></p><p>The only fully-compatible while loop that makes sense is this one:<br></p><p>	do {<br>		var i = 10<br>		var j = 20<br>		var first = true<br>		while true {<br>			if first { first = false }<br>			else { i -= 1; j -= 2 }<br>			guard i &gt; 0 &amp;&amp; j &gt; 0 else { break }<br>			... loop body ...<br>		}<br>	}<br></p><p>If the loop body contains a continue, it works. If the loop body mutates one of the loop variables, it works. If the loop throws, it works. If the outer scope has a variable with the same name, it works! There is no code duplication. But oh boy, the boilerplate!<br></p><p>Not all loops contain a continue, or need to mutate its loop variable, or throw. There is an abundance of simpler patterns that can apply to these particular cases. But any of these patterns based on a while loop are more fragile than a C-style for loop. Introduce one continue, or one throw, and the loop needs some refactoring to correctly maintain the loop state. The only robust loop pattern is the for-in loop, but its applicability is limited, especially when applied by an automated tool.<br></p><p>Therefore, to keep the same semantics, any migration tool should use as a replacement either a for-in (for simple forward iteration, the most common case), or the above while loop. Needless to say, nobody is going to be happy seeing a C-style for loop replaced by a while loop like above. There needs to be a better way to express that loop.<br></p><p>Don&#39;t forget that migration in this case is not only a Swift 2 to Swift 3 thing, it&#39;s also a foreign language to Swift 3 thing.<br></p><p><br># If you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>When I was learning programming, I used Pascal a lot. There was no equivalent to the C-style for loop. (There was no break, continue, or return either.) There was a for loop to iterate over a range of numbers, up or down, but sometime that for loop was not enough. So I learned to use variables to control the state of a while loop and express the condition for exiting the loop in term of those variables. The logic for that had to be scattered all across the loop body. This is what the equivalent while loop reminds me of.<br></p><p>The for loop from C is a power tool: it lets you express the loop control variables, the exit condition, and the prepare-the-next-iteration statement all together in one place, cleaning the loop body from the bookkeeping work, and properly handling special cases such as &quot;continue&quot;. It&#39;s a useful middle ground between the strongly abstracted for-in loop and the almost unstructured &quot;while&quot; loop.<br></p><p><br># How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read most messages on the mailing list, made a few proposals, found out a a couple of alternatives and figured out their limitations. I also remembered an experience with someone I worked with, who was better at math than at coding, and for whom a C-style for loop with all the inner working exposed would feel much more reassuring than a clever abstracted sequence type in a for-in loop.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 10, 2015 at 07:00:00pm</p></header><div class="content"><p>Nice review!<br></p><p>&gt; Am 10.12.2015 um 18:16 schrieb Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; You can&#39;t replace C-style for loops with for-in in the general case. Using a &quot;while&quot; loop will always be possible, but also much more verbose. For instance, take this loop iterating downward over i and j in lockstep:<br>&gt; <br>&gt; 	for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt; 		... loop body ...<br>&gt; 	}<br>&gt; <br>&gt; The only fully-compatible while loop that makes sense is this one:<br>&gt; <br>&gt; 	do {<br>&gt; 		var i = 10<br>&gt; 		var j = 20<br>&gt; 		var first = true<br>&gt; 		while true {<br>&gt; 			if first { first = false }<br>&gt; 			else { i -= 1; j -= 2 }<br>&gt; 			guard i &gt; 0 &amp;&amp; j &gt; 0 else { break }<br>&gt; 			... loop body ...<br>&gt; 		}<br>&gt; 	}<br></p><p><br>That is indeed quite ugly because of (a) the need to check for the first iteration in case of continue and (b) having the condition as guard within the loop and not as while-condition.<br></p><p>Another alternative using a while-loop might be extracting the loop body into a function (still not very nice but at least without checking for the first iteration and having the looping condition in its proper place):<br></p><p>do {<br>    func body(i: Int, _ j: Int) {<br>        if i % 2 == 0 { return } // simulating continue<br>        print (i, j)<br>    }<br>    var i = 10<br>    var j = 20<br>    while (i &gt; 0 &amp;&amp; j &gt; 0) {<br>        body(i, j)<br>        i -= 1<br>        j -= 2<br>    }<br>}<br>        <br>A nicer alternative would actually be the for-in loop:<br></p><p>for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>    if i % 2 == 0 { continue }<br>    print(i, j)<br>}<br></p><p>The problem here is that the parameter „to:“ of stride() is not named very intuitively. Its alternative „through:“ is easier to understand. <br>Maybe „to:“ should be renamed to „towards:“ or something like that.<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/358410a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 10, 2015 at 02:00:00pm</p></header><div class="content"><p>Le 10 déc. 2015 à 13:20, thorsten at portableinnovations.de a écrit :<br></p><p>&gt; do {<br>&gt;     func body(i: Int, _ j: Int) {<br>&gt;         if i % 2 == 0 { return } // simulating continue<br>&gt;         print (i, j)<br>&gt;     }<br>&gt;     var i = 10<br>&gt;     var j = 20<br>&gt;     while (i &gt; 0 &amp;&amp; j &gt; 0) {<br>&gt;         body(i, j)<br>&gt;         i -= 1<br>&gt;         j -= 2<br>&gt;     }<br>&gt; }<br></p><p>This is actually worse than the while loop I suggested. Now you can&#39;t break from the loop, nor return from the outer function, and continue has to be replaced by return.<br></p><p><br>&gt; A nicer alternative would actually be the for-in loop:<br>&gt; <br>&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;     if i % 2 == 0 { continue }<br>&gt;     print(i, j)<br>&gt; }<br></p><p>Nice. :-)<br></p><p>But depending on the perspective, this can be harder to read. You have to be familiar with zip and stride, as well as with sequence types in general, to understand what the above loop does. The C-style for loop version, or even the while loop version, is easier to interpret: you just look at the loop header and figure out how each value change over each iteration.<br></p><p>There&#39;s another reason someone could want to avoid the for-in version above: performance relies entirely on the optimiser inlining everything. There&#39;s a much higher risk of an unforeseen cost hiding somewhere when a loop is abstracted this way. Performance will be fine in most cases, but if for some reason the optimizer fails you and that loop really has to be fast, you&#39;ll need to rewrite the loop at a lower level.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 10.12.2015 um 20:57 schrieb Michel Fortin &lt;michel.fortin at michelf.ca&gt;:<br>&gt; <br>&gt;&gt; Le 10 déc. 2015 à 13:20, thorsten at portableinnovations.de a écrit :<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt;    func body(i: Int, _ j: Int) {<br>&gt;&gt;        if i % 2 == 0 { return } // simulating continue<br>&gt;&gt;        print (i, j)<br>&gt;&gt;    }<br>&gt;&gt;    var i = 10<br>&gt;&gt;    var j = 20<br>&gt;&gt;    while (i &gt; 0 &amp;&amp; j &gt; 0) {<br>&gt;&gt;        body(i, j)<br>&gt;&gt;        i -= 1<br>&gt;&gt;        j -= 2<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt; <br>&gt; This is actually worse than the while loop I suggested. Now you can&#39;t break from the loop, nor return from the outer function, and continue has to be replaced by return.<br></p><p>You are right. That&#39;s no good replacement.<br></p><p>&gt;&gt; A nicer alternative would actually be the for-in loop:<br>&gt;&gt; <br>&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt; <br>&gt; Nice. :-)<br>&gt; <br>&gt; But depending on the perspective, this can be harder to read. You have to be familiar with zip and stride, as well as with sequence types in general, to understand what the above loop does. The C-style for loop version, or even the while loop version, is easier to interpret: you just look at the loop header and figure out how each value change over each iteration.<br>&gt; <br>&gt; There&#39;s another reason someone could want to avoid the for-in version above: performance relies entirely on the optimiser inlining everything. There&#39;s a much higher risk of an unforeseen cost hiding somewhere when a loop is abstracted this way. Performance will be fine in most cases, but if for some reason the optimizer fails you and that loop really has to be fast, you&#39;ll need to rewrite the loop at a lower level.<br></p><p>Yes, performance is one thing neglected by the discussions and the proposal.<br>That just occurred to me and I&#39;m going to revoke my support for the proposal for these reasons.<br></p><p>-Thorsten <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; michel.fortin at michelf.ca<br>&gt; https://michelf.ca<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 10, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br></p><p>This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br></p><p>Is there any guarantee that these two loops have the exact same runtime performance?<br></p><p>for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>   if i % 2 == 0 { continue }<br>   print(i, j)<br>}<br></p><p>for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>   if i % 2 == 0 { continue }<br>   print(i, j)<br>}<br></p><p><br>And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br></p><p>These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/4ba44edd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt; <br>&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt; <br>&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br></p><p><br>In a quick and dirty test, the second is approximately 34% slower.<br></p><p>I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br></p><p>P<br></p><p><br></p><p>&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt; <br>&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt; <br>&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt; <br>&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt; <br>&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt; <br>&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/75daa9de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 10, 2015 at 03:00:00pm</p></header><div class="content"><p>Here’s my basic test case:<br></p><p>let first = 10000000<br>let second = 20000000<br></p><p>class LoopPerfTests: XCTestCase {<br>    <br>    func testZipStride() {<br>        self.measureBlock {<br>            var sum = 0<br>            for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>                if i % 2 == 0 { continue }<br>                sum += 1<br>            }<br>            print(sum)<br>        }<br>    }<br>    <br>    func testCStyleFor() {<br>        self.measureBlock {<br>            var sum = 0<br>            for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>                if i % 2 == 0 { continue }<br>                sum += 1<br>            }<br>            print(sum)<br>        }<br></p><p>    }<br></p><p>}<br></p><p>Non-optimized timings:<br>testCStyleFor - 0.126s<br>testZipStride - 2.189s<br></p><p>Optimized timings:<br>testCStyleFor - 0.008s<br>testZipStride - 0.015s<br></p><p>That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br></p><p>Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br></p><p>-David<br></p><p>&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt; <br>&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt; <br>&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt; <br>&gt; P<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt; <br>&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt; <br>&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt; <br>&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt; <br>&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/feb89cb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 10, 2015 at 11:00:00pm</p></header><div class="content"><p>Hold the presses.<br></p><p>David, I found the radical differences in our results troubling, so I did some digging. It turns out that the zip+stride code:<br></p><p>    var sum = 0<br>    for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>        if i % 2 == 0 { continue }<br>        sum += 1<br>    }<br></p><p>…runs much faster if you actually use both i and j inside the loop:<br></p><p>    var sum = 0<br>    for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>        if i % 2 == 0 { continue }<br>        sum += i-j<br>    }<br></p><p>Weird, right? This is with optimization on (default “production” build). It smells like a compiler quirk.<br></p><p>With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster. Also smells like a quirk. Am I doing something fantastically stupid in my code? Or maybe it’s just my idiosyncratic taste in indentation? :P<br></p><p>Here’s my test case, which was a command-line app with manual timing, followed by David’s dropped into the same harness, followed by David’s but with sum += i-j instead of sum += 1:<br></p><p>    https://gist.github.com/pcantrell/6bbe80e630d227ed0262 &lt;https://gist.github.com/pcantrell/6bbe80e630d227ed0262&gt;<br></p><p>Point is: no big performance difference here; even a performance advantage (that is probably a compiler artifact).<br></p><p>David and Thorsten, you might want to reconsider your reviews?<br></p><p>Results:<br></p><p>—————— Paul’s comparison ——————<br></p><p>zip+stride<br></p><p>  Iter 0: 0.519110977649689<br>  Iter 1: 0.503385007381439<br>  Iter 2: 0.503321051597595<br>  Iter 3: 0.485216021537781<br>  Iter 4: 0.524757027626038<br>  Iter 5: 0.478078007698059<br>  Iter 6: 0.503880977630615<br>  Iter 7: 0.498068988323212<br>  Iter 8: 0.485781013965607<br>         ——————————————<br>  Median: 0.524757027626038<br></p><p>C-style<br></p><p>  Iter 0: 0.85480797290802<br>  Iter 1: 0.879491031169891<br>  Iter 2: 0.851797997951508<br>  Iter 3: 0.836017966270447<br>  Iter 4: 0.863684952259064<br>  Iter 5: 0.837742984294891<br>  Iter 6: 0.839070022106171<br>  Iter 7: 0.849772989749908<br>  Iter 8: 0.819278955459595<br>         ——————————————<br>  Median: 0.863684952259064<br></p><p>Zip+stride takes 0.607579217692143x the time of C-style for<br></p><p>—————— David’s comparison ——————<br></p><p>zip+stride<br></p><p>  Iter 0: 1.15285503864288<br>  Iter 1: 1.1244450211525<br>  Iter 2: 1.24192994832993<br>  Iter 3: 1.02782195806503<br>  Iter 4: 1.13640999794006<br>  Iter 5: 1.15879601240158<br>  Iter 6: 1.12114900350571<br>  Iter 7: 1.21364599466324<br>  Iter 8: 1.10698300600052<br>         ——————————————<br>  Median: 1.13640999794006<br></p><p>C-style<br></p><p>  Iter 0: 0.375869989395142<br>  Iter 1: 0.371365010738373<br>  Iter 2: 0.356527984142303<br>  Iter 3: 0.384984970092773<br>  Iter 4: 0.367590010166168<br>  Iter 5: 0.365644037723541<br>  Iter 6: 0.384257972240448<br>  Iter 7: 0.379297018051147<br>  Iter 8: 0.363133013248444<br>         ——————————————<br>  Median: 0.367590010166168<br></p><p>Zip+stride takes 3.09151491202482x the time of C-style for<br></p><p>—————— David’s comparison, actually using indices in the loop ——————<br></p><p>zip+stride<br></p><p>  Iter 0: 0.328687965869904<br>  Iter 1: 0.332105994224548<br>  Iter 2: 0.336817979812622<br>  Iter 3: 0.321089029312134<br>  Iter 4: 0.338591992855072<br>  Iter 5: 0.348567008972168<br>  Iter 6: 0.34687602519989<br>  Iter 7: 0.34755402803421<br>  Iter 8: 0.341500997543335<br>         ——————————————<br>  Median: 0.338591992855072<br></p><p>C-style<br></p><p>  Iter 0: 0.422354996204376<br>  Iter 1: 0.427953958511353<br>  Iter 2: 0.403640985488892<br>  Iter 3: 0.415378987789154<br>  Iter 4: 0.403639018535614<br>  Iter 5: 0.416707038879395<br>  Iter 6: 0.415345013141632<br>  Iter 7: 0.417587995529175<br>  Iter 8: 0.415713012218475<br>         ——————————————<br>  Median: 0.403639018535614<br></p><p>Zip+stride takes 0.838848518865867x the time of C-style for<br></p><p>Program ended with exit code: 0<br></p><p>Cheers,<br></p><p>Paul<br></p><p>&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Here’s my basic test case:<br>&gt; <br>&gt; let first = 10000000<br>&gt; let second = 20000000<br>&gt; <br>&gt; class LoopPerfTests: XCTestCase {<br>&gt;     <br>&gt;     func testZipStride() {<br>&gt;         self.measureBlock {<br>&gt;             var sum = 0<br>&gt;             for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;                 if i % 2 == 0 { continue }<br>&gt;                 sum += 1<br>&gt;             }<br>&gt;             print(sum)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     func testCStyleFor() {<br>&gt;         self.measureBlock {<br>&gt;             var sum = 0<br>&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;                 if i % 2 == 0 { continue }<br>&gt;                 sum += 1<br>&gt;             }<br>&gt;             print(sum)<br>&gt;         }<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Non-optimized timings:<br>&gt; testCStyleFor - 0.126s<br>&gt; testZipStride - 2.189s<br>&gt; <br>&gt; Optimized timings:<br>&gt; testCStyleFor - 0.008s<br>&gt; testZipStride - 0.015s<br>&gt; <br>&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br>&gt; <br>&gt; Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt; <br>&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt;&gt; <br>&gt;&gt; P<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/ccfa190f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; David, I found the radical differences in our results troubling, so I did some digging. It turns out that the zip+stride code:<br>&gt; <br>&gt; …runs much faster if you actually use both i and j inside the loop:<br>&gt; <br>&gt; Weird, right? This is with optimization on (default “production” build). It smells like a compiler quirk.<br>&gt; <br>&gt; With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster. Also smells like a quirk. Am I doing something fantastically stupid in my code? Or maybe it’s just my idiosyncratic taste in indentation? :P<br></p><p>One problem: zip+stride suffers tremendously at -Onone. One test looked like this (normalized elapsed time; smaller is better)<br></p><p>  1.0  zip+stride -O<br>  1.2  for(;;) -O<br> 19.3  for(;;) -Onone<br>261.7  zip+stride -Onone<br></p><p>Presumably all of these can be improved with compiler work, but I don&#39;t know how far zip+stride can be pushed in the -Onone case.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/dbdf2e3c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>&gt;&gt; With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster.<br>&gt; <br>&gt; One problem: zip+stride suffers tremendously at -Onone. One test looked like this (normalized elapsed time; smaller is better)<br></p><p>Do we really care about -Onone performance? Doesn’t that flag specifically mean “I don’t care about performance?”<br></p><p>All kinds of Swift code incurs massive performance penalties with -Onone, but the core team hasn’t let that hold back the language. See the “results” section here, for example: http://www.jessesquires.com/apples-to-apples-part-two/<br></p><p>IMO, we should design languages around performance concerns only when a construct has an _inherent_ performance limitation. I’d say these timings results show pretty clearly that no such inherent limitation exists here.<br></p><p>Cheers, P<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/c54a763f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; Am 11.12.2015 um 06:12 schrieb Paul Cantrell &lt;cantrell at pobox.com&gt;:<br>&gt; <br>&gt; David and Thorsten, you might want to reconsider your reviews?<br></p><p>Sorry, no, not at the moment as these results are too quirky to be relied on. Furthermore Greg Parker showed problems with -Oone. Removing a language feature should be based on a more solid base than what we currently have.<br></p><p>-Thorsten<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 11, 2015 at 12:00:00am</p></header><div class="content"><p>I don’t know what you did, your gist 404s. <br></p><p>Here’s an update with the while-loop: https://gist.github.com/owensd/b438bea90075907fa6ec &lt;https://gist.github.com/owensd/b438bea90075907fa6ec&gt; and using both i and j within the loops. This is a simple OS X framework project with unit tests.<br></p><p>Debug Build:<br>testZipStride - 2.496s<br>testCStyleFor - 0.210s<br>testWhileLoop - 0.220s<br></p><p>Release Build:<br>testZipStride - 0.029s<br>testCStyleFor - 0.018s<br>testWhileLoop - 0.019s<br></p><p>I ran these tests from my MacBook Pro, the previous tests were from my iMac.<br></p><p>When you use the sum += (i - j) construct, I think all you are ending up with a hot-path that the optimizer can end up optimizing better (my guess is that the i-j turns into a constant expression - after all, the difference is always 1, but I don’t know enough about the SIL representation to confirm that). If you use a code path where that expression is not constant time (again, assuming my suspicion is correct), the zip+stride is against slower.<br></p><p>I would argue the following:<br></p><p>The code is not objectively easier to read or understand with the zip+stride construct (arguably, they are not even semantically equivalent).<br>The debug builds are prohibitively slower, especially in the context of high-performance requirement code (I’m doing a lot of prototyping Swift in the context of games, so yes, performance matters considerably).<br>The optimized builds are still slower than the for-in “equivalent&quot; functionality.<br>The optimizer is inconsistent, like all optimizers are (this is a simple truth, not a value judgement - optimizers are not magic, they are code that is run like any other code and can only do as well as they are coded under the conditions they are coded against), at actually producing similar results with code that ends up with slightly different shapes.<br>There is not functionally equivalent version of the code that I can write that is not more verbose, while requiring artificial scoping constructs, to achieve the same behavior.<br></p><p>So no, there is no evidence that I’ve seen to reconsider my opinion that this proposal should not be implemented. If there is evidence to show that my findings are incorrect or a poor summary of the general problem I am seeing, then of course I would reconsider my opinion.<br></p><p>-David<br></p><p>&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; Hold the presses.<br>&gt; <br>&gt; David, I found the radical differences in our results troubling, so I did some digging. It turns out that the zip+stride code:<br>&gt; <br>&gt;     var sum = 0<br>&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;         if i % 2 == 0 { continue }<br>&gt;         sum += 1<br>&gt;     }<br>&gt; <br>&gt; …runs much faster if you actually use both i and j inside the loop:<br>&gt; <br>&gt;     var sum = 0<br>&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;         if i % 2 == 0 { continue }<br>&gt;         sum += i-j<br>&gt;     }<br>&gt; <br>&gt; Weird, right? This is with optimization on (default “production” build). It smells like a compiler quirk.<br>&gt; <br>&gt; With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster. Also smells like a quirk. Am I doing something fantastically stupid in my code? Or maybe it’s just my idiosyncratic taste in indentation? :P<br>&gt; <br>&gt; Here’s my test case, which was a command-line app with manual timing, followed by David’s dropped into the same harness, followed by David’s but with sum += i-j instead of sum += 1:<br>&gt; <br>&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262 &lt;https://gist.github.com/pcantrell/6bbe80e630d227ed0262&gt;<br>&gt; <br>&gt; Point is: no big performance difference here; even a performance advantage (that is probably a compiler artifact).<br>&gt; <br>&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt; <br>&gt; Results:<br>&gt; <br>&gt; —————— Paul’s comparison ——————<br>&gt; <br>&gt; zip+stride<br>&gt; <br>&gt;   Iter 0: 0.519110977649689<br>&gt;   Iter 1: 0.503385007381439<br>&gt;   Iter 2: 0.503321051597595<br>&gt;   Iter 3: 0.485216021537781<br>&gt;   Iter 4: 0.524757027626038<br>&gt;   Iter 5: 0.478078007698059<br>&gt;   Iter 6: 0.503880977630615<br>&gt;   Iter 7: 0.498068988323212<br>&gt;   Iter 8: 0.485781013965607<br>&gt;          ——————————————<br>&gt;   Median: 0.524757027626038<br>&gt; <br>&gt; C-style<br>&gt; <br>&gt;   Iter 0: 0.85480797290802<br>&gt;   Iter 1: 0.879491031169891<br>&gt;   Iter 2: 0.851797997951508<br>&gt;   Iter 3: 0.836017966270447<br>&gt;   Iter 4: 0.863684952259064<br>&gt;   Iter 5: 0.837742984294891<br>&gt;   Iter 6: 0.839070022106171<br>&gt;   Iter 7: 0.849772989749908<br>&gt;   Iter 8: 0.819278955459595<br>&gt;          ——————————————<br>&gt;   Median: 0.863684952259064<br>&gt; <br>&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt; <br>&gt; —————— David’s comparison ——————<br>&gt; <br>&gt; zip+stride<br>&gt; <br>&gt;   Iter 0: 1.15285503864288<br>&gt;   Iter 1: 1.1244450211525<br>&gt;   Iter 2: 1.24192994832993<br>&gt;   Iter 3: 1.02782195806503<br>&gt;   Iter 4: 1.13640999794006<br>&gt;   Iter 5: 1.15879601240158<br>&gt;   Iter 6: 1.12114900350571<br>&gt;   Iter 7: 1.21364599466324<br>&gt;   Iter 8: 1.10698300600052<br>&gt;          ——————————————<br>&gt;   Median: 1.13640999794006<br>&gt; <br>&gt; C-style<br>&gt; <br>&gt;   Iter 0: 0.375869989395142<br>&gt;   Iter 1: 0.371365010738373<br>&gt;   Iter 2: 0.356527984142303<br>&gt;   Iter 3: 0.384984970092773<br>&gt;   Iter 4: 0.367590010166168<br>&gt;   Iter 5: 0.365644037723541<br>&gt;   Iter 6: 0.384257972240448<br>&gt;   Iter 7: 0.379297018051147<br>&gt;   Iter 8: 0.363133013248444<br>&gt;          ——————————————<br>&gt;   Median: 0.367590010166168<br>&gt; <br>&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt; <br>&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt; <br>&gt; zip+stride<br>&gt; <br>&gt;   Iter 0: 0.328687965869904<br>&gt;   Iter 1: 0.332105994224548<br>&gt;   Iter 2: 0.336817979812622<br>&gt;   Iter 3: 0.321089029312134<br>&gt;   Iter 4: 0.338591992855072<br>&gt;   Iter 5: 0.348567008972168<br>&gt;   Iter 6: 0.34687602519989<br>&gt;   Iter 7: 0.34755402803421<br>&gt;   Iter 8: 0.341500997543335<br>&gt;          ——————————————<br>&gt;   Median: 0.338591992855072<br>&gt; <br>&gt; C-style<br>&gt; <br>&gt;   Iter 0: 0.422354996204376<br>&gt;   Iter 1: 0.427953958511353<br>&gt;   Iter 2: 0.403640985488892<br>&gt;   Iter 3: 0.415378987789154<br>&gt;   Iter 4: 0.403639018535614<br>&gt;   Iter 5: 0.416707038879395<br>&gt;   Iter 6: 0.415345013141632<br>&gt;   Iter 7: 0.417587995529175<br>&gt;   Iter 8: 0.415713012218475<br>&gt;          ——————————————<br>&gt;   Median: 0.403639018535614<br>&gt; <br>&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt; <br>&gt; Program ended with exit code: 0<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here’s my basic test case:<br>&gt;&gt; <br>&gt;&gt; let first = 10000000<br>&gt;&gt; let second = 20000000<br>&gt;&gt; <br>&gt;&gt; class LoopPerfTests: XCTestCase {<br>&gt;&gt;     <br>&gt;&gt;     func testZipStride() {<br>&gt;&gt;         self.measureBlock {<br>&gt;&gt;             var sum = 0<br>&gt;&gt;             for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;                 sum += 1<br>&gt;&gt;             }<br>&gt;&gt;             print(sum)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func testCStyleFor() {<br>&gt;&gt;         self.measureBlock {<br>&gt;&gt;             var sum = 0<br>&gt;&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;                 sum += 1<br>&gt;&gt;             }<br>&gt;&gt;             print(sum)<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Non-optimized timings:<br>&gt;&gt; testCStyleFor - 0.126s<br>&gt;&gt; testZipStride - 2.189s<br>&gt;&gt; <br>&gt;&gt; Optimized timings:<br>&gt;&gt; testCStyleFor - 0.008s<br>&gt;&gt; testZipStride - 0.015s<br>&gt;&gt; <br>&gt;&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br>&gt;&gt; <br>&gt;&gt; Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/cc654edc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>Your revised results are now right in line with what I get in my test harness, so that’s reassuring!<br></p><p>I’d quibble with this:<br></p><p>&gt; The optimized builds are still slower than the for-in “equivalent” functionality.<br></p><p>That’s not an accurate summary. Depending on precisely what’s in the loop, the for-in flavor is clocking in anywhere from 80% slower to 20% faster.<br></p><p>None of this performance testing undercuts your entirely valid concerns about syntax. We have, I think, widespread agreement on the list that the C-style for is very rarely used in most Swift code in the wild — but if your usage patterns are unusual and you use it a lot, I can see why you’d be reluctant to part with it!<br></p><p>It’s a question, then, of whether it’s worth having a leaner language at the expense of making some less-common code more verbose when optimized. I’m not sure that any of the C-style audits people have done on the list have been games. Are there other game developers on the list using Swift who could do the audit on their code?<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Dec 11, 2015, at 2:33 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; I don’t know what you did, your gist 404s. <br>&gt; <br>&gt; Here’s an update with the while-loop: https://gist.github.com/owensd/b438bea90075907fa6ec &lt;https://gist.github.com/owensd/b438bea90075907fa6ec&gt; and using both i and j within the loops. This is a simple OS X framework project with unit tests.<br>&gt; <br>&gt; Debug Build:<br>&gt; testZipStride - 2.496s<br>&gt; testCStyleFor - 0.210s<br>&gt; testWhileLoop - 0.220s<br>&gt; <br>&gt; Release Build:<br>&gt; testZipStride - 0.029s<br>&gt; testCStyleFor - 0.018s<br>&gt; testWhileLoop - 0.019s<br>&gt; <br>&gt; I ran these tests from my MacBook Pro, the previous tests were from my iMac.<br>&gt; <br>&gt; When you use the sum += (i - j) construct, I think all you are ending up with a hot-path that the optimizer can end up optimizing better (my guess is that the i-j turns into a constant expression - after all, the difference is always 1, but I don’t know enough about the SIL representation to confirm that). If you use a code path where that expression is not constant time (again, assuming my suspicion is correct), the zip+stride is against slower.<br>&gt; <br>&gt; I would argue the following:<br>&gt; <br>&gt; The code is not objectively easier to read or understand with the zip+stride construct (arguably, they are not even semantically equivalent).<br>&gt; The debug builds are prohibitively slower, especially in the context of high-performance requirement code (I’m doing a lot of prototyping Swift in the context of games, so yes, performance matters considerably).<br>&gt; The optimized builds are still slower than the for-in “equivalent&quot; functionality.<br>&gt; The optimizer is inconsistent, like all optimizers are (this is a simple truth, not a value judgement - optimizers are not magic, they are code that is run like any other code and can only do as well as they are coded under the conditions they are coded against), at actually producing similar results with code that ends up with slightly different shapes.<br>&gt; There is not functionally equivalent version of the code that I can write that is not more verbose, while requiring artificial scoping constructs, to achieve the same behavior.<br>&gt; <br>&gt; So no, there is no evidence that I’ve seen to reconsider my opinion that this proposal should not be implemented. If there is evidence to show that my findings are incorrect or a poor summary of the general problem I am seeing, then of course I would reconsider my opinion.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hold the presses.<br>&gt;&gt; <br>&gt;&gt; David, I found the radical differences in our results troubling, so I did some digging. It turns out that the zip+stride code:<br>&gt;&gt; <br>&gt;&gt;     var sum = 0<br>&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;         sum += 1<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; …runs much faster if you actually use both i and j inside the loop:<br>&gt;&gt; <br>&gt;&gt;     var sum = 0<br>&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;         sum += i-j<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Weird, right? This is with optimization on (default “production” build). It smells like a compiler quirk.<br>&gt;&gt; <br>&gt;&gt; With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster. Also smells like a quirk. Am I doing something fantastically stupid in my code? Or maybe it’s just my idiosyncratic taste in indentation? :P<br>&gt;&gt; <br>&gt;&gt; Here’s my test case, which was a command-line app with manual timing, followed by David’s dropped into the same harness, followed by David’s but with sum += i-j instead of sum += 1:<br>&gt;&gt; <br>&gt;&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262 &lt;https://gist.github.com/pcantrell/6bbe80e630d227ed0262&gt;<br>&gt;&gt; <br>&gt;&gt; Point is: no big performance difference here; even a performance advantage (that is probably a compiler artifact).<br>&gt;&gt; <br>&gt;&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt;&gt; <br>&gt;&gt; Results:<br>&gt;&gt; <br>&gt;&gt; —————— Paul’s comparison ——————<br>&gt;&gt; <br>&gt;&gt; zip+stride<br>&gt;&gt; <br>&gt;&gt;   Iter 0: 0.519110977649689<br>&gt;&gt;   Iter 1: 0.503385007381439<br>&gt;&gt;   Iter 2: 0.503321051597595<br>&gt;&gt;   Iter 3: 0.485216021537781<br>&gt;&gt;   Iter 4: 0.524757027626038<br>&gt;&gt;   Iter 5: 0.478078007698059<br>&gt;&gt;   Iter 6: 0.503880977630615<br>&gt;&gt;   Iter 7: 0.498068988323212<br>&gt;&gt;   Iter 8: 0.485781013965607<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.524757027626038<br>&gt;&gt; <br>&gt;&gt; C-style<br>&gt;&gt; <br>&gt;&gt;   Iter 0: 0.85480797290802<br>&gt;&gt;   Iter 1: 0.879491031169891<br>&gt;&gt;   Iter 2: 0.851797997951508<br>&gt;&gt;   Iter 3: 0.836017966270447<br>&gt;&gt;   Iter 4: 0.863684952259064<br>&gt;&gt;   Iter 5: 0.837742984294891<br>&gt;&gt;   Iter 6: 0.839070022106171<br>&gt;&gt;   Iter 7: 0.849772989749908<br>&gt;&gt;   Iter 8: 0.819278955459595<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.863684952259064<br>&gt;&gt; <br>&gt;&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt;&gt; <br>&gt;&gt; —————— David’s comparison ——————<br>&gt;&gt; <br>&gt;&gt; zip+stride<br>&gt;&gt; <br>&gt;&gt;   Iter 0: 1.15285503864288<br>&gt;&gt;   Iter 1: 1.1244450211525<br>&gt;&gt;   Iter 2: 1.24192994832993<br>&gt;&gt;   Iter 3: 1.02782195806503<br>&gt;&gt;   Iter 4: 1.13640999794006<br>&gt;&gt;   Iter 5: 1.15879601240158<br>&gt;&gt;   Iter 6: 1.12114900350571<br>&gt;&gt;   Iter 7: 1.21364599466324<br>&gt;&gt;   Iter 8: 1.10698300600052<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 1.13640999794006<br>&gt;&gt; <br>&gt;&gt; C-style<br>&gt;&gt; <br>&gt;&gt;   Iter 0: 0.375869989395142<br>&gt;&gt;   Iter 1: 0.371365010738373<br>&gt;&gt;   Iter 2: 0.356527984142303<br>&gt;&gt;   Iter 3: 0.384984970092773<br>&gt;&gt;   Iter 4: 0.367590010166168<br>&gt;&gt;   Iter 5: 0.365644037723541<br>&gt;&gt;   Iter 6: 0.384257972240448<br>&gt;&gt;   Iter 7: 0.379297018051147<br>&gt;&gt;   Iter 8: 0.363133013248444<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.367590010166168<br>&gt;&gt; <br>&gt;&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt;&gt; <br>&gt;&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt;&gt; <br>&gt;&gt; zip+stride<br>&gt;&gt; <br>&gt;&gt;   Iter 0: 0.328687965869904<br>&gt;&gt;   Iter 1: 0.332105994224548<br>&gt;&gt;   Iter 2: 0.336817979812622<br>&gt;&gt;   Iter 3: 0.321089029312134<br>&gt;&gt;   Iter 4: 0.338591992855072<br>&gt;&gt;   Iter 5: 0.348567008972168<br>&gt;&gt;   Iter 6: 0.34687602519989<br>&gt;&gt;   Iter 7: 0.34755402803421<br>&gt;&gt;   Iter 8: 0.341500997543335<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.338591992855072<br>&gt;&gt; <br>&gt;&gt; C-style<br>&gt;&gt; <br>&gt;&gt;   Iter 0: 0.422354996204376<br>&gt;&gt;   Iter 1: 0.427953958511353<br>&gt;&gt;   Iter 2: 0.403640985488892<br>&gt;&gt;   Iter 3: 0.415378987789154<br>&gt;&gt;   Iter 4: 0.403639018535614<br>&gt;&gt;   Iter 5: 0.416707038879395<br>&gt;&gt;   Iter 6: 0.415345013141632<br>&gt;&gt;   Iter 7: 0.417587995529175<br>&gt;&gt;   Iter 8: 0.415713012218475<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.403639018535614<br>&gt;&gt; <br>&gt;&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt;&gt; <br>&gt;&gt; Program ended with exit code: 0<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s my basic test case:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let first = 10000000<br>&gt;&gt;&gt; let second = 20000000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class LoopPerfTests: XCTestCase {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func testZipStride() {<br>&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;             for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func testCStyleFor() {<br>&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-optimized timings:<br>&gt;&gt;&gt; testCStyleFor - 0.126s<br>&gt;&gt;&gt; testZipStride - 2.189s<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Optimized timings:<br>&gt;&gt;&gt; testCStyleFor - 0.008s<br>&gt;&gt;&gt; testZipStride - 0.015s<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/6dd0366e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>For many of these number-crunching performance-stretching scenarios, many I suggest once again, that if you&#39;re doing serious number crunching that Accelerate or similar approaches is to be preferred? As for c-style-for vs while, the two are mechanically convertible.<br></p><p><br></p><p>Where heavy performance is not required, for-in is more readable, maintainable, and optimizable to a sufficient extent that I do not see it as a bar to conversion.<br></p><p>-- E<br></p><p><br>&gt; On Dec 11, 2015, at 8:44 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Your revised results are now right in line with what I get in my test harness, so that’s reassuring!<br>&gt; <br>&gt; I’d quibble with this:<br>&gt; <br>&gt;&gt; The optimized builds are still slower than the for-in “equivalent” functionality.<br>&gt; <br>&gt; That’s not an accurate summary. Depending on precisely what’s in the loop, the for-in flavor is clocking in anywhere from 80% slower to 20% faster.<br>&gt; <br>&gt; None of this performance testing undercuts your entirely valid concerns about syntax. We have, I think, widespread agreement on the list that the C-style for is very rarely used in most Swift code in the wild — but if your usage patterns are unusual and you use it a lot, I can see why you’d be reluctant to part with it!<br>&gt; <br>&gt; It’s a question, then, of whether it’s worth having a leaner language at the expense of making some less-common code more verbose when optimized. I’m not sure that any of the C-style audits people have done on the list have been games. Are there other game developers on the list using Swift who could do the audit on their code?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 2:33 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don’t know what you did, your gist 404s. <br>&gt;&gt; <br>&gt;&gt; Here’s an update with the while-loop: https://gist.github.com/owensd/b438bea90075907fa6ec &lt;https://gist.github.com/owensd/b438bea90075907fa6ec&gt; and using both i and j within the loops. This is a simple OS X framework project with unit tests.<br>&gt;&gt; <br>&gt;&gt; Debug Build:<br>&gt;&gt; testZipStride - 2.496s<br>&gt;&gt; testCStyleFor - 0.210s<br>&gt;&gt; testWhileLoop - 0.220s<br>&gt;&gt; <br>&gt;&gt; Release Build:<br>&gt;&gt; testZipStride - 0.029s<br>&gt;&gt; testCStyleFor - 0.018s<br>&gt;&gt; testWhileLoop - 0.019s<br>&gt;&gt; <br>&gt;&gt; I ran these tests from my MacBook Pro, the previous tests were from my iMac.<br>&gt;&gt; <br>&gt;&gt; When you use the sum += (i - j) construct, I think all you are ending up with a hot-path that the optimizer can end up optimizing better (my guess is that the i-j turns into a constant expression - after all, the difference is always 1, but I don’t know enough about the SIL representation to confirm that). If you use a code path where that expression is not constant time (again, assuming my suspicion is correct), the zip+stride is against slower.<br>&gt;&gt; <br>&gt;&gt; I would argue the following:<br>&gt;&gt; <br>&gt;&gt; The code is not objectively easier to read or understand with the zip+stride construct (arguably, they are not even semantically equivalent).<br>&gt;&gt; The debug builds are prohibitively slower, especially in the context of high-performance requirement code (I’m doing a lot of prototyping Swift in the context of games, so yes, performance matters considerably).<br>&gt;&gt; The optimized builds are still slower than the for-in “equivalent&quot; functionality.<br>&gt;&gt; The optimizer is inconsistent, like all optimizers are (this is a simple truth, not a value judgement - optimizers are not magic, they are code that is run like any other code and can only do as well as they are coded under the conditions they are coded against), at actually producing similar results with code that ends up with slightly different shapes.<br>&gt;&gt; There is not functionally equivalent version of the code that I can write that is not more verbose, while requiring artificial scoping constructs, to achieve the same behavior.<br>&gt;&gt; <br>&gt;&gt; So no, there is no evidence that I’ve seen to reconsider my opinion that this proposal should not be implemented. If there is evidence to show that my findings are incorrect or a poor summary of the general problem I am seeing, then of course I would reconsider my opinion.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hold the presses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David, I found the radical differences in our results troubling, so I did some digging. It turns out that the zip+stride code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var sum = 0<br>&gt;&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;&gt;         sum += 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …runs much faster if you actually use both i and j inside the loop:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var sum = 0<br>&gt;&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;&gt;         sum += i-j<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Weird, right? This is with optimization on (default “production” build). It smells like a compiler quirk.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster. Also smells like a quirk. Am I doing something fantastically stupid in my code? Or maybe it’s just my idiosyncratic taste in indentation? :P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s my test case, which was a command-line app with manual timing, followed by David’s dropped into the same harness, followed by David’s but with sum += i-j instead of sum += 1:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262 &lt;https://gist.github.com/pcantrell/6bbe80e630d227ed0262&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Point is: no big performance difference here; even a performance advantage (that is probably a compiler artifact).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Results:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —————— Paul’s comparison ——————<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Iter 0: 0.519110977649689<br>&gt;&gt;&gt;   Iter 1: 0.503385007381439<br>&gt;&gt;&gt;   Iter 2: 0.503321051597595<br>&gt;&gt;&gt;   Iter 3: 0.485216021537781<br>&gt;&gt;&gt;   Iter 4: 0.524757027626038<br>&gt;&gt;&gt;   Iter 5: 0.478078007698059<br>&gt;&gt;&gt;   Iter 6: 0.503880977630615<br>&gt;&gt;&gt;   Iter 7: 0.498068988323212<br>&gt;&gt;&gt;   Iter 8: 0.485781013965607<br>&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;   Median: 0.524757027626038<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; C-style<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Iter 0: 0.85480797290802<br>&gt;&gt;&gt;   Iter 1: 0.879491031169891<br>&gt;&gt;&gt;   Iter 2: 0.851797997951508<br>&gt;&gt;&gt;   Iter 3: 0.836017966270447<br>&gt;&gt;&gt;   Iter 4: 0.863684952259064<br>&gt;&gt;&gt;   Iter 5: 0.837742984294891<br>&gt;&gt;&gt;   Iter 6: 0.839070022106171<br>&gt;&gt;&gt;   Iter 7: 0.849772989749908<br>&gt;&gt;&gt;   Iter 8: 0.819278955459595<br>&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;   Median: 0.863684952259064<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —————— David’s comparison ——————<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Iter 0: 1.15285503864288<br>&gt;&gt;&gt;   Iter 1: 1.1244450211525<br>&gt;&gt;&gt;   Iter 2: 1.24192994832993<br>&gt;&gt;&gt;   Iter 3: 1.02782195806503<br>&gt;&gt;&gt;   Iter 4: 1.13640999794006<br>&gt;&gt;&gt;   Iter 5: 1.15879601240158<br>&gt;&gt;&gt;   Iter 6: 1.12114900350571<br>&gt;&gt;&gt;   Iter 7: 1.21364599466324<br>&gt;&gt;&gt;   Iter 8: 1.10698300600052<br>&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;   Median: 1.13640999794006<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; C-style<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Iter 0: 0.375869989395142<br>&gt;&gt;&gt;   Iter 1: 0.371365010738373<br>&gt;&gt;&gt;   Iter 2: 0.356527984142303<br>&gt;&gt;&gt;   Iter 3: 0.384984970092773<br>&gt;&gt;&gt;   Iter 4: 0.367590010166168<br>&gt;&gt;&gt;   Iter 5: 0.365644037723541<br>&gt;&gt;&gt;   Iter 6: 0.384257972240448<br>&gt;&gt;&gt;   Iter 7: 0.379297018051147<br>&gt;&gt;&gt;   Iter 8: 0.363133013248444<br>&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;   Median: 0.367590010166168<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Iter 0: 0.328687965869904<br>&gt;&gt;&gt;   Iter 1: 0.332105994224548<br>&gt;&gt;&gt;   Iter 2: 0.336817979812622<br>&gt;&gt;&gt;   Iter 3: 0.321089029312134<br>&gt;&gt;&gt;   Iter 4: 0.338591992855072<br>&gt;&gt;&gt;   Iter 5: 0.348567008972168<br>&gt;&gt;&gt;   Iter 6: 0.34687602519989<br>&gt;&gt;&gt;   Iter 7: 0.34755402803421<br>&gt;&gt;&gt;   Iter 8: 0.341500997543335<br>&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;   Median: 0.338591992855072<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; C-style<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   Iter 0: 0.422354996204376<br>&gt;&gt;&gt;   Iter 1: 0.427953958511353<br>&gt;&gt;&gt;   Iter 2: 0.403640985488892<br>&gt;&gt;&gt;   Iter 3: 0.415378987789154<br>&gt;&gt;&gt;   Iter 4: 0.403639018535614<br>&gt;&gt;&gt;   Iter 5: 0.416707038879395<br>&gt;&gt;&gt;   Iter 6: 0.415345013141632<br>&gt;&gt;&gt;   Iter 7: 0.417587995529175<br>&gt;&gt;&gt;   Iter 8: 0.415713012218475<br>&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;   Median: 0.403639018535614<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Program ended with exit code: 0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s my basic test case:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let first = 10000000<br>&gt;&gt;&gt;&gt; let second = 20000000<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class LoopPerfTests: XCTestCase {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     func testZipStride() {<br>&gt;&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;&gt;             for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     func testCStyleFor() {<br>&gt;&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-optimized timings:<br>&gt;&gt;&gt;&gt; testCStyleFor - 0.126s<br>&gt;&gt;&gt;&gt; testZipStride - 2.189s<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Optimized timings:<br>&gt;&gt;&gt;&gt; testCStyleFor - 0.008s<br>&gt;&gt;&gt;&gt; testZipStride - 0.015s<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; P<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/52d98443/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2015-12-08 at 3.54.37 PM.png<br>Type: image/png<br>Size: 93414 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/52d98443/attachment.png&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>If Swift is to be a systems language someday, then we also need to be able to write (parts of) Accelerate in Swift.<br></p><p>– Steve<br></p><p>&gt; On Dec 11, 2015, at 11:27 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For many of these number-crunching performance-stretching scenarios, many I suggest once again, that if you&#39;re doing serious number crunching that Accelerate or similar approaches is to be preferred? As for c-style-for vs while, the two are mechanically convertible.<br>&gt; <br>&gt; &lt;Screen Shot 2015-12-08 at 3.54.37 PM.png&gt;<br>&gt; <br>&gt; Where heavy performance is not required, for-in is more readable, maintainable, and optimizable to a sufficient extent that I do not see it as a bar to conversion.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 8:44 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Your revised results are now right in line with what I get in my test harness, so that’s reassuring!<br>&gt;&gt; <br>&gt;&gt; I’d quibble with this:<br>&gt;&gt; <br>&gt;&gt;&gt; The optimized builds are still slower than the for-in “equivalent” functionality.<br>&gt;&gt; <br>&gt;&gt; That’s not an accurate summary. Depending on precisely what’s in the loop, the for-in flavor is clocking in anywhere from 80% slower to 20% faster.<br>&gt;&gt; <br>&gt;&gt; None of this performance testing undercuts your entirely valid concerns about syntax. We have, I think, widespread agreement on the list that the C-style for is very rarely used in most Swift code in the wild — but if your usage patterns are unusual and you use it a lot, I can see why you’d be reluctant to part with it!<br>&gt;&gt; <br>&gt;&gt; It’s a question, then, of whether it’s worth having a leaner language at the expense of making some less-common code more verbose when optimized. I’m not sure that any of the C-style audits people have done on the list have been games. Are there other game developers on the list using Swift who could do the audit on their code?<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 2:33 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know what you did, your gist 404s. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s an update with the while-loop: https://gist.github.com/owensd/b438bea90075907fa6ec &lt;https://gist.github.com/owensd/b438bea90075907fa6ec&gt; and using both i and j within the loops. This is a simple OS X framework project with unit tests.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Debug Build:<br>&gt;&gt;&gt; testZipStride - 2.496s<br>&gt;&gt;&gt; testCStyleFor - 0.210s<br>&gt;&gt;&gt; testWhileLoop - 0.220s<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Release Build:<br>&gt;&gt;&gt; testZipStride - 0.029s<br>&gt;&gt;&gt; testCStyleFor - 0.018s<br>&gt;&gt;&gt; testWhileLoop - 0.019s<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I ran these tests from my MacBook Pro, the previous tests were from my iMac.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you use the sum += (i - j) construct, I think all you are ending up with a hot-path that the optimizer can end up optimizing better (my guess is that the i-j turns into a constant expression - after all, the difference is always 1, but I don’t know enough about the SIL representation to confirm that). If you use a code path where that expression is not constant time (again, assuming my suspicion is correct), the zip+stride is against slower.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would argue the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The code is not objectively easier to read or understand with the zip+stride construct (arguably, they are not even semantically equivalent).<br>&gt;&gt;&gt; The debug builds are prohibitively slower, especially in the context of high-performance requirement code (I’m doing a lot of prototyping Swift in the context of games, so yes, performance matters considerably).<br>&gt;&gt;&gt; The optimized builds are still slower than the for-in “equivalent&quot; functionality.<br>&gt;&gt;&gt; The optimizer is inconsistent, like all optimizers are (this is a simple truth, not a value judgement - optimizers are not magic, they are code that is run like any other code and can only do as well as they are coded under the conditions they are coded against), at actually producing similar results with code that ends up with slightly different shapes.<br>&gt;&gt;&gt; There is not functionally equivalent version of the code that I can write that is not more verbose, while requiring artificial scoping constructs, to achieve the same behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So no, there is no evidence that I’ve seen to reconsider my opinion that this proposal should not be implemented. If there is evidence to show that my findings are incorrect or a poor summary of the general problem I am seeing, then of course I would reconsider my opinion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hold the presses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David, I found the radical differences in our results troubling, so I did some digging. It turns out that the zip+stride code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var sum = 0<br>&gt;&gt;&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;         sum += 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …runs much faster if you actually use both i and j inside the loop:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var sum = 0<br>&gt;&gt;&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;         sum += i-j<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Weird, right? This is with optimization on (default “production” build). It smells like a compiler quirk.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster. Also smells like a quirk. Am I doing something fantastically stupid in my code? Or maybe it’s just my idiosyncratic taste in indentation? :P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s my test case, which was a command-line app with manual timing, followed by David’s dropped into the same harness, followed by David’s but with sum += i-j instead of sum += 1:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262 &lt;https://gist.github.com/pcantrell/6bbe80e630d227ed0262&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Point is: no big performance difference here; even a performance advantage (that is probably a compiler artifact).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Results:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— Paul’s comparison ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.519110977649689<br>&gt;&gt;&gt;&gt;   Iter 1: 0.503385007381439<br>&gt;&gt;&gt;&gt;   Iter 2: 0.503321051597595<br>&gt;&gt;&gt;&gt;   Iter 3: 0.485216021537781<br>&gt;&gt;&gt;&gt;   Iter 4: 0.524757027626038<br>&gt;&gt;&gt;&gt;   Iter 5: 0.478078007698059<br>&gt;&gt;&gt;&gt;   Iter 6: 0.503880977630615<br>&gt;&gt;&gt;&gt;   Iter 7: 0.498068988323212<br>&gt;&gt;&gt;&gt;   Iter 8: 0.485781013965607<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.524757027626038<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.85480797290802<br>&gt;&gt;&gt;&gt;   Iter 1: 0.879491031169891<br>&gt;&gt;&gt;&gt;   Iter 2: 0.851797997951508<br>&gt;&gt;&gt;&gt;   Iter 3: 0.836017966270447<br>&gt;&gt;&gt;&gt;   Iter 4: 0.863684952259064<br>&gt;&gt;&gt;&gt;   Iter 5: 0.837742984294891<br>&gt;&gt;&gt;&gt;   Iter 6: 0.839070022106171<br>&gt;&gt;&gt;&gt;   Iter 7: 0.849772989749908<br>&gt;&gt;&gt;&gt;   Iter 8: 0.819278955459595<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.863684952259064<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— David’s comparison ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 1.15285503864288<br>&gt;&gt;&gt;&gt;   Iter 1: 1.1244450211525<br>&gt;&gt;&gt;&gt;   Iter 2: 1.24192994832993<br>&gt;&gt;&gt;&gt;   Iter 3: 1.02782195806503<br>&gt;&gt;&gt;&gt;   Iter 4: 1.13640999794006<br>&gt;&gt;&gt;&gt;   Iter 5: 1.15879601240158<br>&gt;&gt;&gt;&gt;   Iter 6: 1.12114900350571<br>&gt;&gt;&gt;&gt;   Iter 7: 1.21364599466324<br>&gt;&gt;&gt;&gt;   Iter 8: 1.10698300600052<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 1.13640999794006<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.375869989395142<br>&gt;&gt;&gt;&gt;   Iter 1: 0.371365010738373<br>&gt;&gt;&gt;&gt;   Iter 2: 0.356527984142303<br>&gt;&gt;&gt;&gt;   Iter 3: 0.384984970092773<br>&gt;&gt;&gt;&gt;   Iter 4: 0.367590010166168<br>&gt;&gt;&gt;&gt;   Iter 5: 0.365644037723541<br>&gt;&gt;&gt;&gt;   Iter 6: 0.384257972240448<br>&gt;&gt;&gt;&gt;   Iter 7: 0.379297018051147<br>&gt;&gt;&gt;&gt;   Iter 8: 0.363133013248444<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.367590010166168<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.328687965869904<br>&gt;&gt;&gt;&gt;   Iter 1: 0.332105994224548<br>&gt;&gt;&gt;&gt;   Iter 2: 0.336817979812622<br>&gt;&gt;&gt;&gt;   Iter 3: 0.321089029312134<br>&gt;&gt;&gt;&gt;   Iter 4: 0.338591992855072<br>&gt;&gt;&gt;&gt;   Iter 5: 0.348567008972168<br>&gt;&gt;&gt;&gt;   Iter 6: 0.34687602519989<br>&gt;&gt;&gt;&gt;   Iter 7: 0.34755402803421<br>&gt;&gt;&gt;&gt;   Iter 8: 0.341500997543335<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.338591992855072<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.422354996204376<br>&gt;&gt;&gt;&gt;   Iter 1: 0.427953958511353<br>&gt;&gt;&gt;&gt;   Iter 2: 0.403640985488892<br>&gt;&gt;&gt;&gt;   Iter 3: 0.415378987789154<br>&gt;&gt;&gt;&gt;   Iter 4: 0.403639018535614<br>&gt;&gt;&gt;&gt;   Iter 5: 0.416707038879395<br>&gt;&gt;&gt;&gt;   Iter 6: 0.415345013141632<br>&gt;&gt;&gt;&gt;   Iter 7: 0.417587995529175<br>&gt;&gt;&gt;&gt;   Iter 8: 0.415713012218475<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.403639018535614<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Program ended with exit code: 0<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Paul<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here’s my basic test case:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let first = 10000000<br>&gt;&gt;&gt;&gt;&gt; let second = 20000000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class LoopPerfTests: XCTestCase {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     func testZipStride() {<br>&gt;&gt;&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;&gt;&gt;             for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     func testCStyleFor() {<br>&gt;&gt;&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;&gt;&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Non-optimized timings:<br>&gt;&gt;&gt;&gt;&gt; testCStyleFor - 0.126s<br>&gt;&gt;&gt;&gt;&gt; testZipStride - 2.189s<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Optimized timings:<br>&gt;&gt;&gt;&gt;&gt; testCStyleFor - 0.008s<br>&gt;&gt;&gt;&gt;&gt; testZipStride - 0.015s<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; P<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/9271536e/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>On Dec 11, 2015, at 9:27 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>For many of these number-crunching performance-stretching scenarios, many I suggest once again, that if you&#39;re doing serious number crunching that Accelerate (or similar approaches) is to be preferred? As for c-style-for vs while, the two are mechanically convertible: http://imgur.com/G4qxING &lt;http://imgur.com/G4qxING&gt; Where heavy performance is not required, for-in is more readable and maintainable. And it is still optimizable.<br></p><p>Let me close with three points, one new, two from my previous input on this matter:<br>* Optimization specifics: I&#39;m not sure that -Onone optimization performance for 2.x should determine whether a feature is or is not in 3.x.<br>* Extreme coding: I prefer to refactor unnecessarily complex code and eliminate edge case abuse over retaining archaic control-flow patterns.<br>* Reactionary preservation:  If the ultimate goal is to program in C, the C compiler is not going away<br></p><p>-- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 8:44 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Your revised results are now right in line with what I get in my test harness, so that’s reassuring!<br>&gt;&gt; <br>&gt;&gt; I’d quibble with this:<br>&gt;&gt; <br>&gt;&gt;&gt; The optimized builds are still slower than the for-in “equivalent” functionality.<br>&gt;&gt; <br>&gt;&gt; That’s not an accurate summary. Depending on precisely what’s in the loop, the for-in flavor is clocking in anywhere from 80% slower to 20% faster.<br>&gt;&gt; <br>&gt;&gt; None of this performance testing undercuts your entirely valid concerns about syntax. We have, I think, widespread agreement on the list that the C-style for is very rarely used in most Swift code in the wild — but if your usage patterns are unusual and you use it a lot, I can see why you’d be reluctant to part with it!<br>&gt;&gt; <br>&gt;&gt; It’s a question, then, of whether it’s worth having a leaner language at the expense of making some less-common code more verbose when optimized. I’m not sure that any of the C-style audits people have done on the list have been games. Are there other game developers on the list using Swift who could do the audit on their code?<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 2:33 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know what you did, your gist 404s. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s an update with the while-loop: https://gist.github.com/owensd/b438bea90075907fa6ec &lt;https://gist.github.com/owensd/b438bea90075907fa6ec&gt; and using both i and j within the loops. This is a simple OS X framework project with unit tests.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Debug Build:<br>&gt;&gt;&gt; testZipStride - 2.496s<br>&gt;&gt;&gt; testCStyleFor - 0.210s<br>&gt;&gt;&gt; testWhileLoop - 0.220s<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Release Build:<br>&gt;&gt;&gt; testZipStride - 0.029s<br>&gt;&gt;&gt; testCStyleFor - 0.018s<br>&gt;&gt;&gt; testWhileLoop - 0.019s<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I ran these tests from my MacBook Pro, the previous tests were from my iMac.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you use the sum += (i - j) construct, I think all you are ending up with a hot-path that the optimizer can end up optimizing better (my guess is that the i-j turns into a constant expression - after all, the difference is always 1, but I don’t know enough about the SIL representation to confirm that). If you use a code path where that expression is not constant time (again, assuming my suspicion is correct), the zip+stride is against slower.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would argue the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The code is not objectively easier to read or understand with the zip+stride construct (arguably, they are not even semantically equivalent).<br>&gt;&gt;&gt; The debug builds are prohibitively slower, especially in the context of high-performance requirement code (I’m doing a lot of prototyping Swift in the context of games, so yes, performance matters considerably).<br>&gt;&gt;&gt; The optimized builds are still slower than the for-in “equivalent&quot; functionality.<br>&gt;&gt;&gt; The optimizer is inconsistent, like all optimizers are (this is a simple truth, not a value judgement - optimizers are not magic, they are code that is run like any other code and can only do as well as they are coded under the conditions they are coded against), at actually producing similar results with code that ends up with slightly different shapes.<br>&gt;&gt;&gt; There is not functionally equivalent version of the code that I can write that is not more verbose, while requiring artificial scoping constructs, to achieve the same behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So no, there is no evidence that I’ve seen to reconsider my opinion that this proposal should not be implemented. If there is evidence to show that my findings are incorrect or a poor summary of the general problem I am seeing, then of course I would reconsider my opinion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hold the presses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David, I found the radical differences in our results troubling, so I did some digging. It turns out that the zip+stride code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var sum = 0<br>&gt;&gt;&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;         sum += 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …runs much faster if you actually use both i and j inside the loop:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var sum = 0<br>&gt;&gt;&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;         sum += i-j<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Weird, right? This is with optimization on (default “production” build). It smells like a compiler quirk.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster. Also smells like a quirk. Am I doing something fantastically stupid in my code? Or maybe it’s just my idiosyncratic taste in indentation? :P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s my test case, which was a command-line app with manual timing, followed by David’s dropped into the same harness, followed by David’s but with sum += i-j instead of sum += 1:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262 &lt;https://gist.github.com/pcantrell/6bbe80e630d227ed0262&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Point is: no big performance difference here; even a performance advantage (that is probably a compiler artifact).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Results:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— Paul’s comparison ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.519110977649689<br>&gt;&gt;&gt;&gt;   Iter 1: 0.503385007381439<br>&gt;&gt;&gt;&gt;   Iter 2: 0.503321051597595<br>&gt;&gt;&gt;&gt;   Iter 3: 0.485216021537781<br>&gt;&gt;&gt;&gt;   Iter 4: 0.524757027626038<br>&gt;&gt;&gt;&gt;   Iter 5: 0.478078007698059<br>&gt;&gt;&gt;&gt;   Iter 6: 0.503880977630615<br>&gt;&gt;&gt;&gt;   Iter 7: 0.498068988323212<br>&gt;&gt;&gt;&gt;   Iter 8: 0.485781013965607<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.524757027626038<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.85480797290802<br>&gt;&gt;&gt;&gt;   Iter 1: 0.879491031169891<br>&gt;&gt;&gt;&gt;   Iter 2: 0.851797997951508<br>&gt;&gt;&gt;&gt;   Iter 3: 0.836017966270447<br>&gt;&gt;&gt;&gt;   Iter 4: 0.863684952259064<br>&gt;&gt;&gt;&gt;   Iter 5: 0.837742984294891<br>&gt;&gt;&gt;&gt;   Iter 6: 0.839070022106171<br>&gt;&gt;&gt;&gt;   Iter 7: 0.849772989749908<br>&gt;&gt;&gt;&gt;   Iter 8: 0.819278955459595<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.863684952259064<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— David’s comparison ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 1.15285503864288<br>&gt;&gt;&gt;&gt;   Iter 1: 1.1244450211525<br>&gt;&gt;&gt;&gt;   Iter 2: 1.24192994832993<br>&gt;&gt;&gt;&gt;   Iter 3: 1.02782195806503<br>&gt;&gt;&gt;&gt;   Iter 4: 1.13640999794006<br>&gt;&gt;&gt;&gt;   Iter 5: 1.15879601240158<br>&gt;&gt;&gt;&gt;   Iter 6: 1.12114900350571<br>&gt;&gt;&gt;&gt;   Iter 7: 1.21364599466324<br>&gt;&gt;&gt;&gt;   Iter 8: 1.10698300600052<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 1.13640999794006<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.375869989395142<br>&gt;&gt;&gt;&gt;   Iter 1: 0.371365010738373<br>&gt;&gt;&gt;&gt;   Iter 2: 0.356527984142303<br>&gt;&gt;&gt;&gt;   Iter 3: 0.384984970092773<br>&gt;&gt;&gt;&gt;   Iter 4: 0.367590010166168<br>&gt;&gt;&gt;&gt;   Iter 5: 0.365644037723541<br>&gt;&gt;&gt;&gt;   Iter 6: 0.384257972240448<br>&gt;&gt;&gt;&gt;   Iter 7: 0.379297018051147<br>&gt;&gt;&gt;&gt;   Iter 8: 0.363133013248444<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.367590010166168<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.328687965869904<br>&gt;&gt;&gt;&gt;   Iter 1: 0.332105994224548<br>&gt;&gt;&gt;&gt;   Iter 2: 0.336817979812622<br>&gt;&gt;&gt;&gt;   Iter 3: 0.321089029312134<br>&gt;&gt;&gt;&gt;   Iter 4: 0.338591992855072<br>&gt;&gt;&gt;&gt;   Iter 5: 0.348567008972168<br>&gt;&gt;&gt;&gt;   Iter 6: 0.34687602519989<br>&gt;&gt;&gt;&gt;   Iter 7: 0.34755402803421<br>&gt;&gt;&gt;&gt;   Iter 8: 0.341500997543335<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.338591992855072<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.422354996204376<br>&gt;&gt;&gt;&gt;   Iter 1: 0.427953958511353<br>&gt;&gt;&gt;&gt;   Iter 2: 0.403640985488892<br>&gt;&gt;&gt;&gt;   Iter 3: 0.415378987789154<br>&gt;&gt;&gt;&gt;   Iter 4: 0.403639018535614<br>&gt;&gt;&gt;&gt;   Iter 5: 0.416707038879395<br>&gt;&gt;&gt;&gt;   Iter 6: 0.415345013141632<br>&gt;&gt;&gt;&gt;   Iter 7: 0.417587995529175<br>&gt;&gt;&gt;&gt;   Iter 8: 0.415713012218475<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.403639018535614<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Program ended with exit code: 0<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Paul<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here’s my basic test case:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let first = 10000000<br>&gt;&gt;&gt;&gt;&gt; let second = 20000000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class LoopPerfTests: XCTestCase {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     func testZipStride() {<br>&gt;&gt;&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;&gt;&gt;             for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     func testCStyleFor() {<br>&gt;&gt;&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;&gt;&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Non-optimized timings:<br>&gt;&gt;&gt;&gt;&gt; testCStyleFor - 0.126s<br>&gt;&gt;&gt;&gt;&gt; testZipStride - 2.189s<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Optimized timings:<br>&gt;&gt;&gt;&gt;&gt; testCStyleFor - 0.008s<br>&gt;&gt;&gt;&gt;&gt; testZipStride - 0.015s<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; P<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/2f994a9b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>I should note that I agree that performance is mainly a red herring.  There is likely some optimizer work to be done, but unless the optimizer guys speak up and say it’s infeasible, I don’t think it’s a major concern.<br></p><p>What does concern me is that the mechanical translation into a while loop is strictly worse from the standpoint of code readability and maintenance.  The only great virtue of c-style-for is that all of the loop control is in a single place, which makes it easy to find and study.  None of the proposals for replacing it that I’ve seen floated[1] have that feature (which is literally the only thing that it has going for it, in my book).<br></p><p>The proposed while-loop is especially painful, as not only does it split the control structure into three source locations (one of them at the end of the loop), but it also loses scoping of the iteration variable.<br></p><p>– Steve<br></p><p>[1] ok, except for proposals that are just mechanical translations of semicolons into keywords like:<br></p><p>	for let i=0 while i&lt;N step i+=2 {<br>	}<br></p><p>&gt; On Dec 11, 2015, at 11:27 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For many of these number-crunching performance-stretching scenarios, many I suggest once again, that if you&#39;re doing serious number crunching that Accelerate or similar approaches is to be preferred? As for c-style-for vs while, the two are mechanically convertible.<br>&gt; <br>&gt; &lt;Screen Shot 2015-12-08 at 3.54.37 PM.png&gt;<br>&gt; <br>&gt; Where heavy performance is not required, for-in is more readable, maintainable, and optimizable to a sufficient extent that I do not see it as a bar to conversion.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 8:44 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Your revised results are now right in line with what I get in my test harness, so that’s reassuring!<br>&gt;&gt; <br>&gt;&gt; I’d quibble with this:<br>&gt;&gt; <br>&gt;&gt;&gt; The optimized builds are still slower than the for-in “equivalent” functionality.<br>&gt;&gt; <br>&gt;&gt; That’s not an accurate summary. Depending on precisely what’s in the loop, the for-in flavor is clocking in anywhere from 80% slower to 20% faster.<br>&gt;&gt; <br>&gt;&gt; None of this performance testing undercuts your entirely valid concerns about syntax. We have, I think, widespread agreement on the list that the C-style for is very rarely used in most Swift code in the wild — but if your usage patterns are unusual and you use it a lot, I can see why you’d be reluctant to part with it!<br>&gt;&gt; <br>&gt;&gt; It’s a question, then, of whether it’s worth having a leaner language at the expense of making some less-common code more verbose when optimized. I’m not sure that any of the C-style audits people have done on the list have been games. Are there other game developers on the list using Swift who could do the audit on their code?<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 2:33 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know what you did, your gist 404s. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s an update with the while-loop: https://gist.github.com/owensd/b438bea90075907fa6ec &lt;https://gist.github.com/owensd/b438bea90075907fa6ec&gt; and using both i and j within the loops. This is a simple OS X framework project with unit tests.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Debug Build:<br>&gt;&gt;&gt; testZipStride - 2.496s<br>&gt;&gt;&gt; testCStyleFor - 0.210s<br>&gt;&gt;&gt; testWhileLoop - 0.220s<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Release Build:<br>&gt;&gt;&gt; testZipStride - 0.029s<br>&gt;&gt;&gt; testCStyleFor - 0.018s<br>&gt;&gt;&gt; testWhileLoop - 0.019s<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I ran these tests from my MacBook Pro, the previous tests were from my iMac.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you use the sum += (i - j) construct, I think all you are ending up with a hot-path that the optimizer can end up optimizing better (my guess is that the i-j turns into a constant expression - after all, the difference is always 1, but I don’t know enough about the SIL representation to confirm that). If you use a code path where that expression is not constant time (again, assuming my suspicion is correct), the zip+stride is against slower.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would argue the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The code is not objectively easier to read or understand with the zip+stride construct (arguably, they are not even semantically equivalent).<br>&gt;&gt;&gt; The debug builds are prohibitively slower, especially in the context of high-performance requirement code (I’m doing a lot of prototyping Swift in the context of games, so yes, performance matters considerably).<br>&gt;&gt;&gt; The optimized builds are still slower than the for-in “equivalent&quot; functionality.<br>&gt;&gt;&gt; The optimizer is inconsistent, like all optimizers are (this is a simple truth, not a value judgement - optimizers are not magic, they are code that is run like any other code and can only do as well as they are coded under the conditions they are coded against), at actually producing similar results with code that ends up with slightly different shapes.<br>&gt;&gt;&gt; There is not functionally equivalent version of the code that I can write that is not more verbose, while requiring artificial scoping constructs, to achieve the same behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So no, there is no evidence that I’ve seen to reconsider my opinion that this proposal should not be implemented. If there is evidence to show that my findings are incorrect or a poor summary of the general problem I am seeing, then of course I would reconsider my opinion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hold the presses.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David, I found the radical differences in our results troubling, so I did some digging. It turns out that the zip+stride code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var sum = 0<br>&gt;&gt;&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;         sum += 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …runs much faster if you actually use both i and j inside the loop:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var sum = 0<br>&gt;&gt;&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;         sum += i-j<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Weird, right? This is with optimization on (default “production” build). It smells like a compiler quirk.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With that tweak, the zip+stride approach actually clocks in faster than the C-style for. Yes, you read that right: faster. Also smells like a quirk. Am I doing something fantastically stupid in my code? Or maybe it’s just my idiosyncratic taste in indentation? :P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s my test case, which was a command-line app with manual timing, followed by David’s dropped into the same harness, followed by David’s but with sum += i-j instead of sum += 1:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262 &lt;https://gist.github.com/pcantrell/6bbe80e630d227ed0262&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Point is: no big performance difference here; even a performance advantage (that is probably a compiler artifact).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Results:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— Paul’s comparison ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.519110977649689<br>&gt;&gt;&gt;&gt;   Iter 1: 0.503385007381439<br>&gt;&gt;&gt;&gt;   Iter 2: 0.503321051597595<br>&gt;&gt;&gt;&gt;   Iter 3: 0.485216021537781<br>&gt;&gt;&gt;&gt;   Iter 4: 0.524757027626038<br>&gt;&gt;&gt;&gt;   Iter 5: 0.478078007698059<br>&gt;&gt;&gt;&gt;   Iter 6: 0.503880977630615<br>&gt;&gt;&gt;&gt;   Iter 7: 0.498068988323212<br>&gt;&gt;&gt;&gt;   Iter 8: 0.485781013965607<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.524757027626038<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.85480797290802<br>&gt;&gt;&gt;&gt;   Iter 1: 0.879491031169891<br>&gt;&gt;&gt;&gt;   Iter 2: 0.851797997951508<br>&gt;&gt;&gt;&gt;   Iter 3: 0.836017966270447<br>&gt;&gt;&gt;&gt;   Iter 4: 0.863684952259064<br>&gt;&gt;&gt;&gt;   Iter 5: 0.837742984294891<br>&gt;&gt;&gt;&gt;   Iter 6: 0.839070022106171<br>&gt;&gt;&gt;&gt;   Iter 7: 0.849772989749908<br>&gt;&gt;&gt;&gt;   Iter 8: 0.819278955459595<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.863684952259064<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— David’s comparison ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 1.15285503864288<br>&gt;&gt;&gt;&gt;   Iter 1: 1.1244450211525<br>&gt;&gt;&gt;&gt;   Iter 2: 1.24192994832993<br>&gt;&gt;&gt;&gt;   Iter 3: 1.02782195806503<br>&gt;&gt;&gt;&gt;   Iter 4: 1.13640999794006<br>&gt;&gt;&gt;&gt;   Iter 5: 1.15879601240158<br>&gt;&gt;&gt;&gt;   Iter 6: 1.12114900350571<br>&gt;&gt;&gt;&gt;   Iter 7: 1.21364599466324<br>&gt;&gt;&gt;&gt;   Iter 8: 1.10698300600052<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 1.13640999794006<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.375869989395142<br>&gt;&gt;&gt;&gt;   Iter 1: 0.371365010738373<br>&gt;&gt;&gt;&gt;   Iter 2: 0.356527984142303<br>&gt;&gt;&gt;&gt;   Iter 3: 0.384984970092773<br>&gt;&gt;&gt;&gt;   Iter 4: 0.367590010166168<br>&gt;&gt;&gt;&gt;   Iter 5: 0.365644037723541<br>&gt;&gt;&gt;&gt;   Iter 6: 0.384257972240448<br>&gt;&gt;&gt;&gt;   Iter 7: 0.379297018051147<br>&gt;&gt;&gt;&gt;   Iter 8: 0.363133013248444<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.367590010166168<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; zip+stride<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.328687965869904<br>&gt;&gt;&gt;&gt;   Iter 1: 0.332105994224548<br>&gt;&gt;&gt;&gt;   Iter 2: 0.336817979812622<br>&gt;&gt;&gt;&gt;   Iter 3: 0.321089029312134<br>&gt;&gt;&gt;&gt;   Iter 4: 0.338591992855072<br>&gt;&gt;&gt;&gt;   Iter 5: 0.348567008972168<br>&gt;&gt;&gt;&gt;   Iter 6: 0.34687602519989<br>&gt;&gt;&gt;&gt;   Iter 7: 0.34755402803421<br>&gt;&gt;&gt;&gt;   Iter 8: 0.341500997543335<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.338591992855072<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; C-style<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Iter 0: 0.422354996204376<br>&gt;&gt;&gt;&gt;   Iter 1: 0.427953958511353<br>&gt;&gt;&gt;&gt;   Iter 2: 0.403640985488892<br>&gt;&gt;&gt;&gt;   Iter 3: 0.415378987789154<br>&gt;&gt;&gt;&gt;   Iter 4: 0.403639018535614<br>&gt;&gt;&gt;&gt;   Iter 5: 0.416707038879395<br>&gt;&gt;&gt;&gt;   Iter 6: 0.415345013141632<br>&gt;&gt;&gt;&gt;   Iter 7: 0.417587995529175<br>&gt;&gt;&gt;&gt;   Iter 8: 0.415713012218475<br>&gt;&gt;&gt;&gt;          ——————————————<br>&gt;&gt;&gt;&gt;   Median: 0.403639018535614<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Program ended with exit code: 0<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Paul<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here’s my basic test case:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let first = 10000000<br>&gt;&gt;&gt;&gt;&gt; let second = 20000000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class LoopPerfTests: XCTestCase {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     func testZipStride() {<br>&gt;&gt;&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;&gt;&gt;             for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     func testCStyleFor() {<br>&gt;&gt;&gt;&gt;&gt;         self.measureBlock {<br>&gt;&gt;&gt;&gt;&gt;             var sum = 0<br>&gt;&gt;&gt;&gt;&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;                 sum += 1<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;             print(sum)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Non-optimized timings:<br>&gt;&gt;&gt;&gt;&gt; testCStyleFor - 0.126s<br>&gt;&gt;&gt;&gt;&gt; testZipStride - 2.189s<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Optimized timings:<br>&gt;&gt;&gt;&gt;&gt; testCStyleFor - 0.008s<br>&gt;&gt;&gt;&gt;&gt; testZipStride - 0.015s<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; P<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/89cdaa1c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 8:27 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As for c-style-for vs while, the two are mechanically convertible.<br></p><p>This is provably false and has been demonstrated, but here is an example of it again: <br></p><p>    var sum = 0<br>    for var i = 10 /* expr1 */; i &gt; 0 /* expr2 */; i -= 1 /* expr3 */ {<br>        if i % 2 == 0 { continue } // statement<br>        sum += 1                   // statement<br>    }<br>    print(sum)<br></p><p><br>    var sum = 0<br>    var i = 10 // expr1<br>    while i &gt; 0 /* expr2 */ {<br>        if i % 2 == 0 { continue } // statement<br>        sum += 1                   // statement<br>        <br>        i -= 1 // expr3<br>    }<br>    print(sum)<br></p><p>It’s not just a mechanical conversion; consideration for early loop-exits and continuations need to be made as well. The rote conversion for the while version above is an infinite loop. Not only that, expr1 now leaks variables into a scope that is no longer contained within the loop. <br></p><p>&gt; Where heavy performance is not required, for-in is more readable, maintainable, and optimizable to a sufficient extent that I do not see it as a bar to conversion.<br></p><p>This is a pure philosophical difference that I don’t think we’ll agree on. The injection of types are required to make for-in constructs work with the hope that the optimizer can clean all of this up later. This is fundamentally the same claim that C++ makes with it’s zero-cost abstraction. Mike Action has some great talks on YouTube that demonstrate many of the real-world problems he runs into.<br></p><p>Should the for ;; construct be used for all loop iteration? No, I don’t think so. But we shouldn’t make the claim that the while-loop is an equivalent form, because it’s not. Can it be used to mimic the functionality? Of course, but not in a mechanical conversion like you suggest. Care has to be taken that the statements don’t essentially branch and an artificial scope needs to be added. <br></p><p>    if true {<br>        var sum = 0<br>        var i = 10 // expr1<br>        while i &gt; 0 /* expr2 */ {<br>            if i % 2 == 0 { continue } // statement<br>            sum += 1                   // statement<br>        <br>            i -= 1 // expr3<br>        }<br>    }<br>    print(sum)<br></p><p>And then there is this:<br></p><p>&gt; Performance is definitely a consideration; we already reverted a pull request that remove C-style fors from the standard library. I believe Andy is currently looking into where the regressions come from. stride(...) performing poorly seems like something we should fix regardless, since that&#39;s arguably the idiomatic way to write such loops and ought to perform well. I agree we should investigate ways to ensure common loops over ranges or strides perform reasonably at -Onone if we move forward with this.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/cf4b5d38/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>David, the <br></p><p>if true {<br>        <br>}<br></p><p>scope mechanism can be accomplished with <br></p><p>do {<br>        <br>}<br></p><p>Nonetheless, I would agree that the point remains that the while loop equivalent is more difficult to read (and write) and maintain. I would argue perhaps somewhat controversially that the loop that should go is the while loop, as it has a strict subset of the functionality of the C style for loop.<br></p><p>Why not allow each of the three expressions to be optional?<br></p><p>for var i = 0 while i &lt; 5 step i += 1  {<br></p><p>or <br></p><p>while someCondition() { <br></p><p>or <br></p><p>for var i = 0 step i += 1 {<br></p><p>or <br></p><p>for var i = 0 while someOtherCondition() {<br></p><p><br>The mechanical conversion of for to while that you proposed below demonstrates that there is a purpose to the C style for loop features, why not allow them to be optional?<br></p><p>Tyler<br></p><p>&gt; On Dec 11, 2015, at 9:18 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 8:27 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As for c-style-for vs while, the two are mechanically convertible.<br>&gt; <br>&gt; This is provably false and has been demonstrated, but here is an example of it again: <br>&gt; <br>&gt;     var sum = 0<br>&gt;     for var i = 10 /* expr1 */; i &gt; 0 /* expr2 */; i -= 1 /* expr3 */ {<br>&gt;         if i % 2 == 0 { continue } // statement<br>&gt;         sum += 1                   // statement<br>&gt;     }<br>&gt;     print(sum)<br>&gt; <br>&gt; <br>&gt;     var sum = 0<br>&gt;     var i = 10 // expr1<br>&gt;     while i &gt; 0 /* expr2 */ {<br>&gt;         if i % 2 == 0 { continue } // statement<br>&gt;         sum += 1                   // statement<br>&gt;         <br>&gt;         i -= 1 // expr3<br>&gt;     }<br>&gt;     print(sum)<br>&gt; <br>&gt; It’s not just a mechanical conversion; consideration for early loop-exits and continuations need to be made as well. The rote conversion for the while version above is an infinite loop. Not only that, expr1 now leaks variables into a scope that is no longer contained within the loop. <br>&gt; <br>&gt;&gt; Where heavy performance is not required, for-in is more readable, maintainable, and optimizable to a sufficient extent that I do not see it as a bar to conversion.<br>&gt; <br>&gt; This is a pure philosophical difference that I don’t think we’ll agree on. The injection of types are required to make for-in constructs work with the hope that the optimizer can clean all of this up later. This is fundamentally the same claim that C++ makes with it’s zero-cost abstraction. Mike Action has some great talks on YouTube that demonstrate many of the real-world problems he runs into.<br>&gt; <br>&gt; Should the for ;; construct be used for all loop iteration? No, I don’t think so. But we shouldn’t make the claim that the while-loop is an equivalent form, because it’s not. Can it be used to mimic the functionality? Of course, but not in a mechanical conversion like you suggest. Care has to be taken that the statements don’t essentially branch and an artificial scope needs to be added. <br>&gt; <br>&gt;     if true {<br>&gt;         var sum = 0<br>&gt;         var i = 10 // expr1<br>&gt;         while i &gt; 0 /* expr2 */ {<br>&gt;             if i % 2 == 0 { continue } // statement<br>&gt;             sum += 1                   // statement<br>&gt;         <br>&gt;             i -= 1 // expr3<br>&gt;         }<br>&gt;     }<br>&gt;     print(sum)<br>&gt; <br>&gt; And then there is this:<br>&gt; <br>&gt;&gt; Performance is definitely a consideration; we already reverted a pull request that remove C-style fors from the standard library. I believe Andy is currently looking into where the regressions come from. stride(...) performing poorly seems like something we should fix regardless, since that&#39;s arguably the idiomatic way to write such loops and ought to perform well. I agree we should investigate ways to ensure common loops over ranges or strides perform reasonably at -Onone if we move forward with this.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/5347c41e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 12, 2015 at 10:00:00am</p></header><div class="content"><p>&gt;&gt; As for c-style-for vs while, the two are mechanically convertible.<br>&gt; <br>&gt; This is provably false and has been demonstrated, but here is an example of it again: <br>&gt; <br>&gt;     var sum = 0<br>&gt;     for var i = 10 /* expr1 */; i &gt; 0 /* expr2 */; i -= 1 /* expr3 */ {<br>&gt;         if i % 2 == 0 { continue } // statement<br>&gt;         sum += 1                   // statement<br>&gt;     }<br>&gt;     print(sum)<br>&gt; <br>&gt; <br>&gt;     var sum = 0<br>&gt;     var i = 10 // expr1<br>&gt;     while i &gt; 0 /* expr2 */ {<br>&gt;         if i % 2 == 0 { continue } // statement<br>&gt;         sum += 1                   // statement<br>&gt;         <br>&gt;         i -= 1 // expr3<br>&gt;     }<br>&gt;     print(sum)<br>&gt; <br>&gt; It’s not just a mechanical conversion; consideration for early loop-exits and continuations need to be made as well. The rote conversion for the while version above is an infinite loop. Not only that, expr1 now leaks variables into a scope that is no longer contained within the loop. <br></p><p>You know, Perl *makes* it mechanically convertible by adding a continue {} block after the while {} loop. The continue {} block is run between the loop body and the condition, so it’s skipped by `break` (well, `last`) and other early constructs that leave the loop, but not `continue` (spelled `next` there). Maybe something along those lines would help us here by making the loss of `for` more palatable. (Although that does kind of defeat the purpose of removing this syntax…)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>This does not take continue into account which would then require a<br>duplication of expr3.<br>It would also change the scope of variables defined in expr1<br>potentially causing<br>collisions or unexpected shadowing.<br></p><p>On Fri, Dec 11, 2015 at 5:27 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; For many of these number-crunching performance-stretching scenarios, many<br>&gt; I suggest once again, that if you&#39;re doing serious number crunching that<br>&gt; Accelerate or similar approaches is to be preferred? As for c-style-for vs<br>&gt; while, the two are mechanically convertible.<br>&gt;<br>&gt;<br>&gt; Where heavy performance is not required, for-in is more readable,<br>&gt; maintainable, and optimizable to a sufficient extent that I do not see it<br>&gt; as a bar to conversion.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Dec 11, 2015, at 8:44 AM, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Your revised results are now right in line with what I get in my test<br>&gt; harness, so that’s reassuring!<br>&gt;<br>&gt; I’d quibble with this:<br>&gt;<br>&gt;<br>&gt;    1. The optimized builds are still slower than the for-in “equivalent”<br>&gt;    functionality.<br>&gt;<br>&gt;<br>&gt; That’s not an accurate summary. Depending on precisely what’s in the loop,<br>&gt; the for-in flavor is clocking in anywhere from 80% slower to 20% *faster*.<br>&gt;<br>&gt; None of this performance testing undercuts your entirely valid concerns<br>&gt; about syntax. We have, I think, widespread agreement on the list that the<br>&gt; C-style for is very rarely used in most Swift code in the wild — but if<br>&gt; your usage patterns are unusual and you use it a lot, I can see why you’d<br>&gt; be reluctant to part with it!<br>&gt;<br>&gt; It’s a question, then, of whether it’s worth having a leaner language at<br>&gt; the expense of making some less-common code more verbose when optimized.<br>&gt; I’m not sure that any of the C-style audits people have done on the list<br>&gt; have been games. Are there other game developers on the list using Swift<br>&gt; who could do the audit on their code?<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt;<br>&gt; On Dec 11, 2015, at 2:33 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;<br>&gt; I don’t know what you did, your gist 404s.<br>&gt;<br>&gt; Here’s an update with the while-loop:<br>&gt; https://gist.github.com/owensd/b438bea90075907fa6ec and using both i and<br>&gt; j within the loops. This is a simple OS X framework project with unit tests.<br>&gt;<br>&gt; *Debug Build:*<br>&gt;<br>&gt;    - testZipStride - 2.496s<br>&gt;    - testCStyleFor - 0.210s<br>&gt;    - testWhileLoop - 0.220s<br>&gt;<br>&gt;<br>&gt; *Release Build:*<br>&gt;<br>&gt;    - testZipStride - 0.029s<br>&gt;    - testCStyleFor - 0.018s<br>&gt;    - testWhileLoop - 0.019s<br>&gt;<br>&gt;<br>&gt; I ran these tests from my MacBook Pro, the previous tests were from my<br>&gt; iMac.<br>&gt;<br>&gt; When you use the sum += (i - j) construct, I think all you are ending up<br>&gt; with a hot-path that the optimizer can end up optimizing better (my guess<br>&gt; is that the i-j turns into a constant expression - after all, the<br>&gt; difference is always 1, but I don’t know enough about the SIL<br>&gt; representation to confirm that). If you use a code path where that<br>&gt; expression is not constant time (again, assuming my suspicion is correct),<br>&gt; the zip+stride is against slower.<br>&gt;<br>&gt; I would argue the following:<br>&gt;<br>&gt;<br>&gt;    1. The code is not objectively easier to read or understand with the<br>&gt;    zip+stride construct (arguably, they are not even semantically equivalent).<br>&gt;    2. The debug builds are prohibitively slower, especially in the<br>&gt;    context of high-performance requirement code (I’m doing a lot of<br>&gt;    prototyping Swift in the context of games, so yes, performance matters<br>&gt;    considerably).<br>&gt;    3. The optimized builds are still slower than the for-in “equivalent&quot;<br>&gt;    functionality.<br>&gt;    4. The optimizer is inconsistent, like all optimizers are (this is a<br>&gt;    simple truth, not a value judgement - optimizers are not magic, they are<br>&gt;    code that is run like any other code and can only do as well as they are<br>&gt;    coded under the conditions they are coded against), at actually producing<br>&gt;    similar results with code that ends up with slightly different shapes.<br>&gt;    5. There is not functionally equivalent version of the code that I can<br>&gt;    write that is not more verbose, while requiring artificial scoping<br>&gt;    constructs, to achieve the same behavior.<br>&gt;<br>&gt;<br>&gt; So no, there is no evidence that I’ve seen to reconsider my opinion that<br>&gt; this proposal should not be implemented. If there is evidence to show that<br>&gt; my findings are incorrect or a poor summary of the general problem I am<br>&gt; seeing, then of course I would reconsider my opinion.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;<br>&gt; Hold the presses.<br>&gt;<br>&gt; David, I found the radical differences in our results troubling, so I did<br>&gt; some digging. It turns out that the zip+stride code:<br>&gt;<br>&gt;     var sum = 0<br>&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0,<br>&gt; by: -2)) {<br>&gt;         if i % 2 == 0 { continue }<br>&gt;         sum += 1<br>&gt;     }<br>&gt;<br>&gt; …runs *much* faster if you actually use both i and j inside the loop:<br>&gt;<br>&gt;     var sum = 0<br>&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0,<br>&gt; by: -2)) {<br>&gt;         if i % 2 == 0 { continue }<br>&gt;         sum += *i-j*<br>&gt;     }<br>&gt;<br>&gt; Weird, right? This is with optimization on (default “production” build).<br>&gt; It smells like a compiler quirk.<br>&gt;<br>&gt; With that tweak, the zip+stride approach actually clocks in faster than<br>&gt; the C-style for. Yes, you read that right: *faster*. Also smells like a<br>&gt; quirk. Am I doing something fantastically stupid in my code? Or maybe it’s<br>&gt; just my idiosyncratic taste in indentation? :P<br>&gt;<br>&gt; Here’s my test case, which was a command-line app with manual timing,<br>&gt; followed by David’s dropped into the same harness, followed by David’s but<br>&gt; with sum += i-j instead of sum += 1:<br>&gt;<br>&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262<br>&gt;<br>&gt; Point is: *no big performance difference here; even a performance<br>&gt; advantage* (that is probably a compiler artifact).<br>&gt;<br>&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt;<br>&gt; Results:<br>&gt;<br>&gt; —————— Paul’s comparison ——————<br>&gt;<br>&gt; zip+stride<br>&gt;<br>&gt;   Iter 0: 0.519110977649689<br>&gt;   Iter 1: 0.503385007381439<br>&gt;   Iter 2: 0.503321051597595<br>&gt;   Iter 3: 0.485216021537781<br>&gt;   Iter 4: 0.524757027626038<br>&gt;   Iter 5: 0.478078007698059<br>&gt;   Iter 6: 0.503880977630615<br>&gt;   Iter 7: 0.498068988323212<br>&gt;   Iter 8: 0.485781013965607<br>&gt;          ——————————————<br>&gt;   Median: 0.524757027626038<br>&gt;<br>&gt; C-style<br>&gt;<br>&gt;   Iter 0: 0.85480797290802<br>&gt;   Iter 1: 0.879491031169891<br>&gt;   Iter 2: 0.851797997951508<br>&gt;   Iter 3: 0.836017966270447<br>&gt;   Iter 4: 0.863684952259064<br>&gt;   Iter 5: 0.837742984294891<br>&gt;   Iter 6: 0.839070022106171<br>&gt;   Iter 7: 0.849772989749908<br>&gt;   Iter 8: 0.819278955459595<br>&gt;          ——————————————<br>&gt;   Median: 0.863684952259064<br>&gt;<br>&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt;<br>&gt; —————— David’s comparison ——————<br>&gt;<br>&gt; zip+stride<br>&gt;<br>&gt;   Iter 0: 1.15285503864288<br>&gt;   Iter 1: 1.1244450211525<br>&gt;   Iter 2: 1.24192994832993<br>&gt;   Iter 3: 1.02782195806503<br>&gt;   Iter 4: 1.13640999794006<br>&gt;   Iter 5: 1.15879601240158<br>&gt;   Iter 6: 1.12114900350571<br>&gt;   Iter 7: 1.21364599466324<br>&gt;   Iter 8: 1.10698300600052<br>&gt;          ——————————————<br>&gt;   Median: 1.13640999794006<br>&gt;<br>&gt; C-style<br>&gt;<br>&gt;   Iter 0: 0.375869989395142<br>&gt;   Iter 1: 0.371365010738373<br>&gt;   Iter 2: 0.356527984142303<br>&gt;   Iter 3: 0.384984970092773<br>&gt;   Iter 4: 0.367590010166168<br>&gt;   Iter 5: 0.365644037723541<br>&gt;   Iter 6: 0.384257972240448<br>&gt;   Iter 7: 0.379297018051147<br>&gt;   Iter 8: 0.363133013248444<br>&gt;          ——————————————<br>&gt;   Median: 0.367590010166168<br>&gt;<br>&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt;<br>&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt;<br>&gt; zip+stride<br>&gt;<br>&gt;   Iter 0: 0.328687965869904<br>&gt;   Iter 1: 0.332105994224548<br>&gt;   Iter 2: 0.336817979812622<br>&gt;   Iter 3: 0.321089029312134<br>&gt;   Iter 4: 0.338591992855072<br>&gt;   Iter 5: 0.348567008972168<br>&gt;   Iter 6: 0.34687602519989<br>&gt;   Iter 7: 0.34755402803421<br>&gt;   Iter 8: 0.341500997543335<br>&gt;          ——————————————<br>&gt;   Median: 0.338591992855072<br>&gt;<br>&gt; C-style<br>&gt;<br>&gt;   Iter 0: 0.422354996204376<br>&gt;   Iter 1: 0.427953958511353<br>&gt;   Iter 2: 0.403640985488892<br>&gt;   Iter 3: 0.415378987789154<br>&gt;   Iter 4: 0.403639018535614<br>&gt;   Iter 5: 0.416707038879395<br>&gt;   Iter 6: 0.415345013141632<br>&gt;   Iter 7: 0.417587995529175<br>&gt;   Iter 8: 0.415713012218475<br>&gt;          ——————————————<br>&gt;   Median: 0.403639018535614<br>&gt;<br>&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt;<br>&gt; Program ended with exit code: 0<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;<br>&gt; Here’s my basic test case:<br>&gt;<br>&gt; let first = 10000000<br>&gt; let second = 20000000<br>&gt;<br>&gt; class LoopPerfTests: XCTestCase {<br>&gt;<br>&gt;     func testZipStride() {<br>&gt;         self.measureBlock {<br>&gt;             var sum = 0<br>&gt;             for (i, j) in zip(first.stride(to: 0, by:<br>&gt; -1), second.stride(to: 0, by: -2)) {<br>&gt;                 if i % 2 == 0 { continue }<br>&gt;                 sum += 1<br>&gt;             }<br>&gt;             print(sum)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func testCStyleFor() {<br>&gt;         self.measureBlock {<br>&gt;             var sum = 0<br>&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;                 if i % 2 == 0 { continue }<br>&gt;                 sum += 1<br>&gt;             }<br>&gt;             print(sum)<br>&gt;         }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Non-optimized timings:<br>&gt;<br>&gt;    - testCStyleFor - 0.126s<br>&gt;    - testZipStride - 2.189s<br>&gt;<br>&gt;<br>&gt; Optimized timings:<br>&gt;<br>&gt;    - testCStyleFor - 0.008s<br>&gt;    - testZipStride - 0.015s<br>&gt;<br>&gt;<br>&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower<br>&gt; and in debug builds, that’s 17x slower. I think it’s unreasonable to force<br>&gt; people to write a more verbose while-loop construct to simply get the<br>&gt; performance they need.<br>&gt;<br>&gt; Also, the readability argument is very subjective; for example, I don’t<br>&gt; find the zip version more readability. In fact, I think it obscures what<br>&gt; the logic of the loop is doing. But again, that’s subjective.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;<br>&gt; Is there any guarantee that these two loops have the exact same runtime<br>&gt; performance?<br>&gt;<br>&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt;<br>&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;<br>&gt; I’d say that’s more than acceptable for the readability gain. If you’re in<br>&gt; that rare stretch of critical code where the extra 34% actually matters,<br>&gt; write it using a while loop instead.<br>&gt;<br>&gt; P<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Yes, performance is one thing neglected by the discussions and the<br>&gt; proposal.<br>&gt;<br>&gt;<br>&gt; This is my primary objection to to this proposal; it assumes (or<br>&gt; neglects?) that all of the types used can magically be inlined to nothing<br>&gt; but the imperative code. This isn’t magical, someone has to implement the<br>&gt; optimizations to do this.<br>&gt;<br>&gt; Is there any guarantee that these two loops have the exact same runtime<br>&gt; performance?<br>&gt;<br>&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt;<br>&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; And can you guarantee that performance is relatively the same across debug<br>&gt; and release builds? Because historically, Swift has suffered greatly in<br>&gt; this regard with respects to the performance of optimized versus<br>&gt; non-optimized builds.<br>&gt;<br>&gt; These types of optimizer issues are real-world things I’ve had to deal<br>&gt; with (and have written up many blog posts about). I get the desire to<br>&gt; simplify the constructs, but we need an escape hatch to write performant<br>&gt; code when the optimizer isn’t up to the job.<br>&gt;<br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/b0acb653/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2015-12-08 at 3.54.37 PM.png<br>Type: image/png<br>Size: 93414 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/b0acb653/attachment.png&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/503220368e284e974ffb41f5a9ff36ac?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>inbox only</string> &lt;inboxonly4 at gmail.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>I don&#39;t know why do you try to force for-in loop more than it is.It is for<br>SequenceType(s). For-in mostly it is for arrays(because it is a<br>sequence).Even though you can force everything to be a sequence because no<br>matter what the optimizer will be ,the SequenceType requires more time<br>because you have to call next() which can be a little bit slower or take a<br>lot more time for what in a C style for-loop can be done by a simple<br>subtraction or addition.<br></p><p>2015-12-11 19:17 GMT+02:00 Marc Knaup via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; This does not take continue into account which would then require a<br>&gt; duplication of expr3.<br>&gt; It would also change the scope of variables defined in expr1 potentially causing<br>&gt; collisions or unexpected shadowing.<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 5:27 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; For many of these number-crunching performance-stretching scenarios, many<br>&gt;&gt; I suggest once again, that if you&#39;re doing serious number crunching that<br>&gt;&gt; Accelerate or similar approaches is to be preferred? As for c-style-for vs<br>&gt;&gt; while, the two are mechanically convertible.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Where heavy performance is not required, for-in is more readable,<br>&gt;&gt; maintainable, and optimizable to a sufficient extent that I do not see it<br>&gt;&gt; as a bar to conversion.<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 11, 2015, at 8:44 AM, Paul Cantrell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Your revised results are now right in line with what I get in my test<br>&gt;&gt; harness, so that’s reassuring!<br>&gt;&gt;<br>&gt;&gt; I’d quibble with this:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    1. The optimized builds are still slower than the for-in “equivalent”<br>&gt;&gt;    functionality.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That’s not an accurate summary. Depending on precisely what’s in the<br>&gt;&gt; loop, the for-in flavor is clocking in anywhere from 80% slower to 20%<br>&gt;&gt; *faster*.<br>&gt;&gt;<br>&gt;&gt; None of this performance testing undercuts your entirely valid concerns<br>&gt;&gt; about syntax. We have, I think, widespread agreement on the list that the<br>&gt;&gt; C-style for is very rarely used in most Swift code in the wild — but if<br>&gt;&gt; your usage patterns are unusual and you use it a lot, I can see why you’d<br>&gt;&gt; be reluctant to part with it!<br>&gt;&gt;<br>&gt;&gt; It’s a question, then, of whether it’s worth having a leaner language at<br>&gt;&gt; the expense of making some less-common code more verbose when optimized.<br>&gt;&gt; I’m not sure that any of the C-style audits people have done on the list<br>&gt;&gt; have been games. Are there other game developers on the list using Swift<br>&gt;&gt; who could do the audit on their code?<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; Paul<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 11, 2015, at 2:33 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I don’t know what you did, your gist 404s.<br>&gt;&gt;<br>&gt;&gt; Here’s an update with the while-loop:<br>&gt;&gt; https://gist.github.com/owensd/b438bea90075907fa6ec and using both i and<br>&gt;&gt; j within the loops. This is a simple OS X framework project with unit tests.<br>&gt;&gt;<br>&gt;&gt; *Debug Build:*<br>&gt;&gt;<br>&gt;&gt;    - testZipStride - 2.496s<br>&gt;&gt;    - testCStyleFor - 0.210s<br>&gt;&gt;    - testWhileLoop - 0.220s<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *Release Build:*<br>&gt;&gt;<br>&gt;&gt;    - testZipStride - 0.029s<br>&gt;&gt;    - testCStyleFor - 0.018s<br>&gt;&gt;    - testWhileLoop - 0.019s<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I ran these tests from my MacBook Pro, the previous tests were from my<br>&gt;&gt; iMac.<br>&gt;&gt;<br>&gt;&gt; When you use the sum += (i - j) construct, I think all you are ending up<br>&gt;&gt; with a hot-path that the optimizer can end up optimizing better (my guess<br>&gt;&gt; is that the i-j turns into a constant expression - after all, the<br>&gt;&gt; difference is always 1, but I don’t know enough about the SIL<br>&gt;&gt; representation to confirm that). If you use a code path where that<br>&gt;&gt; expression is not constant time (again, assuming my suspicion is correct),<br>&gt;&gt; the zip+stride is against slower.<br>&gt;&gt;<br>&gt;&gt; I would argue the following:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    1. The code is not objectively easier to read or understand with the<br>&gt;&gt;    zip+stride construct (arguably, they are not even semantically equivalent).<br>&gt;&gt;    2. The debug builds are prohibitively slower, especially in the<br>&gt;&gt;    context of high-performance requirement code (I’m doing a lot of<br>&gt;&gt;    prototyping Swift in the context of games, so yes, performance matters<br>&gt;&gt;    considerably).<br>&gt;&gt;    3. The optimized builds are still slower than the for-in “equivalent&quot;<br>&gt;&gt;    functionality.<br>&gt;&gt;    4. The optimizer is inconsistent, like all optimizers are (this is a<br>&gt;&gt;    simple truth, not a value judgement - optimizers are not magic, they are<br>&gt;&gt;    code that is run like any other code and can only do as well as they are<br>&gt;&gt;    coded under the conditions they are coded against), at actually producing<br>&gt;&gt;    similar results with code that ends up with slightly different shapes.<br>&gt;&gt;    5. There is not functionally equivalent version of the code that I<br>&gt;&gt;    can write that is not more verbose, while requiring artificial scoping<br>&gt;&gt;    constructs, to achieve the same behavior.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So no, there is no evidence that I’ve seen to reconsider my opinion that<br>&gt;&gt; this proposal should not be implemented. If there is evidence to show that<br>&gt;&gt; my findings are incorrect or a poor summary of the general problem I am<br>&gt;&gt; seeing, then of course I would reconsider my opinion.<br>&gt;&gt;<br>&gt;&gt; -David<br>&gt;&gt;<br>&gt;&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hold the presses.<br>&gt;&gt;<br>&gt;&gt; David, I found the radical differences in our results troubling, so I did<br>&gt;&gt; some digging. It turns out that the zip+stride code:<br>&gt;&gt;<br>&gt;&gt;     var sum = 0<br>&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0,<br>&gt;&gt; by: -2)) {<br>&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;         sum += 1<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; …runs *much* faster if you actually use both i and j inside the loop:<br>&gt;&gt;<br>&gt;&gt;     var sum = 0<br>&gt;&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0,<br>&gt;&gt; by: -2)) {<br>&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;         sum += *i-j*<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; Weird, right? This is with optimization on (default “production” build).<br>&gt;&gt; It smells like a compiler quirk.<br>&gt;&gt;<br>&gt;&gt; With that tweak, the zip+stride approach actually clocks in faster than<br>&gt;&gt; the C-style for. Yes, you read that right: *faster*. Also smells like a<br>&gt;&gt; quirk. Am I doing something fantastically stupid in my code? Or maybe it’s<br>&gt;&gt; just my idiosyncratic taste in indentation? :P<br>&gt;&gt;<br>&gt;&gt; Here’s my test case, which was a command-line app with manual timing,<br>&gt;&gt; followed by David’s dropped into the same harness, followed by David’s but<br>&gt;&gt; with sum += i-j instead of sum += 1:<br>&gt;&gt;<br>&gt;&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262<br>&gt;&gt;<br>&gt;&gt; Point is: *no big performance difference here; even a performance<br>&gt;&gt; advantage* (that is probably a compiler artifact).<br>&gt;&gt;<br>&gt;&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt;&gt;<br>&gt;&gt; Results:<br>&gt;&gt;<br>&gt;&gt; —————— Paul’s comparison ——————<br>&gt;&gt;<br>&gt;&gt; zip+stride<br>&gt;&gt;<br>&gt;&gt;   Iter 0: 0.519110977649689<br>&gt;&gt;   Iter 1: 0.503385007381439<br>&gt;&gt;   Iter 2: 0.503321051597595<br>&gt;&gt;   Iter 3: 0.485216021537781<br>&gt;&gt;   Iter 4: 0.524757027626038<br>&gt;&gt;   Iter 5: 0.478078007698059<br>&gt;&gt;   Iter 6: 0.503880977630615<br>&gt;&gt;   Iter 7: 0.498068988323212<br>&gt;&gt;   Iter 8: 0.485781013965607<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.524757027626038<br>&gt;&gt;<br>&gt;&gt; C-style<br>&gt;&gt;<br>&gt;&gt;   Iter 0: 0.85480797290802<br>&gt;&gt;   Iter 1: 0.879491031169891<br>&gt;&gt;   Iter 2: 0.851797997951508<br>&gt;&gt;   Iter 3: 0.836017966270447<br>&gt;&gt;   Iter 4: 0.863684952259064<br>&gt;&gt;   Iter 5: 0.837742984294891<br>&gt;&gt;   Iter 6: 0.839070022106171<br>&gt;&gt;   Iter 7: 0.849772989749908<br>&gt;&gt;   Iter 8: 0.819278955459595<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.863684952259064<br>&gt;&gt;<br>&gt;&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt;&gt;<br>&gt;&gt; —————— David’s comparison ——————<br>&gt;&gt;<br>&gt;&gt; zip+stride<br>&gt;&gt;<br>&gt;&gt;   Iter 0: 1.15285503864288<br>&gt;&gt;   Iter 1: 1.1244450211525<br>&gt;&gt;   Iter 2: 1.24192994832993<br>&gt;&gt;   Iter 3: 1.02782195806503<br>&gt;&gt;   Iter 4: 1.13640999794006<br>&gt;&gt;   Iter 5: 1.15879601240158<br>&gt;&gt;   Iter 6: 1.12114900350571<br>&gt;&gt;   Iter 7: 1.21364599466324<br>&gt;&gt;   Iter 8: 1.10698300600052<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 1.13640999794006<br>&gt;&gt;<br>&gt;&gt; C-style<br>&gt;&gt;<br>&gt;&gt;   Iter 0: 0.375869989395142<br>&gt;&gt;   Iter 1: 0.371365010738373<br>&gt;&gt;   Iter 2: 0.356527984142303<br>&gt;&gt;   Iter 3: 0.384984970092773<br>&gt;&gt;   Iter 4: 0.367590010166168<br>&gt;&gt;   Iter 5: 0.365644037723541<br>&gt;&gt;   Iter 6: 0.384257972240448<br>&gt;&gt;   Iter 7: 0.379297018051147<br>&gt;&gt;   Iter 8: 0.363133013248444<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.367590010166168<br>&gt;&gt;<br>&gt;&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt;&gt;<br>&gt;&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt;&gt;<br>&gt;&gt; zip+stride<br>&gt;&gt;<br>&gt;&gt;   Iter 0: 0.328687965869904<br>&gt;&gt;   Iter 1: 0.332105994224548<br>&gt;&gt;   Iter 2: 0.336817979812622<br>&gt;&gt;   Iter 3: 0.321089029312134<br>&gt;&gt;   Iter 4: 0.338591992855072<br>&gt;&gt;   Iter 5: 0.348567008972168<br>&gt;&gt;   Iter 6: 0.34687602519989<br>&gt;&gt;   Iter 7: 0.34755402803421<br>&gt;&gt;   Iter 8: 0.341500997543335<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.338591992855072<br>&gt;&gt;<br>&gt;&gt; C-style<br>&gt;&gt;<br>&gt;&gt;   Iter 0: 0.422354996204376<br>&gt;&gt;   Iter 1: 0.427953958511353<br>&gt;&gt;   Iter 2: 0.403640985488892<br>&gt;&gt;   Iter 3: 0.415378987789154<br>&gt;&gt;   Iter 4: 0.403639018535614<br>&gt;&gt;   Iter 5: 0.416707038879395<br>&gt;&gt;   Iter 6: 0.415345013141632<br>&gt;&gt;   Iter 7: 0.417587995529175<br>&gt;&gt;   Iter 8: 0.415713012218475<br>&gt;&gt;          ——————————————<br>&gt;&gt;   Median: 0.403639018535614<br>&gt;&gt;<br>&gt;&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt;&gt;<br>&gt;&gt; Program ended with exit code: 0<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; Paul<br>&gt;&gt;<br>&gt;&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Here’s my basic test case:<br>&gt;&gt;<br>&gt;&gt; let first = 10000000<br>&gt;&gt; let second = 20000000<br>&gt;&gt;<br>&gt;&gt; class LoopPerfTests: XCTestCase {<br>&gt;&gt;<br>&gt;&gt;     func testZipStride() {<br>&gt;&gt;         self.measureBlock {<br>&gt;&gt;             var sum = 0<br>&gt;&gt;             for (i, j) in zip(first.stride(to: 0, by:<br>&gt;&gt; -1), second.stride(to: 0, by: -2)) {<br>&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;                 sum += 1<br>&gt;&gt;             }<br>&gt;&gt;             print(sum)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     func testCStyleFor() {<br>&gt;&gt;         self.measureBlock {<br>&gt;&gt;             var sum = 0<br>&gt;&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j<br>&gt;&gt; -= 2 {<br>&gt;&gt;                 if i % 2 == 0 { continue }<br>&gt;&gt;                 sum += 1<br>&gt;&gt;             }<br>&gt;&gt;             print(sum)<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Non-optimized timings:<br>&gt;&gt;<br>&gt;&gt;    - testCStyleFor - 0.126s<br>&gt;&gt;    - testZipStride - 2.189s<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Optimized timings:<br>&gt;&gt;<br>&gt;&gt;    - testCStyleFor - 0.008s<br>&gt;&gt;    - testZipStride - 0.015s<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower<br>&gt;&gt; and in debug builds, that’s 17x slower. I think it’s unreasonable to force<br>&gt;&gt; people to write a more verbose while-loop construct to simply get the<br>&gt;&gt; performance they need.<br>&gt;&gt;<br>&gt;&gt; Also, the readability argument is very subjective; for example, I don’t<br>&gt;&gt; find the zip version more readability. In fact, I think it obscures what<br>&gt;&gt; the logic of the loop is doing. But again, that’s subjective.<br>&gt;&gt;<br>&gt;&gt; -David<br>&gt;&gt;<br>&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Is there any guarantee that these two loops have the exact same runtime<br>&gt;&gt; performance?<br>&gt;&gt;<br>&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt;<br>&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re<br>&gt;&gt; in that rare stretch of critical code where the extra 34% actually matters,<br>&gt;&gt; write it using a while loop instead.<br>&gt;&gt;<br>&gt;&gt; P<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Yes, performance is one thing neglected by the discussions and the<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is my primary objection to to this proposal; it assumes (or<br>&gt;&gt; neglects?) that all of the types used can magically be inlined to nothing<br>&gt;&gt; but the imperative code. This isn’t magical, someone has to implement the<br>&gt;&gt; optimizations to do this.<br>&gt;&gt;<br>&gt;&gt; Is there any guarantee that these two loops have the exact same runtime<br>&gt;&gt; performance?<br>&gt;&gt;<br>&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;    print(i, j)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; And can you guarantee that performance is relatively the same across<br>&gt;&gt; debug and release builds? Because historically, Swift has suffered greatly<br>&gt;&gt; in this regard with respects to the performance of optimized versus<br>&gt;&gt; non-optimized builds.<br>&gt;&gt;<br>&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal<br>&gt;&gt; with (and have written up many blog posts about). I get the desire to<br>&gt;&gt; simplify the constructs, but we need an escape hatch to write performant<br>&gt;&gt; code when the optimizer isn’t up to the job.<br>&gt;&gt;<br>&gt;&gt; -David<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/e9943375/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2015-12-08 at 3.54.37 PM.png<br>Type: image/png<br>Size: 93414 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/e9943375/attachment.png&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>FWIW:<br></p><p>Performance differences in loops exist in any language. And the vast<br>majority of cases it is only a matter of compiler optimization difference:<br></p><p>Using this example:<br></p><p>http://stackoverflow.com/a/2959105<br></p><p>&quot;For instance, the following code shows that the &quot;do-while&quot; is a bit<br>faster. This because the &quot;jmp&quot; istruction is not used by the &quot;do-while&quot;<br>loop.&quot;<br></p><p>int main(int argc, char* argv[])  {     int i;  char x[100];<br>//&quot;FOR&quot; LOOP:for(i=0; i&lt;100; i++ )  { x[i] = 0; }<br>//&quot;WHILE&quot; LOOP:<br>i=0;  while(i&lt;100 )  { x[i++] = 0;  }<br>//&quot;DO-WHILE&quot; LOOP:<br>i=0;  do  { x[i++] = 0;   }  while(i&lt;100);<br>return 0;  }<br></p><p>*// &quot;FOR&quot; LOOP:*<br></p><p>    010013C8  mov         dword ptr [ebp-0Ch],0<br>    010013CF  jmp         wmain+3Ah (10013DAh)<br></p><p>  for(i=0; i&lt;100; i++ )<br>  { x[i] = 0;<br>    010013D1  mov         eax,dword ptr [ebp-0Ch]  &lt;&lt;&lt; UPDATE i<br>    010013D4  add         eax,1<br>    010013D7  mov         dword ptr [ebp-0Ch],eax<br>    010013DA  cmp         dword ptr [ebp-0Ch],64h  &lt;&lt;&lt; TEST<br>    010013DE  jge         wmain+4Ah (10013EAh)     &lt;&lt;&lt; COND JUMP<br>    010013E0  mov         eax,dword ptr [ebp-0Ch]  &lt;&lt;&lt; DO THE JOB..<br>    010013E3  mov         byte ptr [ebp+eax-78h],0<br>    010013E8  jmp         wmain+31h (10013D1h)     &lt;&lt;&lt; UNCOND JUMP<br>  }<br></p><p>*// &quot;WHILE&quot; LOOP:*<br></p><p>  i=0;<br>  010013EA  mov         dword ptr [ebp-0Ch],0<br>  while(i&lt;100 )<br>  { x[i++] = 0;<br>    010013F1  cmp         dword ptr [ebp-0Ch],64h   &lt;&lt;&lt; TEST<br>    010013F5  jge         wmain+6Ah (100140Ah)      &lt;&lt;&lt; COND JUMP<br>    010013F7  mov         eax,dword ptr [ebp-0Ch]   &lt;&lt;&lt; DO THE JOB..<br>    010013FA  mov         byte ptr [ebp+eax-78h],0<br>    010013FF  mov         ecx,dword ptr [ebp-0Ch]   &lt;&lt;&lt; UPDATE i<br>    01001402  add         ecx,1<br>    01001405  mov         dword ptr [ebp-0Ch],ecx<br>    01001408  jmp         wmain+51h (10013F1h)      &lt;&lt;&lt; UNCOND JUMP<br>  }<br></p><p>*// &quot;DO-WHILE&quot; LOOP:*<br></p><p>i=0;  .  0100140A  mov         dword ptr [ebp-0Ch],0<br>  do<br>  { x[i++] = 0;<br>    01001411  mov         eax,dword ptr [ebp-0Ch]   &lt;&lt;&lt; DO THE JOB..<br>    01001414  mov         byte ptr [ebp+eax-78h],0<br>    01001419  mov         ecx,dword ptr [ebp-0Ch]   &lt;&lt;&lt; UPDATE i<br>    0100141C  add         ecx,1<br>    0100141F  mov         dword ptr [ebp-0Ch],ecx<br>    01001422  cmp         dword ptr [ebp-0Ch],64h   &lt;&lt;&lt; TEST<br>    01001426  jl          wmain+71h (1001411h)      &lt;&lt;&lt; COND JUMP<br>  }<br>  while(i&lt;100);<br></p><p><br></p><p>Em sex, 11 de dez de 2015 às 06:34, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; I don’t know what you did, your gist 404s.<br>&gt;<br>&gt; Here’s an update with the while-loop:<br>&gt; https://gist.github.com/owensd/b438bea90075907fa6ec and using both i and<br>&gt; j within the loops. This is a simple OS X framework project with unit tests.<br>&gt;<br>&gt; *Debug Build:*<br>&gt;<br>&gt;    - testZipStride - 2.496s<br>&gt;    - testCStyleFor - 0.210s<br>&gt;    - testWhileLoop - 0.220s<br>&gt;<br>&gt;<br>&gt; *Release Build:*<br>&gt;<br>&gt;    - testZipStride - 0.029s<br>&gt;    - testCStyleFor - 0.018s<br>&gt;    - testWhileLoop - 0.019s<br>&gt;<br>&gt;<br>&gt; I ran these tests from my MacBook Pro, the previous tests were from my<br>&gt; iMac.<br>&gt;<br>&gt; When you use the sum += (i - j) construct, I think all you are ending up<br>&gt; with a hot-path that the optimizer can end up optimizing better (my guess<br>&gt; is that the i-j turns into a constant expression - after all, the<br>&gt; difference is always 1, but I don’t know enough about the SIL<br>&gt; representation to confirm that). If you use a code path where that<br>&gt; expression is not constant time (again, assuming my suspicion is correct),<br>&gt; the zip+stride is against slower.<br>&gt;<br>&gt; I would argue the following:<br>&gt;<br>&gt;<br>&gt;    1. The code is not objectively easier to read or understand with the<br>&gt;    zip+stride construct (arguably, they are not even semantically equivalent).<br>&gt;    2. The debug builds are prohibitively slower, especially in the<br>&gt;    context of high-performance requirement code (I’m doing a lot of<br>&gt;    prototyping Swift in the context of games, so yes, performance matters<br>&gt;    considerably).<br>&gt;    3. The optimized builds are still slower than the for-in “equivalent&quot;<br>&gt;    functionality.<br>&gt;    4. The optimizer is inconsistent, like all optimizers are (this is a<br>&gt;    simple truth, not a value judgement - optimizers are not magic, they are<br>&gt;    code that is run like any other code and can only do as well as they are<br>&gt;    coded under the conditions they are coded against), at actually producing<br>&gt;    similar results with code that ends up with slightly different shapes.<br>&gt;    5. There is not functionally equivalent version of the code that I can<br>&gt;    write that is not more verbose, while requiring artificial scoping<br>&gt;    constructs, to achieve the same behavior.<br>&gt;<br>&gt;<br>&gt; So no, there is no evidence that I’ve seen to reconsider my opinion that<br>&gt; this proposal should not be implemented. If there is evidence to show that<br>&gt; my findings are incorrect or a poor summary of the general problem I am<br>&gt; seeing, then of course I would reconsider my opinion.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Dec 10, 2015, at 9:12 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;<br>&gt; Hold the presses.<br>&gt;<br>&gt; David, I found the radical differences in our results troubling, so I did<br>&gt; some digging. It turns out that the zip+stride code:<br>&gt;<br>&gt;     var sum = 0<br>&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0,<br>&gt; by: -2)) {<br>&gt;         if i % 2 == 0 { continue }<br>&gt;         sum += 1<br>&gt;     }<br>&gt;<br>&gt; …runs *much* faster if you actually use both i and j inside the loop:<br>&gt;<br>&gt;     var sum = 0<br>&gt;     for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0,<br>&gt; by: -2)) {<br>&gt;         if i % 2 == 0 { continue }<br>&gt;         sum += *i-j*<br>&gt;     }<br>&gt;<br>&gt; Weird, right? This is with optimization on (default “production” build).<br>&gt; It smells like a compiler quirk.<br>&gt;<br>&gt; With that tweak, the zip+stride approach actually clocks in faster than<br>&gt; the C-style for. Yes, you read that right: *faster*. Also smells like a<br>&gt; quirk. Am I doing something fantastically stupid in my code? Or maybe it’s<br>&gt; just my idiosyncratic taste in indentation? :P<br>&gt;<br>&gt; Here’s my test case, which was a command-line app with manual timing,<br>&gt; followed by David’s dropped into the same harness, followed by David’s but<br>&gt; with sum += i-j instead of sum += 1:<br>&gt;<br>&gt;     https://gist.github.com/pcantrell/6bbe80e630d227ed0262<br>&gt;<br>&gt; Point is: *no big performance difference here; even a performance<br>&gt; advantage* (that is probably a compiler artifact).<br>&gt;<br>&gt; David and Thorsten, you might want to reconsider your reviews?<br>&gt;<br>&gt; Results:<br>&gt;<br>&gt; —————— Paul’s comparison ——————<br>&gt;<br>&gt; zip+stride<br>&gt;<br>&gt;   Iter 0: 0.519110977649689<br>&gt;   Iter 1: 0.503385007381439<br>&gt;   Iter 2: 0.503321051597595<br>&gt;   Iter 3: 0.485216021537781<br>&gt;   Iter 4: 0.524757027626038<br>&gt;   Iter 5: 0.478078007698059<br>&gt;   Iter 6: 0.503880977630615<br>&gt;   Iter 7: 0.498068988323212<br>&gt;   Iter 8: 0.485781013965607<br>&gt;          ——————————————<br>&gt;   Median: 0.524757027626038<br>&gt;<br>&gt; C-style<br>&gt;<br>&gt;   Iter 0: 0.85480797290802<br>&gt;   Iter 1: 0.879491031169891<br>&gt;   Iter 2: 0.851797997951508<br>&gt;   Iter 3: 0.836017966270447<br>&gt;   Iter 4: 0.863684952259064<br>&gt;   Iter 5: 0.837742984294891<br>&gt;   Iter 6: 0.839070022106171<br>&gt;   Iter 7: 0.849772989749908<br>&gt;   Iter 8: 0.819278955459595<br>&gt;          ——————————————<br>&gt;   Median: 0.863684952259064<br>&gt;<br>&gt; Zip+stride takes 0.607579217692143x the time of C-style for<br>&gt;<br>&gt; —————— David’s comparison ——————<br>&gt;<br>&gt; zip+stride<br>&gt;<br>&gt;   Iter 0: 1.15285503864288<br>&gt;   Iter 1: 1.1244450211525<br>&gt;   Iter 2: 1.24192994832993<br>&gt;   Iter 3: 1.02782195806503<br>&gt;   Iter 4: 1.13640999794006<br>&gt;   Iter 5: 1.15879601240158<br>&gt;   Iter 6: 1.12114900350571<br>&gt;   Iter 7: 1.21364599466324<br>&gt;   Iter 8: 1.10698300600052<br>&gt;          ——————————————<br>&gt;   Median: 1.13640999794006<br>&gt;<br>&gt; C-style<br>&gt;<br>&gt;   Iter 0: 0.375869989395142<br>&gt;   Iter 1: 0.371365010738373<br>&gt;   Iter 2: 0.356527984142303<br>&gt;   Iter 3: 0.384984970092773<br>&gt;   Iter 4: 0.367590010166168<br>&gt;   Iter 5: 0.365644037723541<br>&gt;   Iter 6: 0.384257972240448<br>&gt;   Iter 7: 0.379297018051147<br>&gt;   Iter 8: 0.363133013248444<br>&gt;          ——————————————<br>&gt;   Median: 0.367590010166168<br>&gt;<br>&gt; Zip+stride takes 3.09151491202482x the time of C-style for<br>&gt;<br>&gt; —————— David’s comparison, actually using indices in the loop ——————<br>&gt;<br>&gt; zip+stride<br>&gt;<br>&gt;   Iter 0: 0.328687965869904<br>&gt;   Iter 1: 0.332105994224548<br>&gt;   Iter 2: 0.336817979812622<br>&gt;   Iter 3: 0.321089029312134<br>&gt;   Iter 4: 0.338591992855072<br>&gt;   Iter 5: 0.348567008972168<br>&gt;   Iter 6: 0.34687602519989<br>&gt;   Iter 7: 0.34755402803421<br>&gt;   Iter 8: 0.341500997543335<br>&gt;          ——————————————<br>&gt;   Median: 0.338591992855072<br>&gt;<br>&gt; C-style<br>&gt;<br>&gt;   Iter 0: 0.422354996204376<br>&gt;   Iter 1: 0.427953958511353<br>&gt;   Iter 2: 0.403640985488892<br>&gt;   Iter 3: 0.415378987789154<br>&gt;   Iter 4: 0.403639018535614<br>&gt;   Iter 5: 0.416707038879395<br>&gt;   Iter 6: 0.415345013141632<br>&gt;   Iter 7: 0.417587995529175<br>&gt;   Iter 8: 0.415713012218475<br>&gt;          ——————————————<br>&gt;   Median: 0.403639018535614<br>&gt;<br>&gt; Zip+stride takes 0.838848518865867x the time of C-style for<br>&gt;<br>&gt; Program ended with exit code: 0<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; On Dec 10, 2015, at 5:36 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;<br>&gt; Here’s my basic test case:<br>&gt;<br>&gt; let first = 10000000<br>&gt; let second = 20000000<br>&gt;<br>&gt; class LoopPerfTests: XCTestCase {<br>&gt;<br>&gt;     func testZipStride() {<br>&gt;         self.measureBlock {<br>&gt;             var sum = 0<br>&gt;             for (i, j) in zip(first.stride(to: 0, by:<br>&gt; -1), second.stride(to: 0, by: -2)) {<br>&gt;                 if i % 2 == 0 { continue }<br>&gt;                 sum += 1<br>&gt;             }<br>&gt;             print(sum)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func testCStyleFor() {<br>&gt;         self.measureBlock {<br>&gt;             var sum = 0<br>&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;                 if i % 2 == 0 { continue }<br>&gt;                 sum += 1<br>&gt;             }<br>&gt;             print(sum)<br>&gt;         }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Non-optimized timings:<br>&gt;<br>&gt;    - testCStyleFor - 0.126s<br>&gt;    - testZipStride - 2.189s<br>&gt;<br>&gt;<br>&gt; Optimized timings:<br>&gt;<br>&gt;    - testCStyleFor - 0.008s<br>&gt;    - testZipStride - 0.015s<br>&gt;<br>&gt;<br>&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower<br>&gt; and in debug builds, that’s 17x slower. I think it’s unreasonable to force<br>&gt; people to write a more verbose while-loop construct to simply get the<br>&gt; performance they need.<br>&gt;<br>&gt; Also, the readability argument is very subjective; for example, I don’t<br>&gt; find the zip version more readability. In fact, I think it obscures what<br>&gt; the logic of the loop is doing. But again, that’s subjective.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;<br>&gt; Is there any guarantee that these two loops have the exact same runtime<br>&gt; performance?<br>&gt;<br>&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt;<br>&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;<br>&gt; I’d say that’s more than acceptable for the readability gain. If you’re in<br>&gt; that rare stretch of critical code where the extra 34% actually matters,<br>&gt; write it using a while loop instead.<br>&gt;<br>&gt; P<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Yes, performance is one thing neglected by the discussions and the<br>&gt; proposal.<br>&gt;<br>&gt;<br>&gt; This is my primary objection to to this proposal; it assumes (or<br>&gt; neglects?) that all of the types used can magically be inlined to nothing<br>&gt; but the imperative code. This isn’t magical, someone has to implement the<br>&gt; optimizations to do this.<br>&gt;<br>&gt; Is there any guarantee that these two loops have the exact same runtime<br>&gt; performance?<br>&gt;<br>&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt;<br>&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;    if i % 2 == 0 { continue }<br>&gt;    print(i, j)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; And can you guarantee that performance is relatively the same across debug<br>&gt; and release builds? Because historically, Swift has suffered greatly in<br>&gt; this regard with respects to the performance of optimized versus<br>&gt; non-optimized builds.<br>&gt;<br>&gt; These types of optimizer issues are real-world things I’ve had to deal<br>&gt; with (and have written up many blog posts about). I get the desire to<br>&gt; simplify the constructs, but we need an escape hatch to write performant<br>&gt; code when the optimizer isn’t up to the job.<br>&gt;<br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/50bca11a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>Big thanks for doing the measurements!<br></p><p>-Thorsten <br></p><p>&gt; Am 11.12.2015 um 00:36 schrieb David Owens II &lt;david at owensd.io&gt;:<br>&gt; <br>&gt; Here’s my basic test case:<br>&gt; <br>&gt; let first = 10000000<br>&gt; let second = 20000000<br>&gt; <br>&gt; class LoopPerfTests: XCTestCase {<br>&gt;     <br>&gt;     func testZipStride() {<br>&gt;         self.measureBlock {<br>&gt;             var sum = 0<br>&gt;             for (i, j) in zip(first.stride(to: 0, by: -1), second.stride(to: 0, by: -2)) {<br>&gt;                 if i % 2 == 0 { continue }<br>&gt;                 sum += 1<br>&gt;             }<br>&gt;             print(sum)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     func testCStyleFor() {<br>&gt;         self.measureBlock {<br>&gt;             var sum = 0<br>&gt;             for var i = first, j = second; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;                 if i % 2 == 0 { continue }<br>&gt;                 sum += 1<br>&gt;             }<br>&gt;             print(sum)<br>&gt;         }<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Non-optimized timings:<br>&gt; testCStyleFor - 0.126s<br>&gt; testZipStride - 2.189s<br>&gt; <br>&gt; Optimized timings:<br>&gt; testCStyleFor - 0.008s<br>&gt; testZipStride - 0.015s<br>&gt; <br>&gt; That’s a lot worse than 34%; even in optimized builds, that’s 2x slower and in debug builds, that’s 17x slower. I think it’s unreasonable to force people to write a more verbose while-loop construct to simply get the performance they need.<br>&gt; <br>&gt; Also, the readability argument is very subjective; for example, I don’t find the zip version more readability. In fact, I think it obscures what the logic of the loop is doing. But again, that’s subjective.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 2:41 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In a quick and dirty test, the second is approximately 34% slower.<br>&gt;&gt; <br>&gt;&gt; I’d say that’s more than acceptable for the readability gain. If you’re in that rare stretch of critical code where the extra 34% actually matters, write it using a while loop instead.<br>&gt;&gt; <br>&gt;&gt; P<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 4:07 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 1:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my primary objection to to this proposal; it assumes (or neglects?) that all of the types used can magically be inlined to nothing but the imperative code. This isn’t magical, someone has to implement the optimizations to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any guarantee that these two loops have the exact same runtime performance?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for (i, j) in zip(10.stride(to: 0, by: -1), 20.stride(to: 0, by: -2)) {<br>&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;&gt;    if i % 2 == 0 { continue }<br>&gt;&gt;&gt;    print(i, j)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And can you guarantee that performance is relatively the same across debug and release builds? Because historically, Swift has suffered greatly in this regard with respects to the performance of optimized versus non-optimized builds.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These types of optimizer issues are real-world things I’ve had to deal with (and have written up many blog posts about). I get the desire to simplify the constructs, but we need an escape hatch to write performant code when the optimizer isn’t up to the job.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/da209b06/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>On Dec 10, 2015, at 2:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt; That just occurred to me and I&#39;m going to revoke my support for the proposal for these reasons.<br>&gt; <br>&gt; -Thorsten <br></p><p>Do you mean your support is conditional based on performance?<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/246abeee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>I revoked my support for two reasons: One, worries about performance which has in the meantime been confirmed by David Owens II to suffer considerably, and Two, by repeated suggestions of using defer for the incrementing clause even though it changes semantics. <br>Removing the for-loop would therefore mean that we lose a construct needed in cases whe high performance is requird and that instead of incrasing readability we would decrease it in those cases where defer would be misused.<br></p><p>-Thorsten<br></p><p>&gt; Am 11.12.2015 um 01:33 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 2:57 PM, thorsten--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, performance is one thing neglected by the discussions and the proposal.<br>&gt;&gt; That just occurred to me and I&#39;m going to revoke my support for the proposal for these reasons.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt; <br>&gt; Do you mean your support is conditional based on performance?<br>&gt; <br>&gt; -DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/fdf91fb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 11, 2015 at 04:00:00am</p></header><div class="content"><p>This might be a controversial opinion, but:<br></p><p>- The indices/values being created by a for loop should be immutable through each iteration of the actual loop (this is actually enforced by for-in and forEach() ). For example, this is appropriate for iterating a sequence<br>- If you are modifying indices within the body of a loop, you should use while or repeat..while. This is appropriate for use cases like traversal of a singly-linked list.<br></p><p>We have seen plenty of for statements that fit each bucket, so there isn’t a single fix-it option. In fact, I don’t believe it is appropriate to have a fixit option more complex than “it looks like you meant to use a range”. We will not be able to interpret the purpose of the loop, and it will be easier for developers to recognize the meaning of the code they wrote vs our generated equivalent.<br></p><p>Defer might be appropriate in some cases. It might not be appropriate in others. Why are we trying to guess the programmer’s intentions?<br></p><p>-DW<br></p><p>&gt; On Dec 11, 2015, at 12:55 AM, thorsten at portableinnovations.de wrote:<br>&gt; <br>&gt; I revoked my support for two reasons: One, worries about performance which has in the meantime been confirmed by David Owens II to suffer considerably, and Two, by repeated suggestions of using defer for the incrementing clause even though it changes semantics. <br>&gt; Removing the for-loop would therefore mean that we lose a construct needed in cases whe high performance is requird and that instead of incrasing readability we would decrease it in those cases where defer would be misused.<br>&gt; <br>&gt; -Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>Le 11 déc. 2015 à 6:20, David Waite &lt;david at alkaline-solutions.com&gt; a écrit :<br></p><p>&gt; Defer might be appropriate in some cases. It might not be appropriate in others. Why are we trying to guess the programmer’s intentions?<br></p><p>Defer is geared to do cleanup work, work that must not be avoided even when an exception is thrown. If one day Swift becomes capable of properly unwinding the stack when a C++ or Objective-C exception is thrown, defer&#39;s performance characteristics might change a little bit. More code will be added to handle the exception case, and an entry will have to be added to the unwind table so the unwind mechanism can call that increment that should not be called in the first place.<br></p><p>That&#39;s not supported right now, but the Swift team at Apple has obviously been thinking about it.<br>https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst<br></p><p>All this illustrates that defer is the wrong mechanism for implementing a loop. Add that the semantics are slightly wrong anyway, the only remaining thing in its favor is that it&#39;s more syntactically convenient. Well, I think that&#39;s a problem. It must not be syntactically more convenient. Let&#39;s not encourage the use of defer to implement a loop.<br></p><p>Keeping the C-style for loop would help avoid defer being used in that situation. Adding an optional increment clause to a while loop could do the trick too. There might be better solutions. But please, not defer.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 10, 2015 at 03:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 12:16 PM, Michel Fortin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; You can&#39;t replace C-style for loops with for-in in the general case. Using<br>&gt; a &quot;while&quot; loop will always be possible, but also much more verbose. For<br>&gt; instance, take this loop iterating downward over i and j in lockstep:<br>&gt;<br>&gt;         for var i = 10, j = 20; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;                 ... loop body ...<br>&gt;         }<br>&gt;<br>&gt; The only fully-compatible while loop that makes sense is this one:<br>&gt;<br>&gt;         do {<br>&gt;                 var i = 10<br>&gt;                 var j = 20<br>&gt;                 var first = true<br>&gt;                 while true {<br>&gt;                         if first { first = false }<br>&gt;                         else { i -= 1; j -= 2 }<br>&gt;                         guard i &gt; 0 &amp;&amp; j &gt; 0 else { break }<br>&gt;                         ... loop body ...<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; If the loop body contains a continue, it works. If the loop body mutates<br>&gt; one of the loop variables, it works. If the loop throws, it works. If the<br>&gt; outer scope has a variable with the same name, it works! There is no code<br>&gt; duplication. But oh boy, the boilerplate!<br>&gt;<br></p><p>Can&#39;t you do the following?<br></p><p>    var i = 10, j = 20; while i &gt; 0 &amp;&amp; j &gt; 0 { defer { i -= 1; j -= 2 }<br>        // ...<br>    }<br></p><p>I adjusted the formatting to more closely match the C-style for loop, so if<br>you were to use a more Swift-y style, it would be slightly more verbose.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/88281597/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 10, 2015 at 03:00:00pm</p></header><div class="content"><p>Le 10 déc. 2015 à 15:13, Stephen Celis &lt;stephen.celis at gmail.com&gt; a écrit :<br></p><p>&gt; Can&#39;t you do the following?<br>&gt; <br>&gt;     var i = 10, j = 20; while i &gt; 0 &amp;&amp; j &gt; 0 { defer { i -= 1; j -= 2 }<br>&gt;         // ...<br>&gt;     }<br></p><p>In this particular case you can and it won&#39;t have any noticeable side effects. But in the general case it has a different behaviour: the increment part is called on break or throw. Just imagine a loop body like this one:<br></p><p>	defer { i += 1 }<br>	if i == Int.max { break }<br></p><p>I know I keep coming up with made-up examples to disqualify smart replacements. That might seem artificial, and it certainly is. But any migration tool needs to guaranty identical behaviour.<br></p><p>I&#39;m also starting to wonder if this example with defer that keeps coming up (it&#39;s probably the third time already) is an indicator that people will start to depend on clever tricks like this one, failing to realize the subtle change in semantics it introduces.<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 10, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; In this particular case you can and it won&#39;t have any noticeable side effects. But in the general case it has a different behaviour: the increment part is called on break or throw<br></p><p>I know there’s no single replacement that compactly implements the exact behavior of a `for` loop using a `while` loop. But we don’t usually have to mimic the full behavior:<br></p><p>* The vast majority of for loops don’t use an iteration variable which shadows something in the enclosing scope, so the fact that the variable isn’t scoped to the loop doesn’t usually matter.<br>* The vast majority of for loops don’t have iteration statements which cause side effects beyond the statement itself, so the fact that `defer` will run an extra time if you exit the loop with `break` or `throw` doesn’t usually matter.<br></p><p>If we provide a fix-it, we should try to make sure it doesn’t write broken code. But if that means that, sometimes, we throw up our hands and don’t offer an automatic translation, I don’t think that’s the end of the world. If you’re maintaining code with bizarre, gnarly C-style for loops with no obvious translation, you probably know how to rewrite them as while loops.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Review] SE-0007 Remove C-style for-loops with conditions and incrementers</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>Le 10 déc. 2015 à 16:35, Brent Royal-Gordon &lt;brent at architechies.com&gt; a écrit :<br></p><p>&gt;&gt; In this particular case you can and it won&#39;t have any noticeable side effects. But in the general case it has a different behaviour: the increment part is called on break or throw<br>&gt; <br>&gt; I know there’s no single replacement that compactly implements the exact behavior of a `for` loop using a `while` loop. But we don’t usually have to mimic the full behavior:<br>&gt; <br>&gt; * The vast majority of for loops don’t use an iteration variable which shadows something in the enclosing scope, so the fact that the variable isn’t scoped to the loop doesn’t usually matter.<br></p><p>Note that this is actually true *because* the variable is scoped. It&#39;s very common to have two loops in a row using the same variable name. This could of course be detected somehow by the migration tool, which could do a reasonably intelligent job here. I&#39;m not that much concerned about this, it&#39;s just a minor nuisance.<br></p><p><br>&gt; * The vast majority of for loops don’t have iteration statements which cause side effects beyond the statement itself, so the fact that `defer` will run an extra time if you exit the loop with `break` or `throw` doesn’t usually matter.<br></p><p>If you discount potential integer overflows, you&#39;re right that increments generally won&#39;t have side effects.<br></p><p><br>&gt; If we provide a fix-it, we should try to make sure it doesn’t write broken code. But if that means that, sometimes, we throw up our hands and don’t offer an automatic translation, I don’t think that’s the end of the world. <br></p><p>So, how do you propose the fix-it tool determines which code has side effects and which code doesn&#39;t? I don&#39;t think it can. It certainly could recognize some common safe patterns and offer tailored solutions to these patterns however, if you invest enough time in the tool.<br></p><p>There is never a reason for the fix-it tool to abort and not offer a translation. There is a simple solution that will work in all cases, which I presented in my review. It&#39;s ugly and verbose. But it&#39;s better to have ugly code that is guarantied to works than leaving the code in an uncompilable state.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] Remove C-style for-loops with conditions and incrementers</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>Review of SE-0007<br></p><p>* What is your evaluation of the proposal?<br></p><p>I can understand how this change is controversial - however, I’m in favor of it.<br></p><p>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Many examples have been given on the list of for loops that look more complex or involve additional nesting once C-style for loops are eliminated. However, I couldn’t help thinking many of these examples are greatly complex in themselves - that using a functional syntax (even if it makes the line longer or has the sequence building moved to another function) serves to make the code intrinsically more readable and maintainable.<br></p><p>For example, <br></p><p>	for i in (0..&lt;things.length).reverse() { … } is longer/more verbose, but is also very clear in purpose<br></p><p>For someone coming from C, for loop support may help them port their code quicker. However, for someone without C experience, the syntax and rules are different than the rest of the language (for instance, the for loop is the only construct which requires a semicolon for expression).<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>With ++ and -- operators slated for removal, the main motivator for having for loop support (ease of porting C-dialect code) is greatly reduced.<br></p><p>There is a push to use functional concepts in Swift (avoiding terms like Monoids and Monads since the theory isn’t needed for usage). Every for loop I’ve ever seen is non-functional, and the availability of the feature pushes people toward imperative thinking and coding.<br></p><p>** Additional feedback on evaluation<br></p><p>I *wish* there was greater consistency with blocks and closures, so that for - in … {…} wasn’t required in addition to .forEach {…}.<br></p><p>Some of the concepts given seem like they may warrant language use guidance (such as in TSPL book):<br></p><p>	for i in 0..&lt;things.length { … } <br></p><p>should perhaps instead be <br></p><p>	for i in things.indices { … }<br></p><p>* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The main language I’ve used without for loops is ruby. I honestly didn’t realize they were missing until another review stated so - once I moved away from using them, I’ve never been motivated to go back.<br></p><p>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve followed the mailing list discussion and looked at my own code.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/d3ef6cad/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review] Remove C-style for-loops with conditions and incrementers</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>Review of SE-0007<br></p><p>* What is your evaluation of the proposal?<br></p><p>I am against this change. I’ve seen no consideration of the performance implications that this change brings about. Also, many of the proposed alternatives tend towards using defer as the mechanism to provide consistent increments/decrements. However, this is problematic around the boundary edges as break and throw are not mechanisms that can halt the execution of the defer statement. So unlike the c-style loop that would not perform that code, the alternatives would.<br></p><p>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>No; it offers no alternative solution to maintain the performance that a c-style for-loop ensures. There is no general pattern than can be used to satisfy a c-style loop’s behavior; each proposed alternative has different issues.<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>No, it limits the language’s ability to create concise and legible code when the situation does arise for a c-style loop.<br></p><p>This is the alternative to create a loop that matches the same functionality, including preventing the leaking of loop-variables.<br></p><p>var sum = 0<br>for var i = 1000, j = 2000; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>    if i % 2 == 0 { continue }<br>    sum += 1<br>}<br>print(sum)<br></p><p>// versus<br></p><p>var sum = 0<br></p><p>if true { // some arbitrary scope mechanism is needed to contain i and j<br>    var i = 1000, j = 2000<br>    while i &gt; 0 &amp;&amp; j &gt; 0 {<br>        defer {<br>            i -= 1<br>            j -= 2<br>        }<br>        <br>        if i % 2 == 0 { continue }<br>        sum += 1<br>    }<br>}<br></p><p>print(sum)<br></p><p>To me, that is not a fair trade-off; maybe if the defer pattern could be used at all times and the leaking of the loop-variables was considered ok. There are some ways to consolidate the code so that it takes up less visual space, but I don’t do that for other constructs, so I don’t think that is a valid thing to try and do here. Also, the use of defer in this context is a somewhat of a trick that I’m not sure is even a good pattern to promote as it can lead to boundary-case crashes.<br></p><p>This is unsafe code:<br></p><p>var sum = 0<br>var i: UInt = 1000<br>while i &gt;= 0 {<br>    defer {<br>        i -= 1<br>    }<br>    if i == 0 {<br>        print(&quot;zero has been reached!&quot;)<br>        break<br>    }<br></p><p>    if i % 2 == 0 { continue }<br>    sum += 1<br>}<br></p><p>The defer statement is still executed, so now I need to come up with a different pattern to handle this type of problem.<br></p><p>* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>n/a<br></p><p>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A few hours. I’ve read the proposal multiple times and followed the mail threads. I’ve also done some basic performance analysis (attached mail) on the problem for some of the “improved” versions of the loop construct.<br></p><p>-David<br></p><p><br></p><p>&gt; On Dec 7, 2015, at 12:44 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Remove C-style for-loops with conditions and incrementers” begins now and runs through Thursday, December 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; 	Cheers,<br>&gt; 	Doug Gregor<br>&gt; 	Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/3d1d78c4/attachment.html&gt;<br>-------------- next part --------------<br>An embedded message was scrubbed...<br>From: David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Review] SE-0007 Remove C-style for-loops<br>	with conditions and incrementers<br>Date: Thu, 10 Dec 2015 15:36:52 -0800<br>Size: 27384<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/3d1d78c4/attachment.eml&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/3d1d78c4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[swift-evolution-announce] [Review] Remove C-style for-loops with conditions and incrementers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 5:17 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Review of SE-0007<br>&gt; <br>&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; I am against this change. I’ve seen no consideration of the performance implications that this change brings about. Also, many of the proposed alternatives tend towards using defer as the mechanism to provide consistent increments/decrements. However, this is problematic around the boundary edges as break and throw are not mechanisms that can halt the execution of the defer statement. So unlike the c-style loop that would not perform that code, the alternatives would.<br>&gt; <br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; No; it offers no alternative solution to maintain the performance that a c-style for-loop ensures. There is no general pattern than can be used to satisfy a c-style loop’s behavior; each proposed alternative has different issues.<br>&gt; <br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; No, it limits the language’s ability to create concise and legible code when the situation does arise for a c-style loop.<br>&gt; <br>&gt; This is the alternative to create a loop that matches the same functionality, including preventing the leaking of loop-variables.<br>&gt; <br>&gt; var sum = 0<br>&gt; for var i = 1000, j = 2000; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;     if i % 2 == 0 { continue }<br>&gt;     sum += 1<br>&gt; }<br>&gt; print(sum)<br>&gt; <br>&gt; // versus<br>&gt; <br>&gt; var sum = 0<br>&gt; <br>&gt; if true { // some arbitrary scope mechanism is needed to contain i and j<br>&gt;     var i = 1000, j = 2000<br>&gt;     while i &gt; 0 &amp;&amp; j &gt; 0 {<br>&gt;         defer {<br>&gt;             i -= 1<br>&gt;             j -= 2<br>&gt;         }<br>&gt;         <br>&gt;         if i % 2 == 0 { continue }<br>&gt;         sum += 1<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; print(sum)<br>&gt; <br>&gt; To me, that is not a fair trade-off; maybe if the defer pattern could be used at all times and the leaking of the loop-variables was considered ok. There are some ways to consolidate the code so that it takes up less visual space, but I don’t do that for other constructs, so I don’t think that is a valid thing to try and do here. Also, the use of defer in this context is a somewhat of a trick that I’m not sure is even a good pattern to promote as it can lead to boundary-case crashes.<br>&gt; <br>&gt; This is unsafe code:<br>&gt; <br>&gt; var sum = 0<br>&gt; var i: UInt = 1000<br>&gt; while i &gt;= 0 {<br>&gt;     defer {<br>&gt;         i -= 1<br>&gt;     }<br>&gt;     if i == 0 {<br>&gt;         print(&quot;zero has been reached!&quot;)<br>&gt;         break<br>&gt;     }<br>&gt; <br>&gt;     if i % 2 == 0 { continue }<br>&gt;     sum += 1<br>&gt; }<br>&gt; <br>&gt; The defer statement is still executed, so now I need to come up with a different pattern to handle this type of problem.<br>&gt; <br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; n/a<br>&gt; <br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; A few hours. I’ve read the proposal multiple times and followed the mail threads. I’ve also done some basic performance analysis (attached mail) on the problem for some of the “improved” versions of the loop construct.<br></p><p>Performance is definitely a consideration; we already reverted a pull request that remove C-style fors from the standard library. I believe Andy is currently looking into where the regressions come from. stride(...) performing poorly seems like something we should fix regardless, since that&#39;s arguably the idiomatic way to write such loops and ought to perform well. I agree we should investigate ways to ensure common loops over ranges or strides perform reasonably at -Onone if we move forward with this.<br></p><p>-Joe<br></p><p>&gt; -David<br>&gt; <br>&gt; &lt;SE-0007 Remove C-style for-loops with conditions and incrementers - Performance Consideration.eml&gt;<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 12:44 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Remove C-style for-loops with conditions and incrementers” begins now and runs through Thursday, December 10th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; <br>&gt;&gt; 	Cheers,<br>&gt;&gt; 	Doug Gregor<br>&gt;&gt; 	Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt; swift-evolution-announce at swift.org &lt;mailto:swift-evolution-announce at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce &lt;https://lists.swift.org/mailman/listinfo/swift-evolution-announce&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/67475cb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18c60397fcda8f42900d42ba4db4f029?s=50"></div><header><strong>[swift-evolution-announce] [Review] Remove C-style for-loops with conditions and incrementers</strong> from <string>Nadav Rotem</string> &lt;nrotem at apple.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 9:09 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 10, 2015, at 5:17 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Review of SE-0007<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I am against this change. I’ve seen no consideration of the performance implications that this change brings about. Also, many of the proposed alternatives tend towards using defer as the mechanism to provide consistent increments/decrements. However, this is problematic around the boundary edges as break and throw are not mechanisms that can halt the execution of the defer statement. So unlike the c-style loop that would not perform that code, the alternatives would.<br></p><p>In the general case for-each loops are as efficient as c-style for loops. For example, the memset function below is optimized to something that is equivalent to the performance of C’s memset (no bounds checks, no overflow checks, vectorized, unrolled, etc). <br></p><p>I reverted the changes in the standard library because they exposed a problem in a different part of the code. The code for for-each is larger than c-style loops before it is optimized. According to Arnold, this changed the inlining decision and caused an extra retain/release pair, that slowed down String. <br></p><p><br>func memset(inout a: [Int], _ c: Int) {<br>  for i in 0..&lt;a.count {<br>    a[i] = c <br>  }<br>}<br></p><p><br>&gt;&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; No; it offers no alternative solution to maintain the performance that a c-style for-loop ensures. There is no general pattern than can be used to satisfy a c-style loop’s behavior; each proposed alternative has different issues.<br>&gt;&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; No, it limits the language’s ability to create concise and legible code when the situation does arise for a c-style loop.<br>&gt;&gt; <br>&gt;&gt; This is the alternative to create a loop that matches the same functionality, including preventing the leaking of loop-variables.<br>&gt;&gt; <br>&gt;&gt; var sum = 0<br>&gt;&gt; for var i = 1000, j = 2000; i &gt; 0 &amp;&amp; j &gt; 0; i -= 1, j -= 2 {<br>&gt;&gt;     if i % 2 == 0 { continue }<br>&gt;&gt;     sum += 1<br>&gt;&gt; }<br>&gt;&gt; print(sum)<br>&gt;&gt; <br>&gt;&gt; // versus<br>&gt;&gt; <br>&gt;&gt; var sum = 0<br>&gt;&gt; <br>&gt;&gt; if true { // some arbitrary scope mechanism is needed to contain i and j<br>&gt;&gt;     var i = 1000, j = 2000<br>&gt;&gt;     while i &gt; 0 &amp;&amp; j &gt; 0 {<br>&gt;&gt;         defer {<br>&gt;&gt;             i -= 1<br>&gt;&gt;             j -= 2<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         if i % 2 == 0 { continue }<br>&gt;&gt;         sum += 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; print(sum)<br>&gt;&gt; <br>&gt;&gt; To me, that is not a fair trade-off; maybe if the defer pattern could be used at all times and the leaking of the loop-variables was considered ok. There are some ways to consolidate the code so that it takes up less visual space, but I don’t do that for other constructs, so I don’t think that is a valid thing to try and do here. Also, the use of defer in this context is a somewhat of a trick that I’m not sure is even a good pattern to promote as it can lead to boundary-case crashes.<br>&gt;&gt; <br>&gt;&gt; This is unsafe code:<br>&gt;&gt; <br>&gt;&gt; var sum = 0<br>&gt;&gt; var i: UInt = 1000<br>&gt;&gt; while i &gt;= 0 {<br>&gt;&gt;     defer {<br>&gt;&gt;         i -= 1<br>&gt;&gt;     }<br>&gt;&gt;     if i == 0 {<br>&gt;&gt;         print(&quot;zero has been reached!&quot;)<br>&gt;&gt;         break<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     if i % 2 == 0 { continue }<br>&gt;&gt;     sum += 1<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The defer statement is still executed, so now I need to come up with a different pattern to handle this type of problem.<br>&gt;&gt; <br>&gt;&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; n/a<br>&gt;&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; A few hours. I’ve read the proposal multiple times and followed the mail threads. I’ve also done some basic performance analysis (attached mail) on the problem for some of the “improved” versions of the loop construct.<br>&gt; <br>&gt; Performance is definitely a consideration; we already reverted a pull request that remove C-style fors from the standard library. I believe Andy is currently looking into where the regressions come from. stride(...) performing poorly seems like something we should fix regardless, since that&#39;s arguably the idiomatic way to write such loops and ought to perform well. I agree we should investigate ways to ensure common loops over ranges or strides perform reasonably at -Onone if we move forward with this.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; &lt;SE-0007 Remove C-style for-loops with conditions and incrementers - Performance Consideration.eml&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 12:44 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;Remove C-style for-loops with conditions and incrementers” begins now and runs through Thursday, December 10th. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	Cheers,<br>&gt;&gt;&gt; 	Doug Gregor<br>&gt;&gt;&gt; 	Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt;&gt; swift-evolution-announce at swift.org &lt;mailto:swift-evolution-announce at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce &lt;https://lists.swift.org/mailman/listinfo/swift-evolution-announce&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/56bfdb04/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] Remove C-style for-loops with conditions and incrementers</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>Thanks to everyone for participating in this review!<br></p><p>	- Doug<br></p><p>&gt; On Dec 7, 2015, at 12:44 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Remove C-style for-loops with conditions and incrementers” begins now and runs through Thursday, December 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; 	Cheers,<br>&gt; 	Doug Gregor<br>&gt; 	Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/c4adcc46/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
