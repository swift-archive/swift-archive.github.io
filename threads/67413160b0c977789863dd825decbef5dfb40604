<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/214d1bb1587020b60ef37c85b887562e?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Alex Johnson</string> &lt;ajohnson at quickleft.com&gt;<p>January  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I&#39;m curious how other members of the Swift community feel about the clarity<br>of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that the<br>default type for integers is &quot;Int&quot;, but the default type for floating point<br>numbers is not &quot;Float&quot;.<br></p><p>What if the name &quot;Float&quot; were given to the intrinsic, 64-bit floating point<br>type? (And the existing &quot;Float&quot; and &quot;Double&quot; names were removed in favor of<br>&quot;Float32&quot; and &quot;Float64&quot;?)<br></p><p><br>*Discussion:*<br></p><p>I understand the origins of these names in single- and double-precision<br>IEEE floats. But this distinction feels like a holdover from C (and a<br>32-bit world), rather than a natural fit for Swift.<br></p><p>Here are some reasons to *keep Double and Float as they are* (numbered for<br>easy reference, but otherwise unordered):<br></p><p>   1. &quot;Double&quot; and &quot;Float&quot; are more natural for developers who are<br>   &quot;familiar with C-like languages.&quot;<br>   2. A corollary: A 64-bit &quot;Float&quot; type could be confusing to those<br>   developers.<br>   3. Another corollary: Swift needs to interoperate with Objective C, and<br>   its &quot;float&quot; and &quot;double&quot; types.<br>   4. Renaming these types would open the door to bike-shedding every type<br>   name and keyword in the language.<br>   5. Changing the meaning of an existing type (&quot;Float&quot;) would be a bit<br>   PITA for existing code (although an automated migration from &quot;Float&quot; to<br>   &quot;Float32&quot; and &quot;Double&quot; to &quot;Float&quot; should be possible).<br>   6. Renaming a fundamental type would take considerable effort.<br></p><p>Here are some reasons to *rename these types*:<br></p><p>   1. The default for a &quot;float literal&quot; in Swift is a 64-bit value. It<br>   would feel natural if that that value were of type &quot;Float&quot;.<br>   2. There are size-specific names for 32-bit (&quot;Float32&quot;) and 64-bit<br>   (&quot;Float64&quot;) floating point types. For cases where a size-specific type is<br>   needed, a size-specific name like &quot;Float32&quot; probably makes the intention of<br>   the code more clear (compared to just &quot;Float&quot;).<br>   3. Apple&#39;s Objective C APIs generally use aliased types like &quot;CGFloat&quot;<br>   rather than raw float or double types.<br>   4. There is precedent for &quot;Float&quot; types being 64-bit in other languages<br>   like Ruby, Python and Go (as long as the hardware supports it).<br>   5. What kind of a name for a type is &quot;Double&quot; anyways, amirite?<br></p><p>(that last one is a joke, BTW)<br></p><p>What do you think? Do you agree or disagree with any of my assessments? Are<br>there any pros or cons that I&#39;ve missed? Is the level of effort so large<br>that it makes this change impractical? Is it a colossal waste of human<br>effort to even consider a change like this?<br></p><p>Thanks for your time and attention,<br>Alex Johnson (@nonsensery)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/67410604/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  5, 2016 at 10:00:00am</p></header><div class="content"><p>+1. I think it brings a nice symmetry with the integer types and puts size classing in a more consistent place.<br></p><p>And to be frank, I already typedef the intrinsic float/double types in my C code to f32/f64 for similar reasons.<br></p><p>-David<br></p><p>&gt; On Jan 4, 2016, at 12:58 PM, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;m curious how other members of the Swift community feel about the clarity of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that the default type for integers is &quot;Int&quot;, but the default type for floating point numbers is not &quot;Float&quot;.<br>&gt; <br>&gt; What if the name &quot;Float&quot; were given to the intrinsic, 64-bit floating point type? (And the existing &quot;Float&quot; and &quot;Double&quot; names were removed in favor of &quot;Float32&quot; and &quot;Float64&quot;?)<br>&gt; <br>&gt; <br>&gt; Discussion:<br>&gt; <br>&gt; I understand the origins of these names in single- and double-precision IEEE floats. But this distinction feels like a holdover from C (and a 32-bit world), rather than a natural fit for Swift.<br>&gt; <br>&gt; Here are some reasons to keep Double and Float as they are (numbered for easy reference, but otherwise unordered):<br>&gt; &quot;Double&quot; and &quot;Float&quot; are more natural for developers who are &quot;familiar with C-like languages.&quot;<br>&gt; A corollary: A 64-bit &quot;Float&quot; type could be confusing to those developers.<br>&gt; Another corollary: Swift needs to interoperate with Objective C, and its &quot;float&quot; and &quot;double&quot; types.<br>&gt; Renaming these types would open the door to bike-shedding every type name and keyword in the language.<br>&gt; Changing the meaning of an existing type (&quot;Float&quot;) would be a bit PITA for existing code (although an automated migration from &quot;Float&quot; to &quot;Float32&quot; and &quot;Double&quot; to &quot;Float&quot; should be possible).<br>&gt; Renaming a fundamental type would take considerable effort.<br>&gt; Here are some reasons to rename these types:<br>&gt; The default for a &quot;float literal&quot; in Swift is a 64-bit value. It would feel natural if that that value were of type &quot;Float&quot;.<br>&gt; There are size-specific names for 32-bit (&quot;Float32&quot;) and 64-bit (&quot;Float64&quot;) floating point types. For cases where a size-specific type is needed, a size-specific name like &quot;Float32&quot; probably makes the intention of the code more clear (compared to just &quot;Float&quot;).<br>&gt; Apple&#39;s Objective C APIs generally use aliased types like &quot;CGFloat&quot; rather than raw float or double types.<br>&gt; There is precedent for &quot;Float&quot; types being 64-bit in other languages like Ruby, Python and Go (as long as the hardware supports it).<br>&gt; What kind of a name for a type is &quot;Double&quot; anyways, amirite?<br>&gt; (that last one is a joke, BTW)<br>&gt; <br>&gt; What do you think? Do you agree or disagree with any of my assessments? Are there any pros or cons that I&#39;ve missed? Is the level of effort so large that it makes this change impractical? Is it a colossal waste of human effort to even consider a change like this?<br>&gt; <br>&gt; Thanks for your time and attention,<br>&gt; Alex Johnson (@nonsensery)<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/8a7c3866/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  5, 2016 at 10:00:00am</p></header><div class="content"><p>On Jan 4, 2016, at 12:58 PM, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;m curious how other members of the Swift community feel about the clarity of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that the default type for integers is &quot;Int&quot;, but the default type for floating point numbers is not &quot;Float”.<br></p><p>&gt; Discussion:<br>&gt; <br>&gt; I understand the origins of these names in single- and double-precision IEEE floats. But this distinction feels like a holdover from C (and a 32-bit world), rather than a natural fit for Swift.<br></p><p>Yes, the proper IEEE names for these would be “Single” and “Double”.  We briefly considered and rejected that.<br></p><p>&gt; Here are some reasons to keep Double and Float as they are (numbered for easy reference, but otherwise unordered):<br>&gt; &quot;Double&quot; and &quot;Float&quot; are more natural for developers who are &quot;familiar with C-like languages.&quot;<br>&gt; A corollary: A 64-bit &quot;Float&quot; type could be confusing to those developers.<br>Yes, I think that 64-bit Float would be *actively* confusing to people, and using that name could cause real harm.<br></p><p>&gt; Here are some reasons to rename these types:<br>&gt; The default for a &quot;float literal&quot; in Swift is a 64-bit value. It would feel natural if that that value were of type &quot;Float&quot;.<br>&gt; There are size-specific names for 32-bit (&quot;Float32&quot;) and 64-bit (&quot;Float64&quot;) floating point types. For cases where a size-specific type is needed, a size-specific name like &quot;Float32&quot; probably makes the intention of the code more clear (compared to just &quot;Float&quot;).<br>&gt; Apple&#39;s Objective C APIs generally use aliased types like &quot;CGFloat&quot; rather than raw float or double types.<br>&gt; There is precedent for &quot;Float&quot; types being 64-bit in other languages like Ruby, Python and Go (as long as the hardware supports it).<br>&gt; What kind of a name for a type is &quot;Double&quot; anyways, amirite?<br>Aside from #3 (CGFloat is a distinct type in Swift, not an alias) and #5 :-)  I agree with these points.<br></p><p>That said, personally, my feeling is that the momentum here in the broad family of C languages (including things like Java) is very strong, and that diverging from that would be extremely problematic.  I don’t see any “active&quot; problems with our current names.  If this is a matter of aesthetics, or an attempt to align with Ruby/Python/Go instead of C/Java etc, then this seems like the wrong direction for Swift.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/703d0a1f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  5, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; That said, personally, my feeling is that the momentum here in the broad family of C languages (including things like Java) is very strong, and that diverging from that would be extremely problematic.  I don’t see any “active&quot; problems with our current names.  If this is a matter of aesthetics, or an attempt to align with Ruby/Python/Go instead of C/Java etc, then this seems like the wrong direction for Swift.<br></p><p><br>Losing alignment to C-like paradigms is a valid concern, but then removing unwary decrement and increment operators feels out of place... Sad to have seen it culled.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 5 Jan 2016, at 18:40, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 12:58 PM, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I&#39;m curious how other members of the Swift community feel about the clarity of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that the default type for integers is &quot;Int&quot;, but the default type for floating point numbers is not &quot;Float”.<br>&gt; <br>&gt;&gt; Discussion:<br>&gt;&gt; <br>&gt;&gt; I understand the origins of these names in single- and double-precision IEEE floats. But this distinction feels like a holdover from C (and a 32-bit world), rather than a natural fit for Swift.<br>&gt; <br>&gt; Yes, the proper IEEE names for these would be “Single” and “Double”.  We briefly considered and rejected that.<br>&gt; <br>&gt;&gt; Here are some reasons to keep Double and Float as they are (numbered for easy reference, but otherwise unordered):<br>&gt;&gt; &quot;Double&quot; and &quot;Float&quot; are more natural for developers who are &quot;familiar with C-like languages.&quot;<br>&gt;&gt; A corollary: A 64-bit &quot;Float&quot; type could be confusing to those developers.<br>&gt; Yes, I think that 64-bit Float would be *actively* confusing to people, and using that name could cause real harm.<br>&gt; <br>&gt;&gt; Here are some reasons to rename these types:<br>&gt;&gt; The default for a &quot;float literal&quot; in Swift is a 64-bit value. It would feel natural if that that value were of type &quot;Float&quot;.<br>&gt;&gt; There are size-specific names for 32-bit (&quot;Float32&quot;) and 64-bit (&quot;Float64&quot;) floating point types. For cases where a size-specific type is needed, a size-specific name like &quot;Float32&quot; probably makes the intention of the code more clear (compared to just &quot;Float&quot;).<br>&gt;&gt; Apple&#39;s Objective C APIs generally use aliased types like &quot;CGFloat&quot; rather than raw float or double types.<br>&gt;&gt; There is precedent for &quot;Float&quot; types being 64-bit in other languages like Ruby, Python and Go (as long as the hardware supports it).<br>&gt;&gt; What kind of a name for a type is &quot;Double&quot; anyways, amirite?<br>&gt; Aside from #3 (CGFloat is a distinct type in Swift, not an alias) and #5 :-)  I agree with these points.<br>&gt; <br>&gt; That said, personally, my feeling is that the momentum here in the broad family of C languages (including things like Java) is very strong, and that diverging from that would be extremely problematic.  I don’t see any “active&quot; problems with our current names.  If this is a matter of aesthetics, or an attempt to align with Ruby/Python/Go instead of C/Java etc, then this seems like the wrong direction for Swift.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/5a8e2a53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 11:20 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; That said, personally, my feeling is that the momentum here in the broad family of C languages (including things like Java) is very strong, and that diverging from that would be extremely problematic.  I don’t see any “active&quot; problems with our current names.  If this is a matter of aesthetics, or an attempt to align with Ruby/Python/Go instead of C/Java etc, then this seems like the wrong direction for Swift.<br>&gt; <br>&gt; <br>&gt; Losing alignment to C-like paradigms is a valid concern, but then removing unwary decrement and increment operators feels out of place... Sad to have seen it culled.<br></p><p>These are functionally different cases.  We are *omitting* a C feature by removing ++ and --.  This proposal included keeping the name “Double” but giving it a different meaning.<br></p><p>There are good and bad parts of C syntax.  The goal is not to cargo cult all of the bad parts of C into Swift, it is to keep the good parts and discard the bad parts.  For things that could go either way, we should keep alignment with C.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/3d03112c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/214d1bb1587020b60ef37c85b887562e?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Alex Johnson</string> &lt;ajohnson at quickleft.com&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>Just to clarify: I was suggesting removing the name &quot;Double&quot; and giving a<br>different meaning to the name &quot;Float&quot;.<br></p><p>~ Alex<br></p><p>On Tue, Jan 5, 2016 at 11:51 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>These are functionally different cases.  We are *omitting* a C feature by<br>&gt; removing ++ and --.  This proposal included keeping the name “Double” but<br>&gt; giving it a different meaning.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/3313afde/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  5, 2016 at 03:00:00pm</p></header><div class="content"><p>In principle, having Float, Float32, and Float64 and no “Double” at all seems highly sensible to me.<br></p><p>In practice, the migration cost of changing the meaning of Float from “32-bit” to “platform preferred size” seems like a potential deal-killer.<br></p><p>P<br></p><p>&gt; On Jan 5, 2016, at 2:25 PM, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just to clarify: I was suggesting removing the name &quot;Double&quot; and giving a different meaning to the name &quot;Float&quot;.<br>&gt; <br>&gt; ~ Alex<br>&gt; <br>&gt; On Tue, Jan 5, 2016 at 11:51 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; These are functionally different cases.  We are *omitting* a C feature by removing ++ and --.  This proposal included keeping the name “Double” but giving it a different meaning.<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/432952bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>January  5, 2016 at 04:00:00pm</p></header><div class="content"><p>What would this actually gain, other than most floating-point code producing different results even for basic arithmetic when run on differing platforms?  Having “Int” mean “native word size” is tolerable because:<br></p><p>(a) most integer code deals with small numbers for which the result is the same either way<br>(b) if the result were different due to overflow, that would trap in Swift<br></p><p>Neither of these properties holds for floating-point.  1/3 will give one result on one platform, and another result on another platform.  Floating-point has enough misunderstood sharp edges as is.  We don’t need to add more.<br></p><p>– Steve<br></p><p>&gt; On Jan 5, 2016, at 4:10 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In principle, having Float, Float32, and Float64 and no “Double” at all seems highly sensible to me.<br>&gt; <br>&gt; In practice, the migration cost of changing the meaning of Float from “32-bit” to “platform preferred size” seems like a potential deal-killer.<br>&gt; <br>&gt; P<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 2:25 PM, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just to clarify: I was suggesting removing the name &quot;Double&quot; and giving a different meaning to the name &quot;Float&quot;.<br>&gt;&gt; <br>&gt;&gt; ~ Alex<br>&gt;&gt; <br>&gt;&gt; On Tue, Jan 5, 2016 at 11:51 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; These are functionally different cases.  We are *omitting* a C feature by removing ++ and --.  This proposal included keeping the name “Double” but giving it a different meaning.<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/df0ac9f9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>January  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; That said, personally, my feeling is that the momentum here in the broad family of C languages (including things like Java) is very strong, and that diverging from that would be extremely problematic.  I don’t see any “active&quot; problems with our current names.  If this is a matter of aesthetics, or an attempt to align with Ruby/Python/Go instead of C/Java etc, then this seems like the wrong direction for Swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Losing alignment to C-like paradigms is a valid concern, but then removing unwary decrement and increment operators feels out of place... Sad to have seen it culled.<br>&gt; <br>&gt; These are functionally different cases.  We are *omitting* a C feature by removing ++ and --.  This proposal included keeping the name “Double” but giving it a different meaning.<br>&gt; <br>&gt; There are good and bad parts of C syntax.  The goal is not to cargo cult all of the bad parts of C into Swift, it is to keep the good parts and discard the bad parts.  For things that could go either way, we should keep alignment with C.<br></p><p>All these points are sensible but from a standpoint of my real world experience we end up using a typealias for CGFloat in most scenarios because it does precisely what we want; that being it tracks natural size.  I presume this is also the only reason Apple’s frameworks ever defined it.<br></p><p>I would say, again from my experience, dropping Double and making Float track the machine size would be a valid thing to do.  It would also provide a bit of synergy with the way Int is handled.  Finally, as far as I know there is no “Long” or “LongLong” type in Swift, as there is in C/Java, so some precedent has been set to do this as well.<br></p><p>-kw<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/9bd1c7e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 13:22, Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; That said, personally, my feeling is that the momentum here in the broad family of C languages (including things like Java) is very strong, and that diverging from that would be extremely problematic.  I don’t see any “active&quot; problems with our current names.  If this is a matter of aesthetics, or an attempt to align with Ruby/Python/Go instead of C/Java etc, then this seems like the wrong direction for Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Losing alignment to C-like paradigms is a valid concern, but then removing unwary decrement and increment operators feels out of place... Sad to have seen it culled.<br>&gt;&gt; <br>&gt;&gt; These are functionally different cases.  We are *omitting* a C feature by removing ++ and --.  This proposal included keeping the name “Double” but giving it a different meaning.<br>&gt;&gt; <br>&gt;&gt; There are good and bad parts of C syntax.  The goal is not to cargo cult all of the bad parts of C into Swift, it is to keep the good parts and discard the bad parts.  For things that could go either way, we should keep alignment with C.<br>&gt; <br>&gt; All these points are sensible but from a standpoint of my real world experience we end up using a typealias for CGFloat in most scenarios because it does precisely what we want; that being it tracks natural size.  I presume this is also the only reason Apple’s frameworks ever defined it.<br>&gt; <br>&gt; I would say, again from my experience, dropping Double and making Float track the machine size would be a valid thing to do.  It would also provide a bit of synergy with the way Int is handled.  Finally, as far as I know there is no “Long” or “LongLong” type in Swift, as there is in C/Java, so some precedent has been set to do this as well.<br></p><p>It&#39;s really not useful to have Float track the machine size. In pretty much all cases, you either care about precision or you care about memory usage. CPU word size is somewhat correlated with available RAM, but not so strongly.<br></p><p>Alex&#39;s original proposal was to make Float be Float64, always.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/6be386d4/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  5, 2016 at 07:00:00pm</p></header><div class="content"><p>Is there a reason we need a Double as well as a Float ? I see the value in<br>Int and Float butt could they not both be the biggest value supported on<br>the platform?<br></p><p><br>Usually when mapped to Objective-C Swift values become NSIntegers anyways<br>which I don&#39;t believe is a pure float or double.<br></p><p>On Tue, Jan 5, 2016 at 7:20 PM, Goffredo Marocchi via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That said, personally, my feeling is that the momentum here in the broad<br>&gt; family of C languages (including things like Java) is very strong, and that<br>&gt; diverging from that would be extremely problematic.  I don’t see any<br>&gt; “active&quot; problems with our current names.  If this is a matter of<br>&gt; aesthetics, or an attempt to align with Ruby/Python/Go instead of C/Java<br>&gt; etc, then this seems like the wrong direction for Swift.<br>&gt;<br>&gt;<br>&gt; Losing alignment to C-like paradigms is a valid concern, but then removing<br>&gt; unwary decrement and increment operators feels out of place... Sad to have<br>&gt; seen it culled.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 5 Jan 2016, at 18:40, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jan 4, 2016, at 12:58 PM, Alex Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I&#39;m curious how other members of the Swift community feel about the<br>&gt; clarity of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that<br>&gt; the default type for integers is &quot;Int&quot;, but the default type for floating<br>&gt; point numbers is not &quot;Float”.<br>&gt;<br>&gt;<br>&gt; *Discussion:*<br>&gt;<br>&gt; I understand the origins of these names in single- and double-precision<br>&gt; IEEE floats. But this distinction feels like a holdover from C (and a<br>&gt; 32-bit world), rather than a natural fit for Swift.<br>&gt;<br>&gt;<br>&gt; Yes, the proper IEEE names for these would be “Single” and “Double”.  We<br>&gt; briefly considered and rejected that.<br>&gt;<br>&gt; Here are some reasons to *keep Double and Float as they are* (numbered<br>&gt; for easy reference, but otherwise unordered):<br>&gt;<br>&gt;    1. &quot;Double&quot; and &quot;Float&quot; are more natural for developers who are<br>&gt;    &quot;familiar with C-like languages.&quot;<br>&gt;    2. A corollary: A 64-bit &quot;Float&quot; type could be confusing to those<br>&gt;    developers.<br>&gt;<br>&gt; Yes, I think that 64-bit Float would be *actively* confusing to people,<br>&gt; and using that name could cause real harm.<br>&gt;<br>&gt; Here are some reasons to *rename these types*:<br>&gt;<br>&gt;    1. The default for a &quot;float literal&quot; in Swift is a 64-bit value. It<br>&gt;    would feel natural if that that value were of type &quot;Float&quot;.<br>&gt;    2. There are size-specific names for 32-bit (&quot;Float32&quot;) and 64-bit<br>&gt;    (&quot;Float64&quot;) floating point types. For cases where a size-specific type is<br>&gt;    needed, a size-specific name like &quot;Float32&quot; probably makes the intention of<br>&gt;    the code more clear (compared to just &quot;Float&quot;).<br>&gt;    3. Apple&#39;s Objective C APIs generally use aliased types like &quot;CGFloat&quot;<br>&gt;    rather than raw float or double types.<br>&gt;    4. There is precedent for &quot;Float&quot; types being 64-bit in other<br>&gt;    languages like Ruby, Python and Go (as long as the hardware supports it).<br>&gt;    5. What kind of a name for a type is &quot;Double&quot; anyways, amirite?<br>&gt;<br>&gt; Aside from #3 (CGFloat is a distinct type in Swift, not an alias) and #5<br>&gt; :-)  I agree with these points.<br>&gt;<br>&gt; That said, personally, my feeling is that the momentum here in the broad<br>&gt; family of C languages (including things like Java) is very strong, and that<br>&gt; diverging from that would be extremely problematic.  I don’t see any<br>&gt; “active&quot; problems with our current names.  If this is a matter of<br>&gt; aesthetics, or an attempt to align with Ruby/Python/Go instead of C/Java<br>&gt; etc, then this seems like the wrong direction for Swift.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/78e42583/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January  6, 2016 at 01:00:00am</p></header><div class="content"><p>I also think that Float and Double are not ideal type names but I also agree with many of the concerns that have been raised.<br></p><p><br>Why not simply use (the existing) Float32 and Float64 while keeping everything else equal?<br></p><p>So as a first step we could encourage the use of Float32/Float64 over Float/Double:<br>Make Float/Double typealiases for Float32/Float64 instead of the reverse which is true today<br>Use Float32/Float64 in documentation and example code<br>Perhaps add a note to the documentation for Float/Double that the Float32/Float64 types should be preferred<br>...<br></p><p>This would not break any existing code and I think would be a positive change in the long term.<br>Also this might have a better chance to be accepted as a proposal and by the community at large.<br></p><p>Making Float32/Float64 the officially preferred types should still help their adoption a lot without the pains involved in removing Float/Double.<br></p><p>And the deprecation and eventual removal of Float/Double could still be considered separately either now or down the road if people actually adopt Float32/Float64. Also migration would be very simple in this case (and stragglers could simply create their own Float/Double typealiases).<br></p><p><br>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/47f554f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 4:41 PM, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I also think that Float and Double are not ideal type names but I also agree with many of the concerns that have been raised.<br>&gt; <br>&gt; <br>&gt; Why not simply use (the existing) Float32 and Float64 while keeping everything else equal?<br></p><p>What perceived problem are you solving?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  6, 2016 at 08:00:00am</p></header><div class="content"><p>Hello Chris,<br></p><p>When dealing with floating point values, wouldn&#39;t it be in our best interest to always be very specific about the accuracy of the floating point type variables we use regardless of the device it runs on? This is the biggest problem I had with CGFloat: while it is nice at first to have a type that adapts to the device word size it runs on, I prefer to always have an explicit accuracy guarantee than worrying about my CGFloat code changing in behaviour when it runs on a 32 bit device rather than a 64 bit one.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 6 Jan 2016, at 02:08, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 4:41 PM, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also think that Float and Double are not ideal type names but I also agree with many of the concerns that have been raised.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Why not simply use (the existing) Float32 and Float64 while keeping everything else equal?<br>&gt; <br>&gt; What perceived problem are you solving?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd1ac9d0a3d774b1938abdb816240014?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>John Randolph</string> &lt;jcr at icloud.com&gt;<p>January  6, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 12:01 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  This is the biggest problem I had with CGFloat: while it is nice at first to have a type that adapts to the device word size it runs on, I prefer to always have an explicit accuracy guarantee than worrying about my CGFloat code changing in behaviour when it runs on a 32 bit device rather than a 64 bit one.<br></p><p>Well, CGFloat has a specific purpose, which is for calculations having to do with things that are drawn on a display.  If you need guaranteed precision in your model layer, you should be using Double and convert as needed.<br></p><p>-jcr<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 3:01 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; while it is nice at first to have a type that adapts to the device word size it runs on, I prefer to always have an explicit accuracy guarantee than worrying about my CGFloat code changing in behaviour when it runs on a 32 bit device rather than a 64 bit one.<br></p><p>It’s worth noting that the definition of CGFloat is basically a historical curiosity.  If we were starting from scratch today, CGFloat would be Double on all platforms, 32- and 64-bit.  The 64-bit transition simply allowed for the ABI-breaking change of making it 64-bit to happen.  There was never any desire or reason to have it match word size.<br></p><p>– Steve<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 12:01 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello Chris,<br>&gt; <br>&gt; When dealing with floating point values, wouldn&#39;t it be in our best interest to always be very specific about the accuracy of the floating point type variables we use regardless of the device it runs on? This is the biggest problem I had with CGFloat: while it is nice at first to have a type that adapts to the device word size it runs on, I prefer to always have an explicit accuracy guarantee than worrying about my CGFloat code changing in behaviour when it runs on a 32 bit device rather than a 64 bit one.<br></p><p>There are lots of things that are unfortunate about CGFloat.  I don’t see how they translate to Float and Double.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>January  8, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 06 Jan 2016, at 03:08, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 4:41 PM, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also think that Float and Double are not ideal type names but I also agree with many of the concerns that have been raised.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Why not simply use (the existing) Float32 and Float64 while keeping everything else equal?<br>&gt; <br>&gt; What perceived problem are you solving?<br>&gt; <br>&gt; -Chris<br></p><p>a) That ‘Double’ is not a great type name and the Float/Double combination is inconsistent naming.<br>(b) Trying to direct this discussion into a (from my point of view) more reasonable direction; i.e. away from 64-bit Float and CGFloat-reborn)<br></p><p><br>Although I wouldn’t go so far as to call Float/Double a problem, more of a nitpick.<br>I hadn’t given it any thought really before this thread so this is just me thinking out loud…<br></p><p>To me, FloatXX has the following advantages:<br>Consistent naming: Float16, Float32, Float80, Float128<br>The names contain information about the type (what is it, how large is it) that is very accessible<br>Aligns nicely with the integer types<br></p><p>And the following obvious disadvantages:<br>Float and Double are much more prevalent (<br>Float and Double are shorter<br></p><p><br>However I think the decision to go with Float/Double is very reasonable as these advantages are pretty minor and on the other end of the scale is a lot of historical precedent. Hence the ‘can we get people used to and using FloatXX while still retaining Float &amp; Double?’ ;-)<br></p><p>- Janosch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/adee65b2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; What perceived problem are you solving?<br></p><p>Here are the problems I see it solving:<br></p><p>- **Swift makes no recommendations about which floating-point type to use.** Integer types have a clear recommendation: use Int unless you have a compelling reason to use something else. Which float type should you use? Swift just kind of shrugs. This is especially ugly because Swift is so strict about mixing numeric types; by making no recommendation, Swift encourages people to create systems with inconsistent numeric types that require more conversions. And conversions are especially dangerous in floating-point types which are by their nature imprecise.<br></p><p>- **`Double` is a meaningless name unless you come from a C-style background.** This is particularly true for learners. With `Float`, you can at least explain that the type name is short for &quot;floating point&quot;, which is the way the number is represented in the computer. But `Double`? Why is `Double` a double-precision float, not a double-wide integer, or a UTF-16 string, or something? Why isn&#39;t it a generic type representing a pair of same-typed instances? Unlike, for instance, `switch`/`case`/`default`, where these are plausible names you might pick even without C&#39;s influence, `Double` is pure C jargon.<br></p><p>- **The naming of float types is unrelated to the naming of integer types.** Swift&#39;s integer types have a rationalized, ergonomic naming scheme. Swift&#39;s float types have a haphazard naming scheme. It just doesn&#39;t feel like the same language. By matching the floating-point types&#39; naming scheme to the integer types, you can bring your knowledge of the integer types over to the floating-point types.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>My thoughts are that I wish they’d been named Float32 and Float64, and that “Float” was typealiased to the “native word size” floating point type, so that all the numeric types had the same naming scheme. But with Float/Double being around for, what, 1.5(?) years, I wouldn’t blame anyone for thinking it’s not worth the hassle to switch (although I would be in favor of it if there was an actual vote or something).<br></p><p>Also, it’d be nice to have built-in arbitrary precision types for us math nerds, but I’m well aware that’s a whole other thing.<br></p><p>&gt; On Jan 4, 2016, at 12:58, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;m curious how other members of the Swift community feel about the clarity of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that the default type for integers is &quot;Int&quot;, but the default type for floating point numbers is not &quot;Float&quot;.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>May 23, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>Is there any draft/proposal related to this suggestion?<br></p><p>Best,<br></p><p>— A<br></p><p>&gt; On Jan 4, 2016, at 3:58 PM, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;m curious how other members of the Swift community feel about the clarity of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that the default type for integers is &quot;Int&quot;, but the default type for floating point numbers is not &quot;Float&quot;.<br>&gt; <br>&gt; What if the name &quot;Float&quot; were given to the intrinsic, 64-bit floating point type? (And the existing &quot;Float&quot; and &quot;Double&quot; names were removed in favor of &quot;Float32&quot; and &quot;Float64&quot;?)<br>&gt; <br>&gt; <br>&gt; Discussion:<br>&gt; <br>&gt; I understand the origins of these names in single- and double-precision IEEE floats. But this distinction feels like a holdover from C (and a 32-bit world), rather than a natural fit for Swift.<br>&gt; <br>&gt; Here are some reasons to keep Double and Float as they are (numbered for easy reference, but otherwise unordered):<br>&gt; &quot;Double&quot; and &quot;Float&quot; are more natural for developers who are &quot;familiar with C-like languages.&quot;<br>&gt; A corollary: A 64-bit &quot;Float&quot; type could be confusing to those developers.<br>&gt; Another corollary: Swift needs to interoperate with Objective C, and its &quot;float&quot; and &quot;double&quot; types.<br>&gt; Renaming these types would open the door to bike-shedding every type name and keyword in the language.<br>&gt; Changing the meaning of an existing type (&quot;Float&quot;) would be a bit PITA for existing code (although an automated migration from &quot;Float&quot; to &quot;Float32&quot; and &quot;Double&quot; to &quot;Float&quot; should be possible).<br>&gt; Renaming a fundamental type would take considerable effort.<br>&gt; Here are some reasons to rename these types:<br>&gt; The default for a &quot;float literal&quot; in Swift is a 64-bit value. It would feel natural if that that value were of type &quot;Float&quot;.<br>&gt; There are size-specific names for 32-bit (&quot;Float32&quot;) and 64-bit (&quot;Float64&quot;) floating point types. For cases where a size-specific type is needed, a size-specific name like &quot;Float32&quot; probably makes the intention of the code more clear (compared to just &quot;Float&quot;).<br>&gt; Apple&#39;s Objective C APIs generally use aliased types like &quot;CGFloat&quot; rather than raw float or double types.<br>&gt; There is precedent for &quot;Float&quot; types being 64-bit in other languages like Ruby, Python and Go (as long as the hardware supports it).<br>&gt; What kind of a name for a type is &quot;Double&quot; anyways, amirite?<br>&gt; (that last one is a joke, BTW)<br>&gt; <br>&gt; What do you think? Do you agree or disagree with any of my assessments? Are there any pros or cons that I&#39;ve missed? Is the level of effort so large that it makes this change impractical? Is it a colossal waste of human effort to even consider a change like this?<br>&gt; <br>&gt; Thanks for your time and attention,<br>&gt; Alex Johnson (@nonsensery)<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/91f5a7bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 23, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;d prefer they mirror the integer type naming &quot;conventions&quot;, that is have an explicit &quot;Float32&quot; and &quot;Float64&quot; type, with &quot;Float&quot; being a typealias for Float64.<br></p><p>Sent from my iPhone<br></p><p>&gt; On May 23, 2016, at 18:26, Adriano Ferreira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; Is there any draft/proposal related to this suggestion?<br>&gt; <br>&gt; Best,<br>&gt; <br>&gt; — A<br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 3:58 PM, Alex Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I&#39;m curious how other members of the Swift community feel about the clarity of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that the default type for integers is &quot;Int&quot;, but the default type for floating point numbers is not &quot;Float&quot;.<br>&gt;&gt; <br>&gt;&gt; What if the name &quot;Float&quot; were given to the intrinsic, 64-bit floating point type? (And the existing &quot;Float&quot; and &quot;Double&quot; names were removed in favor of &quot;Float32&quot; and &quot;Float64&quot;?)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Discussion:<br>&gt;&gt; <br>&gt;&gt; I understand the origins of these names in single- and double-precision IEEE floats. But this distinction feels like a holdover from C (and a 32-bit world), rather than a natural fit for Swift.<br>&gt;&gt; <br>&gt;&gt; Here are some reasons to keep Double and Float as they are (numbered for easy reference, but otherwise unordered):<br>&gt;&gt; &quot;Double&quot; and &quot;Float&quot; are more natural for developers who are &quot;familiar with C-like languages.&quot;<br>&gt;&gt; A corollary: A 64-bit &quot;Float&quot; type could be confusing to those developers.<br>&gt;&gt; Another corollary: Swift needs to interoperate with Objective C, and its &quot;float&quot; and &quot;double&quot; types.<br>&gt;&gt; Renaming these types would open the door to bike-shedding every type name and keyword in the language.<br>&gt;&gt; Changing the meaning of an existing type (&quot;Float&quot;) would be a bit PITA for existing code (although an automated migration from &quot;Float&quot; to &quot;Float32&quot; and &quot;Double&quot; to &quot;Float&quot; should be possible).<br>&gt;&gt; Renaming a fundamental type would take considerable effort.<br>&gt;&gt; Here are some reasons to rename these types:<br>&gt;&gt; The default for a &quot;float literal&quot; in Swift is a 64-bit value. It would feel natural if that that value were of type &quot;Float&quot;.<br>&gt;&gt; There are size-specific names for 32-bit (&quot;Float32&quot;) and 64-bit (&quot;Float64&quot;) floating point types. For cases where a size-specific type is needed, a size-specific name like &quot;Float32&quot; probably makes the intention of the code more clear (compared to just &quot;Float&quot;).<br>&gt;&gt; Apple&#39;s Objective C APIs generally use aliased types like &quot;CGFloat&quot; rather than raw float or double types.<br>&gt;&gt; There is precedent for &quot;Float&quot; types being 64-bit in other languages like Ruby, Python and Go (as long as the hardware supports it).<br>&gt;&gt; What kind of a name for a type is &quot;Double&quot; anyways, amirite?<br>&gt;&gt; (that last one is a joke, BTW)<br>&gt;&gt; <br>&gt;&gt; What do you think? Do you agree or disagree with any of my assessments? Are there any pros or cons that I&#39;ve missed? Is the level of effort so large that it makes this change impractical? Is it a colossal waste of human effort to even consider a change like this?<br>&gt;&gt; <br>&gt;&gt; Thanks for your time and attention,<br>&gt;&gt; Alex Johnson (@nonsensery)<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/0a6c3af7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 23, 2016 at 08:00:00pm</p></header><div class="content"><p>Int is the same size as Int64 on a 64-bit machine but the same size as<br>Int32 on a 32-bit machine. By contrast, modern 32-bit architectures have<br>FPUs that handle 64-bit and even 80-bit floating point types. Therefore, it<br>does not make sense for Float to be Float32 on a 32-bit machine, as would<br>be the case in one interpretation of what it means to mirror naming<br>&quot;conventions.&quot; However, if you interpret the convention to mean that Float<br>should be the largest floating point type supported by the FPU, Float<br>should actually be a typealias for Float80 even on some 32-bit machines. In<br>neither interpretation does it mean that Float should simply be a typealias<br>for what&#39;s now called Double.<br></p><p>Another issue to consider: a number like 42 is stored exactly regardless of<br>whether you&#39;re using an Int32 or an Int64. However, a number like 1.1 is<br>not stored exactly as a binary floating point type, and it&#39;s approximated<br>*differently* as a Float than as a Double. Thus, it can be essential to<br>consider what kind of floating point type you&#39;re using in scenarios even<br>when the number is small, whereas the same is not true for integer types.<br></p><p><br>On Mon, May 23, 2016 at 7:48 PM, David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;d prefer they mirror the integer type naming &quot;conventions&quot;, that is have<br>&gt; an explicit &quot;Float32&quot; and &quot;Float64&quot; type, with &quot;Float&quot; being a typealias<br>&gt; for Float64.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On May 23, 2016, at 18:26, Adriano Ferreira via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi everyone,<br>&gt;<br>&gt; Is there any draft/proposal related to this suggestion?<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; — A<br>&gt;<br>&gt; On Jan 4, 2016, at 3:58 PM, Alex Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I&#39;m curious how other members of the Swift community feel about the<br>&gt; clarity of the &quot;Double&quot; and &quot;Float&quot; type names. It seems incongruous that<br>&gt; the default type for integers is &quot;Int&quot;, but the default type for floating<br>&gt; point numbers is not &quot;Float&quot;.<br>&gt;<br>&gt; What if the name &quot;Float&quot; were given to the intrinsic, 64-bit floating<br>&gt; point type? (And the existing &quot;Float&quot; and &quot;Double&quot; names were removed in<br>&gt; favor of &quot;Float32&quot; and &quot;Float64&quot;?)<br>&gt;<br>&gt;<br>&gt; *Discussion:*<br>&gt;<br>&gt; I understand the origins of these names in single- and double-precision<br>&gt; IEEE floats. But this distinction feels like a holdover from C (and a<br>&gt; 32-bit world), rather than a natural fit for Swift.<br>&gt;<br>&gt; Here are some reasons to *keep Double and Float as they are* (numbered<br>&gt; for easy reference, but otherwise unordered):<br>&gt;<br>&gt;    1. &quot;Double&quot; and &quot;Float&quot; are more natural for developers who are<br>&gt;    &quot;familiar with C-like languages.&quot;<br>&gt;    2. A corollary: A 64-bit &quot;Float&quot; type could be confusing to those<br>&gt;    developers.<br>&gt;    3. Another corollary: Swift needs to interoperate with Objective C,<br>&gt;    and its &quot;float&quot; and &quot;double&quot; types.<br>&gt;    4. Renaming these types would open the door to bike-shedding every<br>&gt;    type name and keyword in the language.<br>&gt;    5. Changing the meaning of an existing type (&quot;Float&quot;) would be a bit<br>&gt;    PITA for existing code (although an automated migration from &quot;Float&quot; to<br>&gt;    &quot;Float32&quot; and &quot;Double&quot; to &quot;Float&quot; should be possible).<br>&gt;    6. Renaming a fundamental type would take considerable effort.<br>&gt;<br>&gt; Here are some reasons to *rename these types*:<br>&gt;<br>&gt;    1. The default for a &quot;float literal&quot; in Swift is a 64-bit value. It<br>&gt;    would feel natural if that that value were of type &quot;Float&quot;.<br>&gt;    2. There are size-specific names for 32-bit (&quot;Float32&quot;) and 64-bit<br>&gt;    (&quot;Float64&quot;) floating point types. For cases where a size-specific type is<br>&gt;    needed, a size-specific name like &quot;Float32&quot; probably makes the intention of<br>&gt;    the code more clear (compared to just &quot;Float&quot;).<br>&gt;    3. Apple&#39;s Objective C APIs generally use aliased types like &quot;CGFloat&quot;<br>&gt;    rather than raw float or double types.<br>&gt;    4. There is precedent for &quot;Float&quot; types being 64-bit in other<br>&gt;    languages like Ruby, Python and Go (as long as the hardware supports it).<br>&gt;    5. What kind of a name for a type is &quot;Double&quot; anyways, amirite?<br>&gt;<br>&gt; (that last one is a joke, BTW)<br>&gt;<br>&gt; What do you think? Do you agree or disagree with any of my assessments?<br>&gt; Are there any pros or cons that I&#39;ve missed? Is the level of effort so<br>&gt; large that it makes this change impractical? Is it a colossal waste of<br>&gt; human effort to even consider a change like this?<br>&gt;<br>&gt; Thanks for your time and attention,<br>&gt; Alex Johnson (@nonsensery)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/83ced746/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 23, 2016 at 09:00:00pm</p></header><div class="content"><p>On May 23, 2016, at 8:18 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Int is the same size as Int64 on a 64-bit machine but the same size as Int32 on a 32-bit machine. By contrast, modern 32-bit architectures have FPUs that handle 64-bit and even 80-bit floating point types. Therefore, it does not make sense for Float to be Float32 on a 32-bit machine, as would be the case in one interpretation of what it means to mirror naming &quot;conventions.&quot; However, if you interpret the convention to mean that Float should be the largest floating point type supported by the FPU, Float should actually be a typealias for Float80 even on some 32-bit machines. In neither interpretation does it mean that Float should simply be a typealias for what&#39;s now called Double.<br>IIRC, `Int` is typealiased to the target&#39;s biggest native/efficient/practical integer type, regardless of its bit-depth (although I believe some do exist, I can’t think of any CPUs in which those are different). I don’t see why it shouldn’t be the same way with floats… IMHO, `Float` should be typealiased to the biggest native/efficient/practical floating point type, which I think is pretty universally Float64. I’m under the impression that Intel’s 80-bit format is intended to be an interim representation which is automatically converted to/from 64-bit, and loading &amp; storing a full 80-bits is a non-trivial matter. I’m not even sure if the standard “math.h&quot; functions are defined for Float80 arguments. If Float80 is just as native/efficient/practical as Float64, I wouldn’t object to Float being typealiased to Float80 on such platforms.<br></p><p>&gt; Another issue to consider: a number like 42 is stored exactly regardless of whether you&#39;re using an Int32 or an Int64. However, a number like 1.1 is not stored exactly as a binary floating point type, and it&#39;s approximated *differently* as a Float than as a Double. Thus, it can be essential to consider what kind of floating point type you&#39;re using in scenarios even when the number is small, whereas the same is not true for integer types.<br>Oh I know. I’m not arguing that floating point math isn’t messy, just that since we can use “Int” for when we don’t care and “IntXX” for when we do, we should also be able to use “Float” when we don’t care and “FloatXX” when we do. If someone’s worried about the exact value of “1.1”, they should be specifying the bit-depth anyway. Otherwise, give them most precise type which can work with the language’s goals.<br></p><p>Have we (meaning the list in general, not you &amp; me in particular) had this conversation before? This feels familiar...<br></p><p>-Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 23, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mon, May 23, 2016 at 9:40 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; On May 23, 2016, at 8:18 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Int is the same size as Int64 on a 64-bit machine but the same size as<br>&gt; Int32 on a 32-bit machine. By contrast, modern 32-bit architectures have<br>&gt; FPUs that handle 64-bit and even 80-bit floating point types. Therefore, it<br>&gt; does not make sense for Float to be Float32 on a 32-bit machine, as would<br>&gt; be the case in one interpretation of what it means to mirror naming<br>&gt; &quot;conventions.&quot; However, if you interpret the convention to mean that Float<br>&gt; should be the largest floating point type supported by the FPU, Float<br>&gt; should actually be a typealias for Float80 even on some 32-bit machines. In<br>&gt; neither interpretation does it mean that Float should simply be a typealias<br>&gt; for what&#39;s now called Double.<br>&gt; IIRC, `Int` is typealiased to the target&#39;s biggest<br>&gt; native/efficient/practical integer type, regardless of its bit-depth<br>&gt; (although I believe some do exist, I can’t think of any CPUs in which those<br>&gt; are different). I don’t see why it shouldn’t be the same way with floats…<br>&gt; IMHO, `Float` should be typealiased to the biggest<br>&gt; native/efficient/practical floating point type, which I think is pretty<br>&gt; universally Float64. I’m under the impression that Intel’s 80-bit format is<br>&gt; intended to be an interim representation which is automatically converted<br>&gt; to/from 64-bit, and loading &amp; storing a full 80-bits is a non-trivial<br>&gt; matter. I’m not even sure if the standard “math.h&quot; functions are defined<br>&gt; for Float80 arguments. If Float80 is just as native/efficient/practical as<br>&gt; Float64, I wouldn’t object to Float being typealiased to Float80 on such<br>&gt; platforms.<br>&gt;<br>&gt; &gt; Another issue to consider: a number like 42 is stored exactly regardless<br>&gt; of whether you&#39;re using an Int32 or an Int64. However, a number like 1.1 is<br>&gt; not stored exactly as a binary floating point type, and it&#39;s approximated<br>&gt; *differently* as a Float than as a Double. Thus, it can be essential to<br>&gt; consider what kind of floating point type you&#39;re using in scenarios even<br>&gt; when the number is small, whereas the same is not true for integer types.<br>&gt; Oh I know. I’m not arguing that floating point math isn’t messy, just that<br>&gt; since we can use “Int” for when we don’t care and “IntXX” for when we do,<br>&gt; we should also be able to use “Float” when we don’t care and “FloatXX” when<br>&gt; we do. If someone’s worried about the exact value of “1.1”, they should be<br>&gt; specifying the bit-depth anyway. Otherwise, give them most precise type<br>&gt; which can work with the language’s goals.<br>&gt;<br></p><p>I wouldn&#39;t be opposed to renaming Float and Double to Float32 and Float64,<br>but I would care if Float were typealiased to different types on different<br>platforms. That solution is a non-starter for me because something as<br>simple as (1.1 + 1.1) would evaluate to a different result depending on the<br>machine. That&#39;s a problem. An analogous issue does not come into play with<br>Int because 1 + 1 == 2 regardless of the size of Int. Swift traps when the<br>max value that can be stored in an Int is exceeded, so it is not possible<br>to obtain two different results on two different machines.<br></p><p>Have we (meaning the list in general, not you &amp; me in particular) had this<br>&gt; conversation before? This feels familiar...<br>&gt;<br></p><p>It does, doesn&#39;t it? I&#39;ve been reading this list for too long.<br></p><p><br>&gt;<br>&gt; -Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/5a39db04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 23, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 9:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, May 23, 2016 at 9:40 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; <br>&gt; Have we (meaning the list in general, not you &amp; me in particular) had this conversation before? This feels familiar...<br>&gt; <br>&gt; It does, doesn&#39;t it? I&#39;ve been reading this list for too long.<br>I just checked, and we have! In this very thread! I didn’t realize it was started almost 6 months ago…<br></p><p>Out of curiosity, are there plans for Swift&#39;s IntegerLiteralType &amp; FloatingPointLiteralType when CPUs eventually support 128-bit ints &amp; floats? Will they still evaluate to “Int64&quot; and “Double” by default, or will they become the bigger types?<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/aefc97bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 24, 2016 at 06:00:00am</p></header><div class="content"><p>In UIKit/Cocoa, there&#39;s CGFloat that does pretty much what you&#39;re asking (and it&#39;s pain working with it in Swift, since it&#39;s Double on 64-bit computers, while Swift defaults to Float, so you need casting all the time)... And I think the default behavior of Swift should be similar.<br></p><p>I wouldn&#39;t change the type names since Double still is &quot;double precision&quot;, I&#39;d just prefer changed default behavior...<br></p><p>Charlie<br></p><p>&gt; On May 24, 2016, at 5:39 AM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 23, 2016, at 9:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, May 23, 2016 at 9:40 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Have we (meaning the list in general, not you &amp; me in particular) had this conversation before? This feels familiar...<br>&gt;&gt; <br>&gt;&gt; It does, doesn&#39;t it? I&#39;ve been reading this list for too long.<br>&gt; I just checked, and we have! In this very thread! I didn’t realize it was started almost 6 months ago…<br>&gt; <br>&gt; Out of curiosity, are there plans for Swift&#39;s IntegerLiteralType &amp; FloatingPointLiteralType when CPUs eventually support 128-bit ints &amp; floats? Will they still evaluate to “Int64&quot; and “Double” by default, or will they become the bigger types?<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/b23ce5da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Thoughts on clarity of Double and Float type names?</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>May 24, 2016 at 09:00:00am</p></header><div class="content"><p>[Charlie, this is more of a reply to the thread than to your message in particular.]<br></p><p>There is absolutely no good reason to have a “word size” floating-point type.  We happen to have one on Apple systems (CGFloat), but that should be viewed as a historical curiosity, not as guidance that it’s a reasonable thing to do.  If we were starting from scratch today, we would not have such a type.<br></p><p>1. Having explicit `Float32`, `Float64`, [`Float16`, `Float128`, … ] type names, by analogy to integer types, is great.<br></p><p>2. Making `Float` and `Double` unavailable in favor of these replacements would be a lot of churn for relatively little value, but it’s not a bad idea if you ignore the one-time pain of conversion.  `Float32` and `Float64` are discoverable enough that this would be OK, IMO.<br></p><p>3.a. Making `Float` a “word size” type is bonkers.  The last thing we want to do is create another type with the same difficulties as `CGFloat`.<br></p><p>3.b. Making `Float` be “the widest HW-supported type” is less bonkers, but still results in gratuitous cross-platform differences and very little real benefit.  We’d also need to be careful about how we defined it, since we would *not* want it to be `Float80` on x86_64 (for performance reasons).<br></p><p>3.c. Making `Float` be an alias of `Float64` would just confuse people coming from a C-family language (as commonly implemented).<br></p><p>– Steve<br></p><p>&gt; On May 24, 2016, at 12:52 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In UIKit/Cocoa, there&#39;s CGFloat that does pretty much what you&#39;re asking (and it&#39;s pain working with it in Swift, since it&#39;s Double on 64-bit computers, while Swift defaults to Float, so you need casting all the time)... And I think the default behavior of Swift should be similar.<br>&gt; <br>&gt; I wouldn&#39;t change the type names since Double still is &quot;double precision&quot;, I&#39;d just prefer changed default behavior...<br>&gt; <br>&gt; Charlie<br>&gt; <br>&gt;&gt; On May 24, 2016, at 5:39 AM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 9:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, May 23, 2016 at 9:40 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have we (meaning the list in general, not you &amp; me in particular) had this conversation before? This feels familiar...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does, doesn&#39;t it? I&#39;ve been reading this list for too long.<br>&gt;&gt; I just checked, and we have! In this very thread! I didn’t realize it was started almost 6 months ago…<br>&gt;&gt; <br>&gt;&gt; Out of curiosity, are there plans for Swift&#39;s IntegerLiteralType &amp; FloatingPointLiteralType when CPUs eventually support 128-bit ints &amp; floats? Will they still evaluate to “Int64&quot; and “Double” by default, or will they become the bigger types?<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/c2c17110/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
