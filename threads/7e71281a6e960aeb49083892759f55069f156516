<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>on Wed Jan 13 2016, Thorsten Seitz via swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org&gt; wrote:<br></p><p>&gt;&gt; Am 13.01.2016 um 00:06 schrieb Dave Abrahams<br>&gt;&gt; &lt;dabrahams at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 10:46 AM, Thorsten Seitz<br>&gt;&gt;&gt; &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Really great to hear that you are planning for Swift to be able to<br>&gt;&gt;&gt; do these kinds of things!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tried to see how far I could get (working from memory of a<br>&gt;&gt;&gt; Haskell library; Boost.Units seems quite similar at first glance),<br>&gt;&gt;&gt; but failed of course because of the missing parameterized recursive<br>&gt;&gt;&gt; typealiases:<br>&gt;&gt; <br>&gt;&gt; Sadly, the lack of the ability to define a pretty shorthand for<br>&gt;&gt; quantities is not what stands in the way, fundamentally.<br>&gt;<br>&gt; I&#39;m afraid I don&#39;t get your meaning here. Would you mind to explain a bit more?<br>&gt; Thanks!<br></p><p>Typealiases are just about creating new names for existing types.  The<br>inability to even form the correct type when an an acceleration is<br>multiplied by a time is the more fundamental issue.  You need to add<br>corresponding powers of the fundamental dimensions.<br></p><p>HTH,<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 20.01.2016 um 18:16 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; on Wed Jan 13 2016, Thorsten Seitz via swift-evolution &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Am 13.01.2016 um 00:06 schrieb Dave Abrahams<br>&gt;&gt;&gt; &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:46 AM, Thorsten Seitz<br>&gt;&gt;&gt;&gt; &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Really great to hear that you are planning for Swift to be able to<br>&gt;&gt;&gt;&gt; do these kinds of things!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I tried to see how far I could get (working from memory of a<br>&gt;&gt;&gt;&gt; Haskell library; Boost.Units seems quite similar at first glance),<br>&gt;&gt;&gt;&gt; but failed of course because of the missing parameterized recursive<br>&gt;&gt;&gt;&gt; typealiases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sadly, the lack of the ability to define a pretty shorthand for<br>&gt;&gt;&gt; quantities is not what stands in the way, fundamentally.<br>&gt;&gt; <br>&gt;&gt; I&#39;m afraid I don&#39;t get your meaning here. Would you mind to explain a bit more?<br>&gt;&gt; Thanks!<br>&gt; <br>&gt; Typealiases are just about creating new names for existing types.  The<br>&gt; inability to even form the correct type when an an acceleration is<br>&gt; multiplied by a time is the more fundamental issue.  You need to add<br>&gt; corresponding powers of the fundamental dimensions.<br></p><p>Ah, thanks for explaining what you meant!<br>Actually that’s what the generic recursive typealiases Add and Sub I defined in my example are for: they effectively provide addition and subtraction for Peano numbers implemented in the type system (that’s the way it works in Haskell).<br></p><p>typealias Add&lt;Zero, P: Peano&gt; = P<br>typealias Add&lt;P: Peano, Zero&gt; = P<br>typealias Add&lt;Succ&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Add&lt;Succ&lt;Succ&lt;P1&gt;&gt;,P2&gt;<br>typealias Add&lt;Succ&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Add&lt;P1,P2&gt;<br>typealias Add&lt;Pred&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Add&lt;P1,P2&gt;<br>typealias Add&lt;Pred&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Add&lt;P1,Pred&lt;Pred&lt;P2&gt;&gt;&gt;<br></p><p>public func *<br>    &lt;L1,T1,M1,L2,T2,M2,L,T,M where<br>    L == Add&lt;L1,L2&gt;, T == Add&lt;T1,T2&gt;, M == Add&lt;M1,M2&gt;&gt;<br>    (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>{<br>    return Quantity&lt;L,T,M&gt;(lhs.value * rhs.value)<br>}<br></p><p>Having integers as generic parameters with the possibility of adding them is much nicer, though, as the Peano numbers are no longer needed and everything is much easier to understand. The adaption of my example to that feature was in my other mail, e.g.<br></p><p>public func *<br>    &lt;L1,T1,M1,L2,T2,M2,L,T,M where L == L1+L2, T == T1+T2, M == M1+M2&gt;<br>    (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>{<br>    return Quantity&lt;L,T,M&gt;(lhs.value * rhs.value)<br>}<br></p><p><br>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/518a8ceb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 20, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Jan 20 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br></p><p>&gt;&gt; Am 20.01.2016 um 18:16 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jan 13 2016, Thorsten Seitz via swift-evolution<br>&gt;&gt; &lt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg-AT-public.gmane.org&gt; wrote:<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 13.01.2016 um 00:06 schrieb Dave Abrahams<br>&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 7, 2016, at 10:46 AM, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt; &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Really great to hear that you are planning for Swift to be able to<br>&gt;&gt;&gt;&gt;&gt; do these kinds of things!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I tried to see how far I could get (working from memory of a<br>&gt;&gt;&gt;&gt;&gt; Haskell library; Boost.Units seems quite similar at first glance),<br>&gt;&gt;&gt;&gt;&gt; but failed of course because of the missing parameterized recursive<br>&gt;&gt;&gt;&gt;&gt; typealiases:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sadly, the lack of the ability to define a pretty shorthand for<br>&gt;&gt;&gt;&gt; quantities is not what stands in the way, fundamentally.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m afraid I don&#39;t get your meaning here. Would you mind to explain a bit more?<br>&gt;&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; Typealiases are just about creating new names for existing types.  The<br>&gt;&gt; inability to even form the correct type when an an acceleration is<br>&gt;&gt; multiplied by a time is the more fundamental issue.  You need to add<br>&gt;&gt; corresponding powers of the fundamental dimensions.<br>&gt;<br>&gt; Ah, thanks for explaining what you meant!<br>&gt; Actually that’s what the generic recursive typealiases Add and Sub I<br>&gt; defined in my example are for: they effectively provide addition and<br>&gt; subtraction for Peano numbers implemented in the type system (that’s<br>&gt; the way it works in Haskell).<br></p><p>Yeah, I knew that&#39;s what you were doing.  If you extend typealiases<br>enough, I suppose, they become like class templates with partial<br>specialization, but supporting them throughout the language would<br>require fundamental changes to our type system that have nothing<br>intrinsically to do with typealiases.  That&#39;s all I&#39;m saying.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 20, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Yeah, I knew that&#39;s what you were doing.  If you extend typealiases<br>&gt; enough, I suppose, they become like class templates with partial<br>&gt; specialization, but supporting them throughout the language would<br>&gt; require fundamental changes to our type system that have nothing<br>&gt; intrinsically to do with typealiases.<br></p><p>Speaking of the type system:<br>Has there been any discussion about inheritance for structs?<br></p><p>It isn&#39;t hard to guess why it is forbidden (pass-by-value would make sub-structs incompatible with their parents as soon as you add member variables), but imho there are many examples where you are forced to use reference-semantics just because you want inheritance for things that are good candidates for struct (I&#39;m thinking of data objects like Person/Customer/Employee, Color/ColorWithAlpha…)<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 21, 2016 at 12:00:00pm</p></header><div class="content"><p>on Wed Jan 20 2016, Tino Heth &lt;2th-AT-gmx.de&gt; wrote:<br></p><p>&gt;&gt; Yeah, I knew that&#39;s what you were doing.  If you extend typealiases<br>&gt;&gt; enough, I suppose, they become like class templates with partial<br>&gt;&gt; specialization, but supporting them throughout the language would<br>&gt;&gt; require fundamental changes to our type system that have nothing<br>&gt;&gt; intrinsically to do with typealiases.<br>&gt;<br>&gt; Speaking of the type system:<br>&gt; Has there been any discussion about inheritance for structs?<br></p><p>Yes, struct subtyping has come up several times.  There are several<br>things I&#39;d like to do with it in the standard library.<br></p><p>Cheers,<br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 1:22 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, struct subtyping has come up several times.  There are several<br>&gt; things I&#39;d like to do with it in the standard library.<br>&gt; <br>What do people mean when they say struct subclassing? Code reuse, polymorphism, or something else?<br></p><p>-DW<br></p><p>Sent with my Thumbs<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 21, 2016 at 02:00:00pm</p></header><div class="content"><p>Going off the top of my head, I&#39;d imagine it&#39;s a product type that inherits memory layout, code reuse, and conformances but introduces a distinct type for type safety checks. You could specialize the derived type with behavior and conformance that do not exist for the parent.<br></p><p>(It may also gain additional fields, I suppose, as well as super-type behavior calls, isKindOf checks, etc)<br></p><p>-- Erica<br></p><p>&gt; On Jan 21, 2016, at 1:50 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 21, 2016, at 1:22 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, struct subtyping has come up several times.  There are several<br>&gt;&gt; things I&#39;d like to do with it in the standard library.<br>&gt;&gt; <br>&gt; What do people mean when they say struct subclassing? Code reuse, polymorphism, or something else?<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; Sent with my Thumbs<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>on Thu Jan 21 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br></p><p>&gt;&gt; On Jan 21, 2016, at 1:22 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, struct subtyping has come up several times.  There are several<br>&gt;&gt; things I&#39;d like to do with it in the standard library.<br>&gt;&gt; <br>&gt; What do people mean when they say struct subclassing? Code reuse,<br>&gt; polymorphism, or something else?<br></p><p>By struct subtyping I mean:<br></p><p>A way to define a partial ordering of relationships between value types,<br>with implicit conversions from subtype to supertype, and overload<br>resolution based on a corresponding partial ordering of function/method<br>overloads (much as it works for generics today).<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 21, 2016 at 04:00:00pm</p></header><div class="content"><p>So if I understand you correctly, coercion (not conversion/representable form) relationships between types, giving you the ability to have one type&#39;s instance implicitly coerced into an instance of another type for the purposes of matching the signature needed by a particular method/property/initializer<br></p><p>So not an Employee-is-a-Person relationship, but more of an Int8-is-fully-representable-as-a-Int relationship. In this world, [Int] cannot now hold Int8s, but attempting to append an Int8 to such an array will cause an Int to automatically be created. <br></p><p>Also, not implying code sharing, or declaration in at least the initial definition of the subtype - I could define a Maybe enum that was True,False, or Possibly cases, and a Bool argument could be an acceptable substitute.<br></p><p>One question - could you define then all T to be a subtype/be coerced into Optional&lt;T&gt; using language syntax? All Array&lt;T&gt; to Array&lt;supertype T&gt;<br></p><p>-DW<br></p><p>Sent with my Thumbs<br></p><p>&gt; On Jan 21, 2016, at 2:41 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jan 21 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jan 21, 2016, at 1:22 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, struct subtyping has come up several times.  There are several<br>&gt;&gt;&gt; things I&#39;d like to do with it in the standard library.<br>&gt;&gt; What do people mean when they say struct subclassing? Code reuse,<br>&gt;&gt; polymorphism, or something else?<br>&gt; <br>&gt; By struct subtyping I mean:<br>&gt; <br>&gt; A way to define a partial ordering of relationships between value types,<br>&gt; with implicit conversions from subtype to supertype, and overload<br>&gt; resolution based on a corresponding partial ordering of function/method<br>&gt; overloads (much as it works for generics today).<br>&gt; <br>&gt; -Dave<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
