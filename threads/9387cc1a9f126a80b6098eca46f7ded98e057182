<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>November  1, 2016 at 04:00:00pm</p></header><div class="content"><p>I encountered a localization problem today. At first I translated a string<br>like this.<br></p><p>let count = 10<br>&gt; let says = NSLocalizedString(&quot;It runs \(count) times&quot;, comment: &quot;run<br>&gt; times&quot;)<br></p><p><br>I couldn&#39;t get the translation taking effect.<br></p><p>So I open the setting &quot;Localization Debugging&quot; in scheme and get this error:<br></p><p>[strings] ERROR, It runs 10 times not found in table Localizable of bundle<br>&gt; CFBundle 0x100c01c40 ... (executable, loaded)<br>&gt; IT RUNS 10 TIMES<br></p><p><br>I began to realize that` \(count)` was not dealed well in localization. The<br>compiler calculated the full string then looking for the translation,<br>instead of looking for the translation first.<br></p><p>I managed to replace my code with<br></p><p>let newSays = String.localizedStringWithFormat(NSLocalizedString(&quot;It runs<br>&gt; %d times&quot;, comment: &quot;new run times&quot;), count)<br></p><p><br>However, I still thing it would be better if we could use \(foo) directly,<br>as it is more Swift style. Any idea why this can&#39;t happen?<br></p><p>Zhaoxin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161101/93877182/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>November  1, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; I managed to replace my code with <br>&gt; <br>&gt; let newSays = String.localizedStringWithFormat(NSLocalizedString(&quot;It runs %d times&quot;, comment: &quot;new run times&quot;), count)<br>&gt; <br>&gt; However, I still thing it would be better if we could use \(foo) directly, as it is more Swift style. Any idea why this can&#39;t happen?<br></p><p>I have some code that does that (Swift 2 version: &lt;https://gist.github.com/brentdax/79fa038c0af0cafb52dd&gt;), but it relies on the ExpressibleByStringInterpolation protocol, which is currently deprecated because it&#39;s due for a redesign.<br></p><p>Ultimately, localization is a Foundation-level concern. I&#39;d love to see a future Foundation do something clever with NSLocalizedString, but it seems like their hands have been full with higher-priority stuff like the value-type equivalents.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>November  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 1:53 AM, Zhao Xin via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I began to realize that` \(count)` was not dealed well in localization. The compiler calculated the full string then looking for the translation, instead of looking for the translation first.<br></p><p>NSLocalizedString was designed (in the 1990s) to be used with methods like String(format:…) that take printf-style “%”-substituted format strings.<br>Swift’s string interpolation is obviously a different mechanism entirely.<br></p><p>I suspect that Swift interpolation won’t work well for localized strings because the string and the code are so tightly connected. Localization very often needs to change the order of parameters, for instance. It’s also unclear where things like number formatting happen in Swift interpolation; when localizing a string, the conversion needs to be done using the same locale as the string lookup, which might not happen if the string-to-number conversion is separate and uses the default locale.<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>November  2, 2016 at 10:00:00am</p></header><div class="content"><p>I think in Swift.<br></p><p>let count = 10<br>&gt; let says = NSLocalizedString(&quot;<br>&gt; ​blabla<br>&gt; \(count)<br>&gt; ​blabla<br>&gt; &quot;, comment: &quot;<br>&gt; ​blabla<br>&gt; &quot;)<br></p><p><br>​can be roughly interpreted as<br></p><p>let says = String.localizedStringWithFormat(NSLocalizedString(&quot;<br>&gt; ​blabla<br>&gt; %<br>&gt; ​@<br>&gt; ​blabla<br>&gt; &quot;, comment: &quot;<br>&gt; ​blabla<br>&gt; &quot;), count)<br></p><p><br>​So if Swift does not want to do much effort on this ​, it could just find<br>every localized string that is with  &#39;\(foo)&#39; in `NSLocalizedString` and<br>converted to `String.localizedStringWithFormat(NSLocalizedString...`<br>internally.<br></p><p>Zhaoxin<br></p><p><br>On Wed, Nov 2, 2016 at 12:08 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Nov 1, 2016, at 1:53 AM, Zhao Xin via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I began to realize that` \(count)` was not dealed well in localization.<br>&gt; The compiler calculated the full string then looking for the translation,<br>&gt; instead of looking for the translation first.<br>&gt;<br>&gt; NSLocalizedString was designed (in the 1990s) to be used with methods like<br>&gt; String(format:…) that take printf-style “%”-substituted format strings.<br>&gt; Swift’s string interpolation is obviously a different mechanism entirely.<br>&gt;<br>&gt; I suspect that Swift interpolation won’t work well for localized strings<br>&gt; because the string and the code are so tightly connected. Localization very<br>&gt; often needs to change the order of parameters, for instance. It’s also<br>&gt; unclear where things like number formatting happen in Swift interpolation;<br>&gt; when localizing a string, the conversion needs to be done using the same<br>&gt; locale as the string lookup, which might not happen if the string-to-number<br>&gt; conversion is separate and uses the default locale.<br>&gt;<br>&gt; —Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161102/ee3dec3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>November  2, 2016 at 10:00:00am</p></header><div class="content"><p>The second should be<br></p><p>let says = String.localizedStringWithFormat(NSLocalizedString(&quot;<br>&gt; ​blabla<br>&gt; %<br>&gt; ​@<br>&gt; ​blabla<br>&gt; &quot;, comment: &quot;<br>&gt; ​blabla<br>&gt; &quot;),<br>&gt; ​String(​<br>&gt; count<br>&gt; ​)​<br>&gt; )<br></p><p><br>​Zhaoxin​<br></p><p>On Wed, Nov 2, 2016 at 10:50 AM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br></p><p>&gt; I think in Swift.<br>&gt;<br>&gt; let count = 10<br>&gt;&gt; let says = NSLocalizedString(&quot;<br>&gt;&gt; ​blabla<br>&gt;&gt; \(count)<br>&gt;&gt; ​blabla<br>&gt;&gt; &quot;, comment: &quot;<br>&gt;&gt; ​blabla<br>&gt;&gt; &quot;)<br>&gt;<br>&gt;<br>&gt; ​can be roughly interpreted as<br>&gt;<br>&gt; let says = String.localizedStringWithFormat(NSLocalizedString(&quot;<br>&gt;&gt; ​blabla<br>&gt;&gt; %<br>&gt;&gt; ​@<br>&gt;&gt; ​blabla<br>&gt;&gt; &quot;, comment: &quot;<br>&gt;&gt; ​blabla<br>&gt;&gt; &quot;), count)<br>&gt;<br>&gt;<br>&gt; ​So if Swift does not want to do much effort on this ​, it could just find<br>&gt; every localized string that is with  &#39;\(foo)&#39; in `NSLocalizedString` and<br>&gt; converted to `String.localizedStringWithFormat(NSLocalizedString...`<br>&gt; internally.<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt;<br>&gt; On Wed, Nov 2, 2016 at 12:08 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Nov 1, 2016, at 1:53 AM, Zhao Xin via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I began to realize that` \(count)` was not dealed well in localization.<br>&gt;&gt; The compiler calculated the full string then looking for the translation,<br>&gt;&gt; instead of looking for the translation first.<br>&gt;&gt;<br>&gt;&gt; NSLocalizedString was designed (in the 1990s) to be used with methods<br>&gt;&gt; like String(format:…) that take printf-style “%”-substituted format strings.<br>&gt;&gt; Swift’s string interpolation is obviously a different mechanism entirely.<br>&gt;&gt;<br>&gt;&gt; I suspect that Swift interpolation won’t work well for localized strings<br>&gt;&gt; because the string and the code are so tightly connected. Localization very<br>&gt;&gt; often needs to change the order of parameters, for instance. It’s also<br>&gt;&gt; unclear where things like number formatting happen in Swift interpolation;<br>&gt;&gt; when localizing a string, the conversion needs to be done using the same<br>&gt;&gt; locale as the string lookup, which might not happen if the string-to-number<br>&gt;&gt; conversion is separate and uses the default locale.<br>&gt;&gt;<br>&gt;&gt; —Jens<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161102/b4cae6a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>November  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 7:52 PM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; The second should be<br>&gt; <br>&gt; let says = String.localizedStringWithFormat(NSLocalizedString(&quot;​blabla%​@​blabla&quot;, comment: &quot;​blabla&quot;), ​String(​count​)​)<br></p><p>That’s not quite right, because the conversion of `count` to a string won’t be localized. Some languages use non-ASCII digits, use characters other than “.” for decimal points, etc. Depending on the exact type of `count`, it would need to be something like:<br></p><p>	String.localizedStringWithFormat(NSLocalizedString(&quot;​blabla%​d​blabla&quot;, comment: &quot;​blabla&quot;), ​count​)​<br></p><p>Hardcoding this specific kind of transformation into the parser seems like a bad idea, since NSLocalizedString isn’t part of the language. Why don’t you just use localizedStringWithFormat instead of string interpolation in your code?<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161101/e9a13cef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>November  2, 2016 at 01:00:00pm</p></header><div class="content"><p>I has known that, and it is the developer&#39;s choice,  which means, the<br>developer has already known that. There are many circumstances that there<br>are no needs to translate at all. For example, if I want show the user that<br>I have to ask him to give me permission of a folder, the `url.path` has no<br>need to translate.<br></p><p>And of course,<br>` String.localizedStringWithFormat(NSLocalizedString(&quot;​blabla%​@​blabla&quot;,<br>comment: &quot;​blabla&quot;), ​` has already allows to do that. I just think it<br>should be in a more Swift way by using `\(foo)`.<br></p><p>Zhaoxin<br></p><p>On Wed, Nov 2, 2016 at 11:45 AM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Nov 1, 2016, at 7:52 PM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt;<br>&gt; The second should be<br>&gt;<br>&gt; let says = String.localizedStringWithFormat(NSLocalizedString(&quot;<br>&gt;&gt; ​blabla<br>&gt;&gt; %<br>&gt;&gt; ​@<br>&gt;&gt; ​blabla<br>&gt;&gt; &quot;, comment: &quot;<br>&gt;&gt; ​blabla<br>&gt;&gt; &quot;),<br>&gt;&gt; ​String(​<br>&gt;&gt; count<br>&gt;&gt; ​)​<br>&gt;&gt; )<br>&gt;<br>&gt;<br>&gt; That’s not quite right, because the conversion of `count` to a string<br>&gt; won’t be localized. Some languages use non-ASCII digits, use characters<br>&gt; other than “.” for decimal points, etc. Depending on the exact type of<br>&gt; `count`, it would need to be something like:<br>&gt;<br>&gt; String.localizedStringWithFormat(NSLocalizedString(&quot;​blabla%​d​blabla&quot;,<br>&gt; comment: &quot;​blabla&quot;), ​count​)​<br>&gt;<br>&gt; Hardcoding this specific kind of transformation into the parser seems like<br>&gt; a bad idea, since NSLocalizedString isn’t part of the language. Why don’t<br>&gt; you just use localizedStringWithFormat instead of string interpolation in<br>&gt; your code?<br>&gt;<br>&gt; —Jens<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161102/28186363/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>November  1, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 10:40 PM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; For example, if I want show the user that I have to ask him to give me permission of a folder, the `url.path` has no need to translate.<br></p><p>We’re getting off-topic, but paths do need to be translated, at least on Mac systems. The names of many standard folders like “Applications” and “Documents” are hardwired to English in the filesystem but are localized in the UI. Some application names get localized too (there’s a table in the app’s Info.plist that can substitute localized names.)<br></p><p>Anyway, string interpolation is convenient, but I wouldn’t say it should be the only way to format strings in Swift; it’s a lot less flexible than the C-style “%” substitutions. For comparison, even though C++’s iostreams use “&lt;&lt;“ to format strings by concatenation, I still end up using “%” based formatting a lot, depending on the use case.<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>November  2, 2016 at 01:00:00pm</p></header><div class="content"><p>I am not talking to eliminate &quot;%&quot; style function. I am talking to add more<br>compatibility to `NSLocalizedString` with `\(foo)` style. As there is no<br>rule forbidding that, it should work. If someone doesn&#39;t need the flexible<br>parts, why he has to use the complicated way?<br></p><p>Zhaoxin<br></p><p>On Wed, Nov 2, 2016 at 1:49 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Nov 1, 2016, at 10:40 PM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; For example, if I want show the user that I have to ask him to give me<br>&gt; permission of a folder, the `url.path` has no need to translate.<br>&gt;<br>&gt; We’re getting off-topic, but paths do need to be translated, at least on<br>&gt; Mac systems. The names of many standard folders like “Applications” and<br>&gt; “Documents” are hardwired to English in the filesystem but are localized in<br>&gt; the UI. Some application names get localized too (there’s a table in the<br>&gt; app’s Info.plist that can substitute localized names.)<br>&gt;<br>&gt; Anyway, string interpolation is convenient, but I wouldn’t say it should<br>&gt; be the only way to format strings in Swift; it’s a lot less flexible than<br>&gt; the C-style “%” substitutions. For comparison, even though C++’s iostreams<br>&gt; use “&lt;&lt;“ to format strings by concatenation, I still end up using “%” based<br>&gt; formatting a lot, depending on the use case.<br>&gt;<br>&gt; —Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161102/d5dea0d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>November  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 10:56 PM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; I am not talking to eliminate &quot;%&quot; style function. I am talking to add more compatibility to `NSLocalizedString` with `\(foo)` style.<br></p><p>I don’t think the ExpressibleByStringInterpolation protocol provides enough information to make this work. It hands the implementation a list of values to concatenate, some of which are strings, but as far as I can tell there’s no way to tell which of those strings are the pieces of the string literal and which of them are the results of expressions. So NSLocalizedString would not be able to reassemble the string template that you gave it, to look up in the localization table.<br></p><p>If I’m wrong about this, show me a workable implementation of it. :)<br></p><p>Also, ExpressibleByStringInterpolation is marked as being deprecated and will be “replaced or redesigned in Swift 4.0.” Maybe to solve this limitation?<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>November  2, 2016 at 02:00:00pm</p></header><div class="content"><p>I have already give a workable implementation above.<br></p><p>let count = 10<br>&gt; let says = NSLocalizedString(&quot;<br>&gt; ​blabla<br>&gt; \(count)<br>&gt; ​blabla<br>&gt; &quot;, comment: &quot;<br>&gt; ​blabla<br>&gt; &quot;)<br></p><p><br>​to<br></p><p>let says =<br>&gt; String.localizedStringWithFormat(NSLocalizedString(&quot;​blabla%​@​blabla&quot;,<br>&gt; comment: &quot;​blabla&quot;), ​String(​count​)​<br></p><p><br>When encounter​ `NSLocalizedString`, Swift looks into its key, if it<br>​s key​<br>contains \(foo), just replace it as<br>`String.localizedStringWithFormat(NSLocalizedString(&quot;​blabla%​@​blabla&quot;,<br>comment: &quot;​blabla&quot;), ​String(​foo​)​`. If not, keep it unchanged.<br></p><p>That is enough.<br></p><p>In current situation, Swift still first calculates the value of string<br>first, then `NSLocalizedString` work. So it just needs to add a little work<br>to check if there is  any `\(foo)` in the string, instead of calculating<br>the value of string.<br></p><p>Zhaoxin<br></p><p>On Wed, Nov 2, 2016 at 2:09 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Nov 1, 2016, at 10:56 PM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I am not talking to eliminate &quot;%&quot; style function. I am talking to add<br>&gt; more compatibility to `NSLocalizedString` with `\(foo)` style.<br>&gt;<br>&gt; I don’t think the ExpressibleByStringInterpolation protocol provides<br>&gt; enough information to make this work. It hands the implementation a list of<br>&gt; values to concatenate, some of which are strings, but as far as I can tell<br>&gt; there’s no way to tell which of those strings are the pieces of the string<br>&gt; literal and which of them are the results of expressions. So<br>&gt; NSLocalizedString would not be able to reassemble the string template that<br>&gt; you gave it, to look up in the localization table.<br>&gt;<br>&gt; If I’m wrong about this, show me a workable implementation of it. :)<br>&gt;<br>&gt; Also, ExpressibleByStringInterpolation is marked as being deprecated and<br>&gt; will be “replaced or redesigned in Swift 4.0.” Maybe to solve this<br>&gt; limitation?<br>&gt;<br>&gt; —Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161102/fdda1ce6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc8eae356a7d359691154094ae6d56a7?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Marco S Hyman</string> &lt;marc at snafu.org&gt;<p>November  2, 2016 at 11:00:00am</p></header><div class="content"><p>On Nov 1, 2016, at 11:42 PM, Zhao Xin via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I have already give a workable implementation above.<br></p><p>Your implementation assume \(x) is always %@x.  What does it do when given -- to use an example from the swift book:<br></p><p>  &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)”<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>November  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 11:23 AM, Marco S Hyman via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; On Nov 1, 2016, at 11:42 PM, Zhao Xin via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have already give a workable implementation above.<br>&gt; <br>&gt; Your implementation assume \(x) is always %@x.<br></p><p>It’s also not an implementation. It’s just an English-language sketch for how you might do it. “Implementation” means actual code. As programmers we all  know that there are tons of details that don’t become apparent until you try to build a real program, and both Marco and I have pointed some out.<br></p><p>—Jens<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Localization in Swift.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>November  2, 2016 at 01:00:00pm</p></header><div class="content"><p>(Resending something that was accidentally off-list.)<br></p><p>&gt; On Nov 1, 2016, at 11:09 PM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t think the ExpressibleByStringInterpolation protocol provides enough information to make this work. It hands the implementation a list of values to concatenate, some of which are strings, but as far as I can tell there’s no way to tell which of those strings are the pieces of the string literal and which of them are the results of expressions.<br></p><p>There&#39;s actually a simple trick. The even-indexed elements are literal strings; the odd-indexed ones are interpolated values. This is true even if you have two interpolations adjacent to each other—there will be an empty string between them. I&#39;ve used this for a few different things, including a LocalizableString type in Swift 2 and a SQLStatement type in Swift 3.<br></p><p>	https://gist.github.com/brentdax/79fa038c0af0cafb52dd<br>	https://github.com/brentdax/swift-sql/blob/master/Sources/SQLStatement.swift<br></p><p>&gt; If I’m wrong about this, show me a workable implementation of it. :)<br></p><p>See above. :^)<br></p><p>&gt; Also, ExpressibleByStringInterpolation is marked as being deprecated and will be “replaced or redesigned in Swift 4.0.” Maybe to solve this limitation?<br></p><p>I believe that making it easier to treat the literal and interpolated segments differently is one of the goals.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
