<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Delegate Method Conventions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 26, 2016 at 04:00:00pm</p></header><div class="content"><p>on Tue Jan 26 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jan 24, 2016, at 5:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Jan 23 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 2:33 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sat Jan 23 2016, plx<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 6:12 PM, Ross O&#39;Brien via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How would we apply this to delegate patterns?<br>&gt;&gt;&gt;&gt;&gt;&gt; For example, would we keep<br>&gt;&gt;&gt;&gt;&gt;&gt; tableview(tableView:cellForRowAtIndexPath:), or would we switch to<br>&gt;&gt;&gt;&gt;&gt;&gt; delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt;&gt;&gt;&gt;&gt;&gt; Or perhaps better, for clarity over which protocol is being<br>&gt;&gt;&gt;&gt;&gt;&gt; conformed to / which property of the delegator is calling the<br>&gt;&gt;&gt;&gt;&gt;&gt; function:<br>&gt;&gt;&gt;&gt;&gt;&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt;&gt;&gt;&gt;&gt;&gt; delegate(tableView:didSelectRowAtIndexPath:)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FWIW, I am personally favorable to a more radical-renaming for<br>&gt;&gt;&gt;&gt;&gt; delegate methods, roughly the below:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func numberOfSections(inTableView tableView: UITableView) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; // &lt;- against guidelines, but symmetric<br>&gt;&gt;&gt;&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; func cellForRow(inTableView tableView: UITableView, atIndexPath<br>&gt;&gt;&gt;&gt;&gt; indexPath: NSIndexPath) -&gt; UITableView<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The interesting thing about delegate methods is that, for the most part,<br>&gt;&gt;&gt;&gt; use-sites don&#39;t appear in user code.  So *if* you&#39;re going to come up with<br>&gt;&gt;&gt;&gt; special conventions just for delegate methods you&#39;d want to serve the<br>&gt;&gt;&gt;&gt; declaration site.  I don&#39;t know what these things *ought* to look like,<br>&gt;&gt;&gt;&gt; but the declarations above look to me like they&#39;ve got an awful lot of<br>&gt;&gt;&gt;&gt; redundancy that doesn&#39;t help readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Most of what follows should really be in the discussion about the<br>&gt;&gt;&gt; Objective-C import, not here, but I’ll respond here with the parts<br>&gt;&gt;&gt; relevant to the guidelines.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems self-evident that imported delegate methods violate the<br>&gt;&gt;&gt; spirit of Swift’s API guidelines; in particular, the rule that<br>&gt;&gt;&gt; “Methods can share a base name when they share the same basic meaning<br>&gt;&gt;&gt; but operate on different types, or are in different domains” seems<br>&gt;&gt;&gt; relevant. <br>&gt;&gt; <br>&gt;&gt; That&#39;s quite true.<br>&gt;&gt; <br>&gt;&gt;&gt; It’s thus been a bit surprising to me that delegate-style methods<br>&gt;&gt;&gt; haven’t *already* gotten some special treatment; <br>&gt;&gt; <br>&gt;&gt; Well, it&#39;s a fact of life that major efforts like this one (probably<br>&gt;&gt; property behaviors are the same bucket) are going to have to land<br>&gt;&gt; without solving all the problems they are related to.  I believe<br>&gt;&gt; strongly that we should do *something* about delegate methods.  I also<br>&gt;&gt; believe they&#39;re a separable problem and we should be able to evaluate<br>&gt;&gt; the current direction without working out all the details of how we&#39;re<br>&gt;&gt; going to handle them.  That&#39;s why I changed the subject line: I&#39;d like<br>&gt;&gt; to agree that special treatment for delegate methods in the importer is<br>&gt;&gt; out-of-scope in this review.<br>&gt;&gt; <br>&gt;&gt;&gt; what I had isn’t great, but put it and some variants up against the<br>&gt;&gt;&gt; original, like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func numberOfRows(in tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt; func numberOfRowsIn(tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int<br>&gt;&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; I assume you mean the 3rd one to be &quot;the original?”<br>&gt;<br>&gt; Yes, here: tableView(_:numberOfRowsInSection:)<br>&gt; &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/#//apple_ref/occ/intfm/UITableViewDataSource/tableView:numberOfRowsInSection:&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; …(note the longest is only ~10 characters longer than the shortest!). <br>&gt;&gt; <br>&gt;&gt; Sorry, I don&#39;t see why that is relevant.  Care to explain?<br>&gt;<br>&gt; I did not make the intention clear; apologies. I was intending to<br>&gt; illustrate that although all of the examples contain redundancies,<br>&gt; none of them are egregiously worse than the others (including the<br>&gt; original); the worst case is only moderately more-redundant than the<br>&gt; best case.<br></p><p>I understand that, but if you&#39;ll forgive me for being blunt, so what?<br></p><p>&gt;&gt;&gt; Although there might be an as-yet unseen option that’s superior to all<br>&gt;&gt;&gt; of the above, just out of those 4 it’s hard to see how you can justify<br>&gt;&gt;&gt; option #3 using the API guidelines; <br>&gt;&gt;&gt; it also seems hard to envision a self-consistent expansion of the<br>&gt;&gt;&gt; guidelines that’d lead to favoring #3.<br>&gt;&gt; <br>&gt;&gt; You can&#39;t.<br>&gt;&gt; <br>&gt;&gt;&gt; As already noted this is really more-relevant to the “objective-c<br>&gt;&gt;&gt; import revision”, but you can frame my points as obliquely asking “to<br>&gt;&gt;&gt; what extent should the Swift API guidelines actually matter when doing<br>&gt;&gt;&gt; the big Objective-C import?”<br>&gt;&gt; <br>&gt;&gt; We&#39;re willing to accept that some imported APIs will not follow the<br>&gt;&gt; guidelines.<br>&gt;&gt; <br>&gt;&gt;&gt; I also question your sense of real-world use of delegate protocols;<br>&gt;&gt;&gt; just taking inventory of the most recent project I completed, it looks<br>&gt;&gt;&gt; like it had 5 custom delegate-style protocols. Of these, 4 had exactly<br>&gt;&gt;&gt; one implementation each, and 1 had exactly 2 implementations; <br>&gt;&gt; <br>&gt;&gt; And how many use-sites were there?<br>&gt;<br>&gt; 5, just counting “classes using said delegates”; 14 if you go by<br>&gt; individual method use.<br></p><p>My point is that with most methods, the use sites clearly overwhelm the<br>declaration sites.  I don&#39;t believe that to be the case with delegates.<br>But this is really a minor detail.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; I don’t think this is that untypical. If you accept it as not too<br>&gt;&gt;&gt; atypical,<br>&gt;&gt; <br>&gt;&gt; I do.<br>&gt;&gt; <br>&gt;&gt;&gt; it suggests a more uniform balance between defining a delegate<br>&gt;&gt;&gt; protocol, using said protocol, and implementing said protocol.<br>&gt;&gt; <br>&gt;&gt; Not necessarily.  How many times did this project implement delegate<br>&gt;&gt; protocols that were defined elsewhere?  <br>&gt;<br>&gt; Looks like 12, for implementations; “a lot”, going by by the method<br>&gt; count.<br>&gt;<br>&gt; In any case I don’t dispute the general point, just perhaps the exit.<br></p><p>?<br></p><p>&gt;&gt; In any case, for what it&#39;s worth, I personally think the direction<br>&gt;&gt; you&#39;re going with those delegate APIs is great, and it has the benefit<br>&gt;&gt; of bringing them into conformance with other guidelines.  My only point<br>&gt;&gt; in saying that the declaration site is more important with delegate<br>&gt;&gt; methods than with others is that there&#39;s more type information at the<br>&gt;&gt; declaration site of a method than at its use site, so there&#39;s definitely<br>&gt;&gt; no reason to make them more verbose than others.  Making them simply<br>&gt;&gt; follow the existing guidelines exactly is a simple solution that IMO<br>&gt;&gt; leads to good code, and one I would support.<br>&gt;&gt; <br>&gt;&gt; However, what Cocoa guys like Tony Parker say about the eventual<br>&gt;&gt; direction of delegate APIs should probably carry a lot more weight than<br>&gt;&gt; what I say.<br>&gt;&gt; <br>&gt;&gt;&gt; To wind this digression down now, the API guidelines’ attitude towards<br>&gt;&gt;&gt; redundancy seems somewhat troubling; no one wants needless redundancy,<br>&gt;&gt;&gt; but natural languages tend towards redundancy (cf<br>&gt;&gt;&gt; agreement/pleonasm/etc) and it’s not at all self-evident that less<br>&gt;&gt;&gt; redundancy always implies increased readability (which you may or may<br>&gt;&gt;&gt; not be intending to imply; I can’t tell)…especially when it’s easy to<br>&gt;&gt;&gt; get fooled by increased speed-of-reading.<br>&gt;&gt; <br>&gt;&gt; This seems like a pretty vague concern.  Let&#39;s see concrete examples of<br>&gt;&gt; problems you think the guidelines&#39; attitude toward redundancy will<br>&gt;&gt; cause.  FWIW, &quot;omit needless words&quot; isn&#39;t something we just came<br>&gt;&gt; up with ourselves: it&#39;s a time-honored principle of clear English<br>&gt;&gt; writing (google it).<br>&gt;<br>&gt; Sure, sure, but if you’ll forgive a cheap shot I’d point out Strunk<br>&gt; would’ve tut-tutted here and suggested, perhaps, “we didn’t invent<br>&gt; ‘omit needless words’”. The tricky part of that rule is that what’s<br>&gt; needless is highly contextual, and to be *understood* when writing in<br>&gt; a highly-condensed style usually requires a large amount of shared<br>&gt; context.<br></p><p>Oh, that *was* cheap; and I&#39;m not sure I can forgive it! :-)<br></p><p>&gt; Which need-for-context is at the root of my admittedly-vague concern;<br>&gt; I’ve done my best to come up with a concrete-ish example, but it’s a<br>&gt; bit contrived and not as strong as I’d like, either. It’s more of an<br>&gt; &quot;ecosystem concern”, too.<br>&gt;<br>&gt; Here are *six* functions that could conceivably be named `min` under the guidelines:<br>&gt;<br>&gt; func min() -&gt; Generator.Element? // obviously only where `Generator.Element` is `Comparable`<br>&gt; func min(isLessThan comparator: (Generator.Element,Generator.Element)<br>&gt; -&gt; Bool) -&gt; Generator.Element?<br>&gt; func min&lt;K:Comparable&gt;(extractor: (Generator.Element) -&gt; K) -&gt; K?<br>&gt; func min&lt;K:Comparable&gt;(extractor: (Generator.Element) -&gt; K?) -&gt; K?<br>&gt; func min&lt;T&gt;(extractor: (Generator.Element) -&gt; T, isLessThan comparator: (T,T) -&gt; Bool) -&gt; T?<br>&gt; func min&lt;T&gt;(extractor: (Generator.Element) -&gt; T?, isLessThan comparator: (T,T) -&gt; Bool) -&gt; T?<br>&gt;<br>&gt; …and perhaps they *all* should be named `min` (and we simply let<br>&gt; context and type information sort it all out for us).<br>&gt;<br>&gt; But if the names should be different, what’re good choices?<br>&gt;<br>&gt; My vague concern is that having “maximally-terse” names for the<br>&gt; standard library functions makes it trickier to choose<br>&gt; &quot;non-misleading” names for such closely-related variants.<br></p><p>We are not going for maximal terseness in the standard library.  When we<br>pick a name like &quot;min&quot; it&#39;s because of precedent and expectations.<br>&gt;<br>&gt; EG: if you go with `minValue` for the variants, to a casual reader<br>&gt; there’s room for confusion vis-a-vis `min` (I suspect many would<br>&gt; initially guess that `minValue` does what `minElement` does today, but<br>&gt; would guess the behavior correctly if given a choice between<br>&gt; `minElement` and `minValue`).<br>&gt;<br>&gt; Unfortunately for my case, I think `minFor` is a perfectly-reasonable<br>&gt; choice here, which undermines my concrete example (I warned you the<br>&gt; case wasn’t going to be very convincing).<br></p><p>It is just as you said :-)<br></p><p>&gt; But that’s the kind of vague concern I have here: that a<br>&gt; “maximally-terse” naming convention can be harder to extend in a way<br>&gt; that’s both self-consistent and not-potentially-misleading.<br>&gt;<br>&gt; But I don’t have a great suggestion for an additional guideline, and<br>&gt; there may be nothing serious to worry about here, either.<br></p><p>I think we&#39;ve made it very clear that we&#39;re not going for maximal<br>terseness:<br></p><p>   Clarity is more important than brevity. Although Swift code can be<br>   compact, it is a non-goal to enable the smallest possible code with<br>   the fewest characters. Brevity in Swift code, where it occurs, is a<br>   side-effect of the strong type system and features that naturally<br>   reduce boilerplate.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Delegate Method Conventions</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 30, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 6:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jan 26 2016, plx &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jan 24, 2016, at 5:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat Jan 23 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 23, 2016, at 2:33 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sat Jan 23 2016, plx<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 6:12 PM, Ross O&#39;Brien via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How would we apply this to delegate patterns?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, would we keep<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; tableview(tableView:cellForRowAtIndexPath:), or would we switch to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or perhaps better, for clarity over which protocol is being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformed to / which property of the delegator is calling the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; delegate(tableView:didSelectRowAtIndexPath:)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I am personally favorable to a more radical-renaming for<br>&gt;&gt;&gt;&gt;&gt;&gt; delegate methods, roughly the below:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func numberOfSections(inTableView tableView: UITableView) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt;&gt; // &lt;- against guidelines, but symmetric<br>&gt;&gt;&gt;&gt;&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt;&gt; func cellForRow(inTableView tableView: UITableView, atIndexPath<br>&gt;&gt;&gt;&gt;&gt;&gt; indexPath: NSIndexPath) -&gt; UITableView<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The interesting thing about delegate methods is that, for the most part,<br>&gt;&gt;&gt;&gt;&gt; use-sites don&#39;t appear in user code.  So *if* you&#39;re going to come up with<br>&gt;&gt;&gt;&gt;&gt; special conventions just for delegate methods you&#39;d want to serve the<br>&gt;&gt;&gt;&gt;&gt; declaration site.  I don&#39;t know what these things *ought* to look like,<br>&gt;&gt;&gt;&gt;&gt; but the declarations above look to me like they&#39;ve got an awful lot of<br>&gt;&gt;&gt;&gt;&gt; redundancy that doesn&#39;t help readability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Most of what follows should really be in the discussion about the<br>&gt;&gt;&gt;&gt; Objective-C import, not here, but I’ll respond here with the parts<br>&gt;&gt;&gt;&gt; relevant to the guidelines.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems self-evident that imported delegate methods violate the<br>&gt;&gt;&gt;&gt; spirit of Swift’s API guidelines; in particular, the rule that<br>&gt;&gt;&gt;&gt; “Methods can share a base name when they share the same basic meaning<br>&gt;&gt;&gt;&gt; but operate on different types, or are in different domains” seems<br>&gt;&gt;&gt;&gt; relevant. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s quite true.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s thus been a bit surprising to me that delegate-style methods<br>&gt;&gt;&gt;&gt; haven’t *already* gotten some special treatment; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, it&#39;s a fact of life that major efforts like this one (probably<br>&gt;&gt;&gt; property behaviors are the same bucket) are going to have to land<br>&gt;&gt;&gt; without solving all the problems they are related to.  I believe<br>&gt;&gt;&gt; strongly that we should do *something* about delegate methods.  I also<br>&gt;&gt;&gt; believe they&#39;re a separable problem and we should be able to evaluate<br>&gt;&gt;&gt; the current direction without working out all the details of how we&#39;re<br>&gt;&gt;&gt; going to handle them.  That&#39;s why I changed the subject line: I&#39;d like<br>&gt;&gt;&gt; to agree that special treatment for delegate methods in the importer is<br>&gt;&gt;&gt; out-of-scope in this review.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; what I had isn’t great, but put it and some variants up against the<br>&gt;&gt;&gt;&gt; original, like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func numberOfRows(in tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt; func numberOfRowsIn(tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume you mean the 3rd one to be &quot;the original?”<br>&gt;&gt; <br>&gt;&gt; Yes, here: tableView(_:numberOfRowsInSection:)<br>&gt;&gt; &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/#//apple_ref/occ/intfm/UITableViewDataSource/tableView:numberOfRowsInSection: &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/#//apple_ref/occ/intfm/UITableViewDataSource/tableView:numberOfRowsInSection:&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …(note the longest is only ~10 characters longer than the shortest!). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I don&#39;t see why that is relevant.  Care to explain?<br>&gt;&gt; <br>&gt;&gt; I did not make the intention clear; apologies. I was intending to<br>&gt;&gt; illustrate that although all of the examples contain redundancies,<br>&gt;&gt; none of them are egregiously worse than the others (including the<br>&gt;&gt; original); the worst case is only moderately more-redundant than the<br>&gt;&gt; best case.<br>&gt; <br>&gt; I understand that, but if you&#39;ll forgive me for being blunt, so what?<br></p><p>At the time I thought you meant simply that:<br></p><p>- that the suggestion was annoyingly verbose and redundant<br></p><p>…which seemed an odd criticism, given that “the original” was similarly verbose-and-redundant; however, I think you may have been thinking:<br></p><p>- that because said suggestion was not appreciably-less-redundant than &quot;the original&quot;, it’s hard to justify such a transformation (more work for marginal benefit)<br></p><p>…in which case we have may have simply been talking past each other.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; Although there might be an as-yet unseen option that’s superior to all<br>&gt;&gt;&gt;&gt; of the above, just out of those 4 it’s hard to see how you can justify<br>&gt;&gt;&gt;&gt; option #3 using the API guidelines; <br>&gt;&gt;&gt;&gt; it also seems hard to envision a self-consistent expansion of the<br>&gt;&gt;&gt;&gt; guidelines that’d lead to favoring #3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can&#39;t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As already noted this is really more-relevant to the “objective-c<br>&gt;&gt;&gt;&gt; import revision”, but you can frame my points as obliquely asking “to<br>&gt;&gt;&gt;&gt; what extent should the Swift API guidelines actually matter when doing<br>&gt;&gt;&gt;&gt; the big Objective-C import?”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;re willing to accept that some imported APIs will not follow the<br>&gt;&gt;&gt; guidelines.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also question your sense of real-world use of delegate protocols;<br>&gt;&gt;&gt;&gt; just taking inventory of the most recent project I completed, it looks<br>&gt;&gt;&gt;&gt; like it had 5 custom delegate-style protocols. Of these, 4 had exactly<br>&gt;&gt;&gt;&gt; one implementation each, and 1 had exactly 2 implementations; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And how many use-sites were there?<br>&gt;&gt; <br>&gt;&gt; 5, just counting “classes using said delegates”; 14 if you go by<br>&gt;&gt; individual method use.<br>&gt; <br>&gt; My point is that with most methods, the use sites clearly overwhelm the<br>&gt; declaration sites.  I don&#39;t believe that to be the case with delegates.<br>&gt; But this is really a minor detail.<br></p><p>For the “SDK” protocols from Apple this is of course true; on the other hand, most one-off, in-app protocols are declared once, used once, and implemented at-most a couple times (1 being the mode, I’d imagine).<br></p><p>TBH I wouldn’t have noticed the oddity in delegate-style APIs if I hand’t had to create a few one-off ones and noticed how *odd* it is.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think this is that untypical. If you accept it as not too<br>&gt;&gt;&gt;&gt; atypical,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; it suggests a more uniform balance between defining a delegate<br>&gt;&gt;&gt;&gt; protocol, using said protocol, and implementing said protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not necessarily.  How many times did this project implement delegate<br>&gt;&gt;&gt; protocols that were defined elsewhere?  <br>&gt;&gt; <br>&gt;&gt; Looks like 12, for implementations; “a lot”, going by by the method<br>&gt;&gt; count.<br>&gt;&gt; <br>&gt;&gt; In any case I don’t dispute the general point, just perhaps the exit.<br>&gt; <br>&gt; ?<br></p><p>I meant to type `extent`; apologies.<br></p><p>&gt; <br>&gt;&gt;&gt; In any case, for what it&#39;s worth, I personally think the direction<br>&gt;&gt;&gt; you&#39;re going with those delegate APIs is great, and it has the benefit<br>&gt;&gt;&gt; of bringing them into conformance with other guidelines.  My only point<br>&gt;&gt;&gt; in saying that the declaration site is more important with delegate<br>&gt;&gt;&gt; methods than with others is that there&#39;s more type information at the<br>&gt;&gt;&gt; declaration site of a method than at its use site, so there&#39;s definitely<br>&gt;&gt;&gt; no reason to make them more verbose than others.  Making them simply<br>&gt;&gt;&gt; follow the existing guidelines exactly is a simple solution that IMO<br>&gt;&gt;&gt; leads to good code, and one I would support.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, what Cocoa guys like Tony Parker say about the eventual<br>&gt;&gt;&gt; direction of delegate APIs should probably carry a lot more weight than<br>&gt;&gt;&gt; what I say.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To wind this digression down now, the API guidelines’ attitude towards<br>&gt;&gt;&gt;&gt; redundancy seems somewhat troubling; no one wants needless redundancy,<br>&gt;&gt;&gt;&gt; but natural languages tend towards redundancy (cf<br>&gt;&gt;&gt;&gt; agreement/pleonasm/etc) and it’s not at all self-evident that less<br>&gt;&gt;&gt;&gt; redundancy always implies increased readability (which you may or may<br>&gt;&gt;&gt;&gt; not be intending to imply; I can’t tell)…especially when it’s easy to<br>&gt;&gt;&gt;&gt; get fooled by increased speed-of-reading.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems like a pretty vague concern.  Let&#39;s see concrete examples of<br>&gt;&gt;&gt; problems you think the guidelines&#39; attitude toward redundancy will<br>&gt;&gt;&gt; cause.  FWIW, &quot;omit needless words&quot; isn&#39;t something we just came<br>&gt;&gt;&gt; up with ourselves: it&#39;s a time-honored principle of clear English<br>&gt;&gt;&gt; writing (google it).<br>&gt;&gt; <br>&gt;&gt; Sure, sure, but if you’ll forgive a cheap shot I’d point out Strunk<br>&gt;&gt; would’ve tut-tutted here and suggested, perhaps, “we didn’t invent<br>&gt;&gt; ‘omit needless words’”. The tricky part of that rule is that what’s<br>&gt;&gt; needless is highly contextual, and to be *understood* when writing in<br>&gt;&gt; a highly-condensed style usually requires a large amount of shared<br>&gt;&gt; context.<br>&gt; <br>&gt; Oh, that *was* cheap; and I&#39;m not sure I can forgive it! :-)<br></p><p>I only felt justified taking it b/c “came up with ourselves” is at least a borderline pleonasm.<br></p><p>&gt; <br>&gt;&gt; Which need-for-context is at the root of my admittedly-vague concern;<br>&gt;&gt; I’ve done my best to come up with a concrete-ish example, but it’s a<br>&gt;&gt; bit contrived and not as strong as I’d like, either. It’s more of an<br>&gt;&gt; &quot;ecosystem concern”, too.<br>&gt;&gt; <br>&gt;&gt; Here are *six* functions that could conceivably be named `min` under the guidelines:<br>&gt;&gt; <br>&gt;&gt; func min() -&gt; Generator.Element? // obviously only where `Generator.Element` is `Comparable`<br>&gt;&gt; func min(isLessThan comparator: (Generator.Element,Generator.Element)<br>&gt;&gt; -&gt; Bool) -&gt; Generator.Element?<br>&gt;&gt; func min&lt;K:Comparable&gt;(extractor: (Generator.Element) -&gt; K) -&gt; K?<br>&gt;&gt; func min&lt;K:Comparable&gt;(extractor: (Generator.Element) -&gt; K?) -&gt; K?<br>&gt;&gt; func min&lt;T&gt;(extractor: (Generator.Element) -&gt; T, isLessThan comparator: (T,T) -&gt; Bool) -&gt; T?<br>&gt;&gt; func min&lt;T&gt;(extractor: (Generator.Element) -&gt; T?, isLessThan comparator: (T,T) -&gt; Bool) -&gt; T?<br>&gt;&gt; <br>&gt;&gt; …and perhaps they *all* should be named `min` (and we simply let<br>&gt;&gt; context and type information sort it all out for us).<br>&gt;&gt; <br>&gt;&gt; But if the names should be different, what’re good choices?<br>&gt;&gt; <br>&gt;&gt; My vague concern is that having “maximally-terse” names for the<br>&gt;&gt; standard library functions makes it trickier to choose<br>&gt;&gt; &quot;non-misleading” names for such closely-related variants.<br>&gt; <br>&gt; We are not going for maximal terseness in the standard library.  When we<br>&gt; pick a name like &quot;min&quot; it&#39;s because of precedent and expectations.<br>&gt;&gt; <br>&gt;&gt; EG: if you go with `minValue` for the variants, to a casual reader<br>&gt;&gt; there’s room for confusion vis-a-vis `min` (I suspect many would<br>&gt;&gt; initially guess that `minValue` does what `minElement` does today, but<br>&gt;&gt; would guess the behavior correctly if given a choice between<br>&gt;&gt; `minElement` and `minValue`).<br>&gt;&gt; <br>&gt;&gt; Unfortunately for my case, I think `minFor` is a perfectly-reasonable<br>&gt;&gt; choice here, which undermines my concrete example (I warned you the<br>&gt;&gt; case wasn’t going to be very convincing).<br>&gt; <br>&gt; It is just as you said :-)<br>&gt; <br>&gt;&gt; But that’s the kind of vague concern I have here: that a<br>&gt;&gt; “maximally-terse” naming convention can be harder to extend in a way<br>&gt;&gt; that’s both self-consistent and not-potentially-misleading.<br>&gt;&gt; <br>&gt;&gt; But I don’t have a great suggestion for an additional guideline, and<br>&gt;&gt; there may be nothing serious to worry about here, either.<br>&gt; <br>&gt; I think we&#39;ve made it very clear that we&#39;re not going for maximal<br>&gt; terseness:<br>&gt; <br>&gt;   Clarity is more important than brevity. Although Swift code can be<br>&gt;   compact, it is a non-goal to enable the smallest possible code with<br>&gt;   the fewest characters. Brevity in Swift code, where it occurs, is a<br>&gt;   side-effect of the strong type system and features that naturally<br>&gt;   reduce boilerplate.<br>&gt; <br>&gt; — <br></p><p>I understand you don’t think you’re going for maximal terseness, but guidelines aimed at redundancy-reduction with a lack of concern for what the linguists call “markedness” (which is amongst other things context-dependent, and thus not easy to judge in isolation).<br></p><p>Specifically, what counts as “weak type information” will always be somewhat context-dependent. Here’s another example, this time drawn from the Objective-C import proposal: `documentFor(url: NSURL)`.<br></p><p>`documentFor(url: NSURL)` is certainly in conformance to the current guidelines.<br></p><p>However, in an application context, I’d usually want application code to *largely* avoid calling such “low-level” methods directly, in favor of wrappers defined in terms of application-level concepts, e.g. some possible examples:<br></p><p>documentFor(windowState: WindowState) // e.g. state-restoration<br>documentFor(bookmark: BookmarkData) // e.g. user-favorites menu<br>documentFor(user: User) // e.g. a 1:1 user-document thing (consider a test-administration use case)<br>documentFor(template: TemplateDescriptor) // e.g. create-new-document from a template of some kind<br>documentFor(image: Image) // e.g. create-a-new-document containing `image` and ready for further use<br></p><p>…and so on and so forth. Note that all of the above are also in conformance with the guidelines—if `documentForURL` is wrong, then `documentForWindowState` is even more wrong!<br></p><p>So, given that I would prefer application-level code use the &quot;application-level variants&quot;, I’m a bit stuck if I want the “application-level” variants to be easy to distinguish (visually) from the “low-level” variant: <br></p><p>- `documentFor(url: NSURL)` is out of my control, so I can’t unilaterally-demote it to `documentForURL(url: NSURL)` on my end (I can write a wrapper, but can’t hide the base method at this time...)<br>- lengthening the “application-level” names goes against the spirit of the guidelines<br>- changing the “application-level” names often feels unidiomatic (`restoredDocumentFor(windowState: WindowState)` is ok, but `bookmarkedDocumentFor(bookmark: BookmarkData)` feels awful-and-unnecessary)<br></p><p>…which wan’t a concern in Objective-C, b/c the increased verbosity kept everything uniform and easily-verifiable:<br></p><p>- `documentForURL:`<br>- `documentForWindowState:`<br>- `documentForBookmark:`<br>- `documentForUser:`<br>- `documentForTemplate:`<br>- `documentForImage:`<br></p><p>…(with the extensions likely having `prefix_` in front to boot!).<br></p><p>I do think this is going to be a bit awkward in all settings where the guidelines steer us towards having a bunch of identically-named extension methods calling through to “standard-library” functionality; in such settings what used to be adequate type-information (within the standard library context) starts to look like weak type information (in its context-of-use).<br></p><p>I don’t think the right answer is for, e.g., the Objective-C import to uniformly start using `documentForURL`-type names; that feels like overkill.<br></p><p>I do think a loosened attitude about when-and-how to include a first-argument label will open up a lot of room to address such concerns; I suspect that the other discussions around when to use identical base names and when to use first argument labels is originating from at-least broadly-similar concerns.<br></p><p>Perhaps it can be addressed by taking the below:<br></p><p>&gt; Methods can share a base name when they share the same basic meaning but operate on different types, or are in different domains.<br></p><p>…and tweaking it to include a note that such methods *may* label their first argument when necessary to clarify either:<br></p><p>- the method variant (when the methods do the same thing to the point the same base name should be used, but nevertheless are meant for different-enough intents to benefit from an explicit distinction)<br>- the interpretation of said argument (hopefully this is rather rare)<br></p><p>…but at this point I think I’ve said my bit, brought up the delegate-naming issue, and appreciate the time and consideration. The delegate convention seems to need a reboot, anyways, and should seemingly at least wait for the first review of the objective-c import discussion to conclude.<br></p><p>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/99b9022e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Delegate Method Conventions</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February  3, 2016 at 09:00:00am</p></header><div class="content"><p>After taking the time to look at a few more delegate-style protocols it’s a lot less obvious that the existing delegate-style protocols would, in general, support such a transform (or at least an automated one).<br></p><p>The `UIPageViewDataSource` API is a good short example:<br></p><p>// original:<br>func pageViewController(pageViewController: UIPageViewController, viewControllerAfterViewController viewController: UIViewController) -&gt; UIViewController?<br>func pageViewController(pageViewController: UIPageViewController, viewControllerBeforeViewController viewController: UIViewController) -&gt; UIViewController?<br></p><p>// best-plausible automated output (IMHO):<br>func viewControllerAfter(pageViewController: UIPageViewController, viewController: UIViewController) -&gt; UIViewController? <br>func viewControllerBefore(pageViewController: UIPageViewController, viewController: UIViewController) -&gt; UIViewController? <br></p><p>// manual-option A:<br>func viewController(in pageViewController: UIPageViewController, after viewController: UIViewController) -&gt; UIViewController? <br>func viewController(in pageViewController: UIPageViewController, before viewController: UIViewController) -&gt; UIViewController? <br></p><p>// manual-option B:<br>func nextViewController(in pageViewController: UIPageViewController, after viewController: UIViewController) -&gt; UIViewController? <br>func previousViewController(in pageViewController: UIPageViewController, before viewController: UIViewController) -&gt; UIViewController? <br></p><p>…wherein in case it’s not clear, the problem is that the general rule of “take the first non-delegate argument, split off the explanatory part, and use it as a method” leads to a more-confusingly-named function; this can obviously be corrected manually, but I’m skeptical the automated approach can be extended to cover such scenarios without requiring a lot of manual intervention/annotation.<br></p><p>Additionally, there are related cases like `NSKeyedUnarchiverDelegate`, which have the similar issue of being arguably worse-off for the transformation under most plausible edits in that style; consider e.g.:<br></p><p>// original<br>func unarchiver(unarchiver: NSKeyedUnarchiver, didDecodeObject object: AnyObject?) -&gt; AnyObject? // lets you replace `object` with something else<br>func unarchiver(unarchiver: NSKeyedUnarchiver, willReplaceObject object: AnyObject, withObject newObject: AnyObject) <br>func unarchiver(unarchiver: NSKeyedUnarchiver, cannotDecodeObjectOfClassName name: String, originalClasses classNames: [String]) -&gt; AnyClass? // lets you suggest an alternative class to try<br></p><p>// plausible mechanical transforms<br>func didDecode(unarchiver: NSKeyedUnarchiver, object: AnyObject?) -&gt; AnyObject? <br>func didDecodeObject(unarchiver: NSKeyedUnarchiver, object: AnyObject?) -&gt; AnyObject? <br>func didDecode(unarchiver: NSKeyedUnarchiver, decodedObject: AnyObject?) -&gt; AnyObject? <br></p><p>func willReplace(unarchiver: NSKeyedUnarchiver, object: AnyObject?, withObject newObject: AnyObject)<br>func willReplaceObject(unarchiver: NSKeyedUnarchiver, object: AnyObject?, withObject newObject: AnyObject)<br></p><p>func cannotDecodeObject(unarchiver: NSKeyedUnarchiver, className name: String, originalClasses classNames: [String]) -&gt; AnyClass?<br>func cannotDecodeObjectOfClass(unarchiver: NSKeyedUnarchiver, name: String, originalClasses classNames: [String]) -&gt; AnyClass?<br>func cannotDecodeObjectOfClass(unarchiver: NSKeyedUnarchiver, className: String, originalClasses classNames: [String]) -&gt; AnyClass?<br></p><p>…none of which are really any clearer, to my eyes (and still rather far from the semantics, as the `didDecode` is really asking if you want a replacement object, and the `cannotDecode…` is really asking for another class to try given that unarchiving using the archive-specified class has failed).<br></p><p>Finally, there are also APIs like `NSURLSessionDataDelegate` which have *2* “delegate-style” parameters: `URLSession(_:dataTask:didReceiveResponse:completionHandler:` (and possibly others), so an automated transform has to somehow handle such cases.<br></p><p>Given all of these, perhaps the best that can be done at this time is to try and get the general guidelines such that for *new* delegate APIs it’ll be possible to give them Swift names that are guideline-conformant, but can still be exposed to Objective-C (where necessary) in an idiomatic way (e.g., has the arguments in the right ordering to be a delegate/datasource/etc. call in Objective-C).<br></p><p>But at least at this point I’m rather dubious there’s a worthwhile transformation out there that can be uniformly applied to the “SDK delegate/datasource protocols” and lead to an overall improvement.<br></p><p>&gt; On Jan 30, 2016, at 12:06 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 26, 2016, at 6:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Jan 26 2016, plx &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 24, 2016, at 5:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sat Jan 23 2016, plx &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 23, 2016, at 2:33 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Sat Jan 23 2016, plx<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 22, 2016, at 6:12 PM, Ross O&#39;Brien via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How would we apply this to delegate patterns?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, would we keep<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; tableview(tableView:cellForRowAtIndexPath:), or would we switch to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; delegate(tableView:cellForRowAtIndexPath:) ?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or perhaps better, for clarity over which protocol is being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformed to / which property of the delegator is calling the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dataSource(tableView:cellForRowAtIndexPath:),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; delegate(tableView:didSelectRowAtIndexPath:)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I am personally favorable to a more radical-renaming for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; delegate methods, roughly the below:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func numberOfSections(inTableView tableView: UITableView) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // &lt;- against guidelines, but symmetric<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func cellForRow(inTableView tableView: UITableView, atIndexPath<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; indexPath: NSIndexPath) -&gt; UITableView<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The interesting thing about delegate methods is that, for the most part,<br>&gt;&gt;&gt;&gt;&gt;&gt; use-sites don&#39;t appear in user code.  So *if* you&#39;re going to come up with<br>&gt;&gt;&gt;&gt;&gt;&gt; special conventions just for delegate methods you&#39;d want to serve the<br>&gt;&gt;&gt;&gt;&gt;&gt; declaration site.  I don&#39;t know what these things *ought* to look like,<br>&gt;&gt;&gt;&gt;&gt;&gt; but the declarations above look to me like they&#39;ve got an awful lot of<br>&gt;&gt;&gt;&gt;&gt;&gt; redundancy that doesn&#39;t help readability.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Most of what follows should really be in the discussion about the<br>&gt;&gt;&gt;&gt;&gt; Objective-C import, not here, but I’ll respond here with the parts<br>&gt;&gt;&gt;&gt;&gt; relevant to the guidelines.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems self-evident that imported delegate methods violate the<br>&gt;&gt;&gt;&gt;&gt; spirit of Swift’s API guidelines; in particular, the rule that<br>&gt;&gt;&gt;&gt;&gt; “Methods can share a base name when they share the same basic meaning<br>&gt;&gt;&gt;&gt;&gt; but operate on different types, or are in different domains” seems<br>&gt;&gt;&gt;&gt;&gt; relevant. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s quite true.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s thus been a bit surprising to me that delegate-style methods<br>&gt;&gt;&gt;&gt;&gt; haven’t *already* gotten some special treatment; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, it&#39;s a fact of life that major efforts like this one (probably<br>&gt;&gt;&gt;&gt; property behaviors are the same bucket) are going to have to land<br>&gt;&gt;&gt;&gt; without solving all the problems they are related to.  I believe<br>&gt;&gt;&gt;&gt; strongly that we should do *something* about delegate methods.  I also<br>&gt;&gt;&gt;&gt; believe they&#39;re a separable problem and we should be able to evaluate<br>&gt;&gt;&gt;&gt; the current direction without working out all the details of how we&#39;re<br>&gt;&gt;&gt;&gt; going to handle them.  That&#39;s why I changed the subject line: I&#39;d like<br>&gt;&gt;&gt;&gt; to agree that special treatment for delegate methods in the importer is<br>&gt;&gt;&gt;&gt; out-of-scope in this review.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; what I had isn’t great, but put it and some variants up against the<br>&gt;&gt;&gt;&gt;&gt; original, like so:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func numberOfRows(in tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; func numberOfRowsIn(tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; func numberOfRows(inTableView tableView: UITableView, forSection section: Int) -&gt; Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I assume you mean the 3rd one to be &quot;the original?”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, here: tableView(_:numberOfRowsInSection:)<br>&gt;&gt;&gt; &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/#//apple_ref/occ/intfm/UITableViewDataSource/tableView:numberOfRowsInSection: &lt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITableViewDataSource_Protocol/#//apple_ref/occ/intfm/UITableViewDataSource/tableView:numberOfRowsInSection:&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; …(note the longest is only ~10 characters longer than the shortest!). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I don&#39;t see why that is relevant.  Care to explain?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I did not make the intention clear; apologies. I was intending to<br>&gt;&gt;&gt; illustrate that although all of the examples contain redundancies,<br>&gt;&gt;&gt; none of them are egregiously worse than the others (including the<br>&gt;&gt;&gt; original); the worst case is only moderately more-redundant than the<br>&gt;&gt;&gt; best case.<br>&gt;&gt; <br>&gt;&gt; I understand that, but if you&#39;ll forgive me for being blunt, so what?<br>&gt; <br>&gt; At the time I thought you meant simply that:<br>&gt; <br>&gt; - that the suggestion was annoyingly verbose and redundant<br>&gt; <br>&gt; …which seemed an odd criticism, given that “the original” was similarly verbose-and-redundant; however, I think you may have been thinking:<br>&gt; <br>&gt; - that because said suggestion was not appreciably-less-redundant than &quot;the original&quot;, it’s hard to justify such a transformation (more work for marginal benefit)<br>&gt; <br>&gt; …in which case we have may have simply been talking past each other.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Although there might be an as-yet unseen option that’s superior to all<br>&gt;&gt;&gt;&gt;&gt; of the above, just out of those 4 it’s hard to see how you can justify<br>&gt;&gt;&gt;&gt;&gt; option #3 using the API guidelines; <br>&gt;&gt;&gt;&gt;&gt; it also seems hard to envision a self-consistent expansion of the<br>&gt;&gt;&gt;&gt;&gt; guidelines that’d lead to favoring #3.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can&#39;t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As already noted this is really more-relevant to the “objective-c<br>&gt;&gt;&gt;&gt;&gt; import revision”, but you can frame my points as obliquely asking “to<br>&gt;&gt;&gt;&gt;&gt; what extent should the Swift API guidelines actually matter when doing<br>&gt;&gt;&gt;&gt;&gt; the big Objective-C import?”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;re willing to accept that some imported APIs will not follow the<br>&gt;&gt;&gt;&gt; guidelines.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I also question your sense of real-world use of delegate protocols;<br>&gt;&gt;&gt;&gt;&gt; just taking inventory of the most recent project I completed, it looks<br>&gt;&gt;&gt;&gt;&gt; like it had 5 custom delegate-style protocols. Of these, 4 had exactly<br>&gt;&gt;&gt;&gt;&gt; one implementation each, and 1 had exactly 2 implementations; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And how many use-sites were there?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5, just counting “classes using said delegates”; 14 if you go by<br>&gt;&gt;&gt; individual method use.<br>&gt;&gt; <br>&gt;&gt; My point is that with most methods, the use sites clearly overwhelm the<br>&gt;&gt; declaration sites.  I don&#39;t believe that to be the case with delegates.<br>&gt;&gt; But this is really a minor detail.<br>&gt; <br>&gt; For the “SDK” protocols from Apple this is of course true; on the other hand, most one-off, in-app protocols are declared once, used once, and implemented at-most a couple times (1 being the mode, I’d imagine).<br>&gt; <br>&gt; TBH I wouldn’t have noticed the oddity in delegate-style APIs if I hand’t had to create a few one-off ones and noticed how *odd* it is.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think this is that untypical. If you accept it as not too<br>&gt;&gt;&gt;&gt;&gt; atypical,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; it suggests a more uniform balance between defining a delegate<br>&gt;&gt;&gt;&gt;&gt; protocol, using said protocol, and implementing said protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not necessarily.  How many times did this project implement delegate<br>&gt;&gt;&gt;&gt; protocols that were defined elsewhere?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looks like 12, for implementations; “a lot”, going by by the method<br>&gt;&gt;&gt; count.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In any case I don’t dispute the general point, just perhaps the exit.<br>&gt;&gt; <br>&gt;&gt; ?<br>&gt; <br>&gt; I meant to type `extent`; apologies.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; In any case, for what it&#39;s worth, I personally think the direction<br>&gt;&gt;&gt;&gt; you&#39;re going with those delegate APIs is great, and it has the benefit<br>&gt;&gt;&gt;&gt; of bringing them into conformance with other guidelines.  My only point<br>&gt;&gt;&gt;&gt; in saying that the declaration site is more important with delegate<br>&gt;&gt;&gt;&gt; methods than with others is that there&#39;s more type information at the<br>&gt;&gt;&gt;&gt; declaration site of a method than at its use site, so there&#39;s definitely<br>&gt;&gt;&gt;&gt; no reason to make them more verbose than others.  Making them simply<br>&gt;&gt;&gt;&gt; follow the existing guidelines exactly is a simple solution that IMO<br>&gt;&gt;&gt;&gt; leads to good code, and one I would support.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, what Cocoa guys like Tony Parker say about the eventual<br>&gt;&gt;&gt;&gt; direction of delegate APIs should probably carry a lot more weight than<br>&gt;&gt;&gt;&gt; what I say.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To wind this digression down now, the API guidelines’ attitude towards<br>&gt;&gt;&gt;&gt;&gt; redundancy seems somewhat troubling; no one wants needless redundancy,<br>&gt;&gt;&gt;&gt;&gt; but natural languages tend towards redundancy (cf<br>&gt;&gt;&gt;&gt;&gt; agreement/pleonasm/etc) and it’s not at all self-evident that less<br>&gt;&gt;&gt;&gt;&gt; redundancy always implies increased readability (which you may or may<br>&gt;&gt;&gt;&gt;&gt; not be intending to imply; I can’t tell)…especially when it’s easy to<br>&gt;&gt;&gt;&gt;&gt; get fooled by increased speed-of-reading.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems like a pretty vague concern.  Let&#39;s see concrete examples of<br>&gt;&gt;&gt;&gt; problems you think the guidelines&#39; attitude toward redundancy will<br>&gt;&gt;&gt;&gt; cause.  FWIW, &quot;omit needless words&quot; isn&#39;t something we just came<br>&gt;&gt;&gt;&gt; up with ourselves: it&#39;s a time-honored principle of clear English<br>&gt;&gt;&gt;&gt; writing (google it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, sure, but if you’ll forgive a cheap shot I’d point out Strunk<br>&gt;&gt;&gt; would’ve tut-tutted here and suggested, perhaps, “we didn’t invent<br>&gt;&gt;&gt; ‘omit needless words’”. The tricky part of that rule is that what’s<br>&gt;&gt;&gt; needless is highly contextual, and to be *understood* when writing in<br>&gt;&gt;&gt; a highly-condensed style usually requires a large amount of shared<br>&gt;&gt;&gt; context.<br>&gt;&gt; <br>&gt;&gt; Oh, that *was* cheap; and I&#39;m not sure I can forgive it! :-)<br>&gt; <br>&gt; I only felt justified taking it b/c “came up with ourselves” is at least a borderline pleonasm.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Which need-for-context is at the root of my admittedly-vague concern;<br>&gt;&gt;&gt; I’ve done my best to come up with a concrete-ish example, but it’s a<br>&gt;&gt;&gt; bit contrived and not as strong as I’d like, either. It’s more of an<br>&gt;&gt;&gt; &quot;ecosystem concern”, too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are *six* functions that could conceivably be named `min` under the guidelines:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func min() -&gt; Generator.Element? // obviously only where `Generator.Element` is `Comparable`<br>&gt;&gt;&gt; func min(isLessThan comparator: (Generator.Element,Generator.Element)<br>&gt;&gt;&gt; -&gt; Bool) -&gt; Generator.Element?<br>&gt;&gt;&gt; func min&lt;K:Comparable&gt;(extractor: (Generator.Element) -&gt; K) -&gt; K?<br>&gt;&gt;&gt; func min&lt;K:Comparable&gt;(extractor: (Generator.Element) -&gt; K?) -&gt; K?<br>&gt;&gt;&gt; func min&lt;T&gt;(extractor: (Generator.Element) -&gt; T, isLessThan comparator: (T,T) -&gt; Bool) -&gt; T?<br>&gt;&gt;&gt; func min&lt;T&gt;(extractor: (Generator.Element) -&gt; T?, isLessThan comparator: (T,T) -&gt; Bool) -&gt; T?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …and perhaps they *all* should be named `min` (and we simply let<br>&gt;&gt;&gt; context and type information sort it all out for us).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But if the names should be different, what’re good choices?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My vague concern is that having “maximally-terse” names for the<br>&gt;&gt;&gt; standard library functions makes it trickier to choose<br>&gt;&gt;&gt; &quot;non-misleading” names for such closely-related variants.<br>&gt;&gt; <br>&gt;&gt; We are not going for maximal terseness in the standard library.  When we<br>&gt;&gt; pick a name like &quot;min&quot; it&#39;s because of precedent and expectations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; EG: if you go with `minValue` for the variants, to a casual reader<br>&gt;&gt;&gt; there’s room for confusion vis-a-vis `min` (I suspect many would<br>&gt;&gt;&gt; initially guess that `minValue` does what `minElement` does today, but<br>&gt;&gt;&gt; would guess the behavior correctly if given a choice between<br>&gt;&gt;&gt; `minElement` and `minValue`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately for my case, I think `minFor` is a perfectly-reasonable<br>&gt;&gt;&gt; choice here, which undermines my concrete example (I warned you the<br>&gt;&gt;&gt; case wasn’t going to be very convincing).<br>&gt;&gt; <br>&gt;&gt; It is just as you said :-)<br>&gt;&gt; <br>&gt;&gt;&gt; But that’s the kind of vague concern I have here: that a<br>&gt;&gt;&gt; “maximally-terse” naming convention can be harder to extend in a way<br>&gt;&gt;&gt; that’s both self-consistent and not-potentially-misleading.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I don’t have a great suggestion for an additional guideline, and<br>&gt;&gt;&gt; there may be nothing serious to worry about here, either.<br>&gt;&gt; <br>&gt;&gt; I think we&#39;ve made it very clear that we&#39;re not going for maximal<br>&gt;&gt; terseness:<br>&gt;&gt; <br>&gt;&gt;   Clarity is more important than brevity. Although Swift code can be<br>&gt;&gt;   compact, it is a non-goal to enable the smallest possible code with<br>&gt;&gt;   the fewest characters. Brevity in Swift code, where it occurs, is a<br>&gt;&gt;   side-effect of the strong type system and features that naturally<br>&gt;&gt;   reduce boilerplate.<br>&gt;&gt; <br>&gt;&gt; — <br>&gt; <br>&gt; I understand you don’t think you’re going for maximal terseness, but guidelines aimed at redundancy-reduction with a lack of concern for what the linguists call “markedness” (which is amongst other things context-dependent, and thus not easy to judge in isolation).<br>&gt; <br>&gt; Specifically, what counts as “weak type information” will always be somewhat context-dependent. Here’s another example, this time drawn from the Objective-C import proposal: `documentFor(url: NSURL)`.<br>&gt; <br>&gt; `documentFor(url: NSURL)` is certainly in conformance to the current guidelines.<br>&gt; <br>&gt; However, in an application context, I’d usually want application code to *largely* avoid calling such “low-level” methods directly, in favor of wrappers defined in terms of application-level concepts, e.g. some possible examples:<br>&gt; <br>&gt; documentFor(windowState: WindowState) // e.g. state-restoration<br>&gt; documentFor(bookmark: BookmarkData) // e.g. user-favorites menu<br>&gt; documentFor(user: User) // e.g. a 1:1 user-document thing (consider a test-administration use case)<br>&gt; documentFor(template: TemplateDescriptor) // e.g. create-new-document from a template of some kind<br>&gt; documentFor(image: Image) // e.g. create-a-new-document containing `image` and ready for further use<br>&gt; <br>&gt; …and so on and so forth. Note that all of the above are also in conformance with the guidelines—if `documentForURL` is wrong, then `documentForWindowState` is even more wrong!<br>&gt; <br>&gt; So, given that I would prefer application-level code use the &quot;application-level variants&quot;, I’m a bit stuck if I want the “application-level” variants to be easy to distinguish (visually) from the “low-level” variant: <br>&gt; <br>&gt; - `documentFor(url: NSURL)` is out of my control, so I can’t unilaterally-demote it to `documentForURL(url: NSURL)` on my end (I can write a wrapper, but can’t hide the base method at this time...)<br>&gt; - lengthening the “application-level” names goes against the spirit of the guidelines<br>&gt; - changing the “application-level” names often feels unidiomatic (`restoredDocumentFor(windowState: WindowState)` is ok, but `bookmarkedDocumentFor(bookmark: BookmarkData)` feels awful-and-unnecessary)<br>&gt; <br>&gt; …which wan’t a concern in Objective-C, b/c the increased verbosity kept everything uniform and easily-verifiable:<br>&gt; <br>&gt; - `documentForURL:`<br>&gt; - `documentForWindowState:`<br>&gt; - `documentForBookmark:`<br>&gt; - `documentForUser:`<br>&gt; - `documentForTemplate:`<br>&gt; - `documentForImage:`<br>&gt; <br>&gt; …(with the extensions likely having `prefix_` in front to boot!).<br>&gt; <br>&gt; I do think this is going to be a bit awkward in all settings where the guidelines steer us towards having a bunch of identically-named extension methods calling through to “standard-library” functionality; in such settings what used to be adequate type-information (within the standard library context) starts to look like weak type information (in its context-of-use).<br>&gt; <br>&gt; I don’t think the right answer is for, e.g., the Objective-C import to uniformly start using `documentForURL`-type names; that feels like overkill.<br>&gt; <br>&gt; I do think a loosened attitude about when-and-how to include a first-argument label will open up a lot of room to address such concerns; I suspect that the other discussions around when to use identical base names and when to use first argument labels is originating from at-least broadly-similar concerns.<br>&gt; <br>&gt; Perhaps it can be addressed by taking the below:<br>&gt; <br>&gt;&gt; Methods can share a base name when they share the same basic meaning but operate on different types, or are in different domains.<br>&gt; <br>&gt; …and tweaking it to include a note that such methods *may* label their first argument when necessary to clarify either:<br>&gt; <br>&gt; - the method variant (when the methods do the same thing to the point the same base name should be used, but nevertheless are meant for different-enough intents to benefit from an explicit distinction)<br>&gt; - the interpretation of said argument (hopefully this is rather rare)<br>&gt; <br>&gt; …but at this point I think I’ve said my bit, brought up the delegate-naming issue, and appreciate the time and consideration. The delegate convention seems to need a reboot, anyways, and should seemingly at least wait for the first review of the objective-c import discussion to conclude.<br>&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/cd2072f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Delegate Method Conventions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Given all of these, perhaps the best that can be done at this time is to try and get the general guidelines such that for *new* delegate APIs it’ll be possible to give them Swift names that are guideline-conformant, but can still be exposed to Objective-C (where necessary) in an idiomatic way (e.g., has the arguments in the right ordering to be a delegate/datasource/etc. call in Objective-C).<br>&gt; <br>&gt; But at least at this point I’m rather dubious there’s a worthwhile transformation out there that can be uniformly applied to the “SDK delegate/datasource protocols” and lead to an overall improvement.<br></p><p>You know, the `tableView(_:cellForRowAt:)` format has many disadvantages, but it *does* have a few good points:<br></p><p>- It&#39;s extremely distinctive and unlikely to collide with normal methods.<br>- It clearly identifies not only that it is a delegate method, but which type it&#39;s associated with (through tableView).<br>- It marks all the related methods so they stick together, even in an alphabetical list.<br></p><p>The only exception is with unary delegate methods, which may look like either `numberOfSectionsInTableView(_:)` or `controllerWillChangeContent(_:)`. There&#39;s not really a consistent format for them in Objective-C, and they often get separated from the other methods.<br></p><p>So perhaps the only transformation we should do is to make unary methods more closely match multi-parameter methods:<br></p><p>	tableView(numberOfSectionsIn:)<br>	controller(willChangeContent:)<br></p><p>Then we can provide specific, separate guidance for delegates in the guidelines, justifying this format on the basis that the most important part of a delegate method is not actually what it does, but which type needs to call it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Delegate Method Conventions</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February  3, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 4:55 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Given all of these, perhaps the best that can be done at this time is to try and get the general guidelines such that for *new* delegate APIs it’ll be possible to give them Swift names that are guideline-conformant, but can still be exposed to Objective-C (where necessary) in an idiomatic way (e.g., has the arguments in the right ordering to be a delegate/datasource/etc. call in Objective-C).<br>&gt;&gt; <br>&gt;&gt; But at least at this point I’m rather dubious there’s a worthwhile transformation out there that can be uniformly applied to the “SDK delegate/datasource protocols” and lead to an overall improvement.<br>&gt; <br>&gt; You know, the `tableView(_:cellForRowAt:)` format has many disadvantages, but it *does* have a few good points:<br>&gt; <br>&gt; - It&#39;s extremely distinctive and unlikely to collide with normal methods.<br>&gt; - It clearly identifies not only that it is a delegate method, but which type it&#39;s associated with (through tableView).<br>&gt; - It marks all the related methods so they stick together, even in an alphabetical list.<br>&gt; <br>&gt; The only exception is with unary delegate methods, which may look like either `numberOfSectionsInTableView(_:)` or `controllerWillChangeContent(_:)`. There&#39;s not really a consistent format for them in Objective-C, and they often get separated from the other methods.<br>&gt; <br>&gt; So perhaps the only transformation we should do is to make unary methods more closely match multi-parameter methods:<br>&gt; <br>&gt; 	tableView(numberOfSectionsIn:)<br>&gt; 	controller(willChangeContent:)<br>&gt; <br></p><p>This is a really nice idea.<br></p><p>At least offhand I can’t think of any problematic APIs, either.<br></p><p>&gt; Then we can provide specific, separate guidance for delegates in the guidelines, justifying this format on the basis that the most important part of a delegate method is not actually what it does, but which type needs to call it.<br></p><p>I don’t know if I buy this justification, but I like the end result quite a lot.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
