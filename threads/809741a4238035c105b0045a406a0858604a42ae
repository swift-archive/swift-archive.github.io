<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>Hi Everybody,<br></p><p>We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are soliciting comments.  First, a little background:<br></p><p>Unmanaged &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is primarily used as a return type from imported CoreFoundation functions that haven‚Äôt been annotated with reference-counting semantic information<br>A secondary known use-case is as a vehicle for creating a COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me some info and I‚Äôll give it back to your callback‚Äù mechanism.<br></p><p>We saw several problems with Unmanaged that we wanted to fix:<br>It was poorly-named (the reference is managed by somebody, we just aren&#39;t representing that management in the type system).<br>Its interface was much broader than it needs to be to cover the use-cases<br>The purpose of many of its APIs was unclear<br>Its documentation was vague and hard to understand.<br>It didn‚Äôt establish a maximally-safe usage pattern for handling the results of un-annotated CoreFoundation functions.<br></p><p>The code for the proposed replacement, called UnsafeReference, is here &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;, and a commit that updates Swift to use it is here &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;. <br></p><p>Maximally Safe Usage<br></p><p>The recommended usage pattern for handling an UnsafeReference&lt;T&gt; returned by a function CFSomething is to always use the T instance produced by one of the forms:<br></p><p>    CFSomething(arguments‚Ä¶).release() // when the result is returned at +1<br></p><p>or<br></p><p>    CFSomething(arguments‚Ä¶).object    // when the result is returned at +0<br></p><p>In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as possible, and never store the UnsafeReference&lt;T&gt; in a variable so that it can‚Äôt be (mis)used thereafter.<br></p><p>Points of Discussion<br></p><p>We‚Äôre interested in any feedback you might have, but there are a few points we‚Äôd especially like to address:<br></p><p>The name of the release() method has been contentious.<br>üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally says something like ‚Äúyou are responsible for releasing the result‚Äù in those cases where release() must be called, so there‚Äôs a very direct way to know which variant of the recommended usage pattern to employ.<br>üëé: Some people who are very familiar with existing manual retain/release programming find the recommended usage pattern really counter-intuitive because they&#39;re ‚Äúusing something after calling release on it,‚Äù which one never does in Objective-C.<br>The alternative names we‚Äôve been able to think of so far are verbose, clumsy, and don‚Äôt match up with anything in the documentation of the called function, so this seems like a really hard naming problem.  Better ideas from the community would be most welcome here.<br>We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br>We want to know whether the usage pattern recommended above works for you.<br>We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br></p><p>Thanks in advance,<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/809742ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 17, 2015 at 08:00:00pm</p></header><div class="content"><p>Hello Dave,<br></p><p>I like this change and think that it will help clarify the purpose of the<br>type. As I was reading, the only concern that I had was the name. Could you<br>please provide some of the names that you all have considered so that we<br>can avoid suggesting the same things? My suggestion is<br></p><p>    CF*Something*(*arguments‚Ä¶*).retainedObject() // when the result is<br>returned at +1<br></p><p>or<br></p><p>    CF*Something*(*arguments‚Ä¶*).unretainedObject()    // when the result is<br>returned at +0<br></p><p>on the premise that the important bit of information is whether or not the<br>object is already retained. No matter what names are chosen, that is the<br>data which determines which method to call. `retainedObject |<br>unretainedObject`, `takeRetainedObject | takeUnretainedObject`, or<br> `retained | unretained` all seem like viable options (that you have<br>probably considered).<br></p><p>TJ<br></p><p><br>On Thu, Dec 17, 2015 at 8:37 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Everybody,<br>&gt;<br>&gt; We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are<br>&gt; soliciting comments.  First, a little background:<br>&gt;<br>&gt;<br>&gt;    - Unmanaged<br>&gt;    &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is<br>&gt;    primarily used as a return type from imported CoreFoundation functions that<br>&gt;    haven‚Äôt been annotated with reference-counting semantic information<br>&gt;    - A secondary known use-case is as a vehicle for creating a<br>&gt;    COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to<br>&gt;    pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me<br>&gt;    some info and I‚Äôll give it back to your callback‚Äù mechanism.<br>&gt;<br>&gt;<br>&gt;<br>&gt;    - We saw several problems with Unmanaged that we wanted to fix:<br>&gt;       - It was poorly-named (the reference is managed by *somebody*, we<br>&gt;       just aren&#39;t representing that management in the type system).<br>&gt;       - Its interface was much broader than it needs to be to cover the<br>&gt;       use-cases<br>&gt;       - The purpose of many of its APIs was unclear<br>&gt;       - Its documentation was vague and hard to understand.<br>&gt;       - It didn‚Äôt establish a maximally-safe usage pattern for handling<br>&gt;       the results of un-annotated CoreFoundation functions.<br>&gt;<br>&gt;<br>&gt; The code for the proposed replacement, called UnsafeReference, is here<br>&gt; &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;,<br>&gt; and a commit that updates Swift to use it is here<br>&gt; &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;<br>&gt; .<br>&gt;<br>&gt; Maximally Safe Usage<br>&gt;<br>&gt; The recommended usage pattern for handling an UnsafeReference&lt;T&gt; returned<br>&gt; by a function CF*Something* is to always use the T instance produced by<br>&gt; one of the forms:<br>&gt;<br>&gt;     CF*Something*(*arguments‚Ä¶*).release() // when the result is returned<br>&gt; at +1<br>&gt;<br>&gt; or<br>&gt;<br>&gt;     CF*Something*(*arguments‚Ä¶*).object    // when the result is returned<br>&gt; at +0<br>&gt;<br>&gt; In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as<br>&gt; possible, and never store the UnsafeReference&lt;T&gt; in a variable so that it<br>&gt; can‚Äôt be (mis)used thereafter.<br>&gt;<br>&gt; Points of Discussion<br>&gt;<br>&gt; We‚Äôre interested in any feedback you might have, but there are a few<br>&gt; points we‚Äôd especially like to address:<br>&gt;<br>&gt;<br>&gt;    - The name of the release() method has been contentious.<br>&gt;       - üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule<br>&gt;       &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally<br>&gt;       says something like ‚Äúyou are responsible for releasing the result‚Äù in those<br>&gt;       cases where release() must be called, so there‚Äôs a very direct way<br>&gt;       to know which variant of the recommended usage pattern to employ.<br>&gt;       - üëé: Some people who are very familiar with existing manual<br>&gt;       retain/release programming find the recommended usage pattern really<br>&gt;       counter-intuitive because they&#39;re ‚Äúusing something after calling release on<br>&gt;       it,‚Äù which one never does in Objective-C.<br>&gt;       - The alternative names we‚Äôve been able to think of so far are<br>&gt;       verbose, clumsy, and don‚Äôt match up with anything in the documentation of<br>&gt;       the called function, so this seems like a really hard naming problem.<br>&gt;       Better ideas from the community would be most welcome here.<br>&gt;    - We‚Äôre not sure about the terminology<br>&gt;    &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used<br>&gt;    to precisely describe the semantics of UnsafeReference. We‚Äôd like to<br>&gt;    know if these terms make sense to you or whether you have better ideas.<br>&gt;    - We want to know whether the usage pattern recommended above works<br>&gt;    for you.<br>&gt;    - We want to know if the API is sufficiently broad or if there are<br>&gt;    things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br>&gt;<br>&gt;<br>&gt; Thanks in advance,<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/903092ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 17, 2015 at 06:00:00pm</p></header><div class="content"><p>Thanks very much for the quick feedback TJ, <br></p><p>&gt; On Dec 17, 2015, at 5:52 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello Dave,<br>&gt; <br>&gt; I like this change and think that it will help clarify the purpose of the type. As I was reading, the only concern that I had was the name. Could you please provide some of the names that you all have considered<br></p><p>Honestly, I am sorry to say, we did that exercise almost a month ago and I don‚Äôt remember the ones we discussed.<br></p><p>&gt; so that we can avoid suggesting the same things? My suggestion is <br>&gt; <br>&gt;     CFSomething(arguments‚Ä¶).retainedObject() // when the result is returned at +1<br>&gt; <br>&gt; or<br>&gt; <br>&gt;     CFSomething(arguments‚Ä¶).unretainedObject()    // when the result is returned at +0<br>&gt; <br>&gt; on the premise that the important bit of information is whether or not the object is already retained. No matter what names are chosen, that is the data which determines which method to call. `retainedObject | unretainedObject`, `takeRetainedObject | takeUnretainedObject`, or  `retained | unretained` all seem like viable options (that you have probably considered).<br></p><p><br>Some issues with these names:<br></p><p>The ‚Äúed/ing‚Äù rule &lt;https://swift.org/documentation/api-design-guidelines.html#be-grammatical&gt; makes these names suggest that the accessors are idempotent, but the first one must be called exactly once.  That name should really be an active verb since it is state-changing.<br>‚ÄúretainedObject‚Äù also suggests that it‚Äôs returning some underlying object after retaining it, which is almost the opposite of what that API does‚Ä¶ and vice-versa for ‚ÄúunretainedObject&quot;<br>Also, the object ‚Äúhas been retained‚Äù in all cases, or it would have been deallocated.  The question is whether the object would leak if we fail to call release on it<br>Nothing in these names connect them to what the documentation says about the functions that return Unmanaged, so it‚Äôs hard to know which one to call<br>The second API is objectively safer than the first one (which causes undefined behavior when overused and only leaks when underused).  The API I proposed makes it clear that they are not peers, where yours implies parity‚Äîthough I am of two minds about the value of representing the lack of parity.<br></p><p>You may legitimately argue that any of these concerns are unimportant, but those are the ones that come up for me.<br></p><p>&gt; TJ<br>&gt; <br>&gt; <br>&gt; On Thu, Dec 17, 2015 at 8:37 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi Everybody,<br>&gt; <br>&gt; We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are soliciting comments.  First, a little background:<br>&gt; <br>&gt; Unmanaged &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is primarily used as a return type from imported CoreFoundation functions that haven‚Äôt been annotated with reference-counting semantic information<br>&gt; A secondary known use-case is as a vehicle for creating a COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me some info and I‚Äôll give it back to your callback‚Äù mechanism.<br>&gt; <br>&gt; We saw several problems with Unmanaged that we wanted to fix:<br>&gt; It was poorly-named (the reference is managed by somebody, we just aren&#39;t representing that management in the type system).<br>&gt; Its interface was much broader than it needs to be to cover the use-cases<br>&gt; The purpose of many of its APIs was unclear<br>&gt; Its documentation was vague and hard to understand.<br>&gt; It didn‚Äôt establish a maximally-safe usage pattern for handling the results of un-annotated CoreFoundation functions.<br>&gt; <br>&gt; The code for the proposed replacement, called UnsafeReference, is here &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;, and a commit that updates Swift to use it is here &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;. <br>&gt; <br>&gt; Maximally Safe Usage<br>&gt; <br>&gt; The recommended usage pattern for handling an UnsafeReference&lt;T&gt; returned by a function CFSomething is to always use the T instance produced by one of the forms:<br>&gt; <br>&gt;     CFSomething(arguments‚Ä¶).release() // when the result is returned at +1<br>&gt; <br>&gt; or<br>&gt; <br>&gt;     CFSomething(arguments‚Ä¶).object    // when the result is returned at +0<br>&gt; <br>&gt; In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as possible, and never store the UnsafeReference&lt;T&gt; in a variable so that it can‚Äôt be (mis)used thereafter.<br>&gt; <br>&gt; Points of Discussion<br>&gt; <br>&gt; We‚Äôre interested in any feedback you might have, but there are a few points we‚Äôd especially like to address:<br>&gt; <br>&gt; The name of the release() method has been contentious.<br>&gt; üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally says something like ‚Äúyou are responsible for releasing the result‚Äù in those cases where release() must be called, so there‚Äôs a very direct way to know which variant of the recommended usage pattern to employ.<br>&gt; üëé: Some people who are very familiar with existing manual retain/release programming find the recommended usage pattern really counter-intuitive because they&#39;re ‚Äúusing something after calling release on it,‚Äù which one never does in Objective-C.<br>&gt; The alternative names we‚Äôve been able to think of so far are verbose, clumsy, and don‚Äôt match up with anything in the documentation of the called function, so this seems like a really hard naming problem.  Better ideas from the community would be most welcome here.<br>&gt; We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br>&gt; We want to know whether the usage pattern recommended above works for you.<br>&gt; We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br>&gt; <br>&gt; Thanks in advance,<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/d01d059b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 17, 2015 at 09:00:00pm</p></header><div class="content"><p>I think I see what you mean about parity. `.object` can be called multiple<br>times, then? Why not make `release()` slightly more verbose since it should<br>only be called once anyway? Something along the lines of<br>`.releaseAndReturnObject` or ‚Ä¶ something slightly less verbose.<br></p><p>My main point of contention with `.release()` is that it has the *exact*<br>same name as a method from the MRC strategy. Maybe this is a silly point,<br>but this overlap could further complicate teaching how ARC works and in<br>what ways it is based on MRC conventions.  I am not of the opinion that ARC<br>is fundamentally more difficult to understand than MRC, but I do believe<br>that it takes a very particular kind of faith now that we don&#39;t get to<br>manually write the retains and releases. This is completely worth it, in my<br>opinion, but  I want to avoid making it *more* confusing to explain what<br>ARC doing at compile time.<br></p><p>TJ<br></p><p>On Thu, Dec 17, 2015 at 9:13 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt; Thanks very much for the quick feedback TJ,<br>&gt;<br>&gt; On Dec 17, 2015, at 5:52 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; Hello Dave,<br>&gt;<br>&gt; I like this change and think that it will help clarify the purpose of the<br>&gt; type. As I was reading, the only concern that I had was the name. Could you<br>&gt; please provide some of the names that you all have considered<br>&gt;<br>&gt;<br>&gt; Honestly, I am sorry to say, we did that exercise almost a month ago and I<br>&gt; don‚Äôt remember the ones we discussed.<br>&gt;<br>&gt; so that we can avoid suggesting the same things? My suggestion is<br>&gt;<br>&gt;     CF*Something*(*arguments‚Ä¶*).retainedObject() // when the result is<br>&gt; returned at +1<br>&gt;<br>&gt; or<br>&gt;<br>&gt;     CF*Something*(*arguments‚Ä¶*).unretainedObject()    // when the result<br>&gt; is returned at +0<br>&gt;<br>&gt; on the premise that the important bit of information is whether or not the<br>&gt; object is already retained. No matter what names are chosen, that is the<br>&gt; data which determines which method to call. `retainedObject |<br>&gt; unretainedObject`, `takeRetainedObject | takeUnretainedObject`, or<br>&gt;  `retained | unretained` all seem like viable options (that you have<br>&gt; probably considered).<br>&gt;<br>&gt;<br>&gt;<br>&gt; Some issues with these names:<br>&gt;<br>&gt;<br>&gt;    - The ‚Äúed/ing‚Äù rule<br>&gt;    &lt;https://swift.org/documentation/api-design-guidelines.html#be-grammatical&gt; makes<br>&gt;    these names suggest that the accessors are idempotent, but the first one<br>&gt;    must be called exactly once.  That name should really be an active verb<br>&gt;    since it is state-changing.<br>&gt;    - ‚ÄúretainedObject‚Äù also suggests that it‚Äôs returning some underlying<br>&gt;    object after retaining it, which is almost the opposite of what that API<br>&gt;    does‚Ä¶ and vice-versa for ‚ÄúunretainedObject&quot;<br>&gt;    - Also, the object ‚Äúhas been retained‚Äù in all cases, or it would have<br>&gt;    been deallocated.  The question is whether the object would leak if we fail<br>&gt;    to call release on it<br>&gt;    - Nothing in these names connect them to what the documentation says<br>&gt;    about the functions that return Unmanaged, so it‚Äôs hard to know which one<br>&gt;    to call<br>&gt;    - The second API is objectively safer than the first one (which causes<br>&gt;    undefined behavior when overused and only leaks when underused).  The API I<br>&gt;    proposed makes it clear that they are not peers, where yours implies<br>&gt;    parity‚Äîthough I am of two minds about the value of representing the lack of<br>&gt;    parity.<br>&gt;<br>&gt;<br>&gt; You may legitimately argue that any of these concerns are unimportant, but<br>&gt; those are the ones that come up for me.<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt;<br>&gt; On Thu, Dec 17, 2015 at 8:37 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Everybody,<br>&gt;&gt;<br>&gt;&gt; We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are<br>&gt;&gt; soliciting comments.  First, a little background:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Unmanaged<br>&gt;&gt;    &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is<br>&gt;&gt;    primarily used as a return type from imported CoreFoundation functions that<br>&gt;&gt;    haven‚Äôt been annotated with reference-counting semantic information<br>&gt;&gt;    - A secondary known use-case is as a vehicle for creating a<br>&gt;&gt;    COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to<br>&gt;&gt;    pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me<br>&gt;&gt;    some info and I‚Äôll give it back to your callback‚Äù mechanism.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - We saw several problems with Unmanaged that we wanted to fix:<br>&gt;&gt;       - It was poorly-named (the reference is managed by *somebody*, we<br>&gt;&gt;       just aren&#39;t representing that management in the type system).<br>&gt;&gt;       - Its interface was much broader than it needs to be to cover the<br>&gt;&gt;       use-cases<br>&gt;&gt;       - The purpose of many of its APIs was unclear<br>&gt;&gt;       - Its documentation was vague and hard to understand.<br>&gt;&gt;       - It didn‚Äôt establish a maximally-safe usage pattern for handling<br>&gt;&gt;       the results of un-annotated CoreFoundation functions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The code for the proposed replacement, called UnsafeReference, is here<br>&gt;&gt; &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;,<br>&gt;&gt; and a commit that updates Swift to use it is here<br>&gt;&gt; &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;<br>&gt;&gt; .<br>&gt;&gt;<br>&gt;&gt; Maximally Safe Usage<br>&gt;&gt;<br>&gt;&gt; The recommended usage pattern for handling an UnsafeReference&lt;T&gt;<br>&gt;&gt; returned by a function CF*Something* is to always use the T instance<br>&gt;&gt; produced by one of the forms:<br>&gt;&gt;<br>&gt;&gt;     CF*Something*(*arguments‚Ä¶*).release() // when the result is returned<br>&gt;&gt; at +1<br>&gt;&gt;<br>&gt;&gt; or<br>&gt;&gt;<br>&gt;&gt;     CF*Something*(*arguments‚Ä¶*).object    // when the result is returned<br>&gt;&gt; at +0<br>&gt;&gt;<br>&gt;&gt; In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as<br>&gt;&gt; possible, and never store the UnsafeReference&lt;T&gt; in a variable so that<br>&gt;&gt; it can‚Äôt be (mis)used thereafter.<br>&gt;&gt;<br>&gt;&gt; Points of Discussion<br>&gt;&gt;<br>&gt;&gt; We‚Äôre interested in any feedback you might have, but there are a few<br>&gt;&gt; points we‚Äôd especially like to address:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - The name of the release() method has been contentious.<br>&gt;&gt;       - üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule<br>&gt;&gt;       &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally<br>&gt;&gt;       says something like ‚Äúyou are responsible for releasing the result‚Äù in those<br>&gt;&gt;       cases where release() must be called, so there‚Äôs a very direct way<br>&gt;&gt;       to know which variant of the recommended usage pattern to employ.<br>&gt;&gt;       - üëé: Some people who are very familiar with existing manual<br>&gt;&gt;       retain/release programming find the recommended usage pattern really<br>&gt;&gt;       counter-intuitive because they&#39;re ‚Äúusing something after calling release on<br>&gt;&gt;       it,‚Äù which one never does in Objective-C.<br>&gt;&gt;       - The alternative names we‚Äôve been able to think of so far are<br>&gt;&gt;       verbose, clumsy, and don‚Äôt match up with anything in the documentation of<br>&gt;&gt;       the called function, so this seems like a really hard naming problem.<br>&gt;&gt;       Better ideas from the community would be most welcome here.<br>&gt;&gt;    - We‚Äôre not sure about the terminology<br>&gt;&gt;    &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used<br>&gt;&gt;    to precisely describe the semantics of UnsafeReference. We‚Äôd like to<br>&gt;&gt;    know if these terms make sense to you or whether you have better ideas.<br>&gt;&gt;    - We want to know whether the usage pattern recommended above works<br>&gt;&gt;    for you.<br>&gt;&gt;    - We want to know if the API is sufficiently broad or if there are<br>&gt;&gt;    things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thanks in advance,<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/0d6753cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>F√©lix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 17, 2015 at 10:00:00pm</p></header><div class="content"><p>If this can be used as any reference, I wrote some code to help interoperate with Python in C++. The Python API inconsistently returns references with a +0 or +1 count. I use macros called TAKEREF (when the object is returned with a +1 count) and ADDREF (when it&#39;s returned with +0) to create smart wrappers. The wrapper will always decrement the reference count during destruction.<br></p><p>I find it unambiguous: you need to add a reference if you&#39;re going to take one away at destruction, so ADD; but if the object is returned with a +1 count, you can just TAKE the reference. It coincidentally does not borrow terminology from Objective-C&#39;s memory management system.<br></p><p>&gt; Le 17 d√©c. 2015 √† 21:23:56, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt; <br>&gt; I think I see what you mean about parity. `.object` can be called multiple times, then? Why not make `release()` slightly more verbose since it should only be called once anyway? Something along the lines of `.releaseAndReturnObject` or ‚Ä¶ something slightly less verbose. <br>&gt; <br>&gt; My main point of contention with `.release()` is that it has the *exact* same name as a method from the MRC strategy. Maybe this is a silly point, but this overlap could further complicate teaching how ARC works and in what ways it is based on MRC conventions.  I am not of the opinion that ARC is fundamentally more difficult to understand than MRC, but I do believe that it takes a very particular kind of faith now that we don&#39;t get to manually write the retains and releases. This is completely worth it, in my opinion, but  I want to avoid making it *more* confusing to explain what ARC doing at compile time. <br>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Thu, Dec 17, 2015 at 9:13 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt; Thanks very much for the quick feedback TJ, <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 5:52 PM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Dave,<br>&gt;&gt; <br>&gt;&gt; I like this change and think that it will help clarify the purpose of the type. As I was reading, the only concern that I had was the name. Could you please provide some of the names that you all have considered <br>&gt; <br>&gt; Honestly, I am sorry to say, we did that exercise almost a month ago and I don‚Äôt remember the ones we discussed.<br>&gt; <br>&gt;&gt; so that we can avoid suggesting the same things? My suggestion is <br>&gt;&gt; <br>&gt;&gt;     CFSomething(arguments‚Ä¶).retainedObject() // when the result is returned at +1<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt;     CFSomething(arguments‚Ä¶).unretainedObject()    // when the result is returned at +0<br>&gt;&gt; <br>&gt;&gt; on the premise that the important bit of information is whether or not the object is already retained. No matter what names are chosen, that is the data which determines which method to call. `retainedObject | unretainedObject`, `takeRetainedObject | takeUnretainedObject`, or  `retained | unretained` all seem like viable options (that you have probably considered).<br>&gt; <br>&gt; <br>&gt; Some issues with these names:<br>&gt; <br>&gt; The ‚Äúed/ing‚Äù rule &lt;https://swift.org/documentation/api-design-guidelines.html#be-grammatical&gt; makes these names suggest that the accessors are idempotent, but the first one must be called exactly once.  That name should really be an active verb since it is state-changing.<br>&gt; ‚ÄúretainedObject‚Äù also suggests that it‚Äôs returning some underlying object after retaining it, which is almost the opposite of what that API does‚Ä¶ and vice-versa for ‚ÄúunretainedObject&quot;<br>&gt; Also, the object ‚Äúhas been retained‚Äù in all cases, or it would have been deallocated.  The question is whether the object would leak if we fail to call release on it<br>&gt; Nothing in these names connect them to what the documentation says about the functions that return Unmanaged, so it‚Äôs hard to know which one to call<br>&gt; The second API is objectively safer than the first one (which causes undefined behavior when overused and only leaks when underused).  The API I proposed makes it clear that they are not peers, where yours implies parity‚Äîthough I am of two minds about the value of representing the lack of parity.<br>&gt; <br>&gt; You may legitimately argue that any of these concerns are unimportant, but those are the ones that come up for me.<br>&gt; <br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 17, 2015 at 8:37 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi Everybody,<br>&gt;&gt; <br>&gt;&gt; We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are soliciting comments.  First, a little background:<br>&gt;&gt; <br>&gt;&gt; Unmanaged &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is primarily used as a return type from imported CoreFoundation functions that haven‚Äôt been annotated with reference-counting semantic information<br>&gt;&gt; A secondary known use-case is as a vehicle for creating a COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me some info and I‚Äôll give it back to your callback‚Äù mechanism.<br>&gt;&gt; <br>&gt;&gt; We saw several problems with Unmanaged that we wanted to fix:<br>&gt;&gt; It was poorly-named (the reference is managed by somebody, we just aren&#39;t representing that management in the type system).<br>&gt;&gt; Its interface was much broader than it needs to be to cover the use-cases<br>&gt;&gt; The purpose of many of its APIs was unclear<br>&gt;&gt; Its documentation was vague and hard to understand.<br>&gt;&gt; It didn‚Äôt establish a maximally-safe usage pattern for handling the results of un-annotated CoreFoundation functions.<br>&gt;&gt; <br>&gt;&gt; The code for the proposed replacement, called UnsafeReference, is here &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;, and a commit that updates Swift to use it is here &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;. <br>&gt;&gt; <br>&gt;&gt; Maximally Safe Usage<br>&gt;&gt; <br>&gt;&gt; The recommended usage pattern for handling an UnsafeReference&lt;T&gt; returned by a function CFSomething is to always use the T instance produced by one of the forms:<br>&gt;&gt; <br>&gt;&gt;     CFSomething(arguments‚Ä¶).release() // when the result is returned at +1<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt;     CFSomething(arguments‚Ä¶).object    // when the result is returned at +0<br>&gt;&gt; <br>&gt;&gt; In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as possible, and never store the UnsafeReference&lt;T&gt; in a variable so that it can‚Äôt be (mis)used thereafter.<br>&gt;&gt; <br>&gt;&gt; Points of Discussion<br>&gt;&gt; <br>&gt;&gt; We‚Äôre interested in any feedback you might have, but there are a few points we‚Äôd especially like to address:<br>&gt;&gt; <br>&gt;&gt; The name of the release() method has been contentious.<br>&gt;&gt; üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally says something like ‚Äúyou are responsible for releasing the result‚Äù in those cases where release() must be called, so there‚Äôs a very direct way to know which variant of the recommended usage pattern to employ.<br>&gt;&gt; üëé: Some people who are very familiar with existing manual retain/release programming find the recommended usage pattern really counter-intuitive because they&#39;re ‚Äúusing something after calling release on it,‚Äù which one never does in Objective-C.<br>&gt;&gt; The alternative names we‚Äôve been able to think of so far are verbose, clumsy, and don‚Äôt match up with anything in the documentation of the called function, so this seems like a really hard naming problem.  Better ideas from the community would be most welcome here.<br>&gt;&gt; We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br>&gt;&gt; We want to know whether the usage pattern recommended above works for you.<br>&gt;&gt; We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br>&gt;&gt; <br>&gt;&gt; Thanks in advance,<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/ef6bb4f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 7:32 PM, F√©lix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; If this can be used as any reference, I wrote some code to help interoperate with Python in C++.<br></p><p>BTDT; see http://boost.org/libs/python :-)<br></p><p>&gt; The Python API inconsistently returns references with a +0 or +1 count. I use macros called TAKEREF (when the object is returned with a +1 count) and ADDREF (when it&#39;s returned with +0) to create smart wrappers. The wrapper will always decrement the reference count during destruction.<br>&gt; <br>&gt; I find it unambiguous: you need to add a reference if you&#39;re going to take one away at destruction, so ADD; but if the object is returned with a +1 count, you can just TAKE the reference. It coincidentally does not borrow terminology from Objective-C&#39;s memory management system.<br></p><p>But it does tread on an area we‚Äôre trying very hard to clear up in Swift‚Äôs use of terminology: what does the word ‚Äútake‚Äù mean?  In fact the ‚Äútake‚Äù problem was partly caused by the existing design of Unmanaged.  Also, while unambiguous, it‚Äôs a very low-level description of what‚Äôs happening, that doesn‚Äôt much help the user reading the documentation of a CF function to answer the ‚Äúwhich one do I use?‚Äù question unless s/he‚Äôs already experienced with how to map what it says in that docs onto the use of ADDREF/TAKEREF.<br></p><p>&gt;&gt; Le 17 d√©c. 2015 √† 21:23:56, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt; <br>&gt;&gt; I think I see what you mean about parity. `.object` can be called multiple times, then? Why not make `release()` slightly more verbose since it should only be called once anyway? Something along the lines of `.releaseAndReturnObject` or ‚Ä¶ something slightly less verbose. <br>&gt;&gt; <br>&gt;&gt; My main point of contention with `.release()` is that it has the *exact* same name as a method from the MRC strategy. Maybe this is a silly point, but this overlap could further complicate teaching how ARC works and in what ways it is based on MRC conventions.  I am not of the opinion that ARC is fundamentally more difficult to understand than MRC, but I do believe that it takes a very particular kind of faith now that we don&#39;t get to manually write the retains and releases. This is completely worth it, in my opinion, but  I want to avoid making it *more* confusing to explain what ARC doing at compile time. <br>&gt;&gt; <br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 17, 2015 at 9:13 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; Thanks very much for the quick feedback TJ, <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 5:52 PM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Dave,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this change and think that it will help clarify the purpose of the type. As I was reading, the only concern that I had was the name. Could you please provide some of the names that you all have considered <br>&gt;&gt; <br>&gt;&gt; Honestly, I am sorry to say, we did that exercise almost a month ago and I don‚Äôt remember the ones we discussed.<br>&gt;&gt; <br>&gt;&gt;&gt; so that we can avoid suggesting the same things? My suggestion is <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     CFSomething(arguments‚Ä¶).retainedObject() // when the result is returned at +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     CFSomething(arguments‚Ä¶).unretainedObject()    // when the result is returned at +0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on the premise that the important bit of information is whether or not the object is already retained. No matter what names are chosen, that is the data which determines which method to call. `retainedObject | unretainedObject`, `takeRetainedObject | takeUnretainedObject`, or  `retained | unretained` all seem like viable options (that you have probably considered).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Some issues with these names:<br>&gt;&gt; <br>&gt;&gt; The ‚Äúed/ing‚Äù rule &lt;https://swift.org/documentation/api-design-guidelines.html#be-grammatical&gt; makes these names suggest that the accessors are idempotent, but the first one must be called exactly once.  That name should really be an active verb since it is state-changing.<br>&gt;&gt; ‚ÄúretainedObject‚Äù also suggests that it‚Äôs returning some underlying object after retaining it, which is almost the opposite of what that API does‚Ä¶ and vice-versa for ‚ÄúunretainedObject&quot;<br>&gt;&gt; Also, the object ‚Äúhas been retained‚Äù in all cases, or it would have been deallocated.  The question is whether the object would leak if we fail to call release on it<br>&gt;&gt; Nothing in these names connect them to what the documentation says about the functions that return Unmanaged, so it‚Äôs hard to know which one to call<br>&gt;&gt; The second API is objectively safer than the first one (which causes undefined behavior when overused and only leaks when underused).  The API I proposed makes it clear that they are not peers, where yours implies parity‚Äîthough I am of two minds about the value of representing the lack of parity.<br>&gt;&gt; <br>&gt;&gt; You may legitimately argue that any of these concerns are unimportant, but those are the ones that come up for me.<br>&gt;&gt; <br>&gt;&gt;&gt; TJ<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Dec 17, 2015 at 8:37 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi Everybody,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are soliciting comments.  First, a little background:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unmanaged &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is primarily used as a return type from imported CoreFoundation functions that haven‚Äôt been annotated with reference-counting semantic information<br>&gt;&gt;&gt; A secondary known use-case is as a vehicle for creating a COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me some info and I‚Äôll give it back to your callback‚Äù mechanism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We saw several problems with Unmanaged that we wanted to fix:<br>&gt;&gt;&gt; It was poorly-named (the reference is managed by somebody, we just aren&#39;t representing that management in the type system).<br>&gt;&gt;&gt; Its interface was much broader than it needs to be to cover the use-cases<br>&gt;&gt;&gt; The purpose of many of its APIs was unclear<br>&gt;&gt;&gt; Its documentation was vague and hard to understand.<br>&gt;&gt;&gt; It didn‚Äôt establish a maximally-safe usage pattern for handling the results of un-annotated CoreFoundation functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The code for the proposed replacement, called UnsafeReference, is here &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;, and a commit that updates Swift to use it is here &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maximally Safe Usage<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The recommended usage pattern for handling an UnsafeReference&lt;T&gt; returned by a function CFSomething is to always use the T instance produced by one of the forms:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     CFSomething(arguments‚Ä¶).release() // when the result is returned at +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     CFSomething(arguments‚Ä¶).object    // when the result is returned at +0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as possible, and never store the UnsafeReference&lt;T&gt; in a variable so that it can‚Äôt be (mis)used thereafter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Points of Discussion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We‚Äôre interested in any feedback you might have, but there are a few points we‚Äôd especially like to address:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The name of the release() method has been contentious.<br>&gt;&gt;&gt; üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally says something like ‚Äúyou are responsible for releasing the result‚Äù in those cases where release() must be called, so there‚Äôs a very direct way to know which variant of the recommended usage pattern to employ.<br>&gt;&gt;&gt; üëé: Some people who are very familiar with existing manual retain/release programming find the recommended usage pattern really counter-intuitive because they&#39;re ‚Äúusing something after calling release on it,‚Äù which one never does in Objective-C.<br>&gt;&gt;&gt; The alternative names we‚Äôve been able to think of so far are verbose, clumsy, and don‚Äôt match up with anything in the documentation of the called function, so this seems like a really hard naming problem.  Better ideas from the community would be most welcome here.<br>&gt;&gt;&gt; We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br>&gt;&gt;&gt; We want to know whether the usage pattern recommended above works for you.<br>&gt;&gt;&gt; We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks in advance,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8cc45d00/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; Also, while unambiguous, it‚Äôs a very low-level description of what‚Äôs happening, that doesn‚Äôt much help the user reading the documentation of a CF function to answer the ‚Äúwhich one do I use?‚Äù question unless s/he‚Äôs already experienced with how to map what it says in that docs onto the use of ADDREF/TAKEREF.<br></p><p>I wonder if, instead of talking about retained/unretained, we should talk about whether the call ‚Äúcreated&quot; or ‚Äúretrieved&quot; the object it‚Äôs returning. If it created it, the object is +1; if it retrieved it, the object is +0.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 1:18 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Also, while unambiguous, it‚Äôs a very low-level description of what‚Äôs happening, that doesn‚Äôt much help the user reading the documentation of a CF function to answer the ‚Äúwhich one do I use?‚Äù question unless s/he‚Äôs already experienced with how to map what it says in that docs onto the use of ADDREF/TAKEREF.<br>&gt; <br>&gt; I wonder if, instead of talking about retained/unretained, we should talk about whether the call ‚Äúcreated&quot; or ‚Äúretrieved&quot; the object it‚Äôs returning. If it created it, the object is +1; if it retrieved it, the object is +0.<br></p><p>I think I‚Äôd need more detail in order to evaluate the idea.  Are you suggesting changing the way some CF functions are documented?  Some concrete examples would certainly help.<br> <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 19, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; Also, while unambiguous, it‚Äôs a very low-level description of what‚Äôs happening, that doesn‚Äôt much help the user reading the documentation of a CF function to answer the ‚Äúwhich one do I use?‚Äù question unless s/he‚Äôs already experienced with how to map what it says in that docs onto the use of ADDREF/TAKEREF.<br>&gt;&gt; <br>&gt;&gt; I wonder if, instead of talking about retained/unretained, we should talk about whether the call ‚Äúcreated&quot; or ‚Äúretrieved&quot; the object it‚Äôs returning. If it created it, the object is +1; if it retrieved it, the object is +0.<br>&gt; <br>&gt; I think I‚Äôd need more detail in order to evaluate the idea.  Are you suggesting changing the way some CF functions are documented?  Some concrete examples would certainly help.<br></p><p>CFAttributedString has actually been audited, but pretend it hasn&#39;t been...<br></p><p>	let attributedString = CFAttributedStringCreate(nil, anotherString,nil).takeCreatedObject()<br>	let str = CFAttributedStringGetString(attributedString).takeRetrievedObject()<br></p><p>I&#39;m not a huge fan of the &quot;take&quot; here, but I think this general strategy of trying to say whether the Create Rule or the Get Rule applies is better than trying to make people understand when they should use &quot;released&quot; or not.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 02:00:00pm</p></header><div class="content"><p>Brent, thanks for working through this with me‚Ä¶<br></p><p>&gt; On Dec 19, 2015, at 2:02 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; Also, while unambiguous, it‚Äôs a very low-level description of what‚Äôs happening, that doesn‚Äôt much help the user reading the documentation of a CF function to answer the ‚Äúwhich one do I use?‚Äù question unless s/he‚Äôs already experienced with how to map what it says in that docs onto the use of ADDREF/TAKEREF.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder if, instead of talking about retained/unretained, we should talk about whether the call ‚Äúcreated&quot; or ‚Äúretrieved&quot; the object it‚Äôs returning. If it created it, the object is +1; if it retrieved it, the object is +0.<br>&gt;&gt; <br>&gt;&gt; I think I‚Äôd need more detail in order to evaluate the idea.  Are you suggesting changing the way some CF functions are documented?  Some concrete examples would certainly help.<br>&gt; <br>&gt; CFAttributedString has actually been audited, but pretend it hasn&#39;t been...<br>&gt; <br>&gt; 	let attributedString = CFAttributedStringCreate(nil, anotherString,nil).takeCreatedObject()<br>&gt; 	let str = CFAttributedStringGetString(attributedString).takeRetrievedObject()<br>&gt; <br>&gt; I&#39;m not a huge fan of the &quot;take&quot; here,<br></p><p>Then why did you use it, if you don&#39;t mind my asking?  What is it supposed to mean in this context?<br></p><p>&gt; but I think this general strategy of trying to say whether the Create Rule or the Get Rule applies is better than trying to make people understand when they should use &quot;released&quot; or not.<br></p><p>Why is that better?<br></p><p>And how does &quot;Retrieved&quot; map onto &quot;Get&quot;?<br></p><p>Seems to me that if you know what the &quot;Create Rule&quot; is, you know it says &quot;you&#39;re responsible for releasing the result.&quot;  If you know a name contains &quot;Create&quot;, you already have a good clue that the &quot;Create Rule&quot; applies.  Isn&#39;t it the users of the functions that don&#39;t contain &quot;Create&quot; or &quot;Get&quot; in their names that need the most help?<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 19, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; CFAttributedString has actually been audited, but pretend it hasn&#39;t been...<br>&gt;&gt; <br>&gt;&gt; 	let attributedString = CFAttributedStringCreate(nil, anotherString,nil).takeCreatedObject()<br>&gt;&gt; 	let str = CFAttributedStringGetString(attributedString).takeRetrievedObject()<br>&gt;&gt; <br>&gt;&gt; I&#39;m not a huge fan of the &quot;take&quot; here,<br>&gt; <br>&gt; Then why did you use it, if you don&#39;t mind my asking?  What is it supposed to mean in this context?<br></p><p>I suppose I&#39;m struggling with the fact that there&#39;s clearly an action taking place here (at least in the created case), and yet merely saying `createdObject()` or `retrievedObject()` doesn&#39;t imply that. Those operations sound idempotent, but they&#39;re not.<br></p><p>(I kind of want to suggest that retrieving an object through these calls should destroy the reference so it can&#39;t be used again, but I don&#39;t think that fits with Swift&#39;s mutation model without turning `Unmanaged`/`UnsafeReference` into a reference type and adding lots of overhead.)<br></p><p>&gt;&gt; but I think this general strategy of trying to say whether the Create Rule or the Get Rule applies is better than trying to make people understand when they should use &quot;released&quot; or not.<br>&gt; <br>&gt; Why is that better?<br></p><p>Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit ambiguous to me. Are you saying it *has been* released, or are you saying it *needs to be* released? I have the same problem with the current `takeRetainedValue()`/`takeUnretainedValue()` calls‚ÄîI&#39;m never sure which one I&#39;m supposed to use. I&#39;m hoping that, by stepping up a level and describing the semantic you want rather than the operation needed to achieve that semantic, this confusion can be cleared up.<br></p><p>I also like that this creates a matched pair of methods. Because they look sort of like each other, it&#39;s easier to understand that you should call one or the other, and to remember them.<br></p><p>&gt; And how does &quot;Retrieved&quot; map onto &quot;Get&quot;?<br></p><p>Not all that cleanly, I admit. &quot;Gotten&quot; would be better, but &quot;get&quot; is an irregular verb and I&#39;m a little concerned about programmers who have English as a second language. (Plus, I subjectively think it&#39;s kind of ugly.)<br></p><p>(One possibility would be to have a single call with an enum parameter, like `bridge(.Create)` and `bridge(.Get)`. This would let you use the regular form of the verb.)<br></p><p>&gt; Isn&#39;t it the users of the functions that don&#39;t contain &quot;Create&quot; or &quot;Get&quot; in their names that need the most help?<br></p><p>I think of it more as &quot;treat this like a Create function&quot; or &quot;treat this like a Get function&quot;.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 2:59 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; CFAttributedString has actually been audited, but pretend it hasn&#39;t been...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let attributedString = CFAttributedStringCreate(nil, anotherString,nil).takeCreatedObject()<br>&gt;&gt;&gt; 	let str = CFAttributedStringGetString(attributedString).takeRetrievedObject()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not a huge fan of the &quot;take&quot; here,<br>&gt;&gt; <br>&gt;&gt; Then why did you use it, if you don&#39;t mind my asking?  What is it supposed to mean in this context?<br>&gt; <br>&gt; I suppose I&#39;m struggling with the fact that there&#39;s clearly an action taking place here (at least in the created case), and yet merely saying `createdObject()` or `retrievedObject()` doesn&#39;t imply that. Those operations sound idempotent, but they&#39;re not.<br></p><p>But you applied &quot;take&quot; to both of them?  One of them is idempotent while the other is not.<br></p><p>&gt; (I kind of want to suggest that retrieving an object through these calls should destroy the reference so it can&#39;t be used again, but I don&#39;t think that fits with Swift&#39;s mutation model without turning `Unmanaged`/`UnsafeReference` into a reference type and adding lots of overhead.)<br></p><p>Yes, there&#39;s no way to reconcile that with the safety offered by the recommended usage patterns, since you can&#39;t mutate an rvalue.<br></p><p>&gt;&gt;&gt; but I think this general strategy of trying to say whether the Create Rule or the Get Rule applies is better than trying to make people understand when they should use &quot;released&quot; or not.<br>&gt;&gt; <br>&gt;&gt; Why is that better?<br>&gt; <br>&gt; Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit ambiguous to me.Are you saying it *has been* released, or are you saying it *needs to be* released?<br></p><p>But nobody proposed &quot;released&quot; as a method name.  In what way is &quot;release&quot; ambiguous?  It&#39;s an imperative verb.<br></p><p>&gt; I have the same problem with the current `takeRetainedValue()`/`takeUnretainedValue()` calls‚ÄîI&#39;m never sure which one I&#39;m supposed to use. I&#39;m hoping that, by stepping up a level and describing the semantic you want rather than the operation needed to achieve that semantic, this confusion can be cleared up.<br>&gt; <br>&gt; I also like that this creates a matched pair of methods. Because they look sort of like each other, it&#39;s easier to understand that you should call one or the other, and to remember them.<br></p><p>The similarity of those names seems to me like a weakness of the current Unmanaged design: to me they are so similar it&#39;s hard to understand which one to call.<br></p><p>&gt;&gt; And how does &quot;Retrieved&quot; map onto &quot;Get&quot;?<br>&gt; <br>&gt; Not all that cleanly, I admit. &quot;Gotten&quot; would be better, but &quot;get&quot; is an irregular verb and I&#39;m a little concerned about programmers who have English as a second language. (Plus, I subjectively think it&#39;s kind of ugly.)<br>&gt; <br>&gt; (One possibility would be to have a single call with an enum parameter, like `bridge(.Create)` and `bridge(.Get)`. This would let you use the regular form of the verb.)<br></p><p>There&#39;s no &quot;bridging&quot; going on here, though.  This is simply &quot;turn this unsafe thing into a safe thing in one of two ways&quot;<br></p><p>&gt; <br>&gt;&gt; Isn&#39;t it the users of the functions that don&#39;t contain &quot;Create&quot; or &quot;Get&quot; in their names that need the most help?<br>&gt; <br>&gt; I think of it more as &quot;treat this like a Create function&quot; or &quot;treat this like a Get function&quot;.<br></p><p>So far, my personal assessment of this direction is that it&#39;s no better than what I proposed, and has several weaknesses I&#39;d like to avoid.  In fact, it seems very similar to and roughly as understandable as the current Unmanaged design.  I recognize that this is a highly subjective judgement, so if others disagree with me, I&#39;d really like to hear about it.  This is a tough design space and ultimately, what resonates best with the community is likely to be the best choice.<br></p><p>Thanks again,<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/9fc9886d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 19, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit ambiguous to me.Are you saying it *has been* released, or are you saying it *needs to be* released?<br>&gt; <br>&gt; But nobody proposed &quot;released&quot; as a method name.  In what way is &quot;release&quot; ambiguous?  It&#39;s an imperative verb.<br></p><p>I guess you&#39;re right that &quot;release&quot; is unambiguous, but as you mentioned, it&#39;s also strange to release a value and then use it.<br></p><p>I think what I&#39;m trying to get at here is that I prefer to think of the operations on Unmanaged as &quot;explain to ARC how it should handle this object&quot;, rather than &quot;do some manual operations so that ARC will do the right thing&quot;. Maybe the current Unmanaged design has shown the limitations of that approach, though.<br></p><p>&gt; But you applied &quot;take&quot; to both of them?  One of them is idempotent while the other is not.<br></p><p>The preferred way to use Unmanaged is that you immediately convert it to a managed reference without ever storing it or using it in any other way. That means you should immediately call either the retain-and-return operation or the don&#39;t-retain-and-return operation. Both of these should only ever be called once. You may instead choose to keep the reference Unmanaged and manually retain, release, and access it, but best practices discourage that.<br></p><p>Now, one of the preferred, do-only-once operations *happens* to be safe to apply more than once, but I view that as an implementation detail. Both of them *happen* to be implemented in the same way as manual operations (`manuallyRelease()` and `object`), but I view that as an implementation detail, too.<br></p><p>Honestly, I might be happier splitting an UnsafeReference type out of Unmanaged and putting the manual retain/release stuff into that:<br></p><p>	// Unmanaged is a high-level type for moving object references in and out of ARC&#39;s control.<br>	struct Unmanaged&lt;T: class&gt; {<br>		func created() -&gt; T<br>		func gotten() -&gt; T<br>		<br>		// Also would have stuff for passing, which I haven&#39;t even thought about yet<br>	}<br>	<br>	// UnsafeReference is a low-level type for manually managing the retain count of an object.<br>	struct UnsafeReference&lt;T: class&gt; {<br>		init(_ object: T)<br>		init(_ unmanaged: Unmanaged&lt;T&gt;)<br>		<br>		var object: T<br>		<br>		// Some or all of these might return T<br>		func retain()<br>		func release()<br>		func autorelease()<br>	}<br></p><p>This puts the discouraged manual operations off in their own type where they&#39;ll be available to those who know about them, but not sitting right there on every unaudited call.<br></p><p>&gt;&gt; (I kind of want to suggest that retrieving an object through these calls should destroy the reference so it can&#39;t be used again, but I don&#39;t think that fits with Swift&#39;s mutation model without turning `Unmanaged`/`UnsafeReference` into a reference type and adding lots of overhead.)<br>&gt; <br>&gt; Yes, there&#39;s no way to reconcile that with the safety offered by the recommended usage patterns, since you can&#39;t mutate an rvalue.<br></p><p>I thought so. That&#39;s too bad. (I wonder if the compiler can emit warnings instead, though.)<br></p><p>&gt;&gt; (One possibility would be to have a single call with an enum parameter, like `bridge(.Create)` and `bridge(.Get)`. This would let you use the regular form of the verb.)<br>&gt; <br>&gt; There&#39;s no &quot;bridging&quot; going on here, though.  This is simply &quot;turn this unsafe thing into a safe thing in one of two ways&quot;<br></p><p>The &quot;bridge&quot; here comes from the Objective-C bridging casts, but I think there it&#39;s meant to refer to toll-free bridging, which is not what&#39;s happening in Swift.<br></p><p>If the type name remains `Unmanaged`, then perhaps `manage(_:)` would be better? (I don&#39;t like `managing` here because that again implies it&#39;s side-effect-free and safe to call more than once.)<br></p><p>&gt; So far, my personal assessment of this direction is that it&#39;s no better than what I proposed, and has several weaknesses I&#39;d like to avoid.  In fact, it seems very similar to and roughly as understandable as the current Unmanaged design.  I recognize that this is a highly subjective judgement, so if others disagree with me, I&#39;d really like to hear about it.  This is a tough design space and ultimately, what resonates best with the community is likely to be the best choice.<br></p><p>I understand. I&#39;m obviously struggling with this too, as you can see from how much I&#39;m changing my design based on your replies, rather than defending the design as suggested before.<br></p><p>Ultimately, Unmanaged is an API for handling an abstraction failure. That&#39;s inherently going to be tricky and subjective.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 4:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit ambiguous to me.Are you saying it *has been* released, or are you saying it *needs to be* released?<br>&gt;&gt; <br>&gt;&gt; But nobody proposed &quot;released&quot; as a method name.  In what way is &quot;release&quot; ambiguous?  It&#39;s an imperative verb.<br>&gt; <br>&gt; I guess you&#39;re right that &quot;release&quot; is unambiguous, but as you mentioned, it&#39;s also strange to release a value and then use it.<br></p><p>Yes.  I think there are no really great choices here (at least not so far) so the question is whether that strangeness is enough of a problem to outweigh the points release() has in its favor.  What do you think?<br></p><p>&gt; I think what I&#39;m trying to get at here is that I prefer to think of the operations on Unmanaged as &quot;explain to ARC how it should handle this object&quot;, rather than &quot;do some manual operations so that ARC will do the right thing&quot;. Maybe the current Unmanaged design has shown the limitations of that approach, though.<br></p><p>Not at all; the Unmanaged design‚Äîat least in my best understanding of its intent‚Äîis firmly in the imperative/manual operations camp.  I wanted to do something more declarative, but the &quot;I want to manage the reference that I claim was passed to me at +1&quot; operation is side-effectful. Are we really comfortable with hiding that fact?<br></p><p>&gt;&gt; But you applied &quot;take&quot; to both of them?  One of them is idempotent while the other is not.<br>&gt; <br>&gt; The preferred way to use Unmanaged is that you immediately convert it to a managed reference without ever storing it or using it in any other way. That means you should immediately call either the retain-and-return operation or the don&#39;t-retain-and-return operation. Both of these should only ever be called once. You may instead choose to keep the reference Unmanaged and manually retain, release, and access it, but best practices discourage that.<br></p><p>As I said in my original post, I&#39;m ambivalent about the importance of highlighting the distinctions of safety and idempotence between these methods, but even if they&#39;re named similarly I don&#39;t see any merit in starting with &quot;take.&quot;  One thing I really dislike about is that the receiver, the UnsafeReference, isn&#39;t &quot;taking&quot; anything.  The *caller* might be said to be taking something from the UnsafeReference, but only in the &quot;returned at +1&quot; case.  <br></p><p>How I see it: along with the UnsafeReference the called CF function either notionally<br>a) gives (possibly-shared) ownership of the object directly to the caller, or<br>b) gives the caller a token that allows him to get (shared) ownership of the object<br></p><p>In case a), the caller needs to ask the UnsafeReference to transfer (or &quot;release&quot;) that ownership into a strong reference, and.  In case b), the caller needs to explicitly get (shared) ownership.<br></p><p>If this description doesn&#39;t sound right to you, please try to correct it; that may help me understand your perspective better.<br></p><p>&gt; Now, one of the preferred, do-only-once operations *happens* to be safe to apply more than once, but I view that as an implementation detail. Both of them *happen* to be implemented in the same way as manual operations (`manuallyRelease()` and `object`), but I view that as an implementation detail, too.<br></p><p>Hm, well, I don&#39;t view `object` as a &quot;manual operation&quot; and there&#39;s value in having a smaller API surface area.  I don&#39;t think I want a separate `manuallyRelease` method if there is another method that has the same semantics.  One of the greatest weaknesses of the current Unmanaged is that its interface is too broad and hard to grasp.<br></p><p>&gt; Honestly, I might be happier splitting an UnsafeReference type out of Unmanaged and putting the manual retain/release stuff into that:<br></p><p>As noted in my original post, I really don&#39;t want to keep the name &quot;Unmanaged&quot; for anything.  If anything, it&#39;s &quot;ManuallyManaged.&quot;  And I am very wary of API surface area creep here, whether it&#39;s in one type or two.<br></p><p>&gt; 	// Unmanaged is a high-level type for moving object references in and out of ARC&#39;s control.<br>&gt; 	struct Unmanaged&lt;T: class&gt; {<br>&gt; 		func created() -&gt; T<br>&gt; 		func gotten() -&gt; T<br>&gt; 		<br>&gt; 		// Also would have stuff for passing, which I haven&#39;t even thought about yet<br>&gt; 	}<br>&gt; 	<br>&gt; 	// UnsafeReference is a low-level type for manually managing the retain count of an object.<br>&gt; 	struct UnsafeReference&lt;T: class&gt; {<br>&gt; 		init(_ object: T)<br>&gt; 		init(_ unmanaged: Unmanaged&lt;T&gt;)<br>&gt; 		<br>&gt; 		var object: T<br>&gt; 		<br>&gt; 		// Some or all of these might return T<br>&gt; 		func retain()<br>&gt; 		func release()<br>&gt; 		func autorelease()<br>&gt; 	}<br>&gt; <br>&gt; This puts the discouraged manual operations off in their own type where they&#39;ll be available to those who know about them, but not sitting right there on every unaudited call.<br>&gt; <br>&gt;&gt;&gt; (I kind of want to suggest that retrieving an object through these calls should destroy the reference so it can&#39;t be used again, but I don&#39;t think that fits with Swift&#39;s mutation model without turning `Unmanaged`/`UnsafeReference` into a reference type and adding lots of overhead.)<br>&gt;&gt; <br>&gt;&gt; Yes, there&#39;s no way to reconcile that with the safety offered by the recommended usage patterns, since you can&#39;t mutate an rvalue.<br>&gt; <br>&gt; I thought so. That&#39;s too bad. (I wonder if the compiler can emit warnings instead, though.)<br></p><p>I don&#39;t know what you have in mind here.<br></p><p>&gt; <br>&gt;&gt;&gt; (One possibility would be to have a single call with an enum parameter, like `bridge(.Create)` and `bridge(.Get)`. This would let you use the regular form of the verb.)<br>&gt;&gt; <br>&gt;&gt; There&#39;s no &quot;bridging&quot; going on here, though.  This is simply &quot;turn this unsafe thing into a safe thing in one of two ways&quot;<br>&gt; <br>&gt; The &quot;bridge&quot; here comes from the Objective-C bridging casts, but I think there it&#39;s meant to refer to toll-free bridging, which is not what&#39;s happening in Swift.<br>&gt; <br>&gt; If the type name remains `Unmanaged`, then perhaps `manage(_:)` would be better? (I don&#39;t like `managing` here because that again implies it&#39;s side-effect-free and safe to call more than once.)<br></p><p>Well again, we&#39;re not asking the receiver, the UnsafeReference, to manage anything.  And don&#39;t forget, we have two operations and need two names, especially if you want them to feel similar.<br></p><p>&gt;&gt; So far, my personal assessment of this direction is that it&#39;s no better than what I proposed, and has several weaknesses I&#39;d like to avoid.  In fact, it seems very similar to and roughly as understandable as the current Unmanaged design.  I recognize that this is a highly subjective judgement, so if others disagree with me, I&#39;d really like to hear about it.  This is a tough design space and ultimately, what resonates best with the community is likely to be the best choice.<br>&gt; <br>&gt; I understand. I&#39;m obviously struggling with this too, as you can see from how much I&#39;m changing my design based on your replies, rather than defending the design as suggested before.<br>&gt; <br>&gt; Ultimately, Unmanaged is an API for handling an abstraction failure. That&#39;s inherently going to be tricky and subjective.<br></p><p>Yup.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 19:43 , Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 19, 2015, at 4:22 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit ambiguous to me.Are you saying it *has been* released, or are you saying it *needs to be* released?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But nobody proposed &quot;released&quot; as a method name.  In what way is &quot;release&quot; ambiguous?  It&#39;s an imperative verb.<br>&gt;&gt; <br>&gt;&gt; I guess you&#39;re right that &quot;release&quot; is unambiguous, but as you mentioned, it&#39;s also strange to release a value and then use it.<br>&gt; <br>&gt; Yes.  I think there are no really great choices here (at least not so far) so the question is whether that strangeness is enough of a problem to outweigh the points release() has in its favor.  What do you think?<br>&gt; <br>&gt;&gt; I think what I&#39;m trying to get at here is that I prefer to think of the operations on Unmanaged as &quot;explain to ARC how it should handle this object&quot;, rather than &quot;do some manual operations so that ARC will do the right thing&quot;. Maybe the current Unmanaged design has shown the limitations of that approach, though.<br>&gt; <br>&gt; Not at all; the Unmanaged design‚Äîat least in my best understanding of its intent‚Äîis firmly in the imperative/manual operations camp.  I wanted to do something more declarative, but the &quot;I want to manage the reference that I claim was passed to me at +1&quot; operation is side-effectful. Are we really comfortable with hiding that fact?<br>&gt; <br>&gt;&gt;&gt; But you applied &quot;take&quot; to both of them?  One of them is idempotent while the other is not.<br>&gt;&gt; <br>&gt;&gt; The preferred way to use Unmanaged is that you immediately convert it to a managed reference without ever storing it or using it in any other way. That means you should immediately call either the retain-and-return operation or the don&#39;t-retain-and-return operation. Both of these should only ever be called once. You may instead choose to keep the reference Unmanaged and manually retain, release, and access it, but best practices discourage that.<br>&gt; <br>&gt; As I said in my original post, I&#39;m ambivalent about the importance of highlighting the distinctions of safety and idempotence between these methods, but even if they&#39;re named similarly I don&#39;t see any merit in starting with &quot;take.&quot;  One thing I really dislike about is that the receiver, the UnsafeReference, isn&#39;t &quot;taking&quot; anything.  The *caller* might be said to be taking something from the UnsafeReference, but only in the &quot;returned at +1&quot; case.  <br>&gt; <br>&gt; How I see it: along with the UnsafeReference the called CF function either notionally<br>&gt; a) gives (possibly-shared) ownership of the object directly to the caller, or<br>&gt; b) gives the caller a token that allows him to get (shared) ownership of the object<br>&gt; <br>&gt; In case a), the caller needs to ask the UnsafeReference to transfer (or &quot;release&quot;) that ownership into a strong reference, and.  In case b), the caller needs to explicitly get (shared) ownership.<br>&gt; <br>&gt; If this description doesn&#39;t sound right to you, please try to correct it; that may help me understand your perspective better.<br></p><p>For the record, I have previously talked with Dave about this in person. The conclusion I came to was that &quot;[foo release]&quot; and &quot;CFRelease(foo)&quot; are saying &quot;I release [my hold on] &#39;foo&#39;&quot;, but std::unique_ptr::release &lt;http://en.cppreference.com/w/cpp/memory/unique_ptr/release&gt; is saying &quot;please release your referent to me&quot;. The directionality being different is what created so much cognitive dissonance for me.<br></p><p>I&#39;m still one of those who really doesn&#39;t like plain &#39;release&#39; as a name. Putting &quot;release&quot; in the name is fine (to Greg&#39;s point about CFBridgingRelease), but &#39;release&#39; on its own has way too much baggage for me. (To the point where I have to double-check mentally that it&#39;s what I really want when I&#39;m working with std::unique_ptr.) Maybe that&#39;s historical, though‚Äîa pure Swift programmer has never called CFRelease.<br></p><p>To Brent&#39;s point about putting &quot;Create&quot; somewhere in there: the other use of Unmanaged is &quot;safely&quot; getting managed references through &#39;void *&#39; &quot;context pointers&quot;. In this case you&#39;re balancing a retain you performed. (That said, I&#39;m also against the general pattern of passing references through context pointers, because it&#39;s very hard to ensure that they get cleaned up, if retained, or kept alive, if unretained.)<br></p><p>Oh, and there&#39;s one last use of Unmanaged: fields of structs. These are rare but they do exist.<br></p><p>Jordan<br></p><p>P.S. There is, in fact, a CFBridgingRetain, for going from ObjC ARC to CF manual ref-counting. I&#39;m not sure why Greg didn&#39;t mention it.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/be17a707/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi Dave,<br>Thanks for sharing the proposal. I finally had a chance to catch up with<br>the discussion.<br></p><p>Generally I like the proposal and it would serve my needs well.<br></p><p>I share others&#39; concern that completely manual retain/release calls should<br>still be allowed in some way. This doesn&#39;t have to be via UnsafeReference,<br>but I don&#39;t think it makes sense to replace Unmanaged with UnsafeReference<br>as proposed without some solution to this.<br></p><p>Regarding naming:<br></p><p>&gt; problems with Unmanaged that we wanted to fix:<br>&gt; It was poorly-named (the reference is managed by somebody, we just aren&#39;t<br>representing that management in the type system).<br></p><p>I don&#39;t really agree with this. The management isn&#39;t &quot;not represented&quot; ‚Äî<br>the Unmanaged type explicitly says, at least to me, &quot;this particular<br>reference to the object does not manage its lifetime&quot;. So I don&#39;t think<br>UnsafeReference is particularly an improvement here, though I&#39;m not against<br>it.<br></p><p>- The release() name makes sense to me; it behaves like<br>removeFirst/removeAtIndex. I&#39;d also suggest something like<br>consumeReference(). And for manual retains, if that&#39;s in scope for this<br>API, you could use addReference().<br></p><p>Regarding COpaquePointer:<br></p><p>- Just to clarify, it looks like the proposed API would produce usage<br>patterns like:<br></p><p>    someCFunction(context: COpaquePointer(UnsafeReference(retaining: self)))<br></p><p>    func myCallback(context: COpaquePointer) {<br>        let object = UnsafeReference&lt;Foo&gt;(bitPattern: context).object<br>    }<br></p><p>    func myCleanup(context: COpaquePointer) {<br>        UnsafeReference&lt;Foo&gt;(bitPattern: context).release()<br>    }<br></p><p>- I&#39;m curious why you chose a COpaquePointer initializer, rather than<br>toOpaque() as the current Unmanaged API provides? On my<br>UnsafePointer+Unmanaged proposal, you commented<br>&lt;https://github.com/apple/swift-evolution/pull/44#issuecomment-165902471&gt;<br>&quot;we can‚Äôt give just UnsafePointer&lt;Void&gt; an init taking an UnsafeReference&quot;.<br>But (a) it sounds like this is an eventual goal (I started working on it<br>but it&#39;s a bit over my head currently); (b) using toOpaque() instead solves<br>this problem:<br></p><p>    func toOpaque() -&gt; UnsafePointer&lt;Void&gt; {<br>        return unsafeBitCast(_storage, UnsafePointer&lt;Void&gt;.self)<br>    }<br>    ...<br>    someCFunction(context: UnsafeReference(retaining: self).toOpaque())<br></p><p>My motivation here is mostly that C void* APIs are currently bridged as<br>UnsafePointer&lt;Void&gt;, so APIs that produce COpaquePointer are an obstacle to<br>using them. If the trend is away from UnsafePointer and toward better<br>&quot;Opaque&quot; semantics, that&#39;s fine with me; I&#39;d just like the API to be easy<br>to use in the meantime.<br></p><p>In the same comment you also said &quot;pointers to Void and incomplete types<br>are not in any sense ‚Äúunsafe‚Äù (once you restrict the interface as<br>appropriate for incomplete types), and so maybe we want OpaquePointer&lt;T&gt;<br>for these&quot;. It seems to me, though, that anything which can operate on<br>arbitrary memory addresses is indeed Unsafe.<br></p><p>Regarding documentation comments:<br></p><p>- It might be worth mentioning that init(retaining:) and<br>init(withoutRetaining:) are most likely to be used before conversion to an<br>opaque pointer, rather than immediately calling .object or .release() which<br>wouldn&#39;t be a very useful pattern.<br></p><p>- A weakness I see is that CF/other C APIs won&#39;t have comments saying which<br>&quot;state&quot; the returned UnsafeReference is in. The UnsafeReference doc<br>comments are very clear about which operations may be used when, but the<br>user is forced to mentally translate &quot;‚Ä¶responsible for releasing‚Ä¶&quot; into<br>&quot;this reference is in the *retained* state&quot; ‚Äî a possible source of<br>confusion, unless all the CF doc comments can be reworded when they&#39;re<br>imported into Swift to be more explicit.<br></p><p>- Very minor: your doc comment on &quot;public var object&quot; has a stray/double `.<br>Similarly, the top-level comment has a stray/double &quot;.<br></p><p>Jacob Bandes-Storch<br></p><p>On Sat, Dec 19, 2015 at 7:43 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 19, 2015, at 4:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit<br>&gt; ambiguous to me.Are you saying it *has been* released, or are you saying it<br>&gt; *needs to be* released?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; But nobody proposed &quot;released&quot; as a method name.  In what way is<br>&gt; &quot;release&quot; ambiguous?  It&#39;s an imperative verb.<br>&gt; &gt;<br>&gt; &gt; I guess you&#39;re right that &quot;release&quot; is unambiguous, but as you<br>&gt; mentioned, it&#39;s also strange to release a value and then use it.<br>&gt;<br>&gt; Yes.  I think there are no really great choices here (at least not so far)<br>&gt; so the question is whether that strangeness is enough of a problem to<br>&gt; outweigh the points release() has in its favor.  What do you think?<br>&gt;<br>&gt; &gt; I think what I&#39;m trying to get at here is that I prefer to think of the<br>&gt; operations on Unmanaged as &quot;explain to ARC how it should handle this<br>&gt; object&quot;, rather than &quot;do some manual operations so that ARC will do the<br>&gt; right thing&quot;. Maybe the current Unmanaged design has shown the limitations<br>&gt; of that approach, though.<br>&gt;<br>&gt; Not at all; the Unmanaged design‚Äîat least in my best understanding of its<br>&gt; intent‚Äîis firmly in the imperative/manual operations camp.  I wanted to do<br>&gt; something more declarative, but the &quot;I want to manage the reference that I<br>&gt; claim was passed to me at +1&quot; operation is side-effectful. Are we really<br>&gt; comfortable with hiding that fact?<br>&gt;<br>&gt; &gt;&gt; But you applied &quot;take&quot; to both of them?  One of them is idempotent<br>&gt; while the other is not.<br>&gt; &gt;<br>&gt; &gt; The preferred way to use Unmanaged is that you immediately convert it to<br>&gt; a managed reference without ever storing it or using it in any other way.<br>&gt; That means you should immediately call either the retain-and-return<br>&gt; operation or the don&#39;t-retain-and-return operation. Both of these should<br>&gt; only ever be called once. You may instead choose to keep the reference<br>&gt; Unmanaged and manually retain, release, and access it, but best practices<br>&gt; discourage that.<br>&gt;<br>&gt; As I said in my original post, I&#39;m ambivalent about the importance of<br>&gt; highlighting the distinctions of safety and idempotence between these<br>&gt; methods, but even if they&#39;re named similarly I don&#39;t see any merit in<br>&gt; starting with &quot;take.&quot;  One thing I really dislike about is that the<br>&gt; receiver, the UnsafeReference, isn&#39;t &quot;taking&quot; anything.  The *caller* might<br>&gt; be said to be taking something from the UnsafeReference, but only in the<br>&gt; &quot;returned at +1&quot; case.<br>&gt;<br>&gt; How I see it: along with the UnsafeReference the called CF function either<br>&gt; notionally<br>&gt; a) gives (possibly-shared) ownership of the object directly to the caller,<br>&gt; or<br>&gt; b) gives the caller a token that allows him to get (shared) ownership of<br>&gt; the object<br>&gt;<br>&gt; In case a), the caller needs to ask the UnsafeReference to transfer (or<br>&gt; &quot;release&quot;) that ownership into a strong reference, and.  In case b), the<br>&gt; caller needs to explicitly get (shared) ownership.<br>&gt;<br>&gt; If this description doesn&#39;t sound right to you, please try to correct it;<br>&gt; that may help me understand your perspective better.<br>&gt;<br>&gt; &gt; Now, one of the preferred, do-only-once operations *happens* to be safe<br>&gt; to apply more than once, but I view that as an implementation detail. Both<br>&gt; of them *happen* to be implemented in the same way as manual operations<br>&gt; (`manuallyRelease()` and `object`), but I view that as an implementation<br>&gt; detail, too.<br>&gt;<br>&gt; Hm, well, I don&#39;t view `object` as a &quot;manual operation&quot; and there&#39;s value<br>&gt; in having a smaller API surface area.  I don&#39;t think I want a separate<br>&gt; `manuallyRelease` method if there is another method that has the same<br>&gt; semantics.  One of the greatest weaknesses of the current Unmanaged is that<br>&gt; its interface is too broad and hard to grasp.<br>&gt;<br>&gt; &gt; Honestly, I might be happier splitting an UnsafeReference type out of<br>&gt; Unmanaged and putting the manual retain/release stuff into that:<br>&gt;<br>&gt; As noted in my original post, I really don&#39;t want to keep the name<br>&gt; &quot;Unmanaged&quot; for anything.  If anything, it&#39;s &quot;ManuallyManaged.&quot;  And I am<br>&gt; very wary of API surface area creep here, whether it&#39;s in one type or two.<br>&gt;<br>&gt; &gt;       // Unmanaged is a high-level type for moving object references in<br>&gt; and out of ARC&#39;s control.<br>&gt; &gt;       struct Unmanaged&lt;T: class&gt; {<br>&gt; &gt;               func created() -&gt; T<br>&gt; &gt;               func gotten() -&gt; T<br>&gt; &gt;<br>&gt; &gt;               // Also would have stuff for passing, which I haven&#39;t even<br>&gt; thought about yet<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       // UnsafeReference is a low-level type for manually managing the<br>&gt; retain count of an object.<br>&gt; &gt;       struct UnsafeReference&lt;T: class&gt; {<br>&gt; &gt;               init(_ object: T)<br>&gt; &gt;               init(_ unmanaged: Unmanaged&lt;T&gt;)<br>&gt; &gt;<br>&gt; &gt;               var object: T<br>&gt; &gt;<br>&gt; &gt;               // Some or all of these might return T<br>&gt; &gt;               func retain()<br>&gt; &gt;               func release()<br>&gt; &gt;               func autorelease()<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; This puts the discouraged manual operations off in their own type where<br>&gt; they&#39;ll be available to those who know about them, but not sitting right<br>&gt; there on every unaudited call.<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; (I kind of want to suggest that retrieving an object through these<br>&gt; calls should destroy the reference so it can&#39;t be used again, but I don&#39;t<br>&gt; think that fits with Swift&#39;s mutation model without turning<br>&gt; `Unmanaged`/`UnsafeReference` into a reference type and adding lots of<br>&gt; overhead.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, there&#39;s no way to reconcile that with the safety offered by the<br>&gt; recommended usage patterns, since you can&#39;t mutate an rvalue.<br>&gt; &gt;<br>&gt; &gt; I thought so. That&#39;s too bad. (I wonder if the compiler can emit<br>&gt; warnings instead, though.)<br>&gt;<br>&gt; I don&#39;t know what you have in mind here.<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; (One possibility would be to have a single call with an enum<br>&gt; parameter, like `bridge(.Create)` and `bridge(.Get)`. This would let you<br>&gt; use the regular form of the verb.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There&#39;s no &quot;bridging&quot; going on here, though.  This is simply &quot;turn this<br>&gt; unsafe thing into a safe thing in one of two ways&quot;<br>&gt; &gt;<br>&gt; &gt; The &quot;bridge&quot; here comes from the Objective-C bridging casts, but I think<br>&gt; there it&#39;s meant to refer to toll-free bridging, which is not what&#39;s<br>&gt; happening in Swift.<br>&gt; &gt;<br>&gt; &gt; If the type name remains `Unmanaged`, then perhaps `manage(_:)` would be<br>&gt; better? (I don&#39;t like `managing` here because that again implies it&#39;s<br>&gt; side-effect-free and safe to call more than once.)<br>&gt;<br>&gt; Well again, we&#39;re not asking the receiver, the UnsafeReference, to manage<br>&gt; anything.  And don&#39;t forget, we have two operations and need two names,<br>&gt; especially if you want them to feel similar.<br>&gt;<br>&gt; &gt;&gt; So far, my personal assessment of this direction is that it&#39;s no better<br>&gt; than what I proposed, and has several weaknesses I&#39;d like to avoid.  In<br>&gt; fact, it seems very similar to and roughly as understandable as the current<br>&gt; Unmanaged design.  I recognize that this is a highly subjective judgement,<br>&gt; so if others disagree with me, I&#39;d really like to hear about it.  This is a<br>&gt; tough design space and ultimately, what resonates best with the community<br>&gt; is likely to be the best choice.<br>&gt; &gt;<br>&gt; &gt; I understand. I&#39;m obviously struggling with this too, as you can see<br>&gt; from how much I&#39;m changing my design based on your replies, rather than<br>&gt; defending the design as suggested before.<br>&gt; &gt;<br>&gt; &gt; Ultimately, Unmanaged is an API for handling an abstraction failure.<br>&gt; That&#39;s inherently going to be tricky and subjective.<br>&gt;<br>&gt; Yup.<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/a2b7b376/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>December 20, 2015 at 12:00:00am</p></header><div class="content"><p>Floating an idea here‚Äînot sure if it‚Äôs even in the right ballpark, and I‚Äôm<br>certainly not tied to the specific wording, but what about something along<br>the lines of:<br></p><p>.transferByReleasing()<br>.transferWithoutReleasing()      // or perhaps just .transfer()<br></p><p>Or the slightly-more-verbose:<br></p><p>.transferObjectByReleasingReference()<br>.transferObjectWithoutReleasingReference()        // or .transferObject()<br></p><p>Nevin<br></p><p><br>On Sat, Dec 19, 2015 at 11:37 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Dave,<br>&gt; Thanks for sharing the proposal. I finally had a chance to catch up with<br>&gt; the discussion.<br>&gt;<br>&gt; Generally I like the proposal and it would serve my needs well.<br>&gt;<br>&gt; I share others&#39; concern that completely manual retain/release calls should<br>&gt; still be allowed in some way. This doesn&#39;t have to be via UnsafeReference,<br>&gt; but I don&#39;t think it makes sense to replace Unmanaged with UnsafeReference<br>&gt; as proposed without some solution to this.<br>&gt;<br>&gt; Regarding naming:<br>&gt;<br>&gt; &gt; problems with Unmanaged that we wanted to fix:<br>&gt; &gt; It was poorly-named (the reference is managed by somebody, we just<br>&gt; aren&#39;t representing that management in the type system).<br>&gt;<br>&gt; I don&#39;t really agree with this. The management isn&#39;t &quot;not represented&quot; ‚Äî<br>&gt; the Unmanaged type explicitly says, at least to me, &quot;this particular<br>&gt; reference to the object does not manage its lifetime&quot;. So I don&#39;t think<br>&gt; UnsafeReference is particularly an improvement here, though I&#39;m not against<br>&gt; it.<br>&gt;<br>&gt; - The release() name makes sense to me; it behaves like<br>&gt; removeFirst/removeAtIndex. I&#39;d also suggest something like<br>&gt; consumeReference(). And for manual retains, if that&#39;s in scope for this<br>&gt; API, you could use addReference().<br>&gt;<br>&gt; Regarding COpaquePointer:<br>&gt;<br>&gt; - Just to clarify, it looks like the proposed API would produce usage<br>&gt; patterns like:<br>&gt;<br>&gt;     someCFunction(context: COpaquePointer(UnsafeReference(retaining:<br>&gt; self)))<br>&gt;<br>&gt;     func myCallback(context: COpaquePointer) {<br>&gt;         let object = UnsafeReference&lt;Foo&gt;(bitPattern: context).object<br>&gt;     }<br>&gt;<br>&gt;     func myCleanup(context: COpaquePointer) {<br>&gt;         UnsafeReference&lt;Foo&gt;(bitPattern: context).release()<br>&gt;     }<br>&gt;<br>&gt; - I&#39;m curious why you chose a COpaquePointer initializer, rather than<br>&gt; toOpaque() as the current Unmanaged API provides? On my<br>&gt; UnsafePointer+Unmanaged proposal, you commented<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/44#issuecomment-165902471&gt;<br>&gt; &quot;we can‚Äôt give just UnsafePointer&lt;Void&gt; an init taking an UnsafeReference&quot;.<br>&gt; But (a) it sounds like this is an eventual goal (I started working on it<br>&gt; but it&#39;s a bit over my head currently); (b) using toOpaque() instead solves<br>&gt; this problem:<br>&gt;<br>&gt;     func toOpaque() -&gt; UnsafePointer&lt;Void&gt; {<br>&gt;         return unsafeBitCast(_storage, UnsafePointer&lt;Void&gt;.self)<br>&gt;     }<br>&gt;     ...<br>&gt;     someCFunction(context: UnsafeReference(retaining: self).toOpaque())<br>&gt;<br>&gt; My motivation here is mostly that C void* APIs are currently bridged as<br>&gt; UnsafePointer&lt;Void&gt;, so APIs that produce COpaquePointer are an obstacle to<br>&gt; using them. If the trend is away from UnsafePointer and toward better<br>&gt; &quot;Opaque&quot; semantics, that&#39;s fine with me; I&#39;d just like the API to be easy<br>&gt; to use in the meantime.<br>&gt;<br>&gt; In the same comment you also said &quot;pointers to Void and incomplete types<br>&gt; are not in any sense ‚Äúunsafe‚Äù (once you restrict the interface as<br>&gt; appropriate for incomplete types), and so maybe we want OpaquePointer&lt;T&gt;<br>&gt; for these&quot;. It seems to me, though, that anything which can operate on<br>&gt; arbitrary memory addresses is indeed Unsafe.<br>&gt;<br>&gt; Regarding documentation comments:<br>&gt;<br>&gt; - It might be worth mentioning that init(retaining:) and<br>&gt; init(withoutRetaining:) are most likely to be used before conversion to an<br>&gt; opaque pointer, rather than immediately calling .object or .release() which<br>&gt; wouldn&#39;t be a very useful pattern.<br>&gt;<br>&gt; - A weakness I see is that CF/other C APIs won&#39;t have comments saying<br>&gt; which &quot;state&quot; the returned UnsafeReference is in. The UnsafeReference doc<br>&gt; comments are very clear about which operations may be used when, but the<br>&gt; user is forced to mentally translate &quot;‚Ä¶responsible for releasing‚Ä¶&quot; into<br>&gt; &quot;this reference is in the *retained* state&quot; ‚Äî a possible source of<br>&gt; confusion, unless all the CF doc comments can be reworded when they&#39;re<br>&gt; imported into Swift to be more explicit.<br>&gt;<br>&gt; - Very minor: your doc comment on &quot;public var object&quot; has a stray/double<br>&gt; `. Similarly, the top-level comment has a stray/double &quot;.<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>&gt; On Sat, Dec 19, 2015 at 7:43 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 19, 2015, at 4:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit<br>&gt;&gt; ambiguous to me.Are you saying it *has been* released, or are you saying it<br>&gt;&gt; *needs to be* released?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; But nobody proposed &quot;released&quot; as a method name.  In what way is<br>&gt;&gt; &quot;release&quot; ambiguous?  It&#39;s an imperative verb.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I guess you&#39;re right that &quot;release&quot; is unambiguous, but as you<br>&gt;&gt; mentioned, it&#39;s also strange to release a value and then use it.<br>&gt;&gt;<br>&gt;&gt; Yes.  I think there are no really great choices here (at least not so<br>&gt;&gt; far) so the question is whether that strangeness is enough of a problem to<br>&gt;&gt; outweigh the points release() has in its favor.  What do you think?<br>&gt;&gt;<br>&gt;&gt; &gt; I think what I&#39;m trying to get at here is that I prefer to think of the<br>&gt;&gt; operations on Unmanaged as &quot;explain to ARC how it should handle this<br>&gt;&gt; object&quot;, rather than &quot;do some manual operations so that ARC will do the<br>&gt;&gt; right thing&quot;. Maybe the current Unmanaged design has shown the limitations<br>&gt;&gt; of that approach, though.<br>&gt;&gt;<br>&gt;&gt; Not at all; the Unmanaged design‚Äîat least in my best understanding of its<br>&gt;&gt; intent‚Äîis firmly in the imperative/manual operations camp.  I wanted to do<br>&gt;&gt; something more declarative, but the &quot;I want to manage the reference that I<br>&gt;&gt; claim was passed to me at +1&quot; operation is side-effectful. Are we really<br>&gt;&gt; comfortable with hiding that fact?<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; But you applied &quot;take&quot; to both of them?  One of them is idempotent<br>&gt;&gt; while the other is not.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The preferred way to use Unmanaged is that you immediately convert it<br>&gt;&gt; to a managed reference without ever storing it or using it in any other<br>&gt;&gt; way. That means you should immediately call either the retain-and-return<br>&gt;&gt; operation or the don&#39;t-retain-and-return operation. Both of these should<br>&gt;&gt; only ever be called once. You may instead choose to keep the reference<br>&gt;&gt; Unmanaged and manually retain, release, and access it, but best practices<br>&gt;&gt; discourage that.<br>&gt;&gt;<br>&gt;&gt; As I said in my original post, I&#39;m ambivalent about the importance of<br>&gt;&gt; highlighting the distinctions of safety and idempotence between these<br>&gt;&gt; methods, but even if they&#39;re named similarly I don&#39;t see any merit in<br>&gt;&gt; starting with &quot;take.&quot;  One thing I really dislike about is that the<br>&gt;&gt; receiver, the UnsafeReference, isn&#39;t &quot;taking&quot; anything.  The *caller* might<br>&gt;&gt; be said to be taking something from the UnsafeReference, but only in the<br>&gt;&gt; &quot;returned at +1&quot; case.<br>&gt;&gt;<br>&gt;&gt; How I see it: along with the UnsafeReference the called CF function<br>&gt;&gt; either notionally<br>&gt;&gt; a) gives (possibly-shared) ownership of the object directly to the<br>&gt;&gt; caller, or<br>&gt;&gt; b) gives the caller a token that allows him to get (shared) ownership of<br>&gt;&gt; the object<br>&gt;&gt;<br>&gt;&gt; In case a), the caller needs to ask the UnsafeReference to transfer (or<br>&gt;&gt; &quot;release&quot;) that ownership into a strong reference, and.  In case b), the<br>&gt;&gt; caller needs to explicitly get (shared) ownership.<br>&gt;&gt;<br>&gt;&gt; If this description doesn&#39;t sound right to you, please try to correct it;<br>&gt;&gt; that may help me understand your perspective better.<br>&gt;&gt;<br>&gt;&gt; &gt; Now, one of the preferred, do-only-once operations *happens* to be safe<br>&gt;&gt; to apply more than once, but I view that as an implementation detail. Both<br>&gt;&gt; of them *happen* to be implemented in the same way as manual operations<br>&gt;&gt; (`manuallyRelease()` and `object`), but I view that as an implementation<br>&gt;&gt; detail, too.<br>&gt;&gt;<br>&gt;&gt; Hm, well, I don&#39;t view `object` as a &quot;manual operation&quot; and there&#39;s value<br>&gt;&gt; in having a smaller API surface area.  I don&#39;t think I want a separate<br>&gt;&gt; `manuallyRelease` method if there is another method that has the same<br>&gt;&gt; semantics.  One of the greatest weaknesses of the current Unmanaged is that<br>&gt;&gt; its interface is too broad and hard to grasp.<br>&gt;&gt;<br>&gt;&gt; &gt; Honestly, I might be happier splitting an UnsafeReference type out of<br>&gt;&gt; Unmanaged and putting the manual retain/release stuff into that:<br>&gt;&gt;<br>&gt;&gt; As noted in my original post, I really don&#39;t want to keep the name<br>&gt;&gt; &quot;Unmanaged&quot; for anything.  If anything, it&#39;s &quot;ManuallyManaged.&quot;  And I am<br>&gt;&gt; very wary of API surface area creep here, whether it&#39;s in one type or two.<br>&gt;&gt;<br>&gt;&gt; &gt;       // Unmanaged is a high-level type for moving object references in<br>&gt;&gt; and out of ARC&#39;s control.<br>&gt;&gt; &gt;       struct Unmanaged&lt;T: class&gt; {<br>&gt;&gt; &gt;               func created() -&gt; T<br>&gt;&gt; &gt;               func gotten() -&gt; T<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;               // Also would have stuff for passing, which I haven&#39;t<br>&gt;&gt; even thought about yet<br>&gt;&gt; &gt;       }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       // UnsafeReference is a low-level type for manually managing the<br>&gt;&gt; retain count of an object.<br>&gt;&gt; &gt;       struct UnsafeReference&lt;T: class&gt; {<br>&gt;&gt; &gt;               init(_ object: T)<br>&gt;&gt; &gt;               init(_ unmanaged: Unmanaged&lt;T&gt;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;               var object: T<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;               // Some or all of these might return T<br>&gt;&gt; &gt;               func retain()<br>&gt;&gt; &gt;               func release()<br>&gt;&gt; &gt;               func autorelease()<br>&gt;&gt; &gt;       }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This puts the discouraged manual operations off in their own type where<br>&gt;&gt; they&#39;ll be available to those who know about them, but not sitting right<br>&gt;&gt; there on every unaudited call.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; (I kind of want to suggest that retrieving an object through these<br>&gt;&gt; calls should destroy the reference so it can&#39;t be used again, but I don&#39;t<br>&gt;&gt; think that fits with Swift&#39;s mutation model without turning<br>&gt;&gt; `Unmanaged`/`UnsafeReference` into a reference type and adding lots of<br>&gt;&gt; overhead.)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Yes, there&#39;s no way to reconcile that with the safety offered by the<br>&gt;&gt; recommended usage patterns, since you can&#39;t mutate an rvalue.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I thought so. That&#39;s too bad. (I wonder if the compiler can emit<br>&gt;&gt; warnings instead, though.)<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know what you have in mind here.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; (One possibility would be to have a single call with an enum<br>&gt;&gt; parameter, like `bridge(.Create)` and `bridge(.Get)`. This would let you<br>&gt;&gt; use the regular form of the verb.)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; There&#39;s no &quot;bridging&quot; going on here, though.  This is simply &quot;turn<br>&gt;&gt; this unsafe thing into a safe thing in one of two ways&quot;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The &quot;bridge&quot; here comes from the Objective-C bridging casts, but I<br>&gt;&gt; think there it&#39;s meant to refer to toll-free bridging, which is not what&#39;s<br>&gt;&gt; happening in Swift.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If the type name remains `Unmanaged`, then perhaps `manage(_:)` would<br>&gt;&gt; be better? (I don&#39;t like `managing` here because that again implies it&#39;s<br>&gt;&gt; side-effect-free and safe to call more than once.)<br>&gt;&gt;<br>&gt;&gt; Well again, we&#39;re not asking the receiver, the UnsafeReference, to manage<br>&gt;&gt; anything.  And don&#39;t forget, we have two operations and need two names,<br>&gt;&gt; especially if you want them to feel similar.<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; So far, my personal assessment of this direction is that it&#39;s no<br>&gt;&gt; better than what I proposed, and has several weaknesses I&#39;d like to avoid.<br>&gt;&gt; In fact, it seems very similar to and roughly as understandable as the<br>&gt;&gt; current Unmanaged design.  I recognize that this is a highly subjective<br>&gt;&gt; judgement, so if others disagree with me, I&#39;d really like to hear about<br>&gt;&gt; it.  This is a tough design space and ultimately, what resonates best with<br>&gt;&gt; the community is likely to be the best choice.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I understand. I&#39;m obviously struggling with this too, as you can see<br>&gt;&gt; from how much I&#39;m changing my design based on your replies, rather than<br>&gt;&gt; defending the design as suggested before.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Ultimately, Unmanaged is an API for handling an abstraction failure.<br>&gt;&gt; That&#39;s inherently going to be tricky and subjective.<br>&gt;&gt;<br>&gt;&gt; Yup.<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/bba662f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>F√©lix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 20, 2015 at 12:00:00am</p></header><div class="content"><p>There&#39;s still the &quot;release&quot; issue (std::unique_ptr::release versus -[NSObject release]), but &quot;transfer&quot; seems like a good word to me. What about &quot;transferByRetaining&quot; and &quot;transferWithoutRetaining&quot;?<br></p><p>F√©lix<br></p><p>&gt; Le 20 d√©c. 2015 √† 00:01:22, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt; <br>&gt; Floating an idea here‚Äînot sure if it‚Äôs even in the right ballpark, and I‚Äôm certainly not tied to the specific wording, but what about something along the lines of:<br>&gt; <br>&gt; .transferByReleasing()<br>&gt; .transferWithoutReleasing()      // or perhaps just .transfer()<br>&gt; <br>&gt; Or the slightly-more-verbose:<br>&gt; <br>&gt; .transferObjectByReleasingReference()<br>&gt; .transferObjectWithoutReleasingReference()        // or .transferObject()<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; On Sat, Dec 19, 2015 at 11:37 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi Dave,<br>&gt; Thanks for sharing the proposal. I finally had a chance to catch up with the discussion.<br>&gt; <br>&gt; Generally I like the proposal and it would serve my needs well.<br>&gt; <br>&gt; I share others&#39; concern that completely manual retain/release calls should still be allowed in some way. This doesn&#39;t have to be via UnsafeReference, but I don&#39;t think it makes sense to replace Unmanaged with UnsafeReference as proposed without some solution to this.<br>&gt; <br>&gt; Regarding naming:<br>&gt; <br>&gt; &gt; problems with Unmanaged that we wanted to fix:<br>&gt; &gt; It was poorly-named (the reference is managed by somebody, we just aren&#39;t representing that management in the type system).<br>&gt; <br>&gt; I don&#39;t really agree with this. The management isn&#39;t &quot;not represented&quot; ‚Äî the Unmanaged type explicitly says, at least to me, &quot;this particular reference to the object does not manage its lifetime&quot;. So I don&#39;t think UnsafeReference is particularly an improvement here, though I&#39;m not against it.<br>&gt;  <br>&gt; - The release() name makes sense to me; it behaves like removeFirst/removeAtIndex. I&#39;d also suggest something like consumeReference(). And for manual retains, if that&#39;s in scope for this API, you could use addReference().<br>&gt; <br>&gt; Regarding COpaquePointer:<br>&gt; <br>&gt; - Just to clarify, it looks like the proposed API would produce usage patterns like:<br>&gt; <br>&gt;     someCFunction(context: COpaquePointer(UnsafeReference(retaining: self)))<br>&gt; <br>&gt;     func myCallback(context: COpaquePointer) {<br>&gt;         let object = UnsafeReference&lt;Foo&gt;(bitPattern: context).object<br>&gt;     }<br>&gt; <br>&gt;     func myCleanup(context: COpaquePointer) {<br>&gt;         UnsafeReference&lt;Foo&gt;(bitPattern: context).release()<br>&gt;     }<br>&gt; <br>&gt; - I&#39;m curious why you chose a COpaquePointer initializer, rather than toOpaque() as the current Unmanaged API provides? On my UnsafePointer+Unmanaged proposal, you commented &lt;https://github.com/apple/swift-evolution/pull/44#issuecomment-165902471&gt; &quot;we can‚Äôt give just UnsafePointer&lt;Void&gt; an init taking an UnsafeReference&quot;. But (a) it sounds like this is an eventual goal (I started working on it but it&#39;s a bit over my head currently); (b) using toOpaque() instead solves this problem:<br>&gt; <br>&gt;     func toOpaque() -&gt; UnsafePointer&lt;Void&gt; {<br>&gt;         return unsafeBitCast(_storage, UnsafePointer&lt;Void&gt;.self)<br>&gt;     }<br>&gt;     ...<br>&gt;     someCFunction(context: UnsafeReference(retaining: self).toOpaque())<br>&gt; <br>&gt; My motivation here is mostly that C void* APIs are currently bridged as UnsafePointer&lt;Void&gt;, so APIs that produce COpaquePointer are an obstacle to using them. If the trend is away from UnsafePointer and toward better &quot;Opaque&quot; semantics, that&#39;s fine with me; I&#39;d just like the API to be easy to use in the meantime.<br>&gt; <br>&gt; In the same comment you also said &quot;pointers to Void and incomplete types are not in any sense ‚Äúunsafe‚Äù (once you restrict the interface as appropriate for incomplete types), and so maybe we want OpaquePointer&lt;T&gt; for these&quot;. It seems to me, though, that anything which can operate on arbitrary memory addresses is indeed Unsafe.<br>&gt; <br>&gt; Regarding documentation comments:<br>&gt; <br>&gt; - It might be worth mentioning that init(retaining:) and init(withoutRetaining:) are most likely to be used before conversion to an opaque pointer, rather than immediately calling .object or .release() which wouldn&#39;t be a very useful pattern.<br>&gt; <br>&gt; - A weakness I see is that CF/other C APIs won&#39;t have comments saying which &quot;state&quot; the returned UnsafeReference is in. The UnsafeReference doc comments are very clear about which operations may be used when, but the user is forced to mentally translate &quot;‚Ä¶responsible for releasing‚Ä¶&quot; into &quot;this reference is in the *retained* state&quot; ‚Äî a possible source of confusion, unless all the CF doc comments can be reworded when they&#39;re imported into Swift to be more explicit.<br>&gt; <br>&gt; - Very minor: your doc comment on &quot;public var object&quot; has a stray/double `. Similarly, the top-level comment has a stray/double &quot;.<br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt; On Sat, Dec 19, 2015 at 7:43 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Dec 19, 2015, at 4:22 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit ambiguous to me.Are you saying it *has been* released, or are you saying it *needs to be* released?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; But nobody proposed &quot;released&quot; as a method name.  In what way is &quot;release&quot; ambiguous?  It&#39;s an imperative verb.<br>&gt; &gt;<br>&gt; &gt; I guess you&#39;re right that &quot;release&quot; is unambiguous, but as you mentioned, it&#39;s also strange to release a value and then use it.<br>&gt; <br>&gt; Yes.  I think there are no really great choices here (at least not so far) so the question is whether that strangeness is enough of a problem to outweigh the points release() has in its favor.  What do you think?<br>&gt; <br>&gt; &gt; I think what I&#39;m trying to get at here is that I prefer to think of the operations on Unmanaged as &quot;explain to ARC how it should handle this object&quot;, rather than &quot;do some manual operations so that ARC will do the right thing&quot;. Maybe the current Unmanaged design has shown the limitations of that approach, though.<br>&gt; <br>&gt; Not at all; the Unmanaged design‚Äîat least in my best understanding of its intent‚Äîis firmly in the imperative/manual operations camp.  I wanted to do something more declarative, but the &quot;I want to manage the reference that I claim was passed to me at +1&quot; operation is side-effectful. Are we really comfortable with hiding that fact?<br>&gt; <br>&gt; &gt;&gt; But you applied &quot;take&quot; to both of them?  One of them is idempotent while the other is not.<br>&gt; &gt;<br>&gt; &gt; The preferred way to use Unmanaged is that you immediately convert it to a managed reference without ever storing it or using it in any other way. That means you should immediately call either the retain-and-return operation or the don&#39;t-retain-and-return operation. Both of these should only ever be called once. You may instead choose to keep the reference Unmanaged and manually retain, release, and access it, but best practices discourage that.<br>&gt; <br>&gt; As I said in my original post, I&#39;m ambivalent about the importance of highlighting the distinctions of safety and idempotence between these methods, but even if they&#39;re named similarly I don&#39;t see any merit in starting with &quot;take.&quot;  One thing I really dislike about is that the receiver, the UnsafeReference, isn&#39;t &quot;taking&quot; anything.  The *caller* might be said to be taking something from the UnsafeReference, but only in the &quot;returned at +1&quot; case.<br>&gt; <br>&gt; How I see it: along with the UnsafeReference the called CF function either notionally<br>&gt; a) gives (possibly-shared) ownership of the object directly to the caller, or<br>&gt; b) gives the caller a token that allows him to get (shared) ownership of the object<br>&gt; <br>&gt; In case a), the caller needs to ask the UnsafeReference to transfer (or &quot;release&quot;) that ownership into a strong reference, and.  In case b), the caller needs to explicitly get (shared) ownership.<br>&gt; <br>&gt; If this description doesn&#39;t sound right to you, please try to correct it; that may help me understand your perspective better.<br>&gt; <br>&gt; &gt; Now, one of the preferred, do-only-once operations *happens* to be safe to apply more than once, but I view that as an implementation detail. Both of them *happen* to be implemented in the same way as manual operations (`manuallyRelease()` and `object`), but I view that as an implementation detail, too.<br>&gt; <br>&gt; Hm, well, I don&#39;t view `object` as a &quot;manual operation&quot; and there&#39;s value in having a smaller API surface area.  I don&#39;t think I want a separate `manuallyRelease` method if there is another method that has the same semantics.  One of the greatest weaknesses of the current Unmanaged is that its interface is too broad and hard to grasp.<br>&gt; <br>&gt; &gt; Honestly, I might be happier splitting an UnsafeReference type out of Unmanaged and putting the manual retain/release stuff into that:<br>&gt; <br>&gt; As noted in my original post, I really don&#39;t want to keep the name &quot;Unmanaged&quot; for anything.  If anything, it&#39;s &quot;ManuallyManaged.&quot;  And I am very wary of API surface area creep here, whether it&#39;s in one type or two.<br>&gt; <br>&gt; &gt;       // Unmanaged is a high-level type for moving object references in and out of ARC&#39;s control.<br>&gt; &gt;       struct Unmanaged&lt;T: class&gt; {<br>&gt; &gt;               func created() -&gt; T<br>&gt; &gt;               func gotten() -&gt; T<br>&gt; &gt;<br>&gt; &gt;               // Also would have stuff for passing, which I haven&#39;t even thought about yet<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;       // UnsafeReference is a low-level type for manually managing the retain count of an object.<br>&gt; &gt;       struct UnsafeReference&lt;T: class&gt; {<br>&gt; &gt;               init(_ object: T)<br>&gt; &gt;               init(_ unmanaged: Unmanaged&lt;T&gt;)<br>&gt; &gt;<br>&gt; &gt;               var object: T<br>&gt; &gt;<br>&gt; &gt;               // Some or all of these might return T<br>&gt; &gt;               func retain()<br>&gt; &gt;               func release()<br>&gt; &gt;               func autorelease()<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; This puts the discouraged manual operations off in their own type where they&#39;ll be available to those who know about them, but not sitting right there on every unaudited call.<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; (I kind of want to suggest that retrieving an object through these calls should destroy the reference so it can&#39;t be used again, but I don&#39;t think that fits with Swift&#39;s mutation model without turning `Unmanaged`/`UnsafeReference` into a reference type and adding lots of overhead.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, there&#39;s no way to reconcile that with the safety offered by the recommended usage patterns, since you can&#39;t mutate an rvalue.<br>&gt; &gt;<br>&gt; &gt; I thought so. That&#39;s too bad. (I wonder if the compiler can emit warnings instead, though.)<br>&gt; <br>&gt; I don&#39;t know what you have in mind here.<br>&gt; <br>&gt; &gt;<br>&gt; &gt;&gt;&gt; (One possibility would be to have a single call with an enum parameter, like `bridge(.Create)` and `bridge(.Get)`. This would let you use the regular form of the verb.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There&#39;s no &quot;bridging&quot; going on here, though.  This is simply &quot;turn this unsafe thing into a safe thing in one of two ways&quot;<br>&gt; &gt;<br>&gt; &gt; The &quot;bridge&quot; here comes from the Objective-C bridging casts, but I think there it&#39;s meant to refer to toll-free bridging, which is not what&#39;s happening in Swift.<br>&gt; &gt;<br>&gt; &gt; If the type name remains `Unmanaged`, then perhaps `manage(_:)` would be better? (I don&#39;t like `managing` here because that again implies it&#39;s side-effect-free and safe to call more than once.)<br>&gt; <br>&gt; Well again, we&#39;re not asking the receiver, the UnsafeReference, to manage anything.  And don&#39;t forget, we have two operations and need two names, especially if you want them to feel similar.<br>&gt; <br>&gt; &gt;&gt; So far, my personal assessment of this direction is that it&#39;s no better than what I proposed, and has several weaknesses I&#39;d like to avoid.  In fact, it seems very similar to and roughly as understandable as the current Unmanaged design.  I recognize that this is a highly subjective judgement, so if others disagree with me, I&#39;d really like to hear about it.  This is a tough design space and ultimately, what resonates best with the community is likely to be the best choice.<br>&gt; &gt;<br>&gt; &gt; I understand. I&#39;m obviously struggling with this too, as you can see from how much I&#39;m changing my design based on your replies, rather than defending the design as suggested before.<br>&gt; &gt;<br>&gt; &gt; Ultimately, Unmanaged is an API for handling an abstraction failure. That&#39;s inherently going to be tricky and subjective.<br>&gt; <br>&gt; Yup.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/850ee2b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>December 29, 2015 at 10:00:00pm</p></header><div class="content"><p>I like &quot;transfer&quot; but I think this would be mostly helpful to people familiar with manual ref. counting in Obj-C.<br>It&#39;s probably just as confusing to others and the visual similarity could be confusing as well (like with `Unmanaged`).<br></p><p>But I also wouldn&#39;t be opposed to these if they were selected...<br></p><p><br>&gt; On 20 Dec 2015, at 06:56, F√©lix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There&#39;s still the &quot;release&quot; issue (std::unique_ptr::release versus -[NSObject release]), but &quot;transfer&quot; seems like a good word to me. What about &quot;transferByRetaining&quot; and &quot;transferWithoutRetaining&quot;?<br>&gt; <br>&gt; F√©lix<br>&gt; <br>&gt;&gt; Le 20 d√©c. 2015 √† 00:01:22, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt; <br>&gt;&gt; Floating an idea here‚Äînot sure if it‚Äôs even in the right ballpark, and I‚Äôm certainly not tied to the specific wording, but what about something along the lines of:<br>&gt;&gt; <br>&gt;&gt; .transferByReleasing()<br>&gt;&gt; .transferWithoutReleasing()      // or perhaps just .transfer()<br>&gt;&gt; <br>&gt;&gt; Or the slightly-more-verbose:<br>&gt;&gt; <br>&gt;&gt; .transferObjectByReleasingReference()<br>&gt;&gt; .transferObjectWithoutReleasingReference()        // or .transferObject()<br>&gt;&gt; <br>&gt;&gt; Nevin<br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/3023befa/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>December 19, 2015 at 09:00:00pm</p></header><div class="content"><p>&quot;takeAndRelease()&quot;? <br></p><p>It seems so weird to me to call &quot;release&quot; on something and then use it - but I admit that seems less likely to confuse those not familiar with MRC. The parallel with documentation is nice. <br></p><p>I do agree with Brent that I found the previous symmetry (takeRetained and takeUnretained) easy to remember - even if not easy to keep straight which was which. <br></p><p>&gt; On Dec 19, 2015, at 6:14 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 19, 2015, at 2:59 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; CFAttributedString has actually been audited, but pretend it hasn&#39;t been...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let attributedString = CFAttributedStringCreate(nil, anotherString,nil).takeCreatedObject()<br>&gt;&gt;&gt;&gt; 	let str = CFAttributedStringGetString(attributedString).takeRetrievedObject()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not a huge fan of the &quot;take&quot; here,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then why did you use it, if you don&#39;t mind my asking?  What is it supposed to mean in this context?<br>&gt;&gt; <br>&gt;&gt; I suppose I&#39;m struggling with the fact that there&#39;s clearly an action taking place here (at least in the created case), and yet merely saying `createdObject()` or `retrievedObject()` doesn&#39;t imply that. Those operations sound idempotent, but they&#39;re not.<br>&gt; <br>&gt; But you applied &quot;take&quot; to both of them?  One of them is idempotent while the other is not.<br>&gt; <br>&gt;&gt; (I kind of want to suggest that retrieving an object through these calls should destroy the reference so it can&#39;t be used again, but I don&#39;t think that fits with Swift&#39;s mutation model without turning `Unmanaged`/`UnsafeReference` into a reference type and adding lots of overhead.)<br>&gt; <br>&gt; Yes, there&#39;s no way to reconcile that with the safety offered by the recommended usage patterns, since you can&#39;t mutate an rvalue.<br>&gt; <br>&gt;&gt;&gt;&gt; but I think this general strategy of trying to say whether the Create Rule or the Get Rule applies is better than trying to make people understand when they should use &quot;released&quot; or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why is that better?<br>&gt;&gt; <br>&gt;&gt; Mainly, because simply saying &quot;release&quot; or &quot;released&quot; is a bit ambiguous to me.Are you saying it *has been* released, or are you saying it *needs to be* released?<br>&gt; <br>&gt; But nobody proposed &quot;released&quot; as a method name.  In what way is &quot;release&quot; ambiguous?  It&#39;s an imperative verb.<br>&gt; <br>&gt;&gt; I have the same problem with the current `takeRetainedValue()`/`takeUnretainedValue()` calls‚ÄîI&#39;m never sure which one I&#39;m supposed to use. I&#39;m hoping that, by stepping up a level and describing the semantic you want rather than the operation needed to achieve that semantic, this confusion can be cleared up.<br>&gt;&gt; <br>&gt;&gt; I also like that this creates a matched pair of methods. Because they look sort of like each other, it&#39;s easier to understand that you should call one or the other, and to remember them.<br>&gt; <br>&gt; The similarity of those names seems to me like a weakness of the current Unmanaged design: to me they are so similar it&#39;s hard to understand which one to call.<br>&gt; <br>&gt;&gt;&gt; And how does &quot;Retrieved&quot; map onto &quot;Get&quot;?<br>&gt;&gt; <br>&gt;&gt; Not all that cleanly, I admit. &quot;Gotten&quot; would be better, but &quot;get&quot; is an irregular verb and I&#39;m a little concerned about programmers who have English as a second language. (Plus, I subjectively think it&#39;s kind of ugly.)<br>&gt;&gt; <br>&gt;&gt; (One possibility would be to have a single call with an enum parameter, like `bridge(.Create)` and `bridge(.Get)`. This would let you use the regular form of the verb.)<br>&gt; <br>&gt; There&#39;s no &quot;bridging&quot; going on here, though.  This is simply &quot;turn this unsafe thing into a safe thing in one of two ways&quot;<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Isn&#39;t it the users of the functions that don&#39;t contain &quot;Create&quot; or &quot;Get&quot; in their names that need the most help?<br>&gt;&gt; <br>&gt;&gt; I think of it more as &quot;treat this like a Create function&quot; or &quot;treat this like a Get function&quot;.<br>&gt; <br>&gt; So far, my personal assessment of this direction is that it&#39;s no better than what I proposed, and has several weaknesses I&#39;d like to avoid.  In fact, it seems very similar to and roughly as understandable as the current Unmanaged design.  I recognize that this is a highly subjective judgement, so if others disagree with me, I&#39;d really like to hear about it.  This is a tough design space and ultimately, what resonates best with the community is likely to be the best choice.<br>&gt; <br>&gt; Thanks again,<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/899c680d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 6:23 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think I see what you mean about parity. `.object` can be called multiple times, then?<br></p><p>Indeed, as noted here &lt;https://github.com/dabrahams/swift/blob/UnsafeReference/stdlib/public/core/UnsafeReference.swift#L28&gt;. I said I was ‚Äúof two minds‚Äù about the importance of highlighting the lack of parity because in the recommended usage pattern, you invoke object or release() exactly once and can‚Äôt access the UnsafeReference thereafter.  The main reason to emphasize the difference is that some people really seem to resist the recommended usage pattern, and for them, it really matters.  The secondary difference is that our guidelines (still partly un-published) for what should be a property dictate that one has to be a method and the other a property; I need to try to get those updates out soon.<br></p><p>&gt; Why not make `release()` slightly more verbose since it should only be called once anyway? Something along the lines of `.releaseAndReturnObject` or ‚Ä¶ something slightly less verbose. <br></p><p>We could do that.  I find ‚ÄúObject‚Äù a pretty weak term here, since the original UnsafeReference represents the same ‚Äúobject‚Äù in some abstract sense.  It‚Äôs really something more like ‚ÄúOwnership‚Äù that‚Äôs being returned, but you could also argue that ownership was returned by the original call, too.  If we add words here I‚Äôd like to understand what value they‚Äôre adding in terms of comprehensibility.<br></p><p>&gt; My main point of contention with `.release()` is that it has the *exact* same name as a method from the MRC strategy. Maybe this is a silly point, but this overlap could further complicate teaching how ARC works and in what ways it is based on MRC conventions. <br></p><p>&gt; I am not of the opinion that ARC is fundamentally more difficult to understand than MRC, but I do believe that it takes a very particular kind of faith now that we don&#39;t get to manually write the retains and releases. This is completely worth it, in my opinion, but  I want to avoid making it *more* confusing to explain what ARC doing at compile time. <br></p><p>Well, unsafeRef.release() is equivalent to <br></p><p>  {<br>    let x = $0.object<br>    CFRelease($0) // if CFRelease() wasn&#39;t @unavailable<br>    return x<br>}(unsafeRef)<br></p><p>If you let the return value drop on the floor, it ends up being exactly equivalent to the method with the exact same name from the MRC strategy.  So the correspondence is strong and shouldn‚Äôt be a problem.  That‚Äôs just my opinion, though, and part of the reason we‚Äôre asking for feedback here is so people steeped in MRC like you can argue with me about that :-), so if you find this unconvincing please explain why.<br></p><p>Thanks again,<br>Dave<br></p><p>&gt; TJ<br>&gt; <br>&gt; On Thu, Dec 17, 2015 at 9:13 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt; Thanks very much for the quick feedback TJ, <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 5:52 PM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Dave,<br>&gt;&gt; <br>&gt;&gt; I like this change and think that it will help clarify the purpose of the type. As I was reading, the only concern that I had was the name. Could you please provide some of the names that you all have considered<br>&gt; <br>&gt; Honestly, I am sorry to say, we did that exercise almost a month ago and I don‚Äôt remember the ones we discussed.<br>&gt; <br>&gt;&gt; so that we can avoid suggesting the same things? My suggestion is <br>&gt;&gt; <br>&gt;&gt;     CFSomething(arguments‚Ä¶).retainedObject() // when the result is returned at +1<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt;     CFSomething(arguments‚Ä¶).unretainedObject()    // when the result is returned at +0<br>&gt;&gt; <br>&gt;&gt; on the premise that the important bit of information is whether or not the object is already retained. No matter what names are chosen, that is the data which determines which method to call. `retainedObject | unretainedObject`, `takeRetainedObject | takeUnretainedObject`, or  `retained | unretained` all seem like viable options (that you have probably considered).<br>&gt; <br>&gt; <br>&gt; Some issues with these names:<br>&gt; <br>&gt; The ‚Äúed/ing‚Äù rule &lt;https://swift.org/documentation/api-design-guidelines.html#be-grammatical&gt; makes these names suggest that the accessors are idempotent, but the first one must be called exactly once.  That name should really be an active verb since it is state-changing.<br>&gt; ‚ÄúretainedObject‚Äù also suggests that it‚Äôs returning some underlying object after retaining it, which is almost the opposite of what that API does‚Ä¶ and vice-versa for ‚ÄúunretainedObject&quot;<br>&gt; Also, the object ‚Äúhas been retained‚Äù in all cases, or it would have been deallocated.  The question is whether the object would leak if we fail to call release on it<br>&gt; Nothing in these names connect them to what the documentation says about the functions that return Unmanaged, so it‚Äôs hard to know which one to call<br>&gt; The second API is objectively safer than the first one (which causes undefined behavior when overused and only leaks when underused).  The API I proposed makes it clear that they are not peers, where yours implies parity‚Äîthough I am of two minds about the value of representing the lack of parity.<br>&gt; <br>&gt; You may legitimately argue that any of these concerns are unimportant, but those are the ones that come up for me.<br>&gt; <br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 17, 2015 at 8:37 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi Everybody,<br>&gt;&gt; <br>&gt;&gt; We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are soliciting comments.  First, a little background:<br>&gt;&gt; <br>&gt;&gt; Unmanaged &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is primarily used as a return type from imported CoreFoundation functions that haven‚Äôt been annotated with reference-counting semantic information<br>&gt;&gt; A secondary known use-case is as a vehicle for creating a COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me some info and I‚Äôll give it back to your callback‚Äù mechanism.<br>&gt;&gt; <br>&gt;&gt; We saw several problems with Unmanaged that we wanted to fix:<br>&gt;&gt; It was poorly-named (the reference is managed by somebody, we just aren&#39;t representing that management in the type system).<br>&gt;&gt; Its interface was much broader than it needs to be to cover the use-cases<br>&gt;&gt; The purpose of many of its APIs was unclear<br>&gt;&gt; Its documentation was vague and hard to understand.<br>&gt;&gt; It didn‚Äôt establish a maximally-safe usage pattern for handling the results of un-annotated CoreFoundation functions.<br>&gt;&gt; <br>&gt;&gt; The code for the proposed replacement, called UnsafeReference, is here &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;, and a commit that updates Swift to use it is here &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;. <br>&gt;&gt; <br>&gt;&gt; Maximally Safe Usage<br>&gt;&gt; <br>&gt;&gt; The recommended usage pattern for handling an UnsafeReference&lt;T&gt; returned by a function CFSomething is to always use the T instance produced by one of the forms:<br>&gt;&gt; <br>&gt;&gt;     CFSomething(arguments‚Ä¶).release() // when the result is returned at +1<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt;     CFSomething(arguments‚Ä¶).object    // when the result is returned at +0<br>&gt;&gt; <br>&gt;&gt; In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as possible, and never store the UnsafeReference&lt;T&gt; in a variable so that it can‚Äôt be (mis)used thereafter.<br>&gt;&gt; <br>&gt;&gt; Points of Discussion<br>&gt;&gt; <br>&gt;&gt; We‚Äôre interested in any feedback you might have, but there are a few points we‚Äôd especially like to address:<br>&gt;&gt; <br>&gt;&gt; The name of the release() method has been contentious.<br>&gt;&gt; üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally says something like ‚Äúyou are responsible for releasing the result‚Äù in those cases where release() must be called, so there‚Äôs a very direct way to know which variant of the recommended usage pattern to employ.<br>&gt;&gt; üëé: Some people who are very familiar with existing manual retain/release programming find the recommended usage pattern really counter-intuitive because they&#39;re ‚Äúusing something after calling release on it,‚Äù which one never does in Objective-C.<br>&gt;&gt; The alternative names we‚Äôve been able to think of so far are verbose, clumsy, and don‚Äôt match up with anything in the documentation of the called function, so this seems like a really hard naming problem.  Better ideas from the community would be most welcome here.<br>&gt;&gt; We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br>&gt;&gt; We want to know whether the usage pattern recommended above works for you.<br>&gt;&gt; We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br>&gt;&gt; <br>&gt;&gt; Thanks in advance,<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/0cc05715/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 5:37 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	‚Ä¢ The name of the release() method has been contentious.<br>&gt; 		‚Ä¢ üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule‚Äù‚Äînormally says something like ‚Äúyou are responsible for releasing the result‚Äù in those cases where release() must be called, so there‚Äôs a very direct way to know which variant of the recommended usage pattern to employ.<br>&gt; 		‚Ä¢ üëé: Some people who are very familiar with existing manual retain/release programming find the recommended usage pattern really counter-intuitive because they&#39;re ‚Äúusing something after calling release on it,‚Äù which one never does in Objective-C.<br>&gt; 		‚Ä¢ The alternative names we‚Äôve been able to think of so far are verbose, clumsy, and don‚Äôt match up with anything in the documentation of the called function, so this seems like a really hard naming problem.  Better ideas from the community would be most welcome here.<br></p><p>For inspiration, the Objective-C ARC analogues to UnsafeReference.release() are:<br>    safeReference = (__bridge_transfer id)unsafeReference;<br>    // foreign retain count is &quot;transferred&quot; to ARC&#39;s control<br></p><p>    safeReference = CFBridgingRelease(unsafeReference);<br>    // conceptually balances CFCreate‚Ä¶() or CFRetain() even though it may or may not perform a release.<br></p><p>The two operations behave identically. Most people find that one or the other matches their mental model better. (Personally I find CFBridgingRelease() to be perfectly natural and I can never remember which way the __bridge_* casts work.)<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 5:37 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Everybody,<br>&gt; <br>&gt; We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are soliciting comments.  First, a little background:<br>&gt; <br>&gt; Unmanaged &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is primarily used as a return type from imported CoreFoundation functions that haven‚Äôt been annotated with reference-counting semantic information<br>&gt; A secondary known use-case is as a vehicle for creating a COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me some info and I‚Äôll give it back to your callback‚Äù mechanism.<br>&gt; <br>&gt; We saw several problems with Unmanaged that we wanted to fix:<br>&gt; It was poorly-named (the reference is managed by somebody, we just aren&#39;t representing that management in the type system).<br>&gt; Its interface was much broader than it needs to be to cover the use-cases<br>&gt; The purpose of many of its APIs was unclear<br>&gt; Its documentation was vague and hard to understand.<br>&gt; It didn‚Äôt establish a maximally-safe usage pattern for handling the results of un-annotated CoreFoundation functions.<br>&gt; <br>&gt; The code for the proposed replacement, called UnsafeReference, is here &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;, and a commit that updates Swift to use it is here &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;. <br>&gt; <br>&gt; Maximally Safe Usage<br>&gt; <br>&gt; The recommended usage pattern for handling an UnsafeReference&lt;T&gt; returned by a function CFSomething is to always use the T instance produced by one of the forms:<br>&gt; <br>&gt;     CFSomething(arguments‚Ä¶).release() // when the result is returned at +1<br>&gt; <br>&gt; or<br>&gt; <br>&gt;     CFSomething(arguments‚Ä¶).object    // when the result is returned at +0<br>&gt; <br>&gt; In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as possible, and never store the UnsafeReference&lt;T&gt; in a variable so that it can‚Äôt be (mis)used thereafter.<br>&gt; <br>&gt; Points of Discussion<br>&gt; <br>&gt; We‚Äôre interested in any feedback you might have, but there are a few points we‚Äôd especially like to address:<br>&gt; <br>&gt; The name of the release() method has been contentious.<br>&gt; üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally says something like ‚Äúyou are responsible for releasing the result‚Äù in those cases where release() must be called, so there‚Äôs a very direct way to know which variant of the recommended usage pattern to employ.<br>&gt; üëé: Some people who are very familiar with existing manual retain/release programming find the recommended usage pattern really counter-intuitive because they&#39;re ‚Äúusing something after calling release on it,‚Äù which one never does in Objective-C.<br>&gt; The alternative names we‚Äôve been able to think of so far are verbose, clumsy, and don‚Äôt match up with anything in the documentation of the called function, so this seems like a really hard naming problem.  Better ideas from the community would be most welcome here.<br>&gt; We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br>&gt; We want to know whether the usage pattern recommended above works for you.<br>&gt; We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br></p><p>`UnsafeReference` is a great name, and the proposed API definitely feels cleaner for the CF use case. Just a couple comments:<br></p><p>- The `bitPattern:` constructors should be between UnsafeReference and Unsafe[Mutable]Pointer&lt;Void&gt;, not COpaquePointer. Let COpaquePointer retire gracefully.<br>- `Unmanaged` has also been promoted as a solution for people who need to do manual reference counting, for performance or other reasons, so I think we might want to keep the &#39;retain()&#39; method. Conveniently enough, `release()`-ing and dropping the return value would have the net effect of decrementing the refcount by one, though the admonitions about the `UnsafeReference` become invalid after that point wouldn&#39;t hold if you&#39;re using `release()` purely for that effect, so maybe `manuallyRetain()`/`manuallyRelease()` would be more appropriate for manual refcounting applications.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/a6a3994b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Rados≈Çaw Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>December 18, 2015 at 09:00:00pm</p></header><div class="content"><p>Regarding naming and clarity, my first impression is ‚Äúyes, this is far better‚Äù.<br></p><p>After 1.5 years of doing Swift, I‚Äôm _still_ confused by `takeRetainedValue()` and `takeUnretainedValue()`. Perhaps it‚Äôs because I‚Äôve been spared having to learn at a deep level how to do manual refcounting, and so I only occasionally have to interact with APIs that require this. Still, I always have to check the documentation, and re-read the descriptions of both carefully to make sure I‚Äôm not mixing up the two.<br></p><p>Although `release()` probably isn‚Äôt perfect for reasons mentioned before (a hard naming problem indeed), I somehow find it easier to conceptualize it in my brain than `takeRetainedValue()`.<br></p><p>And the asymmetry between `release()` and `value` definitely seems like a win to me ‚Äî it really emphasizes that `value` doesn‚Äôt really ‚Äúdo‚Äù anything, you‚Äôre just using the underlying value.<br></p><p>best,<br>‚Äî Radek<br></p><p>&gt; On 18 Dec 2015, at 02:37, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Everybody,<br>&gt; <br>&gt; We‚Äôve been working on a rewrite of the Unmanaged&lt;T&gt; component, and are soliciting comments.  First, a little background:<br>&gt; <br>&gt; Unmanaged &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID79&gt; is primarily used as a return type from imported CoreFoundation functions that haven‚Äôt been annotated with reference-counting semantic information<br>&gt; A secondary known use-case is as a vehicle for creating a COpaquePointer containing a reference‚Äôs bits, e.g. for when you need to pass a reference through C APIs that use ‚Äúvoid*‚Äù as a universal ‚Äúgive me some info and I‚Äôll give it back to your callback‚Äù mechanism.<br>&gt; <br>&gt; We saw several problems with Unmanaged that we wanted to fix:<br>&gt; It was poorly-named (the reference is managed by somebody, we just aren&#39;t representing that management in the type system).<br>&gt; Its interface was much broader than it needs to be to cover the use-cases<br>&gt; The purpose of many of its APIs was unclear<br>&gt; Its documentation was vague and hard to understand.<br>&gt; It didn‚Äôt establish a maximally-safe usage pattern for handling the results of un-annotated CoreFoundation functions.<br>&gt; <br>&gt; The code for the proposed replacement, called UnsafeReference, is here &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift&gt;, and a commit that updates Swift to use it is here &lt;https://github.com/dabrahams/swift/commit/6eb86b48d150342709da3f3be9c738df23382866&gt;. <br>&gt; <br>&gt; Maximally Safe Usage<br>&gt; <br>&gt; The recommended usage pattern for handling an UnsafeReference&lt;T&gt; returned by a function CFSomething is to always use the T instance produced by one of the forms:<br>&gt; <br>&gt;     CFSomething(arguments‚Ä¶).release() // when the result is returned at +1<br>&gt; <br>&gt; or<br>&gt; <br>&gt;     CFSomething(arguments‚Ä¶).object    // when the result is returned at +0<br>&gt; <br>&gt; In other words, turn the UnsafeReference&lt;T&gt; into a safe T as quickly as possible, and never store the UnsafeReference&lt;T&gt; in a variable so that it can‚Äôt be (mis)used thereafter.<br>&gt; <br>&gt; Points of Discussion<br>&gt; <br>&gt; We‚Äôre interested in any feedback you might have, but there are a few points we‚Äôd especially like to address:<br>&gt; <br>&gt; The name of the release() method has been contentious.<br>&gt; üëç: Documentation‚Äîor naming conventions such as the ‚Äúcreate rule &lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html&gt;‚Äù‚Äînormally says something like ‚Äúyou are responsible for releasing the result‚Äù in those cases where release() must be called, so there‚Äôs a very direct way to know which variant of the recommended usage pattern to employ.<br>&gt; üëé: Some people who are very familiar with existing manual retain/release programming find the recommended usage pattern really counter-intuitive because they&#39;re ‚Äúusing something after calling release on it,‚Äù which one never does in Objective-C.<br>&gt; The alternative names we‚Äôve been able to think of so far are verbose, clumsy, and don‚Äôt match up with anything in the documentation of the called function, so this seems like a really hard naming problem.  Better ideas from the community would be most welcome here.<br>&gt; We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br>&gt; We want to know whether the usage pattern recommended above works for you.<br>&gt; We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br>&gt; <br>&gt; Thanks in advance,<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/f1fef216/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>December 19, 2015 at 03:00:00am</p></header><div class="content"><p>I like `UnsafeReference` as the new name of the type and I think the basic API is clearer than with `Unmanaged`.<br>The initializers are much better than the static methods and `take(Un)RetainedValue()` were certainly less than ideal method names.<br></p><p><br>&gt; On 18 Dec 2015, at 02:37, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The name of the release() method has been contentious.<br></p><p>This is a hard one. I don&#39;t particularly like `release()` for this but I can&#39;t really think of anything better either.<br>I think it&#39;s descriptive which is good but it will take some getting used to as the &quot;consuming&quot; method although the documentation is pretty clear about the semantics which is helpful.<br></p><p>The `.releaseAndReturnObject` proposed by TJ feels a bit clearer but is also a lot more verbose.<br>Also I don&#39;t think it would make anything clearer if I didn&#39;t already know about the manual memory management terminology.<br>And something along these lines would also be bit more awkward to use if the return values were then discarded, although the proposed `manuallyRelease()` would take care of that...<br></p><p>&gt; We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br></p><p>Coming from Objective-C I find it makes sense. I also don&#39;t think the terminology is a big issue here. If you know the concepts you&#39;re probably able to map them to these terms and the documentation seems helpful in that case.<br></p><p>If, on the other hand, you are not familiar with manual reference counting concepts I doubt this will be very helpful.<br>But I don&#39;t think that can be solved with different terminology but instead requires more extensive documentation.<br>However I don&#39;t think the documentation for `UnsafeReference` is the place to try to explain the whole concept and this is more of a topic for `The Swift Programming Language` or a separate (advanced) tutorial or guide.<br></p><p>I like that the documentation tries to lay out a clear path to follow if you just want to get an object out of some un-annotated CF API but I can&#39;t really personally judge how well that works for a novice.<br></p><p><br>One other approach to terminology that comes to mind would be to focus more on the transfer of ownership into ARC as opposed to out of MRC.<br>Personally I often reason in that direction when thinking about the topic but I can&#39;t see a way in which it would be helpful for the documentation or method names...<br></p><p><br>&gt; We want to know whether the usage pattern recommended above works for you.<br></p><p>For interacting with un-annotated CF APIs: Yes.<br></p><p>&gt; We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br></p><p>&gt; On 18 Dec 2015, at 03:05, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; - `Unmanaged` has also been promoted as a solution for people who need to do manual reference counting, for performance or other reasons, so I think we might want to keep the &#39;retain()&#39; method. Conveniently enough, `release()`-ing and dropping the return value would have the net effect of decrementing the refcount by one, though the admonitions about the `UnsafeReference` become invalid after that point wouldn&#39;t hold if you&#39;re using `release()` purely for that effect, so maybe `manuallyRetain()`/`manuallyRelease()` would be more appropriate for manual refcounting applications.<br></p><p>As Joe mentioned, `Unmanaged` has a use for manual ref counting beyond immediate transfer from un-annotated APIs. <br></p><p>I have used it for performance reasons myself (~ twice) and while I think it&#39;s a pretty small use case there isn&#39;t really any alternative.<br>If it would help I can also describe my use-cases in more detail.<br></p><p>I don&#39;t think this use case even needs to be described in the documentation for `UnsafeReference` and it&#39;s fine if its use is very much discouraged.<br></p><p>Personally I prefer the proposed `manuallyRetain()`/`manuallyRelease()` over plain `retain()`/`release()` as it clearly separates the returning and more generally applicable `release()` from the MRC methods. `retain()` would probably also have to return the object which would interfere with the max safe usage pattern.<br></p><p><br>&gt; On 18 Dec 2015, at 03:05, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; - The `bitPattern:` constructors should be between UnsafeReference and Unsafe[Mutable]Pointer&lt;Void&gt;, not COpaquePointer. Let COpaquePointer retire gracefully.<br></p><p>Very much agreed.<br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/44e345d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 6:18 PM, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like `UnsafeReference` as the new name of the type and I think the basic API is clearer than with `Unmanaged`.<br>&gt; The initializers are much better than the static methods and `take(Un)RetainedValue()` were certainly less than ideal method names.<br>&gt; <br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 02:37, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; The name of the release() method has been contentious.<br>&gt; <br>&gt; This is a hard one. I don&#39;t particularly like `release()` for this but I can&#39;t really think of anything better either.<br>&gt; I think it&#39;s descriptive which is good but it will take some getting used to as the &quot;consuming&quot; method although the documentation is pretty clear about the semantics which is helpful.<br>&gt; <br>&gt; The `.releaseAndReturnObject` proposed by TJ feels a bit clearer but is also a lot more verbose.<br>&gt; Also I don&#39;t think it would make anything clearer if I didn&#39;t already know about the manual memory management terminology.<br>&gt; And something along these lines would also be bit more awkward to use if the return values were then discarded, although the proposed `manuallyRelease()` would take care of that...<br></p><p>I don&#39;t see any point in having &quot;manuallyRelease()&quot; if we already have &quot;release()&quot;; they&#39;d do the same thing if you dropped the return value.<br></p><p>&gt;&gt; We‚Äôre not sure about the terminology &lt;https://github.com/dabrahams/swift/blob/6eb86b48d150342709da3f3be9c738df23382866/stdlib/public/core/UnsafeReference.swift#L27&gt; (Unretained/Retained/Released) used to precisely describe the semantics of UnsafeReference. We‚Äôd like to know if these terms make sense to you or whether you have better ideas.<br>&gt; <br>&gt; Coming from Objective-C I find it makes sense. I also don&#39;t think the terminology is a big issue here. If you know the concepts you&#39;re probably able to map them to these terms and the documentation seems helpful in that case.<br>&gt; <br>&gt; If, on the other hand, you are not familiar with manual reference counting concepts I doubt this will be very helpful.<br>&gt; But I don&#39;t think that can be solved with different terminology but instead requires more extensive documentation.<br>&gt; However I don&#39;t think the documentation for `UnsafeReference` is the place to try to explain the whole concept and this is more of a topic for `The Swift Programming Language` or a separate (advanced) tutorial or guide.<br>&gt; <br>&gt; I like that the documentation tries to lay out a clear path to follow if you just want to get an object out of some un-annotated CF API but I can&#39;t really personally judge how well that works for a novice.<br>&gt; <br>&gt; <br>&gt; One other approach to terminology that comes to mind would be to focus more on the transfer of ownership into ARC as opposed to out of MRC.<br>&gt; Personally I often reason in that direction when thinking about the topic but I can&#39;t see a way in which it would be helpful for the documentation or method names...<br></p><p>Yeah, doesn&#39;t give me any ideas for names, unfortunately.<br></p><p>&gt; <br>&gt;&gt; We want to know whether the usage pattern recommended above works for you.<br>&gt; <br>&gt; For interacting with un-annotated CF APIs: Yes.<br>&gt; <br>&gt;&gt; We want to know if the API is sufficiently broad or if there are things you currently get‚Äîand need‚Äîfrom Unmanaged that we‚Äôve left out.<br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 03:05, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; - `Unmanaged` has also been promoted as a solution for people who need to do manual reference counting, for performance or other reasons, so I think we might want to keep the &#39;retain()&#39; method. Conveniently enough, `release()`-ing and dropping the return value would have the net effect of decrementing the refcount by one, though the admonitions about the `UnsafeReference` become invalid after that point wouldn&#39;t hold if you&#39;re using `release()` purely for that effect, so maybe `manuallyRetain()`/`manuallyRelease()` would be more appropriate for manual refcounting applications.<br>&gt; <br>&gt; As Joe mentioned, `Unmanaged` has a use for manual ref counting beyond immediate transfer from un-annotated APIs. <br>&gt; <br>&gt; I have used it for performance reasons myself (~ twice) and while I think it&#39;s a pretty small use case there isn&#39;t really any alternative.<br>&gt; If it would help I can also describe my use-cases in more detail.<br></p><p>Yes please!<br></p><p>&gt; I don&#39;t think this use case even needs to be described in the documentation for `UnsafeReference` and it&#39;s fine if its use is very much discouraged.<br>&gt; <br>&gt; Personally I prefer the proposed `manuallyRetain()`/`manuallyRelease()` over plain `retain()`/`release()` as it clearly separates the returning and more generally applicable `release()` from the MRC methods. `retain()` would probably also have to return the object which would interfere with the max safe usage pattern.<br></p><p>I don&#39;t understand your last sentence; care to clarify?<br></p><p>&gt;&gt; On 18 Dec 2015, at 03:05, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - The `bitPattern:` constructors should be between UnsafeReference and Unsafe[Mutable]Pointer&lt;Void&gt;, not COpaquePointer. Let COpaquePointer retire gracefully.<br>&gt; <br>&gt; Very much agreed.<br></p><p><br>Please see my comment here &lt;https://github.com/apple/swift-evolution/pull/44#issuecomment-165902471&gt;<br></p><p>Thanks again,<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/c991ea78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>December 29, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On 19 Dec 2015, at 22:09, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 6:18 PM, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; ...<br>&gt; <br>&gt; I don&#39;t see any point in having &quot;manuallyRelease()&quot; if we already have &quot;release()&quot;; they&#39;d do the same thing if you dropped the return value.<br></p><p>I like the proposed idea of having two separate types for handling unannotated CF APIs and MRC which would also nicely resolve this issue. <br></p><p>Would a separate type for MRC also fall under this proposal or would that require a separate proposal?<br></p><p>And speaking of a separate type for MRC, how about `ManagedReference` as a name? Seems much better than `Unmanaged`, nicely contrasts with `UnsafeReference` and `ManuallyManagedReference` is a bit of a mouthful...<br></p><p>&gt;&gt; I don&#39;t think this use case even needs to be described in the documentation for `UnsafeReference` and it&#39;s fine if its use is very much discouraged.<br>&gt;&gt; <br>&gt;&gt; Personally I prefer the proposed `manuallyRetain()`/`manuallyRelease()` over plain `retain()`/`release()` as it clearly separates the returning and more generally applicable `release()` from the MRC methods. `retain()` would probably also have to return the object which would interfere with the max safe usage pattern.<br>&gt; <br>&gt; I don&#39;t understand your last sentence; care to clarify?<br></p><p>My main reason for preferring `manuallyRetain()`/`manuallyRelease()` over `retain()`/`release()` would be that the former would *not* return the object, thus more cleanly separating them from the current `release()` which returns the object to be used from now on, with the `UnsafeReference` to be discarded at that point.<br></p><p>I just think it might be more confusing to also use `release()` for MRC and also introducing `retain()` would only exacerbate the issue. For symmetry reasons `retain()` would likely also return the object. That would make it very similar to `release()` and `.object` which it really shouldn&#39;t be as it shouldn&#39;t ever be used for handling object from unannotated CF APIs.<br></p><p>I think having a third method/property with a very similar signature would likely confusion regarding the &quot;Maximally Safe Usage&quot; pattern you described.<br></p><p>But as mentioned above I would actually prefer having two separate types which would also make this a non-issue.<br></p><p><br>&gt;&gt; As Joe mentioned, `Unmanaged` has a use for manual ref counting beyond immediate transfer from un-annotated APIs. <br>&gt;&gt; <br>&gt;&gt; I have used it for performance reasons myself (~ twice) and while I think it&#39;s a pretty small use case there isn&#39;t really any alternative.<br>&gt;&gt; If it would help I can also describe my use-cases in more detail.<br>&gt; <br>&gt; Yes please!<br></p><p>One place I used Unmanaged is in a small project where I experiment with binary heaps in Swift. I&#39;ve put the project on Github --(https://github.com/Jnosh/SwiftBinaryHeapExperiments) but basically I&#39;m using `Unmanaged` in two places here:<br></p><p>1) Testing the &#39;overhead&#39; of (A)RC.<br>Basically comparing the performance of using ARC-managed objects in the heaps vs. using &#39;unmanaged&#39; objects. In Swift 1.2 the difference was still ~2x but with Swift 2+ it&#39;s likely approaching the cost of the retain/release when entering and exiting the collection.<br></p><p>Now this could also be accomplished using `unowned(unsafe)` but `Unmanaged` has some minor advantages:<br>	a) I can keep the objects alive without keeping them in a separate collection. Not a big issue here since I&#39;m doing that anyway but I also find that `Unmanaged` makes it clearer that &amp; how the objects are (partly) manually managed.<br>	b) I had previously experimented with using `unowned(unsafe)` for this purpose but found that `Unmanaged` performed better. However, that was in a more complex example and in the Swift 1.2 era. A quick test indicates that in this case and with Swift 2.1 `unowned(unsafe)` and `Unmanaged` perform about equally.<br></p><p>2) A (object only) binary heap that uses `Unmanaged` internally<br>Not much practical use either in this case since the compiler seems to do quite well by itself but still a somewhat interesting exercise.<br>`Unmanaged` is pretty much required here to make CoW work by manually retaining the objects.<br></p><p><br>The other project was a simple 2D sprite engine (think a simplified version of SpriteKit) I experimented with about a year ago.<br>Textures and Shaders were abstracted as value types privately backed by reference types that managed the underlying OpenGL objects, i.e. destroy the OpenGL texture object on deinit, etc...<br></p><p>I found this to be quite nice to use but ARC overhead during batching &amp; rendering amounted to something like 20-30% of CPU time IIRC. (This was under Swift 1.2 and with WMO). Using `Unmanaged` was one of the things I played around with to get around this and it worked very well.<br>The `Unmanaged` instances were created when draw commands are submitted to the renderer so they were only used inside the rendering pipeline.<br>I eventually switched to using the OpenGL names (i.e. UInts) directly inside the renderer since they are already available anyway but that also requires extra logic to ensure the resources are not destroyed prematurely (e.g. retaining the object until the end of the frame or delaying the cleanup of the OpenGL resources until the end of the frame, ...). In many ways it&#39;s quite a bit messier than just using `Unmanaged`.<br></p><p><br>I don&#39;t think these are particularly great examples and I could certainly live without &#39;native&#39; MRC but ultimately I think it&#39;s an interesting capability so I&#39;d like to keep it around. Although I&#39;d be in favor of keeping it out of the stdlib but I don&#39;t think that&#39;s really an option just yet...<br></p><p>It would also be interesting to be able to do the same with indirect enum instances and closures but it&#39;s not like I have a particular use case for that ;-)<br></p><p><br>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/91d86c92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 21, 2016 at 03:00:00am</p></header><div class="content"><p>Back to this after a long hiatus, sorry.<br></p><p>on Tue Dec 29 2015, Janosch Hildebrand &lt;jnosh-AT-jnosh.com&gt; wrote:<br></p><p>&gt;&gt; On 19 Dec 2015, at 22:09, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 6:18 PM, Janosch Hildebrand via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see any point in having &quot;manuallyRelease()&quot; if we already<br>&gt;&gt; have &quot;release()&quot;; they&#39;d do the same thing if you dropped the return<br>&gt;&gt; value.<br>&gt;<br>&gt; I like the proposed idea of having two separate types for handling<br>&gt; unannotated CF APIs and MRC which would also nicely resolve this<br>&gt; issue.<br>&gt;<br>&gt; Would a separate type for MRC also fall under this proposal or would<br>&gt; that require a separate proposal?<br></p><p>Considering that we&#39;re just RFC&#39;ing here, we can certainly talk about<br>that.<br></p><p>&gt; And speaking of a separate type for MRC, how about `ManagedReference`<br>&gt; as a name? Seems much better than `Unmanaged`, nicely contrasts with<br>&gt; `UnsafeReference` and `ManuallyManagedReference` is a bit of a<br>&gt; mouthful...<br></p><p>I think we want ‚Äúmanaged‚Äù to mean ‚Äúmanaged for you,‚Äù not ‚Äúmanaged by<br>you.‚Äù  It&#39;s also quite unsafe because you can overrelease it, etc., so<br>it would have to have ‚Äúunsafe‚Äù in the name somewhere I think.<br></p><p><br>&gt;&gt;&gt; I don&#39;t think this use case even needs to be described in the<br>&gt;&gt;&gt; documentation for `UnsafeReference` and it&#39;s fine if its use is<br>&gt;&gt;&gt; very much discouraged.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I prefer the proposed<br>&gt;&gt;&gt; `manuallyRetain()`/`manuallyRelease()` over plain<br>&gt;&gt;&gt; `retain()`/`release()` as it clearly separates the returning and<br>&gt;&gt;&gt; more generally applicable `release()` from the MRC<br>&gt;&gt;&gt; methods. `retain()` would probably also have to return the object<br>&gt;&gt;&gt; which would interfere with the max safe usage pattern.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t understand your last sentence; care to clarify?<br>&gt;<br>&gt; My main reason for preferring `manuallyRetain()`/`manuallyRelease()`<br>&gt; over `retain()`/`release()` would be that the former would *not*<br>&gt; return the object, thus more cleanly separating them from the current<br>&gt; `release()` which returns the object to be used from now on, with the<br>&gt; `UnsafeReference` to be discarded at that point.<br>&gt;<br>&gt; I just think it might be more confusing to also use `release()` for<br>&gt; MRC and also introducing `retain()` would only exacerbate the<br>&gt; issue. For symmetry reasons `retain()` would likely also return the<br>&gt; object. <br></p><p>There might be other reasons to do it, but I don&#39;t think symmetry is<br>necessarily a design goal here.<br></p><p>&gt; That would make it very similar to `release()` and `.object` which it<br>&gt; really shouldn&#39;t be as it shouldn&#39;t ever be used for handling object<br>&gt; from unannotated CF APIs.<br>&gt;<br>&gt; I think having a third method/property with a very similar signature<br>&gt; would likely confusion regarding the &quot;Maximally Safe Usage&quot; pattern<br>&gt; you described.<br>&gt;<br>&gt; But as mentioned above I would actually prefer having two separate<br>&gt; types which would also make this a non-issue.<br></p><p>Questions:<br></p><p>1. How would these types interact?  Does one need to be able to convert<br>   between them liberally, or is it sufficient to use strong references<br>   as the common currency?<br></p><p>2. Do you really want a type at all?  Why not just retain() and<br>   release() as free functions?<br></p><p>&gt;&gt;&gt; As Joe mentioned, `Unmanaged` has a use for manual ref counting<br>&gt;&gt;&gt; beyond immediate transfer from un-annotated APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have used it for performance reasons myself (~ twice) and while I<br>&gt;&gt;&gt; think it&#39;s a pretty small use case there isn&#39;t really any<br>&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt; If it would help I can also describe my use-cases in more detail.<br>&gt;&gt; <br>&gt;&gt; Yes please!<br>&gt;<br>&gt; One place I used Unmanaged is in a small project where I experiment<br>&gt; with binary heaps in Swift. I&#39;ve put the project on Github<br>&gt; --(https://github.com/Jnosh/SwiftBinaryHeapExperiments) but basically<br>&gt; I&#39;m using `Unmanaged` in two places here:<br>&gt;<br>&gt; 1) Testing the &#39;overhead&#39; of (A)RC.<br>&gt; Basically comparing the performance of using ARC-managed objects in<br>&gt; the heaps vs. using &#39;unmanaged&#39; objects. In Swift 1.2 the difference<br>&gt; was still ~2x but with Swift 2+ it&#39;s likely approaching the cost of<br>&gt; the retain/release when entering and exiting the collection.<br>&gt;<br>&gt; Now this could also be accomplished using `unowned(unsafe)` but<br>&gt; `Unmanaged` has some minor advantages:<br>&gt; 	a) I can keep the objects alive without keeping them in a<br>&gt; separate collection. Not a big issue here since I&#39;m doing that anyway<br>&gt; but I also find that `Unmanaged` makes it clearer that &amp; how the<br>&gt; objects are (partly) manually managed.<br>&gt; 	b) I had previously experimented with using `unowned(unsafe)`<br>&gt; for this purpose but found that `Unmanaged` performed better. However,<br>&gt; that was in a more complex example and in the Swift 1.2 era. A quick<br>&gt; test indicates that in this case and with Swift 2.1 `unowned(unsafe)`<br>&gt; and `Unmanaged` perform about equally.<br></p><p>They should.  unowned(unsafe) var T is essentially just an<br>UnsafePointer.  unowned/unowned(safe) do incur reference-counting cost<br>in exchange for their safety.<br></p><p>&gt; 2) A (object only) binary heap that uses `Unmanaged` internally<br>&gt; Not much practical use either in this case since the compiler seems to<br>&gt; do quite well by itself but still a somewhat interesting exercise.<br>&gt; `Unmanaged` is pretty much required here to make CoW work by manually<br>&gt; retaining the objects.<br></p><p>It&#39;s hard for me to imagine why that would be the case.  Would I have<br>needed to use Unmanaged in implementing Arrays of objects, if it were?<br></p><p>&gt; The other project was a simple 2D sprite engine (think a simplified<br>&gt; version of SpriteKit) I experimented with about a year ago.<br>&gt; Textures and Shaders were abstracted as value types privately backed<br>&gt; by reference types that managed the underlying OpenGL objects,<br>&gt; i.e. destroy the OpenGL texture object on deinit, etc...<br>&gt;<br>&gt; I found this to be quite nice to use but ARC overhead during batching<br>&gt; &amp; rendering amounted to something like 20-30% of CPU time IIRC. (This<br>&gt; was under Swift 1.2 and with WMO). Using `Unmanaged` was one of the<br>&gt; things I played around with to get around this and it worked very<br>&gt; well.<br></p><p>Another case where you can use unowned(unsafe), is it not?<br></p><p>&gt; The `Unmanaged` instances were created when draw commands are<br>&gt; submitted to the renderer so they were only used inside the rendering<br>&gt; pipeline.<br>&gt; I eventually switched to using the OpenGL names (i.e. UInts) directly<br>&gt; inside the renderer since they are already available anyway but that<br>&gt; also requires extra logic to ensure the resources are not destroyed<br>&gt; prematurely (e.g. retaining the object until the end of the frame or<br>&gt; delaying the cleanup of the OpenGL resources until the end of the<br>&gt; frame, ...). In many ways it&#39;s quite a bit messier than just using<br>&gt; `Unmanaged`.<br></p><p>I don&#39;t see how Unmanaged could have been less messy; don&#39;t you still<br>need a strong reference somewhere to ensure the lifetime?<br></p><p>&gt; I don&#39;t think these are particularly great examples and I could<br>&gt; certainly live without &#39;native&#39; MRC but ultimately I think it&#39;s an<br>&gt; interesting capability so I&#39;d like to keep it around. <br>&gt; Although I&#39;d be in favor of keeping it out of the stdlib but I don&#39;t<br>&gt; think that&#39;s really an option just yet...<br>&gt;<br>&gt; It would also be interesting to be able to do the same with indirect<br>&gt; enum instances and closures but it&#39;s not like I have a particular use<br>&gt; case for that ;-)<br></p><p>I don&#39;t understand what you might be hinting at here.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 21 Feb 2016, at 12:28, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Back to this after a long hiatus, sorry.<br></p><p>No problem, you&#39;ve got bigger fish to fry. :-)<br></p><p>And thanks again for your time and questions. Having someone ask<br>the hard questions really helps me reevaluate and better understand<br>my own thoughts and opinions.<br></p><p>&gt; on Tue Dec 29 2015, Janosch Hildebrand &lt;jnosh-AT-jnosh.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 19 Dec 2015, at 22:09, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 6:18 PM, Janosch Hildebrand via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see any point in having &quot;manuallyRelease()&quot; if we already<br>&gt;&gt;&gt; have &quot;release()&quot;; they&#39;d do the same thing if you dropped the return<br>&gt;&gt;&gt; value.<br>&gt;&gt; <br>&gt;&gt; I like the proposed idea of having two separate types for handling<br>&gt;&gt; unannotated CF APIs and MRC which would also nicely resolve this<br>&gt;&gt; issue.<br>&gt;&gt; <br>&gt;&gt; Would a separate type for MRC also fall under this proposal or would<br>&gt;&gt; that require a separate proposal?<br>&gt; <br>&gt; Considering that we&#39;re just RFC&#39;ing here, we can certainly talk about<br>&gt; that.<br>&gt; <br>&gt;&gt; And speaking of a separate type for MRC, how about `ManagedReference`<br>&gt;&gt; as a name? Seems much better than `Unmanaged`, nicely contrasts with<br>&gt;&gt; `UnsafeReference` and `ManuallyManagedReference` is a bit of a<br>&gt;&gt; mouthful...<br>&gt; <br>&gt; I think we want ‚Äúmanaged‚Äù to mean ‚Äúmanaged for you,‚Äù not ‚Äúmanaged by<br>&gt; you.‚Äù  It&#39;s also quite unsafe because you can overrelease it, etc., so<br>&gt; it would have to have ‚Äúunsafe‚Äù in the name somewhere I think.<br></p><p>That makes sense. Something like `UnsafeReferenceCountedPointer` but<br>shorter?<br></p><p>&gt;&gt;&gt;&gt; I don&#39;t think this use case even needs to be described in the<br>&gt;&gt;&gt;&gt; documentation for `UnsafeReference` and it&#39;s fine if its use is<br>&gt;&gt;&gt;&gt; very much discouraged.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally I prefer the proposed<br>&gt;&gt;&gt;&gt; `manuallyRetain()`/`manuallyRelease()` over plain<br>&gt;&gt;&gt;&gt; `retain()`/`release()` as it clearly separates the returning and<br>&gt;&gt;&gt;&gt; more generally applicable `release()` from the MRC<br>&gt;&gt;&gt;&gt; methods. `retain()` would probably also have to return the object<br>&gt;&gt;&gt;&gt; which would interfere with the max safe usage pattern.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t understand your last sentence; care to clarify?<br>&gt;&gt; <br>&gt;&gt; My main reason for preferring `manuallyRetain()`/`manuallyRelease()`<br>&gt;&gt; over `retain()`/`release()` would be that the former would *not*<br>&gt;&gt; return the object, thus more cleanly separating them from the current<br>&gt;&gt; `release()` which returns the object to be used from now on, with the<br>&gt;&gt; `UnsafeReference` to be discarded at that point.<br>&gt;&gt; <br>&gt;&gt; I just think it might be more confusing to also use `release()` for<br>&gt;&gt; MRC and also introducing `retain()` would only exacerbate the<br>&gt;&gt; issue. For symmetry reasons `retain()` would likely also return the<br>&gt;&gt; object. <br>&gt; <br>&gt; There might be other reasons to do it, but I don&#39;t think symmetry is<br>&gt; necessarily a design goal here.<br>&gt; <br>&gt;&gt; That would make it very similar to `release()` and `.object` which it<br>&gt;&gt; really shouldn&#39;t be as it shouldn&#39;t ever be used for handling object<br>&gt;&gt; from unannotated CF APIs.<br>&gt;&gt; <br>&gt;&gt; I think having a third method/property with a very similar signature<br>&gt;&gt; would likely confusion regarding the &quot;Maximally Safe Usage&quot; pattern<br>&gt;&gt; you described.<br>&gt;&gt; <br>&gt;&gt; But as mentioned above I would actually prefer having two separate<br>&gt;&gt; types which would also make this a non-issue.<br>&gt; <br>&gt; Questions:<br>&gt; <br>&gt; 1. How would these types interact?  Does one need to be able to convert<br>&gt;   between them liberally, or is it sufficient to use strong references<br>&gt;   as the common currency?<br></p><p>If we were to have two separate types I think it would be more than fine to<br>use strong references as a go-between. The use cases for the two types are<br>so different that I doubt it would be an issue.<br></p><p>&gt; 2. Do you really want a type at all?  Why not just retain() and<br>&gt;   release() as free functions?<br></p><p>I assume these would be unsafeRetain() and unsafeRelease() ;-)<br></p><p>But yeah, that would work as well and might be a nicer solution overall.<br>(And you could easily create your own type from these + unowned(unsafe))<br></p><p>The downside I see is that being free functions and working with<br>AnyObject makes them much more discoverable than being hidden<br>inside some other type. But given the other unsafe* free functions<br>that&#39;s already exists that might be fine.<br></p><p>Also having a predefined wrapper type has some use, e.g. when you<br>want to store your unowned(unsafe) objects into some collection.<br>But I&#39;d guess you&#39;ll end up with a dedicated wrapper type anyway<br>in most circumstances where this is an issue so it&#39;s probably OK.<br>And this gets rid of having a separate type that also plays the role<br>of unowned(unsafe) which seems like a plus.<br></p><p><br>I have some more answers below but I&#39;ll summarize my opinion here.<br>Preferences (in descending order):<br></p><p>1) unsafeRetain() + unsafeRelease() + unowned(unsafe)<br>2) &quot;UnsafeReferenceCountedPointer&quot;<br>3) No dedicated functionality so just abuse UnsafeReference instead of<br>    Unmanaged<br></p><p><br>I think ultimately it&#39;s a question of whether we want to expose the<br>reference counting implementation to manual use...<br></p><p>Is it something I can live without? Absolutely.<br>Is it something I would use often? Absolutely not.<br>But then again, it is going to be exposed through UnsafeReference anyway.<br></p><p>And having access to a solid manual reference counting solution<br>that integrates very well with the rest of the language is kinda neat in<br>my opinion. And the integration with ARC is something an external<br>library cannot provide without becoming even more &quot;hacky&quot;.<br>And I don&#39;t think it&#39;s any more dangerous than any other manual<br>memory management we have access to. <br></p><p>I also wonder if it has some minor use for learning/teaching.<br>Yes, ARC is great because most of the time you don&#39;t need to think<br>about this but if you&#39;re trying to understand reference counting it&#39;s<br>kinda nice to be able to actually interact and play around with it.<br>Then again I&#39;m the kind of person that likes doing that but YMMV...<br></p><p><br>&gt;&gt;&gt;&gt; As Joe mentioned, `Unmanaged` has a use for manual ref counting<br>&gt;&gt;&gt;&gt; beyond immediate transfer from un-annotated APIs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have used it for performance reasons myself (~ twice) and while I<br>&gt;&gt;&gt;&gt; think it&#39;s a pretty small use case there isn&#39;t really any<br>&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt;&gt; If it would help I can also describe my use-cases in more detail.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes please!<br>&gt;&gt; <br>&gt;&gt; One place I used Unmanaged is in a small project where I experiment<br>&gt;&gt; with binary heaps in Swift. I&#39;ve put the project on Github<br>&gt;&gt; --(https://github.com/Jnosh/SwiftBinaryHeapExperiments) but basically<br>&gt;&gt; I&#39;m using `Unmanaged` in two places here:<br>&gt;&gt; <br>&gt;&gt; 1) Testing the &#39;overhead&#39; of (A)RC.<br>&gt;&gt; Basically comparing the performance of using ARC-managed objects in<br>&gt;&gt; the heaps vs. using &#39;unmanaged&#39; objects. In Swift 1.2 the difference<br>&gt;&gt; was still ~2x but with Swift 2+ it&#39;s likely approaching the cost of<br>&gt;&gt; the retain/release when entering and exiting the collection.<br>&gt;&gt; <br>&gt;&gt; Now this could also be accomplished using `unowned(unsafe)` but<br>&gt;&gt; `Unmanaged` has some minor advantages:<br>&gt;&gt; 	a) I can keep the objects alive without keeping them in a<br>&gt;&gt; separate collection. Not a big issue here since I&#39;m doing that anyway<br>&gt;&gt; but I also find that `Unmanaged` makes it clearer that &amp; how the<br>&gt;&gt; objects are (partly) manually managed.<br>&gt;&gt; 	b) I had previously experimented with using `unowned(unsafe)`<br>&gt;&gt; for this purpose but found that `Unmanaged` performed better. However,<br>&gt;&gt; that was in a more complex example and in the Swift 1.2 era. A quick<br>&gt;&gt; test indicates that in this case and with Swift 2.1 `unowned(unsafe)`<br>&gt;&gt; and `Unmanaged` perform about equally.<br>&gt; <br>&gt; They should.  unowned(unsafe) var T is essentially just an<br>&gt; UnsafePointer.  unowned/unowned(safe) do incur reference-counting cost<br>&gt; in exchange for their safety.<br></p><p>I&#39;ll come back to this further down.<br></p><p>&gt;&gt; 2) A (object only) binary heap that uses `Unmanaged` internally<br>&gt;&gt; Not much practical use either in this case since the compiler seems to<br>&gt;&gt; do quite well by itself but still a somewhat interesting exercise.<br>&gt;&gt; `Unmanaged` is pretty much required here to make CoW work by manually<br>&gt;&gt; retaining the objects.<br>&gt; <br>&gt; It&#39;s hard for me to imagine why that would be the case.  Would I have<br>&gt; needed to use Unmanaged in implementing Arrays of objects, if it were?<br></p><p>Sorry, I wasn&#39;t clear enough. I (ab)use Unmanaged for two different reasons here.<br></p><p>1) To have a performance baseline where the ARC overhead inside the collection<br>is essentially zero beyond the mandatory retain on insert, i.e. as if the compiler was<br>able to eliminate all (redundant) retains and releases.<br></p><p>One part of this is exempting the objects from ARC which is is done by storing the<br>elements in Unmanaged instances but a wrapper type using unowned(unsafe)<br>would work just as well.<br></p><p>However, I still need a strong reference to the objects to keep them alive. Using a<br>separate data structure would work but that has a space, time and code complexity<br>cost.<br>Instead I use Unmanaged to manually retain the objects on insert and release on<br>removal. unowned cannot do that on its own hence the need for something like<br>unsafeRetain() &amp; unsafeRelease().<br></p><p>2) I then abuse Unmanaged&#39;s capabilities a second time to retain the elements<br>when the collection is copied (which would happen &#39;automatically&#39; with ARC).<br></p><p><br>Btw, with Swift 2.2 under WMO the performance of a normal ManagedBuffer<br>is on par with this &quot;hack&quot;. Go Swift team!<br></p><p><br>&gt;&gt; The other project was a simple 2D sprite engine (think a simplified<br>&gt;&gt; version of SpriteKit) I experimented with about a year ago.<br>&gt;&gt; Textures and Shaders were abstracted as value types privately backed<br>&gt;&gt; by reference types that managed the underlying OpenGL objects,<br>&gt;&gt; i.e. destroy the OpenGL texture object on deinit, etc...<br>&gt;&gt; <br>&gt;&gt; I found this to be quite nice to use but ARC overhead during batching<br>&gt;&gt; &amp; rendering amounted to something like 20-30% of CPU time IIRC. (This<br>&gt;&gt; was under Swift 1.2 and with WMO). Using `Unmanaged` was one of the<br>&gt;&gt; things I played around with to get around this and it worked very<br>&gt;&gt; well.<br>&gt; <br>&gt; Another case where you can use unowned(unsafe), is it not?<br></p><p>Indeed, and that was what I originally tried to use.<br>Ultimately i settled on Unmanaged however. Now it&#39;s been a long time and<br>I don&#39;t recall the exact details so take this with a grain of salt: <br></p><p>One reason certainly was that I ended up needing Unmanaged anyway<br>to perform manual retain &amp; releases at which point why not also use it<br>for &#39;storage&#39;...<br></p><p>But I also vaguely recall that Unmanaged had more of a performance impact.<br>Now one possibility is that there was some issue with unowned(unsafe) (this<br>was with 1.2Œ≤1) but much more likely is that Unmanaged was easier to apply<br>consistently and correctly.<br>e.g. assume you have some struct that contains an unowned(unsafe) variable.<br>Now if you extract that into a local variable you add a perhaps unwanted<br>retain/release so you might need to mark the local variable as unowned(unsafe)<br>as well, etc...<br>What I&#39;m trying to say is that with unowned you need to be careful and considerate<br>with how you use it at all times since the &#39;obvious&#39; thing generally leads to<br>retain/release.<br>Unmanaged is fine to pass around, store in a local variable, etc... and any ARC<br>related interactions are obvious because they manifest as method calls on the<br>Unmanaged instance.<br></p><p>For their main application, breaking retain cycles, weak and unowned work fine<br>because you want to retain the objects when they are not &#39;at rest&#39;.<br>But if you want to avoid retains even when working with the objects, a type is<br>just a much more comfortable way to handle this.<br>Like I mentioned before, I imagine that in many cases you&#39;ll end up making a<br>custom wrapper anyway but it&#39;s something I&#39;m a bit apprehensive about.<br></p><p>Still, I think unowned(unsafe) together with unsafeRetain() and unsafeRelease()<br>free functions makes for a nicer API and I don&#39;t think I can adequately judge it<br>beyond that. I&#39;ve barely used this in it&#39;s current form have no real experience<br>with a potential future form and I hopefully won&#39;t use it (often) anyway.<br>So I think it&#39;s more than appropriate to prioritize the general API over making<br>this esoteric use case more comfortable to use.<br></p><p><br>&gt;&gt; The `Unmanaged` instances were created when draw commands are<br>&gt;&gt; submitted to the renderer so they were only used inside the rendering<br>&gt;&gt; pipeline.<br>&gt;&gt; I eventually switched to using the OpenGL names (i.e. UInts) directly<br>&gt;&gt; inside the renderer since they are already available anyway but that<br>&gt;&gt; also requires extra logic to ensure the resources are not destroyed<br>&gt;&gt; prematurely (e.g. retaining the object until the end of the frame or<br>&gt;&gt; delaying the cleanup of the OpenGL resources until the end of the<br>&gt;&gt; frame, ...). In many ways it&#39;s quite a bit messier than just using<br>&gt;&gt; `Unmanaged`.<br>&gt; <br>&gt; I don&#39;t see how Unmanaged could have been less messy; don&#39;t you still<br>&gt; need a strong reference somewhere to ensure the lifetime?<br></p><p>Absolutely. You can retain the object directly through Unmanaged<br>(via passRetained() or retain()) and make the Unmanaged instance<br>a strong reference in effect.<br></p><p>Not a big difference to retaining by putting the objects in some container.<br>Just a different set of tradeoffs.<br></p><p>I don&#39;t think it&#39;s the best solution for this case but it&#39;s pretty simple. Retain<br>when creating the draw command, release when discarding the draw<br>command - nothing different than malloc/free.<br></p><p>Collecting the objects in some collection is likely to be a cleaner solution<br>and more efficient too, since you don&#39;t retain objects multiple times if they are<br>used multiple times in the same frame (which is likely for shaders, textures).<br>But then someone somewhere needs to manage this, and you need to<br>access that state when creating or submitting the draw command.<br></p><p>Or perhaps make sure the referenced resources stay valid until the frame<br>is drawn so you don&#39;t need to retain here at all but now you need to track<br>all the scene contents, etc...<br> <br></p><p>Hopefully I don&#39;t come across as too petulant. :-)<br>I don&#39;t really want to argue in favor of or defend these approaches.<br>I&#39;m merely trying to give some examples of when and what for I actually<br>used this stuff not to prove the merits of these cases but instead to argue<br>for the existence of better justified uses based on the same ideas.<br>Not sure if that makes any sense but there you go :-)<br></p><p><br>&gt;&gt; I don&#39;t think these are particularly great examples and I could<br>&gt;&gt; certainly live without &#39;native&#39; MRC but ultimately I think it&#39;s an<br>&gt;&gt; interesting capability so I&#39;d like to keep it around. <br>&gt;&gt; Although I&#39;d be in favor of keeping it out of the stdlib but I don&#39;t<br>&gt;&gt; think that&#39;s really an option just yet...<br>&gt;&gt; <br>&gt;&gt; It would also be interesting to be able to do the same with indirect<br>&gt;&gt; enum instances and closures but it&#39;s not like I have a particular use<br>&gt;&gt; case for that ;-)<br>&gt; <br>&gt; I don&#39;t understand what you might be hinting at here.<br></p><p>Just that AFAIK closures and indirect enum instances also use ARCed<br>references under the hood. So in theory the could potentially also be<br>stored unowned and manually retained/released.<br></p><p>I just find it slightly interesting that with (Any)Objects certain things are<br>exposed (unsafeAddressOf, retain/release, ...) whereas with indirect enums<br>and closures they are not.<br></p><p>I don&#39;t want to imply that that would be a good idea and it would certainly<br>be hard, complicated, and annoying to implement with essentially n<br>benefit so I don&#39;t want to go anywhere with this other than the partial similarity.<br></p><p>Basically it&#39;s just my brain going:<br>&quot;Oh look, some pyramids. Hmm, you could store these much more efficiently<br>if you stacked them up against each other&quot; ;-)<br></p><p>- Janosch<br></p><p>&gt; -- <br>&gt; -Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 22, 2016 at 07:00:00am</p></header><div class="content"><p>on Mon Feb 22 2016, Janosch Hildebrand &lt;jnosh-AT-jnosh.com&gt; wrote:<br></p><p>&gt;&gt;&gt; And speaking of a separate type for MRC, how about `ManagedReference`<br>&gt;&gt;&gt; as a name? Seems much better than `Unmanaged`, nicely contrasts with<br>&gt;&gt;&gt; `UnsafeReference` and `ManuallyManagedReference` is a bit of a<br>&gt;&gt;&gt; mouthful...<br>&gt;&gt; <br>&gt;&gt; I think we want ‚Äúmanaged‚Äù to mean ‚Äúmanaged for you,‚Äù not ‚Äúmanaged by<br>&gt;&gt; you.‚Äù  It&#39;s also quite unsafe because you can overrelease it, etc., so<br>&gt;&gt; it would have to have ‚Äúunsafe‚Äù in the name somewhere I think.<br>&gt;<br>&gt; That makes sense. Something like `UnsafeReferenceCountedPointer` but<br>&gt; shorter?<br></p><p>Something like that.  I&#39;m not attached to it being shorter.<br></p><p>&gt;&gt;&gt;&gt;&gt; I don&#39;t think this use case even needs to be described in the<br>&gt;&gt;&gt;&gt;&gt; documentation for `UnsafeReference` and it&#39;s fine if its use is<br>&gt;&gt;&gt;&gt;&gt; very much discouraged.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Personally I prefer the proposed<br>&gt;&gt;&gt;&gt;&gt; `manuallyRetain()`/`manuallyRelease()` over plain<br>&gt;&gt;&gt;&gt;&gt; `retain()`/`release()` as it clearly separates the returning and<br>&gt;&gt;&gt;&gt;&gt; more generally applicable `release()` from the MRC<br>&gt;&gt;&gt;&gt;&gt; methods. `retain()` would probably also have to return the object<br>&gt;&gt;&gt;&gt;&gt; which would interfere with the max safe usage pattern.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t understand your last sentence; care to clarify?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My main reason for preferring `manuallyRetain()`/`manuallyRelease()`<br>&gt;&gt;&gt; over `retain()`/`release()` would be that the former would *not*<br>&gt;&gt;&gt; return the object, thus more cleanly separating them from the current<br>&gt;&gt;&gt; `release()` which returns the object to be used from now on, with the<br>&gt;&gt;&gt; `UnsafeReference` to be discarded at that point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just think it might be more confusing to also use `release()` for<br>&gt;&gt;&gt; MRC and also introducing `retain()` would only exacerbate the<br>&gt;&gt;&gt; issue. For symmetry reasons `retain()` would likely also return the<br>&gt;&gt;&gt; object. <br>&gt;&gt; <br>&gt;&gt; There might be other reasons to do it, but I don&#39;t think symmetry is<br>&gt;&gt; necessarily a design goal here.<br>&gt;&gt; <br>&gt;&gt;&gt; That would make it very similar to `release()` and `.object` which it<br>&gt;&gt;&gt; really shouldn&#39;t be as it shouldn&#39;t ever be used for handling object<br>&gt;&gt;&gt; from unannotated CF APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think having a third method/property with a very similar signature<br>&gt;&gt;&gt; would likely confusion regarding the &quot;Maximally Safe Usage&quot; pattern<br>&gt;&gt;&gt; you described.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But as mentioned above I would actually prefer having two separate<br>&gt;&gt;&gt; types which would also make this a non-issue.<br>&gt;&gt; <br>&gt;&gt; Questions:<br>&gt;&gt; <br>&gt;&gt; 1. How would these types interact?  Does one need to be able to convert<br>&gt;&gt;   between them liberally, or is it sufficient to use strong references<br>&gt;&gt;   as the common currency?<br>&gt;<br>&gt; If we were to have two separate types I think it would be more than fine to<br>&gt; use strong references as a go-between. The use cases for the two types are<br>&gt; so different that I doubt it would be an issue.<br>&gt;<br>&gt;&gt; 2. Do you really want a type at all?  Why not just retain() and<br>&gt;&gt;   release() as free functions?<br>&gt;<br>&gt; I assume these would be unsafeRetain() and unsafeRelease() ;-)<br></p><p>Yes of course.<br></p><p>&gt; But yeah, that would work as well and might be a nicer solution overall.<br>&gt; (And you could easily create your own type from these + unowned(unsafe))<br>&gt;<br>&gt; The downside I see is that being free functions and working with<br>&gt; AnyObject makes them much more discoverable than being hidden<br>&gt; inside some other type. <br></p><p>How discoverable *are* free functions, really, after all?  If you want<br>we could nest them:<br></p><p>enum UnsafeManualReferenceCounting {<br>  static func retain(AnyObject) {...}<br>  static func release(AnyObject) {...}<br>}<br></p><p>&gt; But given the other unsafe* free functions that&#39;s already exists that<br>&gt; might be fine.<br></p><p>Yeah, IMO that would be reasonable.<br></p><p>&gt; Also having a predefined wrapper type has some use, e.g. when you<br>&gt; want to store your unowned(unsafe) objects into some collection.<br></p><p>Yeah, though it seems to me that wrapper should be UnsafeReference&lt;T&gt;.<br></p><p>&gt; But I&#39;d guess you&#39;ll end up with a dedicated wrapper type anyway in<br>&gt; most circumstances where this is an issue so it&#39;s probably OK.  And<br>&gt; this gets rid of having a separate type that also plays the role of<br>&gt; unowned(unsafe) which seems like a plus.<br>&gt;<br>&gt; I have some more answers below but I&#39;ll summarize my opinion here.<br>&gt; Preferences (in descending order):<br>&gt;<br>&gt; 1) unsafeRetain() + unsafeRelease() + unowned(unsafe)<br>&gt; 2) &quot;UnsafeReferenceCountedPointer&quot;<br>&gt; 3) No dedicated functionality so just abuse UnsafeReference instead of<br>&gt;     Unmanaged<br>&gt;<br>&gt; I think ultimately it&#39;s a question of whether we want to expose the<br>&gt; reference counting implementation to manual use...<br>&gt;<br>&gt; Is it something I can live without? Absolutely.<br>&gt; Is it something I would use often? Absolutely not.<br>&gt; But then again, it is going to be exposed through UnsafeReference anyway.<br>&gt;<br>&gt; And having access to a solid manual reference counting solution<br>&gt; that integrates very well with the rest of the language is kinda neat in<br>&gt; my opinion. And the integration with ARC is something an external<br>&gt; library cannot provide without becoming even more &quot;hacky&quot;.<br>&gt; And I don&#39;t think it&#39;s any more dangerous than any other manual<br>&gt; memory management we have access to. <br></p><p>Okay.  My current feeling about all this is that UnsafeReference should<br>have retain and release directly on it, for MRC.<br></p><p>The thing I&#39;m really unclear about at this point is whether it&#39;s<br>reasonable to ask users to use ‚Äúrelease()‚Äù for the maximally-safe usage<br>pattern, or if that&#39;s just too weird.  My sense all along has been that<br>asking them to get used to it is a much better design choice than<br>expanding the API, especially when we don&#39;t really have a better name for<br>it than ‚Äúrelease.‚Äù  If a better name presented itself, that might change<br>the picture.<br></p><p>&gt; I also wonder if it has some minor use for learning/teaching.<br>&gt; Yes, ARC is great because most of the time you don&#39;t need to think<br>&gt; about this but if you&#39;re trying to understand reference counting it&#39;s<br>&gt; kinda nice to be able to actually interact and play around with it.<br>&gt; Then again I&#39;m the kind of person that likes doing that but YMMV...<br></p><p>As long as you don&#39;t need to share anything across threads, it&#39;s easy<br>enough to build MRC using malloc, free, and a counter in each allocated<br>block, so this doesn&#39;t sound like a strong argument to me.<br></p><p>&gt;&gt;&gt;&gt;&gt; As Joe mentioned, `Unmanaged` has a use for manual ref counting<br>&gt;&gt;&gt;&gt;&gt; beyond immediate transfer from un-annotated APIs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have used it for performance reasons myself (~ twice) and while I<br>&gt;&gt;&gt;&gt;&gt; think it&#39;s a pretty small use case there isn&#39;t really any<br>&gt;&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt;&gt;&gt; If it would help I can also describe my use-cases in more detail.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes please!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One place I used Unmanaged is in a small project where I experiment<br>&gt;&gt;&gt; with binary heaps in Swift. I&#39;ve put the project on Github<br>&gt;&gt;&gt; --(https://github.com/Jnosh/SwiftBinaryHeapExperiments) but basically<br>&gt;&gt;&gt; I&#39;m using `Unmanaged` in two places here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Testing the &#39;overhead&#39; of (A)RC.<br>&gt;&gt;&gt; Basically comparing the performance of using ARC-managed objects in<br>&gt;&gt;&gt; the heaps vs. using &#39;unmanaged&#39; objects. In Swift 1.2 the difference<br>&gt;&gt;&gt; was still ~2x but with Swift 2+ it&#39;s likely approaching the cost of<br>&gt;&gt;&gt; the retain/release when entering and exiting the collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now this could also be accomplished using `unowned(unsafe)` but<br>&gt;&gt;&gt; `Unmanaged` has some minor advantages:<br>&gt;&gt;&gt; 	a) I can keep the objects alive without keeping them in a<br>&gt;&gt;&gt; separate collection. Not a big issue here since I&#39;m doing that anyway<br>&gt;&gt;&gt; but I also find that `Unmanaged` makes it clearer that &amp; how the<br>&gt;&gt;&gt; objects are (partly) manually managed.<br>&gt;&gt;&gt; 	b) I had previously experimented with using `unowned(unsafe)`<br>&gt;&gt;&gt; for this purpose but found that `Unmanaged` performed better. However,<br>&gt;&gt;&gt; that was in a more complex example and in the Swift 1.2 era. A quick<br>&gt;&gt;&gt; test indicates that in this case and with Swift 2.1 `unowned(unsafe)`<br>&gt;&gt;&gt; and `Unmanaged` perform about equally.<br>&gt;&gt; <br>&gt;&gt; They should.  unowned(unsafe) var T is essentially just an<br>&gt;&gt; UnsafePointer.  unowned/unowned(safe) do incur reference-counting cost<br>&gt;&gt; in exchange for their safety.<br>&gt;<br>&gt; I&#39;ll come back to this further down.<br>&gt;<br>&gt;&gt;&gt; 2) A (object only) binary heap that uses `Unmanaged` internally<br>&gt;&gt;&gt; Not much practical use either in this case since the compiler seems to<br>&gt;&gt;&gt; do quite well by itself but still a somewhat interesting exercise.<br>&gt;&gt;&gt; `Unmanaged` is pretty much required here to make CoW work by manually<br>&gt;&gt;&gt; retaining the objects.<br>&gt;&gt; <br>&gt;&gt; It&#39;s hard for me to imagine why that would be the case.  Would I have<br>&gt;&gt; needed to use Unmanaged in implementing Arrays of objects, if it were?<br>&gt;<br>&gt; Sorry, I wasn&#39;t clear enough. I (ab)use Unmanaged for two different reasons here.<br>&gt;<br>&gt; 1) To have a performance baseline where the ARC overhead inside the collection<br>&gt; is essentially zero beyond the mandatory retain on insert, i.e. as if the compiler was<br>&gt; able to eliminate all (redundant) retains and releases.<br>&gt;<br>&gt; One part of this is exempting the objects from ARC which is is done by storing the<br>&gt; elements in Unmanaged instances but a wrapper type using unowned(unsafe)<br>&gt; would work just as well.<br>&gt;<br>&gt; However, I still need a strong reference to the objects to keep them alive. Using a<br>&gt; separate data structure would work but that has a space, time and code complexity<br>&gt; cost.<br>&gt; Instead I use Unmanaged to manually retain the objects on insert and release on<br>&gt; removal. unowned cannot do that on its own hence the need for something like<br>&gt; unsafeRetain() &amp; unsafeRelease().<br></p><p>OK.<br></p><p>&gt; 2) I then abuse Unmanaged&#39;s capabilities a second time to retain the elements<br>&gt; when the collection is copied (which would happen &#39;automatically&#39; with<br>&gt; ARC).<br>&gt;<br>&gt; Btw, with Swift 2.2 under WMO the performance of a normal ManagedBuffer<br>&gt; is on par with this &quot;hack&quot;. Go Swift team!<br></p><p>:-)<br></p><p>&gt;&gt;&gt; The other project was a simple 2D sprite engine (think a simplified<br>&gt;&gt;&gt; version of SpriteKit) I experimented with about a year ago.<br>&gt;&gt;&gt; Textures and Shaders were abstracted as value types privately backed<br>&gt;&gt;&gt; by reference types that managed the underlying OpenGL objects,<br>&gt;&gt;&gt; i.e. destroy the OpenGL texture object on deinit, etc...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I found this to be quite nice to use but ARC overhead during batching<br>&gt;&gt;&gt; &amp; rendering amounted to something like 20-30% of CPU time IIRC. (This<br>&gt;&gt;&gt; was under Swift 1.2 and with WMO). Using `Unmanaged` was one of the<br>&gt;&gt;&gt; things I played around with to get around this and it worked very<br>&gt;&gt;&gt; well.<br>&gt;&gt; <br>&gt;&gt; Another case where you can use unowned(unsafe), is it not?<br>&gt;<br>&gt; Indeed, and that was what I originally tried to use.<br>&gt; Ultimately i settled on Unmanaged however. Now it&#39;s been a long time and<br>&gt; I don&#39;t recall the exact details so take this with a grain of salt: <br>&gt;<br>&gt; One reason certainly was that I ended up needing Unmanaged anyway<br>&gt; to perform manual retain &amp; releases at which point why not also use it<br>&gt; for &#39;storage&#39;...<br>&gt;<br>&gt; But I also vaguely recall that Unmanaged had more of a performance impact.<br>&gt; Now one possibility is that there was some issue with unowned(unsafe) (this<br>&gt; was with 1.2.Œ≤1) but much more likely is that Unmanaged was easier to apply<br>&gt; consistently and correctly.<br>&gt; e.g. assume you have some struct that contains an unowned(unsafe) variable.<br>&gt; Now if you extract that into a local variable you add a perhaps unwanted<br>&gt; retain/release so you might need to mark the local variable as unowned(unsafe)<br>&gt; as well, etc...<br></p><p>Right; makes sense.<br></p><p>&gt; <br>&gt; What I&#39;m trying to say is that with unowned you need to be careful and<br>&gt; considerate with how you use it at all times since the &#39;obvious&#39; thing<br>&gt; generally leads to retain/release.  <br></p><p>That&#39;s safer, though, but in this case you&#39;re more concerned about performance.<br></p><p>&gt; Unmanaged is fine to pass around, store in a local variable,<br>&gt; etc... and any ARC related interactions are obvious because they<br>&gt; manifest as method calls on the Unmanaged instance.<br>&gt;<br>&gt; For their main application, breaking retain cycles, weak and unowned work fine<br>&gt; because you want to retain the objects when they are not &#39;at rest&#39;.<br>&gt; But if you want to avoid retains even when working with the objects, a type is<br>&gt; just a much more comfortable way to handle this.<br>&gt; Like I mentioned before, I imagine that in many cases you&#39;ll end up making a<br>&gt; custom wrapper anyway but it&#39;s something I&#39;m a bit apprehensive about.<br>&gt;<br>&gt; Still, I think unowned(unsafe) together with unsafeRetain() and unsafeRelease()<br>&gt; free functions makes for a nicer API and I don&#39;t think I can adequately judge it<br>&gt; beyond that. I&#39;ve barely used this in it&#39;s current form have no real experience<br>&gt; with a potential future form and I hopefully won&#39;t use it (often) anyway.<br>&gt; So I think it&#39;s more than appropriate to prioritize the general API over making<br>&gt; this esoteric use case more comfortable to use.<br></p><p>I think you&#39;ve already talked me into the idea that we need a type for<br>transporting manually reference-counted references.<br></p><p>&gt;&gt;&gt; The `Unmanaged` instances were created when draw commands are<br>&gt;&gt;&gt; submitted to the renderer so they were only used inside the rendering<br>&gt;&gt;&gt; pipeline.<br>&gt;&gt;&gt; I eventually switched to using the OpenGL names (i.e. UInts) directly<br>&gt;&gt;&gt; inside the renderer since they are already available anyway but that<br>&gt;&gt;&gt; also requires extra logic to ensure the resources are not destroyed<br>&gt;&gt;&gt; prematurely (e.g. retaining the object until the end of the frame or<br>&gt;&gt;&gt; delaying the cleanup of the OpenGL resources until the end of the<br>&gt;&gt;&gt; frame, ...). In many ways it&#39;s quite a bit messier than just using<br>&gt;&gt;&gt; `Unmanaged`.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how Unmanaged could have been less messy; don&#39;t you still<br>&gt;&gt; need a strong reference somewhere to ensure the lifetime?<br>&gt;<br>&gt; Absolutely. You can retain the object directly through Unmanaged<br>&gt; (via passRetained() or retain()) and make the Unmanaged instance<br>&gt; a strong reference in effect.<br></p><p>Right.  Thanks for refreshing my ability to think about these issues<br>again :-)<br></p><p>&gt; Not a big difference to retaining by putting the objects in some container.<br>&gt; Just a different set of tradeoffs.<br>&gt;<br>&gt; I don&#39;t think it&#39;s the best solution for this case but it&#39;s pretty simple. Retain<br>&gt; when creating the draw command, release when discarding the draw<br>&gt; command - nothing different than malloc/free.<br>&gt;<br>&gt; Collecting the objects in some collection is likely to be a cleaner solution<br>&gt; and more efficient too, since you don&#39;t retain objects multiple times if they are<br>&gt; used multiple times in the same frame (which is likely for shaders, textures).<br>&gt; But then someone somewhere needs to manage this, and you need to<br>&gt; access that state when creating or submitting the draw command.<br>&gt;<br>&gt; Or perhaps make sure the referenced resources stay valid until the frame<br>&gt; is drawn so you don&#39;t need to retain here at all but now you need to track<br>&gt; all the scene contents, etc...<br>&gt;<br>&gt; Hopefully I don&#39;t come across as too petulant. :-)<br></p><p>Not a bit.<br></p><p>&gt; I don&#39;t really want to argue in favor of or defend these approaches.<br>&gt; I&#39;m merely trying to give some examples of when and what for I actually<br>&gt; used this stuff not to prove the merits of these cases but instead to argue<br>&gt; for the existence of better justified uses based on the same ideas.<br>&gt; Not sure if that makes any sense but there you go :-)<br></p><p>Thanks, it&#39;s been very helpful.<br></p><p>&gt;&gt;&gt; I don&#39;t think these are particularly great examples and I could<br>&gt;&gt;&gt; certainly live without &#39;native&#39; MRC but ultimately I think it&#39;s an<br>&gt;&gt;&gt; interesting capability so I&#39;d like to keep it around. <br>&gt;&gt;&gt; Although I&#39;d be in favor of keeping it out of the stdlib but I don&#39;t<br>&gt;&gt;&gt; think that&#39;s really an option just yet...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would also be interesting to be able to do the same with indirect<br>&gt;&gt;&gt; enum instances and closures but it&#39;s not like I have a particular use<br>&gt;&gt;&gt; case for that ;-)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t understand what you might be hinting at here.<br>&gt;<br>&gt; Just that AFAIK closures and indirect enum instances also use ARCed<br>&gt; references under the hood. So in theory the could potentially also be<br>&gt; stored unowned and manually retained/released.<br>&gt;<br>&gt; I just find it slightly interesting that with (Any)Objects certain things are<br>&gt; exposed (unsafeAddressOf, retain/release, ...) whereas with indirect enums<br>&gt; and closures they are not.<br>&gt;<br>&gt; I don&#39;t want to imply that that would be a good idea and it would certainly<br>&gt; be hard, complicated, and annoying to implement with essentially n<br>&gt; benefit so I don&#39;t want to go anywhere with this other than the partial similarity.<br>&gt;<br>&gt; Basically it&#39;s just my brain going:<br>&gt; &quot;Oh look, some pyramids. Hmm, you could store these much more efficiently<br>&gt; if you stacked them up against each other&quot; ;-)<br></p><p>Say, you must be some kind of engineer or something! ;-)<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 22 Feb 2016, at 16:45, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; on Mon Feb 22 2016, Janosch Hildebrand &lt;jnosh-AT-jnosh.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But yeah, that would work as well and might be a nicer solution overall.<br>&gt;&gt; (And you could easily create your own type from these + unowned(unsafe))<br>&gt;&gt; <br>&gt;&gt; The downside I see is that being free functions and working with<br>&gt;&gt; AnyObject makes them much more discoverable than being hidden<br>&gt;&gt; inside some other type. <br>&gt; <br>&gt; How discoverable *are* free functions, really, after all?  If you want<br>&gt; we could nest them:<br>&gt; <br>&gt; enum UnsafeManualReferenceCounting {<br>&gt; static func retain(AnyObject) {...}<br>&gt; static func release(AnyObject) {...}<br>&gt; }<br></p><p>I try to have a general overview of the standard library in terms of what is<br>available and how it is structured. And the stdlib is compact enough that<br>that is feasible.<br></p><p>Now a type naturally scopes and encloses functionality so I don&#39;t (need to)<br>have as precise a mental overview over the type&#39;s members &amp; methods.<br>Knowing the type or how to find it also means that &#39;lookups&#39; via auto-<br>completion or documentation will produce a relatively narrow set of results<br>for me to process.<br></p><p>Finding a free function that way is much harder. The enclosing scope is<br>much larger so autocompletion for example becomes pretty much useless<br>unless you already know what you are looking for. This is even worse if you<br>have Darwin imported (unless you do &#39;Swift.&#39;).<br></p><p>So I want a decent overview over what free functions are available because<br>I probably should know about them before I need them. Being free functions<br>also signals that they are potentially special or different in some way so that<br>also makes them of interest.<br></p><p>Now this is mostly a sub- or semi-concious affair and I have no idea how<br>other people approach this...<br></p><p><br>That said if this has&#39;t been an issue with other unsafe* function then I<br>doubt it would be one in this case.<br>And nesting them doesn&#39;t feel right without any other precedent and<br>opens up the discussion about nesting other free functions which is<br>probably not something we want to do right now.<br></p><p><br>&gt;&gt; But given the other unsafe* free functions that&#39;s already exists that<br>&gt;&gt; might be fine.<br>&gt; <br>&gt; Yeah, IMO that would be reasonable.<br>&gt; <br>&gt;&gt; Also having a predefined wrapper type has some use, e.g. when you<br>&gt;&gt; want to store your unowned(unsafe) objects into some collection.<br>&gt; <br>&gt; Yeah, though it seems to me that wrapper should be UnsafeReference&lt;T&gt;.<br></p><p>Yes, it would certainly be the simplest solution.<br></p><p>IIRC, my biggest concern with that was that this continues to combine<br>&quot;transfer unannotated objects&quot; and &quot;manual reference counting&quot; into a<br>single type. Which might make it harder for someone new to the topic<br>that just needs to use some object that comes from an unannotated API.<br></p><p>But again that is probably not a huge issue in practice and we have the<br>same issue with Unmanaged today. Also UnsafeReference&#39;s improved<br>method names &amp; documentation should hopefully mitigate this as well.<br></p><p>A dedicated type or free functions have other tradeoffs so ultimately I&#39;m<br>pretty much open to any of these given that, as you mentioned, MRC is<br>probably going to be retained (no pun intended) in some form...<br></p><p>&gt;&gt; But I&#39;d guess you&#39;ll end up with a dedicated wrapper type anyway in<br>&gt;&gt; most circumstances where this is an issue so it&#39;s probably OK.  And<br>&gt;&gt; this gets rid of having a separate type that also plays the role of<br>&gt;&gt; unowned(unsafe) which seems like a plus.<br>&gt;&gt; <br>&gt;&gt; I have some more answers below but I&#39;ll summarize my opinion here.<br>&gt;&gt; Preferences (in descending order):<br>&gt;&gt; <br>&gt;&gt; 1) unsafeRetain() + unsafeRelease() + unowned(unsafe)<br>&gt;&gt; 2) &quot;UnsafeReferenceCountedPointer&quot;<br>&gt;&gt; 3) No dedicated functionality so just abuse UnsafeReference instead of<br>&gt;&gt;   Unmanaged<br>&gt;&gt; <br>&gt;&gt; I think ultimately it&#39;s a question of whether we want to expose the<br>&gt;&gt; reference counting implementation to manual use...<br>&gt;&gt; <br>&gt;&gt; Is it something I can live without? Absolutely.<br>&gt;&gt; Is it something I would use often? Absolutely not.<br>&gt;&gt; But then again, it is going to be exposed through UnsafeReference anyway.<br>&gt;&gt; <br>&gt;&gt; And having access to a solid manual reference counting solution<br>&gt;&gt; that integrates very well with the rest of the language is kinda neat in<br>&gt;&gt; my opinion. And the integration with ARC is something an external<br>&gt;&gt; library cannot provide without becoming even more &quot;hacky&quot;.<br>&gt;&gt; And I don&#39;t think it&#39;s any more dangerous than any other manual<br>&gt;&gt; memory management we have access to. <br>&gt; <br>&gt; Okay.  My current feeling about all this is that UnsafeReference should<br>&gt; have retain and release directly on it, for MRC.<br>&gt; <br>&gt; The thing I&#39;m really unclear about at this point is whether it&#39;s<br>&gt; reasonable to ask users to use ‚Äúrelease()‚Äù for the maximally-safe usage<br>&gt; pattern, or if that&#39;s just too weird.  My sense all along has been that<br>&gt; asking them to get used to it is a much better design choice than<br>&gt; expanding the API, especially when we don&#39;t really have a better name for<br>&gt; it than ‚Äúrelease.‚Äù  If a better name presented itself, that might change<br>&gt; the picture.<br></p><p>I&#39;ve taken issue with it before but I&#39;ve reread the thread and I still don&#39;t have<br>any new ideas.<br></p><p>I think &#39;transferByReleasing()&#39; &amp; &#39;transfer()&#39; as suggested by Nevin might be<br>my favorite of the proposed alternatives. Other verbs than &#39;transfer&#39; might<br>work too.<br>Whether it&#39;s better than release() and .object... I don&#39;t know.<br></p><p>At any rate, at least retain() would fit somewhat nicely in the state diagram<br>described by the &quot;ownership states&quot; section so retain() could be documented<br>as going from Unretained-&gt;Retained.<br></p><p>But I don&#39;t know what the plan would be regarding documentation if MRC<br>behaviour is done through UnsafeReference. Trying to document it would<br>probably really detract from and add confusion to the simple model that<br>is currently laid out.<br></p><p><br>[Quick aside : I was looking at the draft for UnsafeReference as quoted in<br>Proposal 6 and there is a period missing after<br>&quot;No API should pass or return a *released* UnsafeReference`&quot;<br>and a double-space right before the sentence (and in a few other places).]<br></p><p>&gt;&gt; I also wonder if it has some minor use for learning/teaching.<br>&gt;&gt; Yes, ARC is great because most of the time you don&#39;t need to think<br>&gt;&gt; about this but if you&#39;re trying to understand reference counting it&#39;s<br>&gt;&gt; kinda nice to be able to actually interact and play around with it.<br>&gt;&gt; Then again I&#39;m the kind of person that likes doing that but YMMV...<br>&gt; <br>&gt; As long as you don&#39;t need to share anything across threads, it&#39;s easy<br>&gt; enough to build MRC using malloc, free, and a counter in each allocated<br>&gt; block, so this doesn&#39;t sound like a strong argument to me.<br></p><p>Right and it&#39;s certainly no justification for the feature by itself.<br></p><p>I think it could be nice as a real world example / demonstration tool though.<br>Along the lines of:<br>&quot;So you&#39;ve been learning about ref counting now and you&#39;ve also been using<br>Swift. Well guess what, Swift does that and you can even watch it do its thing&quot;.<br></p><p>Demystifying the &quot;magic&quot; in complex systems with simple building blocks is<br>something I love about all of Science and Engineering.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt; As Joe mentioned, `Unmanaged` has a use for manual ref counting<br>&gt;&gt;&gt;&gt;&gt;&gt; beyond immediate transfer from un-annotated APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have used it for performance reasons myself (~ twice) and while I<br>&gt;&gt;&gt;&gt;&gt;&gt; think it&#39;s a pretty small use case there isn&#39;t really any<br>&gt;&gt;&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt; If it would help I can also describe my use-cases in more detail.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes please!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One place I used Unmanaged is in a small project where I experiment<br>&gt;&gt;&gt;&gt; with binary heaps in Swift. I&#39;ve put the project on Github<br>&gt;&gt;&gt;&gt; --(https://github.com/Jnosh/SwiftBinaryHeapExperiments) but basically<br>&gt;&gt;&gt;&gt; I&#39;m using `Unmanaged` in two places here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) Testing the &#39;overhead&#39; of (A)RC.<br>&gt;&gt;&gt;&gt; Basically comparing the performance of using ARC-managed objects in<br>&gt;&gt;&gt;&gt; the heaps vs. using &#39;unmanaged&#39; objects. In Swift 1.2 the difference<br>&gt;&gt;&gt;&gt; was still ~2x but with Swift 2+ it&#39;s likely approaching the cost of<br>&gt;&gt;&gt;&gt; the retain/release when entering and exiting the collection.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now this could also be accomplished using `unowned(unsafe)` but<br>&gt;&gt;&gt;&gt; `Unmanaged` has some minor advantages:<br>&gt;&gt;&gt;&gt; 	a) I can keep the objects alive without keeping them in a<br>&gt;&gt;&gt;&gt; separate collection. Not a big issue here since I&#39;m doing that anyway<br>&gt;&gt;&gt;&gt; but I also find that `Unmanaged` makes it clearer that &amp; how the<br>&gt;&gt;&gt;&gt; objects are (partly) manually managed.<br>&gt;&gt;&gt;&gt; 	b) I had previously experimented with using `unowned(unsafe)`<br>&gt;&gt;&gt;&gt; for this purpose but found that `Unmanaged` performed better. However,<br>&gt;&gt;&gt;&gt; that was in a more complex example and in the Swift 1.2 era. A quick<br>&gt;&gt;&gt;&gt; test indicates that in this case and with Swift 2.1 `unowned(unsafe)`<br>&gt;&gt;&gt;&gt; and `Unmanaged` perform about equally.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They should.  unowned(unsafe) var T is essentially just an<br>&gt;&gt;&gt; UnsafePointer.  unowned/unowned(safe) do incur reference-counting cost<br>&gt;&gt;&gt; in exchange for their safety.<br>&gt;&gt; <br>&gt;&gt; I&#39;ll come back to this further down.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) A (object only) binary heap that uses `Unmanaged` internally<br>&gt;&gt;&gt;&gt; Not much practical use either in this case since the compiler seems to<br>&gt;&gt;&gt;&gt; do quite well by itself but still a somewhat interesting exercise.<br>&gt;&gt;&gt;&gt; `Unmanaged` is pretty much required here to make CoW work by manually<br>&gt;&gt;&gt;&gt; retaining the objects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s hard for me to imagine why that would be the case.  Would I have<br>&gt;&gt;&gt; needed to use Unmanaged in implementing Arrays of objects, if it were?<br>&gt;&gt; <br>&gt;&gt; Sorry, I wasn&#39;t clear enough. I (ab)use Unmanaged for two different reasons here.<br>&gt;&gt; <br>&gt;&gt; 1) To have a performance baseline where the ARC overhead inside the collection<br>&gt;&gt; is essentially zero beyond the mandatory retain on insert, i.e. as if the compiler was<br>&gt;&gt; able to eliminate all (redundant) retains and releases.<br>&gt;&gt; <br>&gt;&gt; One part of this is exempting the objects from ARC which is is done by storing the<br>&gt;&gt; elements in Unmanaged instances but a wrapper type using unowned(unsafe)<br>&gt;&gt; would work just as well.<br>&gt;&gt; <br>&gt;&gt; However, I still need a strong reference to the objects to keep them alive. Using a<br>&gt;&gt; separate data structure would work but that has a space, time and code complexity<br>&gt;&gt; cost.<br>&gt;&gt; Instead I use Unmanaged to manually retain the objects on insert and release on<br>&gt;&gt; removal. unowned cannot do that on its own hence the need for something like<br>&gt;&gt; unsafeRetain() &amp; unsafeRelease().<br>&gt; <br>&gt; OK.<br>&gt; <br>&gt;&gt; 2) I then abuse Unmanaged&#39;s capabilities a second time to retain the elements<br>&gt;&gt; when the collection is copied (which would happen &#39;automatically&#39; with<br>&gt;&gt; ARC).<br>&gt;&gt; <br>&gt;&gt; Btw, with Swift 2.2 under WMO the performance of a normal ManagedBuffer<br>&gt;&gt; is on par with this &quot;hack&quot;. Go Swift team!<br>&gt; <br>&gt; :-)<br>&gt; <br>&gt;&gt;&gt;&gt; The other project was a simple 2D sprite engine (think a simplified<br>&gt;&gt;&gt;&gt; version of SpriteKit) I experimented with about a year ago.<br>&gt;&gt;&gt;&gt; Textures and Shaders were abstracted as value types privately backed<br>&gt;&gt;&gt;&gt; by reference types that managed the underlying OpenGL objects,<br>&gt;&gt;&gt;&gt; i.e. destroy the OpenGL texture object on deinit, etc...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I found this to be quite nice to use but ARC overhead during batching<br>&gt;&gt;&gt;&gt; &amp; rendering amounted to something like 20-30% of CPU time IIRC. (This<br>&gt;&gt;&gt;&gt; was under Swift 1.2 and with WMO). Using `Unmanaged` was one of the<br>&gt;&gt;&gt;&gt; things I played around with to get around this and it worked very<br>&gt;&gt;&gt;&gt; well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another case where you can use unowned(unsafe), is it not?<br>&gt;&gt; <br>&gt;&gt; Indeed, and that was what I originally tried to use.<br>&gt;&gt; Ultimately i settled on Unmanaged however. Now it&#39;s been a long time and<br>&gt;&gt; I don&#39;t recall the exact details so take this with a grain of salt: <br>&gt;&gt; <br>&gt;&gt; One reason certainly was that I ended up needing Unmanaged anyway<br>&gt;&gt; to perform manual retain &amp; releases at which point why not also use it<br>&gt;&gt; for &#39;storage&#39;...<br>&gt;&gt; <br>&gt;&gt; But I also vaguely recall that Unmanaged had more of a performance impact.<br>&gt;&gt; Now one possibility is that there was some issue with unowned(unsafe) (this<br>&gt;&gt; was with 1.2.Œ≤1) but much more likely is that Unmanaged was easier to apply<br>&gt;&gt; consistently and correctly.<br>&gt;&gt; e.g. assume you have some struct that contains an unowned(unsafe) variable.<br>&gt;&gt; Now if you extract that into a local variable you add a perhaps unwanted<br>&gt;&gt; retain/release so you might need to mark the local variable as unowned(unsafe)<br>&gt;&gt; as well, etc...<br>&gt; <br>&gt; Right; makes sense.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; What I&#39;m trying to say is that with unowned you need to be careful and<br>&gt;&gt; considerate with how you use it at all times since the &#39;obvious&#39; thing<br>&gt;&gt; generally leads to retain/release.  <br>&gt; <br>&gt; That&#39;s safer, though, but in this case you&#39;re more concerned about performance.<br></p><p>Yep. In my experience Unmanaged also worked surprisingly well.<br>You can (and will) of course make all the obvious mistakes but at least it forces<br>you to think about what exactly you want whenever you access it.<br></p><p>And whenever you screw up, all the potential failure points are relatively easy to<br>find since you can mostly just ignore all the &quot;normal&quot; objects.<br></p><p>&gt;&gt; Unmanaged is fine to pass around, store in a local variable,<br>&gt;&gt; etc... and any ARC related interactions are obvious because they<br>&gt;&gt; manifest as method calls on the Unmanaged instance.<br>&gt;&gt; <br>&gt;&gt; For their main application, breaking retain cycles, weak and unowned work fine<br>&gt;&gt; because you want to retain the objects when they are not &#39;at rest&#39;.<br>&gt;&gt; But if you want to avoid retains even when working with the objects, a type is<br>&gt;&gt; just a much more comfortable way to handle this.<br>&gt;&gt; Like I mentioned before, I imagine that in many cases you&#39;ll end up making a<br>&gt;&gt; custom wrapper anyway but it&#39;s something I&#39;m a bit apprehensive about.<br>&gt;&gt; <br>&gt;&gt; Still, I think unowned(unsafe) together with unsafeRetain() and unsafeRelease()<br>&gt;&gt; free functions makes for a nicer API and I don&#39;t think I can adequately judge it<br>&gt;&gt; beyond that. I&#39;ve barely used this in it&#39;s current form have no real experience<br>&gt;&gt; with a potential future form and I hopefully won&#39;t use it (often) anyway.<br>&gt;&gt; So I think it&#39;s more than appropriate to prioritize the general API over making<br>&gt;&gt; this esoteric use case more comfortable to use.<br>&gt; <br>&gt; I think you&#39;ve already talked me into the idea that we need a type for<br>&gt; transporting manually reference-counted references.<br>&gt; <br>&gt;&gt;&gt;&gt; The `Unmanaged` instances were created when draw commands are<br>&gt;&gt;&gt;&gt; submitted to the renderer so they were only used inside the rendering<br>&gt;&gt;&gt;&gt; pipeline.<br>&gt;&gt;&gt;&gt; I eventually switched to using the OpenGL names (i.e. UInts) directly<br>&gt;&gt;&gt;&gt; inside the renderer since they are already available anyway but that<br>&gt;&gt;&gt;&gt; also requires extra logic to ensure the resources are not destroyed<br>&gt;&gt;&gt;&gt; prematurely (e.g. retaining the object until the end of the frame or<br>&gt;&gt;&gt;&gt; delaying the cleanup of the OpenGL resources until the end of the<br>&gt;&gt;&gt;&gt; frame, ...). In many ways it&#39;s quite a bit messier than just using<br>&gt;&gt;&gt;&gt; `Unmanaged`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how Unmanaged could have been less messy; don&#39;t you still<br>&gt;&gt;&gt; need a strong reference somewhere to ensure the lifetime?<br>&gt;&gt; <br>&gt;&gt; Absolutely. You can retain the object directly through Unmanaged<br>&gt;&gt; (via passRetained() or retain()) and make the Unmanaged instance<br>&gt;&gt; a strong reference in effect.<br>&gt; <br>&gt; Right.  Thanks for refreshing my ability to think about these issues<br>&gt; again :-)<br></p><p>:-) I should know better by now but I&#39;m still often surprised how something<br>that felt relatively simple and sensible when writing the code turns out to be<br>very hard to put into words and properly justify.<br></p><p>You had me going back to to some code more than once because I was<br>wondering myself why on earth I couldn&#39;t have just done X.<br></p><p>&gt;&gt; Not a big difference to retaining by putting the objects in some container.<br>&gt;&gt; Just a different set of tradeoffs.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think it&#39;s the best solution for this case but it&#39;s pretty simple. Retain<br>&gt;&gt; when creating the draw command, release when discarding the draw<br>&gt;&gt; command - nothing different than malloc/free.<br>&gt;&gt; <br>&gt;&gt; Collecting the objects in some collection is likely to be a cleaner solution<br>&gt;&gt; and more efficient too, since you don&#39;t retain objects multiple times if they are<br>&gt;&gt; used multiple times in the same frame (which is likely for shaders, textures).<br>&gt;&gt; But then someone somewhere needs to manage this, and you need to<br>&gt;&gt; access that state when creating or submitting the draw command.<br>&gt;&gt; <br>&gt;&gt; Or perhaps make sure the referenced resources stay valid until the frame<br>&gt;&gt; is drawn so you don&#39;t need to retain here at all but now you need to track<br>&gt;&gt; all the scene contents, etc...<br>&gt;&gt; <br>&gt;&gt; Hopefully I don&#39;t come across as too petulant. :-)<br>&gt; <br>&gt; Not a bit.<br>&gt; <br>&gt;&gt; I don&#39;t really want to argue in favor of or defend these approaches.<br>&gt;&gt; I&#39;m merely trying to give some examples of when and what for I actually<br>&gt;&gt; used this stuff not to prove the merits of these cases but instead to argue<br>&gt;&gt; for the existence of better justified uses based on the same ideas.<br>&gt;&gt; Not sure if that makes any sense but there you go :-)<br>&gt; <br>&gt; Thanks, it&#39;s been very helpful.<br>&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think these are particularly great examples and I could<br>&gt;&gt;&gt;&gt; certainly live without &#39;native&#39; MRC but ultimately I think it&#39;s an<br>&gt;&gt;&gt;&gt; interesting capability so I&#39;d like to keep it around. <br>&gt;&gt;&gt;&gt; Although I&#39;d be in favor of keeping it out of the stdlib but I don&#39;t<br>&gt;&gt;&gt;&gt; think that&#39;s really an option just yet...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would also be interesting to be able to do the same with indirect<br>&gt;&gt;&gt;&gt; enum instances and closures but it&#39;s not like I have a particular use<br>&gt;&gt;&gt;&gt; case for that ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t understand what you might be hinting at here.<br>&gt;&gt; <br>&gt;&gt; Just that AFAIK closures and indirect enum instances also use ARCed<br>&gt;&gt; references under the hood. So in theory the could potentially also be<br>&gt;&gt; stored unowned and manually retained/released.<br>&gt;&gt; <br>&gt;&gt; I just find it slightly interesting that with (Any)Objects certain things are<br>&gt;&gt; exposed (unsafeAddressOf, retain/release, ...) whereas with indirect enums<br>&gt;&gt; and closures they are not.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t want to imply that that would be a good idea and it would certainly<br>&gt;&gt; be hard, complicated, and annoying to implement with essentially n<br>&gt;&gt; benefit so I don&#39;t want to go anywhere with this other than the partial similarity.<br>&gt;&gt; <br>&gt;&gt; Basically it&#39;s just my brain going:<br>&gt;&gt; &quot;Oh look, some pyramids. Hmm, you could store these much more efficiently<br>&gt;&gt; if you stacked them up against each other&quot; ;-)<br>&gt; <br>&gt; Say, you must be some kind of engineer or something! ;-)<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p><br>- Janosch<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>February 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 22 Feb 2016, at 23:00, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So I want a decent overview over what free functions are available because<br>&gt; I probably should know about them before I need them. Being free functions<br>&gt; also signals that they are potentially special or different in some way so that<br>&gt; also makes them of interest.<br></p><p>Should the existing documentation be moved to the Swift.org website?<br></p><p>&lt;https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_StandardLibrary_Functions/&gt;<br></p><p>-- Ben<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>RFC: Proposed rewrite of Unmanaged&lt;T&gt;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 1:09 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Please see my comment here &lt;https://github.com/apple/swift-evolution/pull/44#issuecomment-165902471&gt;<br></p><p>I&#39;m open to changing how we import void* from C. I think it&#39;s pretty important that UnsafeReference&#39;s conversion APIs match the C importer&#39;s behavior in any case.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/ca99ad47/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
