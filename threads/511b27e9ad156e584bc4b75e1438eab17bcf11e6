<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 18, 2016 at 09:00:00am</p></header><div class="content"><p>didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br></p><p>-- E, going through her &quot;ttd notes&quot; this morning<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 18, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 to consistency!<br>On Wed, May 18, 2016 at 10:10 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; didSet and willSet remain outliers in the general rule of conjoined<br>&gt; lowercase keywords. Is there any support for bringing these outliers into<br>&gt; the fold?<br>&gt;<br>&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/ab35fe37/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>I would rather like to see them disappear completely — although those &quot;decorators&quot; [is there any established term to describe them?] can be quite handy, they add a lot of special syntax to the language...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 19, 2016 at 08:00:00am</p></header><div class="content"><p>Because some posts explicitly stated the willSet/didSet-functionality should be kept (and I mentioned the option of discarding them):<br>My statement had the same background as Brent&#39;s — I expect there will be a &quot;cleaner&quot; and more versatile replacement in the future, so &quot;don&#39;t fix it if it isn&#39;t broken, and will be replaced soon anyways&quot; ;-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 19, 2016 at 09:00:00am</p></header><div class="content"><p>I don&#39;t see a cleaner solution for observing value change for a property on superclass:<br></p><p>class MyView: UIView {<br></p><p>	override var bounds: CGRect {<br>		didSet { <br>			self._clearCachedValues() <br>		}<br>	}<br></p><p>}<br></p><p>Without didSet, you need to do this:<br></p><p>class MyView: UIView {<br></p><p>	override var bounds: CGRect {<br>		get { <br>			return super.bounds <br>		}<br>		set { <br>			super.bounds = newValue<br>			self._clearCachedValues() <br>		}<br>	}<br></p><p>}<br></p><p>Which is just so painful to type out.<br></p><p>Krystof<br></p><p><br>&gt; On May 19, 2016, at 8:37 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Because some posts explicitly stated the willSet/didSet-functionality should be kept (and I mentioned the option of discarding them):<br>&gt; My statement had the same background as Brent&#39;s — I expect there will be a &quot;cleaner&quot; and more versatile replacement in the future, so &quot;don&#39;t fix it if it isn&#39;t broken, and will be replaced soon anyways&quot; ;-)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 19, 2016 at 05:00:00am</p></header><div class="content"><p>Not really sure, Like the way the camel case ones look. I’m not sure I understand why keywords are lowercase? To reduce clashes with variables?<br></p><p><br>&gt; On 19 May 2016, at 1:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt; <br>&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Erica,<br></p><p>&quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br></p><p>=&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br></p><p>I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br></p><p>And for all the others who want to abolish didSet and willSet completely:<br>NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br></p><p>    public var points: Array&lt;CGPoint&gt; = [] {<br>        didSet {<br>            _area = nil<br>            _centroid = nil<br>        }<br>    }<br></p><p>I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br></p><p>    private var _points: Array&lt;CGPoint&gt; = []<br>    public var points {<br>        get {<br>            return _points<br>        }<br>        set {<br>            _area = nil<br>            _centroid = nil<br>            _points = newValue<br>        }<br>    }<br></p><p>That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br></p><p>-Michael<br></p><p>&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt; <br>&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 on not getting rid of willSet and didSet for sure!<br></p><p>As for naming, it doesn’t bother me much either way, but I think lowercase makes sense with the direction everything else is going.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On May 18, 2016, at 3:38 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Erica,<br>&gt; <br>&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt; <br>&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt; <br>&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt; <br>&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt; <br>&gt;    public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;        didSet {<br>&gt;            _area = nil<br>&gt;            _centroid = nil<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt; <br>&gt;    private var _points: Array&lt;CGPoint&gt; = []<br>&gt;    public var points {<br>&gt;        get {<br>&gt;            return _points<br>&gt;        }<br>&gt;        set {<br>&gt;            _area = nil<br>&gt;            _centroid = nil<br>&gt;            _points = newValue<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt; <br>&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Just some context:<br></p><p>&quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough).  In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers&quot;<br></p><p>and<br></p><p>&quot;On it being a conjoined word, we agreed that the language is currently inconsistent (we have typealias, fallthrough, but also didSet/willSet and @warn_unused_result) and that we should clean it up.  Conjoined feels like the right direction to go for this case.  We didn’t discuss it but IMO, didSet should get lowercased as well.&quot;<br></p><p>-- E<br></p><p><br>&gt; On May 18, 2016, at 2:50 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; +1 on not getting rid of willSet and didSet for sure!<br>&gt; <br>&gt; As for naming, it doesn’t bother me much either way, but I think lowercase makes sense with the direction everything else is going.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 3:38 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Erica,<br>&gt;&gt; <br>&gt;&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt;&gt; <br>&gt;&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt;&gt; <br>&gt;&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt;&gt; <br>&gt;&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt;&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt;&gt; <br>&gt;&gt;   public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;&gt;       didSet {<br>&gt;&gt;           _area = nil<br>&gt;&gt;           _centroid = nil<br>&gt;&gt;       }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt;&gt; <br>&gt;&gt;   private var _points: Array&lt;CGPoint&gt; = []<br>&gt;&gt;   public var points {<br>&gt;&gt;       get {<br>&gt;&gt;           return _points<br>&gt;&gt;       }<br>&gt;&gt;       set {<br>&gt;&gt;           _area = nil<br>&gt;&gt;           _centroid = nil<br>&gt;&gt;           _points = newValue<br>&gt;&gt;       }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Not to mention @NSApplicationMain, @NSManaged, ...<br></p><p>I&#39;d personally keep it camelCase.<br></p><p>&gt; On May 18, 2016, at 10:53 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just some context:<br>&gt; <br>&gt; &quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough).  In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers&quot;<br>&gt; <br>&gt; and<br>&gt; <br>&gt; &quot;On it being a conjoined word, we agreed that the language is currently inconsistent (we have typealias, fallthrough, but also didSet/willSet and @warn_unused_result) and that we should clean it up.  Conjoined feels like the right direction to go for this case.  We didn’t discuss it but IMO, didSet should get lowercased as well.&quot;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 2:50 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 on not getting rid of willSet and didSet for sure!<br>&gt;&gt; <br>&gt;&gt; As for naming, it doesn’t bother me much either way, but I think lowercase makes sense with the direction everything else is going.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 3:38 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt;&gt;&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;&gt;&gt;      didSet {<br>&gt;&gt;&gt;          _area = nil<br>&gt;&gt;&gt;          _centroid = nil<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  private var _points: Array&lt;CGPoint&gt; = []<br>&gt;&gt;&gt;  public var points {<br>&gt;&gt;&gt;      get {<br>&gt;&gt;&gt;          return _points<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;      set {<br>&gt;&gt;&gt;          _area = nil<br>&gt;&gt;&gt;          _centroid = nil<br>&gt;&gt;&gt;          _points = newValue<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b74cd4039f0c53145a186868ab569c0?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Josh Parmenter</string> &lt;jparmenter at vectorform.com&gt;<p>May 18, 2016 at 08:00:00pm</p></header><div class="content"><p>I have a general preference for camelCase as well, but I would prefer consistency in the language over my own personal preference.<br></p><p>Best,<br>Josh<br></p><p>&gt; On May 18, 2016, at 1:56 PM, Krystof Vasa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Not to mention @NSApplicationMain, @NSManaged, ...<br>&gt; <br>&gt; I&#39;d personally keep it camelCase.<br>&gt; <br>&gt;&gt; On May 18, 2016, at 10:53 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just some context:<br>&gt;&gt; <br>&gt;&gt; &quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough).  In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers&quot;<br>&gt;&gt; <br>&gt;&gt; and<br>&gt;&gt; <br>&gt;&gt; &quot;On it being a conjoined word, we agreed that the language is currently inconsistent (we have typealias, fallthrough, but also didSet/willSet and @warn_unused_result) and that we should clean it up.  Conjoined feels like the right direction to go for this case.  We didn’t discuss it but IMO, didSet should get lowercased as well.&quot;<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 2:50 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 on not getting rid of willSet and didSet for sure!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for naming, it doesn’t bother me much either way, but I think lowercase makes sense with the direction everything else is going.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 3:38 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt;&gt;&gt;&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;&gt;&gt;&gt;     didSet {<br>&gt;&gt;&gt;&gt;         _area = nil<br>&gt;&gt;&gt;&gt;         _centroid = nil<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private var _points: Array&lt;CGPoint&gt; = []<br>&gt;&gt;&gt;&gt; public var points {<br>&gt;&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;&gt;         return _points<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;&gt;         _area = nil<br>&gt;&gt;&gt;&gt;         _centroid = nil<br>&gt;&gt;&gt;&gt;         _points = newValue<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 18, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 18.05.2016 um 22:58 schrieb Josh Parmenter via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I have a general preference for camelCase as well, but I would prefer consistency in the language over my own personal preference.<br></p><p>In fact, I wouldn&#39;t care much about the naming. But I don&#39;t like much change. Change is okay if there is a real improvement. But changes for &quot;consistency&quot; have to be very convincing for me to be even considered. After all, &quot;didSet&quot; and &quot;willSet&quot; is what I have learned. And I don&#39;t think that is entirely bad. I&#39;m still open for improvements, but I want to have a feeling that the improvement is bigger than my pain about having to learn something new* . I hope that is not too much to ask for. &quot;Being easy to learn for Swift 2 wizards&quot; should be a medium-priority design goal for Swift 3. That&#39;s just my personal opinion though. Maybe it&#39;s because I have no problem with remembering big amounts of keywords with mixed case and underscore rules. (And Xcode 7.3 turns all these case-issues into non-issues IMHO.)<br></p><p>-Michael<br></p><p>* Learning about Generics is fun. Learning about the new case-changes in Swift 3 is not.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 2:56 PM, Krystof Vasa &lt;kvasa at icloud.com&gt; wrote:<br>&gt; <br>&gt; Not to mention @NSApplicationMain, @NSManaged, ...<br>&gt; <br>&gt; I&#39;d personally keep it camelCase.<br>&gt; <br></p><p>Those are sourced external to Swift.<br></p><p>&gt;&gt; On May 18, 2016, at 10:53 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just some context:<br>&gt;&gt; <br>&gt;&gt; &quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough).  In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers&quot;<br>&gt;&gt; <br>&gt;&gt; and<br>&gt;&gt; <br>&gt;&gt; &quot;On it being a conjoined word, we agreed that the language is currently inconsistent (we have typealias, fallthrough, but also didSet/willSet and @warn_unused_result) and that we should clean it up.  Conjoined feels like the right direction to go for this case.  We didn’t discuss it but IMO, didSet should get lowercased as well.&quot;<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 2:50 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 on not getting rid of willSet and didSet for sure!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for naming, it doesn’t bother me much either way, but I think lowercase makes sense with the direction everything else is going.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 3:38 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt;&gt;&gt;&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;&gt;&gt;&gt;     didSet {<br>&gt;&gt;&gt;&gt;         _area = nil<br>&gt;&gt;&gt;&gt;         _centroid = nil<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private var _points: Array&lt;CGPoint&gt; = []<br>&gt;&gt;&gt;&gt; public var points {<br>&gt;&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;&gt;         return _points<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;&gt;         _area = nil<br>&gt;&gt;&gt;&gt;         _centroid = nil<br>&gt;&gt;&gt;&gt;         _points = newValue<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 18, 2016 at 09:00:00pm</p></header><div class="content"><p>I like them camelCase. <br></p><p>&gt; On May 18, 2016, at 4:58 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 2:56 PM, Krystof Vasa &lt;kvasa at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not to mention @NSApplicationMain, @NSManaged, ...<br>&gt;&gt; <br>&gt;&gt; I&#39;d personally keep it camelCase.<br>&gt; <br>&gt; Those are sourced external to Swift.<br>&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 10:53 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just some context:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough).  In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;On it being a conjoined word, we agreed that the language is currently inconsistent (we have typealias, fallthrough, but also didSet/willSet and @warn_unused_result) and that we should clean it up.  Conjoined feels like the right direction to go for this case.  We didn’t discuss it but IMO, didSet should get lowercased as well.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 2:50 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 on not getting rid of willSet and didSet for sure!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for naming, it doesn’t bother me much either way, but I think lowercase makes sense with the direction everything else is going.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; l8r<br>&gt;&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 3:38 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt;&gt;&gt;&gt;&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;&gt;&gt;&gt;&gt;    didSet {<br>&gt;&gt;&gt;&gt;&gt;        _area = nil<br>&gt;&gt;&gt;&gt;&gt;        _centroid = nil<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private var _points: Array&lt;CGPoint&gt; = []<br>&gt;&gt;&gt;&gt;&gt; public var points {<br>&gt;&gt;&gt;&gt;&gt;    get {<br>&gt;&gt;&gt;&gt;&gt;        return _points<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;    set {<br>&gt;&gt;&gt;&gt;&gt;        _area = nil<br>&gt;&gt;&gt;&gt;&gt;        _centroid = nil<br>&gt;&gt;&gt;&gt;&gt;        _points = newValue<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/74b2be3f33e2efebef65c9a48c32872a?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Angelo Villegas</string> &lt;gelo.web at gmail.com&gt;<p>May 19, 2016 at 10:00:00am</p></header><div class="content"><p>I prefer camelCase but if it&#39;s inconsistent to the current Swift then I guess a review is needed. I would like to add though that a small change of letter case that will break Swift just because it feels inconsistent is a bit over the top. It needs to be reviewed properly.<br></p><p>I&#39;m also against removing it completely. didSet/willSet can be helpful the same as viewWillAppear/viewDidAppear.<br></p><p><br>On 19 May 2016, 9:44 AM +0800, Ricardo Parada via swift-evolution&lt;swift-evolution at swift.org&gt;, wrote:<br>&gt; I like them camelCase.<br>&gt;  <br>&gt; &gt; On May 18, 2016, at 4:58 PM, Erica Sadun via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; &gt; On May 18, 2016, at 2:56 PM, Krystof Vasa&lt;kvasa at icloud.com&gt;wrote:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; Not to mention @NSApplicationMain, @NSManaged, ...<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; I&#39;d personally keep it camelCase.<br>&gt; &gt;  <br>&gt; &gt; Those are sourced external to Swift.<br>&gt; &gt;  <br>&gt; &gt; &gt; &gt; On May 18, 2016, at 10:53 PM, Erica Sadun via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Just some context:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough). In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers&quot;<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; and<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &quot;On it being a conjoined word, we agreed that the language is currently inconsistent (we have typealias, fallthrough, but also didSet/willSet and @warn_unused_result) and that we should clean it up. Conjoined feels like the right direction to go for this case. We didn’t discuss it but IMO, didSet should get lowercased as well.&quot;<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; -- E<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; On May 18, 2016, at 2:50 PM, Sean Heber&lt;sean at fifthace.com&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; +1 on not getting rid of willSet and didSet for sure!<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; As for naming, it doesn’t bother me much either way, but I think lowercase makes sense with the direction everything else is going.<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; l8r<br>&gt; &gt; &gt; &gt; &gt; Sean<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; On May 18, 2016, at 3:38 PM, Michael Peternell via swift-evolution&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; Hi Erica,<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; =&gt;I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt; &gt; &gt; &gt; &gt; &gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; public var points: Array&lt;CGPoint&gt;= [] {<br>&gt; &gt; &gt; &gt; &gt; &gt; didSet {<br>&gt; &gt; &gt; &gt; &gt; &gt; _area = nil<br>&gt; &gt; &gt; &gt; &gt; &gt; _centroid = nil<br>&gt; &gt; &gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; private var _points: Array&lt;CGPoint&gt;= []<br>&gt; &gt; &gt; &gt; &gt; &gt; public var points {<br>&gt; &gt; &gt; &gt; &gt; &gt; get {<br>&gt; &gt; &gt; &gt; &gt; &gt; return _points<br>&gt; &gt; &gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt; &gt; &gt; set {<br>&gt; &gt; &gt; &gt; &gt; &gt; _area = nil<br>&gt; &gt; &gt; &gt; &gt; &gt; _centroid = nil<br>&gt; &gt; &gt; &gt; &gt; &gt; _points = newValue<br>&gt; &gt; &gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; -Michael<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution&lt;swift-evolution at swift.org&gt;:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;  <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/8465e46f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 18, 2016 at 07:00:00pm</p></header><div class="content"><p>I really don&#39;t want didSet and willSet to be changed.<br></p><p>Will changing them make them easier to tell apart from each other? I don&#39;t think so. I think it&#39;ll only make it slightly harder, now that there isn&#39;t a easily-identifiable visual cue that groups &quot;didSet&quot; and &quot;willSet&quot; on one hand, and &quot;set&quot; and &quot;get&quot; on the other.<br></p><p>Are &quot;didSet&quot; and &quot;willSet&quot; used in the Swift grammar in a way where they might be confused with a type, identifier, or other language construct? I don&#39;t think so either. They can only be used to open a curly-brace delimited clause within a property definition. That&#39;s the only place they show up, and the way in which they are used is highly formulaic.<br></p><p>What is the primary reason to change them? If it&#39;s consistency, why then is this (rather synthetic form of) consistency an end, rather than a means to an end? Code is, after all, meant to be read by human beings, and human beings still care about aesthetics and things being easy and pleasant to look at, where &#39;easy to look at&#39; and &#39;consistent&#39; aren&#39;t the same.<br></p><p>By the way, fun fact - if you try to use &quot;didSet&quot; in a subscript the error message reads &quot;DidSet is not allowed in subscripts.&quot; That should probably be fixed. (Xcode 7.3.1.)<br></p><p>Austin<br></p><p><br>&gt; On May 18, 2016, at 7:42 PM, Angelo Villegas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I prefer camelCase but if it&#39;s inconsistent to the current Swift then I guess a review is needed. I would like to add though that a small change of letter case that will break Swift just because it feels inconsistent is a bit over the top. It needs to be reviewed properly.<br>&gt; <br>&gt; I&#39;m also against removing it completely. didSet/willSet can be helpful the same as viewWillAppear/viewDidAppear.<br>&gt; <br>&gt; <br>&gt; On 19 May 2016, 9:44 AM +0800, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt;, wrote:<br>&gt;&gt; I like them camelCase.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 4:58 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 2:56 PM, Krystof Vasa &lt;kvasa at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not to mention @NSApplicationMain, @NSManaged, ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d personally keep it camelCase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those are sourced external to Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 10:53 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just some context:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough). In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;On it being a conjoined word, we agreed that the language is currently inconsistent (we have typealias, fallthrough, but also didSet/willSet and @warn_unused_result) and that we should clean it up. Conjoined feels like the right direction to go for this case. We didn’t discuss it but IMO, didSet should get lowercased as well.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 2:50 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 on not getting rid of willSet and didSet for sure!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As for naming, it doesn’t bother me much either way, but I think lowercase makes sense with the direction everything else is going.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; l8r<br>&gt;&gt;&gt;&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 3:38 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Erica,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; didSet {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _area = nil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _centroid = nil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; private var _points: Array&lt;CGPoint&gt; = []<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public var points {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; get {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return _points<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; set {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _area = nil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _centroid = nil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _points = newValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 19, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 18 May 2016, at 21:53, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just some context:<br>&gt; <br>&gt; &quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough).  In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers”<br></p><p>Hmm, that’s kind of spurious isn’t it? Camel case has nothing to do with whether the concept referred to is atomic but whether the label for it is composed of multiple words.<br></p><p>If you came across the following <br></p><p>    let databaseTransaction = database.beginTransaction()<br></p><p>you wouldn’t change the T&#39;s to lower case on the grounds that database transactions are atomic.<br></p><p>&gt; <br>&gt; and<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 19, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 1:53 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just some context:<br>&gt; <br>&gt; &quot;We have a few conjoined keywords already (typealias, associatedtype, fallthrough).  In the discussion about these terms, we decided that these read best when all lowercase, because they are treated as atomic concepts by programmers&quot;<br>&gt; <br>&gt; and<br>&gt; <br>&gt; &quot;On it being a conjoined word, we agreed that the language is currently inconsistent (we have typealias, fallthrough, but also didSet/willSet and @warn_unused_result) and that we should clean it up.  Conjoined feels like the right direction to go for this case.  We didn’t discuss it but IMO, didSet should get lowercased as well.”<br></p><p>FWIW, I still agree with the logic you quote.  These seem like they should be lowercase to me.<br></p><p>Although it is not literally the case, programmers will treat them effectively as though they are keywords in the language, and that is what matters.  When we introduce property behaviors, the surface level syntax for this sort of thing is likely to remain the same, and it therefore stands to reason that the behavior “accessors” would follow the same convention as keywords. <br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 19, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; When we introduce property behaviors, the surface level syntax for this sort of thing is likely to remain the same, and it therefore stands to reason that the behavior “accessors” would follow the same convention as keywords.<br></p><p>Yes, but what will the conventions be? Is the accessor for the &quot;did change&quot; behavior going to be `didchange` or `didChange`? If I write a JSON behavior, is my accessor going to be `toJSON` or `tojson`?<br></p><p>*That*—not some general rule about keywords which is primarily designed to address things like `fallthrough` and `associatedtype`—is what I think `willSet` and `didSet` ought to match. Users do not care whether something comes out of the standard library or the language grammar; they care whether it has the feel of other things which fit that syntactic slot.<br></p><p>(For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is more appropriate than `foo.dynamictype` would be.)<br></p><p>Thus, `willSet` and `didSet` should be capitalized like other, user-defined, accessors. If user-defined accessors are not going to go into that syntactic slot, or if they are going to have all-lowercase accessor names, then by all means, lowercase `willSet` and `didSet`. But if user-defined accessors are going to be mixed-case, then `willSet` and `didSet` should be too. And if we aren&#39;t sure whether user-defined accessors will be all-lowercase or mixed case, then let&#39;s not jump the gun and make a change that we&#39;re likely to reverse later.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 20, 2016, at 1:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; When we introduce property behaviors, the surface level syntax for this sort of thing is likely to remain the same, and it therefore stands to reason that the behavior “accessors” would follow the same convention as keywords.<br>&gt; <br>&gt; Yes, but what will the conventions be? Is the accessor for the &quot;did change&quot; behavior going to be `didchange` or `didChange`? If I write a JSON behavior, is my accessor going to be `toJSON` or `tojson`?<br>&gt; <br>&gt; *That*—not some general rule about keywords which is primarily designed to address things like `fallthrough` and `associatedtype`—is what I think `willSet` and `didSet` ought to match. Users do not care whether something comes out of the standard library or the language grammar; they care whether it has the feel of other things which fit that syntactic slot.<br></p><p>+1.  Standard library behaviors should use a convention that is appropriate to recommend for user behaviors as well.<br></p><p>&gt; <br>&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is more appropriate than `foo.dynamictype` would be.)<br></p><p>+1.  &#39;foo.dynamictype&#39; seems strange to me. <br></p><p>&gt; <br>&gt; Thus, `willSet` and `didSet` should be capitalized like other, user-defined, accessors. If user-defined accessors are not going to go into that syntactic slot, or if they are going to have all-lowercase accessor names, then by all means, lowercase `willSet` and `didSet`. But if user-defined accessors are going to be mixed-case, then `willSet` and `didSet` should be too. And if we aren&#39;t sure whether user-defined accessors will be all-lowercase or mixed case, then let&#39;s not jump the gun and make a change that we&#39;re likely to reverse later.<br></p><p>+1.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>I think camelCase is richer and easier to read. <br></p><p>&gt; On May 20, 2016, at 10:26 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 20, 2016, at 1:34 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; When we introduce property behaviors, the surface level syntax for this sort of thing is likely to remain the same, and it therefore stands to reason that the behavior “accessors” would follow the same convention as keywords.<br>&gt;&gt; <br>&gt;&gt; Yes, but what will the conventions be? Is the accessor for the &quot;did change&quot; behavior going to be `didchange` or `didChange`? If I write a JSON behavior, is my accessor going to be `toJSON` or `tojson`?<br>&gt;&gt; <br>&gt;&gt; *That*—not some general rule about keywords which is primarily designed to address things like `fallthrough` and `associatedtype`—is what I think `willSet` and `didSet` ought to match. Users do not care whether something comes out of the standard library or the language grammar; they care whether it has the feel of other things which fit that syntactic slot.<br>&gt; <br>&gt; +1.  Standard library behaviors should use a convention that is appropriate to recommend for user behaviors as well.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is more appropriate than `foo.dynamictype` would be.)<br>&gt; <br>&gt; +1.  &#39;foo.dynamictype&#39; seems strange to me. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thus, `willSet` and `didSet` should be capitalized like other, user-defined, accessors. If user-defined accessors are not going to go into that syntactic slot, or if they are going to have all-lowercase accessor names, then by all means, lowercase `willSet` and `didSet`. But if user-defined accessors are going to be mixed-case, then `willSet` and `didSet` should be too. And if we aren&#39;t sure whether user-defined accessors will be all-lowercase or mixed case, then let&#39;s not jump the gun and make a change that we&#39;re likely to reverse later.<br>&gt; <br>&gt; +1.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>On May 20, 2016, at 7:26 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is more appropriate than `foo.dynamictype` would be.)<br>&gt; <br>&gt; +1.  &#39;foo.dynamictype&#39; seems strange to me. <br></p><p>foo.dynamicType is broken for other reasons.  I see x.dynamicType as being a named operator (like sizeof) and not a property.  For example, we don’t want .dynamicType to show up in code completion on every value in the universe (&quot;4.dynamicType”, really?).<br></p><p>That argues that it should be spelled as dynamicType(x), and ideally being a standard library feature instead of a keyword.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 12:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On May 20, 2016, at 7:26 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is more appropriate than `foo.dynamictype` would be.)<br>&gt;&gt; <br>&gt;&gt; +1.  &#39;foo.dynamictype&#39; seems strange to me. <br>&gt; <br>&gt; foo.dynamicType is broken for other reasons.  I see x.dynamicType as being a named operator (like sizeof) and not a property.  For example, we don’t want .dynamicType to show up in code completion on every value in the universe (&quot;4.dynamicType”, really?).<br>&gt; <br>&gt; That argues that it should be spelled as dynamicType(x), and ideally being a standard library feature instead of a keyword.<br></p><p>That makes sense.  It never crossed my mind until now, but given that `sizeof` is a standard library feature why isn’t it camel case `sizeOf`?  Is this a case of “term of the art”? <br></p><p>&gt; <br>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>On Fri, May 20, 2016 at 1:16 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 20, 2016, at 12:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On May 20, 2016, at 7:26 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType`<br>&gt; is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I<br>&gt; think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is<br>&gt; more appropriate than `foo.dynamictype` would be.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1.  &#39;foo.dynamictype&#39; seems strange to me.<br>&gt; &gt;<br>&gt; &gt; foo.dynamicType is broken for other reasons.  I see x.dynamicType as<br>&gt; being a named operator (like sizeof) and not a property.  For example, we<br>&gt; don’t want .dynamicType to show up in code completion on every value in the<br>&gt; universe (&quot;4.dynamicType”, really?).<br>&gt; &gt;<br>&gt; &gt; That argues that it should be spelled as dynamicType(x), and ideally<br>&gt; being a standard library feature instead of a keyword.<br>&gt;<br>&gt; That makes sense.  It never crossed my mind until now, but given that<br>&gt; `sizeof` is a standard library feature why isn’t it camel case `sizeOf`?<br>&gt; Is this a case of “term of the art”?<br>&gt;<br></p><p>See: http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830/<br></p><p><br>&gt;<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/a9844eea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 1:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, May 20, 2016 at 1:16 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On May 20, 2016, at 12:41 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On May 20, 2016, at 7:26 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is more appropriate than `foo.dynamictype` would be.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1.  &#39;foo.dynamictype&#39; seems strange to me.<br>&gt; &gt;<br>&gt; &gt; foo.dynamicType is broken for other reasons.  I see x.dynamicType as being a named operator (like sizeof) and not a property.  For example, we don’t want .dynamicType to show up in code completion on every value in the universe (&quot;4.dynamicType”, really?).<br>&gt; &gt;<br>&gt; &gt; That argues that it should be spelled as dynamicType(x), and ideally being a standard library feature instead of a keyword.<br>&gt; <br>&gt; That makes sense.  It never crossed my mind until now, but given that `sizeof` is a standard library feature why isn’t it camel case `sizeOf`?  Is this a case of “term of the art”?<br>&gt; <br>&gt; See: http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830/&gt;<br>Thanks.  That’s what I figured.  :)<br></p><p>&gt;  <br>&gt; <br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/396032c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>I may yet whip up the results of that conversation into a formal proposal,<br>but at the moment I&#39;m unsure whether I myself would prefer the result over<br>the current sizeof().<br>On Fri, May 20, 2016 at 13:50 Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On May 20, 2016, at 1:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Fri, May 20, 2016 at 1:16 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On May 20, 2016, at 12:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On May 20, 2016, at 7:26 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType`<br>&gt;&gt; is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I<br>&gt;&gt; think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is<br>&gt;&gt; more appropriate than `foo.dynamictype` would be.)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; +1.  &#39;foo.dynamictype&#39; seems strange to me.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; foo.dynamicType is broken for other reasons.  I see x.dynamicType as<br>&gt;&gt; being a named operator (like sizeof) and not a property.  For example, we<br>&gt;&gt; don’t want .dynamicType to show up in code completion on every value in the<br>&gt;&gt; universe (&quot;4.dynamicType”, really?).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That argues that it should be spelled as dynamicType(x), and ideally<br>&gt;&gt; being a standard library feature instead of a keyword.<br>&gt;&gt;<br>&gt;&gt; That makes sense.  It never crossed my mind until now, but given that<br>&gt;&gt; `sizeof` is a standard library feature why isn’t it camel case `sizeOf`?<br>&gt;&gt; Is this a case of “term of the art”?<br>&gt;&gt;<br>&gt;<br>&gt; See: http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830/<br>&gt;<br>&gt;<br>&gt; Thanks.  That’s what I figured.  :)<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Chris<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/24070d1c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:41 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On May 20, 2016, at 7:26 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic slot it&#39;s in. That&#39;s not to say I think we should *keep* `dynamicType`, but simply that `foo.dynamicType` is more appropriate than `foo.dynamictype` would be.)<br>&gt;&gt; <br>&gt;&gt; +1.  &#39;foo.dynamictype&#39; seems strange to me. <br>&gt; <br>&gt; foo.dynamicType is broken for other reasons.  I see x.dynamicType as being a named operator (like sizeof) and not a property.  For example, we don’t want .dynamicType to show up in code completion on every value in the universe (&quot;4.dynamicType”, really?).<br>&gt; <br>&gt; That argues that it should be spelled as dynamicType(x), and ideally being a standard library feature instead of a keyword.<br>&gt; <br>&gt; -Chris<br></p><p>Gist: https://gist.github.com/erica/b0155e2f6d96c3d530fdafa9b3bd6272 &lt;https://gist.github.com/erica/b0155e2f6d96c3d530fdafa9b3bd6272&gt;<br></p><p>Moving dynamicType to the standard library<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/b0155e2f6d96c3d530fdafa9b3bd6272#introduction&gt;Introduction<br></p><p>This proposal establishes dynamicType as a named operator rather than a property and moves it to the standard library.<br></p><p> &lt;https://gist.github.com/erica/b0155e2f6d96c3d530fdafa9b3bd6272#motivation&gt;Motivation<br></p><p>In Swift, dynamicType is a property. Because of that, it shows up in code completion as an &quot;appropriate&quot; completion for all values, regardless of whether it makes sense to do so or not. For example, Swift offers 4.dynamicType, myFunction().dynamicType, etc. Rather than express a logical attribute of a specific type, it can be applied to any expression. Since dynamicType behaves more like a operator (like sizeof), its implementation should follow suit.<br></p><p>Moving it to the standard library, allows Swift to remove a keyword and better aligns the functionality with its intended use.<br></p><p> &lt;https://gist.github.com/erica/b0155e2f6d96c3d530fdafa9b3bd6272#detailed-design&gt;Detailed Design<br></p><p>Upon adoption of this proposal, Swift removes the dynamicType keyword and introduces a dynamicType function:<br></p><p>dynamicType(value) // returns the dynamicType of value<br> &lt;https://gist.github.com/erica/b0155e2f6d96c3d530fdafa9b3bd6272#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>Adopting this proposal will break code and require migration support, moving the postfix property syntax into a prefix function call.<br></p><p> &lt;https://gist.github.com/erica/b0155e2f6d96c3d530fdafa9b3bd6272#alternatives-considered&gt;Alternatives Considered<br></p><p>Not adopting this proposal<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/4f1de590/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>On May 19, 2016, at 11:34 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; When we introduce property behaviors, the surface level syntax for this sort of thing is likely to remain the same, and it therefore stands to reason that the behavior “accessors” would follow the same convention as keywords.<br>&gt; <br>&gt; Yes, but what will the conventions be? Is the accessor for the &quot;did change&quot; behavior going to be `didchange` or `didChange`?<br></p><p>I’m arguing for “didchange”.  <br></p><p>To be clear, this is just my personal opinion, but even in the context of a general user-defined behavior, these things seem extremely &quot;keyword like” from the users perspective.  To a user of a behavior, these aspects are not arbitrary user defined names, they are specific things that you can pick from.  The existing accessors clearly work the same way.<br></p><p>&gt; If I write a JSON behavior, is my accessor going to be `toJSON` or `tojson`?<br></p><p>If you’re writing a JSON behavior, including “JSON” in the accessor would be a needless word.  The names for the accessors should describe “aspects” of the behavior they are implementing, not the behavior itself.<br></p><p>That said, you’re right that this could come up.  When and if we have a specific example to discuss, I&#39;m sure we can figure out a reasonable policy.<br></p><p><br>&gt; *That*—not some general rule about keywords which is primarily designed to address things like `fallthrough` and `associatedtype`—is what I think `willSet` and `didSet` ought to match. Users do not care whether something comes out of the standard library or the language grammar; they care whether it has the feel of other things which fit that syntactic slot.<br></p><p>I don’t understand what you’re trying to say here.<br></p><p>&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic <br>&gt; slot it&#39;s in.<br></p><p>As I mentioned down-thread, the problem with .dynamicType is that it is in the wrong slot :-)<br></p><p>&gt; Thus, `willSet` and `didSet` should be capitalized like other, user-defined, accessors.<br></p><p>I agree with your believe that we should treat these just like user-defined accessors.  So lets assume we had an “observed” behavior that had didset/willset aspects that can be specified.  To the implementor of the behavior, these are terms that they define, but to users of the behavior, they are indistinguishable from keywords.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 12:50 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On May 19, 2016, at 11:34 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; When we introduce property behaviors, the surface level syntax for this sort of thing is likely to remain the same, and it therefore stands to reason that the behavior “accessors” would follow the same convention as keywords.<br>&gt;&gt; <br>&gt;&gt; Yes, but what will the conventions be? Is the accessor for the &quot;did change&quot; behavior going to be `didchange` or `didChange`?<br>&gt; <br>&gt; I’m arguing for “didchange”.  <br>&gt; <br>&gt; To be clear, this is just my personal opinion, but even in the context of a general user-defined behavior, these things seem extremely &quot;keyword like” from the users perspective.  To a user of a behavior, these aspects are not arbitrary user defined names, they are specific things that you can pick from.  The existing accessors clearly work the same way.<br>&gt; <br>&gt;&gt; If I write a JSON behavior, is my accessor going to be `toJSON` or `tojson`?<br>&gt; <br>&gt; If you’re writing a JSON behavior, including “JSON” in the accessor would be a needless word.  The names for the accessors should describe “aspects” of the behavior they are implementing, not the behavior itself.<br>&gt; <br>&gt; That said, you’re right that this could come up.  When and if we have a specific example to discuss, I&#39;m sure we can figure out a reasonable policy.<br>&gt; <br>&gt; <br>&gt;&gt; *That*—not some general rule about keywords which is primarily designed to address things like `fallthrough` and `associatedtype`—is what I think `willSet` and `didSet` ought to match. Users do not care whether something comes out of the standard library or the language grammar; they care whether it has the feel of other things which fit that syntactic slot.<br>&gt; <br>&gt; I don’t understand what you’re trying to say here.<br>&gt; <br>&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic <br>&gt;&gt; slot it&#39;s in.<br>&gt; <br>&gt; As I mentioned down-thread, the problem with .dynamicType is that it is in the wrong slot :-)<br>&gt; <br>&gt;&gt; Thus, `willSet` and `didSet` should be capitalized like other, user-defined, accessors.<br>&gt; <br>&gt; I agree with your believe that we should treat these just like user-defined accessors.  So lets assume we had an “observed” behavior that had didset/willset aspects that can be specified.  To the implementor of the behavior, these are terms that they define, but to users of the behavior, they are indistinguishable from keywords.<br></p><p>So you’re arguing that all user-defined accessors in all user-defined behaviors should be all lowercase?  Are we sure that there would be no legitimate accessor names which would be very hard to read without some kind of visible word boundaries?<br></p><p><br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; When we introduce property behaviors, the surface level syntax for this sort of thing is likely to remain the same, and it therefore stands to reason that the behavior “accessors” would follow the same convention as keywords.<br>&gt;&gt; <br>&gt;&gt; Yes, but what will the conventions be? Is the accessor for the &quot;did change&quot; behavior going to be `didchange` or `didChange`?<br>&gt; <br>&gt; I’m arguing for “didchange”.  <br>&gt; <br>&gt; To be clear, this is just my personal opinion, but even in the context of a general user-defined behavior, these things seem extremely &quot;keyword like” from the users perspective.  To a user of a behavior, these aspects are not arbitrary user defined names, they are specific things that you can pick from.  The existing accessors clearly work the same way.<br></p><p>Okay. That was not the answer I expected :^), but if that is your answer, and if you&#39;re pretty confident in that answer, then I support changing willSet and didSet.<br></p><p>&gt;&gt; *That*—not some general rule about keywords which is primarily designed to address things like `fallthrough` and `associatedtype`—is what I think `willSet` and `didSet` ought to match. Users do not care whether something comes out of the standard library or the language grammar; they care whether it has the feel of other things which fit that syntactic slot.<br>&gt; <br>&gt; I don’t understand what you’re trying to say here.<br></p><p>I&#39;m trying to articulate a general rule, that when there is a built-in thing that goes alongside user-defined things, the built-in thing should be capitalized like the user-defined things even if it&#39;s implemented as a &quot;keyword&quot;.<br></p><p>That is, nobody cares whether dynamicType is a keyword or an extension on Any, and nobody cares whether willSet is a keyword or an accessor for a built-in property. Since they behave like something else in the grammar, they should be spelled like that thing, too.<br></p><p>&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic <br>&gt;&gt; slot it&#39;s in.<br>&gt; <br>&gt; As I mentioned down-thread, the problem with .dynamicType is that it is in the wrong slot :-)<br></p><p>I don&#39;t necessarily disagree. What I&#39;m saying is, fake properties should be capitalized like real properties, and fake accessors should be capitalized like real accessors.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>I agree with you completely. I tried to argue the same thing but maybe not as eloquently :P. <br></p><p>I don&#39;t think the qualification should be that all keywords must look a specific way but more like &quot;where does this fit in naturally&quot;. <br></p><p>dynamicType is masquerading as a property and didSet and willSet are acting like methods and I think they should look as such unless they are changed. <br></p><p>Brandon <br></p><p>On May 20, 2016, at 4:02 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt; When we introduce property behaviors, the surface level syntax for this sort of thing is likely to remain the same, and it therefore stands to reason that the behavior “accessors” would follow the same convention as keywords.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but what will the conventions be? Is the accessor for the &quot;did change&quot; behavior going to be `didchange` or `didChange`?<br>&gt;&gt; <br>&gt;&gt; I’m arguing for “didchange”.  <br>&gt;&gt; <br>&gt;&gt; To be clear, this is just my personal opinion, but even in the context of a general user-defined behavior, these things seem extremely &quot;keyword like” from the users perspective.  To a user of a behavior, these aspects are not arbitrary user defined names, they are specific things that you can pick from.  The existing accessors clearly work the same way.<br>&gt; <br>&gt; Okay. That was not the answer I expected :^), but if that is your answer, and if you&#39;re pretty confident in that answer, then I support changing willSet and didSet.<br>&gt; <br>&gt;&gt;&gt; *That*—not some general rule about keywords which is primarily designed to address things like `fallthrough` and `associatedtype`—is what I think `willSet` and `didSet` ought to match. Users do not care whether something comes out of the standard library or the language grammar; they care whether it has the feel of other things which fit that syntactic slot.<br>&gt;&gt; <br>&gt;&gt; I don’t understand what you’re trying to say here.<br>&gt; <br>&gt; I&#39;m trying to articulate a general rule, that when there is a built-in thing that goes alongside user-defined things, the built-in thing should be capitalized like the user-defined things even if it&#39;s implemented as a &quot;keyword&quot;.<br>&gt; <br>&gt; That is, nobody cares whether dynamicType is a keyword or an extension on Any, and nobody cares whether willSet is a keyword or an accessor for a built-in property. Since they behave like something else in the grammar, they should be spelled like that thing, too.<br>&gt; <br>&gt;&gt;&gt; (For instance, a perhaps controversial opinion: I think `dynamicType` is properly capitalized for the syntactic <br>&gt;&gt;&gt; slot it&#39;s in.<br>&gt;&gt; <br>&gt;&gt; As I mentioned down-thread, the problem with .dynamicType is that it is in the wrong slot :-)<br>&gt; <br>&gt; I don&#39;t necessarily disagree. What I&#39;m saying is, fake properties should be capitalized like real properties, and fake accessors should be capitalized like real accessors.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 20, 2016 at 09:00:00pm</p></header><div class="content"><p>If accessors are defined by the developer who designs a property behavior then I do not see them as keywords. Or am I wrong?<br></p><p>That is why I would prefer them lowerCamelCase. <br></p><p><br>On May 20, 2016, at 1:50 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Thus, `willSet` and `didSet` should be capitalized like other, user-defined, accessors.<br>&gt; <br>&gt; I agree with your believe that we should treat these just like user-defined accessors.  So lets assume we had an “observed” behavior that had didset/willset aspects that can be specified.  To the implementor of the behavior, these are terms that they define, but to users of the behavior, they are indistinguishable from keywords.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 21, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, I don’t think they are the same as keywords, and should stay camelCase. Especially if you can define your own with behaviours — it will feel like you are defining your own keywords, which is wrong.<br></p><p>userDefined<br>languagedefined<br></p><p>I’d much prefer to just stay with willSet and didSet. Let’s see what behaviours turn out to be, and design some pinned down rules then.<br></p><p>As Erica said in her post about Swift 3, &quot;Make big breaking changes later and once rather than sooner and multiple times.”<br>http://ericasadun.com/2016/05/18/if-i-had-my-druthers-swift-2-2-swift-3-0-abis-etc/<br></p><p>Chris said &quot;In practice, we can accept both spellings for a long time at no harm to anyone.”, so hopefully as proposed Swift 3 would support both willSet/didSet &amp; willset/didset anyway. So this is a pointless addition with wishes for consistency that won’t be known until property behaviours.<br></p><p>The other proposals for dynamicType etc sound fine to me.<br></p><p><br>&gt; On 21 May 2016, at 11:03 AM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If accessors are defined by the developer who designs a property behavior then I do not see them as keywords. Or am I wrong?<br>&gt; <br>&gt; That is why I would prefer them lowerCamelCase. <br>&gt; <br>&gt; <br>&gt; On May 20, 2016, at 1:50 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Thus, `willSet` and `didSet` should be capitalized like other, user-defined, accessors.<br>&gt;&gt; <br>&gt;&gt; I agree with your believe that we should treat these just like user-defined accessors.  So lets assume we had an “observed” behavior that had didset/willset aspects that can be specified.  To the implementor of the behavior, these are terms that they define, but to users of the behavior, they are indistinguishable from keywords.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 18, 2016 at 05:00:00pm</p></header><div class="content"><p>I may be wrong but I don&#39;t remember any other case of a keyword in<br>Swift composed of two or more words, so I believe these should be<br>exceptions. I would agree best to change these keywords for others<br>consisting of only one word but I myself have no suggestion what those<br>could be. Otherwise I&#39;d rather keep them as-is.<br></p><p>On 18 May 2016 at 17:38, Michael Peternell via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi Erica,<br>&gt;<br>&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt;<br>&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt;<br>&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt;<br>&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt;<br>&gt;     public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;         didSet {<br>&gt;             _area = nil<br>&gt;             _centroid = nil<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt;<br>&gt;     private var _points: Array&lt;CGPoint&gt; = []<br>&gt;     public var points {<br>&gt;         get {<br>&gt;             return _points<br>&gt;         }<br>&gt;         set {<br>&gt;             _area = nil<br>&gt;             _centroid = nil<br>&gt;             _points = newValue<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;<br>&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 18, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt; Swift composed of two or more words, so I believe these should be<br>&gt; exceptions.<br></p><p>`typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 3:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt;&gt; Swift composed of two or more words, so I believe these should be<br>&gt;&gt; exceptions.<br>&gt; <br>&gt; `typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br></p><p>Yeah, some of these changes which may feel like low hanging fruit to some turn out to take a lot of energy.  <br></p><p>If we’re going to pursue more of these kinds of changes, I would prefer a comprehensive proposal that evaluates everything, establishes well defined conventions, and then applies the changes holistically.  <br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Matthew&#39;s right. The first thing here is to define a consistent rule<br>which takes no exceptions and then apply this rule to every existing<br>or new keyword and attribute.<br></p><p>On 18 May 2016 at 18:02, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt;&gt; On May 18, 2016, at 3:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt;&gt;&gt; Swift composed of two or more words, so I believe these should be<br>&gt;&gt;&gt; exceptions.<br>&gt;&gt;<br>&gt;&gt; `typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br>&gt;<br>&gt; Yeah, some of these changes which may feel like low hanging fruit to some turn out to take a lot of energy.<br>&gt;<br>&gt; If we’re going to pursue more of these kinds of changes, I would prefer a comprehensive proposal that evaluates everything, establishes well defined conventions, and then applies the changes holistically.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 19, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 1:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt;&gt; Swift composed of two or more words, so I believe these should be<br>&gt;&gt; exceptions.<br>&gt; <br>&gt; `typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br></p><p>Right, but the catfight had a clear outcome:<br></p><p>1) keywords are conjoined<br>2) attributes are lower camel cased.<br>3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 20, 2016, at 1:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 1:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt;&gt;&gt; Swift composed of two or more words, so I believe these should be<br>&gt;&gt;&gt; exceptions.<br>&gt;&gt; <br>&gt;&gt; `typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br>&gt; <br>&gt; Right, but the catfight had a clear outcome:<br>&gt; <br>&gt; 1) keywords are conjoined<br>&gt; 2) attributes are lower camel cased.<br>&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br></p><p>Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 7:24 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 20, 2016, at 1:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 18, 2016, at 1:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt;&gt;&gt;&gt; Swift composed of two or more words, so I believe these should be<br>&gt;&gt;&gt;&gt; exceptions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br>&gt;&gt; <br>&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt; <br>&gt;&gt; 1) keywords are conjoined<br>&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt; <br>&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br></p><p>I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 7:24 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 1:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 1:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt;&gt;&gt;&gt;&gt; Swift composed of two or more words, so I believe these should be<br>&gt;&gt;&gt;&gt;&gt; exceptions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt; <br>&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt; <br>&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br></p><p>Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:41 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt;&gt; <br>&gt;&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br>&gt; <br>&gt; Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br></p><p>I think that these are the relevant rules.  As I mentioned upthread, .dynamicType is broken for a different reason, and thus leads to a different solution (it should be a global function in the stdlib, not a propery).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:43 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 10:41 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br>&gt;&gt; <br>&gt;&gt; Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br>&gt; <br>&gt; I think that these are the relevant rules.  As I mentioned upthread, .dynamicType is broken for a different reason, and thus leads to a different solution (it should be a global function in the stdlib, not a propery).<br>&gt; <br>&gt; -Chris<br></p><p><br>Separate action items:<br></p><p>* Move dynamicType to standard library as a global function<br>* Rename didSet and willSet to lowercase to conform to Swift standard of conjoined lowercase keywords.<br>* Rename noescape to nonescaping to conform to Swift standard of &quot;non&quot;-modified attributes<br></p><p>Roger that?<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 11:43 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 10:41 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt;&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt;&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br>&gt;&gt; <br>&gt;&gt; I think that these are the relevant rules.  As I mentioned upthread, .dynamicType is broken for a different reason, and thus leads to a different solution (it should be a global function in the stdlib, not a propery).<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Separate action items:<br>&gt; <br>&gt; * Move dynamicType to standard library as a global function<br>&gt; * Rename didSet and willSet to lowercase to conform to Swift standard of conjoined lowercase keywords.<br></p><p>Sounds great.<br></p><p>&gt; * Rename noescape to nonescaping to conform to Swift standard of &quot;non&quot;-modified attributes<br></p><p>I just looked and the one other wrong one we have is “noreturn”.  It would be great to tackle nonescaping and whatever noreturn should be in the same proposal.<br></p><p>Thanks Erica!<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:52 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 20, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 11:43 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 10:41 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that these are the relevant rules.  As I mentioned upthread, .dynamicType is broken for a different reason, and thus leads to a different solution (it should be a global function in the stdlib, not a propery).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Separate action items:<br>&gt;&gt; <br>&gt;&gt; * Move dynamicType to standard library as a global function<br>&gt;&gt; * Rename didSet and willSet to lowercase to conform to Swift standard of conjoined lowercase keywords.<br>&gt; <br>&gt; Sounds great.<br>&gt; <br>&gt;&gt; * Rename noescape to nonescaping to conform to Swift standard of &quot;non&quot;-modified attributes<br>&gt; <br>&gt; I just looked and the one other wrong one we have is “noreturn”.  It would be great to tackle nonescaping and whatever noreturn should be in the same proposal.<br>&gt; <br>&gt; Thanks Erica!<br>&gt; <br>&gt; -Chris<br></p><p>To be clear before I put anything together, `nonreturning`, yes?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/8eac52f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>IMHO noreturn is fine. You are indicating &quot;there is no return from this function&quot;, as in point of no return.<br></p><p>Also, this is kind of an idiom amongst many programming languages...<br></p><p>20. 5. 2016 v 19:55, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 11:52 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 20, 2016, at 11:43 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 20, 2016, at 10:41 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that these are the relevant rules.  As I mentioned upthread, .dynamicType is broken for a different reason, and thus leads to a different solution (it should be a global function in the stdlib, not a propery).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Separate action items:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Move dynamicType to standard library as a global function<br>&gt;&gt;&gt; * Rename didSet and willSet to lowercase to conform to Swift standard of conjoined lowercase keywords.<br>&gt;&gt; <br>&gt;&gt; Sounds great.<br>&gt;&gt; <br>&gt;&gt;&gt; * Rename noescape to nonescaping to conform to Swift standard of &quot;non&quot;-modified attributes<br>&gt;&gt; <br>&gt;&gt; I just looked and the one other wrong one we have is “noreturn”.  It would be great to tackle nonescaping and whatever noreturn should be in the same proposal.<br>&gt;&gt; <br>&gt;&gt; Thanks Erica!<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; To be clear before I put anything together, `nonreturning`, yes?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/bb9a9150/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:58 AM, Krystof Vasa &lt;kvasa at icloud.com&gt; wrote:<br>&gt; <br>&gt; IMHO noreturn is fine. You are indicating &quot;there is no return from this function&quot;, as in point of no return.<br>&gt; <br>&gt; Also, this is kind of an idiom amongst many programming languages...<br></p><p>I&#39;d like a core team call one way or the other.<br></p><p>`nonreturning`: follows rule<br>`noreturn`: term of art exception<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:03 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 20, 2016, at 11:58 AM, Krystof Vasa &lt;kvasa at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; IMHO noreturn is fine. You are indicating &quot;there is no return from this function&quot;, as in point of no return.<br>&gt;&gt; <br>&gt;&gt; Also, this is kind of an idiom amongst many programming languages...<br>&gt; <br>&gt; I&#39;d like a core team call one way or the other.<br>&gt; <br>&gt; `nonreturning`: follows rule<br>&gt; `noreturn`: term of art exception<br></p><p>The core team hasn’t discussed this specifically, and doesn’t have a lot of time for extra bikeshedding meetings at the moment :-).  I’d suggest putting several different options in the proposal so the community can work through it.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:52 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; On May 20, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; On May 20, 2016, at 11:43 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 20, 2016, at 10:41 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that these are the relevant rules.  As I mentioned upthread, .dynamicType is broken for a different reason, and thus leads to a different solution (it should be a global function in the stdlib, not a propery).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; Separate action items:<br>&gt;&gt; <br>&gt;&gt; * Move dynamicType to standard library as a global function<br>&gt;&gt; * Rename didSet and willSet to lowercase to conform to Swift standard of conjoined lowercase keywords.<br>&gt; <br>&gt; Sounds great.<br>&gt; <br>&gt;&gt; * Rename noescape to nonescaping to conform to Swift standard of &quot;non&quot;-modified attributes<br>&gt; <br>&gt; I just looked and the one other wrong one we have is “noreturn”.  It would be great to tackle nonescaping and whatever noreturn should be in the same proposal.<br>&gt; <br>&gt; Thanks Erica!<br>&gt; <br>&gt; -Chris<br></p><p>Please look through and comment:<br></p><p>https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407 &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407&gt;<br></p><p>Gist contents pasted below.<br></p><p>-- Erica<br></p><p><br>Adopting consistent keyword casing in Swift<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#introduction&gt;Introduction<br></p><p>This proposal adopts consistent conjoined keyword lowercasing.<br></p><p>Swift-evolution thread: RFC: didset and willset &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/17534&gt;<br> &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#motivation&gt;Motivation<br></p><p>Swift is an opinionated language. One opinion it adheres to is that keywords should use conjoined lowercasing. Conjoined lowercase terms already in the language include typealias, associatedtype, and fallthrough. Using this casing style enables programmers to treat keywords as atomic concepts. This proposal formalizes this rule and fixes current inconsistencies. <br></p><p> &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#swift-casing-rules-roadmap&gt;Swift Casing Rules Roadmap<br></p><p>This proposal addresses the first of the following Swift casing rules:<br></p><p>Keywords use lower case conjoined naming.<br>Attributes use lower camel cased naming.<br>Attributes use “non” prefixes in preference to &quot;no&quot; prefixes.<br>Compiler-expanded literals use lower camel casing and are prefixed with octothorpes (#)<br>Swift eschews snake casing. (See also: SE-0028 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md&gt;)<br>Terms of art may be exempted from casing rules.<br>Phrases sourced from outside Swift may be exempted from Swift casing rules, e.g. @UIApplicationMain.<br> &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#swift-language-cleanup-roadmap&gt;Swift Language Cleanup Roadmap<br></p><p>This proposal is part of a series that will:<br></p><p>Normalize casing to lower conjoined names.<br>Normalize naming for &quot;negative&quot; attributes (from &quot;noFeature&quot; to &quot;nonfeaturing&quot;).<br>Move dynamicType to the standard library as a global function.<br> &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#detailed-design&gt;Detailed Design<br></p><p>Upon adoption, Swift will rename didSet and willSet to willset and didset. Future expansions to the language will follow this adopted rule, for example didchange.<br></p><p>This proposal deliberately omits the dynamicType keyword, which will be addressed under separate cover: to be moved to the standard library as a standalone global function.<br></p><p> &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal requires migration support to rename keywords that use the old convention to adopt the new convention. This is a simple substitution that should limit effect on code.<br></p><p>This proposal recommends deprecating old-style keywords in Swift 2.3 and removing them in Swift 3.<br></p><p> &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#alternatives-considered&gt;Alternatives Considered<br></p><p>Not adopting this rule for Swift.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/cc1601be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Upon adoption, Swift will rename didSet and willSet to willset and didset. Future expansions to the language will follow this adopted rule, for example didchange.<br></p><p>Might want to switch the order of the two keywords in one of those pairs, unless you&#39;re proposing we prank our user base. :^)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>Fixing<br></p><p>-- E<br></p><p>&gt; On May 20, 2016, at 2:48 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Upon adoption, Swift will rename didSet and willSet to willset and didset. Future expansions to the language will follow this adopted rule, for example didchange.<br>&gt; <br>&gt; Might want to switch the order of the two keywords in one of those pairs, unless you&#39;re proposing we prank our user base. :^)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 3:41 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 20, 2016, at 11:52 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On May 20, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 20, 2016, at 11:43 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On May 20, 2016, at 10:41 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that these are the relevant rules.  As I mentioned upthread, .dynamicType is broken for a different reason, and thus leads to a different solution (it should be a global function in the stdlib, not a propery).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Separate action items:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Move dynamicType to standard library as a global function<br>&gt;&gt;&gt; * Rename didSet and willSet to lowercase to conform to Swift standard of conjoined lowercase keywords.<br>&gt;&gt; <br>&gt;&gt; Sounds great.<br>&gt;&gt; <br>&gt;&gt;&gt; * Rename noescape to nonescaping to conform to Swift standard of &quot;non&quot;-modified attributes<br>&gt;&gt; <br>&gt;&gt; I just looked and the one other wrong one we have is “noreturn”.  It would be great to tackle nonescaping and whatever noreturn should be in the same proposal.<br>&gt;&gt; <br>&gt;&gt; Thanks Erica!<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; Please look through and comment:<br>&gt; <br>&gt; https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407 &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407&gt;<br>&gt; <br>&gt; Gist contents pasted below.<br></p><p>Looks good.  I’m glad to see a proposal to address this holistically.  :)  <br></p><p>I do support Brent’s argument that keywords which syntactically appear in the same syntactic location as user-defined names should follow the same convention as those user-defined names.  This means, for example, that dynamicType already has the correct case even though it is a keyword.  I would like to see this exemption added to the proposal.<br></p><p>Also, with this in mind I would like to see more discussion about the naming convention the community prefers for user-defined behavior accessors (under the assumption that they will make it eventually).  If we agree on lowercase for user-defined accessors (which is Chris’s stated preference) I support the change to willset and didset.  <br></p><p>However, it is possible that this discussion would result in he community agreeing on lower came case for user-defined behavior accessors.  If that is the result then we should not change them.  <br></p><p>Most specifically, I would like the discussion to consider whether there may be reallylongbehavioraccessornames that will be completely unreadable in all lowercase (I’m intentionally giving a very extreme example here).  Swift favors clarity over conciseness when necessary.  Can we really be sure that all accessors for all behaviors will be concise enough for all lowercase names to make sense?<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; Adopting consistent keyword casing in Swift<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal adopts consistent conjoined keyword lowercasing.<br>&gt; <br>&gt; Swift-evolution thread: RFC: didset and willset &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/17534&gt;<br>&gt;  &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#motivation&gt;Motivation<br>&gt; <br>&gt; Swift is an opinionated language. One opinion it adheres to is that keywords should use conjoined lowercasing. Conjoined lowercase terms already in the language include typealias, associatedtype, and fallthrough. Using this casing style enables programmers to treat keywords as atomic concepts. This proposal formalizes this rule and fixes current inconsistencies. <br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#swift-casing-rules-roadmap&gt;Swift Casing Rules Roadmap<br>&gt; <br>&gt; This proposal addresses the first of the following Swift casing rules:<br>&gt; <br>&gt; Keywords use lower case conjoined naming.<br>&gt; Attributes use lower camel cased naming.<br>&gt; Attributes use “non” prefixes in preference to &quot;no&quot; prefixes.<br>&gt; Compiler-expanded literals use lower camel casing and are prefixed with octothorpes (#)<br>&gt; Swift eschews snake casing. (See also: SE-0028 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md&gt;)<br>&gt; Terms of art may be exempted from casing rules.<br>&gt; Phrases sourced from outside Swift may be exempted from Swift casing rules, e.g. @UIApplicationMain.<br>&gt;  &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#swift-language-cleanup-roadmap&gt;Swift Language Cleanup Roadmap<br>&gt; <br>&gt; This proposal is part of a series that will:<br>&gt; <br>&gt; Normalize casing to lower conjoined names.<br>&gt; Normalize naming for &quot;negative&quot; attributes (from &quot;noFeature&quot; to &quot;nonfeaturing&quot;).<br>&gt; Move dynamicType to the standard library as a global function.<br>&gt;  &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Upon adoption, Swift will rename didSet and willSet to willset and didset. Future expansions to the language will follow this adopted rule, for example didchange.<br>&gt; <br>&gt; This proposal deliberately omits the dynamicType keyword, which will be addressed under separate cover: to be moved to the standard library as a standalone global function.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal requires migration support to rename keywords that use the old convention to adopt the new convention. This is a simple substitution that should limit effect on code.<br>&gt; <br>&gt; This proposal recommends deprecating old-style keywords in Swift 2.3 and removing them in Swift 3.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/7fa61c3b74b2a2635dbea02120ac5407#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this rule for Swift.<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/1255fe2f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>If I remember correctly the property behaviors proposal it seemed that accessors such as willSet, didSet, willRead, etc. were being called.  I look at them at the same level as instance methods, properties, etc. and should follow camelCase. Not to mention that I think they look so much better camelCase. <br></p><p>When we start having accessors made up of three or more lowercase conjoined words we are going to realize what a bad choice it was to switch these to lowercase.  <br></p><p>I think they should stay camelCase. Please. :-)<br></p><p>Sent from my iPhone<br></p><p>&gt; On May 20, 2016, at 4:59 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I do support Brent’s argument that keywords which syntactically appear in the same syntactic location as user-defined names should follow the same convention as those user-defined names.  This means, for example, that dynamicType already has the correct case even though it is a keyword.  I would like to see this exemption added to the proposal.<br>&gt; <br>&gt; Also, with this in mind I would like to see more discussion about the naming convention the community prefers for user-defined behavior accessors (under the assumption that they will make it eventually).  If we agree on lowercase for user-defined accessors (which is Chris’s stated preference) I support the change to willset and didset.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Correction. I meant lowerCamelCase not CamelCase. <br></p><p>Sent from my iPhone<br></p><p>&gt; On May 20, 2016, at 7:18 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If I remember correctly the property behaviors proposal it seemed that accessors such as willSet, didSet, willRead, etc. were being called.  I look at them at the same level as instance methods, properties, etc. and should follow camelCase. Not to mention that I think they look so much better camelCase. <br>&gt; <br>&gt; When we start having accessors made up of three or more lowercase conjoined words we are going to realize what a bad choice it was to switch these to lowercase.  <br>&gt; <br>&gt; I think they should stay camelCase. Please. :-)<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 20, 2016, at 4:59 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I do support Brent’s argument that keywords which syntactically appear in the same syntactic location as user-defined names should follow the same convention as those user-defined names.  This means, for example, that dynamicType already has the correct case even though it is a keyword.  I would like to see this exemption added to the proposal.<br>&gt;&gt; <br>&gt;&gt; Also, with this in mind I would like to see more discussion about the naming convention the community prefers for user-defined behavior accessors (under the assumption that they will make it eventually).  If we agree on lowercase for user-defined accessors (which is Chris’s stated preference) I support the change to willset and didset.  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 6:18 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; If I remember correctly the property behaviors proposal it seemed that accessors such as willSet, didSet, willRead, etc. were being called.  I look at them at the same level as instance methods, properties, etc. and should follow camelCase. Not to mention that I think they look so much better camelCase. <br>&gt; <br>&gt; When we start having accessors made up of three or more lowercase conjoined words we are going to realize what a bad choice it was to switch these to lowercase.  <br>&gt; <br>&gt; I think they should stay camelCase. Please. :-)<br></p><p>I generally agree with you.  Especially because I believe sooner or later we will regret all lowercase because we find that sometimes the best accessor names are a bit too long to be comfortable with all lowercase (even 3 or 4 short words would be uncomfortable in all lowercase IMO).  I would at least like to see this get more discussion before it is settled.<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 20, 2016, at 4:59 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I do support Brent’s argument that keywords which syntactically appear in the same syntactic location as user-defined names should follow the same convention as those user-defined names.  This means, for example, that dynamicType already has the correct case even though it is a keyword.  I would like to see this exemption added to the proposal.<br>&gt;&gt; <br>&gt;&gt; Also, with this in mind I would like to see more discussion about the naming convention the community prefers for user-defined behavior accessors (under the assumption that they will make it eventually).  If we agree on lowercase for user-defined accessors (which is Chris’s stated preference) I support the change to willset and didset.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 23, 2016 at 04:00:00pm</p></header><div class="content"><p>On May 20, 2016, at 4:18 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; If I remember correctly the property behaviors proposal it seemed that accessors such as willSet, didSet, willRead, etc. were being called.  I look at them at the same level as instance methods, properties, etc. and should follow camelCase. Not to mention that I think they look so much better camelCase. <br>&gt; <br>&gt; When we start having accessors made up of three or more lowercase conjoined words we are going to realize what a bad choice it was to switch these to lowercase.  <br>&gt; <br>&gt; I think they should stay camelCase. Please. :-)<br></p><p>FWIW, the entire purpose of having a review period is so that lots of people from the community can weigh in on the topic.  When this comes up for review (tomorrow), please chime in on the review thread.<br></p><p>I have no idea how the core team as a whole feels about this.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Swift Casing Rules Roadmap<br>&gt; <br>&gt; This proposal addresses the first of the following Swift casing rules:<br>&gt; <br>&gt; 	• Keywords use lower case conjoined naming.<br>&gt; 	• Attributes use lower camel cased naming.<br>&gt; 	• Attributes use “non” prefixes in preference to &quot;no&quot; prefixes.<br>&gt; 	• Compiler-expanded literals use lower camel casing and are prefixed with octothorpes (#)<br>&gt; 	• Swift eschews snake casing. (See also: SE-0028)<br>&gt; 	• Terms of art may be exempted from casing rules.<br>&gt; 	• Phrases sourced from outside Swift may be exempted from Swift casing rules, e.g. @UIApplicationMain.<br></p><p>I started working on expanding this and ended up creating a general set of guidelines for naming language entities in Swift. Oops. You might want to just use the relevant subset.<br></p><p>* * *<br></p><p>Keywords:<br></p><p>1. Appear anywhere in the grammar appropriate for their purpose.<br>2. Have no prefix.<br>3. Use lowercaseonly naming (conjoined without underscores) and have no prefix.<br>4. May be any part of speech appropriate for the use, but are usually nouns, verbs, conjunctions, or prepositions, rarely adjectives or adverbs.<br></p><p>Declaration modifiers:<br></p><p>1. Appear in declarations before the declaration&#39;s keyword (e.g. `let`, `func`), or before the type if there is no keyword (e.g. function parameters). Can be intermixed with attributes.<br>2. Have no prefix.<br>3. Use lowercaseonly naming (conjoined without underscores) and have no prefix.<br>4. Are usually adjectives.<br></p><p>Attributes:<br></p><p>1. Appear in declarations before the declaration&#39;s keyword (e.g. `let`, `func`), or before the type if there is no keyword (e.g. function parameters). Can be intermixed with declaration modifiers.<br>2. Are prefixed with `@` symbols.<br>3. Use lowerCamelCase, unless prefixed to match a closely related module, in which case they use PFXUpperCamelCase.<br>	* Prefixes like &quot;auto&quot; and &quot;non&quot; do not introduce new words.<br>4. Are usually adjectives or involve an adjective.<br>	* When constructing an attribute name from a verb, use the &quot;-ing&quot; form (e.g. &quot;escaping&quot;, not &quot;escape&quot;) to turn it into an adjective.<br>	* When negating a term, use the &quot;non&quot; prefix.<br></p><p>Build configuration statements:<br></p><p>1. Appear where statements or declarations are valid.<br>2. Are prefixed with `#` symbols.<br>3. Use lowercaseonly naming (conjoined without underscores) and have no prefix.<br>	* If block-scoped, they run until a matching `#end&lt;foo&gt;` statement.<br>4. May be any part of speech appropriate for the use, but are usually verbs, conjunctions, or prepositions.<br></p><p>Compiler-expanded expressions:<br>	<br>1. Are prefixed with `#` symbols.<br>2. Use lowerCamelCase, unless prefixed to match a closely related module, in which case they use PFXUpperCamelCase.<br>3. Are usually nouns, but may be adjectives if they have parameters and are testing for that trait.[1]<br>4. Appear in expressions.<br></p><p>As always in Swift naming, you may deviate from these rules to preserve a widely-used term of art if it is a very close match for the meaning of the entity.<br></p><p>[1] The adjective rule here is for #available. Should that be #isAvailable, though? That would more closely match our usual rules about Boolean expressions.<br></p><p><br>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; 1. Appear anywhere in the grammar appropriate for their purpose.<br></p><p>Actually, I&#39;ll modify this one:<br></p><p>1. Appear anywhere in the grammar appropriate for their purpose, but most commonly in one of the following positions:<br>	* At the beginning of a statement.<br>	* Between parts of a keyword-introduced statement.<br>	* Just before the name in a declaration.<br>	* In infix operator position.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 4:48 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Swift Casing Rules Roadmap<br>&gt;&gt; <br>&gt;&gt; This proposal addresses the first of the following Swift casing rules:<br>&gt;&gt; <br>&gt;&gt; 	• Keywords use lower case conjoined naming.<br>&gt;&gt; 	• Attributes use lower camel cased naming.<br>&gt;&gt; 	• Attributes use “non” prefixes in preference to &quot;no&quot; prefixes.<br>&gt;&gt; 	• Compiler-expanded literals use lower camel casing and are prefixed with octothorpes (#)<br>&gt;&gt; 	• Swift eschews snake casing. (See also: SE-0028)<br>&gt;&gt; 	• Terms of art may be exempted from casing rules.<br>&gt;&gt; 	• Phrases sourced from outside Swift may be exempted from Swift casing rules, e.g. @UIApplicationMain.<br>&gt; <br>&gt; I started working on expanding this and ended up creating a general set of guidelines for naming language entities in Swift. Oops. You might want to just use the relevant subset.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Keywords:<br>&gt; <br>&gt; 1. Appear anywhere in the grammar appropriate for their purpose.<br>&gt; 2. Have no prefix.<br>&gt; 3. Use lowercaseonly naming (conjoined without underscores) and have no prefix.<br>&gt; 4. May be any part of speech appropriate for the use, but are usually nouns, verbs, conjunctions, or prepositions, rarely adjectives or adverbs.<br>&gt; <br>&gt; Declaration modifiers:<br>&gt; <br>&gt; 1. Appear in declarations before the declaration&#39;s keyword (e.g. `let`, `func`), or before the type if there is no keyword (e.g. function parameters). Can be intermixed with attributes.<br>&gt; 2. Have no prefix.<br>&gt; 3. Use lowercaseonly naming (conjoined without underscores) and have no prefix.<br>&gt; 4. Are usually adjectives.<br>&gt; <br>&gt; Attributes:<br>&gt; <br>&gt; 1. Appear in declarations before the declaration&#39;s keyword (e.g. `let`, `func`), or before the type if there is no keyword (e.g. function parameters). Can be intermixed with declaration modifiers.<br>&gt; 2. Are prefixed with `@` symbols.<br>&gt; 3. Use lowerCamelCase, unless prefixed to match a closely related module, in which case they use PFXUpperCamelCase.<br>&gt; 	* Prefixes like &quot;auto&quot; and &quot;non&quot; do not introduce new words.<br>&gt; 4. Are usually adjectives or involve an adjective.<br>&gt; 	* When constructing an attribute name from a verb, use the &quot;-ing&quot; form (e.g. &quot;escaping&quot;, not &quot;escape&quot;) to turn it into an adjective.<br>&gt; 	* When negating a term, use the &quot;non&quot; prefix.<br>&gt; <br>&gt; Build configuration statements:<br>&gt; <br>&gt; 1. Appear where statements or declarations are valid.<br>&gt; 2. Are prefixed with `#` symbols.<br>&gt; 3. Use lowercaseonly naming (conjoined without underscores) and have no prefix.<br>&gt; 	* If block-scoped, they run until a matching `#end&lt;foo&gt;` statement.<br>&gt; 4. May be any part of speech appropriate for the use, but are usually verbs, conjunctions, or prepositions.<br>&gt; <br>&gt; Compiler-expanded expressions:<br>&gt; 	<br>&gt; 1. Are prefixed with `#` symbols.<br>&gt; 2. Use lowerCamelCase, unless prefixed to match a closely related module, in which case they use PFXUpperCamelCase.<br>&gt; 3. Are usually nouns, but may be adjectives if they have parameters and are testing for that trait.[1]<br>&gt; 4. Appear in expressions.<br>&gt; <br>&gt; As always in Swift naming, you may deviate from these rules to preserve a widely-used term of art if it is a very close match for the meaning of the entity.<br>&gt; <br>&gt; [1] The adjective rule here is for #available. Should that be #isAvailable, though? That would more closely match our usual rules about Boolean expressions.<br></p><p>You haven’t discussed behavior accessors here, presumably because you’re not counting them (and therefore didSet and willSet) language entities.  Is that correct?  <br></p><p>It is probably worth discussing them here as well since this thread is about changing the names of what are going to be behavior accessors in the future.<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:52 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On May 20, 2016, at 10:48 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; On May 20, 2016, at 11:43 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; On May 20, 2016, at 10:41 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt;&gt;&gt;&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt;&gt;&gt;&gt;&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br>&gt;&gt;&gt;&gt; Before putting together a proposal, are there any other de-facto rules besides the three already listed that touch on naming keywords and attributes? (I suppose no snake case is a given)<br>&gt;&gt;&gt; I think that these are the relevant rules.  As I mentioned upthread, .dynamicType is broken for a different reason, and thus leads to a different solution (it should be a global function in the stdlib, not a propery).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; Separate action items:<br>&gt;&gt; <br>&gt;&gt; * Move dynamicType to standard library as a global function<br>&gt;&gt; * Rename didSet and willSet to lowercase to conform to Swift standard of conjoined lowercase keywords.<br>&gt;&gt; * Rename noescape to nonescaping to conform to Swift standard of &quot;non&quot;-modified attributes<br>&gt; <br>&gt; Sounds great.<br></p><p>Part 2: https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5 &lt;https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5&gt;<br></p><p>Gist pasted below<br></p><p>Normalizing naming for &quot;negative&quot; attributes<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5#introduction&gt;Introduction<br></p><p>This proposal normalizes naming for &quot;negative&quot; attributes by adopting a rule that replaces camel-cased property names starting with no with adjectives starting with non. <br></p><p>Swift-evolution thread: RFC: didset and willset &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/17534&gt;<br> &lt;https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5#motivation&gt;Motivation<br></p><p>Some Swift-sourced attributes including available and testable are both adjectives. Converting no-prefixed attributes to non changes them into a single word that describes how they modify the syntax they decorate.<br></p><p> &lt;https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5#swift-casing-rules-roadmap&gt;Swift Casing Rules Roadmap<br></p><p>This proposal addresses the third of the following Swift casing rules:<br></p><p>Keywords use lower case conjoined naming.<br>Attributes use lower camel cased naming.<br>Attributes use “non” prefixes in preference to &quot;no&quot; prefixes.<br>Compiler-expanded literals use lower camel casing and are prefixed with octothorpes (#)<br>Swift eschews snake casing. (See also: SE-0028 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md&gt;)<br>Terms of art may be exempted from casing rules.<br>Phrases sourced from outside Swift may be exempted from Swift casing rules, e.g. @UIApplicationMain.<br>Keywords that appear in the same syntactic locations as user-defined names should follow the convention of those user-defined names.<br> &lt;https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5#swift-language-cleanup-roadmap&gt;Swift Language Cleanup Roadmap<br></p><p>This proposal is part of a series that will:<br></p><p>Normalize casing to lower conjoined names.<br>Normalize naming for &quot;negative&quot; attributes (from &quot;noFeature&quot; to &quot;nonfeaturing&quot;).<br>Move dynamicType to the standard library as a global function.<br> &lt;https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5#detailed-design&gt;Detailed Design<br></p><p>Upon adoption, Swift will rename:<br></p><p>noreturn to nonreturning<br>noescape to nonescaping<br> &lt;https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal requires migration support to rename keywords that use the old convention to adopt the new convention. This is a simple substitution that should limit effect on code.<br></p><p> &lt;https://gist.github.com/erica/f31d580d7dcca3c416181a2973a185d5#alternatives-considered&gt;Alternatives Considered<br></p><p>The core team may consider exceptions for terms of art. For example, &quot;no return&quot; indicates &quot;there is no return from this function&quot;, as in the &quot;point of no return&quot;.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/8ae3372c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 12:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 7:24 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 1:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 18, 2016, at 1:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt;&gt;&gt;&gt;&gt; Swift composed of two or more words, so I believe these should be<br>&gt;&gt;&gt;&gt;&gt; exceptions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, but the catfight had a clear outcome:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) keywords are conjoined<br>&gt;&gt;&gt; 2) attributes are lower camel cased.<br>&gt;&gt;&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt;&gt; <br>&gt;&gt; Would you be in favor of a proposal that cleans all of this up at once and establishes this standard for all new features?  I don&#39;t mind the change and think consistency is a good idea, I just think it doesn&#39;t make sense to keep doing these as one-off changes.<br>&gt; <br>&gt; I’d prefer one proposal to cover didset/willset and one to cover nonescaping (and any other nofoo attributes left).    They will raise different sorts of discussion, even though they both seem obvious to me.<br></p><p>Fair enough.  It just feels like it makes it more difficult to reach consistency that way (the discussions could have different outcomes) and consistency is the whole motivation behind these proposals.<br></p><p>&gt; <br>&gt; -Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>I think my problem stems from the fact that some of these keywords aren&#39;t in the normal place we&#39;d find a keyword. Some are acting like properties and others are acting like methods:<br></p><p>someClass.dynamicType looks like a normal property on an object. <br>someClass.dynamictype just looks unnatural as a result. <br></p><p>didSet/willSet also look like methods and not really keywords. They also contain descriptive names that are an action of doing something or something about to be down, like a normal method name would usually convey. <br></p><p>I&#39;m not sure there is a perfect way to reconcile these two things: being a keyword and following those rules yet not really seeming like one read or seen. <br></p><p>Would it be easier not to make these keywords somehow? I.E. dynamicType on a protocol all classes conform to which would end that debate once and for all. <br></p><p>Just some thoughts, <br>Brandon <br></p><p>Sent from my iPad<br></p><p>&gt; On May 20, 2016, at 2:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 1:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt;&gt;&gt; Swift composed of two or more words, so I believe these should be<br>&gt;&gt;&gt; exceptions.<br>&gt;&gt; <br>&gt;&gt; `typealias` and `associatedtype` are the main examples; there were huge catfights on swift-evolution about whether the latter should be `associatedtype`, `associatedType`, or `associated_type`. There are also a number of attributes like `@noescape` and `@discardableResult`, which aren&#39;t 100% consistent.<br>&gt; <br>&gt; Right, but the catfight had a clear outcome:<br>&gt; <br>&gt; 1) keywords are conjoined<br>&gt; 2) attributes are lower camel cased.<br>&gt; 3) attributes should use “non” not “no”.  noescape should be nonescaping (and thus no camel bump).<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 19, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 18 May 2016, at 21:51, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I may be wrong but I don&#39;t remember any other case of a keyword in<br>&gt; Swift composed of two or more words,<br></p><p><br>dynamicType, associatedtype, typealias, privatefile<br></p><p><br>&gt; so I believe these should be<br>&gt; exceptions. I would agree best to change these keywords for others<br>&gt; consisting of only one word but I myself have no suggestion what those<br>&gt; could be. Otherwise I&#39;d rather keep them as-is.<br></p><p>At some point (I think it was during the bike shedding for associatedtype), somebody declared that camel case for keywords is abhorrent and everybody accepted it without question. Looking back on it, I think that was a mistake. The point of camel case is to help resolve the individual words in an identifier. I don’t see why that shouldn’t also apply to keywords, especially as, in the list above, Apple Mail kept inserting spaces into the ones that weren’t in camel case, which is really annoying.<br></p><p>A better convention might be to put keywords in ALL CAPS like in Algol. &lt;&lt; Ducks &gt;&gt;<br></p><p>&gt; <br>&gt; On 18 May 2016 at 17:38, Michael Peternell via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi Erica,<br>&gt;&gt; <br>&gt;&gt; &quot;didset&quot; and &quot;willset&quot; are outliers in the general rule that when combining multiple words into an identifier, that you should use camelCase. which rule is more important? I&#39;d like to introduce a third rule: don&#39;t fix it if it isn&#39;t broken, or more mildly: if in doubt, keep it the way it is. or another one: embrace precedent.. &quot;@IBOutlet&quot; is also not all-lowercase, should it be changed too? I&#39;d say no, because in objc it is called &quot;IBOutlet&quot; as well. Also, for my Apple Mail client, &quot;didset&quot; and &quot;willset&quot; are marked as typos, but &quot;didSet&quot; and &quot;willSet&quot; is okay :)<br>&gt;&gt; <br>&gt;&gt; =&gt; I vote for &quot;didSet&quot; and &quot;willSet&quot;.<br>&gt;&gt; <br>&gt;&gt; I think we should be more careful when trying to argue with &quot;consistency&quot;. It sounds objective, when in reality it&#39;s often very subjective, because Immanuel Kant&#39;s imperative is ambiguous ;) there are multiple ways to be consistent. If you are saying that something is inconsistent, you either assert a specific rule of consistency (like &quot;keywords are always lowercase&quot;), or you must argue that there is no general/sane rule under which the individual parts of the system are consistent.<br>&gt;&gt; <br>&gt;&gt; And for all the others who want to abolish didSet and willSet completely:<br>&gt;&gt; NO WAY! they are both useful and I even used them for real code. For example, from code in my bachelors thesis (it&#39;s about polygons):<br>&gt;&gt; <br>&gt;&gt;    public var points: Array&lt;CGPoint&gt; = [] {<br>&gt;&gt;        didSet {<br>&gt;&gt;            _area = nil<br>&gt;&gt;            _centroid = nil<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; I want to cache the _area and _centroid of a polygon, because I&#39;m going to use it many many times more often than I change points. I would have to rewrite that code to something like<br>&gt;&gt; <br>&gt;&gt;    private var _points: Array&lt;CGPoint&gt; = []<br>&gt;&gt;    public var points {<br>&gt;&gt;        get {<br>&gt;&gt;            return _points<br>&gt;&gt;        }<br>&gt;&gt;        set {<br>&gt;&gt;            _area = nil<br>&gt;&gt;            _centroid = nil<br>&gt;&gt;            _points = newValue<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; That&#39;s not better, and it probably breaks the COW-optimization of the underlying array. (And don&#39;t tell me that my design is bad because I use &quot;didSet&quot;, I really don&#39;t think so.)<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 18.05.2016 um 17:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 18, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br></p><p>I don&#39;t think we shouldn&#39;t touch these until we know what accessors on property behaviors are going to look like. We could very well change these now and then change them back in the next version; that kind of bouncing back and forth is maddening for users. Better leave them alone for now and change them later if we decide to, than change them in Swift 3 and then have a high probability of changing them back in Swift 4.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 19, 2016 at 06:00:00am</p></header><div class="content"><p>Yeah I agree completely with this. They may be camel case with property behaviours, so best to keep them as is for now.<br></p><p>&gt; On 19 May 2016, at 6:53 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt; <br>&gt; I don&#39;t think we shouldn&#39;t touch these until we know what accessors on property behaviors are going to look like. We could very well change these now and then change them back in the next version; that kind of bouncing back and forth is maddening for users. Better leave them alone for now and change them later if we decide to, than change them in Swift 3 and then have a high probability of changing them back in Swift 4.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 3:53 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt; <br>&gt; I don&#39;t think we shouldn&#39;t touch these until we know what accessors on property behaviors are going to look like. We could very well change these now and then change them back in the next version; that kind of bouncing back and forth is maddening for users. Better leave them alone for now and change them later if we decide to, than change them in Swift 3 and then have a high probability of changing them back in Swift 4.<br></p><p>I generally agree, but is that an option?  Changing `didSet` to `didset` is a breaking change.  Or are you arguing that this is a special case as it is already going to change when property behaviors are introduced?<br></p><p>I wish we had a clearer sense of how breaking changes will be evaluated in future versions of Swift.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 19, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 2:01 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 3:53 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think we shouldn&#39;t touch these until we know what accessors on property behaviors are going to look like. We could very well change these now and then change them back in the next version; that kind of bouncing back and forth is maddening for users. Better leave them alone for now and change them later if we decide to, than change them in Swift 3 and then have a high probability of changing them back in Swift 4.<br>&gt; <br>&gt; I generally agree, but is that an option?  Changing `didSet` to `didset` is a breaking change.<br></p><p>In practice, we can accept both spellings for a long time at no harm to anyone.  The first question to answer is “what is the right thing”.  We can talk about how to phase it in separately.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 19, 2016 at 11:00:00pm</p></header><div class="content"><p>My personal opinion (as with the @lazy proposal) is that changing the names of to-be-property-behaviors should be deferred until the property behaviors proposal is finalized and accepted. I understand why fixing them pre-emptively might be a good idea, though.<br></p><p>Austin<br></p><p>&gt; On May 19, 2016, at 11:12 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 2:01 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 3:53 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think we shouldn&#39;t touch these until we know what accessors on property behaviors are going to look like. We could very well change these now and then change them back in the next version; that kind of bouncing back and forth is maddening for users. Better leave them alone for now and change them later if we decide to, than change them in Swift 3 and then have a high probability of changing them back in Swift 4.<br>&gt;&gt; <br>&gt;&gt; I generally agree, but is that an option?  Changing `didSet` to `didset` is a breaking change.<br>&gt; <br>&gt; In practice, we can accept both spellings for a long time at no harm to anyone.  The first question to answer is “what is the right thing”.  We can talk about how to phase it in separately.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>RFC: didset and willset</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 19, 2016 at 10:00:00am</p></header><div class="content"><p>Agreed. Personally I prefer willSet and didSet, but consistency of rules is higher priority. +1.<br></p><p><br>&gt; On 19 May 2016, at 1:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; didSet and willSet remain outliers in the general rule of conjoined lowercase keywords. Is there any support for bringing these outliers into the fold?<br>&gt; <br>&gt; -- E, going through her &quot;ttd notes&quot; this morning<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
