<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 25, 2016 at 02:00:00pm</p></header><div class="content"><p>on Sat Apr 23 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;     On 7 Apr 2016, at 18:54, Dmitri Gribenko via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     On Thu, Apr 7, 2016 at 12:20 AM, Vladimir.S via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     But. .successor() .predecessor() methods for Int values do not follow these<br>&gt;         rules for overflow situations. I.e. :<br>&gt;         let i : Int8 = Int8.max<br>&gt;         let k : Int8 = i.successor()<br>&gt;         - is OK for current Swift compiler. We have i==127 and k==-128, no<br>&gt;         run-time<br>&gt;         error.<br>&gt;<br>&gt;     This was done for performance reasons. Array&#39;s indices are Ints, and<br>&gt;     adding an overflow check here was causing significant performance<br>&gt;     issues when iterating over arrays.<br>&gt;<br>&gt; Sorry to bump this after it’s been idle for a little while, but I was thinking<br>&gt; about this again recently and I can’t come up with a test that verifies a<br>&gt; meaningful performance difference. I just threw the following into a playground:<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; do {<br>&gt; let startTime = NSDate().timeIntervalSince1970<br>&gt; var i = 0<br>&gt; while i &lt; 1000000 { i = i &amp;+ 1 }<br>&gt; let elapsed = NSDate().timeIntervalSince1970 - startTime<br>&gt; }<br>&gt;<br>&gt; do {<br>&gt; let startTime = NSDate().timeIntervalSince1970<br>&gt; var i = 0<br>&gt; while i &lt; 1000000 { i = i + 1 }<br>&gt; let elapsed = NSDate().timeIntervalSince1970 - startTime<br>&gt; }<br>&gt;<br>&gt; My results come out with no discernible performance difference; <br></p><p>I wouldn&#39;t be surprised if these examples compiled down to exactly the<br>same code because the compiler can hoist the overflow checks out of the<br>loop.  Try doing the same thing with a sort or a binary search if you<br>want to experience the difference<br></p><p>&gt; I suspect that this a side-effect of the iteration and storing<br>&gt; overhead, but it seems to me that this is the kind of minimum<br>&gt; boilerplate you are going to have anyway if you’re using<br>&gt; .successor(). I know the issue is specifically with array iteration,<br>&gt; but I don’t believe I actually need an array involved to demonstrate<br>&gt; this, in fact the extra overhead would make the difference even less<br>&gt; noticeable.<br>&gt;<br>&gt; Is there a test that can demonstrate a more extreme difference? Even so, if the<br>&gt; issue is with array iteration then it seems that the best place to fix that is<br>&gt; in the array’s generator, rather than using the more generic IndexingGenerator<br>&gt; that has no awareness of the underlying index type.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 25 Apr 2016, at 22:53, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Apr 23 2016, Haravikk &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On 7 Apr 2016, at 18:54, Dmitri Gribenko via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    On Thu, Apr 7, 2016 at 12:20 AM, Vladimir.S via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    But. .successor() .predecessor() methods for Int values do not follow these<br>&gt;&gt;        rules for overflow situations. I.e. :<br>&gt;&gt;        let i : Int8 = Int8.max<br>&gt;&gt;        let k : Int8 = i.successor()<br>&gt;&gt;        - is OK for current Swift compiler. We have i==127 and k==-128, no<br>&gt;&gt;        run-time<br>&gt;&gt;        error.<br>&gt;&gt; <br>&gt;&gt;    This was done for performance reasons. Array&#39;s indices are Ints, and<br>&gt;&gt;    adding an overflow check here was causing significant performance<br>&gt;&gt;    issues when iterating over arrays.<br>&gt;&gt; <br>&gt;&gt; Sorry to bump this after it’s been idle for a little while, but I was thinking<br>&gt;&gt; about this again recently and I can’t come up with a test that verifies a<br>&gt;&gt; meaningful performance difference. I just threw the following into a playground:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt; let startTime = NSDate().timeIntervalSince1970<br>&gt;&gt; var i = 0<br>&gt;&gt; while i &lt; 1000000 { i = i &amp;+ 1 }<br>&gt;&gt; let elapsed = NSDate().timeIntervalSince1970 - startTime<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt; let startTime = NSDate().timeIntervalSince1970<br>&gt;&gt; var i = 0<br>&gt;&gt; while i &lt; 1000000 { i = i + 1 }<br>&gt;&gt; let elapsed = NSDate().timeIntervalSince1970 - startTime<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; My results come out with no discernible performance difference; <br>&gt; <br>&gt; I wouldn&#39;t be surprised if these examples compiled down to exactly the<br>&gt; same code because the compiler can hoist the overflow checks out of the<br>&gt; loop.<br></p><p>I don’t know how that would work exactly, or do you mean it can calculate before the loop that the value will never overflow?<br></p><p>&gt; Try doing the same thing with a sort or a binary search if you<br>&gt; want to experience the difference<br></p><p><br>I tested two versions of a binary search algorithm, one calculating the mid-point using arithmetic with overflow checking and one without, and again both give performance that’s effectively identical. Can you give a concrete example of code that demonstrates the difference?<br></p><p>Still, even if for sorting it makes a big difference to sorting then surely that’s an argument for arrays to have their own sorting implementation with unsafe arithmetic used internally, rather than changing predecessor/successor?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/22343505/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 25, 2016 at 04:00:00pm</p></header><div class="content"><p>on Mon Apr 25 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br></p><p>&gt;     On 25 Apr 2016, at 22:53, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Sat Apr 23 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On 7 Apr 2016, at 18:54, Dmitri Gribenko via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         On Thu, Apr 7, 2016 at 12:20 AM, Vladimir.S via swift-evolution<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         But. .successor() .predecessor() methods for Int values do not follow<br>&gt;         these<br>&gt;         rules for overflow situations. I.e. :<br>&gt;         let i : Int8 = Int8.max<br>&gt;         let k : Int8 = i.successor()<br>&gt;         - is OK for current Swift compiler. We have i==127 and k==-128, no<br>&gt;         run-time<br>&gt;         error.<br>&gt;<br>&gt;         This was done for performance reasons. Array&#39;s indices are Ints, and<br>&gt;         adding an overflow check here was causing significant performance<br>&gt;         issues when iterating over arrays.<br>&gt;<br>&gt;         Sorry to bump this after it’s been idle for a little while, but I was<br>&gt;         thinking<br>&gt;         about this again recently and I can’t come up with a test that verifies<br>&gt;         a<br>&gt;         meaningful performance difference. I just threw the following into a<br>&gt;         playground:<br>&gt;<br>&gt;         import Foundation<br>&gt;<br>&gt;         do {<br>&gt;         let startTime = NSDate().timeIntervalSince1970<br>&gt;         var i = 0<br>&gt;         while i &lt; 1000000 { i = i &amp;+ 1 }<br>&gt;         let elapsed = NSDate().timeIntervalSince1970 - startTime<br>&gt;         }<br>&gt;<br>&gt;         do {<br>&gt;         let startTime = NSDate().timeIntervalSince1970<br>&gt;         var i = 0<br>&gt;         while i &lt; 1000000 { i = i + 1 }<br>&gt;         let elapsed = NSDate().timeIntervalSince1970 - startTime<br>&gt;         }<br>&gt;<br>&gt;         My results come out with no discernible performance difference; <br>&gt;<br>&gt;     I wouldn&#39;t be surprised if these examples compiled down to exactly the<br>&gt;     same code because the compiler can hoist the overflow checks out of the<br>&gt;     loop. <br>&gt;<br>&gt; I don’t know how that would work exactly, or do you mean it can calculate before<br>&gt; the loop that the value will never overflow?<br></p><p>Exactly.<br></p><p>&gt;     Try doing the same thing with a sort or a binary search if you<br>&gt;     want to experience the difference<br>&gt;<br>&gt; I tested two versions of a binary search algorithm, one calculating the<br>&gt; mid-point using arithmetic with overflow checking and one without, and again<br>&gt; both give performance that’s effectively identical. Can you give a concrete<br>&gt; example of code that demonstrates the difference?<br></p><p>Not I.  Perhaps some of our performance gurus will chime in with the answer.  Or,<br>perhaps they&#39;ll tell us this optimization has become obsolete.<br></p><p>&gt; Still, even if for sorting it makes a big difference to sorting then surely<br>&gt; that’s an argument for arrays to have their own sorting implementation with<br>&gt; unsafe arithmetic used internally, rather than changing predecessor/successor?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Improvement proposal: change overflow behavior in successor()/predecessor() methods for Int types</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>April 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 25, 2016, at 4:19 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Apr 25 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt; <br>&gt;&gt;    On 25 Apr 2016, at 22:53, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Sat Apr 23 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On 7 Apr 2016, at 18:54, Dmitri Gribenko via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        On Thu, Apr 7, 2016 at 12:20 AM, Vladimir.S via swift-evolution<br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;        But. .successor() .predecessor() methods for Int values do not follow<br>&gt;&gt;        these<br>&gt;&gt;        rules for overflow situations. I.e. :<br>&gt;&gt;        let i : Int8 = Int8.max<br>&gt;&gt;        let k : Int8 = i.successor()<br>&gt;&gt;        - is OK for current Swift compiler. We have i==127 and k==-128, no<br>&gt;&gt;        run-time<br>&gt;&gt;        error.<br>&gt;&gt; <br>&gt;&gt;        This was done for performance reasons. Array&#39;s indices are Ints, and<br>&gt;&gt;        adding an overflow check here was causing significant performance<br>&gt;&gt;        issues when iterating over arrays.<br>&gt;&gt; <br>&gt;&gt;        Sorry to bump this after it’s been idle for a little while, but I was<br>&gt;&gt;        thinking<br>&gt;&gt;        about this again recently and I can’t come up with a test that verifies<br>&gt;&gt;        a<br>&gt;&gt;        meaningful performance difference. I just threw the following into a<br>&gt;&gt;        playground:<br>&gt;&gt; <br>&gt;&gt;        import Foundation<br>&gt;&gt; <br>&gt;&gt;        do {<br>&gt;&gt;        let startTime = NSDate().timeIntervalSince1970<br>&gt;&gt;        var i = 0<br>&gt;&gt;        while i &lt; 1000000 { i = i &amp;+ 1 }<br>&gt;&gt;        let elapsed = NSDate().timeIntervalSince1970 - startTime<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        do {<br>&gt;&gt;        let startTime = NSDate().timeIntervalSince1970<br>&gt;&gt;        var i = 0<br>&gt;&gt;        while i &lt; 1000000 { i = i + 1 }<br>&gt;&gt;        let elapsed = NSDate().timeIntervalSince1970 - startTime<br>&gt;&gt;        }<br>&gt;&gt; <br>&gt;&gt;        My results come out with no discernible performance difference; <br>&gt;&gt; <br>&gt;&gt;    I wouldn&#39;t be surprised if these examples compiled down to exactly the<br>&gt;&gt;    same code because the compiler can hoist the overflow checks out of the<br>&gt;&gt;    loop. <br>&gt;&gt; <br>&gt;&gt; I don’t know how that would work exactly, or do you mean it can calculate before<br>&gt;&gt; the loop that the value will never overflow?<br>&gt; <br>&gt; Exactly.<br>&gt; <br>&gt;&gt;    Try doing the same thing with a sort or a binary search if you<br>&gt;&gt;    want to experience the difference<br>&gt;&gt; <br>&gt;&gt; I tested two versions of a binary search algorithm, one calculating the<br>&gt;&gt; mid-point using arithmetic with overflow checking and one without, and again<br>&gt;&gt; both give performance that’s effectively identical. Can you give a concrete<br>&gt;&gt; example of code that demonstrates the difference?<br>&gt; <br>&gt; Not I.  Perhaps some of our performance gurus will chime in with the answer.  Or,<br>&gt; perhaps they&#39;ll tell us this optimization has become obsolete.<br></p><p>To answer this specific question, the optimizer will remove the overflow check whenever it proves impossible to fire. The example above has constant loop bounds, so obviously the optimizer can remove the check. In many cases it can’t, but as Dmitri pointed out, the bounds check is strictly narrower so there’s no reason to do both.<br></p><p>-Andy<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
