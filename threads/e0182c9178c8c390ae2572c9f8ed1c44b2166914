<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allowing extensions of bound generic types</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 02:00:00am</p></header><div class="content"><p>I&#39;m looking into allowing extensions like &quot;extension Array where Element ==<br>Int&quot; — relaxing the restriction that prevents generic function/type<br>definitions from having concrete types specified. (Slava mentioned that<br>this is a favorable language change without need for the evolution process:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000865.html<br>)<br></p><p>I&#39;d like to run my thoughts by some people who know what they&#39;re talking<br>about, before diving in too far :-)<br></p><p>The diagnostic in question is<br>    diag::requires_generic_param_made_equal_to_concrete<br>    &quot;same-type requirement makes generic parameter %0 non-generic&quot;<br>which is emitted from ArchetypeBuilder::addSameTypeRequirementToConcrete().<br></p><p>Multiple code paths reach checkGenericParamList() which adds the<br>requirements:<br></p><p>    - DeclChecker::visitClassDecl<br>       -&gt; TC::validateDecl case for struct/class/enum<br>       -&gt; TC::validateGenericTypeSignature<br>       -&gt; TC::validateGenericSignature<br>       -&gt; TC::checkGenericParamList<br></p><p>    - DeclChecker::visitFuncDecl<br>       -&gt; TC::validateGenericFuncSignature<br>       -&gt; TC::checkGenericFuncSignature<br>       -&gt; TC::checkGenericParamList<br></p><p>    - DeclChecker::visitExtensionDecl<br>       -&gt; TC::validateExtension<br>       -&gt; TC::checkExtensionGenericParams<br>       -&gt; TC::validateGenericSignature<br>       -&gt; TC::checkGenericParamList<br>(Mildly confusing to have both &quot;validate&quot; and &quot;check&quot; variants, but only in<br>some of the cases...?)<br></p><p>It&#39;s only in the 3rd case (extensions) that we want to allow the<br>requirements to make the types fully bound/concrete. So here&#39;s what I<br>propose doing:<br></p><p>  1. The ArchetypeBuilder needs to know whether this is allowed. So add a<br>boolean field, called e.g. AllowConcreteRequirements.<br></p><p>  2a. Pass false to the ArchetypeBuilder created in<br>validateGenericFuncSignature.<br>  2b. Pass the boolean through as a param to validateGenericSignature,<br>where the ArchetypeBuilder is created. (validateGenericSignature is used in<br>both class &amp; extension cases). In particular, pass true from<br>checkExtensionGenericParams and false from validateGenericTypeSignature.<br></p><p>  3. Skip the error if AllowConcreteRequirements was true. Instead allow<br>the requirement to be added (and fix any fallout issues from this change,<br>add tests, yadda yadda).<br></p><p>How does that sound?<br></p><p>Also, is there any desire to remove this restriction?<br>    diag::extension_specialization<br>    &quot;constrained extension must be declared on the unspecialized generic<br>type %0 with constraints specified by a &#39;where&#39; clause&quot;<br>It seems natural to want to allow &quot;extension Array&lt;Int&gt;&quot;, but I&#39;m afraid it<br>may complicate things significantly, especially if we only wanted to allow<br>this syntax in the case of .<br></p><p>Jacob Bandes-Storch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151209/e0186914/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allowing extensions of bound generic types</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 02:00:00am</p></header><div class="content"><p>Email is hard...last sentence should say &quot;in the case of extensions&quot;.<br>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151209/fa21e22c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Allowing extensions of bound generic types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 07:00:00am</p></header><div class="content"><p>Hi Jacob<br></p><p>Apologies for the delay in answering…<br></p><p>&gt; On Dec 9, 2015, at 2:00 AM, Jacob Bandes-Storch via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m looking into allowing extensions like &quot;extension Array where Element == Int&quot; — relaxing the restriction that prevents generic function/type definitions from having concrete types specified. (Slava mentioned that this is a favorable language change without need for the evolution process: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000865.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000865.html&gt;)<br>&gt; <br>&gt; I&#39;d like to run my thoughts by some people who know what they&#39;re talking about, before diving in too far :-)<br>&gt; <br>&gt; The diagnostic in question is<br>&gt;     diag::requires_generic_param_made_equal_to_concrete<br>&gt;     &quot;same-type requirement makes generic parameter %0 non-generic&quot;<br>&gt; which is emitted from ArchetypeBuilder::addSameTypeRequirementToConcrete().<br>&gt; <br>&gt; Multiple code paths reach checkGenericParamList() which adds the requirements:<br>&gt; <br>&gt;     - DeclChecker::visitClassDecl<br>&gt;        -&gt; TC::validateDecl case for struct/class/enum<br>&gt;        -&gt; TC::validateGenericTypeSignature<br>&gt;        -&gt; TC::validateGenericSignature<br>&gt;        -&gt; TC::checkGenericParamList<br>&gt; <br>&gt;     - DeclChecker::visitFuncDecl<br>&gt;        -&gt; TC::validateGenericFuncSignature<br>&gt;        -&gt; TC::checkGenericFuncSignature<br>&gt;        -&gt; TC::checkGenericParamList<br>&gt; <br>&gt;     - DeclChecker::visitExtensionDecl<br>&gt;        -&gt; TC::validateExtension<br>&gt;        -&gt; TC::checkExtensionGenericParams<br>&gt;        -&gt; TC::validateGenericSignature<br>&gt;        -&gt; TC::checkGenericParamList<br></p><p>There’s a path through TypeChecker::handleSILGenericParams() that you need to consider, which is triggered when parsing SIL. It’s an odd case because you get all of the generic parameter lists up front. I suspect you would just always allow type parameters to be equated with concrete types from here.<br></p><p>&gt; (Mildly confusing to have both &quot;validate&quot; and &quot;check&quot; variants, but only in some of the cases…?)<br></p><p>Having the “check” in the middle/bottom is the exceptional part here. The rough intent at one point was that “validate” was basic validation of a declaration so that it could be useful from elsewhere, while “check” checks all of the semantic constraints to see if the declaration was well-formed. But, it wasn’t followed that carefully, and this turns out to be a not-terribly-useful distinction. Rather, we should be handling more fine-grained type checking requests iteratively, per<br></p><p>	https://github.com/apple/swift/blob/master/docs/proposals/DeclarationTypeChecker.rst<br></p><p>But that’s off on the horizon. Back to your actual question…<br></p><p>&gt; <br>&gt; It&#39;s only in the 3rd case (extensions) that we want to allow the requirements to make the types fully bound/concrete.<br></p><p>Okay, so this means that your example would be accepted, but something like:<br></p><p>	class X&lt;T where T == Int&gt; {<br>	}<br></p><p>would remain ill-formed, as would<br></p><p>	class X&lt;T&gt; {<br>	  func f&lt;U where T == Int&gt;() { … }<br>	}<br></p><p>&gt; So here&#39;s what I propose doing:<br>&gt; <br>&gt;   1. The ArchetypeBuilder needs to know whether this is allowed. So add a boolean field, called e.g. AllowConcreteRequirements.<br>&gt; <br>&gt;   2a. Pass false to the ArchetypeBuilder created in validateGenericFuncSignature.<br>&gt;   2b. Pass the boolean through as a param to validateGenericSignature, where the ArchetypeBuilder is created. (validateGenericSignature is used in both class &amp; extension cases). In particular, pass true from checkExtensionGenericParams and false from validateGenericTypeSignature.<br>&gt; <br>&gt;   3. Skip the error if AllowConcreteRequirements was true. Instead allow the requirement to be added (and fix any fallout issues from this change, add tests, yadda yadda).<br>&gt; <br>&gt; How does that sound?<br></p><p>You may need to make the AllowConcreteRequirements flag indicate the depth at which generic parameters are allowed to be made equivalent to concrete types. Consider, for example:<br></p><p>	class X&lt;T&gt; { }<br></p><p>	extension X&lt;T&gt; {<br>	  func f&lt;U where T == Int&gt;() { }<br>	}<br></p><p>Presumably that should be ill-formed still, and that one would properly have to write<br></p><p>	extension X where T == Int {<br>	  func f() { }<br>	}<br></p><p>(which is much clearer anyway, of course!).<br></p><p>And although it’s broken today for other reasons, the depth of the generic parameters that are allowed to be made equivalent to concrete types could be &gt; 0 if you had a generic type nested within a generic type, e.g.,<br></p><p>	class X&lt;T&gt; {<br>		class Y&lt;U&gt; {<br>		}<br>	}<br></p><p>	extension X.Y where T == Int, U == String { … } // okay; both depths 0 and 1 are okay to bind to concrete types<br></p><p><br>&gt; Also, is there any desire to remove this restriction?<br>&gt;     diag::extension_specialization<br>&gt;     &quot;constrained extension must be declared on the unspecialized generic type %0 with constraints specified by a &#39;where&#39; clause&quot;<br>&gt; It seems natural to want to allow &quot;extension Array&lt;Int&gt;&quot;, but I&#39;m afraid it may complicate things significantly, especially if we only wanted to allow this syntax in the case of .<br></p><p>I’d want this bit of syntax to go through swift-evolution, even though I suspect it would be very well-received. There’s a syntactic symmetry question it invokes, because<br></p><p>	struct X&lt;T&gt; { … }<br></p><p>introduces T as a type parameter while<br></p><p>	extension X&lt;T&gt; { … }<br></p><p>looks up T in the enclosing scope. That potentially becomes somewhat ambiguous if we want to be able to introduce new type parameters in a specific extension, which comes up if we implement something akin to C++’s partial specialization. For example, extending an array of optional values:<br></p><p>	extension X&lt;T?&gt; { } // no, looks up T in the enclosing scope<br></p><p>There are syntactic ways around this. For example, putting the type parameters after “extension”:<br></p><p>	extension&lt;T&gt; Array&lt;T?&gt; { }<br></p><p>or even spell it with the syntactic sugar:<br></p><p>	extension&lt;T&gt; [T?] {<br>		func nonnilValues() -&gt; [T] {<br>		}<br>	}<br></p><p>to open the flood gates yet further.<br></p><p>I don’t see any rush to push the syntax through swift-evolution: you can work on the implementation using the “Element == Int” syntax (which should work regardless of whether there’s a more concise way to spell the same intent) and discuss/add the syntactic sugar later.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151211/c2bf37b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allowing extensions of bound generic types</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 12, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi Doug, thanks for the response!<br></p><p>There’s a path through TypeChecker::handleSILGenericParams() that you need<br>&gt; to consider, which is triggered when parsing SIL. It’s an odd case because<br>&gt; you get all of the generic parameter lists up front. I suspect you would<br>&gt; just always allow type parameters to be equated with concrete types from<br>&gt; here.<br>&gt;<br></p><p>Yeah, sounds reasonable.<br></p><p>You may need to make the AllowConcreteRequirements flag indicate the depth<br>&gt; at which generic parameters are allowed to be made equivalent to concrete<br>&gt; types.<br>&gt;<br></p><p>I guess that makes sense to me, although I&#39;m not convinced it&#39;s actually<br>going to be necessary. I&#39;m going to try to get an initial version working<br>first, then consider using depth instead of just a bool.<br></p><p>The problem I&#39;m running into now is that the PotentialArchetype&#39;s<br>getType(ArchetypeBuilder&amp;) is returning the concrete type it was<br>constrained to, so castToArchetype fails (inside getAllArchetypes, during<br>finalizeGenericParamList). I tried simply skipping these archetypes, but a<br>lot of stuff downstream seems to depend on the number of archetypes<br>matching the number of generic params (such as<br>ConsraintSystem::openGeneric, BoundGenericType, etc.). Do you think I<br>should be modifying ArchetypeBuilder::PotentialArchetype::getType() to<br>return a valid archetype in this case, and just let the constraint solver<br>deal with the same-type requirement later on?<br></p><p>Thanks,<br>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151212/3085a57f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
