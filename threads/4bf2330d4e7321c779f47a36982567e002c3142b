<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on a design for allowing properties to be extended with user-defined delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open up for broader discussion. Thanks for taking a look!<br></p><p>-Joe<br></p><p>https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3 &lt;https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3&gt;<br></p><p>Property Behaviors<br>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/proposals/NNNN-name.md&gt;<br>Author(s): Joe Groff &lt;https://github.com/jckarter&gt;<br>Status: Review<br>Review manager: TBD<br>Introduction<br>There are property implementation patterns that come up repeatedly. Rather than hardcode a fixed set of patterns into the compiler, we should provide a general “property behavior” mechanism to allow these patterns to be defined as libraries.<br></p><p>Motivation<br>We’ve tried to accommodate several important patterns for property with targeted language support, but this support has been narrow in scope and utility. For instance, Swift 1 and 2 provide lazy properties as a primitive language feature, since lazy initialization is common and is often necessary to avoid having properties be exposed as Optional. Without this language support, it takes a lot of boilerplate to get the same effect:<br></p><p>class Foo {<br>  // lazy var foo = 1738<br>  private var _foo: Int?<br>  var foo: Int {<br>    get {<br>      if let value = _foo { return value }<br>      let initialValue = 1738<br>      _foo = initialValue<br>      return initialValue<br>    }<br>    set {<br>      _foo = newValue<br>    }<br>  }<br>}<br>Building lazy into the language has several disadvantages. It makes the language and compiler more complex and less orthogonal. It’s also inflexible; there are many variations on lazy initialization that make sense, but we wouldn’t want to hardcode language support for all of them. For instance, some applications may want the lazy initialization to be synchronized, but lazyonly provides single-threaded initialization. The standard implementation of lazy is also problematic for value types. A lazygetter must be mutating, which means it can’t be accessed from an immutable value. Inline storage is also suboptimal for many memoization tasks, since the cache cannot be reused across copies of the value. A value-oriented memoized property implementation might look very different:<br></p><p>class MemoizationBox&lt;T&gt; {<br>  var value: T? = nil<br>  init() {}<br>  func getOrEvaluate(fn: () -&gt; T) -&gt; T {<br>    if let value = value { return value }<br>    // Perform initialization in a thread-safe way.<br>    // Implementation of `sync` not shown here<br>    return sync {<br>      let initialValue = fn()<br>      value = initialValue<br>      return initialValue<br>    }<br>  }<br>}<br></p><p>struct Person {<br>  let firstName: String<br>  let lastName: String<br></p><p>  let _cachedFullName = MemoizationBox&lt;String&gt;()<br></p><p>  var fullName: String {<br>    return _cachedFullName.getOrEvaluate { &quot;\(firstName) \(lastName)&quot; }<br>  }<br>}<br>Lazy properties are also unable to surface any additional operations over a regular property. It would be useful to be able to reset a lazy property’s storage to be recomputed again, for instance, but this isn’t possible with lazy.<br></p><p>There are important property patterns outside of lazy initialization. It often makes sense to have “delayed”, once-assignable-then-immutable properties to support multi-phase initialization:<br></p><p>class Foo {<br>  let immediatelyInitialized = &quot;foo&quot;<br>  var _initializedLater: String?<br></p><p>  // We want initializedLater to present like a non-optional &#39;let&#39; to user code;<br>  // it can only be assigned once, and can&#39;t be accessed before being assigned.<br>  var initializedLater: String {<br>    get { return _initializedLater! }<br>    set {<br>      assert(_initializedLater == nil)<br>      _initializedLater = newValue<br>    }<br>  }<br>}<br>Implicitly-unwrapped optionals allow this in a pinch, but give up a lot of safety compared to a non-optional ‘let’. Using IUO for multi-phase initialization gives up both immutability and nil-safety.<br></p><p>We also have other application-specific property features like didSet/willSet and array addressors that add language complexity for limited functionality. Beyond what we’ve baked into the language already, there’s a seemingly endless set of common property behaviors, including resetting, synchronized access, and various kinds of proxying, all begging for language attention to eliminate their boilerplate.<br></p><p>Proposed solution<br>I suggest we allow for property behaviors to be implemented within the language. A var or let declaration can specify its behavior in parens after the keyword:<br></p><p>var (lazy) foo = 1738<br>which acts as sugar for something like this:<br></p><p>var `foo.lazy` = lazy(var: Int.self, initializer: { 1738 })<br>var foo: Int {<br>  get {<br>    return `foo.lazy`[varIn: self,<br>                      initializer: { 1738 }]<br>  }<br>  set {<br>    `foo.lazy`[varIn: self,<br>               initializer: { 1738 }] = newValue<br>  }<br>}<br>Furthermore, the behavior can provide additional operations, such as clear-ing a lazy property, by accessing it with property.behavior syntax:<br></p><p>foo.lazy.clear()<br>(The syntax for declaring and accessing the behavior is up for grabs; I’m offering these only as a starting point.)<br></p><p>Property behaviors obviate the need for special language support for lazy, observers, addressors, and other special-case property behavior, letting us move their functionality into libraries and support new behaviors as well.<br></p><p>Examples<br>Before describing the detailed design, I’ll run through some examples of potential applications for behaviors.<br></p><p>Lazy<br></p><p>The current lazy property feature can be reimplemented as a property behavior:<br></p><p>public struct Lazy&lt;Value&gt; {<br>  var value: Value?<br></p><p>  public init() {<br>    value = nil<br>  }<br></p><p>  public subscript&lt;Container&gt;(varIn _: Container,<br>                              initializer initial: () -&gt; Value) -&gt; Value {<br>    mutating get {<br>      if let existingValue = value {<br>        return existingValue<br>      }<br>      let initialValue = initial()<br>      value = initialValue<br>      return initialValue<br>    }<br>    set {<br>      value = newValue<br>    }<br>  }<br>}<br></p><p>public func lazy&lt;Value&gt;(var type: Value.Type, initializer _: () -&gt; Value)<br>    -&gt; Lazy&lt;Value&gt; {<br>  return Lazy()<br>}<br>As mentioned above, lazy in Swift 2 doesn’t provide a way to reset a lazy value to reclaim memory and let it be recomputed later. A behavior can provide additional operations on properties that use the behavior; for instance, to clear a lazy property:<br></p><p>extension Lazy {<br>  public mutating func clear() {<br>    value = nil<br>  }<br>}<br></p><p>var (lazy) x = somethingThatEatsMemory()<br>use(x)<br>x.lazy.clear()<br>Memoization<br></p><p>Variations of lazy can be implemented that are more appropriate for certain situations. For instance, here’s a memoizedbehavior that stores the cached value indirectly, making it suitable for immutable value types:<br></p><p>public class MemoizationBox&lt;Value&gt; {<br>  var value: Value? = nil<br>  init() {}<br>  func getOrEvaluate(fn: () -&gt; Value) -&gt; Value {<br>    if let value = value { return value }<br>    // Perform the initialization in a thread-safe way.<br>    // Implementation of &#39;sync&#39; not shown here.<br>    return sync {<br>      let initialValue = fn()<br>      value = initialValue<br>      return initialValue<br>    }<br>  }<br>  func clear() {<br>    value = nil<br>  }<br></p><p>  public subscript&lt;Container&gt;(letIn _: Container,<br>                              initializer value: () -&gt; Value) -&gt; Value {<br>    return box.getOrEvaluate(value)<br>  }<br>}<br></p><p>public func memoized&lt;Value&gt;(let type: Value.Type, initializer: () -&gt; Value)<br>    -&gt; MemoizationBox&lt;Value&gt; {<br>  return MemoizationBox()<br>}<br>Which can then be used like this:<br></p><p>struct Location {<br>  let street, city, postalCode: String<br></p><p>  let (memoized) address = &quot;\(street)\n\(city) \(postalCode)&quot;<br>}<br>Delayed Initialization<br></p><p>A property behavior can model “delayed” initialization behavior, where the DI rules for var and let properties are enforced dynamically rather than at compile time:<br></p><p>public func delayed&lt;Value&gt;(let type: Value.Type) -&gt; Delayed&lt;Value&gt; {<br>  return Delayed()<br>}<br>public func delayed&lt;Value&gt;(var type: Value.Type) -&gt; Delayed&lt;Value&gt; {<br>  return Delayed()<br>}<br></p><p>public struct Delayed&lt;Value&gt; {<br>  var value: Value? = nil<br></p><p>  /// DI rules for vars:<br>  /// - Must be assigned before being read<br>  public subscript&lt;Container&gt;(varIn container: Container) {<br>    get {<br>      if let value = value {<br>        return value<br>      }<br>      fatalError(&quot;delayed var used before being initialized&quot;)<br>    }<br>    set {<br>      value = newValue<br>    }<br>  }<br></p><p>  /// DI rules for lets:<br>  /// - Must be initialized once before being read<br>  /// - Cannot be reassigned<br>  public subscript&lt;Container&gt;(letIn container: Container) {<br>    get {<br>      if let value = value {<br>        return value<br>      }<br>      fatalError(&quot;delayed let used before being initialized&quot;)<br>    }<br>  }<br></p><p>  /// Behavior operation to initialize a delayed variable<br>  /// or constant.<br>  public mutating func initialize(value: Value) {<br>    if let value = value {<br>      fatalError(&quot;delayed property already initialized&quot;)<br>    }<br>    self.value = value<br>  }<br>}<br>which can be used like this:<br></p><p>class Foo {<br>  let (delayed) x: Int<br></p><p>  init() {<br>    // We don&#39;t know &quot;x&quot; yet, and we don&#39;t have to set it<br>  }<br></p><p>  func initializeX(x: Int) {<br>    self.x.delayed.initialize(x) // Will crash if &#39;self.x&#39; is already initialized<br>  }<br></p><p>  func getX() -&gt; Int {<br>    return x // Will crash if &#39;self.x&#39; wasn&#39;t initialized<br>  }<br>}<br>Resettable properties<br></p><p>There’s a common pattern in Cocoa where properties are used as optional customization points, but can be reset to nil to fall back to a non-public default value. In Swift, properties that follow this pattern currently must be imported as ImplicitlyUnwrappedOptional, even though the property can only be set to nil. If expressed as a behavior, the reset operation can be decoupled from the type, allowing the property to be exported as non-optional:<br></p><p>public func resettable&lt;Value&gt;(var type: Value.Type,<br>                      initializer fallback: () -&gt; Value) -&gt; Resettable&lt;Value&gt; {<br>  return Resettable(value: fallback())<br>}<br>public struct Resettable&lt;Value&gt; {<br>  var value: Value?<br></p><p>  public subscript&lt;Container&gt;(varIn container: Container,<br>                              initializer fallback: () -&gt; Value) -&gt; Value {<br>    get {<br>      if let value = value { return value }<br>      return fallback()<br>    }<br>    set {<br>      value = newValue<br>    }<br>  }<br></p><p>  public mutating func reset() {<br>    value = nil<br>  }<br>}<br></p><p>var (resettable) foo: Int = 22<br>print(foo) // =&gt; 22<br>foo = 44<br>print(foo) // =&gt; 44<br>foo.resettable.reset()<br>print(foo) // =&gt; 22<br>Synchronized Property Access<br></p><p>Objective-C supports atomic properties, which take a lock on get and set to synchronize accesses to a property. This is occasionally useful, and it can be brought to Swift as a behavior:<br></p><p>// A class that owns a mutex that can be used to synchronize access to its<br>// properties.<br>//<br>// `NSObject` could theoretically be extended to implement this using the<br>// object&#39;s `@synchronized` lock.<br>public protocol Synchronizable: class {<br>  func withLock&lt;R&gt;(@noescape body: () -&gt; R) -&gt; R<br>}<br></p><p>public func synchronized&lt;Value&gt;(var _: Value.Type,<br>                                initializer initial: () -&gt; Value)<br>    -&gt; Synchronized&lt;Value&gt; {<br>  return Synchronized(value: initial())<br>}<br></p><p>public struct Synchronized&lt;Value&gt; {<br>  var value: Value<br></p><p>  public subscript&lt;Container: Synchronizable&gt;(varIn container: Container,<br>                                              initializer _: () -&gt; Value)<br>      -&gt; Value {<br>    get {<br>      return container.withLock {<br>        return value<br>      }<br>    }<br>    set {<br>      container.withLock {<br>        value = newValue<br>      }<br>    }<br>  }<br>}<br>NSCopying<br></p><p>Many Cocoa classes implement value-like objects that require explicit copying. Swift currently provides an @NSCopying attribute for properties to give them behavior like Objective-C’s @property(copy), invoking the copy method on new objects when the property is set. We can turn this into a behavior:<br></p><p>public func copying&lt;Value: NSCopying&gt;(var _: Value.Type,<br>                                      initializer initial: () -&gt; Value)<br>    -&gt; Copying&lt;Value&gt; {<br>  return Copying(value: initial().copy())<br>}<br></p><p>public struct Copying&lt;Value&gt; {<br>  var value: Value<br></p><p>  public subscript&lt;Container&gt;(varIn container: Container,<br>                              initializer _: () -&gt; Value)<br>      -&gt; Value {<br>    get {<br>      return value<br>    }<br>    set {<br>      value = newValue.copy()<br>    }<br>  }<br>}<br>Referencing Properties with Pointers<br></p><p>We provide some affordances for interfacing properties with pointers for C interop and performance reasons, such as withUnsafePointer and implicit argument conversions. These affordances come with a lot of caveats and limitations. A property behavior can be defined that implements properties with manually-allocated memory, guaranteeing that pointers to the property can be freely taken and used:<br></p><p>public func pointable&lt;Value&gt;(var _: Value.Type,<br>                             initializer initial: () -&gt; Value)<br>    -&gt; Pointable&lt;Value&gt; {<br>  return Pointable(value: initial())<br>}<br></p><p>public class Pointable&lt;Value&gt; {<br>  public let pointer: UnsafeMutablePointer&lt;Value&gt;<br></p><p>  init(value: Value) {<br>    pointer = .alloc(1)<br>    pointer.initialize(value)<br>  }<br></p><p>  deinit {<br>    pointer.destroy()<br>    pointer.dealloc(1)<br>  }<br></p><p>  public subscript&lt;Container&gt;(varIn _: Container,<br>                              initializer _: () -&gt; Value)<br>      -&gt; Value {<br>    get {<br>      return pointer.memory<br>    }<br>    set {<br>      pointer.memory = newValue<br>    }<br>  }<br>}<br></p><p>var (pointable) x = 22<br>var (pointable) y = 44<br></p><p>memcpy(x.pointable.pointer, y.pointable.pointer, sizeof(Int.self))<br>print(x) // =&gt; 44<br>(Manually allocating and deallocating a pointer in a class is obviously not ideal, but is shown as an example. A production-quality stdlib implementation could use compiler magic to ensure the property is stored in-line in an addressable way.)<br></p><p>Property Observers<br></p><p>A property behavior can also replicate the built-in behavior of didSet/willSet observers:<br></p><p>typealias ObservingAccessor = (oldValue: Value, newValue: Value) -&gt; ()<br></p><p>public func observed&lt;Value&gt;(var _: Value.Type,<br>                            initializer initial: () -&gt; Value,<br>                            didSet _: ObservingAccessor = {},<br>                            willSet _: ObservingAccessor = {})<br>    -&gt; Observed&lt;Value&gt; {<br>  return Observed(value: initial())<br>}<br></p><p>public struct Observed&lt;Value&gt; {<br>  var value: Value<br></p><p>  public subscript&lt;Container&gt;(varIn _: Container,<br>                              initializer _: () -&gt; Value,<br>                              didSet didSet: ObservingAccessor = {},<br>                              willSet willSet: ObservingAccessor = {})<br>      -&gt; Value {<br>    get { return value }<br>    set {<br>      let oldValue = value<br>      willSet(oldValue, newValue)<br>      value = newValue<br>      didSet(oldValue, newValue)<br>    }<br>  }<br>}<br>A common complaint with didSet/willSet is that the observers fire on every write, not only ones that cause a real change. A behavior that supports a didChange accessor, which only gets invoked if the property value really changed to a value not equal to the old value, can be implemented as a new behavior:<br></p><p>public func changeObserved&lt;Value: Equatable&gt;(var _: Value.Type,<br>                                             initializer initial: () -&gt; Value,<br>                                             didChange _: ObservingAccessor = {})<br>    -&gt; ChangeObserved&lt;Value&gt; {<br>  return ChangeObserved(value: initial())<br>}<br></p><p>public struct ChangeObserved&lt;Value: Equatable&gt; {<br>  var value: Value<br></p><p>  public subscript&lt;Container&gt;(varIn _: Container,<br>                              initializer _: () -&gt; Value,<br>                              didChange didChange: ObservingAccessor = {}) {<br>    get { return value }<br>    set {<br>      if value == newValue { return }<br>      value = newValue<br>      didChange(oldValue, newValue)<br>    }<br>  }<br>}<br>This is a small sampling of the possibilities of behaviors. Let’s look at how they can be implemented:<br></p><p>Detailed design<br>A property declaration can declare a behavior after the var or let keyword in parens:<br></p><p>var (runcible) foo: Int<br>(Possible alternatives to var (behavior) are discussed later.) Inside the parens is a dotted declaration reference that must refer to a behavior function that accepts the property attributes (such as its name, type, initial value (if any), and accessor methods) as parameters. How attributes map to parameters is discussed below.<br></p><p>When a property declares a behavior, the compiler expands this into a backing property, which is initialized by invoking the behavior function with the property’s attributes as arguments. The backing property takes on whatever type is returned by the behavior function. The declared property forwards to the accessors of the backing property’s subscript(varIn:...) (or subscript(letIn:...)) member, with self as the first argument (or () for a free variable declaration). The subscript may also accept any or all of the property’s attributes as arguments. Approximately, the expansion looks like this:<br></p><p>var `foo.runcible` = runcible(var: Int.self)<br>var foo: Int {<br>  return `foo.runcible`[varIn: self]<br>}<br>with the fine print that the property directly receives the get, set, materializeForSet, etc. accessors from the behavior’s subscript declaration. By forwarding to a subscript instead of separate get and set methods, property behaviors preserve all of the mutable property optimizations we support now and in the future for free. The subscript also determines the mutability of the declared property.<br></p><p>The behavior function is resolved by building a call with the following keyword arguments, based on the property declaration:<br></p><p>The metatype of the declared property’s type is passed as an argument labeled var for a var, or labeled let for a let.<br>If the declared property provides an initial value, the initial value expression is passed as a () -&gt; T closure to an argument labeled initializer.<br>If the property is declared with accessors, their bodies are passed by named parameters corresponding to their names. Accessor names can be arbitrary identifiers.<br>For example, a property with a behavior and initial value:<br></p><p>var (runcible) foo = 1738<br>gets its backing property initialized as follows:<br></p><p>var `foo.runcible` = runcible(var: Int.self, initializer: { 1738 })<br>A property that declares accessor methods:<br></p><p>var (runcible) foo: Int {<br>  bar { print(&quot;bar&quot;) }<br>  bas(x) { print(&quot;bas \(x)&quot;) }<br>}<br>passes those accessors on to its behavior function:<br></p><p>private func `foo.bar`() { print(&quot;bar&quot;) }<br>private func `foo.bas`(x: T) { print(&quot;bar&quot;) }<br></p><p>var `foo.runcible` = runcible(var: Int.self,<br>                              bar: self.`foo.bar`,<br>                              bas: self.`foo.bas`)<br>Contextual types from the selected behavior function can be used to infer types for the accessors’ parameters as well as their default names. For example, if the behavior function is declared as:<br></p><p>func runcible&lt;T&gt;(var type: T.Type, bar: (newValue: T) -&gt; ())<br>  -&gt; RuncibleProperty&lt;T&gt;<br>then a bar accessor using this behavior can implicitly receive newValue as a parameter:<br></p><p>var (runcible) x: Int {<br>  bar { print(&quot;\(newValue.dynamicType)&quot;) } // prints Int<br>}<br>Once the behavior function has been resolved, its return type is searched for a matching subscript member with labeled index arguments:<br></p><p>The self value that contains the property is passed to a labeled varIn argument for a var, or a letIn argument for a let. This may be the metatype for a static property, or () for a global or local property.<br>After these arguments, the subscript must take the same labeled initializer and/or accessor closure arguments as the behavior function.<br>It is an error if a matching subscript can’t be found on the type. By constraining what types are allowed to be passed to the varIn or letIn parameter of the subscript, a behavior can constrain what kinds of container it is allowed to appear in.<br></p><p>By passing the initializer and accessor bodies to both the behavior function and subscript, the backing property can avoid requiring storage for closures it doesn’t need immediately at initialization time. It would be unacceptable if every lazy property needed to store its initialization closure in-line, for instance. The tradeoff is that there is potentially redundant work done forming these closures at both initialization and access time, and many of the arguments are not needed by both. However, if the behavior function and subscript are both inlineable, the optimizer ought to be able to eliminate dead arguments and simplify closures. For most applications, the attribute closures ought to be able to be @noescape as well.<br></p><p>Some behaviors may have special operations associated with them; for instance, a lazy property may provide a way to clear itself to reclaim memory and allow the value to be recomputed later when needed. The underlying backing property may be accessed by referencing it as property.behavior.<br></p><p>var (lazy) x = somethingThatEatsMemory()<br></p><p>use(x)<br>x.lazy.clear() // free the memory<br>The backing property has internal visibility by default (or private if the declared property is private). If the backing property should have higher visibility, the visibility can be declared next to the behavior:<br></p><p>public var (public lazy) x = somethingThatEatsMemory()<br>However, the backing property cannot have higher visibility than the declared property.<br></p><p>The backing property is always a stored var property. It is the responsibility of a let property behavior’s implementation to provide the expected behavior of an immutable property over it. A well behaved let should produce an identical value every time it is loaded, or die trying, as in the case of an uninitialized delayed let. A let should be safe to read concurrently from multiple threads. (In the fullness of time, an effects system might be able to enforce this, with escape hatches for internally-impure things like memoization of course.)<br></p><p>Impact on existing code<br>By itself, this is an additive feature that doesn’t impact existing code. However, it potentially obsoletes lazy, willSet/didSet, and @NSCopying as hardcoded language features. We could grandfather these in, but my preference would be to phase them out by migrating them to library-based property behavior implementations. (Removing them should be its own separate proposal, though.)<br></p><p>It’s also worth exploring whether property behaviors could replace the “addressor” mechanism used by the standard library to implement Array efficiently. It’d be great if the language only needed to expose the core conservative access pattern (get/set/materializeForSet) and let all variations be implemented as library features. Note that superseding didSet/willSet and addressors completely would require being able to apply behaviors to subscripts in addition to properties, which seems like a reasonable generalization.<br></p><p>Alternatives considered/to consider<br>Declaration syntax<br></p><p>Alternatives to the proposed var (behavior) propertyName syntax include:<br></p><p>An attribute, such as @behavior(lazy) or behavior(lazy) var. This is the most conservative answer, but is clunky.<br>Use the behavior function name directly as an attribute, so that e.g. @lazy works. This injects functions into the attribute namespace, which is problematic (but maybe not as much if the function itself also has to be marked with a @behavior_function attribute too).<br>Use a new keyword, as in var x: T by behavior.<br>Something on the right side of the colon, such as var x: lazy(T). To me this reads like lazy(T) is a type of some kind, which it really isn’t.<br>Something following the property name, such as var x«lazy»: T or var x¶lazy: T (picking your favorite ASCII characters to replace «»¶). One nice thing about this approach is that it suggests self.x«lazy» as a declaration-follows-use way of accessing the backing property.<br>Syntax for accessing the backing property<br></p><p>The proposal suggests x.behaviorName for accessing the underlying backing property of var (behaviorName) x. The main disadvantage of this is that it complicates name lookup, which must be aware of the behavior in order to resolve the name, and is potentially ambiguous, since the behavior name could of course also be the name of a member of the property’s type. Some alternatives to consider:<br></p><p>Reserving a keyword and syntactic form to refer to the backing property, such as foo.x.behavior or foo.behavior(x). The problems with this are that reserving a keyword is undesirable, and that behavior is a vague term that requires more context for a reader to understand what’s going on. If we support multiple behaviors on a property, it also doesn’t provide a mechanism to distinguish between behaviors.<br>Something following the property name, such a foo.x«lazy» or foo.x¶lazy (choosing your favorite ASCII substitution for «»¶, again), to match the similar proposed declaration syntax above.<br>“Overloading” the property name to refer to both the declared property and its backing property, and doing member lookup in both (favoring the declared property when there are conflicts). If foo.x is known to be lazy, it’s attractive for foo.x.clear() to Just Work without annotation. This has the usual ambiguity problems of overloading, of course; if the behavior’s members are shadowed by the fronting type, something incovenient like (foo.x as Lazy).clear() would be necessary to disambiguate.<br>Defining behavior requirements using a protocol<br></p><p>It’s reasonable to ask why the behavior interface proposed here is ad-hoc rather than modeled as a formal protocol. It’s my feeling that a protocol would be too constraining:<br></p><p>Different behaviors need the flexibility to require different sets of property attributes. Some kinds of property support initializers; some kinds of property have special accessors; some kinds of property support many different configurations. Allowing overloading (and adding new functionality via extensions and overloading) is important expressivity.<br>Different behaviors place different constraints on what containers are allowed to contain properties using the behavior, meaning that subscript needs the freedom to impose different generic constraints on its varIn/ letIn parameter for different behaviors.<br>It’s true that there are type system features we could theoretically add to support these features in a protocol, but increasing the complexity of the type system has its own tradeoffs. I think it’s unlikely that behaviors would be useful in generics either.<br></p><p>A behavior declaration<br></p><p>Instead of relying entirely on an informal protocol, we could add a new declaration to the language to declare a behavior, something like this:<br></p><p>behavior lazy&lt;T&gt; {<br>  func lazy(...) -&gt; Lazy { ... }<br>  struct Lazy { var value: T; ... }<br>}<br>Doing this has some potential advantages:<br></p><p>It provides clear namespacing for things that are intended to be behaviors.<br>If the functions and types that implement the behavior can be nested under the behavior declaration somehow, then they don’t need to pollute the global function/type namespace.<br>The behavior declaration can explicitly provide metadata about the behavior, such as what container and value types it supports, what kinds of accessors properties can provide to it, that are all discovered by overload resolution in this proposal. It’d also be a natural place to place extensions like how a behavior behaves with overriding, what behaviors it can or can’t compose with, etc.<br>Naming convention for behaviors<br></p><p>This proposal doesn’t discuss the naming convention that behaviors should follow. Should they be random adjectives like lazy? Should we try to follow an -ing or -able suffix convention? Does it matter, if behaviors have their own syntax namespace?<br></p><p>TODO<br>When do properties with behaviors get included in the memberwise initializer of structs or classes, if ever? Can properties with behaviors be initialized from init rather than with inline initializers?<br></p><p>Can behaviors be composed, e.g. (lazy, observed), or (lazy, atomic)? How? Composition necessarily has to have an ordering, and some orderings will be wrong; e.g. one of (lazy, atomic) or (atomic, lazy) will be broken.<br></p><p>To be able to fully supplant didSet/willSet (and addressors), we’d need to be able to give behaviors to subscripts as well. The special override behavior of didSet/willSet in subclasses needs to be accounted for as well.<br></p><p>It’s worth considering what the “primitive” interface for properties is; after all, theoretically even computed properties could be considered a behavior if you unstack enough turtles. One key thing to support that I don’t think our current special-case accessors handle is conditional physical access. For instance, a behavior might want to pass through to its physical property, unless some form of transactionality is enabled. As a strawman, if there were an inout accessor, which received the continuation of the property access as an (inout T) -&gt; Void parameter, that might be expressed like this:<br></p><p>var _x = 0<br>var x: Int {<br>  inout(continuation) {<br>    // If we&#39;re not logging, short-circuit to a physical access of `x`.<br>    if !logging {<br>      continuation(&amp;_x)<br>      return<br>    }<br>    // Otherwise, save the oldValue and log before and after<br>    let oldValue = x<br>    var newValue = x<br>    continuation(&amp;newValue)<br>    print(&quot;--- changing _x from \(oldValue) to \(newValue)&quot;)<br>    _x = newValue<br>    print(&quot;--- changed! _x from \(oldValue) to \(newValue)&quot;)<br>  }<br>}<br>An implementation of inout as proposed like this could be unrolled into a materializeForSet implementation using a SIL state machine transform, similar to what one would do to implement yield or await, which would check that continuation always gets called exactly once on all paths and capture the control flow after the continuation call in the materializeForSet continuation.<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#aftertoc&gt;<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#&gt;<br>Property Behaviors<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#propertybehaviors&gt;Introduction<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#introduction&gt;<br>Motivation<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#motivation&gt;<br>Proposed solution<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#proposedsolution&gt;<br>Examples<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#examples&gt;Lazy<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#lazy&gt;<br>Memoization<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#memoization&gt;<br>Delayed Initialization<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#delayedinitialization&gt;<br>Resettable properties<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#resettableproperties&gt;<br>Synchronized Property Access<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#synchronizedpropertyaccess&gt;<br>NSCopying<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#nscopying&gt;<br>Referencing Properties with Pointers<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#referencingpropertieswithpointers&gt;<br>Property Observers<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#propertyobservers&gt;<br>Detailed design<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#detaileddesign&gt;<br>Impact on existing code<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#impactonexistingcode&gt;<br>Alternatives considered/to consider<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#alternativesconsideredtoconsider&gt;Declaration syntax<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#declarationsyntax&gt;<br>Syntax for accessing the backing property<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#syntaxforaccessingthebackingproperty&gt;<br>Defining behavior requirements using a protocol<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#definingbehaviorrequirementsusingaprotocol&gt;<br>A behavior declaration<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#abehaviordeclaration&gt;<br>Naming convention for behaviors<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#namingconventionforbehaviors&gt;<br>TODO<br> &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#todo&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/4bf2142b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>The functionality looks like it is something that is definitely required to reduce the boiler-plate that Swift currently requires. However, this seems like a specific instance of a more general problem. For example, I run into a similar problem with working with other constructs, such as enums, where I want to provide specific “behaviors” for them that is just a bunch of boiler-plate code.<br></p><p>It seems like this proposal could be a starting place to start flush out what a macro/preprocessor/boiler-plate-reducer would look like in Swift. As such, I would like to see a syntax that could be extended beyond properties. Maybe this system is limited in scope to only allow this generation in specific contexts, like this property behavior, especially to scope this proposal down.<br></p><p>The short of it: I like the idea and it seems expandable to future concerns if syntax like attributes are used. And like you mentioned, these could be generate errors when used in the wrong contexts, such as lacking @behavior_function, or its equivalent.<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>I&#39;m in favor of the feature too. It addresses a real shortcoming in the language and it will make the syntax more general.<br></p><p>With my programming background, this looks like decorators applied specifically to properties. If this is a good way to think about it, then in case we want more for Swift 4, it might be a good idea to come up with a syntax that will easily be applicable to methods, free functions, types, enums, locals or anything else that could be decorated.<br></p><p>Félix<br></p><p>&gt; Le 17 déc. 2015 à 13:26:49, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; The functionality looks like it is something that is definitely required to reduce the boiler-plate that Swift currently requires. However, this seems like a specific instance of a more general problem. For example, I run into a similar problem with working with other constructs, such as enums, where I want to provide specific “behaviors” for them that is just a bunch of boiler-plate code.<br>&gt; <br>&gt; It seems like this proposal could be a starting place to start flush out what a macro/preprocessor/boiler-plate-reducer would look like in Swift. As such, I would like to see a syntax that could be extended beyond properties. Maybe this system is limited in scope to only allow this generation in specific contexts, like this property behavior, especially to scope this proposal down.<br>&gt; <br>&gt; The short of it: I like the idea and it seems expandable to future concerns if syntax like attributes are used. And like you mentioned, these could be generate errors when used in the wrong contexts, such as lacking @behavior_function, or its equivalent.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 10:26 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; The functionality looks like it is something that is definitely required to reduce the boiler-plate that Swift currently requires. However, this seems like a specific instance of a more general problem. For example, I run into a similar problem with working with other constructs, such as enums, where I want to provide specific “behaviors” for them that is just a bunch of boiler-plate code.<br>&gt; <br>&gt; It seems like this proposal could be a starting place to start flush out what a macro/preprocessor/boiler-plate-reducer would look like in Swift. As such, I would like to see a syntax that could be extended beyond properties. Maybe this system is limited in scope to only allow this generation in specific contexts, like this property behavior, especially to scope this proposal down.<br>&gt; <br>&gt; The short of it: I like the idea and it seems expandable to future concerns if syntax like attributes are used. And like you mentioned, these could be generate errors when used in the wrong contexts, such as lacking @behavior_function, or its equivalent.<br></p><p>Yeah, Python decorators came up as another potential model when we were discussing this internally, since it would be similarly useful to be able to concisely wrap function bodies in memoizing/logging/proxying logic. Properties were my first target, since we already have too many special-purpose features cooked into the language, and endless feature requests for new ones. I honestly haven&#39;t thought about generalization much; at first blush, I&#39;m concerned that the details of what you&#39;d want to plug in to in a &quot;function behavior&quot; is quite different from what you want in a property. Mutable properties have a bit of non-obvious internal complexity in the language model which influences this proposal, to keep copy-on-write efficient while still allowing for abstraction. That complexity probably wouldn&#39;t be necessary for other things like enum cases or function decorators.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>December 18, 2015 at 12:00:00am</p></header><div class="content"><p>Really grat and interesting!<br></p><p>I have a little question, would it allow to declare behaviours that accept only set and not gets? I&#39;ve found myself some times wanting a &quot;setter only&quot; modifier for properties. It can be done with methods (see watchkit for example) but with this proposal seems like it would be nice to have it.<br></p><p>And to point a small concern, as Matthew mentioned, It seems like some of this behaviors could reduce the actual safety of immutability with lets, specially the delayed initialization. Obviously this is better than not having any solution but would be nice to have it in the stdlib going in hand with some compiler checks.<br></p><p>Looks pretty need writing &quot;arbitrary&quot; (in a specific form, informal protocol) code that the compiler uses to generate this. Looking forward for more freedom in this camp.<br></p><p>Cheers,<br>Alex<br></p><p>Sent from my iPad<br></p><p>&gt; On 17 Dec 2015, at 18:26, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The functionality looks like it is something that is definitely required to reduce the boiler-plate that Swift currently requires. However, this seems like a specific instance of a more general problem. For example, I run into a similar problem with working with other constructs, such as enums, where I want to provide specific “behaviors” for them that is just a bunch of boiler-plate code.<br>&gt; <br>&gt; It seems like this proposal could be a starting place to start flush out what a macro/preprocessor/boiler-plate-reducer would look like in Swift. As such, I would like to see a syntax that could be extended beyond properties. Maybe this system is limited in scope to only allow this generation in specific contexts, like this property behavior, especially to scope this proposal down.<br>&gt; <br>&gt; The short of it: I like the idea and it seems expandable to future concerns if syntax like attributes are used. And like you mentioned, these could be generate errors when used in the wrong contexts, such as lacking @behavior_function, or its equivalent.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 4:05 PM, Alejandro Martinez &lt;alexito4 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Really grat and interesting!<br>&gt; <br>&gt; I have a little question, would it allow to declare behaviours that accept only set and not gets? I&#39;ve found myself some times wanting a &quot;setter only&quot; modifier for properties. It can be done with methods (see watchkit for example) but with this proposal seems like it would be nice to have it.<br></p><p>Set-only properties are problematic for our property model today. This proposal alone wouldn&#39;t provide them, though with Michel&#39;s proposed extension to allow a property to effectively have no accessors at all, you could implement a behavior that only exposed a set() operation on the property.<br></p><p>-Joe<br></p><p>&gt; And to point a small concern, as Matthew mentioned, It seems like some of this behaviors could reduce the actual safety of immutability with lets, specially the delayed initialization. Obviously this is better than not having any solution but would be nice to have it in the stdlib going in hand with some compiler checks.<br>&gt; <br>&gt; Looks pretty need writing &quot;arbitrary&quot; (in a specific form, informal protocol) code that the compiler uses to generate this. Looking forward for more freedom in this camp.<br>&gt; <br>&gt; Cheers,<br>&gt; Alex<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On 17 Dec 2015, at 18:26, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The functionality looks like it is something that is definitely required to reduce the boiler-plate that Swift currently requires. However, this seems like a specific instance of a more general problem. For example, I run into a similar problem with working with other constructs, such as enums, where I want to provide specific “behaviors” for them that is just a bunch of boiler-plate code.<br>&gt;&gt; <br>&gt;&gt; It seems like this proposal could be a starting place to start flush out what a macro/preprocessor/boiler-plate-reducer would look like in Swift. As such, I would like to see a syntax that could be extended beyond properties. Maybe this system is limited in scope to only allow this generation in specific contexts, like this property behavior, especially to scope this proposal down.<br>&gt;&gt; <br>&gt;&gt; The short of it: I like the idea and it seems expandable to future concerns if syntax like attributes are used. And like you mentioned, these could be generate errors when used in the wrong contexts, such as lacking @behavior_function, or its equivalent.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>I’ve really been looking forward to this proposal and I like this idea in general.  I may have comments about specific details after giving it more thought.<br></p><p>I have one significant concern that is worth mentioning immediately.  I would consider it extremely unfortunate if a delayed property behavior was considered sufficient in support of multi-phase initialization.  Using a property behavior for that purpose gives no guarantee that the value is actually initialized at some point during instance initialization.  IMO this is a major flaw.  A runtime error might occur when accessing a delayed property after initialization is supposed to be complete.<br></p><p>Delayed property behaviors may have appropriate use cases but IMO they are not an adequate substitute for something that provides stronger guarantees for the common case of multi-phase initialization.<br></p><p>I very strongly prefer to see direct language support for multi-phase initialization.  The compiler could provide most of the initialization guarantees it does for regular let properties.  It could enforce single assignment in the initializer body and could prevent the initializer body itself from reading the delayed property before assignment.  <br></p><p>The only guarantee that may not be possible is method calls to self during the second phase of initialization, but prior to assignment of all delayed properties (whether directly or by passing self to another instance) are potentially dangerous if they caused a read to a delayed property.  The potential for error is significantly narrower with direct language support.  As this is a very common use case (possibly the most common use case for delayed properties) I strongly believe it warrants direct language support.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 11:12 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I’ve really been looking forward to this proposal and I like this idea in general.  I may have comments about specific details after giving it more thought.<br>&gt; <br>&gt; I have one significant concern that is worth mentioning immediately.  I would consider it extremely unfortunate if a delayed property behavior was considered sufficient in support of multi-phase initialization.  Using a property behavior for that purpose gives no guarantee that the value is actually initialized at some point during instance initialization.  IMO this is a major flaw.  A runtime error might occur when accessing a delayed property after initialization is supposed to be complete.<br>&gt; <br>&gt; Delayed property behaviors may have appropriate use cases but IMO they are not an adequate substitute for something that provides stronger guarantees for the common case of multi-phase initialization.<br>&gt; <br>&gt; I very strongly prefer to see direct language support for multi-phase initialization.  The compiler could provide most of the initialization guarantees it does for regular let properties.  It could enforce single assignment in the initializer body and could prevent the initializer body itself from reading the delayed property before assignment.  <br></p><p>Even without any compiler support, I think implementing (delayed) as a behavior will be an improvement over the status quo. You get none of these guarantees with a `var T!` property either, and you also lose safety from some jerk resetting the property to `nil` or changing the property again after it&#39;s supposed to stop being mutated. Being a library feature also doesn&#39;t preclude a `delayed` behavior from offering diagnostics in common cases. One of our design goals for the SIL layer was to support dataflow-sensitive diagnostics like this; even though integers and arithmetic are implemented as library features, we run optimization passes that fold literal constant arithmetic down and raise errors when constant values aren&#39;t able to statically fit in their containing types. We could do something similar for a production-quality `(delayed)` implementation in the standard library.<br></p><p>&gt; The only guarantee that may not be possible is method calls to self during the second phase of initialization, but prior to assignment of all delayed properties (whether directly or by passing self to another instance) are potentially dangerous if they caused a read to a delayed property.  The potential for error is significantly narrower with direct language support.  As this is a very common use case (possibly the most common use case for delayed properties) I strongly believe it warrants direct language support.<br></p><p>Yeah, statically guaranteeing initialization phase order across method calls is tricky if you don&#39;t have type state or linear types, which until recently have been fairly esoteric features (though Rust is making the latter more prominent). I think implementing `delayed` as proposed still improves the static and dynamic safety of multi-phase initialization over what we have, and it doesn&#39;t shut the door to further refinement in the future.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 3:02 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 11:12 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’ve really been looking forward to this proposal and I like this idea in general.  I may have comments about specific details after giving it more thought.<br>&gt;&gt; <br>&gt;&gt; I have one significant concern that is worth mentioning immediately.  I would consider it extremely unfortunate if a delayed property behavior was considered sufficient in support of multi-phase initialization.  Using a property behavior for that purpose gives no guarantee that the value is actually initialized at some point during instance initialization.  IMO this is a major flaw.  A runtime error might occur when accessing a delayed property after initialization is supposed to be complete.<br>&gt;&gt; <br>&gt;&gt; Delayed property behaviors may have appropriate use cases but IMO they are not an adequate substitute for something that provides stronger guarantees for the common case of multi-phase initialization.<br>&gt;&gt; <br>&gt;&gt; I very strongly prefer to see direct language support for multi-phase initialization.  The compiler could provide most of the initialization guarantees it does for regular let properties.  It could enforce single assignment in the initializer body and could prevent the initializer body itself from reading the delayed property before assignment.  <br>&gt; <br>&gt; Even without any compiler support, I think implementing (delayed) as a behavior will be an improvement over the status quo. You get none of these guarantees with a `var T!` property either, and you also lose safety from some jerk resetting the property to `nil` or changing the property again after it&#39;s supposed to stop being mutated. Being a library feature also doesn&#39;t preclude a `delayed` behavior from offering diagnostics in common cases. One of our design goals for the SIL layer was to support dataflow-sensitive diagnostics like this; even though integers and arithmetic are implemented as library features, we run optimization passes that fold literal constant arithmetic down and raise errors when constant values aren&#39;t able to statically fit in their containing types. We could do something similar for a production-quality `(delayed)` implementation in the standard library.<br></p><p>Maybe I came across a bit too strongly.  I absolutely agree that a delayed property behavior would be a huge improvement over current state.  If the property behavior worked in conjunction with built-in initializer diagnostics that would address my concern.  Maybe I overlooked how closely the compiler and parts of the library are working together.  :)<br></p><p>&gt; <br>&gt;&gt; The only guarantee that may not be possible is method calls to self during the second phase of initialization, but prior to assignment of all delayed properties (whether directly or by passing self to another instance) are potentially dangerous if they caused a read to a delayed property.  The potential for error is significantly narrower with direct language support.  As this is a very common use case (possibly the most common use case for delayed properties) I strongly believe it warrants direct language support.<br>&gt; <br>&gt; Yeah, statically guaranteeing initialization phase order across method calls is tricky if you don&#39;t have type state or linear types, which until recently have been fairly esoteric features (though Rust is making the latter more prominent). I think implementing `delayed` as proposed still improves the static and dynamic safety of multi-phase initialization over what we have, and it doesn&#39;t shut the door to further refinement in the future.<br></p><p>I agree it is an improvement.  I just don’t want it to be the end game.  <br></p><p>Ideally it would come with basic initializer diagnostics that are easy to implement from the start.  That would limit any issues to initialization time which make me very happy and be a dramatic improvement over current state.<br></p><p>Refinements to improve safety of phase two of initialization would be welcome but certainly not an immediate concern.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Ideally it would come with basic initializer diagnostics that are easy to implement from the start.  That would limit any issues to initialization time which make me very happy and be a dramatic improvement over current state.<br></p><p>I should have also included a diagnostic for &#39;instance.x.delayed.initialize(x)&#39; being called outside an initializer so we can catch the jerk who tries to do that at compile time.  :)<br></p><p>Thanks for all of your hard work on this Joe.  Property behaviors look really cool and I&#39;m already looking forward to them.  I didn&#39;t mean to downplay that in my initial post.  I apologize if I did so by emphasizing a concern that wasn&#39;t addressed directly.<br></p><p>Strict compiler diagnostics for delayed would be really sweet icing on the cake.<br></p><p>Matthew<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>I’ve really been looking forward to this proposal and I like this idea in general.  I may have comments about specific details after giving it more thought.<br></p><p>I have one significant concern that is worth mentioning immediately.  I would consider it extremely unfortunate if a delayed property behavior was considered sufficient in support of multi-phase initialization.  Using a property behavior for that purpose gives no guarantee that the value is actually initialized at some point during instance initialization.  IMO this is a major flaw.  A runtime error might occur when accessing a delayed property after initialization is supposed to be complete.<br></p><p>Delayed property behaviors may have appropriate use cases but IMO they are not an adequate substitute for something that provides stronger guarantees for the common case of multi-phase initialization.<br></p><p>I very strongly prefer to see direct language support for multi-phase initialization.  The compiler could provide most of the initialization guarantees it does for regular let properties.  It could enforce single assignment in the initializer body and could prevent the initializer body itself from reading the delayed property before assignment.  <br></p><p>The only guarantee that may not be possible is method calls to self during the second phase of initialization, but prior to assignment of all delayed properties (whether directly or by passing self to another instance) are potentially dangerous if they caused a read to a delayed property.  The potential for error is significantly narrower with direct language support.  As this is a very common use case (possibly the most common use case for delayed properties) I strongly believe it warrants direct language support.<br></p><p>Matthew<br></p><p><br>&gt; On Dec 17, 2015, at 11:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on a design for allowing properties to be extended with user-defined delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open up for broader discussion. Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3 &lt;https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3&gt;<br>&gt; <br>&gt; Property Behaviors<br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Joe Groff &lt;https://github.com/jckarter&gt;<br>&gt; Status: Review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; There are property implementation patterns that come up repeatedly. Rather than hardcode a fixed set of patterns into the compiler, we should provide a general “property behavior” mechanism to allow these patterns to be defined as libraries.<br>&gt; <br>&gt; Motivation<br>&gt; We’ve tried to accommodate several important patterns for property with targeted language support, but this support has been narrow in scope and utility. For instance, Swift 1 and 2 provide lazy properties as a primitive language feature, since lazy initialization is common and is often necessary to avoid having properties be exposed as Optional. Without this language support, it takes a lot of boilerplate to get the same effect:<br>&gt; <br>&gt; class Foo {<br>&gt;   // lazy var foo = 1738<br>&gt;   private var _foo: Int?<br>&gt;   var foo: Int {<br>&gt;     get {<br>&gt;       if let value = _foo { return value }<br>&gt;       let initialValue = 1738<br>&gt;       _foo = initialValue<br>&gt;       return initialValue<br>&gt;     }<br>&gt;     set {<br>&gt;       _foo = newValue<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; Building lazy into the language has several disadvantages. It makes the language and compiler more complex and less orthogonal. It’s also inflexible; there are many variations on lazy initialization that make sense, but we wouldn’t want to hardcode language support for all of them. For instance, some applications may want the lazy initialization to be synchronized, but lazyonly provides single-threaded initialization. The standard implementation of lazy is also problematic for value types. A lazygetter must be mutating, which means it can’t be accessed from an immutable value. Inline storage is also suboptimal for many memoization tasks, since the cache cannot be reused across copies of the value. A value-oriented memoized property implementation might look very different:<br>&gt; <br>&gt; class MemoizationBox&lt;T&gt; {<br>&gt;   var value: T? = nil<br>&gt;   init() {}<br>&gt;   func getOrEvaluate(fn: () -&gt; T) -&gt; T {<br>&gt;     if let value = value { return value }<br>&gt;     // Perform initialization in a thread-safe way.<br>&gt;     // Implementation of `sync` not shown here<br>&gt;     return sync {<br>&gt;       let initialValue = fn()<br>&gt;       value = initialValue<br>&gt;       return initialValue<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; struct Person {<br>&gt;   let firstName: String<br>&gt;   let lastName: String<br>&gt; <br>&gt;   let _cachedFullName = MemoizationBox&lt;String&gt;()<br>&gt; <br>&gt;   var fullName: String {<br>&gt;     return _cachedFullName.getOrEvaluate { &quot;\(firstName) \(lastName)&quot; }<br>&gt;   }<br>&gt; }<br>&gt; Lazy properties are also unable to surface any additional operations over a regular property. It would be useful to be able to reset a lazy property’s storage to be recomputed again, for instance, but this isn’t possible with lazy.<br>&gt; <br>&gt; There are important property patterns outside of lazy initialization. It often makes sense to have “delayed”, once-assignable-then-immutable properties to support multi-phase initialization:<br>&gt; <br>&gt; class Foo {<br>&gt;   let immediatelyInitialized = &quot;foo&quot;<br>&gt;   var _initializedLater: String?<br>&gt; <br>&gt;   // We want initializedLater to present like a non-optional &#39;let&#39; to user code;<br>&gt;   // it can only be assigned once, and can&#39;t be accessed before being assigned.<br>&gt;   var initializedLater: String {<br>&gt;     get { return _initializedLater! }<br>&gt;     set {<br>&gt;       assert(_initializedLater == nil)<br>&gt;       _initializedLater = newValue<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; Implicitly-unwrapped optionals allow this in a pinch, but give up a lot of safety compared to a non-optional ‘let’. Using IUO for multi-phase initialization gives up both immutability and nil-safety.<br>&gt; <br>&gt; We also have other application-specific property features like didSet/willSet and array addressors that add language complexity for limited functionality. Beyond what we’ve baked into the language already, there’s a seemingly endless set of common property behaviors, including resetting, synchronized access, and various kinds of proxying, all begging for language attention to eliminate their boilerplate.<br>&gt; <br>&gt; Proposed solution<br>&gt; I suggest we allow for property behaviors to be implemented within the language. A var or let declaration can specify its behavior in parens after the keyword:<br>&gt; <br>&gt; var (lazy) foo = 1738<br>&gt; which acts as sugar for something like this:<br>&gt; <br>&gt; var `foo.lazy` = lazy(var: Int.self, initializer: { 1738 })<br>&gt; var foo: Int {<br>&gt;   get {<br>&gt;     return `foo.lazy`[varIn: self,<br>&gt;                       initializer: { 1738 }]<br>&gt;   }<br>&gt;   set {<br>&gt;     `foo.lazy`[varIn: self,<br>&gt;                initializer: { 1738 }] = newValue<br>&gt;   }<br>&gt; }<br>&gt; Furthermore, the behavior can provide additional operations, such as clear-ing a lazy property, by accessing it with property.behavior syntax:<br>&gt; <br>&gt; foo.lazy.clear()<br>&gt; (The syntax for declaring and accessing the behavior is up for grabs; I’m offering these only as a starting point.)<br>&gt; <br>&gt; Property behaviors obviate the need for special language support for lazy, observers, addressors, and other special-case property behavior, letting us move their functionality into libraries and support new behaviors as well.<br>&gt; <br>&gt; Examples<br>&gt; Before describing the detailed design, I’ll run through some examples of potential applications for behaviors.<br>&gt; <br>&gt; Lazy<br>&gt; <br>&gt; The current lazy property feature can be reimplemented as a property behavior:<br>&gt; <br>&gt; public struct Lazy&lt;Value&gt; {<br>&gt;   var value: Value?<br>&gt; <br>&gt;   public init() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; <br>&gt;   public subscript&lt;Container&gt;(varIn _: Container,<br>&gt;                               initializer initial: () -&gt; Value) -&gt; Value {<br>&gt;     mutating get {<br>&gt;       if let existingValue = value {<br>&gt;         return existingValue<br>&gt;       }<br>&gt;       let initialValue = initial()<br>&gt;       value = initialValue<br>&gt;       return initialValue<br>&gt;     }<br>&gt;     set {<br>&gt;       value = newValue<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; public func lazy&lt;Value&gt;(var type: Value.Type, initializer _: () -&gt; Value)<br>&gt;     -&gt; Lazy&lt;Value&gt; {<br>&gt;   return Lazy()<br>&gt; }<br>&gt; As mentioned above, lazy in Swift 2 doesn’t provide a way to reset a lazy value to reclaim memory and let it be recomputed later. A behavior can provide additional operations on properties that use the behavior; for instance, to clear a lazy property:<br>&gt; <br>&gt; extension Lazy {<br>&gt;   public mutating func clear() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var (lazy) x = somethingThatEatsMemory()<br>&gt; use(x)<br>&gt; x.lazy.clear()<br>&gt; Memoization<br>&gt; <br>&gt; Variations of lazy can be implemented that are more appropriate for certain situations. For instance, here’s a memoizedbehavior that stores the cached value indirectly, making it suitable for immutable value types:<br>&gt; <br>&gt; public class MemoizationBox&lt;Value&gt; {<br>&gt;   var value: Value? = nil<br>&gt;   init() {}<br>&gt;   func getOrEvaluate(fn: () -&gt; Value) -&gt; Value {<br>&gt;     if let value = value { return value }<br>&gt;     // Perform the initialization in a thread-safe way.<br>&gt;     // Implementation of &#39;sync&#39; not shown here.<br>&gt;     return sync {<br>&gt;       let initialValue = fn()<br>&gt;       value = initialValue<br>&gt;       return initialValue<br>&gt;     }<br>&gt;   }<br>&gt;   func clear() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; <br>&gt;   public subscript&lt;Container&gt;(letIn _: Container,<br>&gt;                               initializer value: () -&gt; Value) -&gt; Value {<br>&gt;     return box.getOrEvaluate(value)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; public func memoized&lt;Value&gt;(let type: Value.Type, initializer: () -&gt; Value)<br>&gt;     -&gt; MemoizationBox&lt;Value&gt; {<br>&gt;   return MemoizationBox()<br>&gt; }<br>&gt; Which can then be used like this:<br>&gt; <br>&gt; struct Location {<br>&gt;   let street, city, postalCode: String<br>&gt; <br>&gt;   let (memoized) address = &quot;\(street)\n\(city) \(postalCode)&quot;<br>&gt; }<br>&gt; Delayed Initialization<br>&gt; <br>&gt; A property behavior can model “delayed” initialization behavior, where the DI rules for var and let properties are enforced dynamically rather than at compile time:<br>&gt; <br>&gt; public func delayed&lt;Value&gt;(let type: Value.Type) -&gt; Delayed&lt;Value&gt; {<br>&gt;   return Delayed()<br>&gt; }<br>&gt; public func delayed&lt;Value&gt;(var type: Value.Type) -&gt; Delayed&lt;Value&gt; {<br>&gt;   return Delayed()<br>&gt; }<br>&gt; <br>&gt; public struct Delayed&lt;Value&gt; {<br>&gt;   var value: Value? = nil<br>&gt; <br>&gt;   /// DI rules for vars:<br>&gt;   /// - Must be assigned before being read<br>&gt;   public subscript&lt;Container&gt;(varIn container: Container) {<br>&gt;     get {<br>&gt;       if let value = value {<br>&gt;         return value<br>&gt;       }<br>&gt;       fatalError(&quot;delayed var used before being initialized&quot;)<br>&gt;     }<br>&gt;     set {<br>&gt;       value = newValue<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   /// DI rules for lets:<br>&gt;   /// - Must be initialized once before being read<br>&gt;   /// - Cannot be reassigned<br>&gt;   public subscript&lt;Container&gt;(letIn container: Container) {<br>&gt;     get {<br>&gt;       if let value = value {<br>&gt;         return value<br>&gt;       }<br>&gt;       fatalError(&quot;delayed let used before being initialized&quot;)<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   /// Behavior operation to initialize a delayed variable<br>&gt;   /// or constant.<br>&gt;   public mutating func initialize(value: Value) {<br>&gt;     if let value = value {<br>&gt;       fatalError(&quot;delayed property already initialized&quot;)<br>&gt;     }<br>&gt;     self.value = value<br>&gt;   }<br>&gt; }<br>&gt; which can be used like this:<br>&gt; <br>&gt; class Foo {<br>&gt;   let (delayed) x: Int<br>&gt; <br>&gt;   init() {<br>&gt;     // We don&#39;t know &quot;x&quot; yet, and we don&#39;t have to set it<br>&gt;   }<br>&gt; <br>&gt;   func initializeX(x: Int) {<br>&gt;     self.x.delayed.initialize(x) // Will crash if &#39;self.x&#39; is already initialized<br>&gt;   }<br>&gt; <br>&gt;   func getX() -&gt; Int {<br>&gt;     return x // Will crash if &#39;self.x&#39; wasn&#39;t initialized<br>&gt;   }<br>&gt; }<br>&gt; Resettable properties<br>&gt; <br>&gt; There’s a common pattern in Cocoa where properties are used as optional customization points, but can be reset to nil to fall back to a non-public default value. In Swift, properties that follow this pattern currently must be imported as ImplicitlyUnwrappedOptional, even though the property can only be set to nil. If expressed as a behavior, the reset operation can be decoupled from the type, allowing the property to be exported as non-optional:<br>&gt; <br>&gt; public func resettable&lt;Value&gt;(var type: Value.Type,<br>&gt;                       initializer fallback: () -&gt; Value) -&gt; Resettable&lt;Value&gt; {<br>&gt;   return Resettable(value: fallback())<br>&gt; }<br>&gt; public struct Resettable&lt;Value&gt; {<br>&gt;   var value: Value?<br>&gt; <br>&gt;   public subscript&lt;Container&gt;(varIn container: Container,<br>&gt;                               initializer fallback: () -&gt; Value) -&gt; Value {<br>&gt;     get {<br>&gt;       if let value = value { return value }<br>&gt;       return fallback()<br>&gt;     }<br>&gt;     set {<br>&gt;       value = newValue<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   public mutating func reset() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var (resettable) foo: Int = 22<br>&gt; print(foo) // =&gt; 22<br>&gt; foo = 44<br>&gt; print(foo) // =&gt; 44<br>&gt; foo.resettable.reset()<br>&gt; print(foo) // =&gt; 22<br>&gt; Synchronized Property Access<br>&gt; <br>&gt; Objective-C supports atomic properties, which take a lock on get and set to synchronize accesses to a property. This is occasionally useful, and it can be brought to Swift as a behavior:<br>&gt; <br>&gt; // A class that owns a mutex that can be used to synchronize access to its<br>&gt; // properties.<br>&gt; //<br>&gt; // `NSObject` could theoretically be extended to implement this using the<br>&gt; // object&#39;s `@synchronized` lock.<br>&gt; public protocol Synchronizable: class {<br>&gt;   func withLock&lt;R&gt;(@noescape body: () -&gt; R) -&gt; R<br>&gt; }<br>&gt; <br>&gt; public func synchronized&lt;Value&gt;(var _: Value.Type,<br>&gt;                                 initializer initial: () -&gt; Value)<br>&gt;     -&gt; Synchronized&lt;Value&gt; {<br>&gt;   return Synchronized(value: initial())<br>&gt; }<br>&gt; <br>&gt; public struct Synchronized&lt;Value&gt; {<br>&gt;   var value: Value<br>&gt; <br>&gt;   public subscript&lt;Container: Synchronizable&gt;(varIn container: Container,<br>&gt;                                               initializer _: () -&gt; Value)<br>&gt;       -&gt; Value {<br>&gt;     get {<br>&gt;       return container.withLock {<br>&gt;         return value<br>&gt;       }<br>&gt;     }<br>&gt;     set {<br>&gt;       container.withLock {<br>&gt;         value = newValue<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; NSCopying<br>&gt; <br>&gt; Many Cocoa classes implement value-like objects that require explicit copying. Swift currently provides an @NSCopying attribute for properties to give them behavior like Objective-C’s @property(copy), invoking the copy method on new objects when the property is set. We can turn this into a behavior:<br>&gt; <br>&gt; public func copying&lt;Value: NSCopying&gt;(var _: Value.Type,<br>&gt;                                       initializer initial: () -&gt; Value)<br>&gt;     -&gt; Copying&lt;Value&gt; {<br>&gt;   return Copying(value: initial().copy())<br>&gt; }<br>&gt; <br>&gt; public struct Copying&lt;Value&gt; {<br>&gt;   var value: Value<br>&gt; <br>&gt;   public subscript&lt;Container&gt;(varIn container: Container,<br>&gt;                               initializer _: () -&gt; Value)<br>&gt;       -&gt; Value {<br>&gt;     get {<br>&gt;       return value<br>&gt;     }<br>&gt;     set {<br>&gt;       value = newValue.copy()<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; Referencing Properties with Pointers<br>&gt; <br>&gt; We provide some affordances for interfacing properties with pointers for C interop and performance reasons, such as withUnsafePointer and implicit argument conversions. These affordances come with a lot of caveats and limitations. A property behavior can be defined that implements properties with manually-allocated memory, guaranteeing that pointers to the property can be freely taken and used:<br>&gt; <br>&gt; public func pointable&lt;Value&gt;(var _: Value.Type,<br>&gt;                              initializer initial: () -&gt; Value)<br>&gt;     -&gt; Pointable&lt;Value&gt; {<br>&gt;   return Pointable(value: initial())<br>&gt; }<br>&gt; <br>&gt; public class Pointable&lt;Value&gt; {<br>&gt;   public let pointer: UnsafeMutablePointer&lt;Value&gt;<br>&gt; <br>&gt;   init(value: Value) {<br>&gt;     pointer = .alloc(1)<br>&gt;     pointer.initialize(value)<br>&gt;   }<br>&gt; <br>&gt;   deinit {<br>&gt;     pointer.destroy()<br>&gt;     pointer.dealloc(1)<br>&gt;   }<br>&gt; <br>&gt;   public subscript&lt;Container&gt;(varIn _: Container,<br>&gt;                               initializer _: () -&gt; Value)<br>&gt;       -&gt; Value {<br>&gt;     get {<br>&gt;       return pointer.memory<br>&gt;     }<br>&gt;     set {<br>&gt;       pointer.memory = newValue<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; var (pointable) x = 22<br>&gt; var (pointable) y = 44<br>&gt; <br>&gt; memcpy(x.pointable.pointer, y.pointable.pointer, sizeof(Int.self))<br>&gt; print(x) // =&gt; 44<br>&gt; (Manually allocating and deallocating a pointer in a class is obviously not ideal, but is shown as an example. A production-quality stdlib implementation could use compiler magic to ensure the property is stored in-line in an addressable way.)<br>&gt; <br>&gt; Property Observers<br>&gt; <br>&gt; A property behavior can also replicate the built-in behavior of didSet/willSet observers:<br>&gt; <br>&gt; typealias ObservingAccessor = (oldValue: Value, newValue: Value) -&gt; ()<br>&gt; <br>&gt; public func observed&lt;Value&gt;(var _: Value.Type,<br>&gt;                             initializer initial: () -&gt; Value,<br>&gt;                             didSet _: ObservingAccessor = {},<br>&gt;                             willSet _: ObservingAccessor = {})<br>&gt;     -&gt; Observed&lt;Value&gt; {<br>&gt;   return Observed(value: initial())<br>&gt; }<br>&gt; <br>&gt; public struct Observed&lt;Value&gt; {<br>&gt;   var value: Value<br>&gt; <br>&gt;   public subscript&lt;Container&gt;(varIn _: Container,<br>&gt;                               initializer _: () -&gt; Value,<br>&gt;                               didSet didSet: ObservingAccessor = {},<br>&gt;                               willSet willSet: ObservingAccessor = {})<br>&gt;       -&gt; Value {<br>&gt;     get { return value }<br>&gt;     set {<br>&gt;       let oldValue = value<br>&gt;       willSet(oldValue, newValue)<br>&gt;       value = newValue<br>&gt;       didSet(oldValue, newValue)<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; A common complaint with didSet/willSet is that the observers fire on every write, not only ones that cause a real change. A behavior that supports a didChange accessor, which only gets invoked if the property value really changed to a value not equal to the old value, can be implemented as a new behavior:<br>&gt; <br>&gt; public func changeObserved&lt;Value: Equatable&gt;(var _: Value.Type,<br>&gt;                                              initializer initial: () -&gt; Value,<br>&gt;                                              didChange _: ObservingAccessor = {})<br>&gt;     -&gt; ChangeObserved&lt;Value&gt; {<br>&gt;   return ChangeObserved(value: initial())<br>&gt; }<br>&gt; <br>&gt; public struct ChangeObserved&lt;Value: Equatable&gt; {<br>&gt;   var value: Value<br>&gt; <br>&gt;   public subscript&lt;Container&gt;(varIn _: Container,<br>&gt;                               initializer _: () -&gt; Value,<br>&gt;                               didChange didChange: ObservingAccessor = {}) {<br>&gt;     get { return value }<br>&gt;     set {<br>&gt;       if value == newValue { return }<br>&gt;       value = newValue<br>&gt;       didChange(oldValue, newValue)<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; This is a small sampling of the possibilities of behaviors. Let’s look at how they can be implemented:<br>&gt; <br>&gt; Detailed design<br>&gt; A property declaration can declare a behavior after the var or let keyword in parens:<br>&gt; <br>&gt; var (runcible) foo: Int<br>&gt; (Possible alternatives to var (behavior) are discussed later.) Inside the parens is a dotted declaration reference that must refer to a behavior function that accepts the property attributes (such as its name, type, initial value (if any), and accessor methods) as parameters. How attributes map to parameters is discussed below.<br>&gt; <br>&gt; When a property declares a behavior, the compiler expands this into a backing property, which is initialized by invoking the behavior function with the property’s attributes as arguments. The backing property takes on whatever type is returned by the behavior function. The declared property forwards to the accessors of the backing property’s subscript(varIn:...) (or subscript(letIn:...)) member, with self as the first argument (or () for a free variable declaration). The subscript may also accept any or all of the property’s attributes as arguments. Approximately, the expansion looks like this:<br>&gt; <br>&gt; var `foo.runcible` = runcible(var: Int.self)<br>&gt; var foo: Int {<br>&gt;   return `foo.runcible`[varIn: self]<br>&gt; }<br>&gt; with the fine print that the property directly receives the get, set, materializeForSet, etc. accessors from the behavior’s subscript declaration. By forwarding to a subscript instead of separate get and set methods, property behaviors preserve all of the mutable property optimizations we support now and in the future for free. The subscript also determines the mutability of the declared property.<br>&gt; <br>&gt; The behavior function is resolved by building a call with the following keyword arguments, based on the property declaration:<br>&gt; <br>&gt; The metatype of the declared property’s type is passed as an argument labeled var for a var, or labeled let for a let.<br>&gt; If the declared property provides an initial value, the initial value expression is passed as a () -&gt; T closure to an argument labeled initializer.<br>&gt; If the property is declared with accessors, their bodies are passed by named parameters corresponding to their names. Accessor names can be arbitrary identifiers.<br>&gt; For example, a property with a behavior and initial value:<br>&gt; <br>&gt; var (runcible) foo = 1738<br>&gt; gets its backing property initialized as follows:<br>&gt; <br>&gt; var `foo.runcible` = runcible(var: Int.self, initializer: { 1738 })<br>&gt; A property that declares accessor methods:<br>&gt; <br>&gt; var (runcible) foo: Int {<br>&gt;   bar { print(&quot;bar&quot;) }<br>&gt;   bas(x) { print(&quot;bas \(x)&quot;) }<br>&gt; }<br>&gt; passes those accessors on to its behavior function:<br>&gt; <br>&gt; private func `foo.bar`() { print(&quot;bar&quot;) }<br>&gt; private func `foo.bas`(x: T) { print(&quot;bar&quot;) }<br>&gt; <br>&gt; var `foo.runcible` = runcible(var: Int.self,<br>&gt;                               bar: self.`foo.bar`,<br>&gt;                               bas: self.`foo.bas`)<br>&gt; Contextual types from the selected behavior function can be used to infer types for the accessors’ parameters as well as their default names. For example, if the behavior function is declared as:<br>&gt; <br>&gt; func runcible&lt;T&gt;(var type: T.Type, bar: (newValue: T) -&gt; ())<br>&gt;   -&gt; RuncibleProperty&lt;T&gt;<br>&gt; then a bar accessor using this behavior can implicitly receive newValue as a parameter:<br>&gt; <br>&gt; var (runcible) x: Int {<br>&gt;   bar { print(&quot;\(newValue.dynamicType)&quot;) } // prints Int<br>&gt; }<br>&gt; Once the behavior function has been resolved, its return type is searched for a matching subscript member with labeled index arguments:<br>&gt; <br>&gt; The self value that contains the property is passed to a labeled varIn argument for a var, or a letIn argument for a let. This may be the metatype for a static property, or () for a global or local property.<br>&gt; After these arguments, the subscript must take the same labeled initializer and/or accessor closure arguments as the behavior function.<br>&gt; It is an error if a matching subscript can’t be found on the type. By constraining what types are allowed to be passed to the varIn or letIn parameter of the subscript, a behavior can constrain what kinds of container it is allowed to appear in.<br>&gt; <br>&gt; By passing the initializer and accessor bodies to both the behavior function and subscript, the backing property can avoid requiring storage for closures it doesn’t need immediately at initialization time. It would be unacceptable if every lazy property needed to store its initialization closure in-line, for instance. The tradeoff is that there is potentially redundant work done forming these closures at both initialization and access time, and many of the arguments are not needed by both. However, if the behavior function and subscript are both inlineable, the optimizer ought to be able to eliminate dead arguments and simplify closures. For most applications, the attribute closures ought to be able to be @noescape as well.<br>&gt; <br>&gt; Some behaviors may have special operations associated with them; for instance, a lazy property may provide a way to clear itself to reclaim memory and allow the value to be recomputed later when needed. The underlying backing property may be accessed by referencing it as property.behavior.<br>&gt; <br>&gt; var (lazy) x = somethingThatEatsMemory()<br>&gt; <br>&gt; use(x)<br>&gt; x.lazy.clear() // free the memory<br>&gt; The backing property has internal visibility by default (or private if the declared property is private). If the backing property should have higher visibility, the visibility can be declared next to the behavior:<br>&gt; <br>&gt; public var (public lazy) x = somethingThatEatsMemory()<br>&gt; However, the backing property cannot have higher visibility than the declared property.<br>&gt; <br>&gt; The backing property is always a stored var property. It is the responsibility of a let property behavior’s implementation to provide the expected behavior of an immutable property over it. A well behaved let should produce an identical value every time it is loaded, or die trying, as in the case of an uninitialized delayed let. A let should be safe to read concurrently from multiple threads. (In the fullness of time, an effects system might be able to enforce this, with escape hatches for internally-impure things like memoization of course.)<br>&gt; <br>&gt; Impact on existing code<br>&gt; By itself, this is an additive feature that doesn’t impact existing code. However, it potentially obsoletes lazy, willSet/didSet, and @NSCopying as hardcoded language features. We could grandfather these in, but my preference would be to phase them out by migrating them to library-based property behavior implementations. (Removing them should be its own separate proposal, though.)<br>&gt; <br>&gt; It’s also worth exploring whether property behaviors could replace the “addressor” mechanism used by the standard library to implement Array efficiently. It’d be great if the language only needed to expose the core conservative access pattern (get/set/materializeForSet) and let all variations be implemented as library features. Note that superseding didSet/willSet and addressors completely would require being able to apply behaviors to subscripts in addition to properties, which seems like a reasonable generalization.<br>&gt; <br>&gt; Alternatives considered/to consider<br>&gt; Declaration syntax<br>&gt; <br>&gt; Alternatives to the proposed var (behavior) propertyName syntax include:<br>&gt; <br>&gt; An attribute, such as @behavior(lazy) or behavior(lazy) var. This is the most conservative answer, but is clunky.<br>&gt; Use the behavior function name directly as an attribute, so that e.g. @lazy works. This injects functions into the attribute namespace, which is problematic (but maybe not as much if the function itself also has to be marked with a @behavior_function attribute too).<br>&gt; Use a new keyword, as in var x: T by behavior.<br>&gt; Something on the right side of the colon, such as var x: lazy(T). To me this reads like lazy(T) is a type of some kind, which it really isn’t.<br>&gt; Something following the property name, such as var x«lazy»: T or var x¶lazy: T (picking your favorite ASCII characters to replace «»¶). One nice thing about this approach is that it suggests self.x«lazy» as a declaration-follows-use way of accessing the backing property.<br>&gt; Syntax for accessing the backing property<br>&gt; <br>&gt; The proposal suggests x.behaviorName for accessing the underlying backing property of var (behaviorName) x. The main disadvantage of this is that it complicates name lookup, which must be aware of the behavior in order to resolve the name, and is potentially ambiguous, since the behavior name could of course also be the name of a member of the property’s type. Some alternatives to consider:<br>&gt; <br>&gt; Reserving a keyword and syntactic form to refer to the backing property, such as foo.x.behavior or foo.behavior(x). The problems with this are that reserving a keyword is undesirable, and that behavior is a vague term that requires more context for a reader to understand what’s going on. If we support multiple behaviors on a property, it also doesn’t provide a mechanism to distinguish between behaviors.<br>&gt; Something following the property name, such a foo.x«lazy» or foo.x¶lazy (choosing your favorite ASCII substitution for «»¶, again), to match the similar proposed declaration syntax above.<br>&gt; “Overloading” the property name to refer to both the declared property and its backing property, and doing member lookup in both (favoring the declared property when there are conflicts). If foo.x is known to be lazy, it’s attractive for foo.x.clear() to Just Work without annotation. This has the usual ambiguity problems of overloading, of course; if the behavior’s members are shadowed by the fronting type, something incovenient like (foo.x as Lazy).clear() would be necessary to disambiguate.<br>&gt; Defining behavior requirements using a protocol<br>&gt; <br>&gt; It’s reasonable to ask why the behavior interface proposed here is ad-hoc rather than modeled as a formal protocol. It’s my feeling that a protocol would be too constraining:<br>&gt; <br>&gt; Different behaviors need the flexibility to require different sets of property attributes. Some kinds of property support initializers; some kinds of property have special accessors; some kinds of property support many different configurations. Allowing overloading (and adding new functionality via extensions and overloading) is important expressivity.<br>&gt; Different behaviors place different constraints on what containers are allowed to contain properties using the behavior, meaning that subscript needs the freedom to impose different generic constraints on its varIn/ letIn parameter for different behaviors.<br>&gt; It’s true that there are type system features we could theoretically add to support these features in a protocol, but increasing the complexity of the type system has its own tradeoffs. I think it’s unlikely that behaviors would be useful in generics either.<br>&gt; <br>&gt; A behavior declaration<br>&gt; <br>&gt; Instead of relying entirely on an informal protocol, we could add a new declaration to the language to declare a behavior, something like this:<br>&gt; <br>&gt; behavior lazy&lt;T&gt; {<br>&gt;   func lazy(...) -&gt; Lazy { ... }<br>&gt;   struct Lazy { var value: T; ... }<br>&gt; }<br>&gt; Doing this has some potential advantages:<br>&gt; <br>&gt; It provides clear namespacing for things that are intended to be behaviors.<br>&gt; If the functions and types that implement the behavior can be nested under the behavior declaration somehow, then they don’t need to pollute the global function/type namespace.<br>&gt; The behavior declaration can explicitly provide metadata about the behavior, such as what container and value types it supports, what kinds of accessors properties can provide to it, that are all discovered by overload resolution in this proposal. It’d also be a natural place to place extensions like how a behavior behaves with overriding, what behaviors it can or can’t compose with, etc.<br>&gt; Naming convention for behaviors<br>&gt; <br>&gt; This proposal doesn’t discuss the naming convention that behaviors should follow. Should they be random adjectives like lazy? Should we try to follow an -ing or -able suffix convention? Does it matter, if behaviors have their own syntax namespace?<br>&gt; <br>&gt; TODO<br>&gt; When do properties with behaviors get included in the memberwise initializer of structs or classes, if ever? Can properties with behaviors be initialized from init rather than with inline initializers?<br>&gt; <br>&gt; Can behaviors be composed, e.g. (lazy, observed), or (lazy, atomic)? How? Composition necessarily has to have an ordering, and some orderings will be wrong; e.g. one of (lazy, atomic) or (atomic, lazy) will be broken.<br>&gt; <br>&gt; To be able to fully supplant didSet/willSet (and addressors), we’d need to be able to give behaviors to subscripts as well. The special override behavior of didSet/willSet in subclasses needs to be accounted for as well.<br>&gt; <br>&gt; It’s worth considering what the “primitive” interface for properties is; after all, theoretically even computed properties could be considered a behavior if you unstack enough turtles. One key thing to support that I don’t think our current special-case accessors handle is conditional physical access. For instance, a behavior might want to pass through to its physical property, unless some form of transactionality is enabled. As a strawman, if there were an inout accessor, which received the continuation of the property access as an (inout T) -&gt; Void parameter, that might be expressed like this:<br>&gt; <br>&gt; var _x = 0<br>&gt; var x: Int {<br>&gt;   inout(continuation) {<br>&gt;     // If we&#39;re not logging, short-circuit to a physical access of `x`.<br>&gt;     if !logging {<br>&gt;       continuation(&amp;_x)<br>&gt;       return<br>&gt;     }<br>&gt;     // Otherwise, save the oldValue and log before and after<br>&gt;     let oldValue = x<br>&gt;     var newValue = x<br>&gt;     continuation(&amp;newValue)<br>&gt;     print(&quot;--- changing _x from \(oldValue) to \(newValue)&quot;)<br>&gt;     _x = newValue<br>&gt;     print(&quot;--- changed! _x from \(oldValue) to \(newValue)&quot;)<br>&gt;   }<br>&gt; }<br>&gt; An implementation of inout as proposed like this could be unrolled into a materializeForSet implementation using a SIL state machine transform, similar to what one would do to implement yield or await, which would check that continuation always gets called exactly once on all paths and capture the control flow after the continuation call in the materializeForSet continuation.<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#aftertoc&gt;<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#&gt;<br>&gt; Property Behaviors<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#propertybehaviors&gt;Introduction<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#introduction&gt;<br>&gt; Motivation<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#motivation&gt;<br>&gt; Proposed solution<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#proposedsolution&gt;<br>&gt; Examples<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#examples&gt;Lazy<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#lazy&gt;<br>&gt; Memoization<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#memoization&gt;<br>&gt; Delayed Initialization<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#delayedinitialization&gt;<br>&gt; Resettable properties<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#resettableproperties&gt;<br>&gt; Synchronized Property Access<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#synchronizedpropertyaccess&gt;<br>&gt; NSCopying<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#nscopying&gt;<br>&gt; Referencing Properties with Pointers<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#referencingpropertieswithpointers&gt;<br>&gt; Property Observers<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#propertyobservers&gt;<br>&gt; Detailed design<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#detaileddesign&gt;<br>&gt; Impact on existing code<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#impactonexistingcode&gt;<br>&gt; Alternatives considered/to consider<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#alternativesconsideredtoconsider&gt;Declaration syntax<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#declarationsyntax&gt;<br>&gt; Syntax for accessing the backing property<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#syntaxforaccessingthebackingproperty&gt;<br>&gt; Defining behavior requirements using a protocol<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#definingbehaviorrequirementsusingaprotocol&gt;<br>&gt; A behavior declaration<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#abehaviordeclaration&gt;<br>&gt; Naming convention for behaviors<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#namingconventionforbehaviors&gt;<br>&gt; TODO<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#todo&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/34af5dce/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>Le 17 déc. 2015 à 12:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; Beyond what we’ve baked into the language already, there’s a seemingly endless set of common property behaviors, including resetting, synchronized access, and various kinds of proxying, all begging for language attention to eliminate their boilerplate.<br></p><p>About synchronized access, it seems to me that it&#39;d be advantageous if implementing subscript in a behaviour was optional. This way you can force access of a property through a synchronized block which will help avoid races:<br></p><p>	var (synchronized) data: (x: Int, y: Int, z: Int)<br></p><p>	func test() {<br>		data.synchronize { (data) in<br>			data.x += 1<br>			data.y += data.x<br>			data.z += data.y<br>		}<br>	}<br></p><p>As for combining behaviours... Someone should have to do the work of combining them properly by creating a new behaviour type for the combined behaviour. To make this easier syntactically, we could have a behaviour combination function that would create a combined behaviour type. That function could be overloaded to support only behaviours that are compatible with each other.<br></p><p>Overall, this looks very good. But there is almost nothing said about derived classes and overriding. I very often override a property just so I can add a `didSet` clause, and if `didChange` was implemented I&#39;d use it too. I&#39;d very much like if those property behaviours could be compatible with overriding (where it makes sense). The way I see it, the behaviour should be able tell the compiler whether the overriding accessor should either replace or be prepended or appended to the overridden closure from the base class, or if overriding is simply not allowed.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 1:14 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 17 déc. 2015 à 12:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; Beyond what we’ve baked into the language already, there’s a seemingly endless set of common property behaviors, including resetting, synchronized access, and various kinds of proxying, all begging for language attention to eliminate their boilerplate.<br>&gt; <br>&gt; About synchronized access, it seems to me that it&#39;d be advantageous if implementing subscript in a behaviour was optional. This way you can force access of a property through a synchronized block which will help avoid races:<br>&gt; <br>&gt; 	var (synchronized) data: (x: Int, y: Int, z: Int)<br>&gt; <br>&gt; 	func test() {<br>&gt; 		data.synchronize { (data) in<br>&gt; 			data.x += 1<br>&gt; 			data.y += data.x<br>&gt; 			data.z += data.y<br>&gt; 		}<br>&gt; 	}<br></p><p>Interesting. IIUC, if a behavior didn&#39;t supply a subscript operation, then the property could *only* be accessed through its behavior interface?<br></p><p>&gt; As for combining behaviours... Someone should have to do the work of combining them properly by creating a new behaviour type for the combined behaviour. To make this easier syntactically, we could have a behaviour combination function that would create a combined behaviour type. That function could be overloaded to support only behaviours that are compatible with each other.<br>&gt; <br>&gt; Overall, this looks very good. But there is almost nothing said about derived classes and overriding. I very often override a property just so I can add a `didSet` clause, and if `didChange` was implemented I&#39;d use it too. I&#39;d very much like if those property behaviours could be compatible with overriding (where it makes sense). The way I see it, the behaviour should be able tell the compiler whether the overriding accessor should either replace or be prepended or appended to the overridden closure from the base class, or if overriding is simply not allowed.<br></p><p>Yeah, composition of behaviors and overloading are two areas I&#39;m still working through. Composition is tricky, since it&#39;s not scalable to require overloads for all possible M!/N! combinations of behaviors. Any decoupled composition behavior is going to have ordering problems too—lazy-before-synchronized and synchronized-before-lazy would both be accepted, but one would be broken (unless you could blacklist problematic combinations, which also seems like an exponential-order problem).<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>Le 17 déc. 2015 à 16:36, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br></p><p>&gt;&gt; On Dec 17, 2015, at 1:14 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; About synchronized access, it seems to me that it&#39;d be advantageous if implementing subscript in a behaviour was optional. This way you can force access of a property through a synchronized block which will help avoid races:<br>&gt;&gt; <br>&gt;&gt; 	var (synchronized) data: (x: Int, y: Int, z: Int)<br>&gt;&gt; <br>&gt;&gt; 	func test() {<br>&gt;&gt; 		data.synchronize { (data) in<br>&gt;&gt; 			data.x += 1<br>&gt;&gt; 			data.y += data.x<br>&gt;&gt; 			data.z += data.y<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt; <br>&gt; Interesting. IIUC, if a behavior didn&#39;t supply a subscript operation, then the property could *only* be accessed through its behavior interface?<br></p><p>Exactly. It&#39;s much better than having a `fatalError(&quot;Don&#39;t access directly&quot;)` in the subscript getter.<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>Great work Joe! I really like this.<br></p><p>I presume the standard library will come with the existing lazy behavior.<br></p><p>It would be nice to have access the sync function used by Swift 2 &#39;lazy&#39;,<br>but for new behaviors. It may be that the usefulness/consistency of this is<br>contingent on lazy being implemented only with the standard library (maybe<br>dispatch?)<br></p><p>My only concern is that it&#39;s not currently obvious (without the<br>proposal) what the type requirements of a behavior are. It feels like it<br>could have a protocol but probably doesn&#39;t need one as it&#39;s a language<br>feature. A badly conforming behavior would really need good and accurate<br>error messages.<br></p><p>It would be important that these are debugable, and that lldb prints<br>something sensible when you print an instance using them.<br></p><p>I missed it if it was mentioned, but access to a behavior (i.e. foo.<br>resettable.reset()) should probably be private by default, and perhaps<br>allow other access modifiers.<br></p><p>On Friday, 18 December 2015, Michel Fortin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Le 17 déc. 2015 à 16:36, Joe Groff &lt;jgroff at apple.com &lt;javascript:;&gt;&gt; a<br>&gt; écrit :<br>&gt;<br>&gt; &gt;&gt; On Dec 17, 2015, at 1:14 PM, Michel Fortin &lt;michel.fortin at michelf.ca<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; About synchronized access, it seems to me that it&#39;d be advantageous if<br>&gt; implementing subscript in a behaviour was optional. This way you can force<br>&gt; access of a property through a synchronized block which will help avoid<br>&gt; races:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      var (synchronized) data: (x: Int, y: Int, z: Int)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      func test() {<br>&gt; &gt;&gt;              data.synchronize { (data) in<br>&gt; &gt;&gt;                      data.x += 1<br>&gt; &gt;&gt;                      data.y += data.x<br>&gt; &gt;&gt;                      data.z += data.y<br>&gt; &gt;&gt;              }<br>&gt; &gt;&gt;      }<br>&gt; &gt;<br>&gt; &gt; Interesting. IIUC, if a behavior didn&#39;t supply a subscript operation,<br>&gt; then the property could *only* be accessed through its behavior interface?<br>&gt;<br>&gt; Exactly. It&#39;s much better than having a `fatalError(&quot;Don&#39;t access<br>&gt; directly&quot;)` in the subscript getter.<br>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; michel.fortin at michelf.ca &lt;javascript:;&gt;<br>&gt; https://michelf.ca<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/4116d8f9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>My first assumption is that behaviors separate broadly into a couple of categories:<br></p><p>1. Eager and uncorrelated. The logging example is a good one. A logging behavior probably doesn’t care about anything else, it just wants to run as early as possible to write the log output.<br>2. Ordered or correlated. These have composability issues.<br>3. Un-eager. didSet/willSet kind of behaviors that want to run after all behaviors of type #2 have run.<br></p><p>I’m trying to think if there is a way to declare the kind of behavior you have and what that would mean for composability and overriding because the compiler would be free to run all behaviors of type #1 first (unordered), then a single #2 behavior, then all the #3 behaviors (unordered), reducing the problem to specifying how ordered behaviors… er… “behave”. Perhaps in that case you’ll just have to manually implement a behavior that calls the desired behaviors. <br></p><p>For overriding, as long as there is only one ordered behavior involved, all the other behaviors can execute in the appropriate “phase” without issue (all inherited eager behaviors first, etc).<br></p><p><br>Russ<br></p><p><br>&gt; On Dec 17, 2015, at 1:36 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; As for combining behaviours... Someone should have to do the work of combining them properly by creating a new behaviour type for the combined behaviour. To make this easier syntactically, we could have a behaviour combination function that would create a combined behaviour type. That function could be overloaded to support only behaviours that are compatible with each other.<br>&gt;&gt; <br>&gt;&gt; Overall, this looks very good. But there is almost nothing said about derived classes and overriding. I very often override a property just so I can add a `didSet` clause, and if `didChange` was implemented I&#39;d use it too. I&#39;d very much like if those property behaviours could be compatible with overriding (where it makes sense). The way I see it, the behaviour should be able tell the compiler whether the overriding accessor should either replace or be prepended or appended to the overridden closure from the base class, or if overriding is simply not allowed.<br>&gt; <br>&gt; Yeah, composition of behaviors and overloading are two areas I&#39;m still working through. Composition is tricky, since it&#39;s not scalable to require overloads for all possible M!/N! combinations of behaviors. Any decoupled composition behavior is going to have ordering problems too—lazy-before-synchronized and synchronized-before-lazy would both be accepted, but one would be broken (unless you could blacklist problematic combinations, which also seems like an exponential-order problem).<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/a40f5c68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 3:22 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; My first assumption is that behaviors separate broadly into a couple of categories:<br>&gt; <br>&gt; 1. Eager and uncorrelated. The logging example is a good one. A logging behavior probably doesn’t care about anything else, it just wants to run as early as possible to write the log output.<br>&gt; 2. Ordered or correlated. These have composability issues.<br>&gt; 3. Un-eager. didSet/willSet kind of behaviors that want to run after all behaviors of type #2 have run.<br>&gt; <br>&gt; I’m trying to think if there is a way to declare the kind of behavior you have and what that would mean for composability and overriding because the compiler would be free to run all behaviors of type #1 first (unordered), then a single #2 behavior, then all the #3 behaviors (unordered), reducing the problem to specifying how ordered behaviors… er… “behave”. Perhaps in that case you’ll just have to manually implement a behavior that calls the desired behaviors. <br>&gt; <br>&gt; For overriding, as long as there is only one ordered behavior involved, all the other behaviors can execute in the appropriate “phase” without issue (all inherited eager behaviors first, etc).<br></p><p>This is a great analysis. Kevin made a similar observation. If we went in the direction of a dedicated `behavior` declaration, then it&#39;d be reasonable to declare the behavior&#39;s kind up front, which would influence its composition behavior.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 17, 2015 at 10:00:00pm</p></header><div class="content"><p>I find that Michel Fortin&#39;s idea for subscript-less behaviors is very cool, but it also has an impact on composition. It seems to me that any behavior that doesn&#39;t implement a subscript would need to be the outer-most behavior, and it could not easily compose with any other subscript-less behavior.<br></p><p>Félix<br></p><p>&gt; Le 17 déc. 2015 à 20:23:46, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 3:22 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My first assumption is that behaviors separate broadly into a couple of categories:<br>&gt;&gt; <br>&gt;&gt; 1. Eager and uncorrelated. The logging example is a good one. A logging behavior probably doesn’t care about anything else, it just wants to run as early as possible to write the log output.<br>&gt;&gt; 2. Ordered or correlated. These have composability issues.<br>&gt;&gt; 3. Un-eager. didSet/willSet kind of behaviors that want to run after all behaviors of type #2 have run.<br>&gt;&gt; <br>&gt;&gt; I’m trying to think if there is a way to declare the kind of behavior you have and what that would mean for composability and overriding because the compiler would be free to run all behaviors of type #1 first (unordered), then a single #2 behavior, then all the #3 behaviors (unordered), reducing the problem to specifying how ordered behaviors… er… “behave”. Perhaps in that case you’ll just have to manually implement a behavior that calls the desired behaviors. <br>&gt;&gt; <br>&gt;&gt; For overriding, as long as there is only one ordered behavior involved, all the other behaviors can execute in the appropriate “phase” without issue (all inherited eager behaviors first, etc).<br>&gt; <br>&gt; This is a great analysis. Kevin made a similar observation. If we went in the direction of a dedicated `behavior` declaration, then it&#39;d be reasonable to declare the behavior&#39;s kind up front, which would influence its composition behavior.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 17, 2015 at 07:00:00pm</p></header><div class="content"><p>Good point. I&#39;m also inclined to say that Michel&#39;s motivating example (of a property that requires going through a `synchronized` accessor) would be better modeled just as a type Synchronized&lt;Value&gt; that exposes the `synchronized` accessor. No need for behaviors, you just say<br></p><p>var data: Synchronized&lt;T&gt; = ...<br></p><p>Behaviors are interesting because they affect how normal property access works. Properties that don&#39;t expose normal property accessors aren&#39;t really properties at all.<br></p><p>The only real downside to the Synchronized&lt;Value&gt; type is there&#39;s no way to prevent anyone from copying the value (it could be a class, but then you&#39;re paying for the overhead of using a separate object). This same limitation is also one of the problems with adding an Atomic&lt;T&gt; type, which is something I would dearly love to have.<br></p><p>On a semi-related note, we should say up-front that accessing behaviors on properties (e.g. with `foo.lazy`) _cannot_ be used to extract the behavior type as a value. The only thing you can do with this is calling a method on it or accessing a property. So no saying `let foo = data.lazy`. This limitation would be more obvious if we use an alternative behavior accessor syntax.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Dec 17, 2015, at 07:00 PM, Félix Cloutier via swift-evolution wrote:<br>&gt; I find that Michel Fortin&#39;s idea for subscript-less behaviors is very cool, but it also has an impact on composition. It seems to me that any behavior that doesn&#39;t implement a subscript would need to be the outer-most behavior, and it could not easily compose with any other subscript-less behavior.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; &gt; Le 17 déc. 2015 à 20:23:46, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt;&gt; On Dec 17, 2015, at 3:22 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; My first assumption is that behaviors separate broadly into a couple of categories:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; 1. Eager and uncorrelated. The logging example is a good one. A logging behavior probably doesn’t care about anything else, it just wants to run as early as possible to write the log output.<br>&gt; &gt;&gt; 2. Ordered or correlated. These have composability issues.<br>&gt; &gt;&gt; 3. Un-eager. didSet/willSet kind of behaviors that want to run after all behaviors of type #2 have run.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I’m trying to think if there is a way to declare the kind of behavior you have and what that would mean for composability and overriding because the compiler would be free to run all behaviors of type #1 first (unordered), then a single #2 behavior, then all the #3 behaviors (unordered), reducing the problem to specifying how ordered behaviors… er… “behave”. Perhaps in that case you’ll just have to manually implement a behavior that calls the desired behaviors. <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; For overriding, as long as there is only one ordered behavior involved, all the other behaviors can execute in the appropriate “phase” without issue (all inherited eager behaviors first, etc).<br>&gt; &gt; <br>&gt; &gt; This is a great analysis. Kevin made a similar observation. If we went in the direction of a dedicated `behavior` declaration, then it&#39;d be reasonable to declare the behavior&#39;s kind up front, which would influence its composition behavior.<br>&gt; &gt; <br>&gt; &gt; -Joe<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>I think I agree with you. On a Synchronized&lt;T&gt;, all you have to do is implement a get&lt;U&gt;(access: T -&gt; U) -&gt; U to get almost the same syntax that Michel suggested.<br></p><p>(Can you do object[] { /* closure */ } or even object { /* closure */ } if you have a subscript that only accepts a closure? That could be interesting...)<br></p><p>On a semi-related note to your semi-related note, I&#39;m not sure how I feel about the &quot;foo.lazy&quot; syntax because of the name resolution problems. I&#39;m also not a fan of &quot;`foo.lazy`&quot;; I don&#39;t know any language that forces you to use the identifier escape to access built-in features.<br></p><p>In general, I think that accessing the behavior object should be restricted to the private scope. IMHO, if we want to restrict usage on behavior objects, the most obvious thing to do is to use a call-like syntax (since calls aren&#39;t assignable).<br></p><p>I&#39;m thinking of something like `&lt;lazy&gt;(foo)` and `var&lt;lazy&gt; foo: Int` (for symmetry) to access the behavior object. I don&#39;t think that any expression can start with a &lt; right now, and this would allow an independent namespace for behaviors. I don&#39;t have a strong opinion on that though.<br></p><p>Additionally, if behaviors become types instead of keywords, perhaps even within their own namespace they should follow regular type naming conventions. This could reduce namespace friction (you could always refer to them through their qualified name if they were shadowed).<br></p><p>&gt; Le 17 déc. 2015 à 22:47:48, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Good point. I&#39;m also inclined to say that Michel&#39;s motivating example (of a property that requires going through a `synchronized` accessor) would be better modeled just as a type Synchronized&lt;Value&gt; that exposes the `synchronized` accessor. No need for behaviors, you just say<br>&gt; <br>&gt; var data: Synchronized&lt;T&gt; = ...<br>&gt; <br>&gt; Behaviors are interesting because they affect how normal property access works. Properties that don&#39;t expose normal property accessors aren&#39;t really properties at all.<br>&gt; <br>&gt; The only real downside to the Synchronized&lt;Value&gt; type is there&#39;s no way to prevent anyone from copying the value (it could be a class, but then you&#39;re paying for the overhead of using a separate object). This same limitation is also one of the problems with adding an Atomic&lt;T&gt; type, which is something I would dearly love to have.<br>&gt; <br>&gt; On a semi-related note, we should say up-front that accessing behaviors on properties (e.g. with `foo.lazy`) _cannot_ be used to extract the behavior type as a value. The only thing you can do with this is calling a method on it or accessing a property. So no saying `let foo = data.lazy`. This limitation would be more obvious if we use an alternative behavior accessor syntax.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Thu, Dec 17, 2015, at 07:00 PM, Félix Cloutier via swift-evolution wrote:<br>&gt;&gt; I find that Michel Fortin&#39;s idea for subscript-less behaviors is very cool, but it also has an impact on composition. It seems to me that any behavior that doesn&#39;t implement a subscript would need to be the outer-most behavior, and it could not easily compose with any other subscript-less behavior.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 17 déc. 2015 à 20:23:46, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 17, 2015, at 3:22 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My first assumption is that behaviors separate broadly into a couple of categories:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Eager and uncorrelated. The logging example is a good one. A logging behavior probably doesn’t care about anything else, it just wants to run as early as possible to write the log output.<br>&gt;&gt;&gt;&gt; 2. Ordered or correlated. These have composability issues.<br>&gt;&gt;&gt;&gt; 3. Un-eager. didSet/willSet kind of behaviors that want to run after all behaviors of type #2 have run.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m trying to think if there is a way to declare the kind of behavior you have and what that would mean for composability and overriding because the compiler would be free to run all behaviors of type #1 first (unordered), then a single #2 behavior, then all the #3 behaviors (unordered), reducing the problem to specifying how ordered behaviors… er… “behave”. Perhaps in that case you’ll just have to manually implement a behavior that calls the desired behaviors. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For overriding, as long as there is only one ordered behavior involved, all the other behaviors can execute in the appropriate “phase” without issue (all inherited eager behaviors first, etc).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a great analysis. Kevin made a similar observation. If we went in the direction of a dedicated `behavior` declaration, then it&#39;d be reasonable to declare the behavior&#39;s kind up front, which would influence its composition behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>Le 17 déc. 2015 à 22:47, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; Good point. I&#39;m also inclined to say that Michel&#39;s motivating example (of a property that requires going through a `synchronized` accessor) would be better modeled just as a type Synchronized&lt;Value&gt; that exposes the `synchronized` accessor. No need for behaviors, you just say<br>&gt; <br>&gt; var data: Synchronized&lt;T&gt; = ...<br>&gt; <br>&gt; Behaviors are interesting because they affect how normal property access works. Properties that don&#39;t expose normal property accessors aren&#39;t really properties at all.<br></p><p>&gt; <br></p><p>&gt; The only real downside to the Synchronized&lt;Value&gt; type is there&#39;s no way to prevent anyone from copying the value (it could be a class, but then you&#39;re paying for the overhead of using a separate object). This same limitation is also one of the problems with adding an Atomic&lt;T&gt; type, which is something I would dearly love to have.<br></p><p><br>There&#39;s indeed the problem that you can&#39;t disallow copying a value, and that makes anything involving a mutex a bit fragile. Even if you append a mutex to a property through a behaviour, can a struct containing that property be safely copied? Or should that behaviour be reserved for properties in classes?<br></p><p>And then the question about the definition of a &quot;property&quot;? Is it still a property if the getter is inaccessible? Maybe not. But this thread is all about redefining properties.<br></p><p>The reason I&#39;m suggesting implementing synchronized as a behaviour instead of a type is because I found out with experience that synchronization should be related to variables, not types. Types exists in a vacuum while variables are bound to a context, and a synchronized access pattern should usually stay encapsulated in a particular context (struct or class). A Synchronized&lt;T&gt; should not be copied or passed by reference and used out of its context; a property behaviour makes that just impossible, which is better.<br></p><p>If it turns out it does not work with the final design of behaviours, it won&#39;t be too bad I guess. But I think it&#39;d be a better fit as a behaviour than as a type.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 18, 2015 at 03:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015, at 07:18 AM, Michel Fortin wrote:<br>&gt; Le 17 déc. 2015 à 22:47, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; &gt; Good point. I&#39;m also inclined to say that Michel&#39;s motivating example (of a property that requires going through a `synchronized` accessor) would be better modeled just as a type Synchronized&lt;Value&gt; that exposes the `synchronized` accessor. No need for behaviors, you just say<br>&gt; &gt; <br>&gt; &gt; var data: Synchronized&lt;T&gt; = ...<br>&gt; &gt; <br>&gt; &gt; Behaviors are interesting because they affect how normal property access works. Properties that don&#39;t expose normal property accessors aren&#39;t really properties at all.<br>&gt; <br>&gt; &gt; <br>&gt; <br>&gt; &gt; The only real downside to the Synchronized&lt;Value&gt; type is there&#39;s no way to prevent anyone from copying the value (it could be a class, but then you&#39;re paying for the overhead of using a separate object). This same limitation is also one of the problems with adding an Atomic&lt;T&gt; type, which is something I would dearly love to have.<br>&gt; <br>&gt; <br>&gt; There&#39;s indeed the problem that you can&#39;t disallow copying a value, and that makes anything involving a mutex a bit fragile. Even if you append a mutex to a property through a behaviour, can a struct containing that property be safely copied? Or should that behaviour be reserved for properties in classes?<br>&gt; <br>&gt; And then the question about the definition of a &quot;property&quot;? Is it still a property if the getter is inaccessible? Maybe not. But this thread is all about redefining properties.<br>&gt; <br>&gt; The reason I&#39;m suggesting implementing synchronized as a behaviour instead of a type is because I found out with experience that synchronization should be related to variables, not types. Types exists in a vacuum while variables are bound to a context, and a synchronized access pattern should usually stay encapsulated in a particular context (struct or class). A Synchronized&lt;T&gt; should not be copied or passed by reference and used out of its context; a property behaviour makes that just impossible, which is better.<br></p><p>I don&#39;t really understand what you&#39;re trying to say here. The goal you describe (of not being able to copy or pass the synchronized value around) is satisfied by having some way to declare a struct that cannot be copied (but can be moved, because moves are always fine as long as there&#39;s no code (e.g. other threads) that is still expecting the value to be at its original location). Describing synchronized behavior as a non-copyable type like this actually works extremely well in practice.<br></p><p>The Rust language is an excellent demonstration of this fact, where literally all of the threading and synchronization behavior is expressed in the libraries by leveraging the type system and borrow checker to guarantee safety. If you want a value with an associated lock, you just have a value of type Mutex&lt;T&gt;, and the only way to access the underlying value is by using an accessor that returns a MutexGuard, which is a smart pointer (Rust has smart pointers) that lets you access the underlying value and releases the lock when the guard goes out of scope. And because of Rust&#39;s borrow checker, it&#39;s impossible to leak a reference to the underlying value past the scope of the MutexGuard (and you&#39;re not allowed to copy MutexGuards or to send them to other threads, but you can still move the guard around locally and the borrow checker will statically ensure the guard itself cannot outlive the mutex). The Mutex value itself also cannot be copied, but (if you have no outstanding guards) you can move it or even send it to other threads, and you can put it in a location that is visible to multiple threads at once (otherwise what&#39;s the point?).<br></p><p>Ultimately, I would love to have non-copyable structs in Swift. But the only way to really do that is to have references in the language (otherwise the moment you call a method on a non-copyable struct, you&#39;ve lost the struct as the value is moved into the method). And if you have references, you really want them to be safe. Personally, I&#39;d love to have the power of Rust&#39;s borrowchecker and lifetimes system, but as I mentioned in another thread recently, there is a pretty steep learning curve there.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 18, 2015 at 06:00:00pm</p></header><div class="content"><p>On Dec 18, 2015, at 3:56 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Ultimately, I would love to have non-copyable structs in Swift. But the only way to really do that is to have references in the language (otherwise the moment you call a method on a non-copyable struct, you&#39;ve lost the struct as the value is moved into the method). And if you have references, you really want them to be safe. Personally, I&#39;d love to have the power of Rust&#39;s borrowchecker and lifetimes system, but as I mentioned in another thread recently, there is a pretty steep learning curve there.<br></p><p>Me too.  Two caveats:<br></p><p>- The model in swift should be opt-in: you should be able to use borrowing references in performance sensitive code, and get guarantees about (e.g.) no ARC.  You should be able to opt into making a struct move-only, and thus only work with those references, etc.  However, it shouldn’t be a required part of the programming model that all swift programmers need to confront to learn the language.<br></p><p>- This is certainly out of scope for swift 3 :-(    OTOH, if someone were motivated to start exploring a concrete design in the space, it would be very very interesting.  One of the reasons that inout is where it is in the grammar is to allow other kinds of named parameter modifiers along the lines of Rust’s.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 19, 2015 at 12:00:00pm</p></header><div class="content"><p>Le 18 déc. 2015 à 18:56, Kevin Ballard &lt;kevin at sb.org&gt; a écrit :<br></p><p>&gt; On Fri, Dec 18, 2015, at 07:18 AM, Michel Fortin wrote:<br>&gt;&gt; The reason I&#39;m suggesting implementing synchronized as a behaviour instead of a type is because I found out with experience that synchronization should be related to variables, not types. Types exists in a vacuum while variables are bound to a context, and a synchronized access pattern should usually stay encapsulated in a particular context (struct or class). A Synchronized&lt;T&gt; should not be copied or passed by reference and used out of its context; a property behaviour makes that just impossible, which is better.<br>&gt; <br>&gt; I don&#39;t really understand what you&#39;re trying to say here. The goal you describe (of not being able to copy or pass the synchronized value around) is satisfied by having some way to declare a struct that cannot be copied (but can be moved, because moves are always fine as long as there&#39;s no code (e.g. other threads) that is still expecting the value to be at its original location). Describing synchronized behavior as a non-copyable type like this actually works extremely well in practice.<br></p><p>In essence, synchronization is an access policy for a variable. It&#39;s somewhat similar to `let` granting you only access to the getter, or the `Delayed` property behaviour that lets you use the setter only once.<br></p><p>Synchronization is an access policy stipulating that you should only use the getter and setter of the variable while the current thread has locked the associated mutex. While you could enforce that at runtime with fatalErrors in the setter and getter whenever the mutex is not locked (similar to `Delayed`), it&#39;s simply more convenient to enforce it at compile time by requiring a closure.<br></p><p>I acknowledge a type such as Synchronized&lt;T&gt; will work fine for that too (assuming non-copyablility). I just think the modeling is slightly off. Synchronization is an access policy, not a data type, and it should be modeled in a similar manner to the other access policies in the language.<br></p><p>Language support for concurrency is out of scope for Swift 3, so it&#39;s perhaps premature to think about that now... but I can&#39;t help but think it&#39;ll have to work this way anyway the day Swift introduces a safe concurrency model.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>As I understand it, the current draft doesn&#39;t appear to support composability very well, though. If the backing property holds the storage, you won&#39;t be able, for instance, to have a `(observable, lazy)` property.<br></p><p>Should composability be a goal? Is there a way to classify behaviors that can and can&#39;t compose?<br></p><p>&gt; Le 17 déc. 2015 à 12:37:25, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on a design for allowing properties to be extended with user-defined delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open up for broader discussion. Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3 &lt;https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/90158e2f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>On Thu, Dec 17, 2015, at 09:37 AM, Joe Groff via swift-evolution wrote:<br>&gt; Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on<br>&gt; a design for allowing properties to be extended with user-defined<br>&gt; delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open<br>&gt; up for broader discussion. Thanks for taking a look!<br></p><p>Thanks for posting this! I just read through it, and there&#39;s a lot to<br>like in here, but I also have a bunch of concerns. I&#39;ll go back through<br>the document in order and respond to bits of it.<br></p><p>I apologize in advance for the massive size of this email, and for its<br>rambling nature. It is a bit of stream-of-consciousness. I also<br>apologize if anything in here has already been addressed in this thread,<br>as I&#39;ve been writing it over several hours and I know the thread has had<br>discussion during that time.<br></p><p>&gt; A var or let declaration can specify its behavior in parens after<br>&gt; the keyword<br></p><p>I like this syntax.<br></p><p>&gt; Furthermore, the behavior can provide additional operations, such<br>&gt; as clear-ing a lazy property, by accessing it with<br>&gt; property.behavior syntax:<br></p><p>You already mentioned this at the end, but I&#39;m concerned about the<br>ambiguity between `foo.behavior` and `foo.someProp`. If the compiler<br>always resolves ambiguity in one way, that makes it impossible to<br>explicitly choose the alternative resolution (e.g. if `foo.lazy`<br>resolves in favor of a property of the type, how do you access the lazy<br>behavior? If it resolves in favor of the behavior, how do you get at the<br>property instead?). Not just that, but it&#39;s also ambiguous to any<br>reader; if I see `self.foo.bar` I have to know up-front whether &quot;bar&quot; is<br>a behavior or a property of the variable&#39;s type.<br></p><p>I&#39;m mildly tempted to say we should use<br></p><p>`foo.lazy`.reset()<br></p><p>but I admit it does look a bit odd, especially if accessing methods of<br>behaviors ends up being common. Another idea might look like<br></p><p>foo.(lazy).reset()<br></p><p>Or maybe we could even come up with a syntax that lets you omit the<br>behavior name if it&#39;s unambiguous (e.g. only one behavior, or if the<br>method/property you&#39;re accessing only exists on one behavior). Being<br>able to omit the behavior name would be nice for defining resettable<br>properties because saying something like `foo.resettable.reset()` is<br>annoyingly redundant. Maybe something like `foo::reset()` or<br>`foo#reset()`, which would be shorthand for`foo::lazy.reset()` or<br>`foo#lazy.reset()`.<br></p><p>&gt; public subscript&lt;Container&gt;(varIn _: Container,<br>&gt; initializer initial: () -&gt; Value) -&gt; Value {<br></p><p>I&#39;m a bit concerned about passing in the Container like this. For class<br>types it&#39;s probably fine, but for value types, it means we&#39;re passing a<br>copy of the value in to the property, which just seems really weird<br>(both because it&#39;s a copy, and because that copy includes a copy of the<br>property).<br></p><p>Also the only example you gave that actually uses the container is<br>Synchronized, but even there it&#39;s not great, because it means every<br>synchronized property in the class all share the same lock. But that&#39;s<br>not how Obj-C atomic properties work, and there&#39;s really no benefit at<br>all to locking the entire class when accessing a single property because<br>it doesn&#39;t provide any guarantees about access to multiple properties<br>(as the lock is unlocked in between each access).<br></p><p>FWIW, the way Obj-C atomic properties work is for scalars it uses atomic<br>unordered loads/stores (which is even weaker than memory_order_relaxed,<br>all it guarantees is that every load sees a value that was written at<br>some point, i.e. no half-written values). For scalars it calls functions<br>objc_copyStruct(), which uses a bank of 128 spinlocks and picks two of<br>them based on the hash of the src/dst addresses (there&#39;s a comment<br>saying the API was designed wrong, hence the need for 2 spinlocks;<br>ideally it would only use one lock based on the address of the property<br>because the other address is a local stack value). For objects it calls<br>objc_getProperty() / objc_setProperty() which uses a separate bank of<br>128 spinlocks (and picks one based on the address of the ivar). The<br>getter retains the object with the spinlock held and then autoreleases<br>it outside of the spinlock. The setter just uses the spinlock to protect<br>writing to the ivar, doing any retains/releases outside of it. I haven&#39;t<br>tested but it appears that Obj-C++ properties containing C++ objects<br>uses yet another bank of 128 spinlocks, using the spinlock around the<br>C++ copy operation.<br></p><p>Ultimately, the point here is that the only interesting synchronization<br>that can be done at the property level is unordered atomic access, and<br>for any properties that can&#39;t actually use an atomic load/store (either<br>because they&#39;re aggregates or because they&#39;re reference-counted objects)<br>you really do want to use a spinlock to minimize the cost. But adding a<br>spinlock to every single property is a lot of wasted space (especially<br>because safe spinlocks on iOS require a full word), which is why the Obj-<br>C runtime uses those banks of spinlocks.<br></p><p>In any case, I guess what I&#39;m saying is we should ditch the Container<br>argument. It&#39;s basically only usable for classes, and even then it&#39;s<br>kind of strange for a property to actually care about its container.<br></p><p>&gt; var `foo.lazy` = lazy(var: Int.self, initializer: { 1738 })<br></p><p>This actually won&#39;t work to replace existing lazy properties. It&#39;s legal<br>today to write<br></p><p>lazy var x: Int = self.y + 1<br></p><p>This works because the initializer expression isn&#39;t actually run until<br>the property is accessed. But if the initializer is passed to the<br>behavior function, then it can&#39;t possibly reference `self` as that runs<br>before stage-1 initialization.<br></p><p>So we need some way to distinguish behaviors that initialize immediately<br>vs behaviors that initialize later. The former want an initializer on<br>the behavior function, and may or may not care about having an<br>initializer on the getter/setter. The latter don&#39;t want an initializer<br>on the behavior, and do want one on the getter/setter. In theory you<br>could use the presence of a declared `initializer` argument on the<br>behavior function to distinguish between eager-initialized and lazy-<br>initialized, though that feels a little odd.<br></p><p>&gt; let (memoized) address = &quot;\(street)\n\(city) \(postalCode)&quot;<br></p><p>You&#39;re using un-qualified accesses to properties on self in the<br>initializer here. I&#39;m not actually against allowing that, but `lazy`<br>properties today require you to use `self.`, otherwise any unqualified<br>property access is resolved against the type instead of the value. I<br>believe the current behavior is because non-lazy properties resolve<br>unqualified properties this way, so `lazy` properties do too in order to<br>allow you to add `lazy` to any property without breaking the existing<br>initializer.<br></p><p>This property declaration also runs into the eager-vs-delayed<br>initializer issue I mentioned above.<br></p><p>&gt; A property behavior can model &quot;delayed&quot; initialization behavior, where<br>&gt; the DI rules for var and let properties are enforced dynamically<br>&gt; rather than at compile time<br></p><p>It looks to me that the only benefit this has versus IOUs is you can use<br>a `let` instead of a `var`. It&#39;s worth pointing out that this actually<br>doesn&#39;t even replace IOUs for @IBOutlets because it&#39;s commonly useful to<br>use optional-chaining on outlets for code that might run before the view<br>is loaded (and while optional chaining is possible with behavior access,<br>it&#39;s a lot more awkward).<br></p><p>&gt; let (delayed) x: Int ... self.x.delayed.initialize(x) ...<br></p><p>Allowing `let` here is actually a violation of Swift&#39;s otherwise-strict<br>rules about `let`. Specifically, Delayed here is a struct, but<br>initializing it requires it to be mutable. So `let (delayed) x: Int`<br>can&#39;t actually ever be initialized. You could make it a class, but<br>that&#39;s a fairly absurd performance penalty for something that provides<br>basically the same behavior as IOUs. You do remark later in detailed<br>design about how the backing storage is always `var`, which solves this<br>at a technical level, but it still appears to the user as though they&#39;re<br>mutating a `let` property and that&#39;s strictly illegal today.<br></p><p>I think the right resolution here is just to remove the `letIn`<br>constructor and use `var` for these properties. The behavior itself<br>(e.g. delayed) can document write-once behavior if it wants to. Heck,<br>that behavior was only enforcing write-once in a custom initialize()<br>method anyway, so nothing about the API would actually change.<br></p><p>&gt; Resettable properties<br></p><p>The implementation here is a bit weird. If the property is nil, it<br>invokes the initializer expression, every single time it&#39;s accessed. And<br>the underlying value is optional. This is really implemented basically<br>like a lazy property that doesn&#39;t automatically initialize itself.<br></p><p>Instead I&#39;d expect a resettable property to have eager-initialization,<br>and to just eagerly re-initialize the property whenever it&#39;s reset. This<br>way the underlying storage isn&#39;t Optional, the initializer expression is<br>invoked at more predictable times, and it only invokes the initializer<br>once per reset.<br></p><p>The problem with this change is the initializer expression needs to be<br>provided to the behavior when reset() is invoked rather than when the<br>getter/setter is called.<br></p><p>&gt; NSCopying<br></p><p>We really need to support composition. Adding NSCopying to a property<br>doesn&#39;t really change the behavior of the property itself, it just makes<br>assignments to it automatically call copy() on the new value before<br>doing the actual assignment. Composition in general is good, but<br>NSCopying seems like an especially good example of where adding this<br>kind of behavior should work fine with everything else.<br></p><p>Based on the examples given here, there&#39;s really several different<br>things behaviors do:<br></p><p>* Behaviors that &quot;decorate&quot; the getter/setter, without actually changing<br>  the underlying value get/set. This includes property observers and<br>  Synchronized (although atomic properties ideally should alter the<br>  get/set to use atomic instructions when possible, but semantically<br>  it&#39;s the same as taking a per-property spinlock).<br>* Behaviors that transform the  value. This is basically NSCopying,<br>  because it copies the value but otherwise wants to preserve any<br>  existing property behavior (just with the new value instead of the<br>  old). But e.g. lazy can also be thought of as doing this where the<br>  transform is from T to T? (the setter converts T into T? and assigns<br>  it to the underlying value; the getter unwraps the T? or initializes<br>  it if nil and returns T). Of course there is probably a difference<br>  between transformers that keep the same type and ones that change the<br>  type; e.g. property observers with NSCopying may want to invoke<br>  willSet with the initial uncopied value (in case the observer wants to<br>  change the assigned value), but didSet should of course be invoked<br>  with the resulting copied value. But transformers where the<br>  transformation is an implementation detail (such as lazy, which<br>  transforms T to T?) don&#39;t want to expose that implementation detail to<br>  the property observers. So maybe there&#39;s two types of transformers;<br>  one that changes the underlying type, and one that doesn&#39;t.<br>* Behaviors that don&#39;t alter the getter/setter but simply provide<br>  additional functionality. This is exemplified by Resettable (at least,<br>  with my suggested change to make it eagerly initialize), because it<br>  really just provides a .reset() function.<br>* The lazy vs eager initialized thing from before<br></p><p>I suspect that we really should have a behavior definition that<br>acknowledges these differences and makes them explicit in the API.<br></p><p>There&#39;s also a lot of composition concerns here. For example,<br>synchronized should probably always be the innermost decorator, because<br>the lock is really only protecting the storage of the value and<br>shouldn&#39;t e.g. cover property observers or NSCopying. Property observers<br>should probably always be the outermost decorator (and willSet should<br>even fire before NSCopying, partially because it should be whatever<br>value the user actually tried to assign, and because willSet observers<br>can actually change the value being assigned and any such new value<br>should then get copied by NSCopying).<br></p><p>Speaking of composition, mixing lazy and synchronized seems really<br>problematic. If Synchronized uses a bank of locks like the obj-c<br>runtime, then lazy can&#39;t execute inside of the lock because the<br>initializer might access something else that hits the same lock and<br>causes an unpredictable deadlock. But it can&#39;t execute outside of the<br>lock either because the initializer might then get executed twice<br>(which would surprise everyone). So really the combination of lazy +<br>synchronized needs to actually use completely separate combined<br>LazySynchronized type, one that provides the expected dispatch_once-<br>like behavior.<br></p><p>&gt; Referencing Properties with Pointers ... A production-quality stdlib<br>&gt; implementation could use compiler magic to ensure the property is<br>&gt; stored in-line in an addressable way.<br></p><p>Sounds like basically an implementation that just stores the value<br>inline as a value and uses Builtin.addressOf(). This behavior is<br>problematic for composition. It also doesn&#39;t work at all for computed<br>properties (although any behavior that directly controls value storage,<br>such as lazy, also has the same limitation). The behavior design should<br>acknowledge the split between behaviors that work on computed properties<br>and those that don&#39;t.<br></p><p>More thoughts on composition: The &quot;obvious&quot; way to compose behaviors is<br>to just have a chain of them where each behavior wraps the next one,<br>e.g. Copying&lt;Resettable&lt;Synchronized&lt;NSString&gt;&gt;&gt;. But this doesn&#39;t<br>actually work for properties like Lazy that change the type of the<br>underlying value, because the &quot;underlying value&quot; in this case is the<br>wrapped behavior, and you can&#39;t have a nil behavior (it would break most<br>of the functionality of behaviors, as well as break the ability to say<br>`foo.behavior.bar()`).<br></p><p>Based on the previous behavior categories, I&#39;m tempted to say that we<br>need to model behaviors with a handful of protocols (e.g. on for<br>decorators, one for transformers, etc), and have the logic of the<br>property itself call the appropriate methods on the collection of<br>protocols at the appropriate times. Transformer behaviors could have an<br>associated type that is the transformed value type (and the behavior<br>itself would be generic, taking the value type as its parameter, as you<br>already have). The compiler can then calculate the ordering of<br>behaviors, and use the associated types to figure out the &quot;real&quot;<br>underlying value, and pass appropriately-transformed value types to the<br>various behaviors depending on where in the chain they execute. By that<br>I mean a chain of (observed, lazy, sync) for a property of type Int<br>(ignoring for a moment the issues with sync + lazy) would create an<br>Observed&lt;Int&gt;, a Lazy&lt;Int&gt;, and a Sync&lt;Int?&gt; (because the Lazy&lt;Int&gt;&#39;s<br>associated type says it transforms to Int?). The problem with this model<br>is the behavior can no longer actually contain the underlying value as a<br>property. And that&#39;s actually fine. If we can split up any stored values<br>the behavior needs from the storage of the property itself, that&#39;s<br>probably a good thing.<br></p><p>&gt; Property Observers<br></p><p>Property Observers need to somehow support the behavior of letting<br>accessors reassign to the property without causing an infinite loop.<br>They also need to support subclassing such that the observers are called<br>in the correct order in the nested classes (and again, with<br>reassignment, such that the reassigned value is visible to the future<br>observers without starting the observer chain over again).<br></p><p>Property Observers also pose a special challenge for subclasses.<br>Overriding a property to add a behavior in many cases would actually<br>want to create brand new underlying storage (e.g. adding lazy to a<br>property needs different storage). But property observers explicitly<br>don&#39;t want to do that, they just want to observe the existing property.<br>I suspect this may actually line up quite well with the distinction<br>between decorators and other behaviors.<br></p><p>On a similar note, I&#39;m not sure if there&#39;s any other behaviors where<br>overriding actually wants to preserve any existing behaviors. Property<br>observers definitely want to, but if I have a lazy property and I<br>override it in a subclass for any reason beyond adding observers, the<br>subclass property probably shouldn&#39;t be lazy. Conversely, if I have an<br>observed property and I override it to be lazy, it should still preserve<br>the property observers (but no other behaviors). This actually suggests<br>to me that Property Observers are unique among behaviors, and are<br>perhaps worthy of leaving as a language feature instead of as a<br>behavior. Of course, I can always override a property with a computed<br>property and call `super` in the getter/setter, at which point any<br>behaviors of the superclass property are expected to apply, but I don&#39;t<br>think there&#39;s any actual problems there.<br></p><p>Speaking of that, how do behaviors interact with computed properties? A<br>lazy computed property doesn&#39;t make sense (which is why the language<br>doesn&#39;t allow it). But an NSCopying computed property is fine (the<br>computed getter would be handed the copied value).<br></p><p>&gt; The backing property has internal visibility by default<br></p><p>In most cases I&#39;d recommend private by default. Just because I have an<br>internal property doesn&#39;t mean the underlying implementation detail<br>should be internal. In 100% of the cases where I&#39;ve written a computed<br>property backed by a second stored property (typically named with a _<br>prefix), the stored property is always private, because nobody has any<br>business looking at it except for the class/struct it belongs to.<br></p><p>Although actually, having said that, there&#39;s at least one behavior<br>(resettable) that only makes sense if it&#39;s just as visible as the<br>property itself (e.g. so it should be public on a public property).<br></p><p>And come to think of it, just because the class designer didn&#39;t<br>anticipate a desire to access the underlying storage of a lazy property<br>(e.g. to check if it&#39;s been initialized yet) doesn&#39;t mean the user of<br>the property doesn&#39;t have a reason to get at that.<br></p><p>So I&#39;m actually now leaning to making it default to the same<br>accessibility as the property itself (e.g. public, if the property<br>is public). Any behaviors that have internal implementation details<br>that should never be exposed (e.g. memoized should never expose its<br>box, but maybe it should expose an accessor to check if it&#39;s<br>initialized) can mark those properties/methods as internal or<br>private and that accessibility modifier would be obeyed. Which is to<br>say, the behavior itself should always be accessible on a property,<br>but implementation details of the behavior are subject to the normal<br>accessibility rules there.<br></p><p>The proposed (public lazy) syntax can still be used to lower visibility,<br>e.g. (private lazy).<br></p><p>&gt; Defining behavior requirements using a protocol<br></p><p>As mentioned above, I think we should actually model behaviors using a<br>family of protocols. This will let us represent decorators vs value<br>transformers (and a behavior could even be both, by implementing both<br>protocols). We could also use protocols for eager initialization vs lazy<br>initialization (which is distinguished only by the presence of the<br>initializer closure in the behavior initializer). We&#39;d need to do<br>something like<br></p><p>protocol Behavior { init(...) } protocol LazyBehavior { init(...) }<br>protocol DecoratorBehavior : Behavior { ... } protocol<br>LazyDecoratorBehavior : LazyBehavior { ... } protocol<br>TransformerBehavior : Behavior { ... } protocol LazyTransformerBehavior<br>: LazyBehavior { ... }<br></p><p>and that way a type could conform to both DecoratorBehavior and<br>TransformerBehavior without any collision in init (because the init<br>requirement comes from a shared base protocol).<br></p><p>As for actually defining the behavior name, you still do need the global<br>function, but it could maybe return the behavior type, e.g. behavior<br>functions are functions that match either of the following:<br></p><p>func name&lt;T: Behavior&gt;(...) -&gt; T.Type func name&lt;T:<br>LazyBehavior&gt;(...) -&gt; T.Type<br></p><p>I&#39;m not really a big fan of having two &quot;root&quot; protocols here, but I also<br>don&#39;t like magical arguments (e.g. treating the presence of an argument<br>named &quot;initializer&quot; as meaningful) which is why the protocols take<br>initializers. I guess the protocols also need to declare typealiases for<br>the Value type (and TransformerBehavior can declare a separate typealias<br>for the TransformedValue, i.e. the underlying storage. e.g T? for lazy)<br></p><p>&gt; A behavior declaration<br></p><p>This has promise as well. By using a declaration like this, you can have<br>basically a DSL (using contextual keywords) to specify things like<br>whether it&#39;s lazy-initialized, decorators, and transformers. Same<br>benefits as the protocol family (e.g. good compiler checking of the<br>behavior definition before it&#39;s even used anywhere), allows for code code-<br>completion too, and it doesn&#39;t litter the global function namespace with<br>behavior names.<br></p><p>The more I think about this, the more I think it&#39;s a good idea.<br>Especially because it won&#39;t litter the global function namespace with<br>behavior names. Behavior constructors should not be callable by the<br>user, and behaviors may be named things we would love to use as function<br>names anyway (if a behavior implements some functionality that is useful<br>to be exposed to the user anyway, it can vend a type like your proposal<br>has and people can just instantiate that type directly).<br></p><p>&gt; Can properties with behaviors be initialized from init rather than<br>&gt; with inline initializers?<br></p><p>I think the answer to this has to be &quot;absolutely&quot;. Especially if<br>property observers are a behavior (as the initial value may need to be<br>computed from init args or other properties, which can&#39;t be done as an<br>inline initializer).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/856c4d65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>Thanks for the thorough feedback, Kevin! There&#39;s a lot to work through here, but here are some quick responses:<br></p><p>&gt; On Dec 17, 2015, at 3:44 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m a bit concerned about passing in the Container like this. For class types it&#39;s probably fine, but for value types, it means we&#39;re passing a copy of the value in to the property, which just seems really weird (both because it&#39;s a copy, and because that copy includes a copy of the property).<br></p><p>True, it&#39;s fundamentally problematic for property behaviors to try to reach back up through containing value types. It&#39;s already been noted that passing all the parameters all the time to both the behavior function and subscript implementation is a potential code size problem as well. Allowing the operations to only take the parameters they&#39;re interested in would help here.<br></p><p>&gt;  Also the only example you gave that actually uses the container is Synchronized, but even there it&#39;s not great, because it means every synchronized property in the class all share the same lock. But that&#39;s not how Obj-C atomic properties work, and there&#39;s really no benefit at all to locking the entire class when accessing a single property because it doesn&#39;t provide any guarantees about access to multiple properties (as the lock is unlocked in between each access).<br>&gt;  <br>&gt; FWIW, the way Obj-C atomic properties work is for scalars it uses atomic unordered loads/stores (which is even weaker than memory_order_relaxed, all it guarantees is that every load sees a value that was written at some point, i.e. no half-written values). For scalars it calls functions objc_copyStruct(), which uses a bank of 128 spinlocks and picks two of them based on the hash of the src/dst addresses (there&#39;s a comment saying the API was designed wrong, hence the need for 2 spinlocks; ideally it would only use one lock based on the address of the property because the other address is a local stack value). For objects it calls objc_getProperty() / objc_setProperty() which uses a separate bank of 128 spinlocks (and picks one based on the address of the ivar). The getter retains the object with the spinlock held and then autoreleases it outside of the spinlock. The setter just uses the spinlock to protect writing to the ivar, doing any retains/releases outside of it. I haven&#39;t tested but it appears that Obj-C++ properties containing C++ objects uses yet another bank of 128 spinlocks, using the spinlock around the C++ copy operation.<br>&gt;  <br>&gt; Ultimately, the point here is that the only interesting synchronization that can be done at the property level is unordered atomic access, and for any properties that can&#39;t actually use an atomic load/store (either because they&#39;re aggregates or because they&#39;re reference-counted objects) you really do want to use a spinlock to minimize the cost. But adding a spinlock to every single property is a lot of wasted space (especially because safe spinlocks on iOS require a full word), which is why the Obj-C runtime uses those banks of spinlocks.<br></p><p>It seems like all of this could still be captured by a behavior, if you gave synchronized enough overloads for all the special cases.<br></p><p>&gt; In any case, I guess what I&#39;m saying is we should ditch the Container argument. It&#39;s basically only usable for classes, and even then it&#39;s kind of strange for a property to actually care about its container.<br>&gt;  <br>&gt; var `foo.lazy` = lazy(var: Int.self, initializer: { 1738 })<br>&gt;  <br>&gt; This actually won&#39;t work to replace existing lazy properties. It&#39;s legal today to write<br>&gt;  <br>&gt;     lazy var x: Int = self.y + 1<br>&gt;  <br>&gt; This works because the initializer expression isn&#39;t actually run until the property is accessed. But if the initializer is passed to the behavior function, then it can&#39;t possibly reference `self` as that runs before stage-1 initialization.<br></p><p>Referencing `self` in `lazy` initializers is hit-or-miss today. This seems like another problem that could be solved by making the behavior function take only the parameters it&#39;s interested in. If lazy() doesn&#39;t accept an initializer, but Lazy&#39;s subscript operator does, then you know the initializer isn&#39;t consumed during init and can safely reference `self`.<br></p><p><br>&gt; A property behavior can model &quot;delayed&quot; initialization behavior, where the DI rules for var and let properties are enforced dynamically rather than at compile time<br>&gt;  <br>&gt; It looks to me that the only benefit this has versus IOUs is you can use a `let` instead of a `var`. It&#39;s worth pointing out that this actually doesn&#39;t even replace IOUs for @IBOutlets because it&#39;s commonly useful to use optional-chaining on outlets for code that might run before the view is loaded (and while optional chaining is possible with behavior access, it&#39;s a lot more awkward).<br></p><p>There are several advantages over IUO that I see. The behavior can ensure that a mutable delayed var never gets reset to nil, and can dynamically enforce that an immutable delayed var/let isn&#39;t reset after it&#39;s been initialized. It also communicates intent; as I mentioned to Matthew in another subthread, <br></p><p>&gt;  <br>&gt; let (delayed) x: Int<br>&gt; ...<br>&gt; self.x.delayed.initialize(x)<br>&gt; ...<br>&gt;  <br>&gt; Allowing `let` here is actually a violation of Swift&#39;s otherwise-strict rules about `let`. Specifically, Delayed here is a struct, but initializing it requires it to be mutable. So `let (delayed) x: Int` can&#39;t actually ever be initialized. You could make it a class, but that&#39;s a fairly absurd performance penalty for something that provides basically the same behavior as IOUs. You do remark later in detailed design about how the backing storage is always `var`, which solves this at a technical level, but it still appears to the user as though they&#39;re mutating a `let` property and that&#39;s strictly illegal today.<br>&gt;  <br>&gt; I think the right resolution here is just to remove the `letIn` constructor and use `var` for these properties. The behavior itself (e.g. delayed) can document write-once behavior if it wants to. Heck, that behavior was only enforcing write-once in a custom initialize() method anyway, so nothing about the API would actually change.<br></p><p>True, I&#39;m on the fence as to whether allowing `let`s to be implemented with user code is a good idea without an effects model. Taking away the `let` functionality and having a separate `immutableDelayed` behavior is a more conservative design for sure.<br>&gt; Resettable properties<br>&gt;  <br>&gt; The implementation here is a bit weird. If the property is nil, it invokes the initializer expression, every single time it&#39;s accessed. And the underlying value is optional. This is really implemented basically like a lazy property that doesn&#39;t automatically initialize itself.<br>&gt;  <br>&gt; Instead I&#39;d expect a resettable property to have eager-initialization, and to just eagerly re-initialize the property whenever it&#39;s reset. This way the underlying storage isn&#39;t Optional, the initializer expression is invoked at more predictable times, and it only invokes the initializer once per reset.<br>&gt;  <br>&gt; The problem with this change is the initializer expression needs to be provided to the behavior when reset() is invoked rather than when the getter/setter is called.<br></p><p>Yeah, the implementation here is admittedly contorted around the fact reset() can&#39;t receive the initializer expression directly, and we don&#39;t want to store it anywhere in the property.<br>&gt; <br>&gt;  <br>&gt; Property Observers need to somehow support the behavior of letting accessors reassign to the property without causing an infinite loop. They also need to support subclassing such that the observers are called in the correct order in the nested classes (and again, with reassignment, such that the reassigned value is visible to the future observers without starting the observer chain over again).<br></p><p>Yeah, overriding is an interesting problem that needs to be solved. An observer can at least reliably poke through the property by assigning to the `observable` behavior&#39;s property, which is more reliable than our current model.<br></p><p>&gt; Speaking of that, how do behaviors interact with computed properties? A lazy computed property doesn&#39;t make sense (which is why the language doesn&#39;t allow it). But an NSCopying computed property is fine (the computed getter would be handed the copied value).<br></p><p>A behavior decides what kinds of property it supports by overload resolution. If you accept an `initializer`, you act like a stored property. If you accept `get` and `set` bodies, you can act like a computed property. You can also accept your own custom set of accessors if that&#39;s necessary.<br></p><p>&gt;  <br>&gt; The backing property has internal visibility by default<br>&gt;  <br>&gt; In most cases I&#39;d recommend private by default. Just because I have an internal property doesn&#39;t mean the underlying implementation detail should be internal. In 100% of the cases where I&#39;ve written a computed property backed by a second stored property (typically named with a _ prefix), the stored property is always private, because nobody has any business looking at it except for the class/struct it belongs to.<br>&gt;  <br>&gt; Although actually, having said that, there&#39;s at least one behavior (resettable) that only makes sense if it&#39;s just as visible as the property itself (e.g. so it should be public on a public property).<br>&gt;  <br>&gt; And come to think of it, just because the class designer didn&#39;t anticipate a desire to access the underlying storage of a lazy property (e.g. to check if it&#39;s been initialized yet) doesn&#39;t mean the user of the property doesn&#39;t have a reason to get at that.<br>&gt;  <br>&gt; So I&#39;m actually now leaning to making it default to the same accessibility as the property itself (e.g. public, if the property is public). Any behaviors that have internal implementation details that should never be exposed (e.g. memoized should never expose its box, but maybe it should expose an accessor to check if it&#39;s initialized) can mark those properties/methods as internal or private and that accessibility modifier would be obeyed. Which is to say, the behavior itself should always be accessible on a property, but implementation details of the behavior are subject to the normal accessibility rules there.<br></p><p>I don&#39;t think we can default to anything more than internal. Public behaviors become an API liability you can never resiliently change, and we generally design to ensure that API publication is a conscious design decision.<br></p><p>&gt; <br>&gt; A behavior declaration<br>&gt;  <br>&gt; This has promise as well. By using a declaration like this, you can have basically a DSL (using contextual keywords) to specify things like whether it&#39;s lazy-initialized, decorators, and transformers. Same benefits as the protocol family (e.g. good compiler checking of the behavior definition before it&#39;s even used anywhere), allows for code code-completion too, and it doesn&#39;t litter the global function namespace with behavior names.<br>&gt;  <br>&gt; The more I think about this, the more I think it&#39;s a good idea. Especially because it won&#39;t litter the global function namespace with behavior names. Behavior constructors should not be callable by the user, and behaviors may be named things we would love to use as function names anyway (if a behavior implements some functionality that is useful to be exposed to the user anyway, it can vend a type like your proposal has and people can just instantiate that type directly).<br></p><p>Agreed, I&#39;m inclined to think a behavior decl is the way to go too.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/c7ae17ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 4:36 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There are several advantages over IUO that I see. The behavior can ensure that a mutable delayed var never gets reset to nil, and can dynamically enforce that an immutable delayed var/let isn&#39;t reset after it&#39;s been initialized. It also communicates intent; as I mentioned to Matthew in another subthread, <br></p><p>Sorry, trailed off here.  As I mentioned to Matthew in another subthread, the implementation of `delayed` could interact with the SIL diagnostic passes so that you still get DI errors in obviously wrong cases, like using the property before you `initialize` it, initializing it more than once, etc.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/7eee31fb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 4:36 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; It looks to me that the only benefit this has versus IOUs is you can use a `let` instead of a `var`. It&#39;s worth pointing out that this actually doesn&#39;t even replace IOUs for @IBOutlets because it&#39;s commonly useful to use optional-chaining on outlets for code that might run before the view is loaded (and while optional chaining is possible with behavior access, it&#39;s a lot more awkward).<br>&gt; <br>&gt; There are several advantages over IUO that I see. The behavior can ensure that a mutable delayed var never gets reset to nil, and can dynamically enforce that an immutable delayed var/let isn&#39;t reset after it&#39;s been initialized. It also communicates intent; as I mentioned to Matthew in another subthread, <br></p><p>Another benefit is that this allows elimination of an entire use-case for IOUs.  This makes it more appetizing and possible to push IOUs further off into a corner.  I’m personally interested in the idea of IOUs evolving into something that isn’t a first class type - instead they could only exist in argument and return types.  Eliminating a common reason that people use them for properties would help with that.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/d3d06bc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 17, 2015, at 7:05 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 4:36 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; It looks to me that the only benefit this has versus IOUs is you can use a `let` instead of a `var`. It&#39;s worth pointing out that this actually doesn&#39;t even replace IOUs for @IBOutlets because it&#39;s commonly useful to use optional-chaining on outlets for code that might run before the view is loaded (and while optional chaining is possible with behavior access, it&#39;s a lot more awkward).<br>&gt;&gt; <br>&gt;&gt; There are several advantages over IUO that I see. The behavior can ensure that a mutable delayed var never gets reset to nil, and can dynamically enforce that an immutable delayed var/let isn&#39;t reset after it&#39;s been initialized. It also communicates intent; as I mentioned to Matthew in another subthread, <br>&gt; <br>&gt; Another benefit is that this allows elimination of an entire use-case for IOUs.  This makes it more appetizing and possible to push IOUs further off into a corner.  I’m personally interested in the idea of IOUs evolving into something that isn’t a first class type - instead they could only exist in argument and return types.  Eliminating a common reason that people use them for properties would help with that.<br></p><p>+1 to this.  Anything that replaces potentially unsafe patterns with safer patterns is a step in the right direction.  That&#39;s why I think it&#39;s so important to have compiler support for delayed properties one way or another.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/0835373e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>On Thu, Dec 17, 2015, at 04:36 PM, Joe Groff wrote:<br>&gt;&gt;&gt; Resettable properties<br>&gt;&gt;<br>&gt;&gt; The implementation here is a bit weird. If the property is nil, it<br>&gt;&gt; invokes the initializer expression, every single time it&#39;s accessed.<br>&gt;&gt; And the underlying value is optional. This is really implemented<br>&gt;&gt; basically like a lazy property that doesn&#39;t automatically initialize<br>&gt;&gt; itself.<br>&gt;&gt;<br>&gt;&gt; Instead I&#39;d expect a resettable property to have eager-<br>&gt;&gt; initialization, and to just eagerly re-initialize the property<br>&gt;&gt; whenever it&#39;s reset. This way the underlying storage isn&#39;t Optional,<br>&gt;&gt; the initializer expression is invoked at more predictable times, and<br>&gt;&gt; it only invokes the initializer once per reset.<br>&gt;&gt;<br>&gt;&gt; The problem with this change is the initializer expression needs to<br>&gt;&gt; be provided to the behavior when reset() is invoked rather than when<br>&gt;&gt; the getter/setter is called.<br>&gt;<br>&gt; Yeah, the implementation here is admittedly contorted around the fact<br>&gt; reset() can&#39;t receive the initializer expression directly, and we<br>&gt; don&#39;t want to store it anywhere in the property.<br></p><p>We definitely can&#39;t have behaviors storing closures. Any closure that<br>references `self` would then become a retain cycle. And of course for<br>value types the closure would have captured an outdated copy of self. I<br>think we should state upfront that any closure type given to a behavior<br>should be required to be @noescape.<br></p><p>Something I meant to suggest but forgot was the idea that maybe a<br>Behavior at runtime should be a struct that&#39;s initialized every time it<br>needs to do something, and takes init arguments for the initializer and<br>any relevant accessors (e.g. willSet, didSet). This is similar to how<br>you already have it optionally take that stuff, but if the struct is<br>initialized fresh on each access, with the initializer and accessors<br>being provided as @noescape bound closures (implemented by hidden<br>function declarations), then even things like reset() will have access<br>to all the info it needs to do whatever it wants. Although I&#39;m not quite<br>sure offhand how to model reset() being able to mutate the property if<br>the behavior doesn&#39;t keep the property storage inline (which, as I<br>previously mentioned, has composability problems). Maybe each method<br>would actually take an inout parameter as the first argument that it can<br>use to read from/write to the underlying property?<br></p><p>Alternatively, properties could not even have a runtime struct<br>representation but just be collections of static functions. Each<br>function would take an inout parameter for the underlying property, and<br>then optional parameters for the various things the user can specify<br>(initializer and accessors). This would make more sense when using the<br>explicit `behavior` keyword because you&#39;d just model this as functions<br>nested inside the behavior scope, with no type declaration anywhere.<br></p><p>&gt;&gt;<br>&gt;&gt;&gt; The backing property has internal visibility by default<br>&gt;&gt;<br>&gt;&gt; In most cases I&#39;d recommend private by default. Just because I have<br>&gt;&gt; an internal property doesn&#39;t mean the underlying implementation<br>&gt;&gt; detail should be internal. In 100% of the cases where I&#39;ve written a<br>&gt;&gt; computed property backed by a second stored property (typically named<br>&gt;&gt; with a _ prefix), the stored property is always private, because<br>&gt;&gt; nobody has any business looking at it except for the class/struct it<br>&gt;&gt; belongs to.<br>&gt;&gt;<br>&gt;&gt; Although actually, having said that, there&#39;s at least one behavior<br>&gt;&gt; (resettable) that only makes sense if it&#39;s just as visible as the<br>&gt;&gt; property itself (e.g. so it should be public on a public property).<br>&gt;&gt;<br>&gt;&gt; And come to think of it, just because the class designer didn&#39;t<br>&gt;&gt; anticipate a desire to access the underlying storage of a lazy<br>&gt;&gt; property (e.g. to check if it&#39;s been initialized yet) doesn&#39;t mean<br>&gt;&gt; the user of the property doesn&#39;t have a reason to get at that.<br>&gt;&gt;<br>&gt;&gt; So I&#39;m actually now leaning to making it default to the same<br>&gt;&gt; accessibility as the property itself (e.g. public, if the property<br>&gt;&gt; is public). Any behaviors that have internal implementation details<br>&gt;&gt; that should never be exposed (e.g. memoized should never expose its<br>&gt;&gt; box, but maybe it should expose an accessor to check if it&#39;s<br>&gt;&gt; initialized) can mark those properties/methods as internal or<br>&gt;&gt; private and that accessibility modifier would be obeyed. Which is to<br>&gt;&gt; say, the behavior itself should always be accessible on a property,<br>&gt;&gt; but implementation details of the behavior are subject to the normal<br>&gt;&gt; accessibility rules there.<br>&gt;<br>&gt; I don&#39;t think we can default to anything more than internal. Public<br>&gt; behaviors become an API liability you can never resiliently change,<br>&gt; and we generally design to ensure that API publication is a conscious<br>&gt; design decision.<br></p><p>I&#39;m inclined to say that some behaviors (like resettable and<br>synchronized) are conceptually part of the public API (assuming the<br>property is public), and some behaviors (like lazy and property<br>observers) aren&#39;t.<br></p><p>With the `behavior` keyword we could let each behavior decide for itself<br>what its default accessibility level should be. That is a bit unusual,<br>but otherwise everyone who uses `resettable` on a public property will<br>actually have to say `public resettable` for it to make sense, and<br>similarly `synchronized` should typically be visible to consumers of the<br>API (even though there&#39;s no actual API on the behavior itself to use)<br>because the threading behavior of an API is part of its public contract.<br>Of course you could always say `private synchronized` if you wanted to<br>override this.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/66a7f0a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 18, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; We definitely can&#39;t have behaviors storing closures. Any closure that references `self` would then become a retain cycle.<br></p><p>If we could somehow enforce `unowned` capture of `self`, that wouldn’t be a problem.<br></p><p>&gt; And of course for value types the closure would have captured an outdated copy of self.<br></p><p>Though this would be.<br></p><p>Perhaps the initializer closure should take `self` as a parameter, and so should any behavior method (at least as an option). So you would write `reset&lt;Container&gt;(inout container: Container)`, but you would call `propertyName.lazy.reset()`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9c72f152ed52fbbdb5f174ad2e1e7b0a?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>John Calsbeek</string> &lt;john.calsbeek+lists at gmail.com&gt;<p>December 17, 2015 at 10:00:00pm</p></header><div class="content"><p>This language feature seemed complicated to me at first glance. Then I read through Kevin’s treatment, and now it seems tremendously complicated. :-)<br></p><p>Property behaviors seem to be moving in the direction of formalizing the language’s property model, in that they interact with the property’s interface (accessors and more), storage, inheritance, delegation (logging/willSet/didSet), polymorphism (covariance), and probably more. Since the scope is so large, maybe this proposal can be split into parts?<br></p><p>What kind of language features would be needed to implement the (language-implemented) behaviors that we have now, ignoring the compiler’s blessing of syntax to make the implementation transparent?<br></p><p>The obvious way to think of behaviors is structs that contain the property’s storage, with interface methods providing access. If we tried to implement everything in Joe’s proposal directly with generic structs, what problems would be hit?<br></p><p>The first problem is the initializer closure: capturing `self` is a bad idea, but if the initializer just took `self` as an argument (if safe to do so), then the initializer could simply be stored in the “property box” with the downside of increased storage. Making this type-safe seems to require that box type also be generic over the type of the containing object, which is interesting. Lazy&lt;Value&gt;, MemoizationBox&lt;Value&gt;, Delayed&lt;Value&gt;, and Resettable&lt;Value&gt; can be straightforwardly implemented this way.<br></p><p>Synchronized&lt;Value&gt; can be as well: if `self` is available to be passed to the initializer, then it is available to grab a lock from. Of course here we start hitting the composition problems: you can write either Lazy&lt;Synchronized&lt;Value&gt;&gt; or Synchronized&lt;Lazy&lt;Value&gt;&gt;. Like Kevin said, what you really want is dispatch_once-like behavior: a single control value which means “uninitialized”, “being initialized”, or “initialized”.<br></p><p>Observed&lt;Value&gt; is another hint of a problem: if I understand correctly (I am really a Swift newbie), willSet and didSet can be overridden. Modeling that by composing a struct seems very difficult. A list of closures? Or closures which call the next one in the chain?<br></p><p>Also, you potentially want to be able to override the *whole property*, which is also a problem since it involves storage changes. And what you may really want is to override the whole property except for the observers.<br></p><p>I guess I’m implying that it should be possible to implement something with similar semantics and performance characteristics to property behaviors in a library, neglecting all special syntax. That prospect alone seems very intimidating. I wonder if there is a set of language features that would allow a library implementation, while still allowing properties to be thought of as a single “thing”? Even if those features are never implemented, it might make it clearer what specific magic is required for property behaviors to function. A non-exhaustive list:<br></p><p>1) overriding storage in a subclass while still vending the original interface to people using the object via a super type or a protocol<br>2) methods in the composed type that are overridable in the container type (willSet/didSet)<br>3) initializer method/closure that neither captures `self` nor takes up space in the instance when stored (i.e. acts like a method of the container type)<br>4) the proposed safety when composing multiple boxes in potentially incompatible orders<br></p><p>I think exploring what those features would look like in isolation might be illuminating. Of course, they may turn out to be overly generic and only useful in the context of properties.<br></p><p>-John<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; A behavior declaration<br>&gt;  <br>&gt; This has promise as well. By using a declaration like this, you can have basically a DSL (using contextual keywords) to specify things like whether it&#39;s lazy-initialized, decorators, and transformers. Same benefits as the protocol family (e.g. good compiler checking of the behavior definition before it&#39;s even used anywhere), allows for code code-completion too, and it doesn&#39;t litter the global function namespace with behavior names.<br>&gt;  <br>&gt; The more I think about this, the more I think it&#39;s a good idea. Especially because it won&#39;t litter the global function namespace with behavior names. Behavior constructors should not be callable by the user, and behaviors may be named things we would love to use as function names anyway (if a behavior implements some functionality that is useful to be exposed to the user anyway, it can vend a type like your proposal has and people can just instantiate that type directly).<br>&gt;  <br></p><p>+1 to these comments.  I think this option should at least be fleshed out further and receive serious consideration.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/51dae5c9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on a design for allowing properties to be extended with user-defined delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open up for broader discussion. Thanks for taking a look!<br></p><p>This is fantastic, Joe.<br></p><p>The one big thing I would like to see from this feature is a way to get all the instances of a particular behavior which were attached to an instance. For example, I’d like to be able to annotate particular values with a `serialized` behavior and then have a serialization framework be able to access all the type’s `serialized` behavior instances and get or set the corresponding properties. Perhaps there’s a way to hack this in with what you’re doing already, but if so, I don’t see it yet.<br></p><p>Relatedly, it would be nice if a behavior got the name of the property and type it was being applied to. In addition to my serialization case, this would be useful for error messages and probably some other things.<br></p><p>It’s awesome and important that you can add arbitrary blocks like `didSet`, but I don’t see any mechanism to pass in any other sort of arbitrary parameter to a behavior. It’d be nice if you could do that.<br></p><p>Okay, time for bikeshedding:<br></p><p>I would really like to see this get the @ syntax. And specifically, I would like to see the @ syntax eventually *only* be used for behaviors and other user-extensible features like it, while anything that&#39;s pure, unalloyed compiler magic (like access modifiers) becomes a plain keyword. Obviously this would require some reorganization of existing features, and perhaps you wouldn’t do this all at once, but currently the @ syntax is not really used in any sort of principled way, and this seems like a good way to clean it up.<br></p><p>If you do adopt @ syntax, then the behavior instance could be accessed with propertyName at behaviorName.<br></p><p>I actually think that behavior instances should probably be private, and there should be no way to change that. Behaviors are inherently an implementation detail, and you should not be exposing them directly to users of your type. Instead, you should expose just the operations you expect to be needed through your own calls, which you can reimplement as needed. (This statement is not 100% compatible with my request for type-wide metadata, of course. Not sure how to reconcile those.)<br></p><p>Overall, great work! I can already tell that I’m going to use the shit out of this feature. Now to read Kevin Ballard’s monster reply…<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 23:50 , Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I actually think that behavior instances should probably be private, and there should be no way to change that. Behaviors are inherently an implementation detail, and you should not be exposing them directly to users of your type. Instead, you should expose just the operations you expect to be needed through your own calls, which you can reimplement as needed.<br></p><p>I&#39;m leaning in this direction too. The idea of exposing the behavior itself as a value seems wrong for almost any client. &quot;foo.prop.reset()&quot; is slightly nicer than &quot;foo.resetProp()&quot;, but not if it conflicts with a &#39;reset&#39; that&#39;s already on the property type. &quot;foo.prop at behavior.reset()&quot; certainly isn&#39;t an improvement.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/8bc2bbfe/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; I actually think that behavior instances should probably be private, and there should be no way to change that. Behaviors are inherently an implementation detail, and you should not be exposing them directly to users of your type. Instead, you should expose just the operations you expect to be needed through your own calls, which you can reimplement as needed.<br>&gt; <br>&gt; I&#39;m leaning in this direction too. The idea of exposing the behavior itself as a value seems wrong for almost any client. &quot;foo.prop.reset()&quot; is slightly nicer than &quot;foo.resetProp()&quot;, but not if it conflicts with a &#39;reset&#39; that&#39;s already on the property type. &quot;foo.prop at behavior.reset()&quot; certainly isn&#39;t an improvement.<br></p><p>I&#39;ve been thinking about this more, and I think there&#39;s at least one exception: if you introduce a behavior that allows for arbitrary observers to watch a property (basically a KVO replacement), you want a standard way to access that functionality, rather than having to declare cover methods for everything. So maybe the visibility of the behavior should be controllable, but by the behavior itself, not the property it&#39;s applied to.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 22, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 5:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I actually think that behavior instances should probably be private, and there should be no way to change that. Behaviors are inherently an implementation detail, and you should not be exposing them directly to users of your type. Instead, you should expose just the operations you expect to be needed through your own calls, which you can reimplement as needed.<br>&gt;&gt; <br>&gt;&gt; I&#39;m leaning in this direction too. The idea of exposing the behavior itself as a value seems wrong for almost any client. &quot;foo.prop.reset()&quot; is slightly nicer than &quot;foo.resetProp()&quot;, but not if it conflicts with a &#39;reset&#39; that&#39;s already on the property type. &quot;foo.prop at behavior.reset()&quot; certainly isn&#39;t an improvement.<br>&gt; <br>&gt; I&#39;ve been thinking about this more, and I think there&#39;s at least one exception: if you introduce a behavior that allows for arbitrary observers to watch a property (basically a KVO replacement), you want a standard way to access that functionality, rather than having to declare cover methods for everything. So maybe the visibility of the behavior should be controllable, but by the behavior itself, not the property it&#39;s applied to.<br></p><p>Yeah. There are behaviors where exporting the functionality is important, so I think we need to preserve the ability to make them public. In addition to `KVOable`, `resettable` also meets this criterion—there&#39;s no point in declaring a resettable property if clients can&#39;t reset it. Maybe visibility is a trait of the behavior, though, and not necessarily of the property declarations using it, since something like &#39;KVOable&#39; is almost always something you want to publish, whereas `lazy` is almost always an implementation detail. However, I could see people wanting to also publish things like `lazy`, `copying`, or `synchronized` as documentation of semantics, even if they aren&#39;t directly useful as API.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 18, 2015 at 11:00:00am</p></header><div class="content"><p>I am excited by the general direction but I have some concerns about the scope of the design at this time; specifically, it seems like it would benefit a lot from having some flexible-and-efficient way for behaviors to “reach upward” back into their container from within their custom methods (without forcing the caller to pass-in the container to each such call, of course).<br></p><p>I took a stab at mocking up one of the behaviors I’d like to be able to write and hit a lot of roadblocks due to the above; I’ve included it below with some commentary. <br></p><p>Even though this is perhaps a rather extreme/niche behavior to want to implement, I think the issues it encountered are actually general enough that other useful behaviors will also encounter them under the proposal as sketched.<br></p><p>Here’s the sample use, starting with motivation.<br></p><p>For some APIs — e.g. CoreBluetooth — you often wind up with highly-stateful objects that receive callbacks on a specific queue, and typically also do their state-maintenance while on that same queue; these objects typically also have a “public API” with methods that are only meant for use while off the queue (e.g. from the main queue, to update the UI…).<br></p><p>You thus wind up with each method-and-property pretty clearly being one and only one of these:<br></p><p>- “on-queue”, e.g. *only* meant for use while on the object’s queue<br>- “off-queue”, e.g. *only* meant for use while off the object’s queue<br></p><p>…with concurrency-and-synchronization logic essentially amounting to only calling / using each method-and-property while appropriately on/off queue.<br></p><p>For a concrete example, for an implementer of CBCentralManagerDelegate:<br></p><p>- all the CBCentralManagerDelegate methods are &quot;on-queue&quot;<br>- all the BT-state-management methods (called in reaction to BT events) are also “on-queue”<br>- the public methods (e.g. for UI use, or for asking the object to do stuff) are “off-queue”<br>- some of the basic properties (status, is-peripheral-foo-connected?) are oddballs, and get:<br>  - private backing properties for use/update while on-queue<br>  - public off-queue accessors that do a dispatch_sync, read the backing property, and return it<br></p><p>…and so on.<br></p><p>This can all be handled today &quot;by hand” — it just requires being careful — but it’d be nice to have a custom behavior that would streamline both the implementation of on/off queue access for properties, and make each site-of-use more self-documenting/self-verifying vis-a-vis on/off-queue status.<br></p><p>Here’s my best attempt (issues flagged in ALL-CAPS):<br></p><p>/// Object assumed to have private queue it uses for synchronization.<br>protocol PrivateQueueOwner : class {<br></p><p>  // we don’t want to leak the actual queue to the wider world,<br>  // so we have to bubble these up to the public API:<br>  func dispatchSync&lt;R&gt;(@noescape action: () -&gt; R) -&gt; R<br>  func dispatchBarrierSync&lt;R&gt;(@noescape action: () -&gt; R) -&gt; R<br>  func dispatchAsync(action: () -&gt; ())<br>  func dispatchBarrierAsync(action: () -&gt; ())<br></p><p>  // we assume we are managing our queues s.t. we can<br>  // actually get the below to work reliably:<br>  func isOnPrivateQueue() -&gt; Bool<br></p><p>}<br></p><p>/// Behavior used to enforce a particular use-pattern around<br>/// a property of an object that uses a private queue for synchronization:<br>struct QueueAccess&lt;Value&gt; {<br>  var value: Value<br>  <br>  // THIS PART IS ONLY-KINDA OK:<br>  subscript&lt;Container:PrivateQueueOwner&gt;(varIn container: Container&gt; {<br>    get {<br>      if container.isOnPrivateQueue() {<br>        return self.value<br>      } else {<br>        return self.container.dispatchSync() {<br>          return self.value<br>          // ^ DOES THIS ACTUALLY WORK AS I’D WANT, IF I AM A STRUCT?<br>        }<br>      }<br>    }<br>    set {<br>      if container.isOnPrivateQueue() { <br>        self.value = newValue<br>      } else {<br>        container.dispatchBarrierAsync() {<br>          self.value = newValue<br>          // ^ DOES THIS ACTUALLY WORK AS I’D WANT, IF I AM A STRUCT?<br>        }<br>      }<br>    }<br>  }<br></p><p>  // EVERYTHING FROM HERE ON DOWN IS MOSTLY PROBLEMATIC:<br></p><p>  func onQueueUpdate(newValue: Value) { <br>    assert(self.container.isOnPrivateQueue()) // &lt;- HOW?<br>    self.value = newValue<br>  }<br>  <br>  func offQueueUpdate(newValue: Value) {<br>    assert(self.container.isOffPrivateQueue()) // &lt;- HOW?<br>    self.container.dispatchBarrierAsync() { // &lt;- HOW?<br>       self.value = newValue<br>       // ^ DOES THIS EVEN WORK IF I AM A STRUCT?   <br>    }<br>  }<br></p><p>  func offQueueAccess() -&gt; Value {<br>    assert(self.container.isOffPrivateQueue()) // &lt;- HOW?<br>    return self.container.dispatchSync() { // &lt;- HOW?<br>      return self.value<br>    }<br>  }<br></p><p>  func onQueueAcccess() -&gt; Value {<br>    assert(self.container.isOnPrivateQueue()) // &lt;- HOW?<br>    return self.value<br>  }<br></p><p>  func offQueueAccess&lt;R&gt;(@noescape transform: (Value) -&gt; R) -&gt; R {<br>    assert(self.container.isOffPrivateQueue()) // &lt;- HOW?<br>    return self.container.dispatchSync() { // &lt;- HOW?<br>      return transform(self.value)<br>    }<br>  }<br></p><p>  func onQueueAcccess&lt;R&gt;(@noescape transform: (Value) -&gt; R) -&gt; R {<br>    assert(self.container.isOnPrivateQueue()) // &lt;- HOW?<br>    return transform(self.value)<br>  }<br></p><p>}<br></p><p>….which if it was implementable, would wind up used like so:<br></p><p>public class BTCentralManagerController : NSObject, CBCentralManagerDelegate, PrivateQueueOwner {<br></p><p>  internal lazy var centralManager: CBCentralManager = CBCentralManager(<br>    delegate: self, <br>    queue: self.privateQueue, <br>    options: self.centralManagerOptions()<br>  )<br>  <br>  private let privateQueue: dispatch_queue_t <br>  <br>  public private(set) var (queueAccess) centralManagerState: CBCentralManagerState = .Unknown<br>  internal private(set) var (queueAccess) peripheralControllers: [NSUUID:BTPeripheralController] = [:]<br>  <br>  // internal API sample:<br></p><p>  func centralManagerDidUpdateState(_ central: CBCentralManager) {<br>    self.centralManagerState.queueAccess.onQueueUpdate(central.state)<br>  }<br> <br>  // public API sample<br></p><p>  public func peripheralControllerForUUID(uuid: NSUUID) -&gt; BTPeripheralController? {<br>    // this is an explicitly “off-queue” method:<br>    self.currentState.queueAccess.offQueueAccess() {<br>      return $0[uuid]<br>    }<br>  }<br></p><p>}<br></p><p>…giving us:<br></p><p>- safe defaults for attempted direct-property access<br>- self-dcoumenting/self-validating customized getters-and-setters for all internal-use scenarios<br></p><p>But, as the # of ALL-CAPS comments should indicate, this behavior seems *well beyond* what the proposal can provide in a natural way (e.g. we can get closer by passing-in the container to each method, but that’s a lot less natural and a lot clunkier).<br> <br>Moreover, even if the “ability to access the container” were to be addressed, I also don’t like having to use a protocol like `PrivateQueueOwner` to make my `queueAccess` behavior re-usable; at least at present, adopted-protocol visibility is the same visibility as the type itself, so that e.g. if a public class conforms to `PrivateQueueOwner` then all the methods in `PrivateQueueOwner` are also public.<br></p><p>This is undesirable, as although I’d want such classes to be public, I wouldn’t want such low-level implementation details to be part of their public API.<br></p><p>Ideally, rather than forcing the container to adopt a protocol, I could instead do something *more* like this:<br></p><p>public class BTCentralManagerController : NSObject, CBCentralManagerDelegate {<br></p><p>  private let privateQueue: dispatch_queue_t <br>  <br>  // configures `queueAccess` behavior to use `self.privateQueue` (with on-queue check also as-specified)<br>  // ...note that if this becomes possible, the syntax might need to change, b/c the below is not very readable!<br>  public private(set) var (queueAccess(queue: `self.privateQueue`, onQueue: `self.isOnPrivateQueue()`)) currentState: CBCentralManagerState = .Unknown<br>  internal private(set) var (queueAccess(queue: `self.privateQueue`, onQueue: `self.isOnPrivateQueue()`)) peripheralControllers: [NSUUID:BTPeripheralController] = [:]<br></p><p>}<br></p><p>// which somehow interacts with a declaration like this:<br>struct QueueAccess&lt;Value&gt; {<br></p><p>  var value: Value<br></p><p>  // declaration stating we expect a `queue` expression during configuration, with the <br>  // following type (and the accessor automagically-synthesized via compiler magic)<br>  container var queue: dispatch_queue_t { get }<br></p><p>  // declaration stating we expect an `onQueue` expression during configuration, with the <br>  // following type (and the implementation automagically-synthesized via compiler magic)<br>  container func onQueue() -&gt; Bool<br></p><p>   func onQueueUpdate(newValue: Value) { <br>    assert(self.onQueue()) <br>    self.value = newValue<br>  }<br>  <br>  func offQueueUpdate(newValue: Value) {<br>    assert(!self.onQueue())<br>    dispatch_barrier_async(self.queue) {<br>      self.value  = newValue<br>      // ^ NOTE: this may still be a problem for struct-based behaviors...?<br>    }<br>  }<br> <br>  // etc...<br> <br>}<br></p><p>…which, if possible, would obviously make behaviors a lot more specialized than they are under the current proposal (e.g. they would seemingly need a lot of specialized help from the compiler to be able to access those variables without either creating a strong reference to the container or wasting a lot of space with redundant stored properties, and might be their own specialized type, rather than an otherwise-vanilla struct-or-class as per the current proposal). <br></p><p>But, if the above were possible, the behaviors would be a *lot* more re-usable, and it’d be unnecessary to have the container adopt a particular protocol.<br></p><p>Note also that even if the “unwanted API pollution” issue were resolved — e.g. by making it possible to somehow privately-adopt a protocol, or equivalent — there’d still be the issue of getting efficient access to the container to address, if these use cases are to be supported.<br></p><p>So that’s my reaction; if you read it this far, thanks for your attention.<br></p><p>I’d *completely* understand if the reaction here is simply that such uses are out-of-scope for this proposal; that seems perfectly reasonable!<br></p><p>But keep in mind, the general issue of reaching-up from custom methods of behaviors can show up in simpler contexts:<br></p><p>// convenience logic:<br>private extension UIViewController {<br></p><p>  func viewHasEnteredWindow() -&gt; Bool {<br>     return self.viewIfLoaded()?.window != nil ?? false<br>  }<br>}<br></p><p>// custom behavior:<br>struct MustSetBeforeVisibility&lt;Value&gt; {<br>  value: Value?<br>  <br>  // THIS PART OK:<br>  subscript&lt;Container:UIViewController&gt;(varIn container: Container&gt; -&gt; Value? {<br>    get {<br>      if container.viewHasEnteredWindow() {<br>        guard let v = self.value else { <br>          fatalError(“Should’ve set property \(self) by now, b/c our VC’s view is in the window (vc: \(container))”)<br>        }<br>        return v<br>      } else {<br>        return self.value // perfectly-cromulent to be unset at this point in lifecycle<br>      }<br>    }<br>    set {<br>      if !container.viewHasEnteredWindow() {<br>        self.value = newValue<br>      } else {<br>        fatalError(“Not meant to be set after we have become potentially-visible!&quot;)<br>      }<br>    }<br>  }<br></p><p>  // HOW TO DO THIS PART:<br>  /// non-optional convenience accessor; only meant for use once our view has <br>  /// become potentially-visible<br>  func direct() -&gt; Value {<br>    if !container.viewHasEnteredWindow() { // &lt;- HOW?<br>       fatalError(“Trying to do direct-access on \(self) too soon!&quot;)<br>    } else if let v = self.value {<br>       return v<br>    } else {<br>       fatalError(“Trying to do direct-access, but never set the value for \(self) appropriately!&quot;)<br>    }<br>  }<br></p><p>}<br></p><p>…which is basically another take on a “smarter” implicitly-unwrapped-optional. You don’t *need* a function like `direct()`, but you might want it, and it might be nice to be able to differentiate “using too soon” and “forgot to set the value”.<br></p><p><br>&gt; On Dec 17, 2015, at 11:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on a design for allowing properties to be extended with user-defined delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open up for broader discussion. Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3 &lt;https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3&gt;<br>&gt; <br>&gt; Lazy<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#lazy&gt;<br>&gt; Memoization<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#memoization&gt;<br>&gt; Delayed Initialization<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#delayedinitialization&gt;<br>&gt; Resettable properties<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#resettableproperties&gt;<br>&gt; Synchronized Property Access<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#synchronizedpropertyaccess&gt;<br>&gt; NSCopying<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#nscopying&gt;<br>&gt; Referencing Properties with Pointers<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#referencingpropertieswithpointers&gt;<br>&gt; Property Observers<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#propertyobservers&gt;<br>&gt; Detailed design<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#detaileddesign&gt;<br>&gt; Impact on existing code<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#impactonexistingcode&gt;<br>&gt; Alternatives considered/to consider<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#alternativesconsideredtoconsider&gt;Declaration syntax<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#declarationsyntax&gt;<br>&gt; Syntax for accessing the backing property<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#syntaxforaccessingthebackingproperty&gt;<br>&gt; Defining behavior requirements using a protocol<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#definingbehaviorrequirementsusingaprotocol&gt;<br>&gt; A behavior declaration<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#abehaviordeclaration&gt;<br>&gt; Naming convention for behaviors<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#namingconventionforbehaviors&gt;<br>&gt; TODO<br>&gt;  &lt;file:///Users/jgroff/src/s/swift-evolution/proposals/XXXX-property-delegates.md#todo&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/6711fdff/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>December 18, 2015 at 08:00:00pm</p></header><div class="content"><p>+1 for this proposal. I’m not clear on the syntax and need to take some<br>time exploring it though.<br></p><p>As I read the code in the proposal, it once again blurred the lines for me<br>between property and method. It often seems to me, at an intuitive /<br>teaching level, a property is just semantic sugar for a particular method,<br>combined with some secret sauce to manage the backing storage for the<br>variable.<br></p><p>Someone (Doug?) mentioned getting some documentation out that would clarify<br>the usage of property vs. method. I’d really like to see that for<br>comparison against my own evolving heuristics. It would also be useful in<br>discussing this proposal.<br></p><p>Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on a<br>&gt; design for allowing properties to be extended with user-defined<br>&gt; delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open up<br>&gt; for broader discussion. Thanks for taking a look!<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt;<br>&gt; … snip …<br></p><p>&gt; Defining behavior requirements using a protocol<br>&gt;<br>&gt; It’s reasonable to ask why the behavior interface proposed here is ad-hoc<br>&gt; rather than modeled as a formal protocol. It’s my feeling that a protocol<br>&gt; would be too constraining:<br>&gt;<br>&gt;    - Different behaviors need the flexibility to require different sets<br>&gt;    of property attributes. Some kinds of property support initializers; some<br>&gt;    kinds of property have special accessors; some kinds of property support<br>&gt;    many different configurations. Allowing overloading (and adding new<br>&gt;    functionality via extensions and overloading) is important<br>&gt;    expressivity.<br>&gt;    - Different behaviors place different constraints on what containers<br>&gt;    are allowed to contain properties using the behavior, meaning that<br>&gt;    subscript needs the freedom to impose different generic constraints on<br>&gt;    its varIn/ letIn parameter for different behaviors.<br>&gt;<br>&gt; Would a set of related protocols (given some suppositions above that we<br>could identify categories of behaviors that have similar needs) be another<br>option?<br></p><p>&gt; Instead of relying entirely on an informal protocol, we could add a new<br>&gt; declaration to the language to declare a behavior, something like this:<br>&gt;<br>&gt; behavior lazy&lt;T&gt; {<br>&gt;   func lazy(...) -&gt; Lazy { ... }<br>&gt;   struct Lazy { var value: T; ... }<br>&gt; }<br>&gt;<br>&gt; I do like the idea of a behavior declaration. I find this to be relatively<br>easy to model mentally. It fits with Swift’s general use of the type system<br>to achieve both power and safety.<br></p><p>&gt; When do properties with behaviors get included in the memberwise<br>&gt; initializer of structs or classes, if ever? Can properties with behaviors<br>&gt; be initialized from init rather than with inline initializers?<br>&gt;<br> There’s a separate discussion that mentioned allowing better control of<br>which initializers are generated or synthesized for a given struct. There’s<br>also been mention of a “derived” feature for adding conformance without<br>needing to supply a separate implementation. This question seems related to<br>me - it would be ideal if Swift had a coherent way to declare something<br>that did not need definition because it can be generated by the compiler.<br>In this case, to declare that a property is part of memberwise<br>initialization. `behavior lazy&lt;T&gt;: memberwise {` ?<br></p><p>Observable behaviors would not want to be precluded from initialization,<br>but would also not want to be fired on initialization - at least that’s my<br>first reaction. Is that true for all behaviors - that they would not want<br>to be fired if the property is set as part of the parent type’s<br>initialization, but only on later changes?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/24f9bc0b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 18, 2015, at 7:05 PM, Stephen Christopher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for this proposal. I’m not clear on the syntax and need to take some time exploring it though. <br>&gt; <br>&gt; As I read the code in the proposal, it once again blurred the lines for me between property and method. It often seems to me, at an intuitive / teaching level, a property is just semantic sugar for a particular method, combined with some secret sauce to manage the backing storage for the variable. <br>&gt; <br>&gt; Someone (Doug?) mentioned getting some documentation out that would clarify the usage of property vs. method. I’d really like to see that for comparison against my own evolving heuristics. It would also be useful in discussing this proposal.<br>&gt; <br>&gt;&gt; Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on a design for allowing properties to be extended with user-defined delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open up for broader discussion. Thanks for taking a look!<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; … snip … <br>&gt;&gt; Defining behavior requirements using a protocol<br>&gt;&gt; It’s reasonable to ask why the behavior interface proposed here is ad-hoc rather than modeled as a formal protocol. It’s my feeling that a protocol would be too constraining:<br>&gt;&gt; <br>&gt;&gt; Different behaviors need the flexibility to require different sets of property attributes. Some kinds of property support initializers; some kinds of property have special accessors; some kinds of property support many different configurations. Allowing overloading (and adding new functionality via extensions and overloading) is important expressivity.<br>&gt;&gt; Different behaviors place different constraints on what containers are allowed to contain properties using the behavior, meaning that subscript needs the freedom to impose different generic constraints on its varIn/ letIn parameter for different behaviors.<br>&gt; Would a set of related protocols (given some suppositions above that we could identify categories of behaviors that have similar needs) be another option?  <br>&gt;&gt; Instead of relying entirely on an informal protocol, we could add a new declaration to the language to declare a behavior, something like this:<br>&gt;&gt; <br>&gt;&gt; behavior lazy&lt;T&gt; {<br>&gt;&gt;   func lazy(...) -&gt; Lazy { ... }<br>&gt;&gt;   struct Lazy { var value: T; ... }<br>&gt;&gt; }<br>&gt; I do like the idea of a behavior declaration. I find this to be relatively easy to model mentally. It fits with Swift’s general use of the type system to achieve both power and safety.<br>&gt;&gt; When do properties with behaviors get included in the memberwise initializer of structs or classes, if ever? Can properties with behaviors be initialized from init rather than with inline initializers?<br>&gt;&gt; <br>&gt;  There’s a separate discussion that mentioned allowing better control of which initializers are generated or synthesized for a given struct. There’s also been mention of a “derived” feature for adding conformance without needing to supply a separate implementation. This question seems related to me - it would be ideal if Swift had a coherent way to declare something that did not need definition because it can be generated by the compiler. In this case, to declare that a property is part of memberwise initialization. `behavior lazy&lt;T&gt;: memberwise {` ?<br></p><p>You might be talking about the initialization discussion I was involved in a week or so ago.  I&#39;m working on a proposal that would allow for more flexible control over synthesized memberwise initialization.  I&#39;m hoping to have a draft ready soon.<br></p><p>Is your example here part of a behavior declaration for lazy which states that properties with the lazy behavior may be memberwise initialized?  That&#39;s what it looks like to me.  I think syntax like that would make sense.  There are some behaviors which would need to opt out.  Somewhat ironically, I think lazy is one of them as the whole point of it is that it is not initialized immediately, but rather on first access.<br></p><p>&gt; <br>&gt; Observable behaviors would not want to be precluded from initialization, but would also not want to be fired on initialization - at least that’s my first reaction. Is that true for all behaviors - that they would not want to be fired if the property is set as part of the parent type’s initialization, but only on later changes?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/2c8418bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>December 18, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt;<br>&gt;<br>&gt; When do properties with behaviors get included in the memberwise<br>&gt;&gt; initializer of structs or classes, if ever? Can properties with behaviors<br>&gt;&gt; be initialized from init rather than with inline initializers?<br>&gt;&gt;<br>&gt;  There’s a separate discussion that mentioned allowing better control of<br>&gt; which initializers are generated or synthesized for a given struct. There’s<br>&gt; also been mention of a “derived” feature for adding conformance without<br>&gt; needing to supply a separate implementation. This question seems related to<br>&gt; me - it would be ideal if Swift had a coherent way to declare something<br>&gt; that did not need definition because it can be generated by the compiler.<br>&gt; In this case, to declare that a property is part of memberwise<br>&gt; initialization. `behavior lazy&lt;T&gt;: memberwise {` ?<br>&gt;<br>&gt;<br>&gt; You might be talking about the initialization discussion I was involved in<br>&gt; a week or so ago.  I&#39;m working on a proposal that would allow for more<br>&gt; flexible control over synthesized memberwise initialization.  I&#39;m hoping to<br>&gt; have a draft ready soon.<br>&gt;<br></p><p>Great! Looking forward to reading it.<br></p><p><br>&gt;<br>&gt; Is your example here part of a behavior declaration for lazy which states<br>&gt; that properties with the lazy behavior may be memberwise initialized?<br>&gt; That&#39;s what it looks like to me.  I think syntax like that would make<br>&gt; sense.  There are some behaviors which would need to opt out.  Somewhat<br>&gt; ironically, I think lazy is one of them as the whole point of it is that it<br>&gt; is not initialized immediately, but rather on first access.<br>&gt;<br>&gt; Yes, that was the idea behind that syntax. Hah, lazy was a terrible<br>example, you’re right. Distracted emailing never ends well.<br></p><p>It could be either opt-in (as my example hinted). Opt-out might be a bit<br>harder to express, and I’m not sure if opt-in is the right default.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8e5aab05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Dec 18, 2015, at 8:11 PM, Stephen Christopher &lt;schristopher at bignerdranch.com&gt; wrote:<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt; When do properties with behaviors get included in the memberwise initializer of structs or classes, if ever? Can properties with behaviors be initialized from init rather than with inline initializers?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;  There’s a separate discussion that mentioned allowing better control of which initializers are generated or synthesized for a given struct. There’s also been mention of a “derived” feature for adding conformance without needing to supply a separate implementation. This question seems related to me - it would be ideal if Swift had a coherent way to declare something that did not need definition because it can be generated by the compiler. In this case, to declare that a property is part of memberwise initialization. `behavior lazy&lt;T&gt;: memberwise {` ?<br>&gt;&gt; <br>&gt;&gt; You might be talking about the initialization discussion I was involved in a week or so ago.  I&#39;m working on a proposal that would allow for more flexible control over synthesized memberwise initialization.  I&#39;m hoping to have a draft ready soon.<br>&gt; <br>&gt; Great! Looking forward to reading it.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt; Is your example here part of a behavior declaration for lazy which states that properties with the lazy behavior may be memberwise initialized?  That&#39;s what it looks like to me.  I think syntax like that would make sense.  There are some behaviors which would need to opt out.  Somewhat ironically, I think lazy is one of them as the whole point of it is that it is not initialized immediately, but rather on first access.<br>&gt; Yes, that was the idea behind that syntax. Hah, lazy was a terrible example, you’re right. Distracted emailing never ends well.<br></p><p>I&#39;ve had a couple incidences of distracted emailing on the list myself!  I hope to learn from those mistakes and not repeat it again. :)<br></p><p>&gt; <br>&gt; It could be either opt-in (as my example hinted). Opt-out might be a bit harder to express, and I’m not sure if opt-in is the right default. <br></p><p>I think opt-in is the right default for behaviors as it conflicts with the semantics of some behaviors.<br></p><p>I don&#39;t think a property with a behavior that *allows* memberwise initialization should be required to support it just because the behavior does.  Part of my proposal discusses properties which cannot be memberwise initialized because of access control restrictions or because they have an @nomemberwise attribute.  This might not make a lot of sense without seeing it in the context of the proposal, but it should once I have the draft ready to share.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/a4c2fe57/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 09:00:00am</p></header><div class="content"><p>I played around a bit with the idea of a special behavior declaration. I think it feels a lot nicer, though it also feels like a much bigger language change if we go this route. Inside the declaration, you need to specify:<br>- what accessors the behavior supports, to be implemented by properties using the behavior,<br>- if the behavior controls storage, what that storage is, and what initialization logic it requires,<br>- if the behavior requires an initializer, and whether that initializer is used eagerly at property initialization or deferred to later, and<br>- what operations the behavior offers, if any.<br></p><p>Here&#39;s a quick sketch of how a behavior declaration could look. As a strawman, I&#39;ll use &#39;var behavior&#39; as the introducer for a property behavior (leaving the door open to &#39;func behavior&#39;, &#39;struct behavior&#39;, etc. in the possible future). If you were going to reinvent computed properties from whole cloth, that might look like this:<br></p><p>var behavior computed&lt;T&gt; {<br>  // A computed property requires a `get` and `set` accessor.<br>  accessor get() -&gt; T<br>  accessor set(newValue: T)<br></p><p>  // Accessors for the property<br>  get { return get() }<br>  set { set(newValue) }<br>}<br></p><p>lazy might look something like this:<br></p><p>var behavior lazy&lt;T&gt; {<br>  // lazy requires an initializer expression, but it isn&#39;t<br>  // used until after object initialization.<br>  deferred initializer: T<br></p><p>  // The optional storage for the property.<br>  var value: T?<br></p><p>  // Initialize the storage to nil.<br>  init() {<br>    value = nil<br>  }<br></p><p>  // Accessors for the property.<br>  mutating get {<br>    if let value = value {<br>      return value<br>    }<br>    // `initializer` is implicitly bound to the initializer expr as a<br>    // `@noescape () -&gt; T` within the behavior&#39;s members.<br>    let initialValue = initializer()<br>    value = initialValue<br>    return initialValue<br>  }<br></p><p>  set {<br>    value = newValue<br>  }<br></p><p>  // clear() operation for the behavior.<br>  mutating func clear() {<br>    value = nil<br>  }<br>}<br></p><p>Some behaviors like `lazy` and `resettable` want to take control of the storage to manage their semantics, but many behaviors are adapters independent of how the underlying behavior behaves. These kinds of behavior are easy to compose with other behaviors and to override base class properties with. You could use inheritance-like syntax to indicate a &quot;wrapping&quot; behavior like this, and commandeer `super` to refer to the underlying property. For instance, `synchronized`:<br></p><p>var behavior synchronized&lt;T&gt;: T {<br>  get {<br>    return sync { return super }<br>  }<br>  set {<br>    return sync { return super }<br>  }<br>}<br></p><p>or `observing` didSet/willSet:<br></p><p>var behavior observing&lt;T&gt;: T {<br>  accessor willSet(oldValue: T, newValue: T) { }<br>  accessor didSet(oldValue: T, newValue: T) { }<br></p><p>  get { return super }<br>  set {<br>    let oldValue = super<br>    willSet(oldValue, newValue)<br>    super = newValue<br>    didSet(oldValue, newValue)<br>  }<br>}<br></p><p>If you want to refer back to the containing `self`, we could support that too, and by treating behavior functions specially we should be able to maintain coherent semantics for backreferencing value types as well. Implementing `synchronized` with a per-object lock could look like this:<br></p><p>var behavior synchronizedByObject&lt;T&gt;: T where Self: Synchronizable {<br>  get {<br>    return self.withLock { return super }<br>  }<br>  set {<br>    return self.withLock { return super }<br>  }<br>}<br></p><p>(though the juxtaposed meanings of `super` and `self` here are weird together…we&#39;d probably want a better implicit binding name for the underlying property.)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/e3714601/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 12:00:00pm</p></header><div class="content"><p>I really like the direction this is heading Joe!  I agree it feels a lot nicer.  It seems like the right long-term solution to me.<br></p><p>Making behaviors an explicit construct in the language may lead to possibilities in the future that we cannot today which would not exist with the ad-hoc approach. <br></p><p>&gt; On Dec 21, 2015, at 11:23 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I played around a bit with the idea of a special behavior declaration. I think it feels a lot nicer, though it also feels like a much bigger language change if we go this route. Inside the declaration, you need to specify:<br>&gt; - what accessors the behavior supports, to be implemented by properties using the behavior,<br>&gt; - if the behavior controls storage, what that storage is, and what initialization logic it requires,<br>&gt; - if the behavior requires an initializer, and whether that initializer is used eagerly at property initialization or deferred to later, and<br>&gt; - what operations the behavior offers, if any.<br>&gt; <br>&gt; Here&#39;s a quick sketch of how a behavior declaration could look. As a strawman, I&#39;ll use &#39;var behavior&#39; as the introducer for a property behavior (leaving the door open to &#39;func behavior&#39;, &#39;struct behavior&#39;, etc. in the possible future). If you were going to reinvent computed properties from whole cloth, that might look like this:<br>&gt; <br>&gt; var behavior computed&lt;T&gt; {<br>&gt;   // A computed property requires a `get` and `set` accessor.<br>&gt;   accessor get() -&gt; T<br>&gt;   accessor set(newValue: T)<br>&gt; <br>&gt;   // Accessors for the property<br>&gt;   get { return get() }<br>&gt;   set { set(newValue) }<br>&gt; }<br>&gt; <br>&gt; lazy might look something like this:<br>&gt; <br>&gt; var behavior lazy&lt;T&gt; {<br>&gt;   // lazy requires an initializer expression, but it isn&#39;t<br>&gt;   // used until after object initialization.<br>&gt;   deferred initializer: T<br>&gt; <br>&gt;   // The optional storage for the property.<br>&gt;   var value: T?<br>&gt; <br>&gt;   // Initialize the storage to nil.<br>&gt;   init() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; <br>&gt;   // Accessors for the property.<br>&gt;   mutating get {<br>&gt;     if let value = value {<br>&gt;       return value<br>&gt;     }<br>&gt;     // `initializer` is implicitly bound to the initializer expr as a<br>&gt;     // `@noescape () -&gt; T` within the behavior&#39;s members.<br>&gt;     let initialValue = initializer()<br>&gt;     value = initialValue<br>&gt;     return initialValue<br>&gt;   }<br>&gt; <br>&gt;   set {<br>&gt;     value = newValue<br>&gt;   }<br>&gt; <br>&gt;   // clear() operation for the behavior.<br>&gt;   mutating func clear() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Some behaviors like `lazy` and `resettable` want to take control of the storage to manage their semantics, but many behaviors are adapters independent of how the underlying behavior behaves. These kinds of behavior are easy to compose with other behaviors and to override base class properties with. You could use inheritance-like syntax to indicate a &quot;wrapping&quot; behavior like this, and commandeer `super` to refer to the underlying property. For instance, `synchronized`:<br>&gt; <br>&gt; var behavior synchronized&lt;T&gt;: T {<br>&gt;   get {<br>&gt;     return sync { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return sync { return super }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; or `observing` didSet/willSet:<br>&gt; <br>&gt; var behavior observing&lt;T&gt;: T {<br>&gt;   accessor willSet(oldValue: T, newValue: T) { }<br>&gt;   accessor didSet(oldValue: T, newValue: T) { }<br>&gt; <br>&gt;   get { return super }<br>&gt;   set {<br>&gt;     let oldValue = super<br>&gt;     willSet(oldValue, newValue)<br>&gt;     super = newValue<br>&gt;     didSet(oldValue, newValue)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; If you want to refer back to the containing `self`, we could support that too, and by treating behavior functions specially we should be able to maintain coherent semantics for backreferencing value types as well. Implementing `synchronized` with a per-object lock could look like this:<br>&gt; <br>&gt; var behavior synchronizedByObject&lt;T&gt;: T where Self: Synchronizable {<br>&gt;   get {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; (though the juxtaposed meanings of `super` and `self` here are weird together…we&#39;d probably want a better implicit binding name for the underlying property.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/fc8eb449/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December 21, 2015 at 06:00:00pm</p></header><div class="content"><p>@Joe could you elaborate on the access pattern for these properties? Are<br>you getting back a boxed object every time or is there some sort of magic<br>going on so the caller thinks its getting the value inside the box but<br>still has some way to access methods on the box (say reset for the lazy<br>property)<br></p><p>On Mon, Dec 21, 2015 at 1:04 PM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I really like the direction this is heading Joe!  I agree it feels a lot<br>&gt; nicer.  It seems like the right long-term solution to me.<br>&gt;<br>&gt; Making behaviors an explicit construct in the language may lead to<br>&gt; possibilities in the future that we cannot today which would not exist with<br>&gt; the ad-hoc approach.<br>&gt;<br>&gt; On Dec 21, 2015, at 11:23 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I played around a bit with the idea of a special behavior declaration. I<br>&gt; think it feels a lot nicer, though it also feels like a much bigger<br>&gt; language change if we go this route. Inside the declaration, you need to<br>&gt; specify:<br>&gt; - what accessors the behavior supports, to be implemented by properties<br>&gt; using the behavior,<br>&gt; - if the behavior controls storage, what that storage is, and what<br>&gt; initialization logic it requires,<br>&gt; - if the behavior requires an initializer, and whether that initializer is<br>&gt; used eagerly at property initialization or deferred to later, and<br>&gt; - what operations the behavior offers, if any.<br>&gt;<br>&gt; Here&#39;s a quick sketch of how a behavior declaration could look. As a<br>&gt; strawman, I&#39;ll use &#39;var behavior&#39; as the introducer for a property behavior<br>&gt; (leaving the door open to &#39;func behavior&#39;, &#39;struct behavior&#39;, etc. in the<br>&gt; possible future). If you were going to reinvent computed properties from<br>&gt; whole cloth, that might look like this:<br>&gt;<br>&gt; var behavior computed&lt;T&gt; {<br>&gt;   // A computed property requires a `get` and `set` accessor.<br>&gt;   accessor get() -&gt; T<br>&gt;   accessor set(newValue: T)<br>&gt;<br>&gt;   // Accessors for the property<br>&gt;   get { return get() }<br>&gt;   set { set(newValue) }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; lazy might look something like this:<br>&gt;<br>&gt; var behavior lazy&lt;T&gt; {<br>&gt;   // lazy requires an initializer expression, but it isn&#39;t<br>&gt;   // used until after object initialization.<br>&gt;   deferred initializer: T<br>&gt;<br>&gt;   // The optional storage for the property.<br>&gt;   var value: T?<br>&gt;<br>&gt;   // Initialize the storage to nil.<br>&gt;   init() {<br>&gt;     value = nil<br>&gt;   }<br>&gt;<br>&gt;   // Accessors for the property.<br>&gt;   mutating get {<br>&gt;     if let value = value {<br>&gt;       return value<br>&gt;     }<br>&gt;     // `initializer` is implicitly bound to the initializer expr as a<br>&gt;     // `@noescape () -&gt; T` within the behavior&#39;s members.<br>&gt;     let initialValue = initializer()<br>&gt;     value = initialValue<br>&gt;     return initialValue<br>&gt;   }<br>&gt;<br>&gt;   set {<br>&gt;     value = newValue<br>&gt;   }<br>&gt;<br>&gt;   // clear() operation for the behavior.<br>&gt;   mutating func clear() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Some behaviors like `lazy` and `resettable` want to take control of the<br>&gt; storage to manage their semantics, but many behaviors are adapters<br>&gt; independent of how the underlying behavior behaves. These kinds of behavior<br>&gt; are easy to compose with other behaviors and to override base class<br>&gt; properties with. You could use inheritance-like syntax to indicate a<br>&gt; &quot;wrapping&quot; behavior like this, and commandeer `super` to refer to the<br>&gt; underlying property. For instance, `synchronized`:<br>&gt;<br>&gt; var behavior synchronized&lt;T&gt;: T {<br>&gt;   get {<br>&gt;     return sync { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return sync { return super }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; or `observing` didSet/willSet:<br>&gt;<br>&gt; var behavior observing&lt;T&gt;: T {<br>&gt;   accessor willSet(oldValue: T, newValue: T) { }<br>&gt;   accessor didSet(oldValue: T, newValue: T) { }<br>&gt;<br>&gt;   get { return super }<br>&gt;   set {<br>&gt;     let oldValue = super<br>&gt;     willSet(oldValue, newValue)<br>&gt;     super = newValue<br>&gt;     didSet(oldValue, newValue)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; If you want to refer back to the containing `self`, we could support that<br>&gt; too, and by treating behavior functions specially we should be able to<br>&gt; maintain coherent semantics for backreferencing value types as well.<br>&gt; Implementing `synchronized` with a per-object lock could look like this:<br>&gt;<br>&gt; var behavior synchronizedByObject&lt;T&gt;: T where Self: Synchronizable {<br>&gt;   get {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; (though the juxtaposed meanings of `super` and `self` here are weird<br>&gt; together…we&#39;d probably want a better implicit binding name for the<br>&gt; underlying property.)<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/c5d064c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 10:28 AM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; @Joe could you elaborate on the access pattern for these properties? Are you getting back a boxed object every time or is there some sort of magic going on so the caller thinks its getting the value inside the box but still has some way to access methods on the box (say reset for the lazy property)<br></p><p>There&#39;s no boxing, the behavior effectively just inserts itself in the property chain. It would still act as if you had defined a backing property yourself:<br></p><p>var _backingProperty: Behavior&lt;T&gt;<br>var property: T {<br>  get {<br>    return _backingProperty.getBehavior()<br>  }<br>  set {<br>    _backingProperty.setBehavior(newValue)<br>  }<br>}<br></p><p>It&#39;s true that, if the behavior is implemented in terms of get/set accessors, that this may introduce temporary copies while drilling down into the property. We have other accessor patterns we allow that can avoid this inefficiency that we would use in production implementations of things like `lazy` and `delayed`.<br></p><p>-Joe<br></p><p><br>&gt; <br>&gt; On Mon, Dec 21, 2015 at 1:04 PM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I really like the direction this is heading Joe!  I agree it feels a lot nicer.  It seems like the right long-term solution to me.<br>&gt; <br>&gt; Making behaviors an explicit construct in the language may lead to possibilities in the future that we cannot today which would not exist with the ad-hoc approach. <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 11:23 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I played around a bit with the idea of a special behavior declaration. I think it feels a lot nicer, though it also feels like a much bigger language change if we go this route. Inside the declaration, you need to specify:<br>&gt;&gt; - what accessors the behavior supports, to be implemented by properties using the behavior,<br>&gt;&gt; - if the behavior controls storage, what that storage is, and what initialization logic it requires,<br>&gt;&gt; - if the behavior requires an initializer, and whether that initializer is used eagerly at property initialization or deferred to later, and<br>&gt;&gt; - what operations the behavior offers, if any.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a quick sketch of how a behavior declaration could look. As a strawman, I&#39;ll use &#39;var behavior&#39; as the introducer for a property behavior (leaving the door open to &#39;func behavior&#39;, &#39;struct behavior&#39;, etc. in the possible future). If you were going to reinvent computed properties from whole cloth, that might look like this:<br>&gt;&gt; <br>&gt;&gt; var behavior computed&lt;T&gt; {<br>&gt;&gt;   // A computed property requires a `get` and `set` accessor.<br>&gt;&gt;   accessor get() -&gt; T<br>&gt;&gt;   accessor set(newValue: T)<br>&gt;&gt; <br>&gt;&gt;   // Accessors for the property<br>&gt;&gt;   get { return get() }<br>&gt;&gt;   set { set(newValue) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; lazy might look something like this:<br>&gt;&gt; <br>&gt;&gt; var behavior lazy&lt;T&gt; {<br>&gt;&gt;   // lazy requires an initializer expression, but it isn&#39;t<br>&gt;&gt;   // used until after object initialization.<br>&gt;&gt;   deferred initializer: T<br>&gt;&gt; <br>&gt;&gt;   // The optional storage for the property.<br>&gt;&gt;   var value: T?<br>&gt;&gt; <br>&gt;&gt;   // Initialize the storage to nil.<br>&gt;&gt;   init() {<br>&gt;&gt;     value = nil<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // Accessors for the property.<br>&gt;&gt;   mutating get {<br>&gt;&gt;     if let value = value {<br>&gt;&gt;       return value<br>&gt;&gt;     }<br>&gt;&gt;     // `initializer` is implicitly bound to the initializer expr as a<br>&gt;&gt;     // `@noescape () -&gt; T` within the behavior&#39;s members.<br>&gt;&gt;     let initialValue = initializer()<br>&gt;&gt;     value = initialValue<br>&gt;&gt;     return initialValue<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   set {<br>&gt;&gt;     value = newValue<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // clear() operation for the behavior.<br>&gt;&gt;   mutating func clear() {<br>&gt;&gt;     value = nil<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Some behaviors like `lazy` and `resettable` want to take control of the storage to manage their semantics, but many behaviors are adapters independent of how the underlying behavior behaves. These kinds of behavior are easy to compose with other behaviors and to override base class properties with. You could use inheritance-like syntax to indicate a &quot;wrapping&quot; behavior like this, and commandeer `super` to refer to the underlying property. For instance, `synchronized`:<br>&gt;&gt; <br>&gt;&gt; var behavior synchronized&lt;T&gt;: T {<br>&gt;&gt;   get {<br>&gt;&gt;     return sync { return super }<br>&gt;&gt;   }<br>&gt;&gt;   set {<br>&gt;&gt;     return sync { return super }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or `observing` didSet/willSet:<br>&gt;&gt; <br>&gt;&gt; var behavior observing&lt;T&gt;: T {<br>&gt;&gt;   accessor willSet(oldValue: T, newValue: T) { }<br>&gt;&gt;   accessor didSet(oldValue: T, newValue: T) { }<br>&gt;&gt; <br>&gt;&gt;   get { return super }<br>&gt;&gt;   set {<br>&gt;&gt;     let oldValue = super<br>&gt;&gt;     willSet(oldValue, newValue)<br>&gt;&gt;     super = newValue<br>&gt;&gt;     didSet(oldValue, newValue)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If you want to refer back to the containing `self`, we could support that too, and by treating behavior functions specially we should be able to maintain coherent semantics for backreferencing value types as well. Implementing `synchronized` with a per-object lock could look like this:<br>&gt;&gt; <br>&gt;&gt; var behavior synchronizedByObject&lt;T&gt;: T where Self: Synchronizable {<br>&gt;&gt;   get {<br>&gt;&gt;     return self.withLock { return super }<br>&gt;&gt;   }<br>&gt;&gt;   set {<br>&gt;&gt;     return self.withLock { return super }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; (though the juxtaposed meanings of `super` and `self` here are weird together…we&#39;d probably want a better implicit binding name for the underlying property.)<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/165a1a51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 21, 2015 at 12:00:00pm</p></header><div class="content"><p>I&#39;ve been thinking a little more about the usage. If you don&#39;t want to do the @ thing, suppose you instead use a behavior by specifying it in the block:<br></p><p>	var foo: Bar {<br>		lazy { Bar() }	// This property will be lazy, and initialized/re-iniitalized with this block<br>		synchronized	// This property will be synchronized (you could provide a block to give a queue, but the default&#39;s fine here)<br>		logged		// Calls are logged<br>	}<br></p><p>You might only be able to specify one closure per behavior, so willSet and didSet would have to be different behaviors, but I don&#39;t think that&#39;s necessarily a bad thing—it&#39;d be nice if `observable` could be saved for arbitrary third-party observation (that is, a KVO replacement).<br></p><p>It&#39;s even possible that you could implement `get` and `set` themselves as behaviors! That would be pretty neat.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 21, 2015 at 03:00:00pm</p></header><div class="content"><p>Le 21 déc. 2015 à 12:23, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; Some behaviors like `lazy` and `resettable` want to take control of the storage to manage their semantics, but many behaviors are adapters independent of how the underlying behavior behaves. These kinds of behavior are easy to compose with other behaviors and to override base class properties with. You could use inheritance-like syntax to indicate a &quot;wrapping&quot; behavior like this, and commandeer `super` to refer to the underlying property. For instance, `synchronized`:<br></p><p>It&#39;s unclear to me whether you can write behaviour extensions with this new model. I&#39;m not sure if that&#39;s really needed, but with the struct-based model, you could.<br></p><p><br>&gt; If you want to refer back to the containing `self`, we could support that too, and by treating behavior functions specially we should be able to maintain coherent semantics for backreferencing value types as well. Implementing `synchronized` with a per-object lock could look like this:<br>&gt; <br>&gt; var behavior synchronizedByObject&lt;T&gt;: T where Self: Synchronizable {<br>&gt;   get {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt; }<br></p><p>Instead of simply writing `: T`, you could use a parameter list to give a name to that `super`-property:<br></p><p>	var behavior synchronizedByObject&lt;T&gt;(var parentProperty: T) where Self: Synchronizable {<br>	  get {<br>	    return self.withLock { return parentProperty }<br>	  }<br>	  set {<br>	    return self.withLock { parentProperty = newValue }<br>	  }<br>	}<br></p><p><br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>:-( I&#39;m worried about increasing the size of the language this much. I really want to be able to say &quot;behaviors are just syntactic sugar for declaring accessors and storage, and then everything else behaves normally&quot;. This makes them another entirely orthogonal decl kind, like operators.<br></p><p>Jordan<br></p><p>&gt; On Dec 21, 2015, at 9:23 , Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I played around a bit with the idea of a special behavior declaration. I think it feels a lot nicer, though it also feels like a much bigger language change if we go this route. Inside the declaration, you need to specify:<br>&gt; - what accessors the behavior supports, to be implemented by properties using the behavior,<br>&gt; - if the behavior controls storage, what that storage is, and what initialization logic it requires,<br>&gt; - if the behavior requires an initializer, and whether that initializer is used eagerly at property initialization or deferred to later, and<br>&gt; - what operations the behavior offers, if any.<br>&gt; <br>&gt; Here&#39;s a quick sketch of how a behavior declaration could look. As a strawman, I&#39;ll use &#39;var behavior&#39; as the introducer for a property behavior (leaving the door open to &#39;func behavior&#39;, &#39;struct behavior&#39;, etc. in the possible future). If you were going to reinvent computed properties from whole cloth, that might look like this:<br>&gt; <br>&gt; var behavior computed&lt;T&gt; {<br>&gt;   // A computed property requires a `get` and `set` accessor.<br>&gt;   accessor get() -&gt; T<br>&gt;   accessor set(newValue: T)<br>&gt; <br>&gt;   // Accessors for the property<br>&gt;   get { return get() }<br>&gt;   set { set(newValue) }<br>&gt; }<br>&gt; <br>&gt; lazy might look something like this:<br>&gt; <br>&gt; var behavior lazy&lt;T&gt; {<br>&gt;   // lazy requires an initializer expression, but it isn&#39;t<br>&gt;   // used until after object initialization.<br>&gt;   deferred initializer: T<br>&gt; <br>&gt;   // The optional storage for the property.<br>&gt;   var value: T?<br>&gt; <br>&gt;   // Initialize the storage to nil.<br>&gt;   init() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; <br>&gt;   // Accessors for the property.<br>&gt;   mutating get {<br>&gt;     if let value = value {<br>&gt;       return value<br>&gt;     }<br>&gt;     // `initializer` is implicitly bound to the initializer expr as a<br>&gt;     // `@noescape () -&gt; T` within the behavior&#39;s members.<br>&gt;     let initialValue = initializer()<br>&gt;     value = initialValue<br>&gt;     return initialValue<br>&gt;   }<br>&gt; <br>&gt;   set {<br>&gt;     value = newValue<br>&gt;   }<br>&gt; <br>&gt;   // clear() operation for the behavior.<br>&gt;   mutating func clear() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Some behaviors like `lazy` and `resettable` want to take control of the storage to manage their semantics, but many behaviors are adapters independent of how the underlying behavior behaves. These kinds of behavior are easy to compose with other behaviors and to override base class properties with. You could use inheritance-like syntax to indicate a &quot;wrapping&quot; behavior like this, and commandeer `super` to refer to the underlying property. For instance, `synchronized`:<br>&gt; <br>&gt; var behavior synchronized&lt;T&gt;: T {<br>&gt;   get {<br>&gt;     return sync { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return sync { return super }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; or `observing` didSet/willSet:<br>&gt; <br>&gt; var behavior observing&lt;T&gt;: T {<br>&gt;   accessor willSet(oldValue: T, newValue: T) { }<br>&gt;   accessor didSet(oldValue: T, newValue: T) { }<br>&gt; <br>&gt;   get { return super }<br>&gt;   set {<br>&gt;     let oldValue = super<br>&gt;     willSet(oldValue, newValue)<br>&gt;     super = newValue<br>&gt;     didSet(oldValue, newValue)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; If you want to refer back to the containing `self`, we could support that too, and by treating behavior functions specially we should be able to maintain coherent semantics for backreferencing value types as well. Implementing `synchronized` with a per-object lock could look like this:<br>&gt; <br>&gt; var behavior synchronizedByObject&lt;T&gt;: T where Self: Synchronizable {<br>&gt;   get {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; (though the juxtaposed meanings of `super` and `self` here are weird together…we&#39;d probably want a better implicit binding name for the underlying property.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/e772a22c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 5:21 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; :-( I&#39;m worried about increasing the size of the language this much. I really want to be able to say &quot;behaviors are just syntactic sugar for declaring accessors and storage, and then everything else behaves normally&quot;. This makes them another entirely orthogonal decl kind, like operators.<br></p><p>I&#39;d prefer not to have a new decl as well, if that was the best choice. However, it&#39;s still just syntactic sugar for declaring accessors and storage.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 5:33 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 5:21 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; :-( I&#39;m worried about increasing the size of the language this much. I really want to be able to say &quot;behaviors are just syntactic sugar for declaring accessors and storage, and then everything else behaves normally&quot;. This makes them another entirely orthogonal decl kind, like operators.<br>&gt; <br>&gt; I&#39;d prefer not to have a new decl as well, if that was the best choice. However, it&#39;s still just syntactic sugar for declaring accessors and storage.<br></p><p>I think there’s value for users in being able to group and scope the components associated with a particular behavior, so IMO it’s worth it.  Overall, it makes usage of the language less complex in practice.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 8:06 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 5:33 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 5:21 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; :-( I&#39;m worried about increasing the size of the language this much. I really want to be able to say &quot;behaviors are just syntactic sugar for declaring accessors and storage, and then everything else behaves normally&quot;. This makes them another entirely orthogonal decl kind, like operators.<br>&gt;&gt; <br>&gt;&gt; I&#39;d prefer not to have a new decl as well, if that was the best choice. However, it&#39;s still just syntactic sugar for declaring accessors and storage.<br>&gt; <br>&gt; I think there’s value for users in being able to group and scope the components associated with a particular behavior, so IMO it’s worth it.  Overall, it makes usage of the language less complex in practice.<br>&gt; <br></p><p>+1<br></p><p>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 6:06 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 5:33 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 5:21 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; :-( I&#39;m worried about increasing the size of the language this much. I really want to be able to say &quot;behaviors are just syntactic sugar for declaring accessors and storage, and then everything else behaves normally&quot;. This makes them another entirely orthogonal decl kind, like operators.<br>&gt;&gt; <br>&gt;&gt; I&#39;d prefer not to have a new decl as well, if that was the best choice. However, it&#39;s still just syntactic sugar for declaring accessors and storage.<br>&gt; <br>&gt; I think there’s value for users in being able to group and scope the components associated with a particular behavior, so IMO it’s worth it.  Overall, it makes usage of the language less complex in practice.<br></p><p>I tend to agree.  There is definite value in having really independent things scoped out and cordoned off in their own areas.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>December 22, 2015 at 01:00:00am</p></header><div class="content"><p>Really interesting thread, and great work on the proposal so far, Joe. I have some additional thoughts but I wanted to chime in with one thing first:<br></p><p>&gt; On Dec 22, 2015, at 12:08 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 21, 2015, at 6:06 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 5:33 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 21, 2015, at 5:21 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; :-( I&#39;m worried about increasing the size of the language this much. I really want to be able to say &quot;behaviors are just syntactic sugar for declaring accessors and storage, and then everything else behaves normally&quot;. This makes them another entirely orthogonal decl kind, like operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d prefer not to have a new decl as well, if that was the best choice. However, it&#39;s still just syntactic sugar for declaring accessors and storage.<br>&gt;&gt; <br>&gt;&gt; I think there’s value for users in being able to group and scope the components associated with a particular behavior, so IMO it’s worth it.  Overall, it makes usage of the language less complex in practice.<br>&gt; <br>&gt; I tend to agree.  There is definite value in having really independent things scoped out and cordoned off in their own areas.<br></p><p>Agreed. For instance, it makes it much easier for tooling to know something is a behavior if it can just look for a keyword, rather than having to infer it from use, or some function declaration pattern or something.<br></p><p>-Colin<br></p><p>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/d9bcb42f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 9:08 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 21, 2015, at 6:06 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 21, 2015, at 5:33 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 21, 2015, at 5:21 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; :-( I&#39;m worried about increasing the size of the language this much. I really want to be able to say &quot;behaviors are just syntactic sugar for declaring accessors and storage, and then everything else behaves normally&quot;. This makes them another entirely orthogonal decl kind, like operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d prefer not to have a new decl as well, if that was the best choice. However, it&#39;s still just syntactic sugar for declaring accessors and storage.<br>&gt;&gt; <br>&gt;&gt; I think there’s value for users in being able to group and scope the components associated with a particular behavior, so IMO it’s worth it.  Overall, it makes usage of the language less complex in practice.<br>&gt; <br>&gt; I tend to agree.  There is definite value in having really independent things scoped out and cordoned off in their own areas.<br></p><p>On balance I like it too. Going with a behavior decl opens some questions though:<br></p><p>- Can behaviors be extended?<br>- Can behaviors be resilient? One nice thing about a fragile behavior is that we can inline its storage, if any, directly into its containing type without having to instantiate metadata for a nominal type, as we would for a struct-based property implementation. A resilient behavior, however, would end up needing more or less the same metadata to encapsulate the layout of the behavior&#39;s state behind the resilience domain, weakening that benefit.<br>- Should behaviors be able to control their default visibility policy? As Brent and others pointed out, most behaviors are implementation details, but the few that make sense as API generally always want to be API, such as `resettable` or `KVOable`.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/92b47300/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>On Dec 22, 2015, at 9:08 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think there’s value for users in being able to group and scope the components associated with a particular behavior, so IMO it’s worth it.  Overall, it makes usage of the language less complex in practice.<br>&gt;&gt; <br>&gt;&gt; I tend to agree.  There is definite value in having really independent things scoped out and cordoned off in their own areas.<br>&gt; <br>&gt; On balance I like it too. Going with a behavior decl opens some questions though:<br>&gt; <br>&gt; - Can behaviors be extended?<br></p><p>From an implementation perspective, I’d prefer not.  From a user model perspective (which is what really matters :) we want to be able to add methods to them somehow.  I think it would be fine to require more boilerplate for this (e.g. the backing store for lazy is actually a struct, and that struct is what gets the extension) - so long as it doesn’t cause boilerplate on the client side.  You shouldn’t have to say myProperty.lazy.backingStore.clear(), just myProperty.lazy.clear().<br></p><p>I don’t know where that leaves us :-)<br></p><p>&gt; - Can behaviors be resilient? One nice thing about a fragile behavior is that we can inline its storage, if any, directly into its containing type without having to instantiate metadata for a nominal type, as we would for a struct-based property implementation. A resilient behavior, however, would end up needing more or less the same metadata to encapsulate the layout of the behavior&#39;s state behind the resilience domain, weakening that benefit.<br></p><p>I’d be fine with requiring an explicit struct to be defined inline in the behavior to get resilience.<br></p><p>&gt; - Should behaviors be able to control their default visibility policy? As Brent and others pointed out, most behaviors are implementation details, but the few that make sense as API generally always want to be API, such as `resettable` or `KVOable`.<br></p><p>I’d suggest defining them to be private by default, and allowing the &quot;var (public lazy)” sort of syntax.  After the basic proposal and model is done, we can then talk about adding a “public_by_default” trait to behavior to reduce boilerplate (if it is an issue in practice).<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/6f884278/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 22, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; You shouldn’t have to say myProperty.lazy.backingStore.clear(), just myProperty.lazy.clear().<br>&gt; <br>&gt; I don’t know where that leaves us :-)<br></p><p>I wonder if these should all just be flattened into the instance that owns the property. So instead of saying foo.myProperty.lazy.clear(), you just say foo.clearMyProperty() or some such. That approach isn&#39;t very principled, but it *is* very convenient.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 8:42 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; You shouldn’t have to say myProperty.lazy.backingStore.clear(), just myProperty.lazy.clear().<br>&gt;&gt; <br>&gt;&gt; I don’t know where that leaves us :-)<br>&gt; <br>&gt; I wonder if these should all just be flattened into the instance that owns the property. So instead of saying foo.myProperty.lazy.clear(), you just say foo.clearMyProperty() or some such. That approach isn&#39;t very principled, but it *is* very convenient.<br></p><p>I agree that &quot;myProperty.clear()&quot; is very appealing, but it has the potential to be confusing when behavior methods are shadowed by members of the front-facing property. You&#39;d still need a way to unambiguously refer to behavior methods when they&#39;re shadowed too.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 23, 2015 at 11:00:00pm</p></header><div class="content"><p>There was a proposal as well to get property accessor method access directly, without referencing the function. <br></p><p>If you had obj#myProperty.get() -&gt; Val and obj#myProperty.set(_:Val) as functions (# syntax being a placeholder more than a proposal) perhaps then you could also have something like obj#myProperty.clear()<br></p><p>-DW<br></p><p>&gt; On Dec 23, 2015, at 10:07 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that &quot;myProperty.clear()&quot; is very appealing, but it has the potential to be confusing when behavior methods are shadowed by members of the front-facing property. You&#39;d still need a way to unambiguously refer to behavior methods when they&#39;re shadowed too.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/7baf5696/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 26, 2015 at 08:00:00am</p></header><div class="content"><p>If a Property Behavior is &#39;officially&#39; defined as a syntax sugar:<br></p><p>    var _name = ...<br>    var name: Type {<br>        get { return _name }<br>        set { _name = ... }<br>    }<br></p><p>Then allow:<br></p><p>    _name.behaviorMember ...<br></p><p>This is simple to implement, understand, and document. <br></p><p>Sent from my iPad<br></p><p>&gt; On 24 Dec 2015, at 5:30 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There was a proposal as well to get property accessor method access directly, without referencing the function. <br>&gt; <br>&gt; If you had obj#myProperty.get() -&gt; Val and obj#myProperty.set(_:Val) as functions (# syntax being a placeholder more than a proposal) perhaps then you could also have something like obj#myProperty.clear()<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 10:07 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that &quot;myProperty.clear()&quot; is very appealing, but it has the potential to be confusing when behavior methods are shadowed by members of the front-facing property. You&#39;d still need a way to unambiguously refer to behavior methods when they&#39;re shadowed too.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/5c0fbd02/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>I have been thinking further about the compiler diagnostics for `delayed`.  It might be interesting to consider making various compiler diagnostics available to any behavior rather than having a special case in the compiler for `delayed`.  <br></p><p>Here are some examples:<br></p><p>* By default properties with a behavior must be initialized in phase one just like normal properties.<br>* Behaviors can opt-in to a relaxed requirement that the property must be initialized *somewhere* in the initializer, but not necessarily phase one.  Delayed would opt-in to this.<br>* Behaviors can opt-in to a requirement that the property *cannot* be set outside of an initializer.  Delayed would opt-in to this.<br>* Behaviors can opt-in to a requirement that the property *cannot* be set anywhere.  A variation of lazy might opt-in to this.  (clear would still work as it is part of the implementation of lazy)<br></p><p>Allowing behaviors to specify diagnostic behavior like this would probably be *possible* in the ad-hoc proposal.  However, it would probably be a lot more clear and elegant if we adopt the “behavior declaration” idea.<br></p><p>Matthew<br></p><p><br>&gt; On Dec 21, 2015, at 11:23 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I played around a bit with the idea of a special behavior declaration. I think it feels a lot nicer, though it also feels like a much bigger language change if we go this route. Inside the declaration, you need to specify:<br>&gt; - what accessors the behavior supports, to be implemented by properties using the behavior,<br>&gt; - if the behavior controls storage, what that storage is, and what initialization logic it requires,<br>&gt; - if the behavior requires an initializer, and whether that initializer is used eagerly at property initialization or deferred to later, and<br>&gt; - what operations the behavior offers, if any.<br>&gt; <br>&gt; Here&#39;s a quick sketch of how a behavior declaration could look. As a strawman, I&#39;ll use &#39;var behavior&#39; as the introducer for a property behavior (leaving the door open to &#39;func behavior&#39;, &#39;struct behavior&#39;, etc. in the possible future). If you were going to reinvent computed properties from whole cloth, that might look like this:<br>&gt; <br>&gt; var behavior computed&lt;T&gt; {<br>&gt;   // A computed property requires a `get` and `set` accessor.<br>&gt;   accessor get() -&gt; T<br>&gt;   accessor set(newValue: T)<br>&gt; <br>&gt;   // Accessors for the property<br>&gt;   get { return get() }<br>&gt;   set { set(newValue) }<br>&gt; }<br>&gt; <br>&gt; lazy might look something like this:<br>&gt; <br>&gt; var behavior lazy&lt;T&gt; {<br>&gt;   // lazy requires an initializer expression, but it isn&#39;t<br>&gt;   // used until after object initialization.<br>&gt;   deferred initializer: T<br>&gt; <br>&gt;   // The optional storage for the property.<br>&gt;   var value: T?<br>&gt; <br>&gt;   // Initialize the storage to nil.<br>&gt;   init() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; <br>&gt;   // Accessors for the property.<br>&gt;   mutating get {<br>&gt;     if let value = value {<br>&gt;       return value<br>&gt;     }<br>&gt;     // `initializer` is implicitly bound to the initializer expr as a<br>&gt;     // `@noescape () -&gt; T` within the behavior&#39;s members.<br>&gt;     let initialValue = initializer()<br>&gt;     value = initialValue<br>&gt;     return initialValue<br>&gt;   }<br>&gt; <br>&gt;   set {<br>&gt;     value = newValue<br>&gt;   }<br>&gt; <br>&gt;   // clear() operation for the behavior.<br>&gt;   mutating func clear() {<br>&gt;     value = nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Some behaviors like `lazy` and `resettable` want to take control of the storage to manage their semantics, but many behaviors are adapters independent of how the underlying behavior behaves. These kinds of behavior are easy to compose with other behaviors and to override base class properties with. You could use inheritance-like syntax to indicate a &quot;wrapping&quot; behavior like this, and commandeer `super` to refer to the underlying property. For instance, `synchronized`:<br>&gt; <br>&gt; var behavior synchronized&lt;T&gt;: T {<br>&gt;   get {<br>&gt;     return sync { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return sync { return super }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; or `observing` didSet/willSet:<br>&gt; <br>&gt; var behavior observing&lt;T&gt;: T {<br>&gt;   accessor willSet(oldValue: T, newValue: T) { }<br>&gt;   accessor didSet(oldValue: T, newValue: T) { }<br>&gt; <br>&gt;   get { return super }<br>&gt;   set {<br>&gt;     let oldValue = super<br>&gt;     willSet(oldValue, newValue)<br>&gt;     super = newValue<br>&gt;     didSet(oldValue, newValue)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; If you want to refer back to the containing `self`, we could support that too, and by treating behavior functions specially we should be able to maintain coherent semantics for backreferencing value types as well. Implementing `synchronized` with a per-object lock could look like this:<br>&gt; <br>&gt; var behavior synchronizedByObject&lt;T&gt;: T where Self: Synchronizable {<br>&gt;   get {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt;   set {<br>&gt;     return self.withLock { return super }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; (though the juxtaposed meanings of `super` and `self` here are weird together…we&#39;d probably want a better implicit binding name for the underlying property.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/7e31af96/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 09:00:00pm</p></header><div class="content"><p>Quite complex proposal… guess I&#39;ll read it a second time when I&#39;m less tired, but I have already one idea for the feature:<br>&gt; Syntax for accessing the backing property<br>&gt; <br>When I saw the examples, I wondered right away &quot;what if foo has an own property called runcible? How is the type modified to allow access to its backing property?&quot; (that was my first interpretation on &quot;foo.runcible&quot;)<br>I think all problems can be avoided without new keywords or a suffix with rarely used (or forbidden) character:<br>Just give the backing property for &quot;foo&quot; the name &quot;super.foo&quot;.<br>- Afaik this is safe, because you can&#39;t create a property that already exists in the superclass (I guess it works if the property is not visible…)<br>- It&#39;s quite intuitive to me, because super always bypasses the normal behavior of self (well, commonly it refers to the superclass, but &quot;bypass self&quot; is just more general than superclass).<br></p><p>May the force be with you<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/97d8ba2d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>Just to clarify a little, this proposal is (will be) addressed to 3.0?<br></p><p>Em qui, 17 de dez de 2015 às 15:41, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Hi everyone. Chris stole my thunder already—yeah, I&#39;ve been working on a<br>&gt; design for allowing properties to be extended with user-defined<br>&gt; delegates^W behaviors. Here&#39;s a draft proposal that I&#39;d like to open up<br>&gt; for broader discussion. Thanks for taking a look!<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/970451aa/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br></p><p>- Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>- I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>- I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br></p><p>Here&#39;s the revised proposal:<br></p><p>https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br></p><p>For reference, here&#39;s the previous iteration:<br></p><p>https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br></p><p>Thanks for taking a look!<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>January 13, 2016 at 05:00:00pm</p></header><div class="content"><p>For var [lazy] foo = 1738 how does the user or compiler know that foo, even<br>though it’s an Int, it has a property called `lazy` on it. And what happens<br>if that object type has a property named `lazy` already?<br></p><p>-Tal<br></p><p>On Wed, Jan 13, 2016 at 5:07 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks everyone for the first round of feedback on my behaviors proposal.<br>&gt; I&#39;ve revised it with the following changes:<br>&gt;<br>&gt; - Instead of relying on mapping behaviors to function or type member<br>&gt; lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration,<br>&gt; which declares the accessor and initializer requirements and provides the<br>&gt; storage and behavior methods of the property. I think this gives a clearer<br>&gt; design for authoring behaviors, and allows for a more efficient and<br>&gt; flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you<br>&gt; noted, it&#39;s better to tackle immutable computed properties more<br>&gt; holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square<br>&gt; brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring<br>&gt; &#39;var&#39; bindings, and also works with future candidates for behavior<br>&gt; decoration, particularly `subscript`.<br>&gt;<br>&gt; Here&#39;s the revised proposal:<br>&gt;<br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt;<br>&gt; For reference, here&#39;s the previous iteration:<br>&gt;<br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt;<br>&gt; Thanks for taking a look!<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/998315f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 2:37 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; For var [lazy] foo = 1738 how does the user or compiler know that foo, even though it’s an Int, it has a property called `lazy` on it.<br></p><p>If name lookup has visibility of the behaviors, it can handle them as a special case.<br></p><p>&gt; And what happens if that object type has a property named `lazy` already?<br></p><p>Good question. We can either overload the name and let type context sort it out, or consider an alternative syntax for accessing members.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>`var [lazy] foo = 123` maybe the accessor could be `foo.[lazy].clear()`<br></p><p>-Tal<br></p><p>On Wed, Jan 13, 2016 at 6:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 13, 2016, at 2:37 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; For var [lazy] foo = 1738 how does the user or compiler know that foo,<br>&gt; even though it’s an Int, it has a property called `lazy` on it.<br>&gt;<br>&gt; If name lookup has visibility of the behaviors, it can handle them as a<br>&gt; special case.<br>&gt;<br>&gt; &gt; And what happens if that object type has a property named `lazy` already?<br>&gt;<br>&gt; Good question. We can either overload the name and let type context sort<br>&gt; it out, or consider an alternative syntax for accessing members.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/08939dd1/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 13, 2016 at 07:00:00pm</p></header><div class="content"><p>I like it. A lot.<br></p><p>+1.<br></p><p>Charles<br></p><p>On 2016-01-13 17:07, Joe Groff via swift-evolution wrote:<br>&gt; Thanks everyone for the first round of feedback on my behaviors<br>&gt; proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member<br>&gt; lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39;<br>&gt; declaration, which declares the accessor and initializer requirements<br>&gt; and provides the storage and behavior methods of the property. I think<br>&gt; this gives a clearer design for authoring behaviors, and allows for a<br>&gt; more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of<br>&gt; you noted, it&#39;s better to tackle immutable computed properties more<br>&gt; holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to<br>&gt; square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with<br>&gt; destructuring &#39;var&#39; bindings, and also works with future candidates<br>&gt; for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Here&#39;s the revised proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; <br>&gt; For reference, here&#39;s the previous iteration:<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br></p><p>This iteration is a big improvement; the use of more syntax is a definite help. Some specific comments:<br></p><p>&gt; var behavior lazy&lt;Value&gt;: Value {<br></p><p>I&#39;m somewhat concerned that this looks like you&#39;re declaring a variable called &quot;behavior&quot;, but I do like that it keeps the opportunity open for us to add, say, `let` behaviors or `func` behaviors in a later version of Swift. `behavior var` doesn&#39;t read very fluidly, but it doesn&#39;t mislead you, either.<br></p><p>Also, why the `: Value`? Can that ever be anything but `: Value`? What does it mean if it is?<br></p><p>Also also, why the `&lt;Value&gt;`? There will always be exactly one generic type there, right? I get that you can dangle requirements off of it, but can&#39;t you do that by supporting a `where` clause?<br></p><p>	var behavior lazy {}<br>	var behavior NSCopying where Value: NSCopying {}<br></p><p>&gt;   private var value: Value? = nil<br></p><p>Should we actually force people to declare the `value` property? I can&#39;t think of many behaviors which won&#39;t need one. You can put the `base` directly on the behavior declaration (arguably it belongs there since the presence or absence of a base is definitely *not* an implementation detail), and if `: Value` is currently purposeless, well, now we have a reason for it: to declare the `value` property&#39;s type.<br></p><p>	var behavior lazy: Value? {<br>		deferred initializer: Value<br>		 get {<br>			if let value = value {<br>				return value<br>			}<br>			<br>			let initialValue = initializer<br>			value = initialValue<br>			return initialValue<br>		}<br>		set {<br>			value = newValue<br>		}<br>	}<br></p><p>While we&#39;re here, why does `initializer` have an explicit type? Can it be different from `Value`? What does it mean if it is?<br></p><p>&gt; Neither inline initializers nor init declaration bodies may reference self, since they will be executed during the initializing of a property&#39;s containing value.<br></p><p>This makes sense, but is there some opportunity for a second-phase initialization that runs when `self` is accessible? I can imagine behaviors using this to register themselves using a method provided by a protocol on `Self`. (Although perhaps it would be better to focus on exposing behaviors through reflection.)<br></p><p>&gt; For the same reason, an init also may not refer to the base property, if any<br></p><p><br>Why not? I would assume that behaviors are initialized from the inside out, and an eager-initialized property will need to initialize its base property&#39;s value. Or is there an implicit rule here that a behavior with a base property cannot take an initializer?<br></p><p>&gt; Inside a behavior declaration, self is implicitly bound to the value that contains the property instantiated using this behavior. For a freestanding property at global or local scope, this will be the empty tuple (), and for a static or class property, this will be the metatype. Within the behavior declaration, the type of self is abstract and represented by the implicit generic type parameter Self. Constraints can be placed on Self in the generic signature of the behavior, to make protocol members available on self:<br></p><p><br>This is handy, but I wonder if it&#39;s a good idea to make `self` refer to something else and then have an apparently anonymous context for all the variables and methods. It just has a really strange feel to it. What aspects of the behavior are captured by a closure? Can you safely dispatch_async() inside a `get`?<br></p><p>Relatedly: How first-class are behaviors? Can you assign `foo.bar.lazy` to a variable, or pass it as a parameter? Or can you pass a value along with its behavior?<br></p><p>	func consumeThing(inout thing: [resettable] Thing) {<br>		thing.use()<br>		thing.resettable.reset()<br>	}<br></p><p>&gt; Behaviors are private by default, unless declared with a higher visibility.<br></p><p><br>I think this is the right move 90% of the time, but I also think that there are certain behaviors which should be public (or as-visible-as-the-property) by default. For instance, consider this one:<br></p><p>	public var behavior observable&lt;Value&gt; {<br>		base var value: Value<br>		<br>		var observers: [ObserverIdentifier: (instance: Self, oldValue: Value, newValue: Value) -&gt; Void]<br>		<br>		public func addObserver(observer: (instance: Self, oldValue: Value, newValue: Value) -&gt; Void) -&gt; ObserverIdentifier {<br>			let identifier = ObserverIdentifier()<br>			observers[identifier] = observer<br>			return identifier<br>		}<br>		public func removeObserverWithIdentifier(identifier: ObserverIdentifier) {<br>			observers[identifier] = nil<br>		}<br>		<br>		get { return value }<br>		set {<br>			let oldValue = value<br>			value = newValue<br>			for observer in observers.values {<br>				observer(self, oldValue, newValue)<br>			}<br>		}<br>	}<br></p><p>It&#39;s very likely that a public property on a public type will want this behavior to be public too. On the other hand, it&#39;s also a relatively niche case and might not be worth complicating the model.<br></p><p>&gt; Behavior extensions can however constrain the generic parameters of the behavior, including Self, to make the members available only on a subset of property and container types.<br></p><p>It might also be useful to allow extensions to provide constrained default accessor implementations:<br></p><p>	public var behavior changeObserved&lt;Value&gt;: Value {<br>	  base var value: Value<br>	  <br>          accessor detectChange(oldValue: Value) -&gt; Bool<br>	  mutating accessor didChange(oldValue: Value) { }<br>	<br>	  get {<br>	    return value<br>	  }<br>	  set {<br>	    let oldValue = value<br>	    value = newValue<br>	    if detectChange(oldValue) {<br>	      didChange(oldValue)<br>	    }<br>	  }<br>	}<br></p><p>	extension changeObserved where Value: Equatable {<br>	  accessor detectChange(oldValue: Value) -&gt; Bool {<br>	    return value != oldValue<br>	  }<br>	}<br></p><p>&gt; The proposal suggests x.behaviorName for accessing the underlying backing property of var (behaviorName) x. The main disadvantage of this is that it complicates name lookup, which must be aware of the behavior in order to resolve the name, and is potentially ambiguous, since the behavior name could of course also be the name of a member of the property&#39;s type.<br></p><p><br>I suggest using `foo.bar[lazy]` as the property access syntax. This echoes the use of square brackets to declare properties, is less likely to look like it conflicts with a valid operation (most types have properties, but very few have subscriptors), and should never be ambiguous to the compiler unless you decide to make a variable with the name of a behavior and then subscript a data structure with it.<br></p><p>If you cared more about ambiguity than appearance, you could even reverse the order and make it `type.[lazy]bar`, but good lord is that ugly.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 5:04 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt; <br>&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; This iteration is a big improvement; the use of more syntax is a definite help. Some specific comments:<br>&gt; <br>&gt;&gt; var behavior lazy&lt;Value&gt;: Value {<br>&gt; <br>&gt; I&#39;m somewhat concerned that this looks like you&#39;re declaring a variable called &quot;behavior&quot;, but I do like that it keeps the opportunity open for us to add, say, `let` behaviors or `func` behaviors in a later version of Swift. `behavior var` doesn&#39;t read very fluidly, but it doesn&#39;t mislead you, either.<br>&gt; <br>&gt; Also, why the `: Value`? Can that ever be anything but `: Value`? What does it mean if it is?<br>&gt; <br>&gt; Also also, why the `&lt;Value&gt;`? There will always be exactly one generic type there, right? I get that you can dangle requirements off of it, but can&#39;t you do that by supporting a `where` clause?<br>&gt; <br>&gt; 	var behavior lazy {}<br>&gt; 	var behavior NSCopying where Value: NSCopying {}<br></p><p>You might want to constrain the behavior to apply only to some subset of a generic type:<br></p><p>var behavior optionalsOnly&lt;Value&gt;: Value? { ... }<br>var behavior dictionariesOfStringsOnly&lt;Key&gt;: Dictionary&lt;Key, String&gt; { ... }<br></p><p>I agree that an unconstrained type is likely to be the 95% case in practice. Maybe an approach more like what we do with generic extensions is appropriate; we could say that `Value` and `Self` are both implicit generic parameters, and use a freestanding `where` clause to constrain them.<br></p><p>&gt;&gt;  private var value: Value? = nil<br>&gt; <br>&gt; Should we actually force people to declare the `value` property? I can&#39;t think of many behaviors which won&#39;t need one. You can put the `base` directly on the behavior declaration (arguably it belongs there since the presence or absence of a base is definitely *not* an implementation detail), and if `: Value` is currently purposeless, well, now we have a reason for it: to declare the `value` property&#39;s type.<br>&gt; <br>&gt; 	var behavior lazy: Value? {<br>&gt; 		deferred initializer: Value<br>&gt; 		 get {<br>&gt; 			if let value = value {<br>&gt; 				return value<br>&gt; 			}<br>&gt; 			<br>&gt; 			let initialValue = initializer<br>&gt; 			value = initialValue<br>&gt; 			return initialValue<br>&gt; 		}<br>&gt; 		set {<br>&gt; 			value = newValue<br>&gt; 		}<br>&gt; 	}<br></p><p>That&#39;s a bit fiddly. `lazy` has optional storage, but produces a property of non-optional type, and other behaviors can reasonably have different (or no) storage needs. I feel like the storage should be explicitly declared.<br></p><p>&gt; <br>&gt; While we&#39;re here, why does `initializer` have an explicit type? Can it be different from `Value`? What does it mean if it is?<br></p><p>As proposed, no, but it might be possible to relax that. My concern with `deferred initializer` floating on its own is that it looked weird. To my eyes, `initializer: T` makes it clear that something named `initializer` of type `T` is being bound in the behavior&#39;s scope.<br></p><p>&gt; <br>&gt;&gt; Neither inline initializers nor init declaration bodies may reference self, since they will be executed during the initializing of a property&#39;s containing value.<br>&gt; <br>&gt; This makes sense, but is there some opportunity for a second-phase initialization that runs when `self` is accessible? I can imagine behaviors using this to register themselves using a method provided by a protocol on `Self`. (Although perhaps it would be better to focus on exposing behaviors through reflection.)<br>&gt; <br>&gt;&gt; For the same reason, an init also may not refer to the base property, if any<br>&gt; <br>&gt; <br>&gt; Why not? I would assume that behaviors are initialized from the inside out, and an eager-initialized property will need to initialize its base property&#39;s value. Or is there an implicit rule here that a behavior with a base property cannot take an initializer?<br></p><p>The base property is out of the current behavior implementation&#39;s control, since it could be a `super` property or the result of another behavior&#39;s instantiation. In the `super` case, the `base` property&#39;s storage won&#39;t be initialized until later when super.init is invoked, and in the behavior composition case, the `base` property&#39;s initialization is in the prior behavior&#39;s hands.<br></p><p>&gt; <br>&gt;&gt; Inside a behavior declaration, self is implicitly bound to the value that contains the property instantiated using this behavior. For a freestanding property at global or local scope, this will be the empty tuple (), and for a static or class property, this will be the metatype. Within the behavior declaration, the type of self is abstract and represented by the implicit generic type parameter Self. Constraints can be placed on Self in the generic signature of the behavior, to make protocol members available on self:<br>&gt; <br>&gt; <br>&gt; This is handy, but I wonder if it&#39;s a good idea to make `self` refer to something else and then have an apparently anonymous context for all the variables and methods. It just has a really strange feel to it. What aspects of the behavior are captured by a closure? Can you safely dispatch_async() inside a `get`?<br></p><p>Capture is tricky; thanks for bringing it up, since I hadn&#39;t thought of it. As I see it being implemented: in a mutating context, `self` is inout, and the behavior&#39;s storage always has to be implicitly projected from `self` in order to avoid overlapping `inout` references to self and the behavior storage. Closures would have to capture a shadow copy of `self`, giving the often unexpected behavior you see with captured `inout` parameters today losing attachment to their original argument after the `inout` parameter returns. In nonmutating contexts, everything&#39;s immutable, so `dispatch_async` can safely capture the minimal state referenced from within a `get`.<br></p><p>&gt; Relatedly: How first-class are behaviors? Can you assign `foo.bar.lazy` to a variable, or pass it as a parameter? Or can you pass a value along with its behavior?<br>&gt; <br>&gt; 	func consumeThing(inout thing: [resettable] Thing) {<br>&gt; 		thing.use()<br>&gt; 		thing.resettable.reset()<br>&gt; 	}<br></p><p>That&#39;s an interesting idea; I think we could add something like that later if it&#39;s useful. It&#39;s my intent in this proposal to avoid treating behaviors as first-class types and keep them mostly instantiation-based, in order to avoid the metadata instantiation overhead of a type-based approach. That would mean that `bar.lazy` isn&#39;t really a first-class entity.<br></p><p>&gt;&gt; Behaviors are private by default, unless declared with a higher visibility.<br>&gt; <br>&gt; <br>&gt; I think this is the right move 90% of the time, but I also think that there are certain behaviors which should be public (or as-visible-as-the-property) by default. For instance, consider this one:<br>&gt; <br>&gt; 	public var behavior observable&lt;Value&gt; {<br>&gt; 		base var value: Value<br>&gt; 		<br>&gt; 		var observers: [ObserverIdentifier: (instance: Self, oldValue: Value, newValue: Value) -&gt; Void]<br>&gt; 		<br>&gt; 		public func addObserver(observer: (instance: Self, oldValue: Value, newValue: Value) -&gt; Void) -&gt; ObserverIdentifier {<br>&gt; 			let identifier = ObserverIdentifier()<br>&gt; 			observers[identifier] = observer<br>&gt; 			return identifier<br>&gt; 		}<br>&gt; 		public func removeObserverWithIdentifier(identifier: ObserverIdentifier) {<br>&gt; 			observers[identifier] = nil<br>&gt; 		}<br>&gt; 		<br>&gt; 		get { return value }<br>&gt; 		set {<br>&gt; 			let oldValue = value<br>&gt; 			value = newValue<br>&gt; 			for observer in observers.values {<br>&gt; 				observer(self, oldValue, newValue)<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; It&#39;s very likely that a public property on a public type will want this behavior to be public too. On the other hand, it&#39;s also a relatively niche case and might not be worth complicating the model.<br></p><p>I agree. It might be interesting for behaviors to specify their preferred visibility policy.<br></p><p>&gt; <br>&gt;&gt; Behavior extensions can however constrain the generic parameters of the behavior, including Self, to make the members available only on a subset of property and container types.<br>&gt; <br>&gt; It might also be useful to allow extensions to provide constrained default accessor implementations:<br>&gt; <br>&gt; 	public var behavior changeObserved&lt;Value&gt;: Value {<br>&gt; 	  base var value: Value<br>&gt; 	  <br>&gt;          accessor detectChange(oldValue: Value) -&gt; Bool<br>&gt; 	  mutating accessor didChange(oldValue: Value) { }<br>&gt; 	<br>&gt; 	  get {<br>&gt; 	    return value<br>&gt; 	  }<br>&gt; 	  set {<br>&gt; 	    let oldValue = value<br>&gt; 	    value = newValue<br>&gt; 	    if detectChange(oldValue) {<br>&gt; 	      didChange(oldValue)<br>&gt; 	    }<br>&gt; 	  }<br>&gt; 	}<br>&gt; <br>&gt; 	extension changeObserved where Value: Equatable {<br>&gt; 	  accessor detectChange(oldValue: Value) -&gt; Bool {<br>&gt; 	    return value != oldValue<br>&gt; 	  }<br>&gt; 	}<br></p><p>Interesting point. You can do that with protocol extensions.<br></p><p>&gt; <br>&gt;&gt; The proposal suggests x.behaviorName for accessing the underlying backing property of var (behaviorName) x. The main disadvantage of this is that it complicates name lookup, which must be aware of the behavior in order to resolve the name, and is potentially ambiguous, since the behavior name could of course also be the name of a member of the property&#39;s type.<br>&gt; <br>&gt; <br>&gt; I suggest using `foo.bar[lazy]` as the property access syntax. This echoes the use of square brackets to declare properties, is less likely to look like it conflicts with a valid operation (most types have properties, but very few have subscriptors), and should never be ambiguous to the compiler unless you decide to make a variable with the name of a behavior and then subscript a data structure with it.<br>&gt; <br>&gt; If you cared more about ambiguity than appearance, you could even reverse the order and make it `type.[lazy]bar`, but good lord is that ugly.<br></p><p>Yeah, I got a similar suggestion from Patrick Smith on Twitter. I kinda like it; it echoes the declaration syntax.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 6:02 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Relatedly: How first-class are behaviors? Can you assign `foo.bar.lazy` to a variable, or pass it as a parameter? Or can you pass a value along with its behavior?<br>&gt;&gt; <br>&gt;&gt; 	func consumeThing(inout thing: [resettable] Thing) {<br>&gt;&gt; 		thing.use()<br>&gt;&gt; 		thing.resettable.reset()<br>&gt;&gt; 	}<br>&gt; <br>&gt; That&#39;s an interesting idea; I think we could add something like that later if it&#39;s useful. It&#39;s my intent in this proposal to avoid treating behaviors as first-class types and keep them mostly instantiation-based, in order to avoid the metadata instantiation overhead of a type-based approach. That would mean that `bar.lazy` isn&#39;t really a first-class entity.<br></p><p>Random point, if bar.lazy isn’t a first class thing, then that reinforces Talin’s syntax idea of bar.[lazy].reset() as the syntax to operate on the behavior.  It would be nice to move towards a model where all simply-dotted things are curryable.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 9:35 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 6:02 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Relatedly: How first-class are behaviors? Can you assign `foo.bar.lazy` to a variable, or pass it as a parameter? Or can you pass a value along with its behavior?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func consumeThing(inout thing: [resettable] Thing) {<br>&gt;&gt;&gt; 		thing.use()<br>&gt;&gt;&gt; 		thing.resettable.reset()<br>&gt;&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; That&#39;s an interesting idea; I think we could add something like that later if it&#39;s useful. It&#39;s my intent in this proposal to avoid treating behaviors as first-class types and keep them mostly instantiation-based, in order to avoid the metadata instantiation overhead of a type-based approach. That would mean that `bar.lazy` isn&#39;t really a first-class entity.<br>&gt; <br>&gt; Random point, if bar.lazy isn’t a first class thing, then that reinforces Talin’s syntax idea of bar.[lazy].reset() as the syntax to operate on the behavior.  It would be nice to move towards a model where all simply-dotted things are curryable.<br></p><p>Sorry, I meant Tal Atlas’ idea.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;&gt; Also, why the `: Value`? Can that ever be anything but `: Value`? What does it mean if it is?<br>&gt;&gt; <br>&gt;&gt; Also also, why the `&lt;Value&gt;`? There will always be exactly one generic type there, right? I get that you can dangle requirements off of it, but can&#39;t you do that by supporting a `where` clause?<br>&gt; <br>&gt; You might want to constrain the behavior to apply only to some subset of a generic type:<br>&gt; <br>&gt; var behavior optionalsOnly&lt;Value&gt;: Value? { ... }<br>&gt; var behavior dictionariesOfStringsOnly&lt;Key&gt;: Dictionary&lt;Key, String&gt; { ... }<br></p><p>Ah, so the type on the right side of the colon is the allowable variable type? That&#39;s a pretty handy feature. Could use a little more explanation, though. :^)<br></p><p>&gt; I agree that an unconstrained type is likely to be the 95% case in practice. Maybe an approach more like what we do with generic extensions is appropriate; we could say that `Value` and `Self` are both implicit generic parameters, and use a freestanding `where` clause to constrain them.<br></p><p>No, your way is probably better. For instance, I think it&#39;s probably more useful for `optionalOnly`&#39;s `Value` type to be the unwrapped type.<br></p><p>&gt;&gt; Should we actually force people to declare the `value` property?<br>&gt; <br>&gt; That&#39;s a bit fiddly. `lazy` has optional storage, but produces a property of non-optional type, and other behaviors can reasonably have different (or no) storage needs. I feel like the storage should be explicitly declared.<br></p><p>That&#39;s fair.<br></p><p>&gt;&gt; While we&#39;re here, why does `initializer` have an explicit type? Can it be different from `Value`? What does it mean if it is?<br>&gt; <br>&gt; As proposed, no, but it might be possible to relax that. My concern with `deferred initializer` floating on its own is that it looked weird. To my eyes, `initializer: T` makes it clear that something named `initializer` of type `T` is being bound in the behavior&#39;s scope.<br></p><p>It does look a little weird, but it has precedent in, for instance, `associativity` declarations.<br></p><p>I feel like there ought to be a way to build this part out of something that already exists. Perhaps a deferred initializer is just one with an autoclosure?<br></p><p>	public var behavior resettable&lt;Value&gt;: Value {<br>	  initializer: Value<br>	  ...<br>	}<br>	<br>	var behavior lazy&lt;Value&gt;: Value {<br>	  initializer: @autoclosure Void -&gt; Value<br>	  ...<br>	}<br>	<br>	public var behavior delayedMutable&lt;Value&gt;: Value {<br>	  // No initializer line, so it doesn&#39;t accept an initializer<br>	  ...<br>	}<br></p><p>Maybe it should be a `var` or `let` property, and it just has a specific name. That might be a little odd, though.<br></p><p>&gt;&gt; Why not? I would assume that behaviors are initialized from the inside out, and an eager-initialized property will need to initialize its base property&#39;s value. Or is there an implicit rule here that a behavior with a base property cannot take an initializer?<br>&gt; <br>&gt; The base property is out of the current behavior implementation&#39;s control, since it could be a `super` property or the result of another behavior&#39;s instantiation. In the `super` case, the `base` property&#39;s storage won&#39;t be initialized until later when super.init is invoked, and in the behavior composition case, the `base` property&#39;s initialization is in the prior behavior&#39;s hands.<br></p><p>Ooh, that&#39;s a good point about overrides.<br></p><p>Do you think it makes sense to allow non-base properties to accept initializers? If so, what does it mean? What happens if one behavior wants deferred and another wants eager?<br></p><p>&gt; Capture is tricky; thanks for bringing it up, since I hadn&#39;t thought of it. As I see it being implemented: in a mutating context, `self` is inout, and the behavior&#39;s storage always has to be implicitly projected from `self` in order to avoid overlapping `inout` references to self and the behavior storage. Closures would have to capture a shadow copy of `self`, giving the often unexpected behavior you see with captured `inout` parameters today losing attachment to their original argument after the `inout` parameter returns. In nonmutating contexts, everything&#39;s immutable, so `dispatch_async` can safely capture the minimal state referenced from within a `get`.<br></p><p>That&#39;s not the greatest behavior, but it&#39;s probably the best you can do.<br></p><p>If Self is a reference type, will capturing the behavior hold a strong reference to `self`? I assume that in that scenario, it will, and then assigning to the behavior&#39;s properties *will* work properly.<br></p><p>&gt;&gt; Relatedly: How first-class are behaviors? Can you assign `foo.bar.lazy` to a variable, or pass it as a parameter? Or can you pass a value along with its behavior?<br>&gt;&gt; <br>&gt;&gt; 	func consumeThing(inout thing: [resettable] Thing) {<br>&gt;&gt; 		thing.use()<br>&gt;&gt; 		thing.resettable.reset()<br>&gt;&gt; 	}<br>&gt; <br>&gt; That&#39;s an interesting idea; I think we could add something like that later if it&#39;s useful. It&#39;s my intent in this proposal to avoid treating behaviors as first-class types and keep them mostly instantiation-based, in order to avoid the metadata instantiation overhead of a type-based approach. That would mean that `bar.lazy` isn&#39;t really a first-class entity.<br></p><p>Fair enough. It&#39;s certainly not so critical that we need to stop the show until we have it.<br></p><p>One more thing: should there be a way to pass arbitrary data, rather than initializers or accessors, into a behavior? For instance, it would be nice if you could do something like:<br></p><p>	var behavior backedByJSON&lt;Value: JSONRepresentable where Self: JSONObjectRepresentable&gt;: Value {<br>		var key: String<br>		<br>		init(key: String) {<br>			backedByJSON.key = key<br>		}<br>		<br>		get {<br>			return Value(JSON: self.JSON[key])<br>		}<br>		set {<br>			self.JSON[key] = newValue.JSON<br>		}<br>	}<br>	<br>	struct User: JSONObjectRepresentable {<br>		var JSON: [String: JSONType]<br>		<br>		var [backedByJSON(key: &quot;id&quot;)] ID: Int<br>		var [backedByJSON(key: &quot;name&quot;)] name: String<br>		<br>		var [backedByJSON(key: &quot;posts&quot;)] posts: [Post]<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 9:38 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Also, why the `: Value`? Can that ever be anything but `: Value`? What does it mean if it is?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also also, why the `&lt;Value&gt;`? There will always be exactly one generic type there, right? I get that you can dangle requirements off of it, but can&#39;t you do that by supporting a `where` clause?<br>&gt;&gt; <br>&gt;&gt; You might want to constrain the behavior to apply only to some subset of a generic type:<br>&gt;&gt; <br>&gt;&gt; var behavior optionalsOnly&lt;Value&gt;: Value? { ... }<br>&gt;&gt; var behavior dictionariesOfStringsOnly&lt;Key&gt;: Dictionary&lt;Key, String&gt; { ... }<br>&gt; <br>&gt; Ah, so the type on the right side of the colon is the allowable variable type? That&#39;s a pretty handy feature. Could use a little more explanation, though. :^)<br>&gt; <br>&gt;&gt; I agree that an unconstrained type is likely to be the 95% case in practice. Maybe an approach more like what we do with generic extensions is appropriate; we could say that `Value` and `Self` are both implicit generic parameters, and use a freestanding `where` clause to constrain them.<br>&gt; <br>&gt; No, your way is probably better. For instance, I think it&#39;s probably more useful for `optionalOnly`&#39;s `Value` type to be the unwrapped type.<br>&gt; <br>&gt;&gt;&gt; Should we actually force people to declare the `value` property?<br>&gt;&gt; <br>&gt;&gt; That&#39;s a bit fiddly. `lazy` has optional storage, but produces a property of non-optional type, and other behaviors can reasonably have different (or no) storage needs. I feel like the storage should be explicitly declared.<br>&gt; <br>&gt; That&#39;s fair.<br>&gt; <br>&gt;&gt;&gt; While we&#39;re here, why does `initializer` have an explicit type? Can it be different from `Value`? What does it mean if it is?<br>&gt;&gt; <br>&gt;&gt; As proposed, no, but it might be possible to relax that. My concern with `deferred initializer` floating on its own is that it looked weird. To my eyes, `initializer: T` makes it clear that something named `initializer` of type `T` is being bound in the behavior&#39;s scope.<br>&gt; <br>&gt; It does look a little weird, but it has precedent in, for instance, `associativity` declarations.<br>&gt; <br>&gt; I feel like there ought to be a way to build this part out of something that already exists. Perhaps a deferred initializer is just one with an autoclosure?<br>&gt; <br>&gt; 	public var behavior resettable&lt;Value&gt;: Value {<br>&gt; 	  initializer: Value<br>&gt; 	  ...<br>&gt; 	}<br>&gt; 	<br>&gt; 	var behavior lazy&lt;Value&gt;: Value {<br>&gt; 	  initializer: @autoclosure Void -&gt; Value<br>&gt; 	  ...<br>&gt; 	}<br>&gt; 	<br>&gt; 	public var behavior delayedMutable&lt;Value&gt;: Value {<br>&gt; 	  // No initializer line, so it doesn&#39;t accept an initializer<br>&gt; 	  ...<br>&gt; 	}<br>&gt; <br>&gt; Maybe it should be a `var` or `let` property, and it just has a specific name. That might be a little odd, though.<br></p><p>@autoclosure instead of `deferred` is an interesting idea. Also, as I mentioned to Felix, if we didn&#39;t have a way to bind the initializer, the same functionality could be achieved using custom accessors, at the loss of some sugar. If that&#39;s acceptable, it would greatly simplify the proposal to leave out the ability to hijack the initializer.<br></p><p>&gt; <br>&gt;&gt;&gt; Why not? I would assume that behaviors are initialized from the inside out, and an eager-initialized property will need to initialize its base property&#39;s value. Or is there an implicit rule here that a behavior with a base property cannot take an initializer?<br>&gt;&gt; <br>&gt;&gt; The base property is out of the current behavior implementation&#39;s control, since it could be a `super` property or the result of another behavior&#39;s instantiation. In the `super` case, the `base` property&#39;s storage won&#39;t be initialized until later when super.init is invoked, and in the behavior composition case, the `base` property&#39;s initialization is in the prior behavior&#39;s hands.<br>&gt; <br>&gt; Ooh, that&#39;s a good point about overrides.<br>&gt; <br>&gt; Do you think it makes sense to allow non-base properties to accept initializers? If so, what does it mean? What happens if one behavior wants deferred and another wants eager?<br></p><p>I think, fundamentally, only the innermost behavior can control initialization. If you innermost behavior itself has a base, then there&#39;s essentially an implicit &quot;stored&quot; behavior nested within it, which has the standard stored property initialization behavior.<br></p><p>&gt; <br>&gt;&gt; Capture is tricky; thanks for bringing it up, since I hadn&#39;t thought of it. As I see it being implemented: in a mutating context, `self` is inout, and the behavior&#39;s storage always has to be implicitly projected from `self` in order to avoid overlapping `inout` references to self and the behavior storage. Closures would have to capture a shadow copy of `self`, giving the often unexpected behavior you see with captured `inout` parameters today losing attachment to their original argument after the `inout` parameter returns. In nonmutating contexts, everything&#39;s immutable, so `dispatch_async` can safely capture the minimal state referenced from within a `get`.<br>&gt; <br>&gt; That&#39;s not the greatest behavior, but it&#39;s probably the best you can do.<br>&gt; <br>&gt; If Self is a reference type, will capturing the behavior hold a strong reference to `self`? I assume that in that scenario, it will, and then assigning to the behavior&#39;s properties *will* work properly.<br></p><p>If Self is class-constrained, we could always strongly capture it. Otherwise, we&#39;d conservatively only be able to do so in nonmutating contexts.<br></p><p>&gt; <br>&gt;&gt;&gt; Relatedly: How first-class are behaviors? Can you assign `foo.bar.lazy` to a variable, or pass it as a parameter? Or can you pass a value along with its behavior?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func consumeThing(inout thing: [resettable] Thing) {<br>&gt;&gt;&gt; 		thing.use()<br>&gt;&gt;&gt; 		thing.resettable.reset()<br>&gt;&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; That&#39;s an interesting idea; I think we could add something like that later if it&#39;s useful. It&#39;s my intent in this proposal to avoid treating behaviors as first-class types and keep them mostly instantiation-based, in order to avoid the metadata instantiation overhead of a type-based approach. That would mean that `bar.lazy` isn&#39;t really a first-class entity.<br>&gt; <br>&gt; Fair enough. It&#39;s certainly not so critical that we need to stop the show until we have it.<br>&gt; <br>&gt; One more thing: should there be a way to pass arbitrary data, rather than initializers or accessors, into a behavior? For instance, it would be nice if you could do something like:<br>&gt; <br>&gt; 	var behavior backedByJSON&lt;Value: JSONRepresentable where Self: JSONObjectRepresentable&gt;: Value {<br>&gt; 		var key: String<br>&gt; 		<br>&gt; 		init(key: String) {<br>&gt; 			backedByJSON.key = key<br>&gt; 		}<br>&gt; 		<br>&gt; 		get {<br>&gt; 			return Value(JSON: self.JSON[key])<br>&gt; 		}<br>&gt; 		set {<br>&gt; 			self.JSON[key] = newValue.JSON<br>&gt; 		}<br>&gt; 	}<br>&gt; 	<br>&gt; 	struct User: JSONObjectRepresentable {<br>&gt; 		var JSON: [String: JSONType]<br>&gt; 		<br>&gt; 		var [backedByJSON(key: &quot;id&quot;)] ID: Int<br>&gt; 		var [backedByJSON(key: &quot;name&quot;)] name: String<br>&gt; 		<br>&gt; 		var [backedByJSON(key: &quot;posts&quot;)] posts: [Post]<br>&gt; 	}<br></p><p><br>That parameterization could be achieved, somewhat more verbosely, using an accessor &#39;key { return &quot;id&quot; }&#39;. If behaviors could be parameterized in-line, I wouldn&#39;t do it by passing the params to `init`, since that again imposes the need for per-instance storage to carry `key` from the behavior initialization to the property implementation.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 14, 2016, at 10:33 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That parameterization could be achieved, somewhat more verbosely, using an accessor &#39;key { return &quot;id&quot; }&#39;. If behaviors could be parameterized in-line, I wouldn&#39;t do it by passing the params to `init`, since that again imposes the need for per-instance storage to carry `key` from the behavior initialization to the property implementation.<br></p><p>Thinking about this more, maybe the need for instance storage could be avoided by letting behaviors declare `static` properties. It&#39;s likely that behavior instantiations will need some global data structure, at least in debug builds, to collect their parameterizations from property decls using the behavior. It&#39;d make sense to put some of that global structure under the behavior&#39;s control. We&#39;d still potentially need a separate `static init()` to initialize that storage once per declaration, rather than once per instance.<br></p><p>This particular use case for mapped serialization/deserialization is interesting. A potential future extension to better support it might be to let behaviors optionally bind the name of a property using them as a `String` (or other `StringLiteralConvertible` type).<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/d497b320/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 14, 2016 at 03:00:00pm</p></header><div class="content"><p>Joe, your idea for initializer as an accessor makes sense to me. Also, it seems that if resettable&#39;s initializer isn&#39;t delayed, we don&#39;t need the redundancy since it can set the base value from its own init:<br></p><p>&gt; public var behavior resettable /* whatever goes here */ {<br>&gt; 	eager accessor resetValue(): Value<br>&gt; 	var value: Value = resetValue()<br>&gt; }<br>&gt; <br>&gt; var [resettable] foo: Int { resetValue { return 42 } }<br></p><p>Even if I made it up just to support this case, I think that allowing `eager` and `delayed` on accessors might be a good idea. Right now, there appears to be no way to enforce that observed&#39;s willSet and didSet do not fire during property initialization. Marking them &quot;delayed&quot; could mean that.<br></p><p>I would support using &quot;initializer&quot; as a special accessor name that refers to the initializer value of the property (parsed as an autoclosure, mapping to whatever behaviors use behind the scenes). Having &quot;delayed accessor&quot;/&quot;eager accessor&quot; in front of it would make it much less magical in my opinion.<br></p><p>&gt; public var behavior resettable /* whatever goes here */ {<br>&gt; 	eager accessor initializer(): Value<br>&gt; 	var value: Value = initializer()<br>&gt; }<br>&gt; <br>&gt; var [resettable] foo: Int = 42<br></p><p>Chiming in with plx:<br></p><p>&gt; ## Request: Declared-Property-Name<br>&gt; <br>&gt; If possible, a property analogous to `self` / `parent` / etc. getting at a behavior’s concrete “declared-name” would be amazing, although I know it’s not quite that easy, either (see @objc questions later).<br></p><p>I also think that this is an interesting idea. In fact, when reflection details are better specified (I think that it&#39;s in scope for Swift 3, right?), I think that behaviors should have access to the property&#39;s &quot;mirror&quot;.<br></p><p>&gt; ## Semantics: Overrides + Behaviors<br>&gt; <br>&gt; I think this is probably specified somewhere and I just don’t understand it, but I need to ask: how do overrides work for things like the following example:<br></p><p>Just like right now, I think that behaviors should be completely opaque to subclasses. This means you can&#39;t alter their behavior (unless they do a virtual call) and you&#39;re possibly not even aware that they have behaviors attached.<br></p><p>&gt; …but if you “expand” what happens within these behaviors, once you have multiple such behaviors in a chain (e.g. `[redraw, invalidateSize]`) you will of course have one `!=` comparison per behavior. Note that although, in this case, `!=` is hopefully not too expensive, you can also consider it as a proxy here for other, possibly-expensive operations.<br></p><p><br>My personal hope is that the accessors will compose and optimize as nicely as short private funcs. I wonder how that would play out with behaviors taken from other modules though.<br></p><p>&gt; ## ObjC Interaction<br></p><p><br>I think that this is an issue with @objc. I agree that it should get the name right for boolean properties.<br></p><p><br>Now going back to a warning when a behavior can alter the property without other behaviors noticing.<br></p><p>We have a pretty small sample size of behaviors, but I predict that it will always be a problem when a property value is set without the whole chain being aware of it. For instance, [resettable, observed] is as much a problem as [resettable, backedByJSON]. Using resettable&#39;s reset method bypasses behavior that was deemed useful (or even necessary) by the developer in these two cases. In fact, I would like to challenge you to think of a behavior B with a setter, in a chain [resettable, B], where `reset` bypassing B&#39;s setter is what the developer intends.<br></p><p>I think that either one of these should be implemented:<br></p><p>warn when using a mutating function on a behavior when &quot;outer behaviors&quot; have setters;<br>ensure that mutating functions send their result value down the behavior chain like a normal assignment (not sure how feasible this is with behaviors that have state).<br></p><p>Félix<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/38a96124/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; That parameterization could be achieved, somewhat more verbosely, using an accessor &#39;key { return &quot;id&quot; }&#39;. If behaviors could be parameterized in-line, I wouldn&#39;t do it by passing the params to `init`, since that again imposes the need for per-instance storage to carry `key` from the behavior initialization to the property implementation.<br>&gt; <br>&gt; Thinking about this more, maybe the need for instance storage could be avoided by letting behaviors declare `static` properties. It&#39;s likely that behavior instantiations will need some global data structure, at least in debug builds, to collect their parameterizations from property decls using the behavior. It&#39;d make sense to put some of that global structure under the behavior&#39;s control. We&#39;d still potentially need a separate `static init()` to initialize that storage once per declaration, rather than once per instance.<br></p><p>That&#39;s really, really, really clever. (Of course, it also means that a property will need to have some kind of existence on the type so we can attach static behaviors to it.)<br></p><p>I have to say, this feature of behaviors where &quot;it&#39;s not really a type, it&#39;s a template for a bunch of stuff that gets added to your type&quot; is a bit mind-bending. Expect to do a lot of writing in the Swift book to explain it!<br></p><p>&gt; This particular use case for mapped serialization/deserialization is interesting. A potential future extension to better support it might be to let behaviors optionally bind the name of a property using them as a `String` (or other `StringLiteralConvertible` type).<br></p><p>Yes, I&#39;d like that too. `key ?? propertyName` would be quite handy here.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; @autoclosure instead of `deferred` is an interesting idea. Also, as I mentioned to Felix, if we didn&#39;t have a way to bind the initializer, the same functionality could be achieved using custom accessors, at the loss of some sugar. If that&#39;s acceptable, it would greatly simplify the proposal to leave out the ability to hijack the initializer.<br></p><p>I think that might be acceptable for lazy, but doing it twice for resettable seems painful. So how about a compromise?<br></p><p>- There are only eager initializers.<br>- All behaviors have access to the initializer at any time by using `initializer`.<br>- The implicit stored property uses the initializer to initialize itself.<br></p><p>So `resettable` becomes a non-base behavior which uses `initializer`:<br></p><p>	var behavior resettable&lt;Value&gt;: Value {<br>		base var value: Value<br>		<br>		func reset() {<br>			value = initializer<br>		}<br>		get {<br>			return value<br>		}<br>		set {<br>			value = newValue<br>		}<br>	}<br>	<br>	class Foo {<br>		var [resettable] bar = 5<br>	}<br></p><p>Which means it can be properly stacked with observation behaviors. Meanwhile, `lazy` is a base behavior with an accessor:<br></p><p>	var behavior lazy&lt;Value&gt;: Value {<br>		var value: Value?<br>		<br>		accessor lazy()<br>		<br>		get {<br>			if let value = value {<br>				return value<br>			}<br>			let newValue = lazy()<br>			value = newValue<br>			return newValue<br>		}<br>		set {<br>			value = newValue<br>		}<br>	}<br>	<br>	class Foo {<br>		var [lazy] bar {<br>			lazy {<br>				return 5<br>			}<br>		}<br>	}<br></p><p>Hmm. Any chance we can get rid of the `[lazy]` when we see `lazy` in the accessor list? Such a feature might also allow us to de-magic `willSet` and `didSet`.<br></p><p>&gt;&gt; Do you think it makes sense to allow non-base properties to accept initializers? If so, what does it mean? What happens if one behavior wants deferred and another wants eager?<br>&gt; <br>&gt; I think, fundamentally, only the innermost behavior can control initialization. If you innermost behavior itself has a base, then there&#39;s essentially an implicit &quot;stored&quot; behavior nested within it, which has the standard stored property initialization behavior.<br></p><p>That makes sense, but I think access to the initializer should probably be broader, as I suggested above. That is, only the innermost behavior initializes the storage, but all behaviors have access to the initial value for whatever use they might want to make of it.<br></p><p>(Although `lazy` would need to be able to say &quot;this takes no initializer&quot;. Hmm...)<br></p><p>&gt;&gt; One more thing: should there be a way to pass arbitrary data, rather than initializers or accessors, into a behavior?<br>&gt; <br>&gt; That parameterization could be achieved, somewhat more verbosely, using an accessor &#39;key { return &quot;id&quot; }&#39;. If behaviors could be parameterized in-line, I wouldn&#39;t do it by passing the params to `init`, since that again imposes the need for per-instance storage to carry `key` from the behavior initialization to the property implementation.<br></p><p>If we were going to do that, I&#39;d prefer to see accessors get the one-expression-return behavior of a closure:<br></p><p>	key { &quot;id&quot; }<br></p><p>This would also make using an accessor for `lazy` more palatable!<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>January 17, 2016 at 08:00:00pm</p></header><div class="content"><p>On Jan 14, 2016, at 10:33 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; One more thing: should there be a way to pass arbitrary data, rather than initializers or accessors, into a behavior? For instance, it would be nice if you could do something like:<br>&gt;&gt; <br>&gt;&gt;    var behavior backedByJSON&lt;Value: JSONRepresentable where Self: JSONObjectRepresentable&gt;: Value {<br>&gt;&gt;        var key: String<br>&gt;&gt;        <br>&gt;&gt;        init(key: String) {<br>&gt;&gt;            backedByJSON.key = key<br>&gt;&gt;        }<br>&gt;&gt;        <br>&gt;&gt;        get {<br>&gt;&gt;            return Value(JSON: self.JSON[key])<br>&gt;&gt;        }<br>&gt;&gt;        set {<br>&gt;&gt;            self.JSON[key] = newValue.JSON<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt;    <br>&gt;&gt;    struct User: JSONObjectRepresentable {<br>&gt;&gt;        var JSON: [String: JSONType]<br>&gt;&gt;        <br>&gt;&gt;        var [backedByJSON(key: &quot;id&quot;)] ID: Int<br>&gt;&gt;        var [backedByJSON(key: &quot;name&quot;)] name: String<br>&gt;&gt;        <br>&gt;&gt;        var [backedByJSON(key: &quot;posts&quot;)] posts: [Post]<br>&gt;&gt;    }<br>&gt; <br>&gt; <br>&gt; That parameterization could be achieved, somewhat more verbosely, using an accessor &#39;key { return &quot;id&quot; }&#39;. If behaviors could be parameterized in-line, I wouldn&#39;t do it by passing the params to `init`, since that again imposes the need for per-instance storage to carry `key` from the behavior initialization to the property implementation.<br></p><p>It would be very handy to have access to the property&#39;s name inside the behavior. As proposed, we have Self and self for referring to the type and instance of the container and newValue for referring to the new value in the core getter. A predefined local variable &quot;name&quot; of type String, bound to the name of the decorated property, would be handy for implementing things like Brent&#39;s backedByJSON behavior:<br></p><p>   var behavior backedByJSON&lt;Value: JSONRepresentable where Self: JSONObjectRepresentable&gt;: Value {<br>       get {<br>           return Value(JSON: self.JSON[name])<br>       }<br>       set {<br>           self.JSON[name] = newValue.JSON<br>       }<br>   }<br></p><p>A &quot;name&quot; property could also be used for an object-level observation system that included the name of the changed property in published notifications. Such a system can be useful, for example, in constructing delta transaction for sending to a remote API. (E.g., we could notify a server that the due date of a task has changed rather than sending the whole task object or performing a diff.)<br></p><p>Adding this bit of magic would go a long way toward letting us implement something like OAAppearance[1] in Swift instead of importing runtime.h and dynamically reifying methods[2]. <br></p><p>Cheers,<br></p><p>Curt<br></p><p>Curt Clifton, PhD<br>Software Developer<br>The Omni Group<br></p><p>[1] - https://github.com/omnigroup/OmniGroup/tree/master/Frameworks/OmniAppKit/Appearance<br>[2] - http://curtclifton.net/video-of-oaappearance-at-xcoders<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/407a3e35/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 13, 2016 at 07:00:00pm</p></header><div class="content"><p>Quick Q1: is it the case that `var behavior redrawing&lt;Value where Self:UIView&gt; : Value { … } ` would work or no? I’d assume so, but I don’t think there are any examples with a non-protocol constraint on `Self`, making it hard to tell at a glance.<br></p><p>Quick Q2: is there anything you can do in this scenario:<br></p><p>// w/in some behavior:<br>mutating func silentlySet(value: Value) {<br>  value = value // &lt;- probably not going to work<br>  self.value = value // &lt;- not right either, `self` is the behavior’s owner, right?<br>}<br></p><p>…other than change the argument name to avoid conflict?<br></p><p>Remark: it definitely feels a bit odd to be using both `Self` and `self` to mean something that’s neither consistent with the rest of the language nor, really, to mean `Self` (or `self`). <br></p><p>I get not wanting new keywords, but this feels like it could be an economy too far; perhaps I’m misunderstanding some aspect of how it’s meant to work.<br></p><p>&gt; On Jan 13, 2016, at 4:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Here&#39;s the revised proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; <br>&gt; For reference, here&#39;s the previous iteration:<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 5:12 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Quick Q1: is it the case that `var behavior redrawing&lt;Value where Self:UIView&gt; : Value { … } ` would work or no? I’d assume so, but I don’t think there are any examples with a non-protocol constraint on `Self`, making it hard to tell at a glance.<br></p><p>Yeah, you should be able to use arbitrary generic constraints.<br></p><p>&gt; <br>&gt; Quick Q2: is there anything you can do in this scenario:<br>&gt; <br>&gt; // w/in some behavior:<br>&gt; mutating func silentlySet(value: Value) {<br>&gt;  value = value // &lt;- probably not going to work<br>&gt;  self.value = value // &lt;- not right either, `self` is the behavior’s owner, right?<br>&gt; }<br>&gt; <br>&gt; …other than change the argument name to avoid conflict?<br></p><p>I thought I mentioned this in the proposal—you could use `behaviorName.value` to qualify a reference to the behavior&#39;s members within the behavior.<br></p><p>&gt; <br>&gt; Remark: it definitely feels a bit odd to be using both `Self` and `self` to mean something that’s neither consistent with the rest of the language nor, really, to mean `Self` (or `self`). <br>&gt; <br>&gt; I get not wanting new keywords, but this feels like it could be an economy too far; perhaps I’m misunderstanding some aspect of how it’s meant to work.<br></p><p>I&#39;m not totally comfortable with it either. It at least corresponds to the notion of `self` you&#39;d get if you&#39;d coded a property by hand within its enclosing type, so the meaning might be useful for refactoring code out of concrete property implementations into behavior templates.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 14, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks for the earlier feedback (you did mention how to resolve reference ambiguity).<br></p><p>After re-reading it this is a really nice proposal overall. Even in it’s current state it is a huge upgrade, and could lead to a huge productivity / implementation-quality upgrade in application code.<br></p><p>I do have a bunch of questions, though.<br></p><p>## Syntax: “In the Large”<br></p><p>One thing that does worry me is readability in real-world variable declarations; I agree that `@behavior(lazy)` is clunky in the small, but in the large the current syntax is questionable:<br></p><p>class SomeView : UIView {<br>  <br>  @IBInspectable<br>   public internal(set) weak var [mainThread,resettable,logged,changeObserved] contentAreaInsets: UIEdgeInsets = UIEdgeInsetsZero {<br>    logName { “contentAreaInsets” } // &lt;- see note later, btw<br>    didChange { setNeedsUpdateConstraints() }<br>  }<br></p><p>}<br></p><p>…which is admittedly an extreme example, but it illustrates the point.<br></p><p>The below is definitely worse in the small, but feels better in the large:<br></p><p>class SomeView : UIView {<br>  <br>  @IBInspectable<br>  @behavior(mainThread,resettable,logged,changeObserved) <br>  public internal(set) weak var contentAreaInsets: UIEdgeInsets = UIEdgeInsetsZero {<br>    logName { “contentAreaInsets” } // &lt;- see note later, btw<br>    didChange { setNeedsUpdateConstraints() }<br>  }<br></p><p>}<br></p><p>…(I could add line breaks in the first one, but a line break anywhere between the `var` and its the name seems odd).<br></p><p>To be clear, I am not suggesting the above syntax as-is; I am more trying to make sure some consideration is “how does this look with longer behavior lists”, since all the examples in the proposal are for “nice” cases.<br></p><p>Putting the behavior-list after `var` but before the name and type seems unfortunate once you want to add a line-break in there.<br></p><p>## Request: Declared-Property-Name<br></p><p>If possible, a property analogous to `self` / `parent` / etc. getting at a behavior’s concrete “declared-name” would be amazing, although I know it’s not quite that easy, either (see @objc questions later).<br></p><p>## Semantics: Overrides + Behaviors<br></p><p>I think this is probably specified somewhere and I just don’t understand it, but I need to ask: how do overrides work for things like the following example:<br></p><p>class BaseView : UIView {<br></p><p>  var [changeObserved] text: String {<br>    didChange { setNeedsLayout() }<br>  }<br></p><p>}<br></p><p>class RefinedView : BaseView {<br></p><p>  // is this right? (recall property is already `changeObserved` in parent):<br>  override var text: String {<br>    didChange { invalidateIntrinsicContentSize() } <br>    // ^ does parent’s didChange get called also? can I control that?<br>    // ^ when is this override called? when is the parent called (if it is)?<br>  }<br></p><p>  // or is this right? (needing to add another `changeObserved` here?)<br>  override var [changeObserved] text: String {<br>    didChange { invalidateIntrinsicContentSize() }<br>    // ^ does parent’s didChange get called also? can I control that?<br>    // ^ when is this override called? when is the parent called (if it is)?<br>  }<br></p><p>}<br></p><p>…I’m really not sure which of the above is more reasonable. <br></p><p>The first variant would seem to have confusing timing (when do the calls happen relative to each other and to other behaviors)?<br></p><p>The other one seems to introduce a new, identically-named behavior, which seems like it’d lead to ambiguity if you had to use behavior methods/behavior properties.<br></p><p>## Semantics: Redundancy/“Static” Parameterization<br></p><p>This is an extended example, but it sort-of has to be to illustrate the concern.<br></p><p>Suppose we wanted to define a bunch of behaviors useful for use on UIView. I’ll provide a few examples, including just the `set` logic to keep it as short as possible:<br></p><p>// goal: `redraw` automatically calls `setNeedsDisplay()` when necessary:<br>var behavior redraw&lt;Value:Equatable where Self:UIView&gt; : Value {<br>  set { <br>    if newValue != value {<br>      value = newValue<br>      self.setNeedsDisplay()<br>    }<br>  }<br>}<br></p><p>// goal: `invalidateSize` automatically calls `invalidateIntrinsicContentSize()` when necessary:<br>var behavior invalidateSize&lt;Value:Equatable where Self:UIView&gt; : Value {<br>  set { <br>    if newValue != value {<br>      value = newValue<br>      self.invalidateIntrinsicContentSize()<br>    }<br>  }<br>}<br></p><p>…(and you can consider also `relayout`, `updateConstraints`, `updateFocus`, accessibility utilities, and so on…).<br></p><p>With all those in hand, we arrive at something IMHO really nice and self-documenting:<br></p><p>class CustomDrawnView : UIView {<br></p><p>  // pure-redrawing:<br>  var [redraw] strokeWidth: CGFloat<br>  var [redraw] outlineWidth: CGFloat<br>  var [redraw] strokeColor: UIColor<br>  var [redraw] outlineColor: UIColor<br></p><p>  // also size-impacting:<br>  var [redraw, invalidateSize] iconPath: UIBezierPath<br>  var [redraw, invalidateSize] captionText: String<br>  var [redraw, invalidateSize] verticalSpace: CGFloat<br>  <br>}<br></p><p>…but if you “expand” what happens within these behaviors, once you have multiple such behaviors in a chain (e.g. `[redraw, invalidateSize]`) you will of course have one `!=` comparison per behavior. Note that although, in this case, `!=` is hopefully not too expensive, you can also consider it as a proxy here for other, possibly-expensive operations.<br></p><p>On the one hand, it seems like it ought to be possible to do better here — e.g., do a single such check, not one per behavior — but on the other hand, it seems hard to augment the proposal to make it possible w/out also making it much more complex than it already is.<br></p><p>EG: the best hope from a readability standpoint might be something like this behavior:<br></p><p>var behavior invalidate&lt;Value:Equatable where Self:UIView&gt; {<br>  // `parameter` here is new syntax; explanation below<br>  parameter display: Bool = false<br>  parameter intrinsicSize: Bool = false<br>  <br>  // as-before:<br>  var value: Value<br></p><p>  // `get` omitted: <br>  set {<br>    if newValue != value {<br>      value = newValue<br>      if display { self.setNeedsDisplay() }<br>      if intrinsicSize { self.invalidateIntrinsicContentSize() }<br>      // also imagine constraints, layout, etc.<br>    }<br>  }<br>}<br></p><p>…but to achieve that “omnibus” capability you’d need a lot of flags, each of which:<br></p><p>- needs to get set somehow (without terrible syntax)<br>- needs to get “stored&quot; somehow (without bloating the behaviors, if possible)<br></p><p>Syntax to set the flags seems awkward at best:<br></p><p>// this seems close to ideal for such parameters:<br>var [invalidate(display,intrinsicSize)] iconPath: UIBezierPath<br></p><p>// but this seems the best-achievable option w/out dedicated compiler magic:<br>var [invalidate(display=true, intrinsicSize=true)] iconPath: UIBezierPath<br></p><p>…and at least to my eyes that &quot;best-achievable syntax&quot; isn’t all that great, anymore.<br></p><p>Likewise you’d need some way to actually store those parameters, presumably *not* as ordinary stored fields — that’s going to bloat the behaviors! — but as some new thing, whence the new `parameter` keyword.<br></p><p>Between that and the naming/parameter-passing, it feels like a big ask, probably too big.<br></p><p>FWIW, for sake of comparison, this seems to be about the best you can do under the current proposal:<br></p><p>class CustomDrawnView : UIView {<br></p><p>  // pure-redrawing:<br>  var [changeObserved] strokeWidth: CGFloat {<br>    didChange { invalidate(.Display) }<br>  }<br></p><p>  var [changeObserved] outlineWidth: CGFloat {<br>    didChange { invalidate(.Display) }<br>  }<br></p><p>  var [changeObserved] strokeColor: UIColor {<br>    didChange { invalidate(.Display) }<br>  }<br></p><p>  var [changeObserved] outlineColor: UIColor {<br>    didChange { invalidate(.Display) }<br>  }<br></p><p>  // also size-impacting:<br>  var [changeObserved] iconPath: UIBezierPath {<br>    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>  }<br></p><p>  var [changeObserved] captionText: String {<br>    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>  }<br></p><p>  var [changeObserved] verticalSpace: CGFloat {<br>    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>  }<br>  <br>}<br></p><p>…where `invalidate` is taking some bitmask/option-set and then calling the appropriate view methods.<br></p><p>This isn’t terrible, it’s just nowhere near what it might be under this proposal.<br></p><p>I also think it’s perfectly reasonable to see the above and decide the likely complexity of a solution probably outweighs whatever gains it might bring; I’m just bringing it up in hopes there might be an easy way to have most of the cake and also eat most of the cake.<br></p><p>## ObjC Interaction<br></p><p>One thing I am not sure about is how this interacts with @objc annotations. <br></p><p>First, my assumption is that, as today, property behaviors and @objc-visibilty are essentially orthogonal (don’t really impact each other). This doesn’t seem to be stated explicitly anywhere, and it would be preserving the status quo, but it’s worth confirming just to be sure.<br></p><p>Secondly, right now one of the language’s minor warts is you can’t really get proper objective-c property names on some read-write properties without some doing.<br></p><p>You can either do this:<br></p><p>class Foo: NSObject {<br>  @objc(isPermitted)<br>  var permitted: Bool<br>}<br></p><p>…which gets you `isPermitted` (good) and `setIsPermitted:` (not ideal), or you can do this:<br></p><p>class Foo: NSObject {<br>  <br>  @nonobjc // maximize chances of efficiency<br>  private final var _permitted: Bool<br>  <br>  var permitted: Bool {<br>    @objc(isPermitted) get { return _permitted }<br>    @objc(setPermitted:) set { _permitted = newValue }<br>  }<br></p><p>}<br></p><p>…which gets the right Objective-C names but is quite clunky.<br></p><p>What you can’t do is this:<br></p><p>class Foo: NSObject {<br>  var permitted: Bool {<br>   @objc(isPermitted) get, // just rename<br>   @objc(setPermitted:) set // just rename <br>}<br></p><p>…at least not to my knowledge; if there’s a trick I don’t know it.<br></p><p>On the one hand, this proposal doesn’t seem to change this situation.<br></p><p>On the other hand, if it can be changed, this seems like a reasonable time/place to do it.<br></p><p>That’s it for the moment.<br></p><p>With this proposal it seems like a really nice feature to have.<br></p><p>&gt; On Jan 13, 2016, at 8:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 5:12 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Quick Q1: is it the case that `var behavior redrawing&lt;Value where Self:UIView&gt; : Value { … } ` would work or no? I’d assume so, but I don’t think there are any examples with a non-protocol constraint on `Self`, making it hard to tell at a glance.<br>&gt; <br>&gt; Yeah, you should be able to use arbitrary generic constraints.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Quick Q2: is there anything you can do in this scenario:<br>&gt;&gt; <br>&gt;&gt; // w/in some behavior:<br>&gt;&gt; mutating func silentlySet(value: Value) {<br>&gt;&gt; value = value // &lt;- probably not going to work<br>&gt;&gt; self.value = value // &lt;- not right either, `self` is the behavior’s owner, right?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …other than change the argument name to avoid conflict?<br>&gt; <br>&gt; I thought I mentioned this in the proposal—you could use `behaviorName.value` to qualify a reference to the behavior&#39;s members within the behavior.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Remark: it definitely feels a bit odd to be using both `Self` and `self` to mean something that’s neither consistent with the rest of the language nor, really, to mean `Self` (or `self`). <br>&gt;&gt; <br>&gt;&gt; I get not wanting new keywords, but this feels like it could be an economy too far; perhaps I’m misunderstanding some aspect of how it’s meant to work.<br>&gt; <br>&gt; I&#39;m not totally comfortable with it either. It at least corresponds to the notion of `self` you&#39;d get if you&#39;d coded a property by hand within its enclosing type, so the meaning might be useful for refactoring code out of concrete property implementations into behavior templates.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 14, 2016, at 11:33 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the earlier feedback (you did mention how to resolve reference ambiguity).<br>&gt; <br>&gt; After re-reading it this is a really nice proposal overall. Even in it’s current state it is a huge upgrade, and could lead to a huge productivity / implementation-quality upgrade in application code.<br>&gt; <br>&gt; I do have a bunch of questions, though.<br>&gt; <br>&gt; ## Syntax: “In the Large”<br>&gt; <br>&gt; One thing that does worry me is readability in real-world variable declarations; I agree that `@behavior(lazy)` is clunky in the small, but in the large the current syntax is questionable:<br>&gt; <br>&gt; class SomeView : UIView {<br>&gt; <br>&gt;  @IBInspectable<br>&gt;   public internal(set) weak var [mainThread,resettable,logged,changeObserved] contentAreaInsets: UIEdgeInsets = UIEdgeInsetsZero {<br>&gt;    logName { “contentAreaInsets” } // &lt;- see note later, btw<br>&gt;    didChange { setNeedsUpdateConstraints() }<br>&gt;  }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …which is admittedly an extreme example, but it illustrates the point.<br>&gt; <br>&gt; The below is definitely worse in the small, but feels better in the large:<br>&gt; <br>&gt; class SomeView : UIView {<br>&gt; <br>&gt;  @IBInspectable<br>&gt;  @behavior(mainThread,resettable,logged,changeObserved) <br>&gt;  public internal(set) weak var contentAreaInsets: UIEdgeInsets = UIEdgeInsetsZero {<br>&gt;    logName { “contentAreaInsets” } // &lt;- see note later, btw<br>&gt;    didChange { setNeedsUpdateConstraints() }<br>&gt;  }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …(I could add line breaks in the first one, but a line break anywhere between the `var` and its the name seems odd).<br>&gt; <br>&gt; To be clear, I am not suggesting the above syntax as-is; I am more trying to make sure some consideration is “how does this look with longer behavior lists”, since all the examples in the proposal are for “nice” cases.<br>&gt; <br>&gt; Putting the behavior-list after `var` but before the name and type seems unfortunate once you want to add a line-break in there.<br></p><p>Good point. Longer behavior compositions are something to consider. If behaviors have dedicated declarations instead of being applications of plain types or functions, it also becomes more reasonable to let them be used as attributes by themselves:<br></p><p>@mainThread @resettable @logged @changeObserved<br>public var foo: Int { ... }<br></p><p>I shied away from that design originally because it would be problematic to pollute the attribute namespace with potentially every function and/or type. That&#39;s less of a problem with this design.<br></p><p>&gt; ## Request: Declared-Property-Name<br>&gt; <br>&gt; If possible, a property analogous to `self` / `parent` / etc. getting at a behavior’s concrete “declared-name” would be amazing, although I know it’s not quite that easy, either (see @objc questions later).<br></p><p>That&#39;s definitely an interesting extension to consider. I think it can be separated from the core proposal, though.<br></p><p>&gt; ## Semantics: Overrides + Behaviors<br>&gt; <br>&gt; I think this is probably specified somewhere and I just don’t understand it, but I need to ask: how do overrides work for things like the following example:<br>&gt; <br>&gt; class BaseView : UIView {<br>&gt; <br>&gt;  var [changeObserved] text: String {<br>&gt;    didChange { setNeedsLayout() }<br>&gt;  }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; class RefinedView : BaseView {<br>&gt; <br>&gt;  // is this right? (recall property is already `changeObserved` in parent):<br>&gt;  override var text: String {<br>&gt;    didChange { invalidateIntrinsicContentSize() } <br>&gt;    // ^ does parent’s didChange get called also? can I control that?<br>&gt;    // ^ when is this override called? when is the parent called (if it is)?<br>&gt;  }<br>&gt; <br>&gt;  // or is this right? (needing to add another `changeObserved` here?)<br>&gt;  override var [changeObserved] text: String {<br>&gt;    didChange { invalidateIntrinsicContentSize() }<br>&gt;    // ^ does parent’s didChange get called also? can I control that?<br>&gt;    // ^ when is this override called? when is the parent called (if it is)?<br>&gt;  }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …I’m really not sure which of the above is more reasonable. <br>&gt; <br>&gt; The first variant would seem to have confusing timing (when do the calls happen relative to each other and to other behaviors)?<br>&gt; <br>&gt; The other one seems to introduce a new, identically-named behavior, which seems like it’d lead to ambiguity if you had to use behavior methods/behavior properties.<br></p><p>I would expect each override&#39;s [changeObserved] behavior to wrap the previous override, as happens if you override with `didSet`/`willSet` today. You raise the interesting question of what happens with the behavior names, since you do end up with two same-named behaviors applied at different times. That potentially requires deeper qualification by type; if we use Tal&#39;s suggested `.[behavior]` qualification syntax, you could refer to `.[BaseView.changeObserved]` and `.[RefinedView.changeObserved]` if you needed to.<br></p><p>&gt; ## Semantics: Redundancy/“Static” Parameterization<br>&gt; <br>&gt; This is an extended example, but it sort-of has to be to illustrate the concern.<br>&gt; <br>&gt; Suppose we wanted to define a bunch of behaviors useful for use on UIView. I’ll provide a few examples, including just the `set` logic to keep it as short as possible:<br>&gt; <br>&gt; // goal: `redraw` automatically calls `setNeedsDisplay()` when necessary:<br>&gt; var behavior redraw&lt;Value:Equatable where Self:UIView&gt; : Value {<br>&gt;  set { <br>&gt;    if newValue != value {<br>&gt;      value = newValue<br>&gt;      self.setNeedsDisplay()<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; // goal: `invalidateSize` automatically calls `invalidateIntrinsicContentSize()` when necessary:<br>&gt; var behavior invalidateSize&lt;Value:Equatable where Self:UIView&gt; : Value {<br>&gt;  set { <br>&gt;    if newValue != value {<br>&gt;      value = newValue<br>&gt;      self.invalidateIntrinsicContentSize()<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; …(and you can consider also `relayout`, `updateConstraints`, `updateFocus`, accessibility utilities, and so on…).<br>&gt; <br>&gt; With all those in hand, we arrive at something IMHO really nice and self-documenting:<br>&gt; <br>&gt; class CustomDrawnView : UIView {<br>&gt; <br>&gt;  // pure-redrawing:<br>&gt;  var [redraw] strokeWidth: CGFloat<br>&gt;  var [redraw] outlineWidth: CGFloat<br>&gt;  var [redraw] strokeColor: UIColor<br>&gt;  var [redraw] outlineColor: UIColor<br>&gt; <br>&gt;  // also size-impacting:<br>&gt;  var [redraw, invalidateSize] iconPath: UIBezierPath<br>&gt;  var [redraw, invalidateSize] captionText: String<br>&gt;  var [redraw, invalidateSize] verticalSpace: CGFloat<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …but if you “expand” what happens within these behaviors, once you have multiple such behaviors in a chain (e.g. `[redraw, invalidateSize]`) you will of course have one `!=` comparison per behavior. Note that although, in this case, `!=` is hopefully not too expensive, you can also consider it as a proxy here for other, possibly-expensive operations.<br>&gt; <br>&gt; On the one hand, it seems like it ought to be possible to do better here — e.g., do a single such check, not one per behavior — but on the other hand, it seems hard to augment the proposal to make it possible w/out also making it much more complex than it already is.<br>&gt; <br>&gt; EG: the best hope from a readability standpoint might be something like this behavior:<br>&gt; <br>&gt; var behavior invalidate&lt;Value:Equatable where Self:UIView&gt; {<br>&gt;  // `parameter` here is new syntax; explanation below<br>&gt;  parameter display: Bool = false<br>&gt;  parameter intrinsicSize: Bool = false<br>&gt; <br>&gt;  // as-before:<br>&gt;  var value: Value<br>&gt; <br>&gt;  // `get` omitted: <br>&gt;  set {<br>&gt;    if newValue != value {<br>&gt;      value = newValue<br>&gt;      if display { self.setNeedsDisplay() }<br>&gt;      if intrinsicSize { self.invalidateIntrinsicContentSize() }<br>&gt;      // also imagine constraints, layout, etc.<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; …but to achieve that “omnibus” capability you’d need a lot of flags, each of which:<br>&gt; <br>&gt; - needs to get set somehow (without terrible syntax)<br>&gt; - needs to get “stored&quot; somehow (without bloating the behaviors, if possible)<br>&gt; <br>&gt; Syntax to set the flags seems awkward at best:<br>&gt; <br>&gt; // this seems close to ideal for such parameters:<br>&gt; var [invalidate(display,intrinsicSize)] iconPath: UIBezierPath<br>&gt; <br>&gt; // but this seems the best-achievable option w/out dedicated compiler magic:<br>&gt; var [invalidate(display=true, intrinsicSize=true)] iconPath: UIBezierPath<br>&gt; <br>&gt; …and at least to my eyes that &quot;best-achievable syntax&quot; isn’t all that great, anymore.<br>&gt; <br>&gt; Likewise you’d need some way to actually store those parameters, presumably *not* as ordinary stored fields — that’s going to bloat the behaviors! — but as some new thing, whence the new `parameter` keyword.<br>&gt; <br>&gt; Between that and the naming/parameter-passing, it feels like a big ask, probably too big.<br>&gt; <br>&gt; FWIW, for sake of comparison, this seems to be about the best you can do under the current proposal:<br>&gt; <br>&gt; class CustomDrawnView : UIView {<br>&gt; <br>&gt;  // pure-redrawing:<br>&gt;  var [changeObserved] strokeWidth: CGFloat {<br>&gt;    didChange { invalidate(.Display) }<br>&gt;  }<br>&gt; <br>&gt;  var [changeObserved] outlineWidth: CGFloat {<br>&gt;    didChange { invalidate(.Display) }<br>&gt;  }<br>&gt; <br>&gt;  var [changeObserved] strokeColor: UIColor {<br>&gt;    didChange { invalidate(.Display) }<br>&gt;  }<br>&gt; <br>&gt;  var [changeObserved] outlineColor: UIColor {<br>&gt;    didChange { invalidate(.Display) }<br>&gt;  }<br>&gt; <br>&gt;  // also size-impacting:<br>&gt;  var [changeObserved] iconPath: UIBezierPath {<br>&gt;    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>&gt;  }<br>&gt; <br>&gt;  var [changeObserved] captionText: String {<br>&gt;    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>&gt;  }<br>&gt; <br>&gt;  var [changeObserved] verticalSpace: CGFloat {<br>&gt;    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>&gt;  }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …where `invalidate` is taking some bitmask/option-set and then calling the appropriate view methods.<br>&gt; <br>&gt; This isn’t terrible, it’s just nowhere near what it might be under this proposal.<br>&gt; <br>&gt; I also think it’s perfectly reasonable to see the above and decide the likely complexity of a solution probably outweighs whatever gains it might bring; I’m just bringing it up in hopes there might be an easy way to have most of the cake and also eat most of the cake.<br></p><p>It seems to me you could factor at least some of this boilerplate into a behavior, reducing it to:<br></p><p>var [invalidate] foo: String { invalidates { return [.Display, .ContentSize] } }<br></p><p>Brent mentioned in the other thread about modeling `lazy` with an accessor some possibilities to whittle this down further, by allowing for implicit single-expression return in accessors, and inferring behaviors from accessor names:<br></p><p>var foo: String { invalidates { [.Display, .ContentSize] } }<br></p><p>&gt; ## ObjC Interaction<br>&gt; <br>&gt; One thing I am not sure about is how this interacts with @objc annotations. <br>&gt; <br>&gt; First, my assumption is that, as today, property behaviors and @objc-visibilty are essentially orthogonal (don’t really impact each other). This doesn’t seem to be stated explicitly anywhere, and it would be preserving the status quo, but it’s worth confirming just to be sure.<br>&gt; <br>&gt; Secondly, right now one of the language’s minor warts is you can’t really get proper objective-c property names on some read-write properties without some doing.<br>&gt; <br>&gt; You can either do this:<br>&gt; <br>&gt; class Foo: NSObject {<br>&gt;  @objc(isPermitted)<br>&gt;  var permitted: Bool<br>&gt; }<br>&gt; <br>&gt; …which gets you `isPermitted` (good) and `setIsPermitted:` (not ideal), or you can do this:<br>&gt; <br>&gt; class Foo: NSObject {<br>&gt; <br>&gt;  @nonobjc // maximize chances of efficiency<br>&gt;  private final var _permitted: Bool<br>&gt; <br>&gt;  var permitted: Bool {<br>&gt;    @objc(isPermitted) get { return _permitted }<br>&gt;    @objc(setPermitted:) set { _permitted = newValue }<br>&gt;  }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …which gets the right Objective-C names but is quite clunky.<br>&gt; <br>&gt; What you can’t do is this:<br>&gt; <br>&gt; class Foo: NSObject {<br>&gt;  var permitted: Bool {<br>&gt;   @objc(isPermitted) get, // just rename<br>&gt;   @objc(setPermitted:) set // just rename <br>&gt; }<br>&gt; <br>&gt; …at least not to my knowledge; if there’s a trick I don’t know it.<br></p><p>You could potentially declare another @objc property that forwards to the stored property, though that&#39;s even less ideal of course:<br></p><p>var permitted: Bool<br>private var _objcPermitted: Bool {<br>  @objc(isPermitted) get { return _permitted }<br>  @objc(setPermitted:) set { _permitted = newValue }<br>}<br></p><p>Behaviors definitely exacerbate this issue, since you have more interesting properties without native get/set accessors that you may want to control the ObjC interface for. The private @objc trick above at least still works.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; On the one hand, this proposal doesn’t seem to change this situation.<br>&gt; <br>&gt; On the other hand, if it can be changed, this seems like a reasonable time/place to do it.<br>&gt; <br>&gt; That’s it for the moment.<br>&gt; <br>&gt; With this proposal it seems like a really nice feature to have.<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 8:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 5:12 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Quick Q1: is it the case that `var behavior redrawing&lt;Value where Self:UIView&gt; : Value { … } ` would work or no? I’d assume so, but I don’t think there are any examples with a non-protocol constraint on `Self`, making it hard to tell at a glance.<br>&gt;&gt; <br>&gt;&gt; Yeah, you should be able to use arbitrary generic constraints.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Quick Q2: is there anything you can do in this scenario:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // w/in some behavior:<br>&gt;&gt;&gt; mutating func silentlySet(value: Value) {<br>&gt;&gt;&gt; value = value // &lt;- probably not going to work<br>&gt;&gt;&gt; self.value = value // &lt;- not right either, `self` is the behavior’s owner, right?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …other than change the argument name to avoid conflict?<br>&gt;&gt; <br>&gt;&gt; I thought I mentioned this in the proposal—you could use `behaviorName.value` to qualify a reference to the behavior&#39;s members within the behavior.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Remark: it definitely feels a bit odd to be using both `Self` and `self` to mean something that’s neither consistent with the rest of the language nor, really, to mean `Self` (or `self`). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I get not wanting new keywords, but this feels like it could be an economy too far; perhaps I’m misunderstanding some aspect of how it’s meant to work.<br>&gt;&gt; <br>&gt;&gt; I&#39;m not totally comfortable with it either. It at least corresponds to the notion of `self` you&#39;d get if you&#39;d coded a property by hand within its enclosing type, so the meaning might be useful for refactoring code out of concrete property implementations into behavior templates.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/97b36894/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 14, 2016 at 05:00:00pm</p></header><div class="content"><p>In favor of them being just functions (even if they were declared as part of a class/struct/whatever)…<br></p><p>Isn’t there a proposal for a function composition operator floating around? I think it was “•” (option-8)… Anyway, assume that’s what I mean by “•”.<br>var &lt;lazy•resettable•changeObserved&gt; foo: Int = {…}<br></p><p>Plus, it’d make the order in which they were applied obvious.<br></p><p>Actually, speaking of using functions that were declared as part of an object… Could this all be done now by introducing an Observable&lt;T&gt; struct which itself uses the existing will/didSet functions? Like this? 	<br>var foo = Observable(3, lazy•resettable•changeObserved)<br></p><p>I think the only thing off the top of my head that wouldn’t pretty much Just Work is automatically converting between Observable&lt;T&gt; and T, the way you can with Implicitly Unwrapped Optionals. I might play with it a bit tonight after dinner.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 14, 2016, at 14:05, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If behaviors have dedicated declarations instead of being applications of plain types or functions, it also becomes more reasonable to let them be used as attributes by themselves<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/085f63d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 15, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jan 14, 2016, at 17:16, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I might play with it a bit tonight after dinner.<br></p><p>Ok, so here’s what I came up with. It partially works. Also, I thought it might be easier to supply a list of behaviors instead of using function composition. Both ways are included, since I’d already written the one using function composition when I thought of the other way.<br></p><p>Oh, and to be clear, I’m NOT saying this is the way I think we should do this… I’m just exploring how for we can take it without adding any new language features.<br></p><p>Here’s the “library” part:<br>//: Playground - noun: a place where people can play<br></p><p>import Cocoa<br></p><p>protocol Wrapper {<br>    typealias T<br>    var value: T {get set}<br>}<br></p><p>// &quot;assignment&quot; operator, since we can&#39;t overload the real one<br>// (yes, I know &quot;≠&quot; means &quot;not equals&quot;... it&#39;s easy to type, and<br>// this is just for a proof of concept)<br>infix operator ≠ {}<br>func ≠ &lt;U: Wrapper, V: Wrapper where U.T == V.T&gt; (inout lhs: U, rhs: V) { lhs.value = rhs.value }<br>func ≠ &lt;V: Wrapper&gt; (inout lhs: V.T, rhs: V) { lhs = rhs.value }<br>func ≠ &lt;V: Wrapper&gt; (inout lhs: V, rhs: V.T) { lhs.value = rhs }<br></p><p>// function composition. Nothing special about &quot;•&quot;... it&#39;s just about as close as<br>// I could get to the &quot;⊙&quot; my math textbooks used without pulling up the symbols palette<br>infix operator • {}<br>func • &lt;T, U, V&gt; (f1: U -&gt; V, f2: T -&gt; U) -&gt; (T -&gt; V) { return { f1(f2($0)) } }<br></p><p>// function currying. Nothing special about &quot;&lt;|&gt;&quot;... is was just what someone else used<br>infix operator &lt;|&gt; {precedence 200}<br>func &lt;|&gt; &lt;T, U, V&gt; (f: (T,U)-&gt;V, b: U) -&gt; (T-&gt;V) { return { f($0, b) } }<br></p><p>// Seemed the easiest way to handle “lazy”.<br>enum MaybeLazy&lt;T&gt; {<br>    case Yep(()-&gt;T)<br>    case Nah(T)<br>    <br>    init(_ value: ()-&gt;T) { self = .Yep(value) }<br>    init(_ value: T) { self = .Nah(value) }<br>    <br>    var value: T {<br>        get {<br>            switch self {<br>            case .Nah(let t): return t<br>            case .Yep(let tc): return tc()<br>            }<br>        }<br>        set {<br>            self = .Nah(newValue)<br>        }<br>    }<br>}<br></p><p>// Where the sufficiently advanced technology happens<br>struct Observable&lt;T&gt; : Wrapper, CustomStringConvertible {<br>    // I&#39;m not actually sure this typealias needs to exist. Sometimes<br>    // the playground gets... stubborn... about what is or isn&#39;t an error,<br>    // and there&#39;s no way to clean/build. Plus I lose track of where the Ts go.<br>    typealias FType = (T,T)-&gt;(T,T)<br>    <br>    // The &quot;do nothing&quot; closure<br>    static func _passThrough(x:(oldValue: T, newValue: T)) -&gt; (T,T) { return x }<br>    <br>    // &quot;Function&quot;<br>    var f: FType! = nil<br>    // &quot;Element Function&quot;. More on this later.<br>    var ef: Any? = nil<br>    var _value:MaybeLazy&lt;T&gt;<br>    var value: T {<br>        get { return _value.value }<br>        set { _value.value = (f != nil) ? f(_value.value, newValue).1 : newValue }<br>    }<br>    <br>    // inits for function composition<br>    init(_ value: T, _ f: (oldValue: T, newValue: T)-&gt;(T, T) = Observable._passThrough) {<br>        self._value = .Nah(value)<br>        self.f = f<br>    }<br>    init(lazy: ()-&gt;T, _ f: (oldValue: T, newValue: T)-&gt;(T, T) = Observable._passThrough) {<br>        self._value = .Yep(lazy)<br>        self.f = f<br>    }<br>    <br>    // inits for variadic list of functions<br>    init(_ value: T, behaviors: ((oldValue: T, newValue: T)-&gt;(T, T))...) {<br>        self._value = .Nah(value)<br>        switch behaviors.count {<br>        case 0: self.f = Observable._passThrough<br>        case 1: self.f = behaviors[0]<br>        case _:<br>            var c = behaviors.last!<br>            for i in (0 ..&lt; (behaviors.count - 1)).reverse() {<br>                c = c • behaviors[i]<br>            }<br>            self.f = c<br>        }<br>    }<br>    init(lazy: ()-&gt;T, behaviors: ((oldValue: T, newValue: T)-&gt;(T, T))...) {<br>        self._value = .Yep(lazy)<br>        switch behaviors.count {<br>        case 0: self.f = Observable._passThrough<br>        case 1: self.f = behaviors[0]<br>        case _:<br>            var c = behaviors.last!<br>            for i in (0 ..&lt; (behaviors.count - 1)).reverse() {<br>                c = c • behaviors[i]<br>            }<br>            self.f = c<br>        }<br>    }<br>    <br>    var description: String { return &quot;\(value)&quot; }<br>}<br></p><p>// the behavior functions to be passed in<br>func didSet &lt;T&gt; (x: (oldValue: T, newValue: T), _ f: ((T,T))-&gt;((T,T))) -&gt; (T,T) {<br>    f(x)<br>    return (x)<br>}<br>func didChange&lt;T: Equatable&gt; (x: (oldValue: T, newValue: T), _ f: ((T,T))-&gt;((T,T))) -&gt; (T,T) {<br>    if x.oldValue != x.newValue {<br>        f(x)<br>    }<br>    return (x)<br>}<br></p><p>And here’s how you’d use it (except with “=“ instead of “≠”, of course):<br>var exampleOfCompositionSyntax = Observable(3,<br>    didSet &lt;|&gt; {<br>        print(&quot;didSet&quot;)<br>        return ($0, $1)<br>    } • didChange &lt;|&gt; {<br>        print(&quot;didChange&quot;)<br>        return ($0,$1)<br>    }<br>)<br>exampleOfCompositionSyntax ≠ 3 // the closure passed to didSet is called, but not didChange<br>exampleOfCompositionSyntax ≠ 4 // both are called, and it now evaluates to 4<br></p><p>var exampleOfVariadicSyntax = Observable(3, behaviors:<br>    didSet &lt;|&gt; {<br>        print(&quot;didSet&quot;)<br>        return ($0, $1)<br>    },<br>    didChange &lt;|&gt; {<br>        print(&quot;didChange&quot;)<br>        return ($0,$1)<br>    }<br>)<br>exampleOfVariadicSyntax ≠ 3 // the closure passed to didSet is called, but not didChange<br>exampleOfVariadicSyntax ≠ 4 // both are called, and it now evaluates to 4<br></p><p>var nowWithMoreLaziness = Observable(lazy: {return 4})<br>var ibar = 0 // here’s one glitchy bit… ibar has to be declared first since “=“ can’t be overloaded<br>ibar ≠ nowWithMoreLaziness // ibar evaluates to 4<br></p><p>Trying to extending the behavior to collections is where things kinda fall apart. This code doesn’t generate any errors, but it causes Xcode to repeatedly “lose communication with the playground service&quot;:<br>extension Observable where T: MutableCollectionType {<br>    // This extension is where we support per-element behavior. &quot;ef&quot; is really<br>    // of type &quot;CType&quot;, but we couldn&#39;t declare it that way because we didn&#39;t<br>    // know that T was a MutableCollectionType until now.<br>    typealias CType = (T.Generator.Element,T.Generator.Element,T.Index)-&gt;(T.Generator.Element,T.Generator.Element,T.Index)<br>    <br>    // The &quot;do nothing&quot; closure<br>    static func _ePassThrough(x:CType) -&gt; CType { return x }<br>    <br>    init(_ value: T, elementalbehaviors: CType...) {<br>        self._value = .Nah(value)<br>        switch elementalbehaviors.count {<br>        case 0: self.ef = Observable._ePassThrough<br>        case 1: self.ef = elementalbehaviors[0]<br>        case _:<br>            var c = elementalbehaviors.last!<br>            for i in (0 ..&lt; (elementalbehaviors.count - 1)).reverse() {<br>                c = c • elementalbehaviors[i]<br>            }<br>            self.ef = c<br>        }<br>    }<br>    subscript(i: T.Index) -&gt; T.Generator.Element {<br>        get { return value[i] }<br>        set { value[i] = (ef != nil) ? (ef! as! CType)(value[i], newValue, i).1 : newValue }<br>        <br>    }<br>}<br></p><p>So is it a bug in my code, or a bug in Playgrounds that’s causing the problem? Dunno, and I’m too tired to find out tonight. Obviously, if any of you want to play with it, go ahead… that’s why I posted the code :-)<br></p><p>- Dave Sweeris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/c7e7d965/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 15, 2016 at 08:00:00am</p></header><div class="content"><p>One more “how will this work?” question: optionals.<br></p><p>Specifically, consider something like this:<br></p><p>// annoyingly-long protocol:<br>protocol ControlExchanging {<br>  typealias Context<br>  func willTakeControlFrom(other: Self?, context: Context)<br>  func didTakeControlFrom(other: Self?, context: Context)<br> <br>  func takeControl(context: Context)<br>  func cedeControl(context: Context)<br>  <br>  func willCedeControlTo(other: Self?, context: Context)<br>  func didCedeControlTo(other: Self?, context: Context)<br>}<br></p><p>var behavior exchangeState&lt;Value:ControlExchanging where Self:Value.Context&gt; : Value {<br>  var value: Value<br>  // here:<br>  set { <br>    let oldValue = value<br>    // boilerplate-choreography begins:<br>    newValue.willTakeControlFrom(oldValue, context: self)<br>    oldValue.willCedeControlTo(newValue, context: self)<br>    oldValue.cedeControl(self)<br>    value = newValue<br>    newValue.takeControl(self)<br>    oldValue.didCedeControlTo(newValue, context: self)<br>    newValue.didTakeControlFrom(oldValue, context: self)<br>  }<br>}<br></p><p>// numerous extraneous details omitted:<br>class GenericSwitchboard&lt;Delegate:ControlExchanging were Delegate.Context == Self&gt; {<br></p><p>  private(set) weak var [exchangeControl] delegate: Delegate? = nil<br></p><p>}<br></p><p>…which presumably won’t actually work unless I’ve either:<br></p><p>- added an additional implementation that’s typed-as `Value?` <br>- added a conditional-conformance for `ControlExchanging` to `Optional` (easy, but boilerplate)<br></p><p>….both of which are workable, neither of which feels optimal (and for the latter, consider also that in many cases such conformances may generally be undesirable).<br></p><p>Is there a trick/detail I’m missing here?<br></p><p>&gt; On Jan 14, 2016, at 4:05 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Good point. Longer behavior compositions are something to consider. If behaviors have dedicated declarations instead of being applications of plain types or functions, it also becomes more reasonable to let them be used as attributes by themselves:<br>&gt; <br>&gt; @mainThread @resettable @logged @changeObserved<br>&gt; public var foo: Int { ... }<br>&gt; <br>&gt; I shied away from that design originally because it would be problematic to pollute the attribute namespace with potentially every function and/or type. That&#39;s less of a problem with this design.<br></p><p>I still like the aesthetics of your design better (until maybe when things get too long).<br></p><p>It might be a good general policy for proposals with syntax changes to always include at least one “heavy-duty/extreme” example.<br></p><p>Another argument in favor of a different positioning: it makes these kinds of things easier to write:<br></p><p>@resettable @changeObserved<br>#if DEBUG<br>@mainThread @onlyAfterViewLoaded @logged <br>#endif<br></p><p>…(which may or may not be a good thing).<br></p><p>&gt;&gt; ## Request: Declared-Property-Name<br>&gt;&gt; <br>&gt;&gt; If possible, a property analogous to `self` / `parent` / etc. getting at a behavior’s concrete “declared-name” would be amazing, although I know it’s not quite that easy, either (see @objc questions later).<br>&gt; <br>&gt; That&#39;s definitely an interesting extension to consider. I think it can be separated from the core proposal, though.<br></p><p>Agreed it is an extension; consider it in the spirit of “if a bunch of other such things get added, perhaps this should be too”.<br></p><p>&gt; <br>&gt;&gt; ## Semantics: Overrides + Behaviors<br>&gt;&gt; <br>&gt; <br>&gt; I would expect each override&#39;s [changeObserved] behavior to wrap the previous override, as happens if you override with `didSet`/`willSet` today. You raise the interesting question of what happens with the behavior names, since you do end up with two same-named behaviors applied at different times. That potentially requires deeper qualification by type; if we use Tal&#39;s suggested `.[behavior]` qualification syntax, you could refer to `.[BaseView.changeObserved]` and `.[RefinedView.changeObserved]` if you needed to.<br></p><p>The behavior is what I’d expect, but it seems that that behavior will be an occasional source of subtle bugs in scenarios like this:<br></p><p>class Simple : Synchronizing {<br>   var [changeObserved,synchronized] delicate: Delicate<br>}<br></p><p>class Fancy : Simple {<br>  override var [changeObserved] delicate: Delicate {<br>    willSet { /* consider timing vis-a-vis base&#39;s `synchronized` */ }<br>    didSet { /* consider timing vis-a-vis base&#39;s `synchronized` */ }<br>  }<br>}<br></p><p>…but I’m note sure there’s an easy way to make property behaviors flexible-enough to solve this problem purely at the property-behavior level; especially when it is easy in this sort of circumstance (and arguably better) to just write appropriate hooks into your class, and override from there.<br></p><p>&gt; <br>&gt;&gt; ## Semantics: Redundancy/“Static” Parameterization<br>&gt;&gt; <br>&gt; <br>&gt; It seems to me you could factor at least some of this boilerplate into a behavior, reducing it to:<br>&gt; <br>&gt; var [invalidate] foo: String { invalidates { return [.Display, .ContentSize] } }<br>&gt; <br>&gt; Brent mentioned in the other thread about modeling `lazy` with an accessor some possibilities to whittle this down further, by allowing for implicit single-expression return in accessors, and inferring behaviors from accessor names:<br>&gt; <br>&gt; var foo: String { invalidates { [.Display, .ContentSize] } }<br></p><p>That’s a really nice trick and makes this a proposal a lot more feature-complete for me than I had realized, particularly if the implicit-return suggestion is taken.<br></p><p>&gt; <br>&gt;&gt; ## ObjC Interaction<br>&gt;&gt; <br>&gt; <br>&gt; You could potentially declare another @objc property that forwards to the stored property, though that&#39;s even less ideal of course:<br>&gt; <br>&gt; var permitted: Bool<br>&gt; private var _objcPermitted: Bool {<br>&gt;   @objc(isPermitted) get { return _permitted }<br>&gt;   @objc(setPermitted:) set { _permitted = newValue }<br>&gt; }<br>&gt; <br>&gt; Behaviors definitely exacerbate this issue, since you have more interesting properties without native get/set accessors that you may want to control the ObjC interface for. The private @objc trick above at least still works.<br></p><p>That’s another really nice way to do it. But, I’ll take this reply to mean an improvement to @objc-renaming is independent of this proposal, which is fine.<br></p><p>Overall this revision of the proposal is looking really nice.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On the one hand, this proposal doesn’t seem to change this situation.<br>&gt;&gt; <br>&gt;&gt; On the other hand, if it can be changed, this seems like a reasonable time/place to do it.<br>&gt;&gt; <br>&gt;&gt; That’s it for the moment.<br>&gt;&gt; <br>&gt;&gt; With this proposal it seems like a really nice feature to have.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 8:04 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:12 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Quick Q1: is it the case that `var behavior redrawing&lt;Value where Self:UIView&gt; : Value { … } ` would work or no? I’d assume so, but I don’t think there are any examples with a non-protocol constraint on `Self`, making it hard to tell at a glance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, you should be able to use arbitrary generic constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Quick Q2: is there anything you can do in this scenario:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // w/in some behavior:<br>&gt;&gt;&gt;&gt; mutating func silentlySet(value: Value) {<br>&gt;&gt;&gt;&gt; value = value // &lt;- probably not going to work<br>&gt;&gt;&gt;&gt; self.value = value // &lt;- not right either, `self` is the behavior’s owner, right?<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …other than change the argument name to avoid conflict?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I thought I mentioned this in the proposal—you could use `behaviorName.value` to qualify a reference to the behavior&#39;s members within the behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Remark: it definitely feels a bit odd to be using both `Self` and `self` to mean something that’s neither consistent with the rest of the language nor, really, to mean `Self` (or `self`). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I get not wanting new keywords, but this feels like it could be an economy too far; perhaps I’m misunderstanding some aspect of how it’s meant to work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not totally comfortable with it either. It at least corresponds to the notion of `self` you&#39;d get if you&#39;d coded a property by hand within its enclosing type, so the meaning might be useful for refactoring code out of concrete property implementations into behavior templates.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/1a0bd8c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 8:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One more “how will this work?” question: optionals.<br>&gt; <br>&gt; Specifically, consider something like this:<br>&gt; <br>&gt; // annoyingly-long protocol:<br>&gt; protocol ControlExchanging {<br>&gt;   typealias Context<br>&gt;   func willTakeControlFrom(other: Self?, context: Context)<br>&gt;   func didTakeControlFrom(other: Self?, context: Context)<br>&gt;  <br>&gt;   func takeControl(context: Context)<br>&gt;   func cedeControl(context: Context)<br>&gt;   <br>&gt;   func willCedeControlTo(other: Self?, context: Context)<br>&gt;   func didCedeControlTo(other: Self?, context: Context)<br>&gt; }<br>&gt; <br>&gt; var behavior exchangeState&lt;Value:ControlExchanging where Self:Value.Context&gt; : Value {<br>&gt;   var value: Value<br>&gt;   // here:<br>&gt;   set { <br>&gt;     let oldValue = value<br>&gt;     // boilerplate-choreography begins:<br>&gt;     newValue.willTakeControlFrom(oldValue, context: self)<br>&gt;     oldValue.willCedeControlTo(newValue, context: self)<br>&gt;     oldValue.cedeControl(self)<br>&gt;     value = newValue<br>&gt;     newValue.takeControl(self)<br>&gt;     oldValue.didCedeControlTo(newValue, context: self)<br>&gt;     newValue.didTakeControlFrom(oldValue, context: self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; // numerous extraneous details omitted:<br>&gt; class GenericSwitchboard&lt;Delegate:ControlExchanging were Delegate.Context == Self&gt; {<br>&gt; <br>&gt;   private(set) weak var [exchangeControl] delegate: Delegate? = nil<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …which presumably won’t actually work unless I’ve either:<br>&gt; <br>&gt; - added an additional implementation that’s typed-as `Value?` <br>&gt; - added a conditional-conformance for `ControlExchanging` to `Optional` (easy, but boilerplate)<br>&gt; <br>&gt; ….both of which are workable, neither of which feels optimal (and for the latter, consider also that in many cases such conformances may generally be undesirable).<br>&gt; <br>&gt; Is there a trick/detail I’m missing here?<br>&gt; <br>&gt;&gt; On Jan 14, 2016, at 4:05 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Good point. Longer behavior compositions are something to consider. If behaviors have dedicated declarations instead of being applications of plain types or functions, it also becomes more reasonable to let them be used as attributes by themselves:<br>&gt;&gt; <br>&gt;&gt; @mainThread @resettable @logged @changeObserved<br>&gt;&gt; public var foo: Int { ... }<br>&gt;&gt; <br>&gt;&gt; I shied away from that design originally because it would be problematic to pollute the attribute namespace with potentially every function and/or type. That&#39;s less of a problem with this design.<br>&gt; <br>&gt; I still like the aesthetics of your design better (until maybe when things get too long).<br>&gt; <br>&gt; It might be a good general policy for proposals with syntax changes to always include at least one “heavy-duty/extreme” example.<br>&gt; <br>&gt; Another argument in favor of a different positioning: it makes these kinds of things easier to write:<br>&gt; <br>&gt; @resettable @changeObserved<br>&gt; #if DEBUG<br>&gt; @mainThread @onlyAfterViewLoaded @logged <br>&gt; #endif<br>&gt; <br>&gt; …(which may or may not be a good thing).<br></p><p>Would it be possible to move the &quot;behavior list” prior to decl modifiers without needing to use attributes?  The square brackets might not work in that case but maybe something else?  <br></p><p>I like the positioning but don’t like all the @ sigils and the fact that the behaviors would be potentially intermixed with other attributes.  I also like that the square brackets in property declaration syntax makes it very clear when behaviors are involved.<br></p><p>&gt; <br>&gt;&gt;&gt; ## Request: Declared-Property-Name<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If possible, a property analogous to `self` / `parent` / etc. getting at a behavior’s concrete “declared-name” would be amazing, although I know it’s not quite that easy, either (see @objc questions later).<br>&gt;&gt; <br>&gt;&gt; That&#39;s definitely an interesting extension to consider. I think it can be separated from the core proposal, though.<br>&gt; <br>&gt; Agreed it is an extension; consider it in the spirit of “if a bunch of other such things get added, perhaps this should be too”.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; ## Semantics: Overrides + Behaviors<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would expect each override&#39;s [changeObserved] behavior to wrap the previous override, as happens if you override with `didSet`/`willSet` today. You raise the interesting question of what happens with the behavior names, since you do end up with two same-named behaviors applied at different times. That potentially requires deeper qualification by type; if we use Tal&#39;s suggested `.[behavior]` qualification syntax, you could refer to `.[BaseView.changeObserved]` and `.[RefinedView.changeObserved]` if you needed to.<br>&gt; <br>&gt; The behavior is what I’d expect, but it seems that that behavior will be an occasional source of subtle bugs in scenarios like this:<br>&gt; <br>&gt; class Simple : Synchronizing {<br>&gt;    var [changeObserved,synchronized] delicate: Delicate<br>&gt; }<br>&gt; <br>&gt; class Fancy : Simple {<br>&gt;   override var [changeObserved] delicate: Delicate {<br>&gt;     willSet { /* consider timing vis-a-vis base&#39;s `synchronized` */ }<br>&gt;     didSet { /* consider timing vis-a-vis base&#39;s `synchronized` */ }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; …but I’m note sure there’s an easy way to make property behaviors flexible-enough to solve this problem purely at the property-behavior level; especially when it is easy in this sort of circumstance (and arguably better) to just write appropriate hooks into your class, and override from there.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; ## Semantics: Redundancy/“Static” Parameterization<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It seems to me you could factor at least some of this boilerplate into a behavior, reducing it to:<br>&gt;&gt; <br>&gt;&gt; var [invalidate] foo: String { invalidates { return [.Display, .ContentSize] } }<br>&gt;&gt; <br>&gt;&gt; Brent mentioned in the other thread about modeling `lazy` with an accessor some possibilities to whittle this down further, by allowing for implicit single-expression return in accessors, and inferring behaviors from accessor names:<br>&gt;&gt; <br>&gt;&gt; var foo: String { invalidates { [.Display, .ContentSize] } }<br>&gt; <br>&gt; That’s a really nice trick and makes this a proposal a lot more feature-complete for me than I had realized, particularly if the implicit-return suggestion is taken.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; ## ObjC Interaction<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You could potentially declare another @objc property that forwards to the stored property, though that&#39;s even less ideal of course:<br>&gt;&gt; <br>&gt;&gt; var permitted: Bool<br>&gt;&gt; private var _objcPermitted: Bool {<br>&gt;&gt;   @objc(isPermitted) get { return _permitted }<br>&gt;&gt;   @objc(setPermitted:) set { _permitted = newValue }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Behaviors definitely exacerbate this issue, since you have more interesting properties without native get/set accessors that you may want to control the ObjC interface for. The private @objc trick above at least still works.<br>&gt; <br>&gt; That’s another really nice way to do it. But, I’ll take this reply to mean an improvement to @objc-renaming is independent of this proposal, which is fine.<br>&gt; <br>&gt; Overall this revision of the proposal is looking really nice.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the one hand, this proposal doesn’t seem to change this situation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, if it can be changed, this seems like a reasonable time/place to do it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s it for the moment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this proposal it seems like a really nice feature to have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 8:04 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:12 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Quick Q1: is it the case that `var behavior redrawing&lt;Value where Self:UIView&gt; : Value { … } ` would work or no? I’d assume so, but I don’t think there are any examples with a non-protocol constraint on `Self`, making it hard to tell at a glance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, you should be able to use arbitrary generic constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Quick Q2: is there anything you can do in this scenario:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // w/in some behavior:<br>&gt;&gt;&gt;&gt;&gt; mutating func silentlySet(value: Value) {<br>&gt;&gt;&gt;&gt;&gt; value = value // &lt;- probably not going to work<br>&gt;&gt;&gt;&gt;&gt; self.value = value // &lt;- not right either, `self` is the behavior’s owner, right?<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; …other than change the argument name to avoid conflict?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I thought I mentioned this in the proposal—you could use `behaviorName.value` to qualify a reference to the behavior&#39;s members within the behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Remark: it definitely feels a bit odd to be using both `Self` and `self` to mean something that’s neither consistent with the rest of the language nor, really, to mean `Self` (or `self`). <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I get not wanting new keywords, but this feels like it could be an economy too far; perhaps I’m misunderstanding some aspect of how it’s meant to work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not totally comfortable with it either. It at least corresponds to the notion of `self` you&#39;d get if you&#39;d coded a property by hand within its enclosing type, so the meaning might be useful for refactoring code out of concrete property implementations into behavior templates.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/eb48d5bc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 6:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One more “how will this work?” question: optionals.<br>&gt; <br>&gt; Specifically, consider something like this:<br>&gt; <br>&gt; // annoyingly-long protocol:<br>&gt; protocol ControlExchanging {<br>&gt;   typealias Context<br>&gt;   func willTakeControlFrom(other: Self?, context: Context)<br>&gt;   func didTakeControlFrom(other: Self?, context: Context)<br>&gt;  <br>&gt;   func takeControl(context: Context)<br>&gt;   func cedeControl(context: Context)<br>&gt;   <br>&gt;   func willCedeControlTo(other: Self?, context: Context)<br>&gt;   func didCedeControlTo(other: Self?, context: Context)<br>&gt; }<br>&gt; <br>&gt; var behavior exchangeState&lt;Value:ControlExchanging where Self:Value.Context&gt; : Value {<br>&gt;   var value: Value<br>&gt;   // here:<br>&gt;   set { <br>&gt;     let oldValue = value<br>&gt;     // boilerplate-choreography begins:<br>&gt;     newValue.willTakeControlFrom(oldValue, context: self)<br>&gt;     oldValue.willCedeControlTo(newValue, context: self)<br>&gt;     oldValue.cedeControl(self)<br>&gt;     value = newValue<br>&gt;     newValue.takeControl(self)<br>&gt;     oldValue.didCedeControlTo(newValue, context: self)<br>&gt;     newValue.didTakeControlFrom(oldValue, context: self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; // numerous extraneous details omitted:<br>&gt; class GenericSwitchboard&lt;Delegate:ControlExchanging were Delegate.Context == Self&gt; {<br>&gt; <br>&gt;   private(set) weak var [exchangeControl] delegate: Delegate? = nil<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …which presumably won’t actually work unless I’ve either:<br>&gt; <br>&gt; - added an additional implementation that’s typed-as `Value?` <br>&gt; - added a conditional-conformance for `ControlExchanging` to `Optional` (easy, but boilerplate)<br>&gt; <br>&gt; ….both of which are workable, neither of which feels optimal (and for the latter, consider also that in many cases such conformances may generally be undesirable).<br>&gt; <br>&gt; Is there a trick/detail I’m missing here?<br></p><p>No, I think you&#39;ve got it. This seems like a general problem to me, though; it&#39;d be nice if protocol conformances could be easily forwarded, for instance from Optional&lt;T&gt; to T.<br></p><p>&gt; <br>&gt;&gt; On Jan 14, 2016, at 4:05 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Good point. Longer behavior compositions are something to consider. If behaviors have dedicated declarations instead of being applications of plain types or functions, it also becomes more reasonable to let them be used as attributes by themselves:<br>&gt;&gt; <br>&gt;&gt; @mainThread @resettable @logged @changeObserved<br>&gt;&gt; public var foo: Int { ... }<br>&gt;&gt; <br>&gt;&gt; I shied away from that design originally because it would be problematic to pollute the attribute namespace with potentially every function and/or type. That&#39;s less of a problem with this design.<br>&gt; <br>&gt; I still like the aesthetics of your design better (until maybe when things get too long).<br>&gt; <br>&gt; It might be a good general policy for proposals with syntax changes to always include at least one “heavy-duty/extreme” example.<br>&gt; <br>&gt; Another argument in favor of a different positioning: it makes these kinds of things easier to write:<br>&gt; <br>&gt; @resettable @changeObserved<br>&gt; #if DEBUG<br>&gt; @mainThread @onlyAfterViewLoaded @logged <br>&gt; #endif<br>&gt; <br>&gt; …(which may or may not be a good thing).<br></p><p>I don&#39;t think this is currently allowed with attributes today, since the content of #if blocks is still parsed as full statement/expression/declarations.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/75272b05/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 15, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 7:45 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 15, 2016, at 6:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One more “how will this work?” question: optionals.<br>&gt;&gt; <br>&gt;&gt; Specifically, consider something like this:<br>&gt;&gt; <br>&gt;&gt; // annoyingly-long protocol:<br>&gt;&gt; protocol ControlExchanging {<br>&gt;&gt;   typealias Context<br>&gt;&gt;   func willTakeControlFrom(other: Self?, context: Context)<br>&gt;&gt;   func didTakeControlFrom(other: Self?, context: Context)<br>&gt;&gt;  <br>&gt;&gt;   func takeControl(context: Context)<br>&gt;&gt;   func cedeControl(context: Context)<br>&gt;&gt;   <br>&gt;&gt;   func willCedeControlTo(other: Self?, context: Context)<br>&gt;&gt;   func didCedeControlTo(other: Self?, context: Context)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var behavior exchangeState&lt;Value:ControlExchanging where Self:Value.Context&gt; : Value {<br>&gt;&gt;   var value: Value<br>&gt;&gt;   // here:<br>&gt;&gt;   set { <br>&gt;&gt;     let oldValue = value<br>&gt;&gt;     // boilerplate-choreography begins:<br>&gt;&gt;     newValue.willTakeControlFrom(oldValue, context: self)<br>&gt;&gt;     oldValue.willCedeControlTo(newValue, context: self)<br>&gt;&gt;     oldValue.cedeControl(self)<br>&gt;&gt;     value = newValue<br>&gt;&gt;     newValue.takeControl(self)<br>&gt;&gt;     oldValue.didCedeControlTo(newValue, context: self)<br>&gt;&gt;     newValue.didTakeControlFrom(oldValue, context: self)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // numerous extraneous details omitted:<br>&gt;&gt; class GenericSwitchboard&lt;Delegate:ControlExchanging were Delegate.Context == Self&gt; {<br>&gt;&gt; <br>&gt;&gt;   private(set) weak var [exchangeControl] delegate: Delegate? = nil<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which presumably won’t actually work unless I’ve either:<br>&gt;&gt; <br>&gt;&gt; - added an additional implementation that’s typed-as `Value?` <br>&gt;&gt; - added a conditional-conformance for `ControlExchanging` to `Optional` (easy, but boilerplate)<br>&gt;&gt; <br>&gt;&gt; ….both of which are workable, neither of which feels optimal (and for the latter, consider also that in many cases such conformances may generally be undesirable).<br>&gt;&gt; <br>&gt;&gt; Is there a trick/detail I’m missing here?<br>&gt; <br>&gt; No, I think you&#39;ve got it. This seems like a general problem to me, though; it&#39;d be nice if protocol conformances could be easily forwarded, for instance from Optional&lt;T&gt; to T.<br></p><p>Any thoughts about how that might work when requirements have a return value?  Or are you just referring to forwarding conformances when the protocol doesn’t have members  with return values?<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 14, 2016, at 4:05 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good point. Longer behavior compositions are something to consider. If behaviors have dedicated declarations instead of being applications of plain types or functions, it also becomes more reasonable to let them be used as attributes by themselves:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @mainThread @resettable @logged @changeObserved<br>&gt;&gt;&gt; public var foo: Int { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I shied away from that design originally because it would be problematic to pollute the attribute namespace with potentially every function and/or type. That&#39;s less of a problem with this design.<br>&gt;&gt; <br>&gt;&gt; I still like the aesthetics of your design better (until maybe when things get too long).<br>&gt;&gt; <br>&gt;&gt; It might be a good general policy for proposals with syntax changes to always include at least one “heavy-duty/extreme” example.<br>&gt;&gt; <br>&gt;&gt; Another argument in favor of a different positioning: it makes these kinds of things easier to write:<br>&gt;&gt; <br>&gt;&gt; @resettable @changeObserved<br>&gt;&gt; #if DEBUG<br>&gt;&gt; @mainThread @onlyAfterViewLoaded @logged <br>&gt;&gt; #endif<br>&gt;&gt; <br>&gt;&gt; …(which may or may not be a good thing).<br>&gt; <br>&gt; I don&#39;t think this is currently allowed with attributes today, since the content of #if blocks is still parsed as full statement/expression/declarations.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/662ac184/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 15, 2016, at 5:54 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 15, 2016, at 7:45 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 6:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One more “how will this work?” question: optionals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Specifically, consider something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // annoyingly-long protocol:<br>&gt;&gt;&gt; protocol ControlExchanging {<br>&gt;&gt;&gt;   typealias Context<br>&gt;&gt;&gt;   func willTakeControlFrom(other: Self?, context: Context)<br>&gt;&gt;&gt;   func didTakeControlFrom(other: Self?, context: Context)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;   func takeControl(context: Context)<br>&gt;&gt;&gt;   func cedeControl(context: Context)<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;   func willCedeControlTo(other: Self?, context: Context)<br>&gt;&gt;&gt;   func didCedeControlTo(other: Self?, context: Context)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var behavior exchangeState&lt;Value:ControlExchanging where Self:Value.Context&gt; : Value {<br>&gt;&gt;&gt;   var value: Value<br>&gt;&gt;&gt;   // here:<br>&gt;&gt;&gt;   set { <br>&gt;&gt;&gt;     let oldValue = value<br>&gt;&gt;&gt;     // boilerplate-choreography begins:<br>&gt;&gt;&gt;     newValue.willTakeControlFrom(oldValue, context: self)<br>&gt;&gt;&gt;     oldValue.willCedeControlTo(newValue, context: self)<br>&gt;&gt;&gt;     oldValue.cedeControl(self)<br>&gt;&gt;&gt;     value = newValue<br>&gt;&gt;&gt;     newValue.takeControl(self)<br>&gt;&gt;&gt;     oldValue.didCedeControlTo(newValue, context: self)<br>&gt;&gt;&gt;     newValue.didTakeControlFrom(oldValue, context: self)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // numerous extraneous details omitted:<br>&gt;&gt;&gt; class GenericSwitchboard&lt;Delegate:ControlExchanging were Delegate.Context == Self&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   private(set) weak var [exchangeControl] delegate: Delegate? = nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …which presumably won’t actually work unless I’ve either:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - added an additional implementation that’s typed-as `Value?` <br>&gt;&gt;&gt; - added a conditional-conformance for `ControlExchanging` to `Optional` (easy, but boilerplate)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ….both of which are workable, neither of which feels optimal (and for the latter, consider also that in many cases such conformances may generally be undesirable).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a trick/detail I’m missing here?<br>&gt;&gt; <br>&gt;&gt; No, I think you&#39;ve got it. This seems like a general problem to me, though; it&#39;d be nice if protocol conformances could be easily forwarded, for instance from Optional&lt;T&gt; to T.<br>&gt; <br>&gt; Any thoughts about how that might work when requirements have a return value?  Or are you just referring to forwarding conformances when the protocol doesn’t have members  with return values?<br></p><p>I don&#39;t have a great answer in mind, unfortunately. You&#39;re right that it only really makes sense for &quot;sink&quot;-like protocols, where none of the requirements produce a value, or theoretically for protocols where all results are of associated types that could be optionalized. The sink protocol use case comes up all the time, though, especially with delegates and callbacks, and is one the places where ObjC&#39;s nil-messaging behavior feels legitimate.<br></p><p>-Joe<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/051bac0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 16, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 16, 2016, at 1:27 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 15, 2016, at 5:54 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 7:45 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 15, 2016, at 6:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One more “how will this work?” question: optionals.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Specifically, consider something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // annoyingly-long protocol:<br>&gt;&gt;&gt;&gt; protocol ControlExchanging {<br>&gt;&gt;&gt;&gt;   typealias Context<br>&gt;&gt;&gt;&gt;   func willTakeControlFrom(other: Self?, context: Context)<br>&gt;&gt;&gt;&gt;   func didTakeControlFrom(other: Self?, context: Context)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;   func takeControl(context: Context)<br>&gt;&gt;&gt;&gt;   func cedeControl(context: Context)<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   func willCedeControlTo(other: Self?, context: Context)<br>&gt;&gt;&gt;&gt;   func didCedeControlTo(other: Self?, context: Context)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var behavior exchangeState&lt;Value:ControlExchanging where Self:Value.Context&gt; : Value {<br>&gt;&gt;&gt;&gt;   var value: Value<br>&gt;&gt;&gt;&gt;   // here:<br>&gt;&gt;&gt;&gt;   set { <br>&gt;&gt;&gt;&gt;     let oldValue = value<br>&gt;&gt;&gt;&gt;     // boilerplate-choreography begins:<br>&gt;&gt;&gt;&gt;     newValue.willTakeControlFrom(oldValue, context: self)<br>&gt;&gt;&gt;&gt;     oldValue.willCedeControlTo(newValue, context: self)<br>&gt;&gt;&gt;&gt;     oldValue.cedeControl(self)<br>&gt;&gt;&gt;&gt;     value = newValue<br>&gt;&gt;&gt;&gt;     newValue.takeControl(self)<br>&gt;&gt;&gt;&gt;     oldValue.didCedeControlTo(newValue, context: self)<br>&gt;&gt;&gt;&gt;     newValue.didTakeControlFrom(oldValue, context: self)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // numerous extraneous details omitted:<br>&gt;&gt;&gt;&gt; class GenericSwitchboard&lt;Delegate:ControlExchanging were Delegate.Context == Self&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   private(set) weak var [exchangeControl] delegate: Delegate? = nil<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …which presumably won’t actually work unless I’ve either:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - added an additional implementation that’s typed-as `Value?` <br>&gt;&gt;&gt;&gt; - added a conditional-conformance for `ControlExchanging` to `Optional` (easy, but boilerplate)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ….both of which are workable, neither of which feels optimal (and for the latter, consider also that in many cases such conformances may generally be undesirable).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a trick/detail I’m missing here?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, I think you&#39;ve got it. This seems like a general problem to me, though; it&#39;d be nice if protocol conformances could be easily forwarded, for instance from Optional&lt;T&gt; to T.<br>&gt;&gt; <br>&gt;&gt; Any thoughts about how that might work when requirements have a return value?  Or are you just referring to forwarding conformances when the protocol doesn’t have members  with return values?<br>&gt; <br>&gt; I don&#39;t have a great answer in mind, unfortunately. You&#39;re right that it only really makes sense for &quot;sink&quot;-like protocols, where none of the requirements produce a value, or theoretically for protocols where all results are of associated types that could be optionalized. The sink protocol use case comes up all the time, though, especially with delegates and callbacks, and is one the places where ObjC&#39;s nil-messaging behavior feels legitimate.<br></p><p>Totally agree it could be useful in many cases.  Thanks for pointing out the associated type case.  I hadn’t considered that one but you’re right that it is theoretically possible.<br></p><p>I’m going to get back to wrapping up the second draft of my protocol-driven forwarding proposal soon.  I wasn’t planning to include forwarding to optional members in the core proposal, but mention that it could be added down the road.  Do you agree with holding off on that or do you think it’s useful enough to include in the core proposal?<br></p><p>I also hadn’t thought about forwarding from Optional&lt;T&gt; to T but that should be a pretty straightforward addition to the feature if it supported forwarding to optionals.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/8542c446/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>[Proposal Draft] Concise Default Values for Containers</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 16, 2016 at 03:00:00pm</p></header><div class="content"><p>This is a preliminary draft, looking for feedback, thanks. <br></p><p>Introduction<br></p><p>There are many cases where you don’t want to deal with an out of range lookup in a array or dictionary. There is quite a lot of boilerplate code to check the range and return a value. This proposal addresses that by making a concise way of providing a default value in an array or dictionary. You quickly and safely want to get the value from an array or dictionary but not have to write a bunch of checks. <br></p><p>Swift-evolution thread: derived from ternary discussion. <br></p><p>Motivation<br></p><p>There are many times when you want to map value to another, the range of input values is beyond the array index. Typically you have to write code like this;<br></p><p>	let dayString = [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”]<br>	guard  dayIndex &gt; 0 &amp;&amp; dayIndex &lt; col..count else {<br>		return “invalid day&quot;<br>	}<br>       dayString[dayIndex] <br></p><p>Or for a dictionary:<br></p><p>	let chineseNumber = [   “一” : “One”, <br>		     “二” : ”Two”,<br>					      “三” : ”Three”]<br></p><p>	guard  let englishString = englishString else {<br>		return “out of range&quot;<br>	}<br>	return englishString <br></p><p>Currently dictionaries only produce “nil” if not found so you must handle an optional. <br></p><p>Proposed solution:<br></p><p>There approach is to add default to the containers. <br></p><p>Array:<br>There is a new syntax which, allows you to choose a default:<br></p><p>let lookupDayOfWeek = [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday” &lt;&gt; “Invalid Day” ]<br></p><p>lookupDayOfWeek[1] -&gt; “Monday”<br>lookupDayOfWeek[9] -&gt; “Invalid Day”<br></p><p>The &lt;&gt; which is less than greater than. for the else portion, it indicates outside the range of the array as in less than the minimum index and greater than the highest index. It also looks like a diamond when run together so it stands out to clearly show that it is the default case and won’t be confused with the main array. In all other ways the array behaves the same, if you want to get the default value you could do this:<br></p><p>lookupDayOfWeek[ _ ] -&gt; “Invalid Day”<br></p><p>Iterating an array with a default would not include the default:<br></p><p>	for day in lookupDayOfWeek {<br>		print(“Day \(day)”)<br>	}<br></p><p>You would need to do this to get the default (see below for slices):<br></p><p>	for day in lookupDayOfWeek[:_] {<br>		print(“Day \(day)”)<br>	}<br></p><p>or this would put the default first:<br></p><p>	for day in lookupDayOfWeek[_:] {<br>		print(“Day \(day)”)<br>	}<br></p><p>Unless there is a better suggestion for this, as this relies on slices. <br></p><p>Likewise contains() and other operations would not include the default as a result. However, if you were to copy an array with a default it would travel with the array:<br></p><p>let myOtherArray = lookupDayOfWeek<br>print(myOtherArray[_])  -&gt; “Invalid Day”<br></p><p>If we were to adopt slices it would be possible to copy just the main values like this (based upon python slice syntax, speculative because slice syntax is not yet defined. If it is;):<br></p><p>let myOtherArray = lookupDayOfWeek[:]<br>print(myOtherArray) -&gt; [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”] <br></p><p>let myOtherArray = lookupDayOfWeek[:_]<br>print(myOtherArray -&gt; [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday” &lt;&gt; &quot;Invalid Day”]<br></p><p>Dictionary:<br>For a dictionary, we use the _: to indicate none of the above, which is consistent with current dictionary syntax except that it adds the _ case..<br></p><p>let chineseToEnglishNumber = [   “一&quot; : “One”, <br>		         “二&quot;: ”Two”,<br>				                      &quot;三&quot;: ”Three”,<br>				                        _:  “Out of Range” ]<br></p><p>print(chineseToEnglishNumber[ “三”]) -&gt; “Three&quot;<br>print(chineseToEnglishNumber[“四”]) -&gt; “Out of Range”<br></p><p>This concisely represents what to do if none of the values are usable. No more if let clauses or guards. Diamond &lt;&gt; could be supported here too, but that is optional for this proposal. The dictionary would be handled pretty much as it is today but the underscore-colon lets you give a default. Similarly, you can access the default value by doing this.<br></p><p>print(chineseToEnglishNumber[_]) -&gt; “Out of Range”<br></p><p>print(chineseToEnglishNumber.contains(“None”)) -&gt; would return false. <br>print(chineseToEnglishNumber) -&gt; [&quot;一&quot;: &quot;2&quot;, &quot;二&quot;: &quot;1&quot;, &quot;三&quot;: “3” &lt;&gt; “ Out of Range”]<br></p><p>Copying the dictionary would include the default but iterating it would not include the default: <br></p><p>for number in chineseToEnglishNumber {<br>	<br>}<br></p><p>to include it (this may need work):<br></p><p>for number in chineseToEnglishNumber[:_] {<br>	<br>}<br></p><p>since dictionaries are unordered it will not necessarily be at the end..<br></p><p>Alternatives considered<br></p><p>Other operators:<br>Tried single colon and double colon but did not stand out enough and colon might not work if we adopted slices. <br></p><p>Sets<br>Thought about sets but not sure that makes sense because you only test existence of a member usually, the following kind makes sense to a point:<br></p><p>let set = Set(“A”, “B”, “C” &lt;&gt; “D”)<br>set.contains(“B”) -&gt; true<br>set.contains(“D”) -&gt; false<br>set.contains(“F”) -&gt; false<br></p><p>print(set) -&gt; [“A”, “B”, “C”]<br></p><p>but typically you are just checking for existence or getting all values so having it return a default does not make sense. <br></p><p>Map<br>This came out of the ternary and switch discussions, this could be done with map defaults. If we don’t want to add it to the container types that might be a better way to go. See that thread for more details. <br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/5b8705dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal Draft] Concise Default Values for Containers</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 17, 2016 at 02:00:00am</p></header><div class="content"><p>While I like the idea of a default value I don&#39;t think that you need one as often.<br></p><p><br>On another thread (&quot;Optional safe subscripting for arrays&quot;) something similar is being discussed where<br></p><p>array[safe: 6]<br></p><p>returns Optionals and your proposal is very similar to<br></p><p>array[safe: 6] ?? defaultValue<br>// or probably rewriting this to<br>array[6, default: defaultValue]<br></p><p>So these two proposals/threads could be merged.<br></p><p><br>In case of (Python like) slices I&#39;m not sure whether the additional syntax pays off for its use.<br></p><p><br>Do you have any concrete plan how it could be implemented? As additional property/closure/DefaultProtocol?<br>I&#39;m in favor of a closure: () -&gt; Element<br>since it is like a generator where less weird behaviors can occur due to referencing classes. (Value types would work (almost) flawlessly with a stored property)<br></p><p><br>Another note: Could there be a more general way to use &quot;_&quot; as a language feature? So the proposal would be more likely to be accepted.<br></p><p><br>Best regards<br>- Maximilian<br></p><p>&gt; Am 17.01.2016 um 00:37 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; This is a preliminary draft, looking for feedback, thanks. <br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; There are many cases where you don’t want to deal with an out of range lookup in a array or dictionary. There is quite a lot of boilerplate code to check the range and return a value. This proposal addresses that by making a concise way of providing a default value in an array or dictionary. You quickly and safely want to get the value from an array or dictionary but not have to write a bunch of checks. <br>&gt; <br>&gt; Swift-evolution thread: derived from ternary discussion. <br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; There are many times when you want to map value to another, the range of input values is beyond the array index. Typically you have to write code like this;<br>&gt; <br>&gt; 	let dayString = [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”]<br>&gt; 	guard  dayIndex &gt; 0 &amp;&amp; dayIndex &lt; col..count else {<br>&gt; 		return “invalid day&quot;<br>&gt; 	}<br>&gt;        dayString[dayIndex] <br>&gt; <br>&gt; Or for a dictionary:<br>&gt; <br>&gt; 	let chineseNumber = [   “一” : “One”, <br>&gt; 		     “二” : ”Two”,<br>&gt; 					      “三” : ”Three”]<br>&gt; <br>&gt; 	guard  let englishString = englishString else {<br>&gt; 		return “out of range&quot;<br>&gt; 	}<br>&gt; 	return englishString <br>&gt; <br>&gt; Currently dictionaries only produce “nil” if not found so you must handle an optional. <br>&gt; <br>&gt; Proposed solution:<br>&gt; <br>&gt; There approach is to add default to the containers. <br>&gt; <br>&gt; Array:<br>&gt; There is a new syntax which, allows you to choose a default:<br>&gt; <br>&gt; let lookupDayOfWeek = [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday” &lt;&gt; “Invalid Day” ]<br>&gt; <br>&gt; lookupDayOfWeek[1] -&gt; “Monday”<br>&gt; lookupDayOfWeek[9] -&gt; “Invalid Day”<br>&gt; <br>&gt; The &lt;&gt; which is less than greater than. for the else portion, it indicates outside the range of the array as in less than the minimum index and greater than the highest index. It also looks like a diamond when run together so it stands out to clearly show that it is the default case and won’t be confused with the main array. In all other ways the array behaves the same, if you want to get the default value you could do this:<br>&gt; <br>&gt; lookupDayOfWeek[ _ ] -&gt; “Invalid Day”<br>&gt; <br>&gt; Iterating an array with a default would not include the default:<br>&gt; <br>&gt; 	for day in lookupDayOfWeek {<br>&gt; 		print(“Day \(day)”)<br>&gt; 	}<br>&gt; <br>&gt; You would need to do this to get the default (see below for slices):<br>&gt; <br>&gt; 	for day in lookupDayOfWeek[:_] {<br>&gt; 		print(“Day \(day)”)<br>&gt; 	}<br>&gt; <br>&gt; or this would put the default first:<br>&gt; <br>&gt; 	for day in lookupDayOfWeek[_:] {<br>&gt; 		print(“Day \(day)”)<br>&gt; 	}<br>&gt; <br>&gt; Unless there is a better suggestion for this, as this relies on slices. <br>&gt; <br>&gt; Likewise contains() and other operations would not include the default as a result. However, if you were to copy an array with a default it would travel with the array:<br>&gt; <br>&gt; let myOtherArray = lookupDayOfWeek<br>&gt; print(myOtherArray[_])  -&gt; “Invalid Day”<br>&gt; <br>&gt; If we were to adopt slices it would be possible to copy just the main values like this (based upon python slice syntax, speculative because slice syntax is not yet defined. If it is;):<br>&gt; <br>&gt; let myOtherArray = lookupDayOfWeek[:]<br>&gt; print(myOtherArray) -&gt; [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”] <br>&gt; <br>&gt; let myOtherArray = lookupDayOfWeek[:_]<br>&gt; print(myOtherArray -&gt; [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday” &lt;&gt; &quot;Invalid Day”]<br>&gt; <br>&gt; Dictionary:<br>&gt; For a dictionary, we use the _: to indicate none of the above, which is consistent with current dictionary syntax except that it adds the _ case..<br>&gt; <br>&gt; let chineseToEnglishNumber = [   “一&quot; : “One”, <br>&gt; 		         “二&quot;: ”Two”,<br>&gt; 				                      &quot;三&quot;: ”Three”,<br>&gt; 				                        _:  “Out of Range” ]<br>&gt; <br>&gt; print(chineseToEnglishNumber[ “三”]) -&gt; “Three&quot;<br>&gt; print(chineseToEnglishNumber[“四”]) -&gt; “Out of Range”<br>&gt; <br>&gt; This concisely represents what to do if none of the values are usable. No more if let clauses or guards. Diamond &lt;&gt; could be supported here too, but that is optional for this proposal. The dictionary would be handled pretty much as it is today but the underscore-colon lets you give a default. Similarly, you can access the default value by doing this.<br>&gt; <br>&gt; print(chineseToEnglishNumber[_]) -&gt; “Out of Range”<br>&gt; <br>&gt; print(chineseToEnglishNumber.contains(“None”)) -&gt; would return false. <br>&gt; print(chineseToEnglishNumber) -&gt; [&quot;一&quot;: &quot;2&quot;, &quot;二&quot;: &quot;1&quot;, &quot;三&quot;: “3” &lt;&gt; “ Out of Range”]<br>&gt; <br>&gt; Copying the dictionary would include the default but iterating it would not include the default: <br>&gt; <br>&gt; for number in chineseToEnglishNumber {<br>&gt; 	<br>&gt; }<br>&gt; <br>&gt; to include it (this may need work):<br>&gt; <br>&gt; for number in chineseToEnglishNumber[:_] {<br>&gt; 	<br>&gt; }<br>&gt; <br>&gt; since dictionaries are unordered it will not necessarily be at the end..<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Other operators:<br>&gt; Tried single colon and double colon but did not stand out enough and colon might not work if we adopted slices. <br>&gt; <br>&gt; Sets<br>&gt; Thought about sets but not sure that makes sense because you only test existence of a member usually, the following kind makes sense to a point:<br>&gt; <br>&gt; let set = Set(“A”, “B”, “C” &lt;&gt; “D”)<br>&gt; set.contains(“B”) -&gt; true<br>&gt; set.contains(“D”) -&gt; false<br>&gt; set.contains(“F”) -&gt; false<br>&gt; <br>&gt; print(set) -&gt; [“A”, “B”, “C”]<br>&gt; <br>&gt; but typically you are just checking for existence or getting all values so having it return a default does not make sense. <br>&gt; <br>&gt; Map<br>&gt; This came out of the ternary and switch discussions, this could be done with map defaults. If we don’t want to add it to the container types that might be a better way to go. See that thread for more details. <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/9250f26c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal Draft] Concise Default Values for Containers</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 16, 2016 at 08:00:00pm</p></header><div class="content"><p>I think that both of these are new types or, at the very least, protocols.<br>If you are ok with using something other than subscript to access them, a<br>protocol is actually the best bet, in my opinion. With these additions,<br>Array acts as though it has *infinite* length and Dictionary acts as though<br>it holds all members that inhabit the Dictionary.Key type.  That is<br>significant difference in behavior.<br>TJ<br></p><p>On Sat, Jan 16, 2016 at 8:16 PM, Maximilian Hünenberger &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; While I like the idea of a default value I don&#39;t think that you need one<br>&gt; as often.<br>&gt;<br>&gt;<br>&gt; On another thread (&quot;Optional safe subscripting for arrays&quot;) something<br>&gt; similar is being discussed where<br>&gt;<br>&gt; array[safe: 6]<br>&gt;<br>&gt; returns Optionals and your proposal is very similar to<br>&gt;<br>&gt; array[safe: 6] ?? defaultValue<br>&gt; // or probably rewriting this to<br>&gt; array[6, default: defaultValue]<br>&gt;<br>&gt; So these two proposals/threads could be merged.<br>&gt;<br>&gt;<br>&gt; In case of (Python like) slices I&#39;m not sure whether the additional syntax<br>&gt; pays off for its use.<br>&gt;<br>&gt;<br>&gt; Do you have any concrete plan how it could be implemented? As additional<br>&gt; property/closure/DefaultProtocol?<br>&gt; I&#39;m in favor of a closure: () -&gt; Element<br>&gt; since it is like a generator where less weird behaviors can occur due to<br>&gt; referencing classes. (Value types would work (almost) flawlessly with a<br>&gt; stored property)<br>&gt;<br>&gt;<br>&gt; Another note: Could there be a more general way to use &quot;_&quot; as a language<br>&gt; feature? So the proposal would be more likely to be accepted.<br>&gt;<br>&gt;<br>&gt; Best regards<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 17.01.2016 um 00:37 schrieb Paul Ossenbruggen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; This is a preliminary draft, looking for feedback, thanks.<br>&gt;<br>&gt; *Introduction*<br>&gt;<br>&gt; There are many cases where you don’t want to deal with an out of range<br>&gt; lookup in a array or dictionary. There is quite a lot of boilerplate code<br>&gt; to check the range and return a value. This proposal addresses that by<br>&gt; making a concise way of providing a default value in an array or<br>&gt; dictionary. You quickly and safely want to get the value from an array or<br>&gt; dictionary but not have to write a bunch of checks.<br>&gt;<br>&gt; Swift-evolution thread: derived from ternary discussion.<br>&gt;<br>&gt; *Motivation*<br>&gt;<br>&gt; There are many times when you want to map value to another, the range of<br>&gt; input values is beyond the array index. Typically you have to write code<br>&gt; like this;<br>&gt;<br>&gt; let dayString = [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”,<br>&gt; “Friday”, “Saturday”]<br>&gt; guard  dayIndex &gt; 0 &amp;&amp; dayIndex &lt; col..count else {<br>&gt; return “invalid day&quot;<br>&gt; }<br>&gt;        dayString[dayIndex]<br>&gt;<br>&gt; Or for a dictionary:<br>&gt;<br>&gt; let chineseNumber = [   “一” : “One”,<br>&gt;      “二” : ”Two”,<br>&gt;       “三” : ”Three”]<br>&gt;<br>&gt; guard  let englishString = englishString else {<br>&gt; return “out of range&quot;<br>&gt; }<br>&gt; return englishString<br>&gt;<br>&gt; Currently dictionaries only produce “nil” if not found so you must handle<br>&gt; an optional.<br>&gt;<br>&gt; *Proposed solution:*<br>&gt;<br>&gt; There approach is to add default to the containers.<br>&gt;<br>&gt; *Array:*<br>&gt; There is a new syntax which, allows you to choose a default:<br>&gt;<br>&gt;<br>&gt; let lookupDayOfWeek = [“Sunday”, “Monday”, “Tuesday”, “Wednesday”,<br>&gt; “Thursday”, “Friday”, “Saturday” &lt;&gt; “Invalid Day” ]<br>&gt;<br>&gt; lookupDayOfWeek[1] -&gt; “Monday”<br>&gt; lookupDayOfWeek[9] -&gt; “Invalid Day”<br>&gt;<br>&gt;<br>&gt; The &lt;&gt; which is less than greater than. for the else portion, it<br>&gt; indicates outside the range of the array as in less than the minimum index<br>&gt; and greater than the highest index. It also looks like a diamond when run<br>&gt; together so it stands out to clearly show that it is the default case and<br>&gt; won’t be confused with the main array. In all other ways the array behaves<br>&gt; the same, if you want to get the default value you could do this:<br>&gt;<br>&gt; lookupDayOfWeek[ _ ] -&gt; “Invalid Day”<br>&gt;<br>&gt;<br>&gt; Iterating an array with a default would not include the default:<br>&gt;<br>&gt; for day in lookupDayOfWeek {<br>&gt; print(“Day \(day)”)<br>&gt; }<br>&gt;<br>&gt; You would need to do this to get the default (see below for slices):<br>&gt;<br>&gt; for day in lookupDayOfWeek[:_] {<br>&gt; print(“Day \(day)”)<br>&gt; }<br>&gt;<br>&gt; or this would put the default first:<br>&gt;<br>&gt; for day in lookupDayOfWeek[_:] {<br>&gt; print(“Day \(day)”)<br>&gt; }<br>&gt;<br>&gt; Unless there is a better suggestion for this, as this relies on slices.<br>&gt;<br>&gt; Likewise contains() and other operations would not include the default as<br>&gt; a result. However, if you were to copy an array with a default it would<br>&gt; travel with the array:<br>&gt;<br>&gt; let myOtherArray = lookupDayOfWeek<br>&gt; print(myOtherArray[_])  -&gt; “Invalid Day”<br>&gt;<br>&gt; If we were to adopt slices it would be possible to copy just the main<br>&gt; values like this (based upon python slice syntax, speculative because slice<br>&gt; syntax is not yet defined. If it is;):<br>&gt;<br>&gt; let myOtherArray = lookupDayOfWeek[:]<br>&gt; print(myOtherArray) -&gt; [“Sunday”, “Monday”, “Tuesday”, “Wednesday”,<br>&gt; “Thursday”, “Friday”, “Saturday”]<br>&gt;<br>&gt; let myOtherArray = lookupDayOfWeek[:_]<br>&gt; print(myOtherArray -&gt; [“Sunday”, “Monday”, “Tuesday”, “Wednesday”,<br>&gt; “Thursday”, “Friday”, “Saturday” &lt;&gt; &quot;Invalid Day”]<br>&gt;<br>&gt;<br>&gt; *Dictionary:*<br>&gt; For a dictionary, we use the _: to indicate none of the above, which is<br>&gt; consistent with current dictionary syntax except that it adds the _ case..<br>&gt;<br>&gt; let chineseToEnglishNumber = [   “一&quot; : “One”,<br>&gt;          “二&quot;: ”Two”,<br>&gt;                       &quot;三&quot;: ”Three”,<br>&gt;                         _:  “Out of Range” ]<br>&gt;<br>&gt; print(chineseToEnglishNumber[ “三”]) -&gt; “Three&quot;<br>&gt; print(chineseToEnglishNumber[“四”]) -&gt; “Out of Range”<br>&gt;<br>&gt; This concisely represents what to do if none of the values are usable. No<br>&gt; more if let clauses or guards. Diamond &lt;&gt; could be supported here too,<br>&gt; but that is optional for this proposal. The dictionary would be handled<br>&gt; pretty much as it is today but the underscore-colon lets you give a<br>&gt; default. Similarly, you can access the default value by doing this.<br>&gt;<br>&gt; print(chineseToEnglishNumber[_]) -&gt; “Out of Range”<br>&gt;<br>&gt; print(chineseToEnglishNumber.contains(“None”)) -&gt; would return false.<br>&gt; print(chineseToEnglishNumber) -&gt; [&quot;一&quot;: &quot;2&quot;, &quot;二&quot;: &quot;1&quot;, &quot;三&quot;: “3” &lt;&gt; “ Out<br>&gt; of Range”]<br>&gt;<br>&gt;<br>&gt; Copying the dictionary would include the default but iterating it would<br>&gt; not include the default:<br>&gt;<br>&gt; for number in chineseToEnglishNumber {<br>&gt; }<br>&gt;<br>&gt;<br>&gt; to include it (this may need work):<br>&gt;<br>&gt; for number in chineseToEnglishNumber[:_] {<br>&gt; }<br>&gt;<br>&gt;<br>&gt; since dictionaries are unordered it will not necessarily be at the end..<br>&gt;<br>&gt;<br>&gt; *Alternatives considered*<br>&gt;<br>&gt; *Other operators:*<br>&gt; Tried single colon and double colon but did not stand out enough and colon<br>&gt; might not work if we adopted slices.<br>&gt;<br>&gt; *Sets*<br>&gt; Thought about sets but not sure that makes sense because you only test<br>&gt; existence of a member usually, the following kind makes sense to a point:<br>&gt;<br>&gt; let set = Set(“A”, “B”, “C” &lt;&gt; “D”)<br>&gt; set.contains(“B”) -&gt; true<br>&gt; set.contains(“D”) -&gt; false<br>&gt; set.contains(“F”) -&gt; false<br>&gt;<br>&gt; print(set) -&gt; [“A”, “B”, “C”]<br>&gt;<br>&gt; but typically you are just checking for existence or getting all values so<br>&gt; having it return a default does not make sense.<br>&gt;<br>&gt; *Map*<br>&gt; This came out of the ternary and switch discussions, this could be done<br>&gt; with map defaults. If we don’t want to add it to the container types that<br>&gt; might be a better way to go. See that thread for more details.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/080279a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Proposal Draft] Concise Default Values for Containers</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>January 18, 2016 at 01:00:00pm</p></header><div class="content"><p>I am not sure I would be in favor of additional syntax for something like this. I think that those who want it could write extensions for Array and Dictionary and do the following instead:<br></p><p>let value = array.objectAtIndex(i, default: defaultValue)<br></p><p>let value = dict.objectForKey(key, default: defaultValue)<br></p><p><br>&gt; On Jan 16, 2016, at 8:28 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think that both of these are new types or, at the very least, protocols. If you are ok with using something other than subscript to access them, a protocol is actually the best bet, in my opinion. With these additions, Array acts as though it has *infinite* length and Dictionary acts as though it holds all members that inhabit the Dictionary.Key type.  That is significant difference in behavior.<br>&gt; TJ<br>&gt; <br>&gt;&gt; On Sat, Jan 16, 2016 at 8:16 PM, Maximilian Hünenberger &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; While I like the idea of a default value I don&#39;t think that you need one as often.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On another thread (&quot;Optional safe subscripting for arrays&quot;) something similar is being discussed where<br>&gt;&gt; <br>&gt;&gt; array[safe: 6]<br>&gt;&gt; <br>&gt;&gt; returns Optionals and your proposal is very similar to<br>&gt;&gt; <br>&gt;&gt; array[safe: 6] ?? defaultValue<br>&gt;&gt; // or probably rewriting this to<br>&gt;&gt; array[6, default: defaultValue]<br>&gt;&gt; <br>&gt;&gt; So these two proposals/threads could be merged.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In case of (Python like) slices I&#39;m not sure whether the additional syntax pays off for its use.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Do you have any concrete plan how it could be implemented? As additional property/closure/DefaultProtocol?<br>&gt;&gt; I&#39;m in favor of a closure: () -&gt; Element<br>&gt;&gt; since it is like a generator where less weird behaviors can occur due to referencing classes. (Value types would work (almost) flawlessly with a stored property)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Another note: Could there be a more general way to use &quot;_&quot; as a language feature? So the proposal would be more likely to be accepted.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Best regards<br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 17.01.2016 um 00:37 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a preliminary draft, looking for feedback, thanks. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are many cases where you don’t want to deal with an out of range lookup in a array or dictionary. There is quite a lot of boilerplate code to check the range and return a value. This proposal addresses that by making a concise way of providing a default value in an array or dictionary. You quickly and safely want to get the value from an array or dictionary but not have to write a bunch of checks. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: derived from ternary discussion. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are many times when you want to map value to another, the range of input values is beyond the array index. Typically you have to write code like this;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let dayString = [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”]<br>&gt;&gt;&gt; 	guard  dayIndex &gt; 0 &amp;&amp; dayIndex &lt; col..count else {<br>&gt;&gt;&gt; 		return “invalid day&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;        dayString[dayIndex] <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or for a dictionary:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let chineseNumber = [   “一” : “One”, <br>&gt;&gt;&gt; 		     “二” : ”Two”,<br>&gt;&gt;&gt; 					      “三” : ”Three”]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	guard  let englishString = englishString else {<br>&gt;&gt;&gt; 		return “out of range&quot;<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	return englishString <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently dictionaries only produce “nil” if not found so you must handle an optional. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There approach is to add default to the containers. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Array:<br>&gt;&gt;&gt; There is a new syntax which, allows you to choose a default:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let lookupDayOfWeek = [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday” &lt;&gt; “Invalid Day” ]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; lookupDayOfWeek[1] -&gt; “Monday”<br>&gt;&gt;&gt; lookupDayOfWeek[9] -&gt; “Invalid Day”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The &lt;&gt; which is less than greater than. for the else portion, it indicates outside the range of the array as in less than the minimum index and greater than the highest index. It also looks like a diamond when run together so it stands out to clearly show that it is the default case and won’t be confused with the main array. In all other ways the array behaves the same, if you want to get the default value you could do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; lookupDayOfWeek[ _ ] -&gt; “Invalid Day”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Iterating an array with a default would not include the default:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	for day in lookupDayOfWeek {<br>&gt;&gt;&gt; 		print(“Day \(day)”)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You would need to do this to get the default (see below for slices):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	for day in lookupDayOfWeek[:_] {<br>&gt;&gt;&gt; 		print(“Day \(day)”)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or this would put the default first:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	for day in lookupDayOfWeek[_:] {<br>&gt;&gt;&gt; 		print(“Day \(day)”)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless there is a better suggestion for this, as this relies on slices. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Likewise contains() and other operations would not include the default as a result. However, if you were to copy an array with a default it would travel with the array:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let myOtherArray = lookupDayOfWeek<br>&gt;&gt;&gt; print(myOtherArray[_])  -&gt; “Invalid Day”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we were to adopt slices it would be possible to copy just the main values like this (based upon python slice syntax, speculative because slice syntax is not yet defined. If it is;):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let myOtherArray = lookupDayOfWeek[:]<br>&gt;&gt;&gt; print(myOtherArray) -&gt; [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”] <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let myOtherArray = lookupDayOfWeek[:_]<br>&gt;&gt;&gt; print(myOtherArray -&gt; [“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday” &lt;&gt; &quot;Invalid Day”]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dictionary:<br>&gt;&gt;&gt; For a dictionary, we use the _: to indicate none of the above, which is consistent with current dictionary syntax except that it adds the _ case..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let chineseToEnglishNumber = [   “一&quot; : “One”, <br>&gt;&gt;&gt; 		         “二&quot;: ”Two”,<br>&gt;&gt;&gt; 				                      &quot;三&quot;: ”Three”,<br>&gt;&gt;&gt; 				                        _:  “Out of Range” ]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(chineseToEnglishNumber[ “三”]) -&gt; “Three&quot;<br>&gt;&gt;&gt; print(chineseToEnglishNumber[“四”]) -&gt; “Out of Range”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This concisely represents what to do if none of the values are usable. No more if let clauses or guards. Diamond &lt;&gt; could be supported here too, but that is optional for this proposal. The dictionary would be handled pretty much as it is today but the underscore-colon lets you give a default. Similarly, you can access the default value by doing this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(chineseToEnglishNumber[_]) -&gt; “Out of Range”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(chineseToEnglishNumber.contains(“None”)) -&gt; would return false. <br>&gt;&gt;&gt; print(chineseToEnglishNumber) -&gt; [&quot;一&quot;: &quot;2&quot;, &quot;二&quot;: &quot;1&quot;, &quot;三&quot;: “3” &lt;&gt; “ Out of Range”]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Copying the dictionary would include the default but iterating it would not include the default: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for number in chineseToEnglishNumber {<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to include it (this may need work):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for number in chineseToEnglishNumber[:_] {<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; since dictionaries are unordered it will not necessarily be at the end..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other operators:<br>&gt;&gt;&gt; Tried single colon and double colon but did not stand out enough and colon might not work if we adopted slices. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sets<br>&gt;&gt;&gt; Thought about sets but not sure that makes sense because you only test existence of a member usually, the following kind makes sense to a point:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let set = Set(“A”, “B”, “C” &lt;&gt; “D”)<br>&gt;&gt;&gt; set.contains(“B”) -&gt; true<br>&gt;&gt;&gt; set.contains(“D”) -&gt; false<br>&gt;&gt;&gt; set.contains(“F”) -&gt; false<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(set) -&gt; [“A”, “B”, “C”]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but typically you are just checking for existence or getting all values so having it return a default does not make sense. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Map<br>&gt;&gt;&gt; This came out of the ternary and switch discussions, this could be done with map defaults. If we don’t want to add it to the container types that might be a better way to go. See that thread for more details. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/c1b45588/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 18, 2016 at 04:00:00pm</p></header><div class="content"><p>Few questions:<br></p><p>1 - This model has any optimization opportunities in mind? Like allow the<br>compiler optimize calls over behaviors?<br></p><p>2 - Will be possible compose behaviors and resuse, like:<br>typealias lazyObserver = [lazy,observer]<br></p><p>3 - &quot;var behavior&quot; will make unusual create any other property called<br>behavior. Its not better make behavior a reserved word like &quot;protocol&quot; and<br>use then? protocol is also a valid identifier.<br></p><p>4 - Will be provided any implementation of standard library of any other<br>behavior like &quot;lazy&quot;, &quot;observer&quot;?<br></p><p>5 - How to handle with behavior name collision? If two modules define the<br>same behavior name, can be handled using full name (module.behavior)?<br></p><p>Em sáb, 16 de jan de 2016 às 17:27, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt;<br>&gt; On Jan 15, 2016, at 5:54 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 15, 2016, at 7:45 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 15, 2016, at 6:42 AM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; One more “how will this work?” question: optionals.<br>&gt;<br>&gt; Specifically, consider something like this:<br>&gt;<br>&gt; // annoyingly-long protocol:<br>&gt; protocol ControlExchanging {<br>&gt;   typealias Context<br>&gt;   func willTakeControlFrom(other: Self?, context: Context)<br>&gt;   func didTakeControlFrom(other: Self?, context: Context)<br>&gt;<br>&gt;   func takeControl(context: Context)<br>&gt;   func cedeControl(context: Context)<br>&gt;<br>&gt;   func willCedeControlTo(other: Self?, context: Context)<br>&gt;   func didCedeControlTo(other: Self?, context: Context)<br>&gt; }<br>&gt;<br>&gt; var behavior exchangeState&lt;Value:ControlExchanging where<br>&gt; Self:Value.Context&gt; : Value {<br>&gt;   var value: Value<br>&gt;   // here:<br>&gt;   set {<br>&gt;     let oldValue = value<br>&gt;     // boilerplate-choreography begins:<br>&gt;     newValue.willTakeControlFrom(oldValue, context: self)<br>&gt;     oldValue.willCedeControlTo(newValue, context: self)<br>&gt;     oldValue.cedeControl(self)<br>&gt;     value = newValue<br>&gt;     newValue.takeControl(self)<br>&gt;     oldValue.didCedeControlTo(newValue, context: self)<br>&gt;     newValue.didTakeControlFrom(oldValue, context: self)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; // numerous extraneous details omitted:<br>&gt; class GenericSwitchboard&lt;Delegate:ControlExchanging were Delegate.Context<br>&gt; == Self&gt; {<br>&gt;<br>&gt;   private(set) weak var [exchangeControl] delegate: Delegate? = nil<br>&gt;<br>&gt; }<br>&gt;<br>&gt; …which presumably won’t actually work unless I’ve either:<br>&gt;<br>&gt; - added an additional implementation that’s typed-as `Value?`<br>&gt; - added a conditional-conformance for `ControlExchanging` to `Optional`<br>&gt; (easy, but boilerplate)<br>&gt;<br>&gt; ….both of which are workable, neither of which feels optimal (and for the<br>&gt; latter, consider also that in many cases such conformances may generally be<br>&gt; undesirable).<br>&gt;<br>&gt; Is there a trick/detail I’m missing here?<br>&gt;<br>&gt;<br>&gt; No, I think you&#39;ve got it. This seems like a general problem to me,<br>&gt; though; it&#39;d be nice if protocol conformances could be easily forwarded,<br>&gt; for instance from Optional&lt;T&gt; to T.<br>&gt;<br>&gt;<br>&gt; Any thoughts about how that might work when requirements have a return<br>&gt; value?  Or are you just referring to forwarding conformances when the<br>&gt; protocol doesn’t have members  with return values?<br>&gt;<br>&gt;<br>&gt; I don&#39;t have a great answer in mind, unfortunately. You&#39;re right that it<br>&gt; only really makes sense for &quot;sink&quot;-like protocols, where none of the<br>&gt; requirements produce a value, or theoretically for protocols where all<br>&gt; results are of associated types that could be optionalized. The sink<br>&gt; protocol use case comes up all the time, though, especially with delegates<br>&gt; and callbacks, and is one the places where ObjC&#39;s nil-messaging behavior<br>&gt; feels legitimate.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/37d5a2f2/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 8:58 AM, Wallacy &lt;wallacyf at gmail.com&gt; wrote:<br>&gt; <br>&gt; Few questions:<br>&gt; <br>&gt; 1 - This model has any optimization opportunities in mind? Like allow the compiler optimize calls over behaviors?<br></p><p>Yeah, the proposal is designed to avoid overhead for the behavior abstraction. By avoiding defining a type for behaviors, we avoid the runtime metadata cost of a generic type. By binding the initializers and accessors of the behavior specially, we avoid needing to store state in the instance of a type using a behavior to carry those parameters from initialization to access. For compile-time speed, we will likely need to generate functions and global data structures in debug builds, but these should all be inlineable in production builds.<br></p><p>&gt; 2 - Will be possible compose behaviors and resuse, like:<br>&gt; typealias lazyObserver = [lazy,observer]<br></p><p>Not as stated. We could add behavior aliases or compositions if we wanted to later.<br></p><p>&gt; 3 - &quot;var behavior&quot; will make unusual create any other property called behavior. Its not better make behavior a reserved word like &quot;protocol&quot; and use then? protocol is also a valid identifier.<br></p><p>The &#39;behavior&#39; keyword can be contextual, since &#39;var behavior &lt;identifier&gt;&#39; isn&#39;t otherwise legal syntax. You could still name a property or function &#39;behavior&#39;.<br></p><p>&gt; <br>&gt; 4 - Will be provided any implementation of standard library of any other behavior like &quot;lazy&quot;, &quot;observer&quot;?<br></p><p>I think we&#39;ll want to make &#39;lazy&#39; and &#39;observer&#39; into behaviors, but further standard library improvements should be discussed separately.<br></p><p>&gt; <br>&gt; 5 - How to handle with behavior name collision? If two modules define the same behavior name, can be handled using full name (module.behavior)?<br></p><p>Yes.<br></p><p>-Joe<br></p><p>&gt; Em sáb, 16 de jan de 2016 às 17:27, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escreveu:<br>&gt; <br>&gt;&gt; On Jan 15, 2016, at 5:54 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 15, 2016, at 7:45 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 15, 2016, at 6:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One more “how will this work?” question: optionals.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Specifically, consider something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // annoyingly-long protocol:<br>&gt;&gt;&gt;&gt; protocol ControlExchanging {<br>&gt;&gt;&gt;&gt;   typealias Context<br>&gt;&gt;&gt;&gt;   func willTakeControlFrom(other: Self?, context: Context)<br>&gt;&gt;&gt;&gt;   func didTakeControlFrom(other: Self?, context: Context)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;   func takeControl(context: Context)<br>&gt;&gt;&gt;&gt;   func cedeControl(context: Context)<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;   func willCedeControlTo(other: Self?, context: Context)<br>&gt;&gt;&gt;&gt;   func didCedeControlTo(other: Self?, context: Context)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var behavior exchangeState&lt;Value:ControlExchanging where Self:Value.Context&gt; : Value {<br>&gt;&gt;&gt;&gt;   var value: Value<br>&gt;&gt;&gt;&gt;   // here:<br>&gt;&gt;&gt;&gt;   set { <br>&gt;&gt;&gt;&gt;     let oldValue = value<br>&gt;&gt;&gt;&gt;     // boilerplate-choreography begins:<br>&gt;&gt;&gt;&gt;     newValue.willTakeControlFrom(oldValue, context: self)<br>&gt;&gt;&gt;&gt;     oldValue.willCedeControlTo(newValue, context: self)<br>&gt;&gt;&gt;&gt;     oldValue.cedeControl(self)<br>&gt;&gt;&gt;&gt;     value = newValue<br>&gt;&gt;&gt;&gt;     newValue.takeControl(self)<br>&gt;&gt;&gt;&gt;     oldValue.didCedeControlTo(newValue, context: self)<br>&gt;&gt;&gt;&gt;     newValue.didTakeControlFrom(oldValue, context: self)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // numerous extraneous details omitted:<br>&gt;&gt;&gt;&gt; class GenericSwitchboard&lt;Delegate:ControlExchanging were Delegate.Context == Self&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   private(set) weak var [exchangeControl] delegate: Delegate? = nil<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …which presumably won’t actually work unless I’ve either:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - added an additional implementation that’s typed-as `Value?` <br>&gt;&gt;&gt;&gt; - added a conditional-conformance for `ControlExchanging` to `Optional` (easy, but boilerplate)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ….both of which are workable, neither of which feels optimal (and for the latter, consider also that in many cases such conformances may generally be undesirable).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a trick/detail I’m missing here?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, I think you&#39;ve got it. This seems like a general problem to me, though; it&#39;d be nice if protocol conformances could be easily forwarded, for instance from Optional&lt;T&gt; to T.<br>&gt;&gt; <br>&gt;&gt; Any thoughts about how that might work when requirements have a return value?  Or are you just referring to forwarding conformances when the protocol doesn’t have members  with return values?<br>&gt; <br>&gt; I don&#39;t have a great answer in mind, unfortunately. You&#39;re right that it only really makes sense for &quot;sink&quot;-like protocols, where none of the requirements produce a value, or theoretically for protocols where all results are of associated types that could be optionalized. The sink protocol use case comes up all the time, though, especially with delegates and callbacks, and is one the places where ObjC&#39;s nil-messaging behavior feels legitimate.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/01fefcc4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 14, 2016, at 4:05 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 14, 2016, at 11:33 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the earlier feedback (you did mention how to resolve reference ambiguity).<br>&gt;&gt; <br>&gt;&gt; After re-reading it this is a really nice proposal overall. Even in it’s current state it is a huge upgrade, and could lead to a huge productivity / implementation-quality upgrade in application code.<br>&gt;&gt; <br>&gt;&gt; I do have a bunch of questions, though.<br>&gt;&gt; <br>&gt;&gt; ## Syntax: “In the Large”<br>&gt;&gt; <br>&gt;&gt; One thing that does worry me is readability in real-world variable declarations; I agree that `@behavior(lazy)` is clunky in the small, but in the large the current syntax is questionable:<br>&gt;&gt; <br>&gt;&gt; class SomeView : UIView {<br>&gt;&gt; <br>&gt;&gt;  @IBInspectable<br>&gt;&gt;   public internal(set) weak var [mainThread,resettable,logged,changeObserved] contentAreaInsets: UIEdgeInsets = UIEdgeInsetsZero {<br>&gt;&gt;    logName { “contentAreaInsets” } // &lt;- see note later, btw<br>&gt;&gt;    didChange { setNeedsUpdateConstraints() }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which is admittedly an extreme example, but it illustrates the point.<br>&gt;&gt; <br>&gt;&gt; The below is definitely worse in the small, but feels better in the large:<br>&gt;&gt; <br>&gt;&gt; class SomeView : UIView {<br>&gt;&gt; <br>&gt;&gt;  @IBInspectable<br>&gt;&gt;  @behavior(mainThread,resettable,logged,changeObserved) <br>&gt;&gt;  public internal(set) weak var contentAreaInsets: UIEdgeInsets = UIEdgeInsetsZero {<br>&gt;&gt;    logName { “contentAreaInsets” } // &lt;- see note later, btw<br>&gt;&gt;    didChange { setNeedsUpdateConstraints() }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …(I could add line breaks in the first one, but a line break anywhere between the `var` and its the name seems odd).<br>&gt;&gt; <br>&gt;&gt; To be clear, I am not suggesting the above syntax as-is; I am more trying to make sure some consideration is “how does this look with longer behavior lists”, since all the examples in the proposal are for “nice” cases.<br>&gt;&gt; <br>&gt;&gt; Putting the behavior-list after `var` but before the name and type seems unfortunate once you want to add a line-break in there.<br>&gt; <br>&gt; Good point. Longer behavior compositions are something to consider. If behaviors have dedicated declarations instead of being applications of plain types or functions, it also becomes more reasonable to let them be used as attributes by themselves:<br>&gt; <br>&gt; @mainThread @resettable @logged @changeObserved<br>&gt; public var foo: Int { ... }<br>&gt; <br>&gt; I shied away from that design originally because it would be problematic to pollute the attribute namespace with potentially every function and/or type. That&#39;s less of a problem with this design.<br>&gt; <br>&gt;&gt; ## Request: Declared-Property-Name<br>&gt;&gt; <br>&gt;&gt; If possible, a property analogous to `self` / `parent` / etc. getting at a behavior’s concrete “declared-name” would be amazing, although I know it’s not quite that easy, either (see @objc questions later).<br>&gt; <br>&gt; That&#39;s definitely an interesting extension to consider. I think it can be separated from the core proposal, though.<br>&gt; <br>&gt;&gt; ## Semantics: Overrides + Behaviors<br>&gt;&gt; <br>&gt;&gt; I think this is probably specified somewhere and I just don’t understand it, but I need to ask: how do overrides work for things like the following example:<br>&gt;&gt; <br>&gt;&gt; class BaseView : UIView {<br>&gt;&gt; <br>&gt;&gt;  var [changeObserved] text: String {<br>&gt;&gt;    didChange { setNeedsLayout() }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class RefinedView : BaseView {<br>&gt;&gt; <br>&gt;&gt;  // is this right? (recall property is already `changeObserved` in parent):<br>&gt;&gt;  override var text: String {<br>&gt;&gt;    didChange { invalidateIntrinsicContentSize() } <br>&gt;&gt;    // ^ does parent’s didChange get called also? can I control that?<br>&gt;&gt;    // ^ when is this override called? when is the parent called (if it is)?<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  // or is this right? (needing to add another `changeObserved` here?)<br>&gt;&gt;  override var [changeObserved] text: String {<br>&gt;&gt;    didChange { invalidateIntrinsicContentSize() }<br>&gt;&gt;    // ^ does parent’s didChange get called also? can I control that?<br>&gt;&gt;    // ^ when is this override called? when is the parent called (if it is)?<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …I’m really not sure which of the above is more reasonable. <br>&gt;&gt; <br>&gt;&gt; The first variant would seem to have confusing timing (when do the calls happen relative to each other and to other behaviors)?<br>&gt;&gt; <br>&gt;&gt; The other one seems to introduce a new, identically-named behavior, which seems like it’d lead to ambiguity if you had to use behavior methods/behavior properties.<br>&gt; <br>&gt; I would expect each override&#39;s [changeObserved] behavior to wrap the previous override, as happens if you override with `didSet`/`willSet` today. You raise the interesting question of what happens with the behavior names, since you do end up with two same-named behaviors applied at different times. That potentially requires deeper qualification by type; if we use Tal&#39;s suggested `.[behavior]` qualification syntax, you could refer to `.[BaseView.changeObserved]` and `.[RefinedView.changeObserved]` if you needed to.<br>&gt; <br>&gt;&gt; ## Semantics: Redundancy/“Static” Parameterization<br>&gt;&gt; <br>&gt;&gt; This is an extended example, but it sort-of has to be to illustrate the concern.<br>&gt;&gt; <br>&gt;&gt; Suppose we wanted to define a bunch of behaviors useful for use on UIView. I’ll provide a few examples, including just the `set` logic to keep it as short as possible:<br>&gt;&gt; <br>&gt;&gt; // goal: `redraw` automatically calls `setNeedsDisplay()` when necessary:<br>&gt;&gt; var behavior redraw&lt;Value:Equatable where Self:UIView&gt; : Value {<br>&gt;&gt;  set { <br>&gt;&gt;    if newValue != value {<br>&gt;&gt;      value = newValue<br>&gt;&gt;      self.setNeedsDisplay()<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // goal: `invalidateSize` automatically calls `invalidateIntrinsicContentSize()` when necessary:<br>&gt;&gt; var behavior invalidateSize&lt;Value:Equatable where Self:UIView&gt; : Value {<br>&gt;&gt;  set { <br>&gt;&gt;    if newValue != value {<br>&gt;&gt;      value = newValue<br>&gt;&gt;      self.invalidateIntrinsicContentSize()<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …(and you can consider also `relayout`, `updateConstraints`, `updateFocus`, accessibility utilities, and so on…).<br>&gt;&gt; <br>&gt;&gt; With all those in hand, we arrive at something IMHO really nice and self-documenting:<br>&gt;&gt; <br>&gt;&gt; class CustomDrawnView : UIView {<br>&gt;&gt; <br>&gt;&gt;  // pure-redrawing:<br>&gt;&gt;  var [redraw] strokeWidth: CGFloat<br>&gt;&gt;  var [redraw] outlineWidth: CGFloat<br>&gt;&gt;  var [redraw] strokeColor: UIColor<br>&gt;&gt;  var [redraw] outlineColor: UIColor<br>&gt;&gt; <br>&gt;&gt;  // also size-impacting:<br>&gt;&gt;  var [redraw, invalidateSize] iconPath: UIBezierPath<br>&gt;&gt;  var [redraw, invalidateSize] captionText: String<br>&gt;&gt;  var [redraw, invalidateSize] verticalSpace: CGFloat<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …but if you “expand” what happens within these behaviors, once you have multiple such behaviors in a chain (e.g. `[redraw, invalidateSize]`) you will of course have one `!=` comparison per behavior. Note that although, in this case, `!=` is hopefully not too expensive, you can also consider it as a proxy here for other, possibly-expensive operations.<br>&gt;&gt; <br>&gt;&gt; On the one hand, it seems like it ought to be possible to do better here — e.g., do a single such check, not one per behavior — but on the other hand, it seems hard to augment the proposal to make it possible w/out also making it much more complex than it already is.<br>&gt;&gt; <br>&gt;&gt; EG: the best hope from a readability standpoint might be something like this behavior:<br>&gt;&gt; <br>&gt;&gt; var behavior invalidate&lt;Value:Equatable where Self:UIView&gt; {<br>&gt;&gt;  // `parameter` here is new syntax; explanation below<br>&gt;&gt;  parameter display: Bool = false<br>&gt;&gt;  parameter intrinsicSize: Bool = false<br>&gt;&gt; <br>&gt;&gt;  // as-before:<br>&gt;&gt;  var value: Value<br>&gt;&gt; <br>&gt;&gt;  // `get` omitted: <br>&gt;&gt;  set {<br>&gt;&gt;    if newValue != value {<br>&gt;&gt;      value = newValue<br>&gt;&gt;      if display { self.setNeedsDisplay() }<br>&gt;&gt;      if intrinsicSize { self.invalidateIntrinsicContentSize() }<br>&gt;&gt;      // also imagine constraints, layout, etc.<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …but to achieve that “omnibus” capability you’d need a lot of flags, each of which:<br>&gt;&gt; <br>&gt;&gt; - needs to get set somehow (without terrible syntax)<br>&gt;&gt; - needs to get “stored&quot; somehow (without bloating the behaviors, if possible)<br>&gt;&gt; <br>&gt;&gt; Syntax to set the flags seems awkward at best:<br>&gt;&gt; <br>&gt;&gt; // this seems close to ideal for such parameters:<br>&gt;&gt; var [invalidate(display,intrinsicSize)] iconPath: UIBezierPath<br>&gt;&gt; <br>&gt;&gt; // but this seems the best-achievable option w/out dedicated compiler magic:<br>&gt;&gt; var [invalidate(display=true, intrinsicSize=true)] iconPath: UIBezierPath<br>&gt;&gt; <br>&gt;&gt; …and at least to my eyes that &quot;best-achievable syntax&quot; isn’t all that great, anymore.<br>&gt;&gt; <br>&gt;&gt; Likewise you’d need some way to actually store those parameters, presumably *not* as ordinary stored fields — that’s going to bloat the behaviors! — but as some new thing, whence the new `parameter` keyword.<br>&gt;&gt; <br>&gt;&gt; Between that and the naming/parameter-passing, it feels like a big ask, probably too big.<br>&gt;&gt; <br>&gt;&gt; FWIW, for sake of comparison, this seems to be about the best you can do under the current proposal:<br>&gt;&gt; <br>&gt;&gt; class CustomDrawnView : UIView {<br>&gt;&gt; <br>&gt;&gt;  // pure-redrawing:<br>&gt;&gt;  var [changeObserved] strokeWidth: CGFloat {<br>&gt;&gt;    didChange { invalidate(.Display) }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  var [changeObserved] outlineWidth: CGFloat {<br>&gt;&gt;    didChange { invalidate(.Display) }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  var [changeObserved] strokeColor: UIColor {<br>&gt;&gt;    didChange { invalidate(.Display) }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  var [changeObserved] outlineColor: UIColor {<br>&gt;&gt;    didChange { invalidate(.Display) }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  // also size-impacting:<br>&gt;&gt;  var [changeObserved] iconPath: UIBezierPath {<br>&gt;&gt;    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  var [changeObserved] captionText: String {<br>&gt;&gt;    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  var [changeObserved] verticalSpace: CGFloat {<br>&gt;&gt;    didChange { invalidate([.Display, .IntrinsicContentSize]) }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …where `invalidate` is taking some bitmask/option-set and then calling the appropriate view methods.<br>&gt;&gt; <br>&gt;&gt; This isn’t terrible, it’s just nowhere near what it might be under this proposal.<br>&gt;&gt; <br>&gt;&gt; I also think it’s perfectly reasonable to see the above and decide the likely complexity of a solution probably outweighs whatever gains it might bring; I’m just bringing it up in hopes there might be an easy way to have most of the cake and also eat most of the cake.<br>&gt; <br>&gt; It seems to me you could factor at least some of this boilerplate into a behavior, reducing it to:<br>&gt; <br>&gt; var [invalidate] foo: String { invalidates { return [.Display, .ContentSize] } }<br>&gt; <br>&gt; Brent mentioned in the other thread about modeling `lazy` with an accessor some possibilities to whittle this down further, by allowing for implicit single-expression return in accessors, and inferring behaviors from accessor names:<br>&gt; <br>&gt; var foo: String { invalidates { [.Display, .ContentSize] } }<br></p><p>+1 to allowing implicit single-expression return.  Is there a reason this isn’t possible everywhere we can return a value?  It seems to me like that is an orthogonal issue and a proposal to allow it everywhere might be a good idea.<br></p><p>&gt; <br>&gt;&gt; ## ObjC Interaction<br>&gt;&gt; <br>&gt;&gt; One thing I am not sure about is how this interacts with @objc annotations. <br>&gt;&gt; <br>&gt;&gt; First, my assumption is that, as today, property behaviors and @objc-visibilty are essentially orthogonal (don’t really impact each other). This doesn’t seem to be stated explicitly anywhere, and it would be preserving the status quo, but it’s worth confirming just to be sure.<br>&gt;&gt; <br>&gt;&gt; Secondly, right now one of the language’s minor warts is you can’t really get proper objective-c property names on some read-write properties without some doing.<br>&gt;&gt; <br>&gt;&gt; You can either do this:<br>&gt;&gt; <br>&gt;&gt; class Foo: NSObject {<br>&gt;&gt;  @objc(isPermitted)<br>&gt;&gt;  var permitted: Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which gets you `isPermitted` (good) and `setIsPermitted:` (not ideal), or you can do this:<br>&gt;&gt; <br>&gt;&gt; class Foo: NSObject {<br>&gt;&gt; <br>&gt;&gt;  @nonobjc // maximize chances of efficiency<br>&gt;&gt;  private final var _permitted: Bool<br>&gt;&gt; <br>&gt;&gt;  var permitted: Bool {<br>&gt;&gt;    @objc(isPermitted) get { return _permitted }<br>&gt;&gt;    @objc(setPermitted:) set { _permitted = newValue }<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which gets the right Objective-C names but is quite clunky.<br>&gt;&gt; <br>&gt;&gt; What you can’t do is this:<br>&gt;&gt; <br>&gt;&gt; class Foo: NSObject {<br>&gt;&gt;  var permitted: Bool {<br>&gt;&gt;   @objc(isPermitted) get, // just rename<br>&gt;&gt;   @objc(setPermitted:) set // just rename <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …at least not to my knowledge; if there’s a trick I don’t know it.<br>&gt; <br>&gt; You could potentially declare another @objc property that forwards to the stored property, though that&#39;s even less ideal of course:<br>&gt; <br>&gt; var permitted: Bool<br>&gt; private var _objcPermitted: Bool {<br>&gt;   @objc(isPermitted) get { return _permitted }<br>&gt;   @objc(setPermitted:) set { _permitted = newValue }<br>&gt; }<br>&gt; <br>&gt; Behaviors definitely exacerbate this issue, since you have more interesting properties without native get/set accessors that you may want to control the ObjC interface for. The private @objc trick above at least still works.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On the one hand, this proposal doesn’t seem to change this situation.<br>&gt;&gt; <br>&gt;&gt; On the other hand, if it can be changed, this seems like a reasonable time/place to do it.<br>&gt;&gt; <br>&gt;&gt; That’s it for the moment.<br>&gt;&gt; <br>&gt;&gt; With this proposal it seems like a really nice feature to have.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 8:04 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:12 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Quick Q1: is it the case that `var behavior redrawing&lt;Value where Self:UIView&gt; : Value { … } ` would work or no? I’d assume so, but I don’t think there are any examples with a non-protocol constraint on `Self`, making it hard to tell at a glance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, you should be able to use arbitrary generic constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Quick Q2: is there anything you can do in this scenario:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // w/in some behavior:<br>&gt;&gt;&gt;&gt; mutating func silentlySet(value: Value) {<br>&gt;&gt;&gt;&gt; value = value // &lt;- probably not going to work<br>&gt;&gt;&gt;&gt; self.value = value // &lt;- not right either, `self` is the behavior’s owner, right?<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …other than change the argument name to avoid conflict?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I thought I mentioned this in the proposal—you could use `behaviorName.value` to qualify a reference to the behavior&#39;s members within the behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Remark: it definitely feels a bit odd to be using both `Self` and `self` to mean something that’s neither consistent with the rest of the language nor, really, to mean `Self` (or `self`). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I get not wanting new keywords, but this feels like it could be an economy too far; perhaps I’m misunderstanding some aspect of how it’s meant to work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not totally comfortable with it either. It at least corresponds to the notion of `self` you&#39;d get if you&#39;d coded a property by hand within its enclosing type, so the meaning might be useful for refactoring code out of concrete property implementations into behavior templates.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/bed8c292/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 14, 2016 at 02:00:00am</p></header><div class="content"><p>Very Good,<br>I&#39;m still pondering some peculiarities in the proposal, but would like to<br>highlight:<br></p><p>Declaration syntax:<br></p><p>@lazy&lt;Value&gt;: Value {<br> //.....//<br>}<br></p><p>And keep:<br></p><p>var [lazy] foo = 1738<br></p><p><br>On Wed, Jan 13, 2016, 20:07 Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks everyone for the first round of feedback on my behaviors proposal.<br>&gt; I&#39;ve revised it with the following changes:<br>&gt;<br>&gt; - Instead of relying on mapping behaviors to function or type member<br>&gt; lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration,<br>&gt; which declares the accessor and initializer requirements and provides the<br>&gt; storage and behavior methods of the property. I think this gives a clearer<br>&gt; design for authoring behaviors, and allows for a more efficient and<br>&gt; flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you<br>&gt; noted, it&#39;s better to tackle immutable computed properties more<br>&gt; holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square<br>&gt; brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring<br>&gt; &#39;var&#39; bindings, and also works with future candidates for behavior<br>&gt; decoration, particularly `subscript`.<br>&gt;<br>&gt; Here&#39;s the revised proposal:<br>&gt;<br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt;<br>&gt; For reference, here&#39;s the previous iteration:<br>&gt;<br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt;<br>&gt; Thanks for taking a look!<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/6fe3e1b9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 13, 2016 at 10:00:00pm</p></header><div class="content"><p>I started by reading the examples and I was very confused. This suggests to me that if you&#39;ve never seen a var behavior before, you are going to wonder what the hell is going on. :-)<br></p><p>Notable points of confusion:<br></p><p>it&#39;s confusing to me that `self` is the containing type and the behavior name is the &quot;behavior&#39;s self&quot;.<br>The `initializer` special field feels absolutely magic. Has anything else been considered, like an init param that has either a Value or an autoclosure returning one? (If we don&#39;t want to capture self, aren&#39;t we in for problems capturing self from accessors anyway?)<br>I see (after reading it) that `var behavior foo&lt;Value&gt;: Value` means that foo &quot;applies to&quot;/&quot;wraps&quot; Value, but I find it confusing to use a syntax more typically associated with &quot;extends&quot; or &quot;implements&quot; or &quot;is a&quot;.<br></p><p>Questions:<br></p><p>Can a behavior have generic parameters that can&#39;t be inferred? Could I write, say, [fooable&lt;Int&gt;]?<br>What is the tradeoff between `eager` and `deferred`? Is it &quot;only&quot; that `deferred` side effects happen at the mercy of the behavior?<br>If so, isn&#39;t it a problem that behaviors aren&#39;t intrinsically explicit about whether they defer initialization? I can see that causing very subtle bugs.<br></p><p>Concerns:<br></p><p>It looks like if you had a [resettable, observable] property, calling resettable.reset() would change the value from under `observable`&#39;s feet.<br></p><p>Comments:<br></p><p>While it might be true that square brackets work better with other declarations that could eventually have behaviors, &quot;var behavior&quot; doesn&#39;t really lend itself to that kind of extensibility. Are we steering towards &quot;func behavior&quot;, &quot;class behavior&quot;, etc? Is it a problem if we are?<br>I&#39;d like to point out that the memoization example is a let variable with a behavior, which is explicitly forbidden by the current proposal.<br></p><p>Finally, I would like to throw the idea of &quot;foo..resettable&quot; to access foo&#39;s resettable behavior (or foo..reset() doing optionally-qualified lookup on foo&#39;s behavior methods).<br></p><p>Félix<br></p><p>&gt; Le 13 janv. 2016 à 17:07:06, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Here&#39;s the revised proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; <br>&gt; For reference, here&#39;s the previous iteration:<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/8d9e87a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 7:13 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I started by reading the examples and I was very confused. This suggests to me that if you&#39;ve never seen a var behavior before, you are going to wonder what the hell is going on. :-)<br></p><p>This is good feedback, thanks!<br></p><p>&gt; Notable points of confusion:<br>&gt; <br>&gt; it&#39;s confusing to me that `self` is the containing type and the behavior name is the &quot;behavior&#39;s self&quot;.<br></p><p>Others have noted this too. Would it be less confusing if one had to explicitly name the &quot;container&quot; as a member, e.g.:<br></p><p>var behavior synchronized {<br>  container var parent: Synchronizable<br>  base var value: Value<br></p><p>  get {<br>    return parent.withLock { value }<br>  }<br>  set {<br>    parent.withLock { value = newValue }<br>  }<br>}<br></p><p>&gt; The `initializer` special field feels absolutely magic. Has anything else been considered, like an init param that has either a Value or an autoclosure returning one? (If we don&#39;t want to capture self, aren&#39;t we in for problems capturing self from accessors anyway?)<br></p><p>An `init` parameter covers use cases where the initializer expression is used only during initialization, but doesn&#39;t let you use the initializer after initialization, which is necessary for `lazy`, `resettable`, and other use cases. Even with @autoclosure, it seems to me that, without `initializer`, we&#39;d need to allocate per-property storage for the initializer expression to use it later, which is something I&#39;d like to avoid.<br></p><p>&gt; I see (after reading it) that `var behavior foo&lt;Value&gt;: Value` means that foo &quot;applies to&quot;/&quot;wraps&quot; Value, but I find it confusing to use a syntax more typically associated with &quot;extends&quot; or &quot;implements&quot; or &quot;is a&quot;.<br></p><p>Would it be less confusing if the type of the property were implicit? In discussion with Brent, I suggested a model where you say:<br></p><p>var behavior foo { ... }<br></p><p>and if you want to constrain the types of properties that can instantiate the behavior, you use a where clause:<br></p><p>var behavior foo where Value: NSCopying { ... }<br></p><p>which optimizes the common case (no constraint), and might be easier to read.<br></p><p>&gt; Questions:<br>&gt; <br>&gt; Can a behavior have generic parameters that can&#39;t be inferred? Could I write, say, [fooable&lt;Int&gt;]?<br></p><p>No, the generic parameters are only used to generalize the property type.<br></p><p>&gt; What is the tradeoff between `eager` and `deferred`? Is it &quot;only&quot; that `deferred` side effects happen at the mercy of the behavior?<br>&gt; If so, isn&#39;t it a problem that behaviors aren&#39;t intrinsically explicit about whether they defer initialization? I can see that causing very subtle bugs.<br></p><p>The tradeoff is that an &#39;eager&#39; initialization can be used in `init`, but that means that an initializer expression can&#39;t refer to `self`, because `self` is not fully initialized. This is how initializer expressions always work today:<br></p><p>struct X {<br>  var x = 0, y = 1<br>  var z = x + y // Error<br>}<br></p><p>A deferred initialization can only be evaluated *after* init, but because of that, it can refer to `self`, which people would like to be able to do with `lazy` (but currently can&#39;t):<br></p><p>struct X {<br>  var x = 0, y = 1<br>  lazy var z = x + y // Theoretically OK<br>}<br></p><p>&gt; <br>&gt; Concerns:<br>&gt; <br>&gt; It looks like if you had a [resettable, observable] property, calling resettable.reset() would change the value from under `observable`&#39;s feet.<br></p><p>True. An unfortunate consequence of these things being user-defined is that there will always be &quot;wrong&quot; orderings of them. I&#39;m not sure how much we can do about that.<br></p><p>&gt; <br>&gt; Comments:<br>&gt; <br>&gt; While it might be true that square brackets work better with other declarations that could eventually have behaviors, &quot;var behavior&quot; doesn&#39;t really lend itself to that kind of extensibility. Are we steering towards &quot;func behavior&quot;, &quot;class behavior&quot;, etc? Is it a problem if we are?<br></p><p>Possibly. Note that square brackets are necessary even only for `var`, because you can declare a destructuring binding `var (x, y) = tuple`.<br></p><p>&gt; I&#39;d like to point out that the memoization example is a let variable with a behavior, which is explicitly forbidden by the current proposal.<br></p><p>Thanks, missed that.<br></p><p>&gt; <br>&gt; Finally, I would like to throw the idea of &quot;foo..resettable&quot; to access foo&#39;s resettable behavior (or foo..reset() doing optionally-qualified lookup on foo&#39;s behavior methods).<br></p><p>Not a bad suggestion.<br></p><p>Thanks again for the feedback!<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/d46d5f6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 13, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Le 13 janv. 2016 à 23:08:24, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; Notable points of confusion:<br>&gt;&gt; <br>&gt;&gt; it&#39;s confusing to me that `self` is the containing type and the behavior name is the &quot;behavior&#39;s self&quot;.<br>&gt; <br>&gt; Others have noted this too. Would it be less confusing if one had to explicitly name the &quot;container&quot; as a member, e.g.:<br>&gt; <br>&gt; var behavior synchronized {<br>&gt;   container var parent: Synchronizable<br>&gt;   base var value: Value<br>&gt; <br>&gt;   get {<br>&gt;     return parent.withLock { value }<br>&gt;   }<br>&gt;   set {<br>&gt;     parent.withLock { value = newValue }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; An `init` parameter covers use cases where the initializer expression is used only during initialization, but doesn&#39;t let you use the initializer after initialization, which is necessary for `lazy`, `resettable`, and other use cases. Even with @autoclosure, it seems to me that, without `initializer`, we&#39;d need to allocate per-property storage for the initializer expression to use it later, which is something I&#39;d like to avoid.<br></p><p>I wish we didn&#39;t have immaterial members like `parent` (which would be an inout parameter to every method, it seems) and `initializer`, but I do prefer having an immaterial &quot;container var parent&quot; over a repurposed self. I can see the point with `initializer` (even though I&#39;m not sure what that one would be).<br></p><p>How are property behaviors &quot;merged&quot; into container types? Is there any chance that `initializer`, whether an autoclosure or a value, could be optimized away in most cases (screwed be debug builds)? That would be my favorite outcome.<br></p><p>&gt; <br>&gt;&gt; I see (after reading it) that `var behavior foo&lt;Value&gt;: Value` means that foo &quot;applies to&quot;/&quot;wraps&quot; Value, but I find it confusing to use a syntax more typically associated with &quot;extends&quot; or &quot;implements&quot; or &quot;is a&quot;.<br>&gt; <br>&gt; Would it be less confusing if the type of the property were implicit? In discussion with Brent, I suggested a model where you say:<br>&gt; <br>&gt; var behavior foo { ... }<br>&gt; <br>&gt; and if you want to constrain the types of properties that can instantiate the behavior, you use a where clause:<br>&gt; <br>&gt; var behavior foo where Value: NSCopying { ... }<br>&gt; <br>&gt; which optimizes the common case (no constraint), and might be easier to read.<br>&gt; <br>&gt;&gt; Questions:<br>&gt;&gt; <br>&gt;&gt; Can a behavior have generic parameters that can&#39;t be inferred? Could I write, say, [fooable&lt;Int&gt;]?<br>&gt; <br>&gt; No, the generic parameters are only used to generalize the property type.<br></p><p>Given this, I think that it makes sense to make the generics and remove the `: Value` (without the obvious downside that Value and Self are less discoverable).<br></p><p>&gt; <br>&gt;&gt; What is the tradeoff between `eager` and `deferred`? Is it &quot;only&quot; that `deferred` side effects happen at the mercy of the behavior?<br>&gt;&gt; If so, isn&#39;t it a problem that behaviors aren&#39;t intrinsically explicit about whether they defer initialization? I can see that causing very subtle bugs.<br>&gt; <br>&gt; The tradeoff is that an &#39;eager&#39; initialization can be used in `init`, but that means that an initializer expression can&#39;t refer to `self`, because `self` is not fully initialized. This is how initializer expressions always work today:<br>&gt; <br>&gt; struct X {<br>&gt;   var x = 0, y = 1<br>&gt;   var z = x + y // Error<br>&gt; }<br>&gt; <br>&gt; A deferred initialization can only be evaluated *after* init, but because of that, it can refer to `self`, which people would like to be able to do with `lazy` (but currently can&#39;t):<br>&gt; <br>&gt; struct X {<br>&gt;   var x = 0, y = 1<br>&gt;   lazy var z = x + y // Theoretically OK<br>&gt; }<br></p><p>Got it. Still, can it be a problem that it might not be obvious whether a behavior defers initialization or not, in terms of side effects?<br></p><p>Also, some behaviors (like resettable) use `initializer` multiple times. Are the side effects evaluated each time? That seems like a bad idea to me, but it does mean that `initializer`&#39;s value would need to be stored otherwise.<br></p><p>&gt;&gt; Concerns:<br>&gt;&gt; <br>&gt;&gt; It looks like if you had a [resettable, observable] property, calling resettable.reset() would change the value from under `observable`&#39;s feet.<br>&gt; <br>&gt; True. An unfortunate consequence of these things being user-defined is that there will always be &quot;wrong&quot; orderings of them. I&#39;m not sure how much we can do about that.<br></p><p>In this case, it&#39;s problematic that resettable simply can&#39;t be ordered after observable because it has a base property.<br></p><p>Would it make sense to have a warning if a behavior down the chain has mutating functions? (Either at the declaration or at the mutating call site)<br></p><p>Speaking of which, `lazy`&#39;s `get` accessor isn&#39;t marked as mutating in the proposal. Is it on purpose?<br></p><p>Thanks for your work on this.<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/75fec303/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 8:44 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 13 janv. 2016 à 23:08:24, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; Notable points of confusion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; it&#39;s confusing to me that `self` is the containing type and the behavior name is the &quot;behavior&#39;s self&quot;.<br>&gt;&gt; <br>&gt;&gt; Others have noted this too. Would it be less confusing if one had to explicitly name the &quot;container&quot; as a member, e.g.:<br>&gt;&gt; <br>&gt;&gt; var behavior synchronized {<br>&gt;&gt;   container var parent: Synchronizable<br>&gt;&gt;   base var value: Value<br>&gt;&gt; <br>&gt;&gt;   get {<br>&gt;&gt;     return parent.withLock { value }<br>&gt;&gt;   }<br>&gt;&gt;   set {<br>&gt;&gt;     parent.withLock { value = newValue }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; An `init` parameter covers use cases where the initializer expression is used only during initialization, but doesn&#39;t let you use the initializer after initialization, which is necessary for `lazy`, `resettable`, and other use cases. Even with @autoclosure, it seems to me that, without `initializer`, we&#39;d need to allocate per-property storage for the initializer expression to use it later, which is something I&#39;d like to avoid.<br>&gt; <br>&gt; I wish we didn&#39;t have immaterial members like `parent` (which would be an inout parameter to every method, it seems) and `initializer`, but I do prefer having an immaterial &quot;container var parent&quot; over a repurposed self. I can see the point with `initializer` (even though I&#39;m not sure what that one would be).<br></p><p>One benefit of making the container binding explicit is that we can avoid referencing the container `inout` in behavior implementations if it isn&#39;t used (and we&#39;re willing to say that a behavior can&#39;t resiliently adopt a container requirement if it wasn&#39;t originally written with one).<br></p><p>&gt; <br>&gt; How are property behaviors &quot;merged&quot; into container types? Is there any chance that `initializer`, whether an autoclosure or a value, could be optimized away in most cases (screwed be debug builds)? That would be my favorite outcome.<br></p><p>The initializer expression and accessors should manifest themselves as methods on the containing type. There shouldn&#39;t be any implicit per-instance storage overhead to using behaviors, and the abstraction should be optimizable by inlining and generic specialization in optimized builds.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I see (after reading it) that `var behavior foo&lt;Value&gt;: Value` means that foo &quot;applies to&quot;/&quot;wraps&quot; Value, but I find it confusing to use a syntax more typically associated with &quot;extends&quot; or &quot;implements&quot; or &quot;is a&quot;.<br>&gt;&gt; <br>&gt;&gt; Would it be less confusing if the type of the property were implicit? In discussion with Brent, I suggested a model where you say:<br>&gt;&gt; <br>&gt;&gt; var behavior foo { ... }<br>&gt;&gt; <br>&gt;&gt; and if you want to constrain the types of properties that can instantiate the behavior, you use a where clause:<br>&gt;&gt; <br>&gt;&gt; var behavior foo where Value: NSCopying { ... }<br>&gt;&gt; <br>&gt;&gt; which optimizes the common case (no constraint), and might be easier to read.<br>&gt;&gt; <br>&gt;&gt;&gt; Questions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can a behavior have generic parameters that can&#39;t be inferred? Could I write, say, [fooable&lt;Int&gt;]?<br>&gt;&gt; <br>&gt;&gt; No, the generic parameters are only used to generalize the property type.<br>&gt; <br>&gt; Given this, I think that it makes sense to make the generics and remove the `: Value` (without the obvious downside that Value and Self are less discoverable).<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; What is the tradeoff between `eager` and `deferred`? Is it &quot;only&quot; that `deferred` side effects happen at the mercy of the behavior?<br>&gt;&gt;&gt; If so, isn&#39;t it a problem that behaviors aren&#39;t intrinsically explicit about whether they defer initialization? I can see that causing very subtle bugs.<br>&gt;&gt; <br>&gt;&gt; The tradeoff is that an &#39;eager&#39; initialization can be used in `init`, but that means that an initializer expression can&#39;t refer to `self`, because `self` is not fully initialized. This is how initializer expressions always work today:<br>&gt;&gt; <br>&gt;&gt; struct X {<br>&gt;&gt;   var x = 0, y = 1<br>&gt;&gt;   var z = x + y // Error<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A deferred initialization can only be evaluated *after* init, but because of that, it can refer to `self`, which people would like to be able to do with `lazy` (but currently can&#39;t):<br>&gt;&gt; <br>&gt;&gt; struct X {<br>&gt;&gt;   var x = 0, y = 1<br>&gt;&gt;   lazy var z = x + y // Theoretically OK<br>&gt;&gt; }<br>&gt; <br>&gt; Got it. Still, can it be a problem that it might not be obvious whether a behavior defers initialization or not, in terms of side effects?<br>&gt; <br>&gt; Also, some behaviors (like resettable) use `initializer` multiple times. Are the side effects evaluated each time? That seems like a bad idea to me, but it does mean that `initializer`&#39;s value would need to be stored otherwise.<br>&gt; <br>&gt;&gt;&gt; Concerns:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks like if you had a [resettable, observable] property, calling resettable.reset() would change the value from under `observable`&#39;s feet.<br>&gt;&gt; <br>&gt;&gt; True. An unfortunate consequence of these things being user-defined is that there will always be &quot;wrong&quot; orderings of them. I&#39;m not sure how much we can do about that.<br>&gt; <br>&gt; In this case, it&#39;s problematic that resettable simply can&#39;t be ordered after observable because it has a base property.<br></p><p>It occurs to me that a bound `initializer` is in a sense a lot like a sugared accessor. Both `lazy` and `resettable` could be designed in terms of accessor requirements, at the cost of some sugar, and some redundancy in the case of `resettable`:<br></p><p>var behavior lazy {<br>  var value: Value?<br>  accessor initialValue() -&gt; Value<br></p><p>  mutating get {<br>    if let value = value { return value }<br>    let val = initialValue()<br>    value = val<br>    return val<br>  }<br>}<br></p><p>var [lazy] x: Int {<br>  initialValue { return 679 }<br>}<br></p><p>var behavior resettable {<br>  base var value: Value<br>  accessor resetValue() -&gt; Value<br></p><p>  mutating func reset() {<br>    value = resetValue<br>  }<br>}<br></p><p>var [resettable] y: Int = 1738 {<br>  resetValue { return 1738 }<br>}<br></p><p>If we could live with that, we could avoid the complexity of the deferred/eager initializer, and `resettable` could also be made composable by a base property.<br></p><p>&gt; <br>&gt; Would it make sense to have a warning if a behavior down the chain has mutating functions? (Either at the declaration or at the mutating call site)<br></p><p>Not sure what you mean, exactly. Seems like that would warn on a lot of legitimate use cases.<br></p><p>&gt; Speaking of which, `lazy`&#39;s `get` accessor isn&#39;t marked as mutating in the proposal. Is it on purpose?<br></p><p>Another oversight; thanks!<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/ffd989ee/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 14, 2016 at 06:00:00pm</p></header><div class="content"><p>I really liked this idea:<br></p><p>x..resettablet.reset()<br></p><p>I can see that when typing the second dot, the autocomplete offering me all<br>behaviors available. ;)<br></p><p>And thinking a little, may the `pipe` can be used to declaration :<br></p><p>var |lazy| number = 1243<br></p><p>The Square brackets is good, but feels like array.<br></p><p>And for multiple behaviors, we can use the &quot;*&gt;*&quot; to infer the &quot;direction&quot;<br>of the &quot;composability&quot;:<br></p><p>var |lazy&gt;observed| observedLazy = expensiveExpression() {<br>  didSet { print(&quot;\(oldValue) =&gt; \(observedLazy)&quot;) }<br>}<br></p><p><br></p><p>Em qui, 14 de jan de 2016 às 02:08, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; On Jan 13, 2016, at 7:13 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt; I started by reading the examples and I was very confused. This suggests<br>&gt; to me that if you&#39;ve never seen a var behavior before, you are going to<br>&gt; wonder what the hell is going on. :-)<br>&gt;<br>&gt;<br>&gt; This is good feedback, thanks!<br>&gt;<br>&gt; Notable points of confusion:<br>&gt;<br>&gt;<br>&gt;    - it&#39;s confusing to me that `self` is the containing type and the<br>&gt;    behavior name is the &quot;behavior&#39;s self&quot;.<br>&gt;<br>&gt;<br>&gt; Others have noted this too. Would it be less confusing if one had to<br>&gt; explicitly name the &quot;container&quot; as a member, e.g.:<br>&gt;<br>&gt; var behavior synchronized {<br>&gt;   container var parent: Synchronizable<br>&gt;   base var value: Value<br>&gt;<br>&gt;   get {<br>&gt;     return parent.withLock { value }<br>&gt;   }<br>&gt;   set {<br>&gt;     parent.withLock { value = newValue }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;    - The `initializer` special field feels absolutely magic. Has anything<br>&gt;    else been considered, like an init param that has either a Value or an<br>&gt;    autoclosure returning one? (If we don&#39;t want to capture self, aren&#39;t we in<br>&gt;    for problems capturing self from accessors anyway?)<br>&gt;<br>&gt;<br>&gt; An `init` parameter covers use cases where the initializer expression is<br>&gt; used only during initialization, but doesn&#39;t let you use the initializer<br>&gt; after initialization, which is necessary for `lazy`, `resettable`, and<br>&gt; other use cases. Even with @autoclosure, it seems to me that, without<br>&gt; `initializer`, we&#39;d need to allocate per-property storage for the<br>&gt; initializer expression to use it later, which is something I&#39;d like to<br>&gt; avoid.<br>&gt;<br>&gt;<br>&gt;    - I see (after reading it) that `var behavior foo&lt;Value&gt;: Value` means<br>&gt;    that foo &quot;applies to&quot;/&quot;wraps&quot; Value, but I find it confusing to use a<br>&gt;    syntax more typically associated with &quot;extends&quot; or &quot;implements&quot; or &quot;is a&quot;.<br>&gt;<br>&gt;<br>&gt; Would it be less confusing if the type of the property were implicit? In<br>&gt; discussion with Brent, I suggested a model where you say:<br>&gt;<br>&gt; var behavior foo { ... }<br>&gt;<br>&gt;<br>&gt; and if you want to constrain the types of properties that can instantiate<br>&gt; the behavior, you use a where clause:<br>&gt;<br>&gt; var behavior foo where Value: NSCopying { ... }<br>&gt;<br>&gt; which optimizes the common case (no constraint), and might be easier to<br>&gt; read.<br>&gt;<br>&gt; Questions:<br>&gt;<br>&gt;<br>&gt;    - Can a behavior have generic parameters that can&#39;t be inferred? Could<br>&gt;    I write, say, [fooable&lt;Int&gt;]?<br>&gt;<br>&gt;<br>&gt; No, the generic parameters are only used to generalize the property type.<br>&gt;<br>&gt;<br>&gt;    - What is the tradeoff between `eager` and `deferred`? Is it &quot;only&quot;<br>&gt;    that `deferred` side effects happen at the mercy of the behavior?<br>&gt;       - If so, isn&#39;t it a problem that behaviors aren&#39;t intrinsically<br>&gt;       explicit about whether they defer initialization? I can see that causing<br>&gt;       very subtle bugs.<br>&gt;<br>&gt;<br>&gt; The tradeoff is that an &#39;eager&#39; initialization can be used in `init`, but<br>&gt; that means that an initializer expression can&#39;t refer to `self`, because<br>&gt; `self` is not fully initialized. This is how initializer expressions always<br>&gt; work today:<br>&gt;<br>&gt; struct X {<br>&gt;   var x = 0, y = 1<br>&gt;   var z = x + y // Error<br>&gt; }<br>&gt;<br>&gt; A deferred initialization can only be evaluated *after* init, but because<br>&gt; of that, it can refer to `self`, which people would like to be able to do<br>&gt; with `lazy` (but currently can&#39;t):<br>&gt;<br>&gt; struct X {<br>&gt;   var x = 0, y = 1<br>&gt;   lazy var z = x + y // Theoretically OK<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Concerns:<br>&gt;<br>&gt;<br>&gt;    - It looks like if you had a [resettable, observable] property,<br>&gt;    calling resettable.reset() would change the value from under `observable`&#39;s<br>&gt;    feet.<br>&gt;<br>&gt;<br>&gt; True. An unfortunate consequence of these things being user-defined is<br>&gt; that there will always be &quot;wrong&quot; orderings of them. I&#39;m not sure how much<br>&gt; we can do about that.<br>&gt;<br>&gt;<br>&gt; Comments:<br>&gt;<br>&gt;<br>&gt;    - While it might be true that square brackets work better with other<br>&gt;    declarations that could eventually have behaviors, &quot;var behavior&quot; doesn&#39;t<br>&gt;    really lend itself to that kind of extensibility. Are we steering towards<br>&gt;    &quot;func behavior&quot;, &quot;class behavior&quot;, etc? Is it a problem if we are?<br>&gt;<br>&gt;<br>&gt; Possibly. Note that square brackets are necessary even only for `var`,<br>&gt; because you can declare a destructuring binding `var (x, y) = tuple`.<br>&gt;<br>&gt;<br>&gt;    - I&#39;d like to point out that the memoization example is a let variable<br>&gt;    with a behavior, which is explicitly forbidden by the current proposal.<br>&gt;<br>&gt;<br>&gt; Thanks, missed that.<br>&gt;<br>&gt;<br>&gt; Finally, I would like to throw the idea of &quot;foo..resettable&quot; to access<br>&gt; foo&#39;s resettable behavior (or foo..reset() doing optionally-qualified<br>&gt; lookup on foo&#39;s behavior methods).<br>&gt;<br>&gt;<br>&gt; Not a bad suggestion.<br>&gt;<br>&gt; Thanks again for the feedback!<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/e497970c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>January 17, 2016 at 08:00:00pm</p></header><div class="content"><p>As long as we&#39;re bike shedding syntax, I&#39;ll add my two cents. <br></p><p>I&#39;m not a fan of typed-based disambiguation of behavior vs. member references, as in foo.resettable.reset(). Behaviors are a very different thing than members. The proposed behavior declaration syntax makes this very clear. I think the reference syntax should do the same.<br></p><p>I also dislike the foo.[resettable].reset() alternative. This is primarily an aesthetic judgment—it looks like punctuation soup—but is also easy to read as the subscriptions foo[resettable] on a glance.<br></p><p>The double-dot approach is maybe somewhat better, but I worry that it&#39;s confusing with the range operators. (That may just be because of my experience in other languages that use &#39;..&#39;. Swift&#39;s &#39;...&#39; and &#39;..&lt;&#39; are probably sufficiently different.)<br></p><p>It seems to me that a sigil for both declaration and access would be clearer:<br></p><p>// declaration<br>var #resettable foo: Int<br></p><p>// use<br>foo#resettable.reset()<br></p><p>// behavior composition<br>var #(lazy, resettable) bar: Int<br></p><p>This makes declaration and use correspond, keeps the syntax lightweight in the common case of a single behavior, and uses an ordered, tuple-like syntax for behavior composition.<br></p><p>Thanks for the updated proposal, Joe. I&#39;m very excited to see where it goes.<br></p><p>Cheers,<br></p><p>Curt<br></p><p>Curt Clifton, PhD<br>Software Developer<br>The Omni Group<br></p><p><br>&gt; On Jan 14, 2016, at 10:43 AM, Wallacy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really liked this idea:<br>&gt; x..resettablet.reset()<br>&gt; I can see that when typing the second dot, the autocomplete offering me all behaviors available. ;)<br>&gt; <br>&gt; And thinking a little, may the `pipe` can be used to declaration :<br>&gt; <br>&gt; var |lazy| number = 1243<br>&gt; The Square brackets is good, but feels like array.<br>&gt; <br>&gt; And for multiple behaviors, we can use the &quot;&gt;&quot; to infer the &quot;direction&quot; of the &quot;composability&quot;:<br>&gt; <br>&gt; var |lazy&gt;observed| observedLazy = expensiveExpression() {<br>&gt;   didSet { print(&quot;\(oldValue) =&gt; \(observedLazy)&quot;) }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Em qui, 14 de jan de 2016 às 02:08, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; escreveu:<br>&gt;&gt;&gt; On Jan 13, 2016, at 7:13 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I started by reading the examples and I was very confused. This suggests to me that if you&#39;ve never seen a var behavior before, you are going to wonder what the hell is going on. :-)<br>&gt;&gt; <br>&gt;&gt; This is good feedback, thanks!<br>&gt;&gt; <br>&gt;&gt;&gt; Notable points of confusion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; it&#39;s confusing to me that `self` is the containing type and the behavior name is the &quot;behavior&#39;s self&quot;.<br>&gt;&gt; <br>&gt;&gt; Others have noted this too. Would it be less confusing if one had to explicitly name the &quot;container&quot; as a member, e.g.:<br>&gt;&gt; <br>&gt;&gt; var behavior synchronized {<br>&gt;&gt;   container var parent: Synchronizable<br>&gt;&gt;   base var value: Value<br>&gt;&gt; <br>&gt;&gt;   get {<br>&gt;&gt;     return parent.withLock { value }<br>&gt;&gt;   }<br>&gt;&gt;   set {<br>&gt;&gt;     parent.withLock { value = newValue }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; The `initializer` special field feels absolutely magic. Has anything else been considered, like an init param that has either a Value or an autoclosure returning one? (If we don&#39;t want to capture self, aren&#39;t we in for problems capturing self from accessors anyway?)<br>&gt;&gt; <br>&gt;&gt; An `init` parameter covers use cases where the initializer expression is used only during initialization, but doesn&#39;t let you use the initializer after initialization, which is necessary for `lazy`, `resettable`, and other use cases. Even with @autoclosure, it seems to me that, without `initializer`, we&#39;d need to allocate per-property storage for the initializer expression to use it later, which is something I&#39;d like to avoid.<br>&gt;&gt; <br>&gt;&gt;&gt; I see (after reading it) that `var behavior foo&lt;Value&gt;: Value` means that foo &quot;applies to&quot;/&quot;wraps&quot; Value, but I find it confusing to use a syntax more typically associated with &quot;extends&quot; or &quot;implements&quot; or &quot;is a&quot;.<br>&gt;&gt; <br>&gt;&gt; Would it be less confusing if the type of the property were implicit? In discussion with Brent, I suggested a model where you say:<br>&gt;&gt; <br>&gt;&gt; var behavior foo { ... }<br>&gt;&gt; <br>&gt;&gt; and if you want to constrain the types of properties that can instantiate the behavior, you use a where clause:<br>&gt;&gt; <br>&gt;&gt; var behavior foo where Value: NSCopying { ... }<br>&gt;&gt; <br>&gt;&gt; which optimizes the common case (no constraint), and might be easier to read.<br>&gt;&gt; <br>&gt;&gt;&gt; Questions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can a behavior have generic parameters that can&#39;t be inferred? Could I write, say, [fooable&lt;Int&gt;]?<br>&gt;&gt; <br>&gt;&gt; No, the generic parameters are only used to generalize the property type.<br>&gt;&gt; <br>&gt;&gt;&gt; What is the tradeoff between `eager` and `deferred`? Is it &quot;only&quot; that `deferred` side effects happen at the mercy of the behavior?<br>&gt;&gt;&gt; If so, isn&#39;t it a problem that behaviors aren&#39;t intrinsically explicit about whether they defer initialization? I can see that causing very subtle bugs.<br>&gt;&gt; <br>&gt;&gt; The tradeoff is that an &#39;eager&#39; initialization can be used in `init`, but that means that an initializer expression can&#39;t refer to `self`, because `self` is not fully initialized. This is how initializer expressions always work today:<br>&gt;&gt; <br>&gt;&gt; struct X {<br>&gt;&gt;   var x = 0, y = 1<br>&gt;&gt;   var z = x + y // Error<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A deferred initialization can only be evaluated *after* init, but because of that, it can refer to `self`, which people would like to be able to do with `lazy` (but currently can&#39;t):<br>&gt;&gt; <br>&gt;&gt; struct X {<br>&gt;&gt;   var x = 0, y = 1<br>&gt;&gt;   lazy var z = x + y // Theoretically OK<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Concerns:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks like if you had a [resettable, observable] property, calling resettable.reset() would change the value from under `observable`&#39;s feet.<br>&gt;&gt; <br>&gt;&gt; True. An unfortunate consequence of these things being user-defined is that there will always be &quot;wrong&quot; orderings of them. I&#39;m not sure how much we can do about that.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While it might be true that square brackets work better with other declarations that could eventually have behaviors, &quot;var behavior&quot; doesn&#39;t really lend itself to that kind of extensibility. Are we steering towards &quot;func behavior&quot;, &quot;class behavior&quot;, etc? Is it a problem if we are?<br>&gt;&gt; <br>&gt;&gt; Possibly. Note that square brackets are necessary even only for `var`, because you can declare a destructuring binding `var (x, y) = tuple`.<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to point out that the memoization example is a let variable with a behavior, which is explicitly forbidden by the current proposal.<br>&gt;&gt; <br>&gt;&gt; Thanks, missed that.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, I would like to throw the idea of &quot;foo..resettable&quot; to access foo&#39;s resettable behavior (or foo..reset() doing optionally-qualified lookup on foo&#39;s behavior methods).<br>&gt;&gt; <br>&gt;&gt; Not a bad suggestion.<br>&gt;&gt; <br>&gt;&gt; Thanks again for the feedback!<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/738935c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 20, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 for disambiguating behavior vs. member access by a sigil. Using # is fine IMO.<br></p><p>-Thorsten <br></p><p>&gt; Am 18.01.2016 um 05:41 schrieb Curt Clifton via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; As long as we&#39;re bike shedding syntax, I&#39;ll add my two cents. <br>&gt; <br>&gt; I&#39;m not a fan of typed-based disambiguation of behavior vs. member references, as in foo.resettable.reset(). Behaviors are a very different thing than members. The proposed behavior declaration syntax makes this very clear. I think the reference syntax should do the same.<br>&gt; <br>&gt; I also dislike the foo.[resettable].reset() alternative. This is primarily an aesthetic judgment—it looks like punctuation soup—but is also easy to read as the subscriptions foo[resettable] on a glance.<br>&gt; <br>&gt; The double-dot approach is maybe somewhat better, but I worry that it&#39;s confusing with the range operators. (That may just be because of my experience in other languages that use &#39;..&#39;. Swift&#39;s &#39;...&#39; and &#39;..&lt;&#39; are probably sufficiently different.)<br>&gt; <br>&gt; It seems to me that a sigil for both declaration and access would be clearer:<br>&gt; <br>&gt; // declaration<br>&gt; var #resettable foo: Int<br>&gt; <br>&gt; // use<br>&gt; foo#resettable.reset()<br>&gt; <br>&gt; // behavior composition<br>&gt; var #(lazy, resettable) bar: Int<br>&gt; <br>&gt; This makes declaration and use correspond, keeps the syntax lightweight in the common case of a single behavior, and uses an ordered, tuple-like syntax for behavior composition.<br>&gt; <br>&gt; Thanks for the updated proposal, Joe. I&#39;m very excited to see where it goes.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Curt<br>&gt; <br>&gt; Curt Clifton, PhD<br>&gt; Software Developer<br>&gt; The Omni Group<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 14, 2016, at 10:43 AM, Wallacy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I really liked this idea:<br>&gt;&gt; x..resettablet.reset()<br>&gt;&gt; I can see that when typing the second dot, the autocomplete offering me all behaviors available. ;)<br>&gt;&gt; <br>&gt;&gt; And thinking a little, may the `pipe` can be used to declaration :<br>&gt;&gt; <br>&gt;&gt; var |lazy| number = 1243<br>&gt;&gt; The Square brackets is good, but feels like array.<br>&gt;&gt; <br>&gt;&gt; And for multiple behaviors, we can use the &quot;&gt;&quot; to infer the &quot;direction&quot; of the &quot;composability&quot;:<br>&gt;&gt; <br>&gt;&gt; var |lazy&gt;observed| observedLazy = expensiveExpression() {<br>&gt;&gt;   didSet { print(&quot;\(oldValue) =&gt; \(observedLazy)&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Em qui, 14 de jan de 2016 às 02:08, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; escreveu:<br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 7:13 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I started by reading the examples and I was very confused. This suggests to me that if you&#39;ve never seen a var behavior before, you are going to wonder what the hell is going on. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is good feedback, thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Notable points of confusion:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; it&#39;s confusing to me that `self` is the containing type and the behavior name is the &quot;behavior&#39;s self&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Others have noted this too. Would it be less confusing if one had to explicitly name the &quot;container&quot; as a member, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var behavior synchronized {<br>&gt;&gt;&gt;   container var parent: Synchronizable<br>&gt;&gt;&gt;   base var value: Value<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   get {<br>&gt;&gt;&gt;     return parent.withLock { value }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   set {<br>&gt;&gt;&gt;     parent.withLock { value = newValue }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The `initializer` special field feels absolutely magic. Has anything else been considered, like an init param that has either a Value or an autoclosure returning one? (If we don&#39;t want to capture self, aren&#39;t we in for problems capturing self from accessors anyway?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An `init` parameter covers use cases where the initializer expression is used only during initialization, but doesn&#39;t let you use the initializer after initialization, which is necessary for `lazy`, `resettable`, and other use cases. Even with @autoclosure, it seems to me that, without `initializer`, we&#39;d need to allocate per-property storage for the initializer expression to use it later, which is something I&#39;d like to avoid.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see (after reading it) that `var behavior foo&lt;Value&gt;: Value` means that foo &quot;applies to&quot;/&quot;wraps&quot; Value, but I find it confusing to use a syntax more typically associated with &quot;extends&quot; or &quot;implements&quot; or &quot;is a&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it be less confusing if the type of the property were implicit? In discussion with Brent, I suggested a model where you say:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var behavior foo { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and if you want to constrain the types of properties that can instantiate the behavior, you use a where clause:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var behavior foo where Value: NSCopying { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which optimizes the common case (no constraint), and might be easier to read.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Questions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can a behavior have generic parameters that can&#39;t be inferred? Could I write, say, [fooable&lt;Int&gt;]?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, the generic parameters are only used to generalize the property type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What is the tradeoff between `eager` and `deferred`? Is it &quot;only&quot; that `deferred` side effects happen at the mercy of the behavior?<br>&gt;&gt;&gt;&gt; If so, isn&#39;t it a problem that behaviors aren&#39;t intrinsically explicit about whether they defer initialization? I can see that causing very subtle bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The tradeoff is that an &#39;eager&#39; initialization can be used in `init`, but that means that an initializer expression can&#39;t refer to `self`, because `self` is not fully initialized. This is how initializer expressions always work today:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X {<br>&gt;&gt;&gt;   var x = 0, y = 1<br>&gt;&gt;&gt;   var z = x + y // Error<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A deferred initialization can only be evaluated *after* init, but because of that, it can refer to `self`, which people would like to be able to do with `lazy` (but currently can&#39;t):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X {<br>&gt;&gt;&gt;   var x = 0, y = 1<br>&gt;&gt;&gt;   lazy var z = x + y // Theoretically OK<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Concerns:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It looks like if you had a [resettable, observable] property, calling resettable.reset() would change the value from under `observable`&#39;s feet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; True. An unfortunate consequence of these things being user-defined is that there will always be &quot;wrong&quot; orderings of them. I&#39;m not sure how much we can do about that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While it might be true that square brackets work better with other declarations that could eventually have behaviors, &quot;var behavior&quot; doesn&#39;t really lend itself to that kind of extensibility. Are we steering towards &quot;func behavior&quot;, &quot;class behavior&quot;, etc? Is it a problem if we are?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Possibly. Note that square brackets are necessary even only for `var`, because you can declare a destructuring binding `var (x, y) = tuple`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to point out that the memoization example is a let variable with a behavior, which is explicitly forbidden by the current proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks, missed that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, I would like to throw the idea of &quot;foo..resettable&quot; to access foo&#39;s resettable behavior (or foo..reset() doing optionally-qualified lookup on foo&#39;s behavior methods).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not a bad suggestion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks again for the feedback!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/bfec1e2d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 13, 2016 at 10:00:00pm</p></header><div class="content"><p>Joe,<br></p><p>There seem to be many new syntactic features to support this, both inside and outside of a behavior. I was wondering if you had considered/had comments an alternative approach where you declare an ordinary new value type which meets certain rules and ‘wraps’ the existing type, then define new syntax/features in Swift for having the wrapper (or possibly even multiple levels of wrappers) be more transparent for use.<br></p><p>For instance, the existing ‘lazy’ keyword functionality might have been implemented by a type  Lazy&lt;T&gt;<br></p><p>struct Lazy&lt;T&gt; {<br>    private var val:T?<br>    let supplier:()-&gt;T<br>    <br>    init(supplier:()-&gt;T) {<br>        self.supplier = supplier<br>    }<br></p><p>    var value:T {<br>        mutating get {<br>            if val == nil {<br>                val = supplier()<br>            }<br>            return val!<br>        }<br>        set {<br>            val = value<br>        }<br>    }<br>    mutating func clear() {<br>        val = nil<br>    }<br></p><p>}<br></p><p>With the following as an example of use (without any additional syntactic features)<br></p><p>var globally = &quot;Test&quot;<br>class Foo {<br>    var bar = Lazy&lt;Int&gt; {<br>        globally = &quot;Side effect&quot;<br>        return 1<br>    }<br>}<br></p><p>print(globally)<br>Foo().bar.value<br>print(globally)<br>Foo().bar.clear()<br></p><p>One could opt into a syntax to allow value to be hidden from view. In fact, I can hide the use of the Lazy struct today if I’m willing to write more code:<br></p><p>class Foo {<br>    private var internalbar = Lazy&lt;Int&gt; {<br>        return 1<br>    }<br>    var bar:Int {<br>        get {<br>            return internalbar.value<br>        }<br>        set {<br>            internalbar.value = newValue<br>        }<br>    }<br>}<br>print(Foo().bar)<br></p><p>Which actually has the benefit of being able to call the clear() method without new syntax, and being able to control access to clear separate from the getter/setter<br></p><p>-DW<br></p><p><br>&gt; On Jan 13, 2016, at 3:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Here&#39;s the revised proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; <br>&gt; For reference, here&#39;s the previous iteration:<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/98f363a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; I was wondering if you had considered/had comments an alternative approach where you declare an ordinary new value type which meets certain rules and ‘wraps’ the existing type, then define new syntax/features in Swift for having the wrapper (or possibly even multiple levels of wrappers) be more transparent for use.<br></p><p>You might want to take a look at the first version of the proposal. It defined behaviors using existing constructs with certain conventions, and most posters argued that it was a bit of a mess and needed syntax to clarify what was happening.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 13, 2016 at 11:00:00pm</p></header><div class="content"><p>Interesting. I suppose that answers my question - the desire to have container references and initialization data presented during storage/retrieval (so that they do not need to be duplicated inside the wrapper type) resulted in types being required to look more like plugins to the type system rather than simple wrappers.<br></p><p>-DW<br></p><p>&gt; On Jan 13, 2016, at 10:53 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I was wondering if you had considered/had comments an alternative approach where you declare an ordinary new value type which meets certain rules and ‘wraps’ the existing type, then define new syntax/features in Swift for having the wrapper (or possibly even multiple levels of wrappers) be more transparent for use.<br>&gt; <br>&gt; You might want to take a look at the first version of the proposal. It defined behaviors using existing constructs with certain conventions, and most posters argued that it was a bit of a mess and needed syntax to clarify what was happening.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 9:34 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; Joe,<br>&gt; <br>&gt; There seem to be many new syntactic features to support this, both inside and outside of a behavior. I was wondering if you had considered/had comments an alternative approach where you declare an ordinary new value type which meets certain rules and ‘wraps’ the existing type, then define new syntax/features in Swift for having the wrapper (or possibly even multiple levels of wrappers) be more transparent for use.<br>&gt; <br>&gt; For instance, the existing ‘lazy’ keyword functionality might have been implemented by a type  Lazy&lt;T&gt;<br>&gt; <br>&gt; struct Lazy&lt;T&gt; {<br>&gt;     private var val:T?<br>&gt;     let supplier:()-&gt;T<br>&gt;     <br>&gt;     init(supplier:()-&gt;T) {<br>&gt;         self.supplier = supplier<br>&gt;     }<br>&gt; <br>&gt;     var value:T {<br>&gt;         mutating get {<br>&gt;             if val == nil {<br>&gt;                 val = supplier()<br>&gt;             }<br>&gt;             return val!<br>&gt;         }<br>&gt;         set {<br>&gt;             val = value<br>&gt;         }<br>&gt;     }<br>&gt;     mutating func clear() {<br>&gt;         val = nil<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; With the following as an example of use (without any additional syntactic features)<br>&gt; <br>&gt; var globally = &quot;Test&quot;<br>&gt; class Foo {<br>&gt;     var bar = Lazy&lt;Int&gt; {<br>&gt;         globally = &quot;Side effect&quot;<br>&gt;         return 1<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; print(globally)<br>&gt; Foo().bar.value<br>&gt; print(globally)<br>&gt; Foo().bar.clear()<br>&gt; <br>&gt; One could opt into a syntax to allow value to be hidden from view. In fact, I can hide the use of the Lazy struct today if I’m willing to write more code:<br>&gt; <br>&gt; class Foo {<br>&gt;     private var internalbar = Lazy&lt;Int&gt; {<br>&gt;         return 1<br>&gt;     }<br>&gt;     var bar:Int {<br>&gt;         get {<br>&gt;             return internalbar.value<br>&gt;         }<br>&gt;         set {<br>&gt;             internalbar.value = newValue<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; print(Foo().bar)<br>&gt; <br>&gt; Which actually has the benefit of being able to call the clear() method without new syntax, and being able to control access to clear separate from the getter/setter<br></p><p>Yes, this was explored by the previous iteration of the proposal. The exact design you propose is unacceptable for us, because it requires per-property instance storage for the &quot;supplier&quot; closure, which would be a massive regression from how `lazy` works today. To avoid this, the parameters of the property declaration need to be passed to the property implementation as well, so I had proposed using a subscript to handle it:<br></p><p>struct Lazy&lt;T&gt; {<br>  var value: T? = nil<br></p><p>  subscript(initialValue: () -&gt; T) -&gt; T { ... }<br>}<br></p><p>which is workable, but if we want this feature to have the flexibility to subsume all of our existing ad-hoc property features, the informal protocol between the behavior and the initialization and subscripting of the underlying type becomes fairly complex. Using types to encapsulate behaviors also introduces some runtime overhead we&#39;d like to avoid if possible.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 3:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt; <br>&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s the revised proposal:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3 &lt;https://gist.github.com/jckarter/50b838e7f036fe85eaa3&gt;<br>&gt;&gt; <br>&gt;&gt; For reference, here&#39;s the previous iteration:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt;&gt; <br>&gt;&gt; Thanks for taking a look!<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/1a8a6ee8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecb50a99bf3b4cc0249312945dce7115?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Ben Langmuir</string> &lt;blangmuir at apple.com&gt;<p>January 14, 2016 at 09:00:00am</p></header><div class="content"><p>Hey Joe,<br></p><p>Just a small bug report:<br>A deferred initializer is used only after the initialization of the behavior&#39;s state. A deferred initializer cannot be referenced until the behavior&#39;s storage is initialized. A property using the behavior can refer to self within its initializer expression, as one would expect a lazy property to be able to.<br></p><p>  var behavior deferredInit: Int {<br>    eager initializer: Int<br>Presumably “eager” should be “deferred” here.<br></p><p><br>&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Here&#39;s the revised proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; <br>&gt; For reference, here&#39;s the previous iteration:<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/0c6f9779/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 14, 2016 at 10:00:00am</p></header><div class="content"><p>Good catch, thanks!<br>&gt; On Jan 14, 2016, at 9:49 AM, Ben Langmuir &lt;blangmuir at apple.com&gt; wrote:<br>&gt; <br>&gt; Hey Joe,<br>&gt; <br>&gt; Just a small bug report:<br>&gt; A deferred initializer is used only after the initialization of the behavior&#39;s state. A deferred initializer cannot be referenced until the behavior&#39;s storage is initialized. A property using the behavior can refer to self within its initializer expression, as one would expect a lazy property to be able to.<br>&gt; <br>&gt;   var behavior deferredInit: Int {<br>&gt;     eager initializer: Int<br>&gt; Presumably “eager” should be “deferred” here.<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt; <br>&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s the revised proposal:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3 &lt;https://gist.github.com/jckarter/50b838e7f036fe85eaa3&gt;<br>&gt;&gt; <br>&gt;&gt; For reference, here&#39;s the previous iteration:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt;&gt; <br>&gt;&gt; Thanks for taking a look!<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/bbc82578/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 15, 2016 at 08:00:00am</p></header><div class="content"><p>Maybe this should be the way to access functions inside behaviours:<br></p><p>	&amp;myvar.resetable.reset()<br></p><p>By using `&amp;myvar`, we indicate that we want access to the variable, not its value, similar to how it works with `inout`. This would also fit well with a future extension where you could access behaviours through `inout` arguments.<br></p><p>Also, I think it&#39;s important that behaviour functions be accessible skipping the behaviour name. This syntax works well for this:<br></p><p>	&amp;myvar.reset()<br></p><p>If more than one behaviour implement a reset function, or if one of the behaviours is called `reset`, then you have to disambiguate using the behaviour name as a prefix.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 15, 2016 at 08:00:00am</p></header><div class="content"><p>Le 15 janv. 2016 à 8:19, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; Maybe this should be the way to access functions inside behaviours:<br>&gt; <br>&gt; 	&amp;myvar.resetable.reset()<br>&gt; <br>&gt; By using `&amp;myvar`, we indicate that we want access to the variable, not its value, similar to how it works with `inout`. This would also fit well with a future extension where you could access behaviours through `inout` arguments.<br>&gt; <br>&gt; Also, I think it&#39;s important that behaviour functions be accessible skipping the behaviour name. This syntax works well for this:<br>&gt; <br>&gt; 	&amp;myvar.reset()<br></p><p>And ten seconds after posting, I realize this would be ambiguous with `inout` in cases like this:<br></p><p>	foo(&amp;myvar.somefield)<br></p><p>so, nevermind.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>January 15, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Joe,<br></p><p>My overall impression is that this is moving in the right direction and getting close.  It is going to be a great feature!  The declaration syntax makes is much more clear and also more scalable. <br></p><p>Many good questions have already come up so I’ll just focus on things that haven’t been discussed yet.<br></p><p>The proposal makes it clear when an initializer is required but is a little bit less clear about when it may be left off.  Is this correct?<br></p><p>var [baseProp] x // no initializer, ok as long as base doesn&#39;t have init req?<br>var [initializerReqt] y // no initializer, error because of the initializer requirement?<br></p><p>Another thing that isn’t clear is what happens when a property with a behavior is set within the initializer of the containing type:<br></p><p>struct S {<br>  var [observed] s: String<br>  init(s: String) {<br>    // What happens here?  Is the behaviors “set” accessor called?  <br>    // This may not always be desirable, as in the case of “observed&quot;<br>    self.s = s<br>  }<br>}<br></p><p>One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br></p><p>This would also allow us to support a variant `delayedImmutable` that *must* be assigned during initialization of the containing type, but not necessarily during phase 1.  That behavior would facilitate maximum safety when we must pass `self` to the initializer when constructing an instance to assign to a property (not an uncommon use case).  <br></p><p>If the compiler could enforce slightly relaxed initialization rules that require initialization of the property before the initializer exits and before the property is read in the initializer body, but not necessarily during phase 1, then we could achieve nearly complete static safety.  The only window for error would be any uses of self that happen outside the initializer body before the property is initialized.  <br></p><p>The behavior might look like this:<br></p><p>public var behavior phase2Immutable&lt;Value&gt;: Value {<br>  private var value: Value? = nil<br></p><p>  get {<br>    guard let value = value else {<br>      fatalError(&quot;property accessed before being initialized&quot;)<br>    }<br>    return value<br>  }<br>  <br>  init {<br>    value = initialValue<br>  }<br>}<br></p><p>This would be a significant improvement over delayedImmutable in many use cases IMO.<br></p><p>-Matthew<br></p><p>&gt; On Jan 13, 2016, at 4:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Here&#39;s the revised proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; <br>&gt; For reference, here&#39;s the previous iteration:<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/90edaca7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>January 15, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>This looks like a GREAT feature.  I’ve read it a few times and I am still assimilating the concepts involved and the syntax.<br></p><p>I remember in the NeXT days when we had Enterprise Objects Framework, which is similar to Core Data.  Model objects were called Enterprise Objects or EOs for short (equivalent to managed objects in Core Data). These objects had properties that represented a to-one relationship or perhaps a to-many relationship.  For example, a Blog object could have an author property that pointed to a Person object.  <br></p><p>In Enterprise Objects the object graph was loaded on demand.  So for example, you can fetch a Blog object from the database that references a Person object via its author property.  Accessing aBlog.author does not incur a fetch of the Person object.  However, accessing aBlog.author.name does incur a fetch to bring the corresponding Person object into memory in order to get from it the value for the name property.  <br></p><p>This magic relied on stand-in objects, also known as fault objects (i.e. EOFault) and Objective-C’s selector forwarding amongst other things.  So for example, if you accessed aBlog.author it would return an EOFault as a stand-in for the Person object. <br></p><p>If you then messaged the fault object with name, then the fault is given a chance by the Objective-C runtime to forward the name message, to which the stand-in responds to by fetching the data for the corresponding Person and turn itself magically into a Person object and send itself the name message.  At a high level that is how the magic happened. It can be described as elegant, magical or perhaps clever.<br></p><p>I remember there were many that wanted Enterprise Objects on java but it was argued that java did not have what it took.  Then NeXT ported Enterprise Objects Framework to java relying on willRead() calls inside property getter methods to check to see if the data was in memory and fetch it if necessary.<br></p><p>Now, if I am understanding this property behavior proposal correctly, it seems to me that this mechanism of on-demand loading of an object graph could be implemented using property behaviors.  Am I right in saying that property behaviors could be used for something like this?<br></p><p>It’s been fascinating reading about this topic and all the different property behaviors.  I would imagine there would be a bunch of well known property behaviors implemented in the library somewhere and most developer will be using property behaviors rather than authoring them.<br></p><p><br></p><p><br>&gt; On Jan 13, 2016, at 5:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Here&#39;s the revised proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; <br>&gt; For reference, here&#39;s the previous iteration:<br>&gt; <br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; Thanks for taking a look!<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160115/ef77d2a1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 16, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m always in favor of removing special cases (like lazy and willSet/didSet), so the idea of property behaviors itself is very appealing to me.<br>There&#39;s one downside, though:<br>The proposal makes some keywords obsolete, but introduces a whole bunch of new stuff in exchange — and all of this only can be used with properties…<br></p><p>I hope you agree with me that there is merit in keeping the language small (it&#39;s called &quot;Swift&quot;, not &quot;Turkey&quot; ;-), and that the proposal would improve if it&#39;s possible to slim it down.<br></p><p>Imho the first step to add property behaviors should be refining how properties are modeled in Swift:<br>In many languages, properties are represented as a pair of methods (setter and getter), and their absence has several downsides (functional programming works best with functions ;-).<br></p><p>As soon as there is a way to read and write properties in a functional way, their behaviors could be expressed in a universal manner:<br>Afaics, all major use cases for behaviors can be implemented as simple &quot;decorators&quot; — in fact, I could simulate most examples from the proposal in a tiny playground (a part of it is attached).<br>Of course, the simulation is ugly, but I am confident that some nice ideas would come up if properties were more accessible.<br></p><p>Best regards,<br>Tino<br></p><p>//: Properties are modelled as a getter/setter pair<br>struct Property&lt;T&gt; {<br>	var get: Void -&gt; T<br>	var set: (T) -&gt; Void<br>}<br></p><p>class Test {<br>	// A field to store the actual data<br>	var mValue: Int?<br></p><p>	// This is our &quot;pseudo-property&quot;: Just imaging that `self.value.get` maps to `self.value`<br>	var value = Property(get: { return 0 }, set: { Int in } )<br></p><p>	init() {<br>		// This is necessary because we need `self` to fake the getter/setter<br>		value = Property(get: { return self.mValue! }, set: { self.mValue = $0 })<br>	}<br>}<br></p><p><br>/*:<br>Behaviors are modelled as a transformation:<br>The take a set of functions and return another set the is extended according to the behavior.<br></p><p>A real implementation would gain more clarity from the (deprecated...) currying-syntax<br>*/<br>func didSetBehavior&lt;T&gt;(property: Property&lt;T&gt;, didSet: (T) -&gt; Void) -&gt; Property&lt;T&gt; {<br>	func setter(value: T) {<br>		property.set(value)<br>		didSet(value)<br>	}<br>	return Property(get: property.get, set: setter)<br>}<br></p><p>class DidSet: Test {<br>//: Imagine we have no superclass, and `value` is declared like<br></p><p>/*:<br>	var[didSetBehavior {<br>		print(&quot;New value is \($0)&quot;)<br>	}] value: Int<br>*/<br>	override init() {<br>		super.init()<br>		value = didSetBehavior(value) {<br>			print(&quot;New value is \($0)&quot;)<br>		}<br>	}<br>}<br></p><p>func willSetBehavior&lt;T&gt;(property: Property&lt;T&gt;)(allow: (old: T, new: T) -&gt; Bool) -&gt; Property&lt;T&gt; {<br>	func setter(new: T) {<br>		if allow(old: property.get(), new: new) {<br>			property.set(new)<br>		}<br>	}<br>	return Property(get: property.get, set: setter)<br>}<br></p><p>class WillSet: Test {<br>	override init() {<br>		super.init()<br>		self.value = willSetBehavior(value)(allow: { return $0 != $1 } )<br>	}<br>}<br></p><p>class WillSetDidSet: WillSet {<br>	override init() {<br>		super.init()<br>		self.value = didSetBehavior(value) {<br>			print(&quot;New value is \($0)&quot;)<br>		}<br>	}<br>}<br></p><p>func copyBehavior&lt;T: NSCopying&gt;(property: Property&lt;T&gt;) -&gt; Property&lt;T&gt; {<br>	func performCopy(value: T) {<br>		let copy = value.copyWithZone(nil) as! T<br>		property.set(copy)<br>	}<br>	return Property(get: property.get, set: performCopy)<br>}<br></p><p>class Copy {<br>	var mValue = NSString()<br>	var value = Property(get: { return NSString() }, set: { NSString in return } )<br></p><p>	init() {<br>		value = Property(get: { return self.mValue }, set: { self.mValue = $0 })<br>		self.value = copyBehavior(value)<br>	}<br></p><p>}<br></p><p>let copyTest = Copy()<br>print(copyTest.value.get())<br>var mutableString = NSMutableString(string: &quot;Mutable&quot;)<br>copyTest.value.set(mutableString)<br>mutableString.appendString(&quot; string&quot;)<br>print(copyTest.value.get())<br></p><p>func decorate&lt;In, Out, Discard&gt;(function: (In) -&gt; Out, decoration: (In) -&gt; Discard) -&gt; (In) -&gt; Out {<br>	func result(input: In) -&gt; Out {<br>		decoration(input)<br>		return function(input)<br>	}<br>	return result<br>}<br></p><p>class FuncTest {<br>	var f = { (input: String) in<br>		print(input)<br>	}<br></p><p>	init() {<br>		self.f = decorate(f) { input in<br>			print(&quot;Our input is \(input)&quot;)<br>		}<br>	}<br>}<br></p><p>FuncTest().f(&quot;duplicated&quot;)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/3fc09dac/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 16, 2016, at 4:39 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; I&#39;m always in favor of removing special cases (like lazy and willSet/didSet), so the idea of property behaviors itself is very appealing to me.<br>&gt; There&#39;s one downside, though:<br>&gt; The proposal makes some keywords obsolete, but introduces a whole bunch of new stuff in exchange — and all of this only can be used with properties…<br>&gt; <br>&gt; I hope you agree with me that there is merit in keeping the language small (it&#39;s called &quot;Swift&quot;, not &quot;Turkey&quot; ;-), and that the proposal would improve if it&#39;s possible to slim it down.<br>&gt; <br>&gt; Imho the first step to add property behaviors should be refining how properties are modeled in Swift:<br>&gt; In many languages, properties are represented as a pair of methods (setter and getter), and their absence has several downsides (functional programming works best with functions ;-).<br>&gt; <br>&gt; As soon as there is a way to read and write properties in a functional way, their behaviors could be expressed in a universal manner:<br>&gt; Afaics, all major use cases for behaviors can be implemented as simple &quot;decorators&quot; — in fact, I could simulate most examples from the proposal in a tiny playground (a part of it is attached).<br>&gt; Of course, the simulation is ugly, but I am confident that some nice ideas would come up if properties were more accessible.<br></p><p>Believe me, I would prefer to keep the language impact small too. There are a couple of issues that make this difficult with property behaviors:<br></p><p>- First of all, Swift properties are *not* a simple getter-setter pair. Get and set is an inefficient protocol for value types, since any mutation of part of a value through get/set requires copying the entire value by &#39;get&#39;, mutating the temporary copy, then copying the entire modified value back by &#39;set&#39;. If properties were limited to a get/set interface, every partial update of an array &#39;foo.arrayProperty[0] = 1&#39; would force at minimum one full copy of the array buffer. It&#39;s better to think of a property as a mutable projection function, `inout T -&gt; inout U`, and in fact I plan to propose allowing &#39;inout&#39; returns as a way of abstracting over properties and other projections.<br></p><p>- If we had inout-projecting functions, it&#39;s true that the property implementation part of most behaviors could be modeled as functional transformations, e.g.:<br></p><p>// Turn an optional property into a &#39;lazy&#39; non-optional property<br>func lazy&lt;Container, Value&gt;(@autoclosure initialValue initialValue: () -&gt; Value, property: inout Value?) -&gt; inout Value {<br>  func adapter() -&gt; inout Value<br>    get {<br>      if let value = property() { return value }<br>      let initial = initialValue()<br>      property() = initial<br>      return initial<br>    }<br>    set {<br>      property() = newValue<br>    }<br>  }<br>  return adapter<br>}<br></p><p>However, there&#39;s more to a behavior than the property implementation itself. We also want behaviors to be able to encapsulate the backing storage for their properties, including their initialization. The compiler could perhaps infer backward from the signature of `lazy` above that, in order to produce a lazy property of type `Value`, it needs to back it with a property of type `Value?`, but it still doesn&#39;t know how or when `lazy` expects that storage to be initialized. Furthermore, we want behaviors to be able to attach behavior-specific operations to their properties, such as to clear a lazy property or reset a property to a private default value. While both of these issues can be addressed by explicitly exposing the backing storage as a separate property:<br></p><p>var fooStorage: Int? = nil<br>var foo: Int { return &amp;lazy(initialValue: 1738, property: &amp;fooStorage) }<br></p><p>that&#39;s quite a bit of boilerplate, and it also clutters the user interface for the type, since the storage now appears as a separate entity from the property itself. We want behaviors to be lightweight and easy to use, and on balance I think the best way to deliver that is with some specialized functionality.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/5b09356c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 17, 2016 at 03:00:00pm</p></header><div class="content"><p>Thank you for the thorough explanation — it is an interesting insight in Swift internals and helps to understand some decisions made.<br></p><p>&gt; - First of all, Swift properties are *not* a simple getter-setter pair.<br>Just out of curiosity: Are there more methods involved, or are the getters &amp; setters just less simple than expected?<br></p><p>In the meantime, I&#39;ve read the first published draft which was helpful as well:<br>Correct me if I&#39;m wrong, but my understanding is that behaviors could be seen as property containers that are merged into the object they belong to, right? At least, this model makes the proposed meaning of self inside behaviors more intuitive. <br></p><p>Is there are reason why arrow brackets (&quot;var&lt;lazy&gt; foo…&quot;) haven&#39;t been considered for declaration?<br>Both generics and behaviors predefine details at compile time, so I see more similarities than with all other possible types of brackets, which usually have a well-defined meaning.<br>I guess there is a possible source of confusion if the concept is extended to functions, but imho that could be resolved easily.<br>Btw:<br>Are there already ideas how to use behaviors in other places (functions, subscripts — maybe even types)?<br></p><p>How about behaviors that need parameters? The alternative &quot;keyword&quot;-declaration (I have seen the &quot;by&quot; in Kotlin, so I guess it&#39;s a Scala-invention ;-) offers an obvious answer here, but I&#39;m not sure for the other variants.<br></p><p>Would it be possible to add behaviors in subclasses?<br></p><p>I guess most of my questions have already been discussed, but I couldn&#39;t find answers in the public archives...<br></p><p>Best regards,<br>Tino<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt; <br>&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br></p><p>Syntax comments:<br></p><p>I still think these feel attribute-like to me, but if we’re not just going to use @lazy — and I agree that that does have some problems —I’m fine with [lazy].<br></p><p>&quot;var behavior&quot; is really weird to me, and the &lt;T&gt; doesn’t seem to fit and is pretty redundant in the common case.  How about this:<br></p><p>  &quot;behavior&quot; var-or-let &quot;[&quot; identifier-list &quot;]&quot; (identifier | &quot;_&quot;) &quot;:&quot; identifier (&quot;=&quot; identifier)? (&quot;where&quot; generic-requirement-list)?<br></p><p>So, for example,<br>  behavior var [lazy] _ : T where T : IntegerLiteralConvertible { … }<br></p><p>This is definitely taking the idea of “this is basically a macro” and running with it.  Think of the stuff between “behavior” and the optional “where” as being a pattern for the declaration.  So this pattern would match:<br>  var [lazy] x: Int<br>but not:<br>  let [lazy] x: Int<br>or:<br>  var [lazy] x : Int = foo()<br></p><p>The behavior list has to match exactly (or maybe as sets?).<br></p><p>The property name, if bound, expands to a string literal within the behavior.<br></p><p>The type name is always a generic parameter.  This interferes with the ability to make a pattern that only matches a concrete type, but I think that’s okay.<br></p><p>The initializer name, if bound, expands to the original expression within the behavior.  Maybe it should be coerced to type T first?  Not sure.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/8c5dc3cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 2:46 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt; <br>&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Syntax comments:<br>&gt; <br>&gt; I still think these feel attribute-like to me, but if we’re not just going to use @lazy — and I agree that that does have some problems —I’m fine with [lazy].<br></p><p>I&#39;m OK with using attribute syntax alongside the declaration approach.<br></p><p>&gt; <br>&gt; &quot;var behavior&quot; is really weird to me, and the &lt;T&gt; doesn’t seem to fit and is pretty redundant in the common case.  How about this:<br>&gt; <br>&gt;   &quot;behavior&quot; var-or-let &quot;[&quot; identifier-list &quot;]&quot; (identifier | &quot;_&quot;) &quot;:&quot; identifier (&quot;=&quot; identifier)? (&quot;where&quot; generic-requirement-list)?<br>&gt; <br>&gt; So, for example,<br>&gt;   behavior var [lazy] _ : T where T : IntegerLiteralConvertible { … }<br>&gt; <br>&gt; This is definitely taking the idea of “this is basically a macro” and running with it.  Think of the stuff between “behavior” and the optional “where” as being a pattern for the declaration.  So this pattern would match:<br>&gt;   var [lazy] x: Int<br>&gt; but not:<br>&gt;   let [lazy] x: Int<br>&gt; or:<br>&gt;   var [lazy] x : Int = foo()<br></p><p>Good idea, I like this approach. However:<br></p><p>&gt; The behavior list has to match exactly (or maybe as sets?).<br></p><p>Are you saying that there would be no ad-hoc composition of behaviors? This seems to imply that you&#39;d need to implement every valid combination of behaviors by hand. That&#39;s a defensible position, given that it&#39;s easy to compose behaviors like &quot;synchronized&quot; in the wrong order, but significantly stifles behaviors like didSet/willSet that are more likely to be order-agnostic.<br></p><p>&gt; <br>&gt; The property name, if bound, expands to a string literal within the behavior.<br>&gt; <br>&gt; The type name is always a generic parameter.  This interferes with the ability to make a pattern that only matches a concrete type, but I think that’s okay.<br></p><p>Seems reasonable, since unconstrained behaviors are likely to be the 95% case. Being able to match concrete types is something we ought to be able solve uniformly with the same limitation on constrained extensions.<br></p><p>&gt; The initializer name, if bound, expands to the original expression within the behavior.  Maybe it should be coerced to type T first?  Not sure.<br></p><p>Yeah, JoeP brought up a good question about how &#39;var&#39; type inference should work with initializer expressions. There are two possible models I can see:<br></p><p>- We infer the type of the initializer independent of any applied behaviors, and raise an error if the behavior can&#39;t be instantiated at the given type.<br>- We add generic constraints from the behavior declaration(s) to the contextual type of the initializer.<br></p><p>In support of the latter approach, &#39;weak&#39; properties currently factor their Optional constraint into type inference (&#39;weak var foo = Foo()&#39; gives you a property of type Foo?), and &#39;weak&#39; has been raised as a candidate for eventual behavior-ization. The downside, of course, is that with arbitrary user-defined behaviors with arbitrary generic constraints, there&#39;s yet another source of potential surprise if the type context of behaviors changes the type-checking of an expression.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/ea2e79e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 3:10 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The behavior list has to match exactly (or maybe as sets?).<br>&gt; <br>&gt; Are you saying that there would be no ad-hoc composition of behaviors? This seems to imply that you&#39;d need to implement every valid combination of behaviors by hand. That&#39;s a defensible position, given that it&#39;s easy to compose behaviors like &quot;synchronized&quot; in the wrong order, but significantly stifles behaviors like didSet/willSet that are more likely to be order-agnostic.<br></p><p>Perhaps we could use &#39;...&#39; to distinguish composable and non-composable behaviors:<br></p><p>// Implementation of exactly [lazy, synchronized]<br>behavior var [lazy, synchronized] _: Value where Self: Synchronizable { ... }<br></p><p>// Implementation of &#39;observed&#39; composed with any other behavior<br>behavior var […, observed] _: Value { ... }<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/57aac093/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 3:10 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 19, 2016, at 2:46 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt;&gt; <br>&gt;&gt; Syntax comments:<br>&gt;&gt; <br>&gt;&gt; I still think these feel attribute-like to me, but if we’re not just going to use @lazy — and I agree that that does have some problems —I’m fine with [lazy].<br>&gt; <br>&gt; I&#39;m OK with using attribute syntax alongside the declaration approach.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &quot;var behavior&quot; is really weird to me, and the &lt;T&gt; doesn’t seem to fit and is pretty redundant in the common case.  How about this:<br>&gt;&gt; <br>&gt;&gt;   &quot;behavior&quot; var-or-let &quot;[&quot; identifier-list &quot;]&quot; (identifier | &quot;_&quot;) &quot;:&quot; identifier (&quot;=&quot; identifier)? (&quot;where&quot; generic-requirement-list)?<br>&gt;&gt; <br>&gt;&gt; So, for example,<br>&gt;&gt;   behavior var [lazy] _ : T where T : IntegerLiteralConvertible { … }<br>&gt;&gt; <br>&gt;&gt; This is definitely taking the idea of “this is basically a macro” and running with it.  Think of the stuff between “behavior” and the optional “where” as being a pattern for the declaration.  So this pattern would match:<br>&gt;&gt;   var [lazy] x: Int<br>&gt;&gt; but not:<br>&gt;&gt;   let [lazy] x: Int<br>&gt;&gt; or:<br>&gt;&gt;   var [lazy] x : Int = foo()<br>&gt; <br>&gt; Good idea, I like this approach. However:<br>&gt; <br>&gt;&gt; The behavior list has to match exactly (or maybe as sets?).<br>&gt; <br>&gt; Are you saying that there would be no ad-hoc composition of behaviors? This seems to imply that you&#39;d need to implement every valid combination of behaviors by hand. That&#39;s a defensible position, given that it&#39;s easy to compose behaviors like &quot;synchronized&quot; in the wrong order, but significantly stifles behaviors like didSet/willSet that are more likely to be order-agnostic.<br></p><p>My first instinct is to say that ad-hoc composition is too treacherous to include in the first model, yeah.<br></p><p>I like the idea of having a model that works for literally everything that’s not pure-computed or pure-stored, but it seems tolerable to continue to build in things like willSet / didSet if it significantly simplifies the problem.  willSet / didSet have some pretty custom behavior and dependencies on the container.  OTOH, maybe that kind of thing is a core requirement for some of the stuff we’re thinking of doing.<br></p><p>&gt;&gt; The property name, if bound, expands to a string literal within the behavior.<br>&gt;&gt; <br>&gt;&gt; The type name is always a generic parameter.  This interferes with the ability to make a pattern that only matches a concrete type, but I think that’s okay.<br>&gt; <br>&gt; Seems reasonable, since unconstrained behaviors are likely to be the 95% case. Being able to match concrete types is something we ought to be able solve uniformly with the same limitation on constrained extensions.<br></p><p>Yeah.<br></p><p>&gt;&gt; The initializer name, if bound, expands to the original expression within the behavior.  Maybe it should be coerced to type T first?  Not sure.<br>&gt; <br>&gt; Yeah, JoeP brought up a good question about how &#39;var&#39; type inference should work with initializer expressions. There are two possible models I can see:<br>&gt; <br>&gt; - We infer the type of the initializer independent of any applied behaviors, and raise an error if the behavior can&#39;t be instantiated at the given type.<br>&gt; - We add generic constraints from the behavior declaration(s) to the contextual type of the initializer.<br>&gt; <br>&gt; In support of the latter approach, &#39;weak&#39; properties currently factor their Optional constraint into type inference (&#39;weak var foo = Foo()&#39; gives you a property of type Foo?), and &#39;weak&#39; has been raised as a candidate for eventual behavior-ization. The downside, of course, is that with arbitrary user-defined behaviors with arbitrary generic constraints, there&#39;s yet another source of potential surprise if the type context of behaviors changes the type-checking of an expression.<br></p><p>Yeah, especially because the initializer could be used in multiple places in the behavior.  Coercing the initializer seems a lot less surprising.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/813fca82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 4:28 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 3:10 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jan 19, 2016, at 2:46 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt;&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt;&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Syntax comments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still think these feel attribute-like to me, but if we’re not just going to use @lazy — and I agree that that does have some problems —I’m fine with [lazy].<br>&gt;&gt; <br>&gt;&gt; I&#39;m OK with using attribute syntax alongside the declaration approach.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;var behavior&quot; is really weird to me, and the &lt;T&gt; doesn’t seem to fit and is pretty redundant in the common case.  How about this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   &quot;behavior&quot; var-or-let &quot;[&quot; identifier-list &quot;]&quot; (identifier | &quot;_&quot;) &quot;:&quot; identifier (&quot;=&quot; identifier)? (&quot;where&quot; generic-requirement-list)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, for example,<br>&gt;&gt;&gt;   behavior var [lazy] _ : T where T : IntegerLiteralConvertible { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is definitely taking the idea of “this is basically a macro” and running with it.  Think of the stuff between “behavior” and the optional “where” as being a pattern for the declaration.  So this pattern would match:<br>&gt;&gt;&gt;   var [lazy] x: Int<br>&gt;&gt;&gt; but not:<br>&gt;&gt;&gt;   let [lazy] x: Int<br>&gt;&gt;&gt; or:<br>&gt;&gt;&gt;   var [lazy] x : Int = foo()<br>&gt;&gt; <br>&gt;&gt; Good idea, I like this approach. However:<br>&gt;&gt; <br>&gt;&gt;&gt; The behavior list has to match exactly (or maybe as sets?).<br>&gt;&gt; <br>&gt;&gt; Are you saying that there would be no ad-hoc composition of behaviors? This seems to imply that you&#39;d need to implement every valid combination of behaviors by hand. That&#39;s a defensible position, given that it&#39;s easy to compose behaviors like &quot;synchronized&quot; in the wrong order, but significantly stifles behaviors like didSet/willSet that are more likely to be order-agnostic.<br>&gt; <br>&gt; My first instinct is to say that ad-hoc composition is too treacherous to include in the first model, yeah.<br>&gt; <br>&gt; I like the idea of having a model that works for literally everything that’s not pure-computed or pure-stored, but it seems tolerable to continue to build in things like willSet / didSet if it significantly simplifies the problem.  willSet / didSet have some pretty custom behavior and dependencies on the container.  OTOH, maybe that kind of thing is a core requirement for some of the stuff we’re thinking of doing.<br></p><p>I think you can define a reasonable facsimile of willSet/didSet under my proposal, but I&#39;m willing to believe there are edge cases I&#39;m missing. What sort of custom behavior do you have in mind?<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt;&gt; The property name, if bound, expands to a string literal within the behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The type name is always a generic parameter.  This interferes with the ability to make a pattern that only matches a concrete type, but I think that’s okay.<br>&gt;&gt; <br>&gt;&gt; Seems reasonable, since unconstrained behaviors are likely to be the 95% case. Being able to match concrete types is something we ought to be able solve uniformly with the same limitation on constrained extensions.<br>&gt; <br>&gt; Yeah.<br>&gt; <br>&gt;&gt;&gt; The initializer name, if bound, expands to the original expression within the behavior.  Maybe it should be coerced to type T first?  Not sure.<br>&gt;&gt; <br>&gt;&gt; Yeah, JoeP brought up a good question about how &#39;var&#39; type inference should work with initializer expressions. There are two possible models I can see:<br>&gt;&gt; <br>&gt;&gt; - We infer the type of the initializer independent of any applied behaviors, and raise an error if the behavior can&#39;t be instantiated at the given type.<br>&gt;&gt; - We add generic constraints from the behavior declaration(s) to the contextual type of the initializer.<br>&gt;&gt; <br>&gt;&gt; In support of the latter approach, &#39;weak&#39; properties currently factor their Optional constraint into type inference (&#39;weak var foo = Foo()&#39; gives you a property of type Foo?), and &#39;weak&#39; has been raised as a candidate for eventual behavior-ization. The downside, of course, is that with arbitrary user-defined behaviors with arbitrary generic constraints, there&#39;s yet another source of potential surprise if the type context of behaviors changes the type-checking of an expression.<br>&gt; <br>&gt; Yeah, especially because the initializer could be used in multiple places in the behavior.  Coercing the initializer seems a lot less surprising.<br>&gt; <br>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/9695e0fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 19, 2016, at 4:28 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 3:10 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 2:46 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt;&gt;&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt;&gt;&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Syntax comments:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still think these feel attribute-like to me, but if we’re not just going to use @lazy — and I agree that that does have some problems —I’m fine with [lazy].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m OK with using attribute syntax alongside the declaration approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;var behavior&quot; is really weird to me, and the &lt;T&gt; doesn’t seem to fit and is pretty redundant in the common case.  How about this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   &quot;behavior&quot; var-or-let &quot;[&quot; identifier-list &quot;]&quot; (identifier | &quot;_&quot;) &quot;:&quot; identifier (&quot;=&quot; identifier)? (&quot;where&quot; generic-requirement-list)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, for example,<br>&gt;&gt;&gt;&gt;   behavior var [lazy] _ : T where T : IntegerLiteralConvertible { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is definitely taking the idea of “this is basically a macro” and running with it.  Think of the stuff between “behavior” and the optional “where” as being a pattern for the declaration.  So this pattern would match:<br>&gt;&gt;&gt;&gt;   var [lazy] x: Int<br>&gt;&gt;&gt;&gt; but not:<br>&gt;&gt;&gt;&gt;   let [lazy] x: Int<br>&gt;&gt;&gt;&gt; or:<br>&gt;&gt;&gt;&gt;   var [lazy] x : Int = foo()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good idea, I like this approach. However:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The behavior list has to match exactly (or maybe as sets?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you saying that there would be no ad-hoc composition of behaviors? This seems to imply that you&#39;d need to implement every valid combination of behaviors by hand. That&#39;s a defensible position, given that it&#39;s easy to compose behaviors like &quot;synchronized&quot; in the wrong order, but significantly stifles behaviors like didSet/willSet that are more likely to be order-agnostic.<br>&gt;&gt; <br>&gt;&gt; My first instinct is to say that ad-hoc composition is too treacherous to include in the first model, yeah.<br>&gt;&gt; <br>&gt;&gt; I like the idea of having a model that works for literally everything that’s not pure-computed or pure-stored, but it seems tolerable to continue to build in things like willSet / didSet if it significantly simplifies the problem.  willSet / didSet have some pretty custom behavior and dependencies on the container.  OTOH, maybe that kind of thing is a core requirement for some of the stuff we’re thinking of doing.<br>&gt; <br>&gt; I think you can define a reasonable facsimile of willSet/didSet under my proposal, but I&#39;m willing to believe there are edge cases I&#39;m missing. What sort of custom behavior do you have in mind?<br></p><p>Well, for one, we only load the old value if the didSet is actually declared.  There’s also the longstanding idea — apparently still not implemented — that we’d only do so if didSet actually used the old value.  The ideal result here really needs macro metaprogramming, I think, unless you’re going to get very sophisticated about accessor declarations.<br></p><p>One of my worries about this proposal in general is that you’ve listed out half-a-dozen different uses and every single one seems to require a new twist on the core semantics.<br></p><p>John.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The property name, if bound, expands to a string literal within the behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The type name is always a generic parameter.  This interferes with the ability to make a pattern that only matches a concrete type, but I think that’s okay.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seems reasonable, since unconstrained behaviors are likely to be the 95% case. Being able to match concrete types is something we ought to be able solve uniformly with the same limitation on constrained extensions.<br>&gt;&gt; <br>&gt;&gt; Yeah.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The initializer name, if bound, expands to the original expression within the behavior.  Maybe it should be coerced to type T first?  Not sure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, JoeP brought up a good question about how &#39;var&#39; type inference should work with initializer expressions. There are two possible models I can see:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - We infer the type of the initializer independent of any applied behaviors, and raise an error if the behavior can&#39;t be instantiated at the given type.<br>&gt;&gt;&gt; - We add generic constraints from the behavior declaration(s) to the contextual type of the initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In support of the latter approach, &#39;weak&#39; properties currently factor their Optional constraint into type inference (&#39;weak var foo = Foo()&#39; gives you a property of type Foo?), and &#39;weak&#39; has been raised as a candidate for eventual behavior-ization. The downside, of course, is that with arbitrary user-defined behaviors with arbitrary generic constraints, there&#39;s yet another source of potential surprise if the type context of behaviors changes the type-checking of an expression.<br>&gt;&gt; <br>&gt;&gt; Yeah, especially because the initializer could be used in multiple places in the behavior.  Coercing the initializer seems a lot less surprising.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/bf296037/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 6:38 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jan 19, 2016, at 4:28 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 3:10 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jan 19, 2016, at 2:46 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt;&gt;&gt;&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt;&gt;&gt;&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Syntax comments:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still think these feel attribute-like to me, but if we’re not just going to use @lazy — and I agree that that does have some problems —I’m fine with [lazy].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m OK with using attribute syntax alongside the declaration approach.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;var behavior&quot; is really weird to me, and the &lt;T&gt; doesn’t seem to fit and is pretty redundant in the common case.  How about this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   &quot;behavior&quot; var-or-let &quot;[&quot; identifier-list &quot;]&quot; (identifier | &quot;_&quot;) &quot;:&quot; identifier (&quot;=&quot; identifier)? (&quot;where&quot; generic-requirement-list)?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, for example,<br>&gt;&gt;&gt;&gt;&gt;   behavior var [lazy] _ : T where T : IntegerLiteralConvertible { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is definitely taking the idea of “this is basically a macro” and running with it.  Think of the stuff between “behavior” and the optional “where” as being a pattern for the declaration.  So this pattern would match:<br>&gt;&gt;&gt;&gt;&gt;   var [lazy] x: Int<br>&gt;&gt;&gt;&gt;&gt; but not:<br>&gt;&gt;&gt;&gt;&gt;   let [lazy] x: Int<br>&gt;&gt;&gt;&gt;&gt; or:<br>&gt;&gt;&gt;&gt;&gt;   var [lazy] x : Int = foo()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good idea, I like this approach. However:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The behavior list has to match exactly (or maybe as sets?).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Are you saying that there would be no ad-hoc composition of behaviors? This seems to imply that you&#39;d need to implement every valid combination of behaviors by hand. That&#39;s a defensible position, given that it&#39;s easy to compose behaviors like &quot;synchronized&quot; in the wrong order, but significantly stifles behaviors like didSet/willSet that are more likely to be order-agnostic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My first instinct is to say that ad-hoc composition is too treacherous to include in the first model, yeah.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the idea of having a model that works for literally everything that’s not pure-computed or pure-stored, but it seems tolerable to continue to build in things like willSet / didSet if it significantly simplifies the problem.  willSet / didSet have some pretty custom behavior and dependencies on the container.  OTOH, maybe that kind of thing is a core requirement for some of the stuff we’re thinking of doing.<br>&gt;&gt; <br>&gt;&gt; I think you can define a reasonable facsimile of willSet/didSet under my proposal, but I&#39;m willing to believe there are edge cases I&#39;m missing. What sort of custom behavior do you have in mind?<br>&gt; <br>&gt; Well, for one, we only load the old value if the didSet is actually declared.  There’s also the longstanding idea — apparently still not implemented — that we’d only do so if didSet actually used the old value.  The ideal result here really needs macro metaprogramming, I think, unless you’re going to get very sophisticated about accessor declarations.<br></p><p>One of the nice things about last month&#39;s function-based proposal was that it allowed overloading a behavior, which could allow for the right variation of behavior to be chosen given different accessors. We could possibly make this work for behavior decls too, treating the set of accessor requirements as the &quot;signature&quot; of a behavior. Even without overloading, we could separate &#39;didSet&#39; and &#39;willSet&#39; into separate behaviors that can be optionally composed.<br></p><p>&gt; One of my worries about this proposal in general is that you’ve listed out half-a-dozen different uses and every single one seems to require a new twist on the core semantics.<br></p><p>Yeah, that worries me too. I think though that these twists are sugar over the basic functionality, though. Fundamentally we want a way to factor out one or both of two things:<br></p><p>- The storage that gets instantiated for a property, and/or<br>- The get/materializeForSet/set implementations that get run for a property.<br></p><p>Most of the accessor and initializer complexity is essentially sugar for parameterizing the behavior. Many in this thread have proposed allowing direct parameterization of the behavior like &#39;var [behavior(param)]&#39;; if the behavior could allocate and initialize static storage to capture those parameters, you could do everything you can with accessors or bound initializers (modulo &quot;only&quot; syntactic things like type-inferencing properties from initializer expressions).<br></p><p>-Joe<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The property name, if bound, expands to a string literal within the behavior.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The type name is always a generic parameter.  This interferes with the ability to make a pattern that only matches a concrete type, but I think that’s okay.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Seems reasonable, since unconstrained behaviors are likely to be the 95% case. Being able to match concrete types is something we ought to be able solve uniformly with the same limitation on constrained extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The initializer name, if bound, expands to the original expression within the behavior.  Maybe it should be coerced to type T first?  Not sure.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, JoeP brought up a good question about how &#39;var&#39; type inference should work with initializer expressions. There are two possible models I can see:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - We infer the type of the initializer independent of any applied behaviors, and raise an error if the behavior can&#39;t be instantiated at the given type.<br>&gt;&gt;&gt;&gt; - We add generic constraints from the behavior declaration(s) to the contextual type of the initializer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In support of the latter approach, &#39;weak&#39; properties currently factor their Optional constraint into type inference (&#39;weak var foo = Foo()&#39; gives you a property of type Foo?), and &#39;weak&#39; has been raised as a candidate for eventual behavior-ization. The downside, of course, is that with arbitrary user-defined behaviors with arbitrary generic constraints, there&#39;s yet another source of potential surprise if the type context of behaviors changes the type-checking of an expression.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, especially because the initializer could be used in multiple places in the behavior.  Coercing the initializer seems a lot less surprising.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/85965eb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:19 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 19, 2016, at 6:38 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 5:47 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 4:28 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 19, 2016, at 3:10 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 19, 2016, at 2:46 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Syntax comments:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I still think these feel attribute-like to me, but if we’re not just going to use @lazy — and I agree that that does have some problems —I’m fine with [lazy].<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m OK with using attribute syntax alongside the declaration approach.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;var behavior&quot; is really weird to me, and the &lt;T&gt; doesn’t seem to fit and is pretty redundant in the common case.  How about this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   &quot;behavior&quot; var-or-let &quot;[&quot; identifier-list &quot;]&quot; (identifier | &quot;_&quot;) &quot;:&quot; identifier (&quot;=&quot; identifier)? (&quot;where&quot; generic-requirement-list)?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, for example,<br>&gt;&gt;&gt;&gt;&gt;&gt;   behavior var [lazy] _ : T where T : IntegerLiteralConvertible { … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is definitely taking the idea of “this is basically a macro” and running with it.  Think of the stuff between “behavior” and the optional “where” as being a pattern for the declaration.  So this pattern would match:<br>&gt;&gt;&gt;&gt;&gt;&gt;   var [lazy] x: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; but not:<br>&gt;&gt;&gt;&gt;&gt;&gt;   let [lazy] x: Int<br>&gt;&gt;&gt;&gt;&gt;&gt; or:<br>&gt;&gt;&gt;&gt;&gt;&gt;   var [lazy] x : Int = foo()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Good idea, I like this approach. However:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The behavior list has to match exactly (or maybe as sets?).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Are you saying that there would be no ad-hoc composition of behaviors? This seems to imply that you&#39;d need to implement every valid combination of behaviors by hand. That&#39;s a defensible position, given that it&#39;s easy to compose behaviors like &quot;synchronized&quot; in the wrong order, but significantly stifles behaviors like didSet/willSet that are more likely to be order-agnostic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My first instinct is to say that ad-hoc composition is too treacherous to include in the first model, yeah.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the idea of having a model that works for literally everything that’s not pure-computed or pure-stored, but it seems tolerable to continue to build in things like willSet / didSet if it significantly simplifies the problem.  willSet / didSet have some pretty custom behavior and dependencies on the container.  OTOH, maybe that kind of thing is a core requirement for some of the stuff we’re thinking of doing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think you can define a reasonable facsimile of willSet/didSet under my proposal, but I&#39;m willing to believe there are edge cases I&#39;m missing. What sort of custom behavior do you have in mind?<br>&gt;&gt; <br>&gt;&gt; Well, for one, we only load the old value if the didSet is actually declared.  There’s also the longstanding idea — apparently still not implemented — that we’d only do so if didSet actually used the old value.  The ideal result here really needs macro metaprogramming, I think, unless you’re going to get very sophisticated about accessor declarations.<br>&gt; <br>&gt; One of the nice things about last month&#39;s function-based proposal was that it allowed overloading a behavior, which could allow for the right variation of behavior to be chosen given different accessors. We could possibly make this work for behavior decls too, treating the set of accessor requirements as the &quot;signature&quot; of a behavior. Even without overloading, we could separate &#39;didSet&#39; and &#39;willSet&#39; into separate behaviors that can be optionally composed.<br>&gt; <br>&gt;&gt; One of my worries about this proposal in general is that you’ve listed out half-a-dozen different uses and every single one seems to require a new twist on the core semantics.<br>&gt; <br>&gt; Yeah, that worries me too. I think though that these twists are sugar over the basic functionality, though. Fundamentally we want a way to factor out one or both of two things:<br>&gt; <br>&gt; - The storage that gets instantiated for a property, and/or<br>&gt; - The get/materializeForSet/set implementations that get run for a property.<br>&gt; <br>&gt; Most of the accessor and initializer complexity is essentially sugar for parameterizing the behavior. Many in this thread have proposed allowing direct parameterization of the behavior like &#39;var [behavior(param)]&#39;; if the behavior could allocate and initialize static storage to capture those parameters, you could do everything you can with accessors or bound initializers (modulo &quot;only&quot; syntactic things like type-inferencing properties from initializer expressions).<br></p><p>That’s reasonable, but it’s definitely treading on future directions for hygienic macro definition.  I think the current syntax leaves plenty of room for that.<br></p><p>It’d be a pretty awkward way of doing willSet / didSet, though.<br></p><p>John.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The property name, if bound, expands to a string literal within the behavior.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The type name is always a generic parameter.  This interferes with the ability to make a pattern that only matches a concrete type, but I think that’s okay.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Seems reasonable, since unconstrained behaviors are likely to be the 95% case. Being able to match concrete types is something we ought to be able solve uniformly with the same limitation on constrained extensions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The initializer name, if bound, expands to the original expression within the behavior.  Maybe it should be coerced to type T first?  Not sure.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah, JoeP brought up a good question about how &#39;var&#39; type inference should work with initializer expressions. There are two possible models I can see:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - We infer the type of the initializer independent of any applied behaviors, and raise an error if the behavior can&#39;t be instantiated at the given type.<br>&gt;&gt;&gt;&gt;&gt; - We add generic constraints from the behavior declaration(s) to the contextual type of the initializer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In support of the latter approach, &#39;weak&#39; properties currently factor their Optional constraint into type inference (&#39;weak var foo = Foo()&#39; gives you a property of type Foo?), and &#39;weak&#39; has been raised as a candidate for eventual behavior-ization. The downside, of course, is that with arbitrary user-defined behaviors with arbitrary generic constraints, there&#39;s yet another source of potential surprise if the type context of behaviors changes the type-checking of an expression.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, especially because the initializer could be used in multiple places in the behavior.  Coercing the initializer seems a lot less surprising.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/21340fd3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>Le 19 janv. 2016 à 21:38, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; One of my worries about this proposal in general is that you’ve listed out half-a-dozen different uses and every single one seems to require a new twist on the core semantics.<br></p><p>That&#39;s my general feeling too about this proposal. I just didn&#39;t know how to express what you said above.<br></p><p>To me this proposal feels like it&#39;s is about trying to find a solution to multiple problems at once. A new problem arise that looks like it could be solved by a behaviour, so the behaviour feature expands to accommodate it. It looks like the wrong approach to me. <br></p><p>The correct approach in my opinion would be to try to make various parts of this proposal standalone, and allow them to combine when it makes sense. For instance, if you wanted to define a standalone feature for defining custom accessors that can be used everywhere, you wouldn&#39;t come with something that requires a behaviour annotation at the variable declaration. You&#39;ll come with something simpler that might looks like this:<br></p><p>custom_acccessor willSet&lt;T&gt;(newValue: T) { // define a custom accessor...<br>	set { // ... by redefining the setter...<br>		willSet(newValue) // ...inserting a call to the accessor here...<br>		currentValue = newValue // ...before calling the underlying setter<br>	}<br>}<br>custom_acccessor didSet&lt;T&gt;(oldValue: T) {<br>	set {<br>		let oldValue = currentValue<br>		currentValue = newValue<br>		didSet(oldValue)<br>	}<br>}<br>custom_acccessor willChange&lt;T&gt;(newValue: T) {<br>	willSet {<br>		if currentValue != newValue {<br>			willChange(newValue)<br>		}<br>	}<br>}<br></p><p>Then at the declaration point you just directly use the globally accessible accessor:<br></p><p>	var myvar: Int {<br>		willChange { print(&quot;will change to \(newValue)&quot;) }<br>	}<br></p><p>This fulfills at least one of the use cases. Can&#39;t we do the same treatment to each proposed use cases and see if there are other parts that can stand on their own?<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 6:12 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 19 janv. 2016 à 21:38, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; One of my worries about this proposal in general is that you’ve listed out half-a-dozen different uses and every single one seems to require a new twist on the core semantics.<br>&gt; <br>&gt; That&#39;s my general feeling too about this proposal. I just didn&#39;t know how to express what you said above.<br></p><p>I *did* somewhat strategically pick my examples to try to cover the breadth of different things I see someone wanting to do with this feature.<br></p><p>&gt; <br>&gt; To me this proposal feels like it&#39;s is about trying to find a solution to multiple problems at once. A new problem arise that looks like it could be solved by a behaviour, so the behaviour feature expands to accommodate it. It looks like the wrong approach to me. <br>&gt; <br>&gt; The correct approach in my opinion would be to try to make various parts of this proposal standalone, and allow them to combine when it makes sense. For instance, if you wanted to define a standalone feature for defining custom accessors that can be used everywhere, you wouldn&#39;t come with something that requires a behaviour annotation at the variable declaration. You&#39;ll come with something simpler that might looks like this:<br>&gt; <br>&gt; custom_acccessor willSet&lt;T&gt;(newValue: T) { // define a custom accessor...<br>&gt; 	set { // ... by redefining the setter...<br>&gt; 		willSet(newValue) // ...inserting a call to the accessor here...<br>&gt; 		currentValue = newValue // ...before calling the underlying setter<br>&gt; 	}<br>&gt; }<br>&gt; custom_acccessor didSet&lt;T&gt;(oldValue: T) {<br>&gt; 	set {<br>&gt; 		let oldValue = currentValue<br>&gt; 		currentValue = newValue<br>&gt; 		didSet(oldValue)<br>&gt; 	}<br>&gt; }<br>&gt; custom_acccessor willChange&lt;T&gt;(newValue: T) {<br>&gt; 	willSet {<br>&gt; 		if currentValue != newValue {<br>&gt; 			willChange(newValue)<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Then at the declaration point you just directly use the globally accessible accessor:<br>&gt; <br>&gt; 	var myvar: Int {<br>&gt; 		willChange { print(&quot;will change to \(newValue)&quot;) }<br>&gt; 	}<br>&gt; <br>&gt; This fulfills at least one of the use cases. Can&#39;t we do the same treatment to each proposed use cases and see if there are other parts that can stand on their own?<br></p><p>I considered this approach. It works for behaviors that don&#39;t need to control a property&#39;s storage and only change the property&#39;s access behavior. To be fair, that covers a lot of ground, including things like observing, NSCopying, resetting, and locking synchronization. We would still need a feature, which could certainly be a different one, to generalize annotations that control the storage policy for decorated properties, which could cover things like laziness, indirect storage, unowned/weak-ness, dirty-tracking, C-style atomics, and pointer addressability—basically, anything where a plain old stored property of the API type isn&#39;t sufficient. (You could even throw get/set in this bucket, if you wanted to be super reductionist.) Finally, there&#39;s the feature to add operations on a *property* independent of its *type*, which interacts usefully with both other features—you need a way to reset a resettable or lazy property; maybe you want to bypass a synchronized property&#39;s lock in one place, etc. We&#39;d like to improve on the &quot;classic&quot; answer of exposing an underlying ivar or property in these cases. If you want to break it down in micro-features, I guess there are three here:<br></p><p>1. Factoring out storage patterns,<br>2. Factoring out accessor patterns, and<br>3. Adding per-property operations.<br></p><p>(1) tends to be tightly coupled with (2)—if you&#39;re controlling storage, you almost certainly want to control the accessors over that storage. And (3) is useful with both (1) and (2). If there are separate features to be factored out here, I think they&#39;re very entangled features.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 21, 2016 at 01:00:00pm</p></header><div class="content"><p>Le 20 janv. 2016 à 21:44, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 6:12 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Le 19 janv. 2016 à 21:38, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; One of my worries about this proposal in general is that you’ve listed out half-a-dozen different uses and every single one seems to require a new twist on the core semantics.<br>&gt;&gt; <br>&gt;&gt; That&#39;s my general feeling too about this proposal. I just didn&#39;t know how to express what you said above.<br>&gt; <br>&gt; I *did* somewhat strategically pick my examples to try to cover the breadth of different things I see someone wanting to do with this feature.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; To me this proposal feels like it&#39;s is about trying to find a solution to multiple problems at once. A new problem arise that looks like it could be solved by a behavior, so the behavior feature expands to accommodate it. It looks like the wrong approach to me. <br>&gt;&gt; <br>&gt;&gt; The correct approach in my opinion would be to try to make various parts of this proposal standalone, and allow them to combine when it makes sense. For instance, if you wanted to define a standalone feature for defining custom accessors that can be used everywhere, you wouldn&#39;t come with something that requires a behavior annotation at the variable declaration. You&#39;ll come with something simpler that might looks like this:<br>&gt;&gt; <br>&gt;&gt; custom_acccessor willSet&lt;T&gt;(newValue: T) { // define a custom accessor...<br>&gt;&gt; 	set { // ... by redefining the setter...<br>&gt;&gt; 		willSet(newValue) // ...inserting a call to the accessor here...<br>&gt;&gt; 		currentValue = newValue // ...before calling the underlying setter<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; custom_acccessor didSet&lt;T&gt;(oldValue: T) {<br>&gt;&gt; 	set {<br>&gt;&gt; 		let oldValue = currentValue<br>&gt;&gt; 		currentValue = newValue<br>&gt;&gt; 		didSet(oldValue)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; custom_acccessor willChange&lt;T&gt;(newValue: T) {<br>&gt;&gt; 	willSet {<br>&gt;&gt; 		if currentValue != newValue {<br>&gt;&gt; 			willChange(newValue)<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Then at the declaration point you just directly use the globally accessible accessor:<br>&gt;&gt; <br>&gt;&gt; 	var myvar: Int {<br>&gt;&gt; 		willChange { print(&quot;will change to \(newValue)&quot;) }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; This fulfills at least one of the use cases. Can&#39;t we do the same treatment to each proposed use cases and see if there are other parts that can stand on their own?<br>&gt; <br>&gt; I considered this approach. It works for behaviors that don&#39;t need to control a property&#39;s storage and only change the property&#39;s access behavior. To be fair, that covers a lot of ground, including things like observing, NSCopying, resetting, and locking synchronization. We would still need a feature, which could certainly be a different one, to generalize annotations that control the storage policy for decorated properties, which could cover things like laziness, indirect storage, unowned/weak-ness, dirty-tracking, C-style atomics, and pointer addressability—basically, anything where a plain old stored property of the API type isn&#39;t sufficient. (You could even throw get/set in this bucket, if you wanted to be super reductionist.) Finally, there&#39;s the feature to add operations on a *property* independent of its *type*, which interacts usefully with both other features—you need a way to reset a resettable or lazy property; maybe you want to bypass a synchronized property&#39;s lock in one place, etc. We&#39;d like to improve on the &quot;classic&quot; answer of exposing an underlying ivar or property in these cases.<br>&gt; <br>&gt; If you want to break it down in micro-features, I guess there are three here:<br>&gt; <br>&gt; 1. Factoring out storage patterns,<br>&gt; 2. Factoring out accessor patterns, and<br>&gt; 3. Adding per-property operations.<br>&gt; <br>&gt; (1) tends to be tightly coupled with (2)—if you&#39;re controlling storage, you almost certainly want to control the accessors over that storage. And (3) is useful with both (1) and (2). If there are separate features to be factored out here, I think they&#39;re very entangled features.<br></p><p>No single language feature necessarily has to &quot;control&quot; the accessor. The accessor is really of a pile of &quot;custom accessor code&quot; wrapping one another, some in the variable declaration, some in the variable&#39;s behaviours, and so why not some others in a global accessor declaration? They just pile up on top of each other.<br></p><p>Last post was about (2), so let&#39;s try to attack (1) using this approach. Basically, this is going to be the same thing as your behaviour proposal, minus `var` inside of it, minus custom accessors defined inside of it, minus functions inside of it (we&#39;ll revisit that at the end), and where the base property is implicit (`currentValue`) and the initializer is implicit too (`initValue`).<br></p><p>I&#39;ll start with an &quot;identity&quot; behavior, a behavior that wraps a base property while actually doing nothing:<br></p><p>// identity for type T creates storage of type T<br>storage_behavior identity&lt;T&gt;: T {<br>	// regular initializer, works with eager or deferred initialization<br>	init {<br>		// initValue is implicitly defined in this scope<br>		currentValue = initValue // initializing the storage<br>	}<br>	get {<br>		return currentValue<br>	}<br>	set {<br>		currentValue = newValue<br>	}<br>}<br></p><p>Sometime you need to force the initializer to be eager or deferred. So we can do that with a keyword, in which case for `eager` the `initValue` becomes available anywhere inside the behavior, and for `deferred` it becomes available everywhere outside of `init`:<br></p><p>// identity for type T creates storage of type T<br>eager storage_behavior eagerIdentity&lt;T&gt;: T {<br>	// initValue is implicitly defined in this scope<br></p><p>	// eager initializer (takes not argument)<br>	init {<br>		currentValue = initValue // initializing the storage<br>	}<br>	get {<br>		return currentValue<br>	}<br>	set {<br>		currentValue = newValue<br>	}<br>}<br></p><p>Note at this point how this is basically the same syntax as with the `custom_accessor` examples from my last post, minus there is no accessor to call in `get` or `set`, plus you have the ability to affect the storage. The main difference for the user is that, since it&#39;s a behavior, you opt in to it by annotating the variable. Whereas in the case of `custom_accessor` you opt it by writing the custom accessor body inside of the variable&#39;s accessors.<br></p><p>Ok, now let&#39;s write lazy:<br></p><p>// lazy for type T creates storage of type T?<br>deferred storage_behavior lazy&lt;T&gt;: T? {<br>	init { <br>		// defered initValue not available in this scope<br>		currentValue = nil // initializing the storage<br>	}<br>	get {<br>		if currentValue == nil {<br>			currentValue = deferredInitValue<br>		}<br>		return currentValue! // converting from T? to T<br>	}<br>	set {<br>		currentValue = newValue // converting from T to T?<br>	}<br>}<br></p><p>Now let&#39;s make it atomic:<br></p><p>storage_behavior atomic&lt;T&gt;: Atomic&lt;T&gt; {<br>	init {<br>		currentValue = Atomic(initValue)<br>	}<br>	get {<br>		return currentValue.payload<br>	}<br>	set {<br>		currentValue.payload = newValue<br>	}<br>}<br></p><p>Note how I can avoid adding variables inside the behavior by just changing the underlying type to be some kind of wrapper of the original type. That makes the feature simpler.<br></p><p>We can also write synchronized (for variables in a context where self is Synchronizable):<br></p><p>storage_behavior synchronzied&lt;T where Self == Synchronizable&gt;: T {<br>	init {<br>		currentValue = initValue<br>	}<br>	get {<br>		return self.withLock {<br>			return currentValue<br>		}<br>	}<br>	set {<br>		self.withLock {<br>			currentValue = newValue<br>		}<br>	}<br>}<br></p><p>Here is a minimalistic logging behavior:<br></p><p>storage_behavior logging&lt;T&gt;: T {<br>	// implied &quot;identity&quot; version of init, get, and set.<br>	willChange {<br>		print(&quot;\(currentValue) will change for \(newValue)&quot;)<br>	}<br>}<br></p><p>This last example is interesting: it shows that you can use a globally-defined accessor inside of the behavior; you don&#39;t have to define a `set` or a `get` to make it useful. This logging behavior is basically just a shortcut for defining a variable like this:<br></p><p>	var myvar: Int {<br>		willChange {<br>			print(&quot;\(myvar) will change for \(newValue)&quot;)<br>		}<br>	}<br></p><p>	@logging var myvar2: Int // way less boilerplate!<br></p><p>So in the end, a storage behavior model defined like this brings to the table the `init` and the modified storage type. Otherwise it&#39;s just a nice and convenient way to avoid repeating boilerplate you can already write inside of a variable declaration. Which is great, because with less special rules the whole behaviour feature looks much more approachable now.<br></p><p>For micro feature (3) I&#39;m not sure what to suggest right now. I&#39;m not 100% convinced exposing functions is necessary, and the visibility rules in your proposal seem quite complex. And while I can see its usefulness, I don&#39;t see why this feature should be limited to property behaviours. I think it would make a lot of sense to have that available directly in the variable declaration too, somewhat like this:<br></p><p>	var myvar: Int = 0 {<br>		mutating func reset() { myvar = 0 }<br>	}<br></p><p>	myvar#.reset() // some syntax to call the function<br></p><p>And if this was allowed, it&#39;d only be natural that you could write the same thing inside of a behavior because behaviours are all about reducing the boilerplate of writing those custom accessors:<br></p><p>	eager storage_behavior resettable&lt;T&gt;: T {<br>		mutating func reset() { myvar = initValue }<br>	}<br></p><p>	@resettable myvar: Int = 0<br>	myvar#.reset()<br></p><p>If you want, this could be extended to allow computed and stored properties inside of the variable declaration, which would naturally extend to the behaviour too.<br></p><p>And that could be the final part of the puzzle. Three simpler features that can be useful on their own but which you can also combine to fulfill all the use cases of your proposal.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 21, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 10:16 AM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 20 janv. 2016 à 21:44, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 6:12 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 19 janv. 2016 à 21:38, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of my worries about this proposal in general is that you’ve listed out half-a-dozen different uses and every single one seems to require a new twist on the core semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s my general feeling too about this proposal. I just didn&#39;t know how to express what you said above.<br>&gt;&gt; <br>&gt;&gt; I *did* somewhat strategically pick my examples to try to cover the breadth of different things I see someone wanting to do with this feature.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me this proposal feels like it&#39;s is about trying to find a solution to multiple problems at once. A new problem arise that looks like it could be solved by a behavior, so the behavior feature expands to accommodate it. It looks like the wrong approach to me. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The correct approach in my opinion would be to try to make various parts of this proposal standalone, and allow them to combine when it makes sense. For instance, if you wanted to define a standalone feature for defining custom accessors that can be used everywhere, you wouldn&#39;t come with something that requires a behavior annotation at the variable declaration. You&#39;ll come with something simpler that might looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; custom_acccessor willSet&lt;T&gt;(newValue: T) { // define a custom accessor...<br>&gt;&gt;&gt; 	set { // ... by redefining the setter...<br>&gt;&gt;&gt; 		willSet(newValue) // ...inserting a call to the accessor here...<br>&gt;&gt;&gt; 		currentValue = newValue // ...before calling the underlying setter<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; custom_acccessor didSet&lt;T&gt;(oldValue: T) {<br>&gt;&gt;&gt; 	set {<br>&gt;&gt;&gt; 		let oldValue = currentValue<br>&gt;&gt;&gt; 		currentValue = newValue<br>&gt;&gt;&gt; 		didSet(oldValue)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; custom_acccessor willChange&lt;T&gt;(newValue: T) {<br>&gt;&gt;&gt; 	willSet {<br>&gt;&gt;&gt; 		if currentValue != newValue {<br>&gt;&gt;&gt; 			willChange(newValue)<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then at the declaration point you just directly use the globally accessible accessor:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	var myvar: Int {<br>&gt;&gt;&gt; 		willChange { print(&quot;will change to \(newValue)&quot;) }<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This fulfills at least one of the use cases. Can&#39;t we do the same treatment to each proposed use cases and see if there are other parts that can stand on their own?<br>&gt;&gt; <br>&gt;&gt; I considered this approach. It works for behaviors that don&#39;t need to control a property&#39;s storage and only change the property&#39;s access behavior. To be fair, that covers a lot of ground, including things like observing, NSCopying, resetting, and locking synchronization. We would still need a feature, which could certainly be a different one, to generalize annotations that control the storage policy for decorated properties, which could cover things like laziness, indirect storage, unowned/weak-ness, dirty-tracking, C-style atomics, and pointer addressability—basically, anything where a plain old stored property of the API type isn&#39;t sufficient. (You could even throw get/set in this bucket, if you wanted to be super reductionist.) Finally, there&#39;s the feature to add operations on a *property* independent of its *type*, which interacts usefully with both other features—you need a way to reset a resettable or lazy property; maybe you want to bypass a synchronized property&#39;s lock in one place, etc. We&#39;d like to improve on the &quot;classic&quot; answer of exposing an underlying ivar or property in these cases.<br>&gt;&gt; <br>&gt;&gt; If you want to break it down in micro-features, I guess there are three here:<br>&gt;&gt; <br>&gt;&gt; 1. Factoring out storage patterns,<br>&gt;&gt; 2. Factoring out accessor patterns, and<br>&gt;&gt; 3. Adding per-property operations.<br>&gt;&gt; <br>&gt;&gt; (1) tends to be tightly coupled with (2)—if you&#39;re controlling storage, you almost certainly want to control the accessors over that storage. And (3) is useful with both (1) and (2). If there are separate features to be factored out here, I think they&#39;re very entangled features.<br>&gt; <br>&gt; No single language feature necessarily has to &quot;control&quot; the accessor. The accessor is really of a pile of &quot;custom accessor code&quot; wrapping one another, some in the variable declaration, some in the variable&#39;s behaviours, and so why not some others in a global accessor declaration? They just pile up on top of each other.<br>&gt; <br>&gt; Last post was about (2), so let&#39;s try to attack (1) using this approach. Basically, this is going to be the same thing as your behaviour proposal, minus `var` inside of it, minus custom accessors defined inside of it, minus functions inside of it (we&#39;ll revisit that at the end), and where the base property is implicit (`currentValue`) and the initializer is implicit too (`initValue`).<br>&gt; <br>&gt; I&#39;ll start with an &quot;identity&quot; behavior, a behavior that wraps a base property while actually doing nothing:<br>&gt; <br>&gt; // identity for type T creates storage of type T<br>&gt; storage_behavior identity&lt;T&gt;: T {<br>&gt; 	// regular initializer, works with eager or deferred initialization<br>&gt; 	init {<br>&gt; 		// initValue is implicitly defined in this scope<br>&gt; 		currentValue = initValue // initializing the storage<br>&gt; 	}<br>&gt; 	get {<br>&gt; 		return currentValue<br>&gt; 	}<br>&gt; 	set {<br>&gt; 		currentValue = newValue<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Sometime you need to force the initializer to be eager or deferred. So we can do that with a keyword, in which case for `eager` the `initValue` becomes available anywhere inside the behavior, and for `deferred` it becomes available everywhere outside of `init`:<br>&gt; <br>&gt; // identity for type T creates storage of type T<br>&gt; eager storage_behavior eagerIdentity&lt;T&gt;: T {<br>&gt; 	// initValue is implicitly defined in this scope<br>&gt; <br>&gt; 	// eager initializer (takes not argument)<br>&gt; 	init {<br>&gt; 		currentValue = initValue // initializing the storage<br>&gt; 	}<br>&gt; 	get {<br>&gt; 		return currentValue<br>&gt; 	}<br>&gt; 	set {<br>&gt; 		currentValue = newValue<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Note at this point how this is basically the same syntax as with the `custom_accessor` examples from my last post, minus there is no accessor to call in `get` or `set`, plus you have the ability to affect the storage. The main difference for the user is that, since it&#39;s a behavior, you opt in to it by annotating the variable. Whereas in the case of `custom_accessor` you opt it by writing the custom accessor body inside of the variable&#39;s accessors.<br>&gt; <br>&gt; Ok, now let&#39;s write lazy:<br>&gt; <br>&gt; // lazy for type T creates storage of type T?<br>&gt; deferred storage_behavior lazy&lt;T&gt;: T? {<br>&gt; 	init { <br>&gt; 		// defered initValue not available in this scope<br>&gt; 		currentValue = nil // initializing the storage<br>&gt; 	}<br>&gt; 	get {<br>&gt; 		if currentValue == nil {<br>&gt; 			currentValue = deferredInitValue<br>&gt; 		}<br>&gt; 		return currentValue! // converting from T? to T<br>&gt; 	}<br>&gt; 	set {<br>&gt; 		currentValue = newValue // converting from T to T?<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Now let&#39;s make it atomic:<br>&gt; <br>&gt; storage_behavior atomic&lt;T&gt;: Atomic&lt;T&gt; {<br>&gt; 	init {<br>&gt; 		currentValue = Atomic(initValue)<br>&gt; 	}<br>&gt; 	get {<br>&gt; 		return currentValue.payload<br>&gt; 	}<br>&gt; 	set {<br>&gt; 		currentValue.payload = newValue<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Note how I can avoid adding variables inside the behavior by just changing the underlying type to be some kind of wrapper of the original type. That makes the feature simpler.<br>&gt; <br>&gt; We can also write synchronized (for variables in a context where self is Synchronizable):<br>&gt; <br>&gt; storage_behavior synchronzied&lt;T where Self == Synchronizable&gt;: T {<br>&gt; 	init {<br>&gt; 		currentValue = initValue<br>&gt; 	}<br>&gt; 	get {<br>&gt; 		return self.withLock {<br>&gt; 			return currentValue<br>&gt; 		}<br>&gt; 	}<br>&gt; 	set {<br>&gt; 		self.withLock {<br>&gt; 			currentValue = newValue<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Here is a minimalistic logging behavior:<br>&gt; <br>&gt; storage_behavior logging&lt;T&gt;: T {<br>&gt; 	// implied &quot;identity&quot; version of init, get, and set.<br>&gt; 	willChange {<br>&gt; 		print(&quot;\(currentValue) will change for \(newValue)&quot;)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; This last example is interesting: it shows that you can use a globally-defined accessor inside of the behavior; you don&#39;t have to define a `set` or a `get` to make it useful. This logging behavior is basically just a shortcut for defining a variable like this:<br>&gt; <br>&gt; 	var myvar: Int {<br>&gt; 		willChange {<br>&gt; 			print(&quot;\(myvar) will change for \(newValue)&quot;)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; 	@logging var myvar2: Int // way less boilerplate!<br>&gt; <br>&gt; So in the end, a storage behavior model defined like this brings to the table the `init` and the modified storage type. Otherwise it&#39;s just a nice and convenient way to avoid repeating boilerplate you can already write inside of a variable declaration. Which is great, because with less special rules the whole behaviour feature looks much more approachable now.<br></p><p>You&#39;re glossing over some of the subtleties of initialization. Recall that a &quot;plain old&quot; stored property can be initialized out-of-line:<br></p><p>func foo() {<br>  var x: Int<br>  ...<br>  x = 1<br>}<br></p><p>struct Bar {<br>  var y: Int<br></p><p>  init(y: Int) {<br>    self.y = y<br>  }<br>}<br></p><p>which creates complications for your &#39;init { }&#39; model. If initializers chain the way you describe, then either storage_behaviors can never be initialized out-of-line, which would be a regression for didSet/willSet applications, or we need to gain the ability for definite initialization to turn &#39;x = 1&#39; into an &#39;init&#39; call. However, since storage_behavior can refer to its initializer anywhere, not only during initialization, the initialization assignment potentially has to *capture* the RHS value to be evaluatable later, which would be surprising. If a behavior wants to be able to override a superclass property, as didSet/willSet can do today, then initialization is out of the behavior&#39;s control. These are the factors that influenced the &quot;base property&quot; design in my proposal—if you want behaviors that compose, they really *can&#39;t* meddle in the underlying base property&#39;s initialization. These use cases can be addressed instead by your accessor modifier mechanism; however, if you try to break apart storage behaviors and custom accessors, then both features suffer—storage behaviors can&#39;t require accessors to parameterize behavior, and custom accessors can&#39;t introduce new storage if needed to apply their implementation over the underlying property.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/9edbdc35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 21, 2016 at 11:00:00pm</p></header><div class="content"><p>Le 21 janv. 2016 à 21:36, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt; You&#39;re glossing over some of the subtleties of initialization. Recall that a &quot;plain old&quot; stored property can be initialized out-of-line:<br>&gt; <br>&gt; func foo() {<br>&gt;   var x: Int<br>&gt;   ...<br>&gt;   x = 1<br>&gt; }<br>&gt; <br>&gt; struct Bar {<br>&gt;   var y: Int<br>&gt; <br>&gt;   init(y: Int) {<br>&gt;     self.y = y<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; which creates complications for your &#39;init { }&#39; model. If initializers chain the way you describe, then either storage_behaviors can never be initialized out-of-line, which would be a regression for didSet/willSet applications, or we need to gain the ability for definite initialization to turn &#39;x = 1&#39; into an &#39;init&#39; call. However, since storage_behavior can refer to its initializer anywhere, not only during initialization, the initialization assignment potentially has to *capture* the RHS value to be evaluatable later, which would be surprising.<br></p><p>The idea was that inside a `storage_behavior` the `initValue` is only available inside of `init`. There are two exceptions: if the behavior is `eager` the `initValue` is available everywhere. Or if the behavior is `deferred` then the `initValue` is available everywhere *except* in `init`.<br></p><p>It seems I mistook what `eager` was for in your proposal. My interpretation of `eager` was that the value had to be specified inline with the variable declaration and could not be specified later in a constructor. Thus, its the same thing as `deferred` except that evaluating the initializer does not depend on `self` so you can use `initValue` truly everywhere including inside of `init`. Thus it appears my `eager` has no equivalent in your proposal while your `eager` is the same as not putting any modifier in front of `storage_behavior`.<br></p><p>I&#39;m unsure now if there is any reason for my version of `eager` to exist. But it turns out you don&#39;t need my `eager` to implement resettable, all you need is to allow some storage for the initial value:<br></p><p>	storage_behavior resettable&lt;T&gt;: (initial: T, current: T) {<br>		init {<br>			currentValue = (initial: initValue, current: initValue)<br>		}<br>		func reset() {<br>			currentValue.current = currentValue.initial<br>		}<br>	}<br></p><p>&gt; If a behavior wants to be able to override a superclass property, as didSet/willSet can do today, then initialization is out of the behavior&#39;s control. These are the factors that influenced the &quot;base property&quot; design in my proposal—if you want behaviors that compose, they really *can&#39;t* meddle in the underlying base property&#39;s initialization. These use cases can be addressed instead by your accessor modifier mechanism; however, if you try to break apart storage behaviors and custom accessors, then both features suffer—storage behaviors can&#39;t require accessors to parameterize behavior, and custom accessors can&#39;t introduce new storage if needed to apply their implementation over the underlying property.<br></p><p>That&#39;s true. In other words, you can&#39;t override a superclass property with a behavior that touches `initValue` or defines the base storage type. As you say, we probably need another modifier keyword alongside `eager` and `deferred` to express that restriction so we can apply a behavior like `logging` when overriding.<br></p><p>And finally, to allow storage in overrides (both behaviors and accessors), all you need is to allow `var` and `let` inside of variable declarations, just like I suggested for functions:<br></p><p>	var myvar: Int {<br>		var observers: [Observer] = []<br>		func addObserver(o: Observer) { observers.append(o) }<br>	}<br></p><p>then it automatically becomes possible to put all that boilerplate code inside of a behavior:<br></p><p>	storage_behavior observable&lt;T&gt;: T {<br>		var observers: [Observer] = []<br>		func addObserver(o: Observer) { observers.append(o) }<br>	}<br></p><p>and it could be allowed in custom accessors too, although I can&#39;t come with a use case for this.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 8:05 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 21 janv. 2016 à 21:36, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; You&#39;re glossing over some of the subtleties of initialization. Recall that a &quot;plain old&quot; stored property can be initialized out-of-line:<br>&gt;&gt; <br>&gt;&gt; func foo() {<br>&gt;&gt;  var x: Int<br>&gt;&gt;  ...<br>&gt;&gt;  x = 1<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Bar {<br>&gt;&gt;  var y: Int<br>&gt;&gt; <br>&gt;&gt;  init(y: Int) {<br>&gt;&gt;    self.y = y<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; which creates complications for your &#39;init { }&#39; model. If initializers chain the way you describe, then either storage_behaviors can never be initialized out-of-line, which would be a regression for didSet/willSet applications, or we need to gain the ability for definite initialization to turn &#39;x = 1&#39; into an &#39;init&#39; call. However, since storage_behavior can refer to its initializer anywhere, not only during initialization, the initialization assignment potentially has to *capture* the RHS value to be evaluatable later, which would be surprising.<br>&gt; <br>&gt; The idea was that inside a `storage_behavior` the `initValue` is only available inside of `init`. There are two exceptions: if the behavior is `eager` the `initValue` is available everywhere. Or if the behavior is `deferred` then the `initValue` is available everywhere *except* in `init`.<br>&gt; <br>&gt; It seems I mistook what `eager` was for in your proposal. My interpretation of `eager` was that the value had to be specified inline with the variable declaration and could not be specified later in a constructor. Thus, its the same thing as `deferred` except that evaluating the initializer does not depend on `self` so you can use `initValue` truly everywhere including inside of `init`. Thus it appears my `eager` has no equivalent in your proposal while your `eager` is the same as not putting any modifier in front of `storage_behavior`.<br>&gt; <br>&gt; I&#39;m unsure now if there is any reason for my version of `eager` to exist. But it turns out you don&#39;t need my `eager` to implement resettable, all you need is to allow some storage for the initial value:<br>&gt; <br>&gt; 	storage_behavior resettable&lt;T&gt;: (initial: T, current: T) {<br>&gt; 		init {<br>&gt; 			currentValue = (initial: initValue, current: initValue)<br>&gt; 		}<br>&gt; 		func reset() {<br>&gt; 			currentValue.current = currentValue.initial<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt;&gt; If a behavior wants to be able to override a superclass property, as didSet/willSet can do today, then initialization is out of the behavior&#39;s control. These are the factors that influenced the &quot;base property&quot; design in my proposal—if you want behaviors that compose, they really *can&#39;t* meddle in the underlying base property&#39;s initialization. These use cases can be addressed instead by your accessor modifier mechanism; however, if you try to break apart storage behaviors and custom accessors, then both features suffer—storage behaviors can&#39;t require accessors to parameterize behavior, and custom accessors can&#39;t introduce new storage if needed to apply their implementation over the underlying property.<br>&gt; <br>&gt; That&#39;s true. In other words, you can&#39;t override a superclass property with a behavior that touches `initValue` or defines the base storage type. As you say, we probably need another modifier keyword alongside `eager` and `deferred` to express that restriction so we can apply a behavior like `logging` when overriding.<br>&gt; <br>&gt; And finally, to allow storage in overrides (both behaviors and accessors), all you need is to allow `var` and `let` inside of variable declarations, just like I suggested for functions:<br>&gt; <br>&gt; 	var myvar: Int {<br>&gt; 		var observers: [Observer] = []<br>&gt; 		func addObserver(o: Observer) { observers.append(o) }<br>&gt; 	}<br>&gt; <br>&gt; then it automatically becomes possible to put all that boilerplate code inside of a behavior:<br>&gt; <br>&gt; 	storage_behavior observable&lt;T&gt;: T {<br>&gt; 		var observers: [Observer] = []<br>&gt; 		func addObserver(o: Observer) { observers.append(o) }<br>&gt; 	}<br>&gt; <br>&gt; and it could be allowed in custom accessors too, although I can&#39;t come with a use case for this.<br></p><p>I feel like, once you start stretching your design this way, we don&#39;t end up with something that&#39;s all that much simpler than what I&#39;ve proposed. To help make review more digestible, I am planning to slim down the proposal a bit—I think we can subset out eager-vs-deferred initializers, composability via base properties, and extensions as future extensions to consider separately. That means the feature won&#39;t immediately be able to replace some of Swift 2&#39;s builtin features in all their subtleties, but it still gives us something useful that can be gradually generalized.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>Will property behaviors work on computed properties? Because for now, we<br>can change a storage to a computed property and a computed for a storage<br>property without breaking anything.<br></p><p>Em qui, 21 de jan de 2016 às 00:44, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt;<br>&gt; &gt; On Jan 20, 2016, at 6:12 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Le 19 janv. 2016 à 21:38, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt;&gt; One of my worries about this proposal in general is that you’ve listed<br>&gt; out half-a-dozen different uses and every single one seems to require a new<br>&gt; twist on the core semantics.<br>&gt; &gt;<br>&gt; &gt; That&#39;s my general feeling too about this proposal. I just didn&#39;t know<br>&gt; how to express what you said above.<br>&gt;<br>&gt; I *did* somewhat strategically pick my examples to try to cover the<br>&gt; breadth of different things I see someone wanting to do with this feature.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; To me this proposal feels like it&#39;s is about trying to find a solution<br>&gt; to multiple problems at once. A new problem arise that looks like it could<br>&gt; be solved by a behaviour, so the behaviour feature expands to accommodate<br>&gt; it. It looks like the wrong approach to me.<br>&gt; &gt;<br>&gt; &gt; The correct approach in my opinion would be to try to make various parts<br>&gt; of this proposal standalone, and allow them to combine when it makes sense.<br>&gt; For instance, if you wanted to define a standalone feature for defining<br>&gt; custom accessors that can be used everywhere, you wouldn&#39;t come with<br>&gt; something that requires a behaviour annotation at the variable declaration.<br>&gt; You&#39;ll come with something simpler that might looks like this:<br>&gt; &gt;<br>&gt; &gt; custom_acccessor willSet&lt;T&gt;(newValue: T) { // define a custom accessor...<br>&gt; &gt;       set { // ... by redefining the setter...<br>&gt; &gt;               willSet(newValue) // ...inserting a call to the accessor<br>&gt; here...<br>&gt; &gt;               currentValue = newValue // ...before calling the<br>&gt; underlying setter<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt; custom_acccessor didSet&lt;T&gt;(oldValue: T) {<br>&gt; &gt;       set {<br>&gt; &gt;               let oldValue = currentValue<br>&gt; &gt;               currentValue = newValue<br>&gt; &gt;               didSet(oldValue)<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt; custom_acccessor willChange&lt;T&gt;(newValue: T) {<br>&gt; &gt;       willSet {<br>&gt; &gt;               if currentValue != newValue {<br>&gt; &gt;                       willChange(newValue)<br>&gt; &gt;               }<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Then at the declaration point you just directly use the globally<br>&gt; accessible accessor:<br>&gt; &gt;<br>&gt; &gt;       var myvar: Int {<br>&gt; &gt;               willChange { print(&quot;will change to \(newValue)&quot;) }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; This fulfills at least one of the use cases. Can&#39;t we do the same<br>&gt; treatment to each proposed use cases and see if there are other parts that<br>&gt; can stand on their own?<br>&gt;<br>&gt; I considered this approach. It works for behaviors that don&#39;t need to<br>&gt; control a property&#39;s storage and only change the property&#39;s access<br>&gt; behavior. To be fair, that covers a lot of ground, including things like<br>&gt; observing, NSCopying, resetting, and locking synchronization. We would<br>&gt; still need a feature, which could certainly be a different one, to<br>&gt; generalize annotations that control the storage policy for decorated<br>&gt; properties, which could cover things like laziness, indirect storage,<br>&gt; unowned/weak-ness, dirty-tracking, C-style atomics, and pointer<br>&gt; addressability—basically, anything where a plain old stored property of the<br>&gt; API type isn&#39;t sufficient. (You could even throw get/set in this bucket, if<br>&gt; you wanted to be super reductionist.) Finally, there&#39;s the feature to add<br>&gt; operations on a *property* independent of its *type*, which interacts<br>&gt; usefully with both other features—you need a way to reset a resettable or<br>&gt; lazy property; maybe you want to bypass a synchronized property&#39;s lock in<br>&gt; one place, etc. We&#39;d like to improve on the &quot;classic&quot; answer of exposing an<br>&gt; underlying ivar or property in these cases. If you want to break it down in<br>&gt; micro-features, I guess there are three here:<br>&gt;<br>&gt; 1. Factoring out storage patterns,<br>&gt; 2. Factoring out accessor patterns, and<br>&gt; 3. Adding per-property operations.<br>&gt;<br>&gt; (1) tends to be tightly coupled with (2)—if you&#39;re controlling storage,<br>&gt; you almost certainly want to control the accessors over that storage. And<br>&gt; (3) is useful with both (1) and (2). If there are separate features to be<br>&gt; factored out here, I think they&#39;re very entangled features.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/68a39353/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 21, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 1:23 PM, Wallacy &lt;wallacyf at gmail.com&gt; wrote:<br>&gt; <br>&gt; Will property behaviors work on computed properties? Because for now, we can change a storage to a computed property and a computed for a storage property without breaking anything.<br></p><p>I&#39;m not sure exactly what you mean, but property behaviors are (by default) implementation details, so you can change the implementation of a property to computed to stored to behaviors without breaking API. If you publish a behavior as public, you&#39;d be promising to use that behavior as part of the implementation forever.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Em qui, 21 de jan de 2016 às 00:44, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escreveu:<br>&gt; <br>&gt; &gt; On Jan 20, 2016, at 6:12 PM, Michel Fortin &lt;michel.fortin at michelf.ca &lt;mailto:michel.fortin at michelf.ca&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Le 19 janv. 2016 à 21:38, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt;&gt; One of my worries about this proposal in general is that you’ve listed out half-a-dozen different uses and every single one seems to require a new twist on the core semantics.<br>&gt; &gt;<br>&gt; &gt; That&#39;s my general feeling too about this proposal. I just didn&#39;t know how to express what you said above.<br>&gt; <br>&gt; I *did* somewhat strategically pick my examples to try to cover the breadth of different things I see someone wanting to do with this feature.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; To me this proposal feels like it&#39;s is about trying to find a solution to multiple problems at once. A new problem arise that looks like it could be solved by a behaviour, so the behaviour feature expands to accommodate it. It looks like the wrong approach to me.<br>&gt; &gt;<br>&gt; &gt; The correct approach in my opinion would be to try to make various parts of this proposal standalone, and allow them to combine when it makes sense. For instance, if you wanted to define a standalone feature for defining custom accessors that can be used everywhere, you wouldn&#39;t come with something that requires a behaviour annotation at the variable declaration. You&#39;ll come with something simpler that might looks like this:<br>&gt; &gt;<br>&gt; &gt; custom_acccessor willSet&lt;T&gt;(newValue: T) { // define a custom accessor...<br>&gt; &gt;       set { // ... by redefining the setter...<br>&gt; &gt;               willSet(newValue) // ...inserting a call to the accessor here...<br>&gt; &gt;               currentValue = newValue // ...before calling the underlying setter<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt; custom_acccessor didSet&lt;T&gt;(oldValue: T) {<br>&gt; &gt;       set {<br>&gt; &gt;               let oldValue = currentValue<br>&gt; &gt;               currentValue = newValue<br>&gt; &gt;               didSet(oldValue)<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt; custom_acccessor willChange&lt;T&gt;(newValue: T) {<br>&gt; &gt;       willSet {<br>&gt; &gt;               if currentValue != newValue {<br>&gt; &gt;                       willChange(newValue)<br>&gt; &gt;               }<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Then at the declaration point you just directly use the globally accessible accessor:<br>&gt; &gt;<br>&gt; &gt;       var myvar: Int {<br>&gt; &gt;               willChange { print(&quot;will change to \(newValue)&quot;) }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; This fulfills at least one of the use cases. Can&#39;t we do the same treatment to each proposed use cases and see if there are other parts that can stand on their own?<br>&gt; <br>&gt; I considered this approach. It works for behaviors that don&#39;t need to control a property&#39;s storage and only change the property&#39;s access behavior. To be fair, that covers a lot of ground, including things like observing, NSCopying, resetting, and locking synchronization. We would still need a feature, which could certainly be a different one, to generalize annotations that control the storage policy for decorated properties, which could cover things like laziness, indirect storage, unowned/weak-ness, dirty-tracking, C-style atomics, and pointer addressability—basically, anything where a plain old stored property of the API type isn&#39;t sufficient. (You could even throw get/set in this bucket, if you wanted to be super reductionist.) Finally, there&#39;s the feature to add operations on a *property* independent of its *type*, which interacts usefully with both other features—you need a way to reset a resettable or lazy property; maybe you want to bypass a synchronized property&#39;s lock in one place, etc. We&#39;d like to improve on the &quot;classic&quot; answer of exposing an underlying ivar or property in these cases. If you want to break it down in micro-features, I guess there are three here:<br>&gt; <br>&gt; 1. Factoring out storage patterns,<br>&gt; 2. Factoring out accessor patterns, and<br>&gt; 3. Adding per-property operations.<br>&gt; <br>&gt; (1) tends to be tightly coupled with (2)—if you&#39;re controlling storage, you almost certainly want to control the accessors over that storage. And (3) is useful with both (1) and (2). If there are separate features to be factored out here, I think they&#39;re very entangled features.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/9989205c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 2:46 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jan 13, 2016, at 2:07 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Thanks everyone for the first round of feedback on my behaviors proposal. I&#39;ve revised it with the following changes:<br>&gt;&gt; <br>&gt;&gt; - Instead of relying on mapping behaviors to function or type member lookup, I&#39;ve introduced a new purpose-built &#39;var behavior&#39; declaration, which declares the accessor and initializer requirements and provides the storage and behavior methods of the property. I think this gives a clearer design for authoring behaviors, and allows for a more efficient and flexible implementation model.<br>&gt;&gt; - I&#39;ve backed off from trying to include &#39;let&#39; behaviors. As many of you noted, it&#39;s better to tackle immutable computed properties more holistically than to try to backdoor them in.<br>&gt;&gt; - I suggest changing the declaration syntax to use a behavior to square brackets—&#39;var [behavior] foo&#39;—which avoids ambiguity with destructuring &#39;var&#39; bindings, and also works with future candidates for behavior decoration, particularly `subscript`.<br>&gt; <br>&gt; Syntax comments:<br>&gt; <br>&gt; I still think these feel attribute-like to me, but if we’re not just going to use @lazy — and I agree that that does have some problems —I’m fine with [lazy].<br>&gt; <br>&gt; &quot;var behavior&quot; is really weird to me, and the &lt;T&gt; doesn’t seem to fit and is pretty redundant in the common case.  How about this:<br>&gt; <br>&gt;   &quot;behavior&quot; var-or-let &quot;[&quot; identifier-list &quot;]&quot; (identifier | &quot;_&quot;) &quot;:&quot; identifier (&quot;=&quot; identifier)? (&quot;where&quot; generic-requirement-list)?<br>&gt; <br>&gt; So, for example,<br>&gt;   behavior var [lazy] _ : T where T : IntegerLiteralConvertible { … }<br>&gt; <br>&gt; This is definitely taking the idea of “this is basically a macro” and running with it.  Think of the stuff between “behavior” and the optional “where” as being a pattern for the declaration.  So this pattern would match:<br>&gt;   var [lazy] x: Int<br>&gt; but not:<br>&gt;   let [lazy] x: Int<br>&gt; or:<br>&gt;   var [lazy] x : Int = foo()<br>&gt; <br>&gt; The behavior list has to match exactly (or maybe as sets?).<br>&gt; <br>&gt; The property name, if bound, expands to a string literal within the behavior.<br>&gt; <br>&gt; The type name is always a generic parameter.  This interferes with the ability to make a pattern that only matches a concrete type, but I think that’s okay.<br>&gt; <br>&gt; The initializer name, if bound, expands to the original expression within the behavior.  Maybe it should be coerced to type T first?  Not sure.<br></p><p>I feel like there are two possible implementation models here: type instantiation and member instantiation.  The type instantiation model has the advantage of allowing generic programming over the complete lazy type, but probably means we end up creating a lot of redundant stuff, some of which we’d have trouble eliminating.  The member instantiation model is tricky and more limiting in terms of what you can do polymorphically directly with behavior types, but (1) I don’t think that’s crucial and (2) it does seem implementable.<br></p><p>The member-instantiation model looks like this:<br></p><p>Conceptually, a behavior declaration creates a generic behavior value type:<br>  struct [weak,lazy]&lt;T&gt; {<br>    ...<br>  }<br></p><p>That behavior declaration always contains an implicit “value” member:<br>  var value : T {<br>    ...<br>  }<br></p><p>Any accessors in the behavior body are considered to be accessors of the value member.  Everything else is just a member of the behavior type.<br></p><p>An expression within the main behavior declaration is “instantiated” if it refers to any of the bound macro parameters (other than the type T).  A function body within the main behavior declaration is instantiated if:<br>  - it contains an instantiated expression,<br>  - it is an initializer, and the initializer expression of a stored property contains an instantiated expression,<br>  - it uses a function within the main behavior declaration that is instantiated, or<br>  - it uses an accessor within the main behavior declaration that is instantiated.<br></p><p>An instantiated member or accessor of the behavior type may not be used outside of the behavior body except as directly applied to a particular behavior object.<br></p><p>We can still separately type-check and even generate SIL for instantiated members.  Type-checking works by saying that the property name is an opaque string literal and the initializer is an opaque r-value of type T; the type-checker would have to do the latter coercion for each use, but that seems better semantically and for type inference anyway.  When an instantiated function was used from an uninstantiated context, SILGen would just create SIL builtins that fetch the name / initializer; instantiating would clone the body and replace those operations.  The type checker would require that instantiated functions can only be used from appropriate contexts, and the SIL verifier and IRGen would do the same.<br></p><p>The behavior type must be nullary-initializable (possibly with an instantiated initializer).  At the use site, the behavior is always expanded as:<br>  var _foo_behavior = [weak,lazy]&lt;T&gt;()<br></p><p>I’m not quite sure how extensions should work with initializers, because what I described above naturally allows behaviors to be overloaded based on the presence/absence of the initializer.  Either that’s disallowed, or you have to write:<br>  extension var [weak,lazy] _ : T = _ { … }<br>to clarify that (1) you mean the behavior that allows an initializer but (2) you can’t actually use the initializer expression in your implementation, because the member-instantiation model definitely doesn’t support doing that.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/73989005/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;ve revised my proposal again based on more feedback. Syntax changes include:<br></p><p>- adopting John McCall&#39;s declaration-follows-use syntax for behavior declarations. I think this looks nice and provides a reasonable framework for binding all the fiddly bits of a property, such as its type, name, and initializer.<br>- changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br></p><p>To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors, and name binding as future extensions. Joe Pamer raised some design and technical challenges around how type inference should work with behaviors too, which I think deserve focused discussion, so I&#39;m sidestepping those issues by starting out saying properties with behaviors always need an explicit type. Here&#39;s the updated proposal:<br></p><p>https://gist.github.com/jckarter/66ae8fb361c0d57b3227<br></p><p>And for reference, previous iterations:<br></p><p>https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>January 22, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Joe,<br></p><p>I have a few of questions after reading your proposal.<br></p><p>Question #1 : <br></p><p>Let’s say that the property behavior has an init() method as in your example for the lazy property behavior where you simply assign nil to the value.  After the declaration of the lazy behavior you show how to use this behavior for a variable declared in the global scope, It appears to me that the init() gets called at the time the property is declared because you mention in the comment that the property is inited to nil:<br></p><p>var [lazy] x = 1738 // Allocates an Int? behind the scenes, inited to nil<br></p><p>My question is as follows: What about when the property is declared inside a class?  At what point is the init() called?<br></p><p><br></p><p>Question #2 :<br></p><p>In your example for the synchronized property behavior, you have the following line of code in the declaration of the behavior:<br></p><p>  var value: Value = initialValue<br></p><p>The get and the set accessors use withLock { … } to get / set the value.  However, the code above that stores the initialValue in the value variable does not use withLock { … }.  Does it matter?  And similar to question #1, at what time is this code executed?<br></p><p><br>Comments About this Proposal:<br></p><p>I’ve been following the threads on property behaviors as it is one of my favorite threads.  I don’t always understand everything that you are all saying, for example, I am not sure if I understand what you guys means by out-of-line initialization in this context.  <br></p><p>In general, I like the proposal.   At first I thought that the square brackets notation could be confusing as it looks like an array.  I understand there aren’t many options to use.  However, now that I think of this as a list of property behaviors preceding the property name, I think the square brackets are the right choice.  <br></p><p><br>Thank you<br></p><p><br></p><p><br>&gt; On Jan 22, 2016, at 7:33 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve revised my proposal again based on more feedback. Syntax changes include:<br>&gt; <br>&gt; - adopting John McCall&#39;s declaration-follows-use syntax for behavior declarations. I think this looks nice and provides a reasonable framework for binding all the fiddly bits of a property, such as its type, name, and initializer.<br>&gt; - changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt; <br>&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors, and name binding as future extensions. Joe Pamer raised some design and technical challenges around how type inference should work with behaviors too, which I think deserve focused discussion, so I&#39;m sidestepping those issues by starting out saying properties with behaviors always need an explicit type. Here&#39;s the updated proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/66ae8fb361c0d57b3227<br>&gt; <br>&gt; And for reference, previous iterations:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/5bfdd90e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 7:38 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; Hi Joe,<br>&gt; <br>&gt; I have a few of questions after reading your proposal.<br>&gt; <br>&gt; Question #1 : <br>&gt; <br>&gt; Let’s say that the property behavior has an init() method as in your example for the lazy property behavior where you simply assign nil to the value.  After the declaration of the lazy behavior you show how to use this behavior for a variable declared in the global scope, It appears to me that the init() gets called at the time the property is declared because you mention in the comment that the property is inited to nil:<br>&gt; <br>&gt; var [lazy] x = 1738 // Allocates an Int? behind the scenes, inited to nil<br>&gt; <br>&gt; My question is as follows: What about when the property is declared inside a class?  At what point is the init() called?<br></p><p>The init() is called at the beginning of initialization, as if the behavior&#39;s storage were expanded out with an initial value:<br></p><p>class Foo {<br>  var [lazy] x = 1738<br></p><p>  // Compiler expands this behind the scenes:<br>  var `x.[lazy]`: Int? = lazy.init()<br>}<br></p><p>It&#39;s useful for this to happen later, since many behaviors would want to allow out-of-line initialization in the containing type&#39;s init method:<br></p><p>class Bar {<br>  var [runcible] x: Int<br></p><p>  init() {<br>    x = 679 // Would like runcible.init(679) to trigger here<br>  }<br>}<br></p><p>There are some subtleties to this, so I wanted to subset that out as a separate extension.<br></p><p>&gt; <br>&gt; <br>&gt; Question #2 :<br>&gt; <br>&gt; In your example for the synchronized property behavior, you have the following line of code in the declaration of the behavior:<br>&gt; <br>&gt;   var value: Value = initialValue<br>&gt; <br>&gt; The get and the set accessors use withLock { … } to get / set the value.  However, the code above that stores the initialValue in the value variable does not use withLock { … }.  Does it matter?  And similar to question #1, at what time is this code executed?<br></p><p>The initializer will occur at the start of the container&#39;s initialization, as in the previous example (though `synchronized` is really somewhere you want to be able to trigger the initialization out-of-line). For `synchronized`, it&#39;s unlikely to be necessary to synchronize the initialization, since a class in Swift can&#39;t be shared across threads until it&#39;s already fully initialized.<br></p><p>&gt; <br>&gt; <br>&gt; Comments About this Proposal:<br>&gt; <br>&gt; I’ve been following the threads on property behaviors as it is one of my favorite threads.  I don’t always understand everything that you are all saying, for example, I am not sure if I understand what you guys means by out-of-line initialization in this context.  <br>&gt; <br>&gt; In general, I like the proposal.   At first I thought that the square brackets notation could be confusing as it looks like an array.  I understand there aren’t many options to use.  However, now that I think of this as a list of property behaviors preceding the property name, I think the square brackets are the right choice.  <br></p><p>Thanks! Don&#39;t be afraid to ask questions about things that aren&#39;t clear. When I refer to out-of-line initialization, I refer to the ability to initialize properties after their initial declaration. For local properties, this is possible by assigning the initial value to the property after its immediate declaration:<br></p><p>func foo() {<br>  var x: Int<br>  // some other stuff happens that doesn&#39;t use x<br>  x = 22 // out-of-line initialization of x<br>}<br></p><p>and for properties inside classes, this is possible during the class&#39;s `init` implementations:<br></p><p>class Foo {<br>  var x: Int<br></p><p>  init(x: Int) {<br>    self.x = x // out-of-line initialization of self.x<br>  }<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/a2dfdb31/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 23, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 23.01.2016 um 01:33 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;  changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br></p><p>As a minor issue I’m not very fond of the behavior member lookup syntax because of the similarity to a subscript. The symmetry with the declaration syntax will break down a little bit as soon as the declaration syntax allows a list of composed behaviors.<br></p><p><br>&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors and […] as future extensions<br></p><p>I think behavior composition should be included right from the beginning as this might require breaking changes otherwise.<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/4668d3a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 8:14 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 23.01.2016 um 01:33 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;  changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt; <br>&gt; As a minor issue I’m not very fond of the behavior member lookup syntax because of the similarity to a subscript. The symmetry with the declaration syntax will break down a little bit as soon as the declaration syntax allows a list of composed behaviors.<br>&gt; <br>&gt; <br>&gt;&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors and […] as future extensions<br>&gt; <br>&gt; I think behavior composition should be included right from the beginning as this might require breaking changes otherwise.<br></p><p>Practically speaking, I think there are inevitably going to be breaking changes here once we get some experience with the feature. It won&#39;t ship until 3.0 at the earliest. Many of the other features I&#39;ve cut, including the initialization generalizations and extensions, would also be ABI-breaking changes at the implementation level.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/845e5346/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 23.01.2016 um 20:30 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 23, 2016, at 8:14 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 23.01.2016 um 01:33 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt;&gt; <br>&gt;&gt; As a minor issue I’m not very fond of the behavior member lookup syntax because of the similarity to a subscript. The symmetry with the declaration syntax will break down a little bit as soon as the declaration syntax allows a list of composed behaviors.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors and […] as future extensions<br>&gt;&gt; <br>&gt;&gt; I think behavior composition should be included right from the beginning as this might require breaking changes otherwise.<br>&gt; <br>&gt; Practically speaking, I think there are inevitably going to be breaking changes here once we get some experience with the feature.<br></p><p>That’s a fair point :-)<br></p><p>&gt; It won&#39;t ship until 3.0 at the earliest. Many of the other features I&#39;ve cut, including the initialization generalizations and extensions, would also be ABI-breaking changes at the implementation level.<br></p><p>Ok, thanks! But doesn’t this collide with the goal of Swift 3.0 of a stable ABI?<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/3997cfc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 1:16 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 23.01.2016 um 20:30 schrieb Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 8:14 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 23.01.2016 um 01:33 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a minor issue I’m not very fond of the behavior member lookup syntax because of the similarity to a subscript. The symmetry with the declaration syntax will break down a little bit as soon as the declaration syntax allows a list of composed behaviors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors and […] as future extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think behavior composition should be included right from the beginning as this might require breaking changes otherwise.<br>&gt;&gt; <br>&gt;&gt; Practically speaking, I think there are inevitably going to be breaking changes here once we get some experience with the feature. <br>&gt; <br>&gt; That’s a fair point :-)<br>&gt; <br>&gt;&gt; It won&#39;t ship until 3.0 at the earliest. Many of the other features I&#39;ve cut, including the initialization generalizations and extensions, would also be ABI-breaking changes at the implementation level.<br>&gt; <br>&gt; Ok, thanks! But doesn’t this collide with the goal of Swift 3.0 of a stable ABI?<br></p><p>I hope we&#39;ll have the feature stabilized by then, of course. However, it&#39;s a strong goal for this feature to be &quot;zero-cost&quot; with little or no runtime footprint. If we&#39;re successful at that, there should be more or less no ABI impact, since behaviors would just be compile-time sugar.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/a577ead7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7b4f0271043628eecd950f1e3cdd1a84?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at googlemail.com&gt;<p>January 25, 2016 at 08:00:00pm</p></header><div class="content"><p>I must say that I really love your idea of property behaviours! I think a facility of this kind would be a great enhancement to Swift. <br></p><p>I probably will have some more comments after I study your proposal in more depth, but for now a very quick one. I am not overly fond of your syntax for accessing behaviour members. I would prefer something like foo(x).method() to x.[foo].method() that you suggest. <br></p><p><br>&gt; I hope we&#39;ll have the feature stabilized by then, of course. However, it&#39;s a strong goal for this feature to be &quot;zero-cost&quot; with little or no runtime footprint. If we&#39;re successful at that, there should be more or less no ABI impact, since behaviors would just be compile-time sugar.<br></p><p>I’m not so sure about that… your suggestion can have some non-trivial impact on reflection and instance memory layout. <br></p><p>— Taras<br></p><p><br>&gt; On 25 Jan 2016, at 19:25, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 24, 2016, at 1:16 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 23.01.2016 um 20:30 schrieb Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 8:14 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 23.01.2016 um 01:33 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a minor issue I’m not very fond of the behavior member lookup syntax because of the similarity to a subscript. The symmetry with the declaration syntax will break down a little bit as soon as the declaration syntax allows a list of composed behaviors.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors and […] as future extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think behavior composition should be included right from the beginning as this might require breaking changes otherwise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Practically speaking, I think there are inevitably going to be breaking changes here once we get some experience with the feature. <br>&gt;&gt; <br>&gt;&gt; That’s a fair point :-)<br>&gt;&gt; <br>&gt;&gt;&gt; It won&#39;t ship until 3.0 at the earliest. Many of the other features I&#39;ve cut, including the initialization generalizations and extensions, would also be ABI-breaking changes at the implementation level.<br>&gt;&gt; <br>&gt;&gt; Ok, thanks! But doesn’t this collide with the goal of Swift 3.0 of a stable ABI?<br>&gt; <br>&gt; I hope we&#39;ll have the feature stabilized by then, of course. However, it&#39;s a strong goal for this feature to be &quot;zero-cost&quot; with little or no runtime footprint. If we&#39;re successful at that, there should be more or less no ABI impact, since behaviors would just be compile-time sugar.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/a9336709/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 25, 2016 at 08:00:00pm</p></header><div class="content"><p>I must say that I really love your idea of property behaviours! I think a facility of this kind would be a great enhancement to Swift. <br></p><p>I probably will have some more comments after I study your proposal in more depth, but for now a very quick one. I am not overly fond of your syntax for accessing behaviour members. I would prefer something like foo(x).method() to x.[foo].method() that you suggest. <br></p><p><br>&gt; I hope we&#39;ll have the feature stabilized by then, of course. However, it&#39;s a strong goal for this feature to be &quot;zero-cost&quot; with little or no runtime footprint. If we&#39;re successful at that, there should be more or less no ABI impact, since behaviors would just be compile-time sugar.<br></p><p>I’m not so sure about that… your suggestion can have some non-trivial impact on reflection and instance memory layout. <br></p><p>— Taras<br></p><p>&gt; On 25 Jan 2016, at 19:25, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 24, 2016, at 1:16 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 23.01.2016 um 20:30 schrieb Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 8:14 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 23.01.2016 um 01:33 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a minor issue I’m not very fond of the behavior member lookup syntax because of the similarity to a subscript. The symmetry with the declaration syntax will break down a little bit as soon as the declaration syntax allows a list of composed behaviors.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors and […] as future extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think behavior composition should be included right from the beginning as this might require breaking changes otherwise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Practically speaking, I think there are inevitably going to be breaking changes here once we get some experience with the feature. <br>&gt;&gt; <br>&gt;&gt; That’s a fair point :-)<br>&gt;&gt; <br>&gt;&gt;&gt; It won&#39;t ship until 3.0 at the earliest. Many of the other features I&#39;ve cut, including the initialization generalizations and extensions, would also be ABI-breaking changes at the implementation level.<br>&gt;&gt; <br>&gt;&gt; Ok, thanks! But doesn’t this collide with the goal of Swift 3.0 of a stable ABI?<br>&gt; <br>&gt; I hope we&#39;ll have the feature stabilized by then, of course. However, it&#39;s a strong goal for this feature to be &quot;zero-cost&quot; with little or no runtime footprint. If we&#39;re successful at that, there should be more or less no ABI impact, since behaviors would just be compile-time sugar.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/4cc6bb53/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 25.01.2016 um 19:25 schrieb Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 24, 2016, at 1:16 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 23.01.2016 um 20:30 schrieb Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 8:14 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 23.01.2016 um 01:33 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a minor issue I’m not very fond of the behavior member lookup syntax because of the similarity to a subscript. The symmetry with the declaration syntax will break down a little bit as soon as the declaration syntax allows a list of composed behaviors.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors and […] as future extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think behavior composition should be included right from the beginning as this might require breaking changes otherwise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Practically speaking, I think there are inevitably going to be breaking changes here once we get some experience with the feature. <br>&gt;&gt; <br>&gt;&gt; That’s a fair point :-)<br>&gt;&gt; <br>&gt;&gt;&gt; It won&#39;t ship until 3.0 at the earliest. Many of the other features I&#39;ve cut, including the initialization generalizations and extensions, would also be ABI-breaking changes at the implementation level.<br>&gt;&gt; <br>&gt;&gt; Ok, thanks! But doesn’t this collide with the goal of Swift 3.0 of a stable ABI?<br>&gt; <br>&gt; I hope we&#39;ll have the feature stabilized by then, of course. However, it&#39;s a strong goal for this feature to be &quot;zero-cost&quot; with little or no runtime footprint. If we&#39;re successful at that, there should be more or less no ABI impact, since behaviors would just be compile-time sugar.<br></p><p>Good point! I think making behaviors &quot;zero-cost“ is a great idea!<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/dcd96e44/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 25, 2016 at 12:00:00pm</p></header><div class="content"><p>I don’t know enough about how ABIs work, but if this is out of scope for Swift 3, is there a way to add some “reserved for future use” bits or something now so that the ABI changes less often? It’d be a shame for people to be hesitant about this stuff for Swift 4 (or whatever) because they don’t want to break compatibility with some 3rd-party library that isn’t being maintained anymore.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 23, 2016, at 11:30, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; […] Many of the other features I’ve cut, including the initialization generalizations and extensions, would also be ABI-breaking changes at the implementation level.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/68c3205d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>January 23, 2016 at 05:00:00pm</p></header><div class="content"><p>This is an excellent update. Simplifying the proposal provides a strong starting point without foreclosing solutions to some of the thorny cases addressed in the original proposal. It will be good to have experience with the simpler behaviors when designing more powerful features later. (For example, I wonder if we&#39;ll discover that something like &quot;behavior combinators&quot; are the right way to solve behavior composition.)<br></p><p>Can the core team comment on the likely evolution of proposals like property behaviors that are separated into first steps and future work? That is, should we expect that some of the future work might be in scope for Swift 3, depending on the implementation of the first steps? Or is the hope to lock down the scope for Swift 3 sooner rather than later?<br></p><p>Regarding the foo.[resettable].reset() syntax, I agree that it&#39;s an improvement over the original proposal, both because it disambiguates with member access and because it provides better alignment of declaration and use. I&#39;m still not thrilled with it. As noted, it&#39;s easy to confuse the new syntax with subscripting. It also occurs to me that reusing common punctuation for an uncommon* language feature might lead to confusion. Will people tend to make what they feel are educated guesses about what a behavior reference means and get in trouble? (*Apart from Kotlin, do other languages have property behaviors?) <br></p><p>So, I continue to prefer a sigil at both declaration and use. On the other hand, I don&#39;t know what sigil we&#39;d use. It seems we&#39;re likely to spend the &#39;#&#39; sigil on #selector, #sourceLocation, and friends; &#39;@&#39; is already spoken for; and I suppose that 🗣 would be right out. :-)<br></p><p>I see that the grammar for property-behavior-decl includes the ability to bind the property name, though the first bullet in the section &quot;Bindings within Behavior Declarations&quot; says that this would be a future extension. At the least, these should be reconciled. If the reconciliation favors punting this aspect, I&#39;d like to see it mentioned in the Future Directions section.<br> <br>That said, I&#39;d love to see binding of the property name in the first iteration of behaviors. On the off chance that an example usage would be helpful, here&#39;s how we could begin implementing something like Omni&#39;s OAAppearance using a behavior:<br></p><p>```<br>public protocol PropertyListBackable {<br>    var backingPropertyList: [String: AnyObject] { get }<br>    func plistValueForKey&lt;T&gt;(key: String) -&gt; T<br>}<br></p><p>public behavior var [plistBacked] propertyName: Value where Self: PropertyListBackable {<br>  get {<br>    return self.plistValueForKey(propertyName)<br>  }<br>}<br></p><p>extension PropertyListBackable {<br>    func plistValueForKey&lt;T&gt;(key: String) -&gt; T {<br>        let plist = self.backingPropertyList<br>        let maybeResult = plist[key]<br>        guard let result = maybeResult as? T else {<br>            fatalError(&quot;Misconfigured property list&quot;)<br>        }<br>        return result<br>    }<br>}<br></p><p>class Appearance: PropertyListBackable {<br>    let backingPropertyList: [String: AnyObject]<br>    var [plistBacked] distance: Double    <br></p><p>    /// Returns the contents of property list resource &lt;ClassName&gt;.plist, where ClassName is the name of the receiver type.<br>    class func propertyListForType() -&gt; [String: AnyObject] {<br>        let typeName = String(self)<br>        let maybePlistURL = NSBundle.mainBundle().URLForResource(typeName, withExtension: &quot;.plist&quot;)<br>        guard let plistURL = maybePlistURL else {<br>            fatalError(&quot;Missing property list: \(typeName).plist&quot;)<br>        }<br>        <br>        let maybeResult = NSDictionary(contentsOfURL: plistURL)<br>        guard let result = maybeResult as? [String: AnyObject] else {<br>            fatalError(&quot;Malformed property list file: \(typeName).plist&quot;)<br>        }<br></p><p>        return result<br>    }<br>    <br>    init() {<br>        let plist = self.dynamicType.propertyListForType()<br>        backingPropertyList = plist<br>    }<br>}<br></p><p>class MyCoolAppAppearance: Appearance {<br>    var [plistBacked] faveSigil: String<br>}<br></p><p>let appearance = Appearance()<br>let distance = appearance.distance<br>print(&quot;distance: \(distance)&quot;) // distance: 3.0<br>        <br>let mcaAppearance = MyCoolAppAppearance()<br>let sigil = mcaAppearance.faveSigil<br>print(&quot;sigil: \(sigil)&quot;) // sigil: ❤️<br>```<br></p><p>Cheers,<br></p><p>Curt<br>-------------------------<br>Curt Clifton, PhD<br>Software Developer<br>The Omni Group<br>www.curtclifton.net<br></p><p><br>&gt; On Jan 22, 2016, at 4:33 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve revised my proposal again based on more feedback. Syntax changes include:<br>&gt; <br>&gt; - adopting John McCall&#39;s declaration-follows-use syntax for behavior declarations. I think this looks nice and provides a reasonable framework for binding all the fiddly bits of a property, such as its type, name, and initializer.<br>&gt; - changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt; <br>&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors, and name binding as future extensions. Joe Pamer raised some design and technical challenges around how type inference should work with behaviors too, which I think deserve focused discussion, so I&#39;m sidestepping those issues by starting out saying properties with behaviors always need an explicit type. Here&#39;s the updated proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/66ae8fb361c0d57b3227<br>&gt; <br>&gt; And for reference, previous iterations:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 25, 2016 at 11:00:00pm</p></header><div class="content"><p>On Jan 23, 2016, at 5:58 PM, Curt Clifton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can the core team comment on the likely evolution of proposals like property behaviors that are separated into first steps and future work? That is, should we expect that some of the future work might be in scope for Swift 3, depending on the implementation of the first steps? Or is the hope to lock down the scope for Swift 3 sooner rather than later?<br></p><p>I’m not sure exactly what you’re asking here, so let me respond to several points that you might be asking :-)<br></p><p>- We generally prefer small proposals that stand on their own, which can then have other proposals built on top of them.<br></p><p>- I think that property behaviors is a strong goal for Swift 3, because we’d like to clean up lazy, @NSManaged, etc to get magic out of the compiler.<br></p><p>- I think we want a fully baked implementation of property behaviors for swift 3, but would be willing to subset out advanced features if it makes sense.  It doesn’t have to solve all conceivable problems and can be extended over time.<br></p><p>- Predicting what will end up in Swift 3 (e.g., “will we achieve our goals?&quot;) is inherently fraught with peril and cannot be done perfectly.  There are a ton of unknowns in design and implementation of any feature (e.g., how do you know how long it will take to implement behaviors when we don’t have a concrete design?), and new work gets added all of the time as we find new problems to solve and the community identifies new problems.  It is also impossible to predict what open source contributors will provide.<br></p><p><br>Part of the reason we have to say “no” to good ideas is that we are incredibly design and implementation bound.  We have high goals for Swift 3 as it is, but we aren’t 100% certain we’ll be able to achieve them (that’s why they are “goals”, not “certainty”).  I think that we’ve had a consistent approach with Swift 3, where we’re focused on fixing core deficiencies in the base language, fixing implementation issues and designing resilience features that affect ABI stability, while taking on small scope extensions to the language.  This has come at a cost of having to defer discussion on “large” extensions to the language that do not affect the core model (e.g. the memberwise init revamp) but I’m hoping that we will still get some of those for Swift 3. <br></p><p>Overall, this comes back to a higher order philosophy about what Swift 3 is really about: it is about driving the next wave of adoption of Swift by even more people.  This will hopefully come from new audiences coming on-board as Corelibs + Swift on Linux (and other platforms) become real, SwiftPM being great and growing into its own, and the Swift language/stdlib maturing even more.<br></p><p>What does this mean looking forward?  Well, Swift 2 to Swift 3 is going to be an unavoidably disruptive change for code since Cocoa renamification is going to land, and we’re going to be building impressive migration technology again.  As such, we should try to get the “rearrange all the deckchairs” changes into Swift 3 if possible, to make Swift 3 to 4 as smooth as possible.  While our community has generally been very kind and understanding about Swift evolving under their feet, we cannot keep doing this for long.  While I don’t think we’ll want to guarantee 100% source compatibility from Swift 3 to Swift 4, I’m hopefully that it will be much simpler than the upgrade to Swift 2 was or Swift 3 will be.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>January 26, 2016 at 11:00:00am</p></header><div class="content"><p>On Jan 25, 2016, at 11:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jan 23, 2016, at 5:58 PM, Curt Clifton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can the core team comment on the likely evolution of proposals like property behaviors that are separated into first steps and future work? That is, should we expect that some of the future work might be in scope for Swift 3, depending on the implementation of the first steps? Or is the hope to lock down the scope for Swift 3 sooner rather than later?<br>&gt; <br>&gt; I’m not sure exactly what you’re asking here, so let me respond to several points that you might be asking :-)<br></p><p>Thanks, Chris. That&#39;s incredibly helpful.<br></p><p>Cheers, <br>Curt<br>-------------------------<br>Curt Clifton, PhD<br>Software Developer<br>The Omni Group<br>www.curtclifton.net<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Finally caught up. :-) I like this latest version better than the two previous versions, but I kind of think that if behaviors can&#39;t emulate &quot;lazy&quot;, we&#39;ve failed. Nothing has a stronger motivation than that at this point in time; there&#39;s lots of cool things we could use behaviors for, but you can still write all of them with a wrapper type.<br></p><p>Deferred questions along that line of thought:<br>- Can a behavior optionally have an initial value, and provide its own default otherwise?<br>- Can a behavior optionally have an initial value, and require phase-1 initialization in an instance initializer otherwise?<br>- Does a behavior with no initializer requirements not allow initial values?<br></p><p>Other comments on the actual proposal:<br></p><p>- Is &#39;Self&#39; the static type or the dynamic type of &#39;self&#39;? That is, what does &#39;Self()&#39; do in a class with subclasses?<br></p><p>- Someone else brought this up, but can I override behavior methods in a subclass with a new behavior? Can I invoke super&#39;s implementation of those behavior methods?<br></p><p>- Can I wrap a superclass property with a behavior? This version of the proposal doesn&#39;t have &#39;base&#39;, so I assume the answer is no, but that knocks out the other special-case language feature that was to be replaced by the general feature.<br></p><p>- I&#39;m not sure why changing the storage in a public behavior is inherently fragile, unless they are public. I think it&#39;s more that behaviors are all inlined, so if the implementation changes there&#39;s no guarantee that existing users of the behavior are using the updated version. That means changes aren&#39;t breaking, just not guaranteed universal.<br></p><p>- Like many others I&#39;m still not happy with the syntax—either the declaration syntax or the use syntax. I agree that it looks like a subscript and has nothing to do with other square brackets in the language…although there are only so many sigils. (Okay, I guess it&#39;s vaguely like capture lists.)<br></p><p>- I don&#39;t like that the name of the behavior shows up in the member access. I feel like the behavior of &quot;Resettable&quot; or &quot;Observable&quot; could be implemented by different behaviors, and I would want the freedom to resiliently change that while keeping the same public interface. Further down that direction lies &quot;behavior protocols&quot;, though, which is way too much complexity for this…<br></p><p>- Nitpick: why are &quot;willSet&quot; and &quot;didSet&quot; mutating? (I know they are now, but that seems like the wrong interface once we have something more flexible.)<br></p><p><br>I think that&#39;s all I have for now. <br></p><p>Jordan<br></p><p><br>&gt; On Jan 22, 2016, at 16:33, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve revised my proposal again based on more feedback. Syntax changes include:<br>&gt; <br>&gt; - adopting John McCall&#39;s declaration-follows-use syntax for behavior declarations. I think this looks nice and provides a reasonable framework for binding all the fiddly bits of a property, such as its type, name, and initializer.<br>&gt; - changing the proposed syntax for behavior member lookup to &#39;property.[behavior].member&#39;, as suggested by Tal Atlas and others. I think this has a nice symmetry with the `var [behavior]` declaration syntax, and doesn&#39;t occupy any new sigils. On the other had, Curt Clifton and others have raised the point that it could be mistaken for a subscript at a glance.<br>&gt; <br>&gt; To reduce the complexity of the initial feature review, I&#39;ve also removed many of the bells and whistles from this initial version for separate consideration. For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized. This imposes some inconvenience on some use cases, but is an additive feature. I&#39;ve also left behavior composition, extending behaviors, overloading behaviors, and name binding as future extensions. Joe Pamer raised some design and technical challenges around how type inference should work with behaviors too, which I think deserve focused discussion, so I&#39;m sidestepping those issues by starting out saying properties with behaviors always need an explicit type. Here&#39;s the updated proposal:<br>&gt; <br>&gt; https://gist.github.com/jckarter/66ae8fb361c0d57b3227<br>&gt; <br>&gt; And for reference, previous iterations:<br>&gt; <br>&gt; https://gist.github.com/jckarter/50b838e7f036fe85eaa3<br>&gt; https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/1137025e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 25, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 6:40 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Finally caught up. :-) I like this latest version better than the two previous versions, but I kind of think that if behaviors can&#39;t emulate &quot;lazy&quot;, we&#39;ve failed. Nothing has a stronger motivation than that at this point in time; there&#39;s lots of cool things we could use behaviors for, but you can still write all of them with a wrapper type.<br></p><p>Not sure what you mean. It can.<br></p><p>&gt; Deferred questions along that line of thought:<br>&gt; - Can a behavior optionally have an initial value, and provide its own default otherwise?<br></p><p>Not yet.<br></p><p>&gt; - Can a behavior optionally have an initial value, and require phase-1 initialization in an instance initializer otherwise?<br></p><p>Not yet.<br></p><p>&gt; - Does a behavior with no initializer requirements not allow initial values?<br></p><p>Yes for now. I&#39;m trying to keep the initial model simple. Rounding out the initialization model is a design discussion unto itself.<br></p><p>&gt; Other comments on the actual proposal:<br>&gt; <br>&gt; - Is &#39;Self&#39; the static type or the dynamic type of &#39;self&#39;? That is, what does &#39;Self()&#39; do in a class with subclasses?<br></p><p>Good question.<br></p><p>&gt; <br>&gt; - Someone else brought this up, but can I override behavior methods in a subclass with a new behavior? Can I invoke super&#39;s implementation of those behavior methods?<br>&gt; <br>&gt; - Can I wrap a superclass property with a behavior? This version of the proposal doesn&#39;t have &#39;base&#39;, so I assume the answer is no, but that knocks out the other special-case language feature that was to be replaced by the general feature.<br></p><p>We&#39;re not done yet; this is just version 1. I&#39;m subsetting composition out, since that&#39;s also an interesting discussion unto itself. You ultimately ought to be able to wrap a superclass property in new behaviors, but I don&#39;t see how you could replace a behavior without violating the superclass&#39;s encapsulation. Chaining to super behavior members also feels a bit overly intimate; do you have a use case in mind?<br></p><p>&gt; - I&#39;m not sure why changing the storage in a public behavior is inherently fragile, unless they are public. I think it&#39;s more that behaviors are all inlined, so if the implementation changes there&#39;s no guarantee that existing users of the behavior are using the updated version. That means changes aren&#39;t breaking, just not guaranteed universal.<br></p><p>Maybe fragile is the wrong word—&#39;inlineable&#39; is more what I meant.<br></p><p>&gt; - Like many others I&#39;m still not happy with the syntax—either the declaration syntax or the use syntax. I agree that it looks like a subscript and has nothing to do with other square brackets in the language…although there are only so many sigils. (Okay, I guess it&#39;s vaguely like capture lists.)<br>&gt; <br>&gt; - I don&#39;t like that the name of the behavior shows up in the member access. I feel like the behavior of &quot;Resettable&quot; or &quot;Observable&quot; could be implemented by different behaviors, and I would want the freedom to resiliently change that while keeping the same public interface. Further down that direction lies &quot;behavior protocols&quot;, though, which is way too much complexity for this…<br>&gt; <br>&gt; - Nitpick: why are &quot;willSet&quot; and &quot;didSet&quot; mutating? (I know they are now, but that seems like the wrong interface once we have something more flexible.)<br>&gt; <br>&gt; I think that&#39;s all I have for now. <br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/0463f537/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 18:54 , Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 6:40 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Finally caught up. :-) I like this latest version better than the two previous versions, but I kind of think that if behaviors can&#39;t emulate &quot;lazy&quot;, we&#39;ve failed. Nothing has a stronger motivation than that at this point in time; there&#39;s lots of cool things we could use behaviors for, but you can still write all of them with a wrapper type.<br>&gt; <br>&gt; Not sure what you mean. It can.<br></p><p>But you have this in your other message:<br></p><p>&gt; For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized.<br></p><p>Is it really just &quot;can&#39;t refer to self&quot; and not actually &quot;eager&quot;?<br></p><p><br>&gt;&gt; - Someone else brought this up, but can I override behavior methods in a subclass with a new behavior? Can I invoke super&#39;s implementation of those behavior methods?<br>&gt;&gt; <br>&gt;&gt; - Can I wrap a superclass property with a behavior? This version of the proposal doesn&#39;t have &#39;base&#39;, so I assume the answer is no, but that knocks out the other special-case language feature that was to be replaced by the general feature.<br>&gt; <br>&gt; We&#39;re not done yet; this is just version 1. I&#39;m subsetting composition out, since that&#39;s also an interesting discussion unto itself. You ultimately ought to be able to wrap a superclass property in new behaviors, but I don&#39;t see how you could replace a behavior without violating the superclass&#39;s encapsulation. Chaining to super behavior members also feels a bit overly intimate; do you have a use case in mind?<br></p><p>willSet or didSet wrapping a superclass setter is not at all uncommon, and the sort of things you wrap with didSet are usually things that want to know about reset() as well. I&#39;m not sure any of your other examples of property methods have this problem, though—it might only be things that are set-like.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/7389de52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 8:15 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 18:54 , Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 6:40 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally caught up. :-) I like this latest version better than the two previous versions, but I kind of think that if behaviors can&#39;t emulate &quot;lazy&quot;, we&#39;ve failed. Nothing has a stronger motivation than that at this point in time; there&#39;s lots of cool things we could use behaviors for, but you can still write all of them with a wrapper type.<br>&gt;&gt; <br>&gt;&gt; Not sure what you mean. It can.<br>&gt; <br>&gt; But you have this in your other message:<br>&gt; <br>&gt;&gt; For now, I&#39;m saying initializer requirements are always &quot;eager&quot; (can&#39;t refer to self) and always inline-initialized.<br>&gt; <br>&gt; Is it really just &quot;can&#39;t refer to self&quot; and not actually &quot;eager&quot;?<br></p><p>`lazy var`s still can&#39;t refer to self today AFAIK (I know we tried to fix that, but we still get plenty of radars saying it doesn&#39;t work…), so I don&#39;t think it would be a regression for a behavior implementation not to immediately be able to either. (And I&#39;m not proposing we immediately replace our existing &#39;lazy&#39; implementation immediately either.)<br></p><p>&gt;&gt;&gt; - Someone else brought this up, but can I override behavior methods in a subclass with a new behavior? Can I invoke super&#39;s implementation of those behavior methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Can I wrap a superclass property with a behavior? This version of the proposal doesn&#39;t have &#39;base&#39;, so I assume the answer is no, but that knocks out the other special-case language feature that was to be replaced by the general feature.<br>&gt;&gt; <br>&gt;&gt; We&#39;re not done yet; this is just version 1. I&#39;m subsetting composition out, since that&#39;s also an interesting discussion unto itself. You ultimately ought to be able to wrap a superclass property in new behaviors, but I don&#39;t see how you could replace a behavior without violating the superclass&#39;s encapsulation. Chaining to super behavior members also feels a bit overly intimate; do you have a use case in mind?<br>&gt; <br>&gt; willSet or didSet wrapping a superclass setter is not at all uncommon, and the sort of things you wrap with didSet are usually things that want to know about reset() as well.<br></p><p>That&#39;s another interesting composition dilemma—if you wrap a property in observers in a subclass, then you&#39;d probably want the base class&#39;s &#39;resettable&#39; behavior to trigger the subclass&#39;s observers.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/338d4ef5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 26, 2016 at 11:00:00am</p></header><div class="content"><p>On Tue, Jan 26, 2016 at 9:14 AM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; `lazy var`s still can&#39;t refer to self today AFAIK (I know we tried to fix<br>&gt; that, but we still get plenty of radars saying it doesn&#39;t work…), so I<br>&gt; don&#39;t think it would be a regression for a behavior implementation not to<br>&gt; immediately be able to either. (And I&#39;m not proposing we immediately<br>&gt; replace our existing &#39;lazy&#39; implementation immediately either.)<br>&gt;<br></p><p>They can; it just requires a type annotation.<br></p><p>class C {<br>    lazy var b: B = B(c: self)<br>}<br></p><p>struct B {<br>    let c: C<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/4154edad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Or with the anonymous self-calling closure dance.<br></p><p>On Tue, Jan 26, 2016, at 02:40 PM, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt; On Tue, Jan 26, 2016 at 9:14 AM, Joe Groff via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; `lazy var`s still can&#39;t refer to self today AFAIK (I know we tried to<br>&gt;&gt; fix that, but we still get plenty of radars saying it doesn&#39;t work…),<br>&gt;&gt; so I don&#39;t think it would be a regression for a behavior<br>&gt;&gt; implementation not to immediately be able to either. (And I&#39;m not<br>&gt;&gt; proposing we immediately replace our existing &#39;lazy&#39; implementation<br>&gt;&gt; immediately either.)<br>&gt;&gt;<br>&gt;<br>&gt; They can; it just requires a type annotation.<br>&gt;<br>&gt; class C {    lazy var b: B = B(c: self) }<br>&gt;<br>&gt; struct B {    let c: C }<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/0155ebca/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 18, 2016 at 04:00:00pm</p></header><div class="content"><p>Here are some of my thoughts from reading through the current version (<br>https://gist.github.com/jckarter/50b838e7f036fe85eaa3). Apologies if this<br>duplicates what anyone else has said; the thread is kind of unmanageable :)<br></p><p>  // Behaviors can declare that properties using the behavior require<br>&gt;   // a `deferred initializer` expression. When deferred, the<br>&gt;   // initializer expression is assumed to be evaluated after<br>&gt;   // initialization of the containing value, which allows it to refer<br>&gt;   // to `self`. If declared, `initializer` is bound in accessors and<br>&gt;   // methods of the behavior.<br>&gt;   deferred initializer: Value<br></p><p><br>This seems like an important feature, but the syntax is strange to me. It<br>looks like it would be declaring storage inside the behavior, but it&#39;s<br>really specifying the type of something used in the containing object&#39;s<br>property declaration.<br></p><p>I can think of a couple alternatives:<br></p><p>1. Rather than passing an initial value in the containing object like &quot;var<br>[lazy] prop = someInitialValue&quot;, pass it explicitly as a parameter to the<br>behavior,<br>    like &quot;var [ lazy({ return someInitialValue }) ] prop: Type&quot;<br></p><p>    I think it might be generally useful for behaviors&#39; initializers to<br>take arguments; it&#39;d handle more than just this case. For example, you<br>could have a behavior called synchronized(maxConcurrentRequests: Int) which<br>would allow arguments passed to affect the behavior&#39;s...behavior.<br></p><p>2. Make the &quot;deferred&quot;-ness a modifier/attribute on the behavior<br>declaration, like &quot;public @deferred var behavior lazy&lt;Value&gt;: Value { ...<br>}&quot;, which would make the implicit initialValue inaccessible from the<br>behavior&#39;s init(). The same with @eager.<br></p><p><br>x.lazy.clear() // Invokes `lazy`&#39;s `clear` method<br></p><p><br>As I think others have mentioned, this is ambiguous if x itself has a<br>property called &quot;lazy&quot;. I&#39;d be reasonably satisfied with any of the<br>proposed solutions to this.<br></p><p><br>  base var value: Int<br></p><p><br>I don&#39;t think I like the fact that this needs to be explicitly declared. Do<br>all behaviors have to use the same identifier for them to be composable?<br>Could you use &quot;super&quot; to mean this, instead of explicitly declaring a base<br>property?<br></p><p><br>Accessor requirements can be made optional by specifying a default<br>&gt; implementation:<br>&gt;   mutating accessor willSet(newValue: Value) {<br>&gt;     // do nothing by default<br>&gt;   }<br></p><p><br>Up until this point, I was thinking of accessor declarations like protocol<br>requirements, in that they have no implementation (&quot;accessor foo()&quot; like<br>&quot;func foo()&quot;). I think the lack of implementation is what makes it clear<br>that these are requirements, not things the behavior is implementing.<br></p><p>So perhaps you could use the &quot;optional&quot; specifier to indicate that they<br>aren&#39;t required, rather than allowing an implementation block in the<br>behavior. &quot;optional accessor foo()&quot; would allow the behavior&#39;s<br>implementation to use &quot;foo?()&quot;.<br></p><p><br>var [foo] x: Int {<br></p><p>    bar(myArg) { print(myArg) } // `arg` explicitly bound to `myArg`<br></p><p>}<br></p><p><br>Why not require a type annotation for parameters here? I recognize this<br>matches the current syntax of set(newValue), but it would be more flexible<br>if this were more like a function declaration.<br></p><p>To preserve the shorthand for get-only computed properties, if the accessor<br>&gt; declaration consists of code like a function body, that code is used as the<br>&gt; implementation of a single accessor named &quot;get&quot;.<br></p><p><br>This seems a bit vestigial. Maybe it could be allowed only when a computed<br>property is declared without using any behaviors.<br></p><p>A few more questions:<br></p><p>- Can a behavior&#39;s own properties/storage use other behaviors? Can a<br>behavior be recursive?<br></p><p>- What of deinitializers for behaviors? Would it be possible, for example,<br>to make an observable behavior whose willSet/didSet run during init and<br>deinit (which Swift&#39;s current property observers can&#39;t do)?<br></p><p>- Are accessor implementations allowed to access the &quot;current&quot; property<br>value? Currently, inside &quot;var foo { didSet { … } }&quot; you can access the<br>current value by referencing &quot;foo&quot;.<br></p><p>Overall this looks great. I&#39;m looking forward to it. :-)<br></p><p>Jacob Bandes-Storch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/2867f735/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 4:29 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Here are some of my thoughts from reading through the current version (https://gist.github.com/jckarter/50b838e7f036fe85eaa3 &lt;https://gist.github.com/jckarter/50b838e7f036fe85eaa3&gt;). Apologies if this duplicates what anyone else has said; the thread is kind of unmanageable :)<br>&gt; <br>&gt;   // Behaviors can declare that properties using the behavior require<br>&gt;   // a `deferred initializer` expression. When deferred, the<br>&gt;   // initializer expression is assumed to be evaluated after<br>&gt;   // initialization of the containing value, which allows it to refer<br>&gt;   // to `self`. If declared, `initializer` is bound in accessors and<br>&gt;   // methods of the behavior.<br>&gt;   deferred initializer: Value<br>&gt; <br>&gt; This seems like an important feature, but the syntax is strange to me. It looks like it would be declaring storage inside the behavior, but it&#39;s really specifying the type of something used in the containing object&#39;s property declaration.<br>&gt; <br>&gt; I can think of a couple alternatives:<br>&gt; <br>&gt; 1. Rather than passing an initial value in the containing object like &quot;var [lazy] prop = someInitialValue&quot;, pass it explicitly as a parameter to the behavior,<br>&gt;     like &quot;var [ lazy({ return someInitialValue }) ] prop: Type&quot;<br>&gt; <br>&gt;     I think it might be generally useful for behaviors&#39; initializers to take arguments; it&#39;d handle more than just this case. For example, you could have a behavior called synchronized(maxConcurrentRequests: Int) which would allow arguments passed to affect the behavior&#39;s...behavior.<br></p><p>You can parameterize using accessors, which can also theoretically replace all uses of a bound initializer. For example:<br></p><p>var [lazy] prop: Type { initialValue { return someInitialValue } }<br></p><p>&gt; 2. Make the &quot;deferred&quot;-ness a modifier/attribute on the behavior declaration, like &quot;public @deferred var behavior lazy&lt;Value&gt;: Value { ... }&quot;, which would make the implicit initialValue inaccessible from the behavior&#39;s init(). The same with @eager.<br>&gt; <br>&gt; <br>&gt; x.lazy.clear() // Invokes `lazy`&#39;s `clear` method<br>&gt; <br>&gt; As I think others have mentioned, this is ambiguous if x itself has a property called &quot;lazy&quot;. I&#39;d be reasonably satisfied with any of the proposed solutions to this.<br>&gt; <br>&gt; <br>&gt;   base var value: Int<br>&gt; <br>&gt; I don&#39;t think I like the fact that this needs to be explicitly declared. Do all behaviors have to use the same identifier for them to be composable? Could you use &quot;super&quot; to mean this, instead of explicitly declaring a base property?<br></p><p>The identifier &#39;value&#39; is up to the declaration to decide. Some behaviors don&#39;t have a base; anything that needs to control the storage, such as &#39;lazy&#39;, can&#39;t really be composed this way. I thought about using &#39;super&#39; for this, but a behavior would still need a way to declare whether it has a &#39;super&#39; or not. It&#39;s also weird to bind both &#39;self&#39; and &#39;super&#39; with totally different meanings. A number of people have objected to the special treatment of &#39;self&#39; I&#39;ve proposed already.<br></p><p>&gt; <br>&gt; Accessor requirements can be made optional by specifying a default implementation:<br>&gt;   mutating accessor willSet(newValue: Value) {<br>&gt;     // do nothing by default<br>&gt;   }<br>&gt; <br>&gt; Up until this point, I was thinking of accessor declarations like protocol requirements, in that they have no implementation (&quot;accessor foo()&quot; like &quot;func foo()&quot;). I think the lack of implementation is what makes it clear that these are requirements, not things the behavior is implementing.<br></p><p>It&#39;s planned for the future to allow protocol declarations to contain default implementations in-line, and I see &#39;optional&#39; protocol requirements as being only for ObjC compatibility and not something you should use in pure Swift designs.<br></p><p>&gt; <br>&gt; So perhaps you could use the &quot;optional&quot; specifier to indicate that they aren&#39;t required, rather than allowing an implementation block in the behavior. &quot;optional accessor foo()&quot; would allow the behavior&#39;s implementation to use &quot;foo?()&quot;.<br>&gt; <br>&gt; <br>&gt; var [foo] x: Int { <br>&gt;     bar(myArg) { print(myArg) } // `arg` explicitly bound to `myArg` <br>&gt; }<br>&gt; <br>&gt; Why not require a type annotation for parameters here? I recognize this matches the current syntax of set(newValue), but it would be more flexible if this were more like a function declaration.<br></p><p>We could optionally accept type annotations, but the argument types should almost always be inferrable.<br></p><p>&gt; <br>&gt; To preserve the shorthand for get-only computed properties, if the accessor declaration consists of code like a function body, that code is used as the implementation of a single accessor named &quot;get&quot;.<br>&gt; <br>&gt; This seems a bit vestigial. Maybe it could be allowed only when a computed property is declared without using any behaviors.<br></p><p>That would be reasonable.<br>&gt; <br>&gt; A few more questions:<br>&gt; <br>&gt; - Can a behavior&#39;s own properties/storage use other behaviors? Can a behavior be recursive?<br></p><p>Yes, and yes, as long as in doing so you don&#39;t produce infinite storage.<br></p><p>&gt; <br>&gt; - What of deinitializers for behaviors? Would it be possible, for example, to make an observable behavior whose willSet/didSet run during init and deinit (which Swift&#39;s current property observers can&#39;t do)?<br></p><p>I don&#39;t think we want to change how behaviors work in init and deinit. It isn&#39;t possible to invoke methods before `self` is initialized, and it&#39;s dangerous to do so during `deinit`.<br></p><p>&gt; <br>&gt; - Are accessor implementations allowed to access the &quot;current&quot; property value? Currently, inside &quot;var foo { didSet { … } }&quot; you can access the current value by referencing &quot;foo&quot;.<br></p><p>Accessor implementations can access the behavior&#39;s storage, so they can either access their stored property containing the property value directly, or factor more complex accessor logic out into a helper method.<br></p><p>&gt; <br>&gt; Overall this looks great. I&#39;m looking forward to it. :-)<br></p><p>Thanks!<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/9d8b08c1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
