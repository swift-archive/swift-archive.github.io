<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>Simpler interpretation of a reference to a generic type with no arguments<br></p><p>Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;Introduction<br></p><p>This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br></p><p>Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br> &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;Motivation<br></p><p>Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br></p><p>If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br></p><p>For example,<br></p><p>struct GenericBox&lt;Contents&gt; {<br>  let contents: Contents<br></p><p>  // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>  func clone() -&gt; GenericBox {<br>    return GenericBox(contents: contents)<br>  }<br>}<br></p><p>extension GenericBox {<br>  func print() {<br>    // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>    let cloned: GenericBox = clone()<br>    print(cloned.contents)<br>  }<br>}<br>If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br></p><p>For example,<br></p><p>func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>  // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>  return GenericBox(contents: 123)<br>}<br>The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br></p><p>extension GenericBox {<br></p><p>  func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>    // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>    // inferring the type parameter<br>    return GenericBox(contents: f(contents))<br>  }<br>}<br> &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed solution<br></p><p>The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br></p><p> &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed design<br></p><p>This really just involves removing an existing piece of logic from the type resolver code.<br></p><p> &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact on existing code<br></p><p>This will have a small impact on existing code that uses a pattern similar to the above.<br></p><p> &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status quo<br></p><p>We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br></p><p> &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More complex inference of generic parameters<br></p><p>We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/d756da92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>When you mention the difficulty of an alternative, is that to say that it&#39;s<br>not feasible for the GenericBox in the last example to be resolved as<br>GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most<br>sensible behavior.<br>On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt;<br>&gt;    - Proposal: SE-9999<br>&gt;    &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt;    - Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal cleans up the semantics of a reference to a generic type<br>&gt; when no generic arguments are applied.<br>&gt;<br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;<br>&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Right now, we allow a generic type to be referenced with no generic<br>&gt; arguments applied in a handful of special cases. The two primary rules here<br>&gt; are the following:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    If the scope from which the reference is made is nested inside the<br>&gt;    definition of the type or an extension thereof, omitting generic arguments<br>&gt;    just means to implicitly apply the arguments from context.<br>&gt;<br>&gt;    For example,<br>&gt;<br>&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;   let contents: Contents<br>&gt;<br>&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;   func clone() -&gt; GenericBox {<br>&gt;     return GenericBox(contents: contents)<br>&gt;   }<br>&gt; }<br>&gt; extension GenericBox {<br>&gt;   func print() {<br>&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;     let cloned: GenericBox = clone()<br>&gt;     print(cloned.contents)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    If the type is referenced from an unrelated scope, we attempt to infer<br>&gt;    the generic parameters.<br>&gt;<br>&gt;    For example,<br>&gt;<br>&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;   return GenericBox(contents: 123)<br>&gt; }<br>&gt;<br>&gt; The problem appears when the user expects the second behavior, but instead<br>&gt; encounters the first. For example, the following does not type check:<br>&gt;<br>&gt; extension GenericBox {<br>&gt;<br>&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;     // inferring the type parameter<br>&gt;     return GenericBox(contents: f(contents))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The proposed solution is to remove the first rule altogether. If the<br>&gt; generic parameters cannot be inferred from context, they must be specified<br>&gt; explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;<br>&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; This really just involves removing an existing piece of logic from the<br>&gt; type resolver code.<br>&gt;<br>&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This will have a small impact on existing code that uses a pattern similar<br>&gt; to the above.<br>&gt;<br>&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status<br>&gt; quo<br>&gt;<br>&gt; We could keep the current behavior, but one can argue it is not very<br>&gt; useful, and adds a special case where one is not needed.<br>&gt;<br>&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More<br>&gt; complex inference of generic parameters<br>&gt; We could attempt to unify the two rules for resolving a reference to a<br>&gt; generic type with no arguments, however this presents theoretical<br>&gt; difficulties with our constraint solver design. Even if it were easy to<br>&gt; implement, it would increase type checking type by creating new<br>&gt; possibilities to consider, with very little actual benefit.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/c4239b31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; When you mention the difficulty of an alternative, is that to say that it&#39;s not feasible for the GenericBox in the last example to be resolved as GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most sensible behavior.<br></p><p>With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt; in the last example. Right now it fails to type check.<br></p><p>Here is an example that works right now, but would not work with my proposed change:<br></p><p>struct GenericBox&lt;Contents&gt; {<br>	// Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>	// With the new rule, we cannot infer the parameter, because there’s no expression to infer it from<br>	func combine(other: GenericBox) {<br>		…<br>	}<br>}<br></p><p>Basically the meaning of ‘GenericBox’ right now depends on whether it appears inside its own definition or extension thereof, or not. The behavior when it appears elsewhere is more general — we infer the parameters from the surrounding expression, instead of assuming they’re equal to the context parameters.<br></p><p>This is a subtle change — definitely let me know if I’m not explaining it well.<br></p><p>Slava<br></p><p>&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt; <br>&gt; Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt; Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;Motivation<br>&gt; <br>&gt; Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br>&gt; <br>&gt; If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br>&gt; <br>&gt; For example,<br>&gt; <br>&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;   let contents: Contents<br>&gt; <br>&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;   func clone() -&gt; GenericBox {<br>&gt;     return GenericBox(contents: contents)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension GenericBox {<br>&gt;   func print() {<br>&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;     let cloned: GenericBox = clone()<br>&gt;     print(cloned.contents)<br>&gt;   }<br>&gt; }<br>&gt; If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br>&gt; <br>&gt; For example,<br>&gt; <br>&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;   return GenericBox(contents: 123)<br>&gt; }<br>&gt; The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br>&gt; <br>&gt; extension GenericBox {<br>&gt; <br>&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;     // inferring the type parameter<br>&gt;     return GenericBox(contents: f(contents))<br>&gt;   }<br>&gt; }<br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed design<br>&gt; <br>&gt; This really just involves removing an existing piece of logic from the type resolver code.<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status quo<br>&gt; <br>&gt; We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More complex inference of generic parameters<br>&gt; <br>&gt; We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/0c54749e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 1:30 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When you mention the difficulty of an alternative, is that to say that it&#39;s not feasible for the GenericBox in the last example to be resolved as GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most sensible behavior.<br>&gt; <br>&gt; With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt; in the last example. Right now it fails to type check.<br></p><p>This should make it clearer:<br></p><p>struct GenericBox&lt;Contents&gt; {<br>  let contents: Contents<br></p><p>  func transform&lt;Result&gt;(f: (Contents) -&gt; Result) -&gt; GenericBox&lt;Result&gt; {<br>    // If you change this to just ‘GenericBox(contents: …)’, it does not type check<br>    return GenericBox&lt;Result&gt;(contents: f(contents))<br>  }<br>}<br></p><p>func transform&lt;Contents, Result&gt;(box: GenericBox&lt;Contents&gt;,<br>                  f: (Contents) -&gt; Result) -&gt; GenericBox&lt;Result&gt; {<br>  // But this is totally fine!<br>  return GenericBox(contents: f(box.contents))<br>}<br></p><p>I suspect most people do not expect the first case to fail, and it is not immediately obvious why it fails when the second example type checks.<br></p><p>&gt; <br>&gt; Here is an example that works right now, but would not work with my proposed change:<br>&gt; <br>&gt; struct GenericBox&lt;Contents&gt; {<br>&gt; 	// Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>&gt; 	// With the new rule, we cannot infer the parameter, because there’s no expression to infer it from<br>&gt; 	func combine(other: GenericBox) {<br>&gt; 		…<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Basically the meaning of ‘GenericBox’ right now depends on whether it appears inside its own definition or extension thereof, or not. The behavior when it appears elsewhere is more general — we infer the parameters from the surrounding expression, instead of assuming they’re equal to the context parameters.<br>&gt; <br>&gt; This is a subtle change — definitely let me know if I’m not explaining it well.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt;&gt; Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br>&gt;&gt; <br>&gt;&gt; If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br>&gt;&gt; <br>&gt;&gt; For example,<br>&gt;&gt; <br>&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt;   let contents: Contents<br>&gt;&gt; <br>&gt;&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;&gt;   func clone() -&gt; GenericBox {<br>&gt;&gt;     return GenericBox(contents: contents)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension GenericBox {<br>&gt;&gt;   func print() {<br>&gt;&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;&gt;     let cloned: GenericBox = clone()<br>&gt;&gt;     print(cloned.contents)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br>&gt;&gt; <br>&gt;&gt; For example,<br>&gt;&gt; <br>&gt;&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;&gt;   return GenericBox(contents: 123)<br>&gt;&gt; }<br>&gt;&gt; The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br>&gt;&gt; <br>&gt;&gt; extension GenericBox {<br>&gt;&gt; <br>&gt;&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;&gt;     // inferring the type parameter<br>&gt;&gt;     return GenericBox(contents: f(contents))<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; This really just involves removing an existing piece of logic from the type resolver code.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status quo<br>&gt;&gt; <br>&gt;&gt; We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More complex inference of generic parameters<br>&gt;&gt; <br>&gt;&gt; We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/ab765040/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>Sorry, it&#39;s I who is saying things all wrong. I meant to ask, is it<br>feasible to keep both behaviors but have #2 &quot;win&quot; over #1, instead of<br>getting rid of behavior #1 entirely?<br></p><p>On Thu, Jun 23, 2016 at 15:30 Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p>&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; When you mention the difficulty of an alternative, is that to say that<br>&gt; it&#39;s not feasible for the GenericBox in the last example to be resolved as<br>&gt; GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most<br>&gt; sensible behavior.<br>&gt;<br>&gt;<br>&gt; With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt; in<br>&gt; the last example. Right now it fails to type check.<br>&gt;<br>&gt; Here is an example that works right now, but would not work with my<br>&gt; proposed change:<br>&gt;<br>&gt; struct GenericBox&lt;Contents&gt; {<br>&gt; // Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>&gt; // With the new rule, we cannot infer the parameter, because there’s no<br>&gt; expression to infer it from<br>&gt; func combine(other: GenericBox) {<br>&gt; …<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Basically the meaning of ‘GenericBox’ right now depends on whether it<br>&gt; appears inside its own definition or extension thereof, or not. The<br>&gt; behavior when it appears elsewhere is more general — we infer the<br>&gt; parameters from the surrounding expression, instead of assuming they’re<br>&gt; equal to the context parameters.<br>&gt;<br>&gt; This is a subtle change — definitely let me know if I’m not explaining it<br>&gt; well.<br>&gt;<br>&gt; Slava<br>&gt;<br>&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-9999<br>&gt;&gt;    &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt;&gt;    - Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal cleans up the semantics of a reference to a generic type<br>&gt;&gt; when no generic arguments are applied.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt;&gt; &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Right now, we allow a generic type to be referenced with no generic<br>&gt;&gt; arguments applied in a handful of special cases. The two primary rules here<br>&gt;&gt; are the following:<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    If the scope from which the reference is made is nested inside the<br>&gt;&gt;    definition of the type or an extension thereof, omitting generic arguments<br>&gt;&gt;    just means to implicitly apply the arguments from context.<br>&gt;&gt;<br>&gt;&gt;    For example,<br>&gt;&gt;<br>&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt;   let contents: Contents<br>&gt;&gt;<br>&gt;&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;&gt;   func clone() -&gt; GenericBox {<br>&gt;&gt;     return GenericBox(contents: contents)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; extension GenericBox {<br>&gt;&gt;   func print() {<br>&gt;&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;&gt;     let cloned: GenericBox = clone()<br>&gt;&gt;     print(cloned.contents)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    -<br>&gt;&gt;<br>&gt;&gt;    If the type is referenced from an unrelated scope, we attempt to<br>&gt;&gt;    infer the generic parameters.<br>&gt;&gt;<br>&gt;&gt;    For example,<br>&gt;&gt;<br>&gt;&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;&gt;   return GenericBox(contents: 123)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The problem appears when the user expects the second behavior, but<br>&gt;&gt; instead encounters the first. For example, the following does not type<br>&gt;&gt; check:<br>&gt;&gt;<br>&gt;&gt; extension GenericBox {<br>&gt;&gt;<br>&gt;&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;&gt;     // inferring the type parameter<br>&gt;&gt;     return GenericBox(contents: f(contents))<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; The proposed solution is to remove the first rule altogether. If the<br>&gt;&gt; generic parameters cannot be inferred from context, they must be specified<br>&gt;&gt; explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; This really just involves removing an existing piece of logic from the<br>&gt;&gt; type resolver code.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; This will have a small impact on existing code that uses a pattern<br>&gt;&gt; similar to the above.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status<br>&gt;&gt; quo<br>&gt;&gt;<br>&gt;&gt; We could keep the current behavior, but one can argue it is not very<br>&gt;&gt; useful, and adds a special case where one is not needed.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More<br>&gt;&gt; complex inference of generic parameters<br>&gt;&gt; We could attempt to unify the two rules for resolving a reference to a<br>&gt;&gt; generic type with no arguments, however this presents theoretical<br>&gt;&gt; difficulties with our constraint solver design. Even if it were easy to<br>&gt;&gt; implement, it would increase type checking type by creating new<br>&gt;&gt; possibilities to consider, with very little actual benefit.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/4122e4f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 1:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry, it&#39;s I who is saying things all wrong. I meant to ask, is it feasible to keep both behaviors but have #2 &quot;win&quot; over #1, instead of getting rid of behavior #1 entirely?<br></p><p>I suspect there might be some way, but I think it would have to be some kind of one-off hack, which is not in line with our long-term goal of making the type checker more maintainable and correct ‘by construction’.<br></p><p>&gt; <br>&gt; On Thu, Jun 23, 2016 at 15:30 Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When you mention the difficulty of an alternative, is that to say that it&#39;s not feasible for the GenericBox in the last example to be resolved as GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most sensible behavior.<br>&gt; <br>&gt; With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt; in the last example. Right now it fails to type check.<br>&gt; <br>&gt; Here is an example that works right now, but would not work with my proposed change:<br>&gt; <br>&gt; struct GenericBox&lt;Contents&gt; {<br>&gt; 	// Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>&gt; 	// With the new rule, we cannot infer the parameter, because there’s no expression to infer it from<br>&gt; 	func combine(other: GenericBox) {<br>&gt; 		…<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Basically the meaning of ‘GenericBox’ right now depends on whether it appears inside its own definition or extension thereof, or not. The behavior when it appears elsewhere is more general — we infer the parameters from the surrounding expression, instead of assuming they’re equal to the context parameters.<br>&gt; <br>&gt; This is a subtle change — definitely let me know if I’m not explaining it well.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt;&gt; Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br>&gt;&gt; <br>&gt;&gt; If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br>&gt;&gt; <br>&gt;&gt; For example,<br>&gt;&gt; <br>&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt;   let contents: Contents<br>&gt;&gt; <br>&gt;&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;&gt;   func clone() -&gt; GenericBox {<br>&gt;&gt;     return GenericBox(contents: contents)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension GenericBox {<br>&gt;&gt;   func print() {<br>&gt;&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;&gt;     let cloned: GenericBox = clone()<br>&gt;&gt;     print(cloned.contents)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br>&gt;&gt; <br>&gt;&gt; For example,<br>&gt;&gt; <br>&gt;&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;&gt;   return GenericBox(contents: 123)<br>&gt;&gt; }<br>&gt;&gt; The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br>&gt;&gt; <br>&gt;&gt; extension GenericBox {<br>&gt;&gt; <br>&gt;&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;&gt;     // inferring the type parameter<br>&gt;&gt;     return GenericBox(contents: f(contents))<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; This really just involves removing an existing piece of logic from the type resolver code.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status quo<br>&gt;&gt; <br>&gt;&gt; We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More complex inference of generic parameters<br>&gt;&gt; <br>&gt;&gt; We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/289bd9a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>Good to know. I absolutely agree that the gains to be had here wouldn&#39;t be<br>worth a one-off hack.<br>On Thu, Jun 23, 2016 at 15:36 Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p>&gt; On Jun 23, 2016, at 1:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Sorry, it&#39;s I who is saying things all wrong. I meant to ask, is it<br>&gt; feasible to keep both behaviors but have #2 &quot;win&quot; over #1, instead of<br>&gt; getting rid of behavior #1 entirely?<br>&gt;<br>&gt;<br>&gt; I suspect there might be some way, but I think it would have to be some<br>&gt; kind of one-off hack, which is not in line with our long-term goal of<br>&gt; making the type checker more maintainable and correct ‘by construction’.<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 23, 2016 at 15:30 Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; When you mention the difficulty of an alternative, is that to say that<br>&gt;&gt; it&#39;s not feasible for the GenericBox in the last example to be resolved as<br>&gt;&gt; GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most<br>&gt;&gt; sensible behavior.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt; in<br>&gt;&gt; the last example. Right now it fails to type check.<br>&gt;&gt;<br>&gt;&gt; Here is an example that works right now, but would not work with my<br>&gt;&gt; proposed change:<br>&gt;&gt;<br>&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt; // Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>&gt;&gt; // With the new rule, we cannot infer the parameter, because there’s no<br>&gt;&gt; expression to infer it from<br>&gt;&gt; func combine(other: GenericBox) {<br>&gt;&gt; …<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Basically the meaning of ‘GenericBox’ right now depends on whether it<br>&gt;&gt; appears inside its own definition or extension thereof, or not. The<br>&gt;&gt; behavior when it appears elsewhere is more general — we infer the<br>&gt;&gt; parameters from the surrounding expression, instead of assuming they’re<br>&gt;&gt; equal to the context parameters.<br>&gt;&gt;<br>&gt;&gt; This is a subtle change — definitely let me know if I’m not explaining it<br>&gt;&gt; well.<br>&gt;&gt;<br>&gt;&gt; Slava<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-9999<br>&gt;&gt;&gt;    &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt;&gt;&gt;    - Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal cleans up the semantics of a reference to a generic type<br>&gt;&gt;&gt; when no generic arguments are applied.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt;&gt;&gt; &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right now, we allow a generic type to be referenced with no generic<br>&gt;&gt;&gt; arguments applied in a handful of special cases. The two primary rules here<br>&gt;&gt;&gt; are the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    -<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    If the scope from which the reference is made is nested inside the<br>&gt;&gt;&gt;    definition of the type or an extension thereof, omitting generic arguments<br>&gt;&gt;&gt;    just means to implicitly apply the arguments from context.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    For example,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt;&gt;   let contents: Contents<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt;   func clone() -&gt; GenericBox {<br>&gt;&gt;&gt;     return GenericBox(contents: contents)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension GenericBox {<br>&gt;&gt;&gt;   func print() {<br>&gt;&gt;&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt;     let cloned: GenericBox = clone()<br>&gt;&gt;&gt;     print(cloned.contents)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    -<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    If the type is referenced from an unrelated scope, we attempt to<br>&gt;&gt;&gt;    infer the generic parameters.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    For example,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;&gt;&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;&gt;&gt;   return GenericBox(contents: 123)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The problem appears when the user expects the second behavior, but<br>&gt;&gt;&gt; instead encounters the first. For example, the following does not type<br>&gt;&gt;&gt; check:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension GenericBox {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;&gt;&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;&gt;&gt;     // inferring the type parameter<br>&gt;&gt;&gt;     return GenericBox(contents: f(contents))<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The proposed solution is to remove the first rule altogether. If the<br>&gt;&gt;&gt; generic parameters cannot be inferred from context, they must be specified<br>&gt;&gt;&gt; explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This really just involves removing an existing piece of logic from the<br>&gt;&gt;&gt; type resolver code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This will have a small impact on existing code that uses a pattern<br>&gt;&gt;&gt; similar to the above.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt; considered<br>&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status<br>&gt;&gt;&gt; quo<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We could keep the current behavior, but one can argue it is not very<br>&gt;&gt;&gt; useful, and adds a special case where one is not needed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More<br>&gt;&gt;&gt; complex inference of generic parameters<br>&gt;&gt;&gt; We could attempt to unify the two rules for resolving a reference to a<br>&gt;&gt;&gt; generic type with no arguments, however this presents theoretical<br>&gt;&gt;&gt; difficulties with our constraint solver design. Even if it were easy to<br>&gt;&gt;&gt; implement, it would increase type checking type by creating new<br>&gt;&gt;&gt; possibilities to consider, with very little actual benefit.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/7bb9ed8e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 1:39 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Good to know. I absolutely agree that the gains to be had here wouldn&#39;t be worth a one-off hack.<br></p><p>If people are strongly (or even mildly) opposed to removing this rule, we can give some thought to a more general solution. I don’t feel very strongly about this proposal one way or another, it’s just a bit of ugly code in TypeCheckType.cpp that would be nice to remove, and a developer on Twitter recently noticed this behavior and found it surprising.<br></p><p>&gt; On Thu, Jun 23, 2016 at 15:36 Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Jun 23, 2016, at 1:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, it&#39;s I who is saying things all wrong. I meant to ask, is it feasible to keep both behaviors but have #2 &quot;win&quot; over #1, instead of getting rid of behavior #1 entirely?<br>&gt; <br>&gt; I suspect there might be some way, but I think it would have to be some kind of one-off hack, which is not in line with our long-term goal of making the type checker more maintainable and correct ‘by construction’.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 23, 2016 at 15:30 Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you mention the difficulty of an alternative, is that to say that it&#39;s not feasible for the GenericBox in the last example to be resolved as GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most sensible behavior.<br>&gt;&gt; <br>&gt;&gt; With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt; in the last example. Right now it fails to type check.<br>&gt;&gt; <br>&gt;&gt; Here is an example that works right now, but would not work with my proposed change:<br>&gt;&gt; <br>&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt; 	// Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>&gt;&gt; 	// With the new rule, we cannot infer the parameter, because there’s no expression to infer it from<br>&gt;&gt; 	func combine(other: GenericBox) {<br>&gt;&gt; 		…<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Basically the meaning of ‘GenericBox’ right now depends on whether it appears inside its own definition or extension thereof, or not. The behavior when it appears elsewhere is more general — we infer the parameters from the surrounding expression, instead of assuming they’re equal to the context parameters.<br>&gt;&gt; <br>&gt;&gt; This is a subtle change — definitely let me know if I’m not explaining it well.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt;&gt;&gt; Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt;&gt;   let contents: Contents<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt;   func clone() -&gt; GenericBox {<br>&gt;&gt;&gt;     return GenericBox(contents: contents)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension GenericBox {<br>&gt;&gt;&gt;   func print() {<br>&gt;&gt;&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt;     let cloned: GenericBox = clone()<br>&gt;&gt;&gt;     print(cloned.contents)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;&gt;&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;&gt;&gt;   return GenericBox(contents: 123)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension GenericBox {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;&gt;&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;&gt;&gt;     // inferring the type parameter<br>&gt;&gt;&gt;     return GenericBox(contents: f(contents))<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This really just involves removing an existing piece of logic from the type resolver code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status quo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More complex inference of generic parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/98fb81f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 23, 2016 at 08:00:00pm</p></header><div class="content"><p>Cool--no opposition here!<br>On Thu, Jun 23, 2016 at 15:43 Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p>&gt; On Jun 23, 2016, at 1:39 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Good to know. I absolutely agree that the gains to be had here wouldn&#39;t be<br>&gt; worth a one-off hack.<br>&gt;<br>&gt;<br>&gt; If people are strongly (or even mildly) opposed to removing this rule, we<br>&gt; can give some thought to a more general solution. I don’t feel very<br>&gt; strongly about this proposal one way or another, it’s just a bit of ugly<br>&gt; code in TypeCheckType.cpp that would be nice to remove, and a developer on<br>&gt; Twitter recently noticed this behavior and found it surprising.<br>&gt;<br>&gt; On Thu, Jun 23, 2016 at 15:36 Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jun 23, 2016, at 1:34 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Sorry, it&#39;s I who is saying things all wrong. I meant to ask, is it<br>&gt;&gt; feasible to keep both behaviors but have #2 &quot;win&quot; over #1, instead of<br>&gt;&gt; getting rid of behavior #1 entirely?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I suspect there might be some way, but I think it would have to be some<br>&gt;&gt; kind of one-off hack, which is not in line with our long-term goal of<br>&gt;&gt; making the type checker more maintainable and correct ‘by construction’.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 23, 2016 at 15:30 Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When you mention the difficulty of an alternative, is that to say that<br>&gt;&gt;&gt; it&#39;s not feasible for the GenericBox in the last example to be resolved as<br>&gt;&gt;&gt; GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most<br>&gt;&gt;&gt; sensible behavior.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt;<br>&gt;&gt;&gt; in the last example. Right now it fails to type check.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here is an example that works right now, but would not work with my<br>&gt;&gt;&gt; proposed change:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt;&gt; // Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>&gt;&gt;&gt; // With the new rule, we cannot infer the parameter, because there’s no<br>&gt;&gt;&gt; expression to infer it from<br>&gt;&gt;&gt; func combine(other: GenericBox) {<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Basically the meaning of ‘GenericBox’ right now depends on whether it<br>&gt;&gt;&gt; appears inside its own definition or extension thereof, or not. The<br>&gt;&gt;&gt; behavior when it appears elsewhere is more general — we infer the<br>&gt;&gt;&gt; parameters from the surrounding expression, instead of assuming they’re<br>&gt;&gt;&gt; equal to the context parameters.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a subtle change — definitely let me know if I’m not explaining<br>&gt;&gt;&gt; it well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Slava<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Simpler interpretation of a reference to a generic type with no<br>&gt;&gt;&gt;&gt; arguments<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Proposal: SE-9999<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt;&gt;&gt;&gt;    - Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt;&gt;&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal cleans up the semantics of a reference to a generic type<br>&gt;&gt;&gt;&gt; when no generic arguments are applied.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt;&gt;&gt;&gt; &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Right now, we allow a generic type to be referenced with no generic<br>&gt;&gt;&gt;&gt; arguments applied in a handful of special cases. The two primary rules here<br>&gt;&gt;&gt;&gt; are the following:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    -<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    If the scope from which the reference is made is nested inside the<br>&gt;&gt;&gt;&gt;    definition of the type or an extension thereof, omitting generic arguments<br>&gt;&gt;&gt;&gt;    just means to implicitly apply the arguments from context.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    For example,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt;&gt;&gt;   let contents: Contents<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt;&gt;   func clone() -&gt; GenericBox {<br>&gt;&gt;&gt;&gt;     return GenericBox(contents: contents)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; extension GenericBox {<br>&gt;&gt;&gt;&gt;   func print() {<br>&gt;&gt;&gt;&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt;&gt;     let cloned: GenericBox = clone()<br>&gt;&gt;&gt;&gt;     print(cloned.contents)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    -<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    If the type is referenced from an unrelated scope, we attempt to<br>&gt;&gt;&gt;&gt;    infer the generic parameters.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    For example,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;&gt;&gt;&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;&gt;&gt;&gt;   return GenericBox(contents: 123)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The problem appears when the user expects the second behavior, but<br>&gt;&gt;&gt;&gt; instead encounters the first. For example, the following does not type<br>&gt;&gt;&gt;&gt; check:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension GenericBox {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;&gt;&gt;&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;&gt;&gt;&gt;     // inferring the type parameter<br>&gt;&gt;&gt;&gt;     return GenericBox(contents: f(contents))<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;&gt; solution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The proposed solution is to remove the first rule altogether. If the<br>&gt;&gt;&gt;&gt; generic parameters cannot be inferred from context, they must be specified<br>&gt;&gt;&gt;&gt; explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed<br>&gt;&gt;&gt;&gt; design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This really just involves removing an existing piece of logic from the<br>&gt;&gt;&gt;&gt; type resolver code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This will have a small impact on existing code that uses a pattern<br>&gt;&gt;&gt;&gt; similar to the above.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt;&gt; considered<br>&gt;&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status<br>&gt;&gt;&gt;&gt; quo<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We could keep the current behavior, but one can argue it is not very<br>&gt;&gt;&gt;&gt; useful, and adds a special case where one is not needed.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More<br>&gt;&gt;&gt;&gt; complex inference of generic parameters<br>&gt;&gt;&gt;&gt; We could attempt to unify the two rules for resolving a reference to a<br>&gt;&gt;&gt;&gt; generic type with no arguments, however this presents theoretical<br>&gt;&gt;&gt;&gt; difficulties with our constraint solver design. Even if it were easy to<br>&gt;&gt;&gt;&gt; implement, it would increase type checking type by creating new<br>&gt;&gt;&gt;&gt; possibilities to consider, with very little actual benefit.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/4ed66a3a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>So the only real downside of this is that if you don’t refer/use all of the generic types in this sort of situation, then it couldn’t figure it out? So the following wouldn’t be a problem even if rule 1 was eliminated because this actually ties other.value to self’s value and implies that other must be GenericBox&lt;Contents&gt;?<br></p><p>struct GenericBox&lt;Contents: AnyObject&gt; {<br>    let value: Contents<br>    <br>    func test(other: GenericBox) -&gt; Bool {<br>        return value === other.value<br>    }<br>}<br></p><p>I might be totally not understanding, though. :P<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 23, 2016, at 3:30 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When you mention the difficulty of an alternative, is that to say that it&#39;s not feasible for the GenericBox in the last example to be resolved as GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most sensible behavior.<br>&gt; <br>&gt; With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt; in the last example. Right now it fails to type check.<br>&gt; <br>&gt; Here is an example that works right now, but would not work with my proposed change:<br>&gt; <br>&gt; struct GenericBox&lt;Contents&gt; {<br>&gt; 	// Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>&gt; 	// With the new rule, we cannot infer the parameter, because there’s no expression to infer it from<br>&gt; 	func combine(other: GenericBox) {<br>&gt; 		…<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Basically the meaning of ‘GenericBox’ right now depends on whether it appears inside its own definition or extension thereof, or not. The behavior when it appears elsewhere is more general — we infer the parameters from the surrounding expression, instead of assuming they’re equal to the context parameters.<br>&gt; <br>&gt; This is a subtle change — definitely let me know if I’m not explaining it well.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt;&gt; <br>&gt;&gt; 	• Proposal: SE-9999<br>&gt;&gt; 	• Author: Slava Pestov<br>&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt; 	• Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br>&gt;&gt; <br>&gt;&gt; 	• If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br>&gt;&gt; <br>&gt;&gt; For example,<br>&gt;&gt; <br>&gt;&gt; struct GenericBox&lt;Contents&gt;<br>&gt;&gt;  {<br>&gt;&gt;   <br>&gt;&gt; let<br>&gt;&gt;  contents: Contents<br>&gt;&gt; <br>&gt;&gt;   <br>&gt;&gt; // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;&gt; <br>&gt;&gt;   <br>&gt;&gt; func clone() -&gt;<br>&gt;&gt;  GenericBox {<br>&gt;&gt;     <br>&gt;&gt; return<br>&gt;&gt;  GenericBox(contents: contents)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension<br>&gt;&gt;  GenericBox {<br>&gt;&gt;   <br>&gt;&gt; func print<br>&gt;&gt; () {<br>&gt;&gt;     <br>&gt;&gt; // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; let cloned: GenericBox =<br>&gt;&gt;  clone()<br>&gt;&gt;     <br>&gt;&gt; print(cloned.<br>&gt;&gt; contents)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 	• If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br>&gt;&gt; <br>&gt;&gt; For example,<br>&gt;&gt; <br>&gt;&gt; func makeABox() -&gt; GenericBox&lt;Int<br>&gt;&gt; &gt; {<br>&gt;&gt;   <br>&gt;&gt; // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;&gt; <br>&gt;&gt;   <br>&gt;&gt; return GenericBox(contents: 123<br>&gt;&gt; )<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br>&gt;&gt; <br>&gt;&gt; extension<br>&gt;&gt;  GenericBox {<br>&gt;&gt; <br>&gt;&gt;   <br>&gt;&gt; func transform&lt;T&gt;(f: Contents -&gt; T) -&gt;<br>&gt;&gt;  GenericBox&lt;T&gt; {<br>&gt;&gt;     <br>&gt;&gt; // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; // inferring the type parameter<br>&gt;&gt; <br>&gt;&gt;     <br>&gt;&gt; return<br>&gt;&gt;  GenericBox(contents: f(contents))<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; This really just involves removing an existing piece of logic from the type resolver code.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Status quo<br>&gt;&gt; <br>&gt;&gt; We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br>&gt;&gt; <br>&gt;&gt; More complex inference of generic parameters<br>&gt;&gt; <br>&gt;&gt; We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>June 23, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 23, 2016, at 1:48 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; So the only real downside of this is that if you don’t refer/use all of the generic types in this sort of situation, then it couldn’t figure it out? So the following wouldn’t be a problem even if rule 1 was eliminated because this actually ties other.value to self’s value and implies that other must be GenericBox&lt;Contents&gt;?<br>&gt; <br>&gt; struct GenericBox&lt;Contents: AnyObject&gt; {<br>&gt;    let value: Contents<br>&gt; <br>&gt;    func test(other: GenericBox) -&gt; Bool {<br>&gt;        return value === other.value<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; I might be totally not understanding, though. :P<br></p><p>This would *not* work with my proposed change. Even though we could theoretically infer that the parameter must be a GenericBox&lt;Contents&gt; to make the === type check, in practice Swift’s type checker operates at the expression level.<br></p><p>Global type inference is not something we’re considering, because of the compile-time cost, increased difficulty in producing localized diagnostics, and the loss of too much explicit type information.<br></p><p>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 23, 2016, at 3:30 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 23, 2016, at 1:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you mention the difficulty of an alternative, is that to say that it&#39;s not feasible for the GenericBox in the last example to be resolved as GenericBox&lt;T&gt;? From an end-user point of view, that seems to be the most sensible behavior.<br>&gt;&gt; <br>&gt;&gt; With my proposed change, GenericBox would be resolved as GenericBox&lt;T&gt; in the last example. Right now it fails to type check.<br>&gt;&gt; <br>&gt;&gt; Here is an example that works right now, but would not work with my proposed change:<br>&gt;&gt; <br>&gt;&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;&gt; 	// Currently Swift resolves this as ‘GenericBox&lt;Contents&gt;’<br>&gt;&gt; 	// With the new rule, we cannot infer the parameter, because there’s no expression to infer it from<br>&gt;&gt; 	func combine(other: GenericBox) {<br>&gt;&gt; 		…<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Basically the meaning of ‘GenericBox’ right now depends on whether it appears inside its own definition or extension thereof, or not. The behavior when it appears elsewhere is more general — we infer the parameters from the surrounding expression, instead of assuming they’re equal to the context parameters.<br>&gt;&gt; <br>&gt;&gt; This is a subtle change — definitely let me know if I’m not explaining it well.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 23, 2016 at 15:14 Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• Proposal: SE-9999<br>&gt;&gt;&gt; 	• Author: Slava Pestov<br>&gt;&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt;&gt; 	• Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let<br>&gt;&gt;&gt; contents: Contents<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func clone() -&gt;<br>&gt;&gt;&gt; GenericBox {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return<br>&gt;&gt;&gt; GenericBox(contents: contents)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension<br>&gt;&gt;&gt; GenericBox {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func print<br>&gt;&gt;&gt; () {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let cloned: GenericBox =<br>&gt;&gt;&gt; clone()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(cloned.<br>&gt;&gt;&gt; contents)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeABox() -&gt; GenericBox&lt;Int<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return GenericBox(contents: 123<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension<br>&gt;&gt;&gt; GenericBox {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func transform&lt;T&gt;(f: Contents -&gt; T) -&gt;<br>&gt;&gt;&gt; GenericBox&lt;T&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // inferring the type parameter<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return<br>&gt;&gt;&gt; GenericBox(contents: f(contents))<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This really just involves removing an existing piece of logic from the type resolver code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Status quo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More complex inference of generic parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 23, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 again.  Thanks for ferreting out these surprising behaviors Slava!<br></p><p>I did not realize the shorthand you propose to remove was possible (is this documented anywhere?).  On the other hand, I make use of the inference that does not work correctly in the “broken” example all the time.  <br></p><p>This is another one that would have been pretty confusing to me had I run into it.  I don’t believe there is any other context where explicit type arguments are required in a type context where they should be inferred.  Fixing this is really important.<br></p><p>I think a reasonably strong argument can be made to remove the first behavior even without this conflict.  I really like Swift’s approach of making type information explicit in signatures.  Allowing it to be inferred in an obscure corner case violates that principle.  <br></p><p>I also think it is reasonable to require the programmer to state all type information explicitly when it isn’t inferred.  This makes the code more clear to a reader.  Type information is either stated or not stated, never partially stated (requiring the programmer to remember what pieces are inferred as well as when partial inference is possible and when it is not possible).<br></p><p>It’s also worth noting that in one of your clone example the whole type could be inferred:<br></p><p>let cloned = clone()<br></p><p><br>&gt; On Jun 23, 2016, at 3:14 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt; <br>&gt; Proposal: SE-9999 &lt;https://github.com/slavapestov/swift-evolution/blob/silly-proposals/proposals/9999-simplify-unbound-generic-type.md&gt;<br>&gt; Author: Slava Pestov &lt;https://github.com/slavapestov&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#motivation&gt;Motivation<br>&gt; <br>&gt; Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br>&gt; <br>&gt; If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br>&gt; <br>&gt; For example,<br>&gt; <br>&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;   let contents: Contents<br>&gt; <br>&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;   func clone() -&gt; GenericBox {<br>&gt;     return GenericBox(contents: contents)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension GenericBox {<br>&gt;   func print() {<br>&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;     let cloned: GenericBox = clone()<br>&gt;     print(cloned.contents)<br>&gt;   }<br>&gt; }<br>&gt; If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br>&gt; <br>&gt; For example,<br>&gt; <br>&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;   return GenericBox(contents: 123)<br>&gt; }<br>&gt; The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br>&gt; <br>&gt; extension GenericBox {<br>&gt; <br>&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;     // inferring the type parameter<br>&gt;     return GenericBox(contents: f(contents))<br>&gt;   }<br>&gt; }<br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#detailed-design&gt;Detailed design<br>&gt; <br>&gt; This really just involves removing an existing piece of logic from the type resolver code.<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#status-quo&gt;Status quo<br>&gt; <br>&gt; We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br>&gt; <br>&gt;  &lt;https://github.com/slavapestov/swift-evolution/tree/silly-proposals/proposals#more-complex-inference-of-generic-parameters&gt;More complex inference of generic parameters<br>&gt; <br>&gt; We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160623/637938e4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Simpler interpretation of a reference to a generic type with no arguments</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 24, 2016 at 12:00:00am</p></header><div class="content"><p>This sounds good to me. I added the first rule a very long time ago (based on C++&#39;s injected-class-name rules) because I felt it eliminated boilerplate, but it&#39;s caused too much confusion to be worth it. Thanks for working on this!<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jun 23, 2016, at 1:14 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Simpler interpretation of a reference to a generic type with no arguments<br>&gt; Proposal: SE-9999<br>&gt; Author: Slava Pestov<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal cleans up the semantics of a reference to a generic type when no generic arguments are applied.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Right now, we allow a generic type to be referenced with no generic arguments applied in a handful of special cases. The two primary rules here are the following:<br>&gt; <br>&gt; If the scope from which the reference is made is nested inside the definition of the type or an extension thereof, omitting generic arguments just means to implicitly apply the arguments from context.<br>&gt; <br>&gt; For example,<br>&gt; <br>&gt; struct GenericBox&lt;Contents&gt; {<br>&gt;   let contents: Contents<br>&gt; <br>&gt;   // Equivalent to: func clone() -&gt; GenericBox&lt;Contents&gt;<br>&gt;   func clone() -&gt; GenericBox {<br>&gt;     return GenericBox(contents: contents)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension GenericBox {<br>&gt;   func print() {<br>&gt;     // Equivalent to: let cloned: GenericBox&lt;Contents&gt;<br>&gt;     let cloned: GenericBox = clone()<br>&gt;     print(cloned.contents)<br>&gt;   }<br>&gt; }<br>&gt; If the type is referenced from an unrelated scope, we attempt to infer the generic parameters.<br>&gt; <br>&gt; For example,<br>&gt; <br>&gt; func makeABox() -&gt; GenericBox&lt;Int&gt; {<br>&gt;   // Equivalent to: GenericBox&lt;Int&gt;(contents: 123)<br>&gt;   return GenericBox(contents: 123)<br>&gt; }<br>&gt; The problem appears when the user expects the second behavior, but instead encounters the first. For example, the following does not type check:<br>&gt; <br>&gt; extension GenericBox {<br>&gt; <br>&gt;   func transform&lt;T&gt;(f: Contents -&gt; T) -&gt; GenericBox&lt;T&gt; {<br>&gt;     // We resolve &#39;GenericBox&#39; as &#39;GenericBox&lt;Contents&gt;&#39;, rather than<br>&gt;     // inferring the type parameter<br>&gt;     return GenericBox(contents: f(contents))<br>&gt;   }<br>&gt; }<br>&gt; Proposed solution<br>&gt; <br>&gt; The proposed solution is to remove the first rule altogether. If the generic parameters cannot be inferred from context, they must be specified explicitly with the usual Type&lt;Args...&gt; syntax.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; This really just involves removing an existing piece of logic from the type resolver code.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This will have a small impact on existing code that uses a pattern similar to the above.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Status quo<br>&gt; <br>&gt; We could keep the current behavior, but one can argue it is not very useful, and adds a special case where one is not needed.<br>&gt; <br>&gt; More complex inference of generic parameters<br>&gt; <br>&gt; We could attempt to unify the two rules for resolving a reference to a generic type with no arguments, however this presents theoretical difficulties with our constraint solver design. Even if it were easy to implement, it would increase type checking type by creating new possibilities to consider, with very little actual benefit.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/68059589/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
