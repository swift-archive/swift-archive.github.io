<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 27, 2015 at 09:00:00pm</p></header><div class="content"><p>Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br></p><p> object.do_something()<br> object.do_somethind_else()<br> object.prop1 = value<br></p><p>becomes<br></p><p> do with object // or with object do<br> {<br>   do_something()<br>   do_somethind_else()<br>   prop1 = value<br> }<br></p><p>Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self. <br></p><p>The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self). <br></p><p>Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit <br></p><p>   do with self {}<br></p><p>Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it. <br></p><p>If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list. <br></p><p>Best, <br></p><p> Taras<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0b06da9d5d4edede8590235c6dcae64?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Radosław Smogura</string> &lt;rsmogura at icloud.com&gt;<p>December 27, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>That’s a great idea!<br></p><p>Kind regards,<br>Radek<br></p><p>&gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt; <br>&gt; object.do_something()<br>&gt; object.do_somethind_else()<br>&gt; object.prop1 = value<br>&gt; <br>&gt; becomes<br>&gt; <br>&gt; do with object // or with object do<br>&gt; {<br>&gt;   do_something()<br>&gt;   do_somethind_else()<br>&gt;   prop1 = value<br>&gt; }<br>&gt; <br>&gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self. <br>&gt; <br>&gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self). <br>&gt; <br>&gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit <br>&gt; <br>&gt;   do with self {}<br>&gt; <br>&gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it. <br>&gt; <br>&gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt; Taras<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc1547c759126cd0e2466a3f783da32b?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Mosab Elagha</string> &lt;mosabelagha at gmail.com&gt;<p>December 27, 2015 at 03:00:00pm</p></header><div class="content"><p>Agreed, this seems like a great idea. Looks like it would also allow for a<br>lot of customization - for example out of one &quot;template&quot; object.<br></p><p>Would the object have to already be initialized or could you initialize it<br>from this? IMO it would have to already be initialized or else it might<br>lead to confusion.<br></p><p>Also, would this be limited to instance methods?<br></p><p>-Mosab Elagha<br></p><p>On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org<br>&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; That’s a great idea!<br>&gt;<br>&gt; Kind regards,<br>&gt; Radek<br>&gt;<br>&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Quite often, one needs to perform a number of operations on a single<br>&gt; object (e.g. call up a bunch of configuration or action methods). This<br>&gt; proposal is to extend the ‘do&#39; statement  with an explicit lexical scope<br>&gt; feature. For instance, this piece of code<br>&gt; &gt;<br>&gt; &gt; object.do_something()<br>&gt; &gt; object.do_somethind_else()<br>&gt; &gt; object.prop1 = value<br>&gt; &gt;<br>&gt; &gt; becomes<br>&gt; &gt;<br>&gt; &gt; do with object // or with object do<br>&gt; &gt; {<br>&gt; &gt;   do_something()<br>&gt; &gt;   do_somethind_else()<br>&gt; &gt;   prop1 = value<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Essentially, this construct would introduce a level of lexical scope —<br>&gt; explicitly controlled by the programmer, in addition to the implicit scope<br>&gt; dictated by statement blocks, closures and self.<br>&gt; &gt;<br>&gt; &gt; The advantage of this construct is that it allows one to remove<br>&gt; boilerplate code for initialisation/configuration as well as adds clear<br>&gt; logical separation to the code. Disadvantage is potential shadowing of<br>&gt; identifiers in the scope, but this should to be a big issue because the<br>&gt; syntax is explicit rather then implicit, meaning that its the programmers<br>&gt; job to make sure that no shadowing occurs (btw, compiler could warn about<br>&gt; shadowing). The additions to the language syntax is minimal and the<br>&gt; implementation should be straightforward (its essentially the same logic as<br>&gt; for self).<br>&gt; &gt;<br>&gt; &gt; Note that this proposal is close to the discussion about popular the<br>&gt; implicit self on this mailing list. A body of any method could be<br>&gt; understood as wrapped into an implicit<br>&gt; &gt;<br>&gt; &gt;   do with self {}<br>&gt; &gt;<br>&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea<br>&gt; if Wirth was inspired by some other feature or not here) and is also<br>&gt; present in a bunch of languages that have dynamic scope. Personally, I use<br>&gt; it all the time in R and I am loving it.<br>&gt; &gt;<br>&gt; &gt; If the community thinks this could be a nice addition to the language, I<br>&gt; am ready to draft a proposal. Also, apologies if this has been suggested<br>&gt; before — it is impossible to keep up with this list.<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt;<br>&gt; &gt; Taras<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/5cfb67c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 27, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On 27 Dec 2015, at 21:55, Mosab Elagha &lt;mosabelagha at gmail.com&gt; wrote:<br>&gt; <br>&gt; Agreed, this seems like a great idea. Looks like it would also allow for a lot of customization - for example out of one &quot;template&quot; object.<br>&gt; <br>&gt; Would the object have to already be initialized or could you initialize it from this? IMO it would have to already be initialized or else it might lead to confusion.<br></p><p>The object could be any kind of valid Swift entity that has members (where you would usually use . to access them): object instance, type, struct etc. I can also imagine combining it with assignment, e.g. instead of <br></p><p>let obj = MyClass()<br>do with obj {<br>  prop1 = v1<br>  setup2()<br>}<br></p><p>a combined assignment form such as <br></p><p>do with let obj = MyClass() {<br>  prop1 = v1<br>  setup2()<br>}<br></p><p>But this clashes with optional binding, so it might be not a good idea. <br></p><p>&gt; Also, would this be limited to instance methods?<br></p><p>Anything you can access with the dot notation. <br></p><p>&gt; <br>&gt; -Mosab Elagha<br>&gt; <br>&gt; On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; That’s a great idea!<br>&gt; <br>&gt; Kind regards,<br>&gt; Radek<br>&gt; <br>&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt; &gt;<br>&gt; &gt; object.do_something()<br>&gt; &gt; object.do_somethind_else()<br>&gt; &gt; object.prop1 = value<br>&gt; &gt;<br>&gt; &gt; becomes<br>&gt; &gt;<br>&gt; &gt; do with object // or with object do<br>&gt; &gt; {<br>&gt; &gt;   do_something()<br>&gt; &gt;   do_somethind_else()<br>&gt; &gt;   prop1 = value<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self.<br>&gt; &gt;<br>&gt; &gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self).<br>&gt; &gt;<br>&gt; &gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit<br>&gt; &gt;<br>&gt; &gt;   do with self {}<br>&gt; &gt;<br>&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it.<br>&gt; &gt;<br>&gt; &gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list.<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt;<br>&gt; &gt; Taras<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/9d238a43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0b06da9d5d4edede8590235c6dcae64?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Radosław Smogura</string> &lt;rsmogura at icloud.com&gt;<p>December 27, 2015 at 10:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>Please find my comment in body:<br></p><p>BR,<br>Radek Smogura<br>&gt; On 27 Dec 2015, at 22:08, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Dec 2015, at 21:55, Mosab Elagha &lt;mosabelagha at gmail.com &lt;mailto:mosabelagha at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Agreed, this seems like a great idea. Looks like it would also allow for a lot of customization - for example out of one &quot;template&quot; object.<br>&gt;&gt; <br>&gt;&gt; Would the object have to already be initialized or could you initialize it from this? IMO it would have to already be initialized or else it might lead to confusion.<br>&gt; <br>&gt; The object could be any kind of valid Swift entity that has members (where you would usually use . to access them): object instance, type, struct etc. I can also imagine combining it with assignment, e.g. instead of <br>&gt; <br>&gt; let obj = MyClass()<br>&gt; do with obj {<br>&gt;   prop1 = v1<br>&gt;   setup2()<br>&gt; }<br>&gt; <br>&gt; a combined assignment form such as <br>&gt; <br>&gt; do with let obj = MyClass() {<br>&gt;   prop1 = v1<br>&gt;   setup2()<br>&gt; }<br>I think in this case it’s important to define scope of obj - it should be only “do with”, not the the outer one?<br></p><p>&gt; But this clashes with optional binding, so it might be not a good idea. <br>&gt; <br>&gt;&gt; Also, would this be limited to instance methods?<br>&gt; <br>&gt; Anything you can access with the dot notation. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Mosab Elagha<br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; That’s a great idea!<br>&gt;&gt; <br>&gt;&gt; Kind regards,<br>&gt;&gt; Radek<br>&gt;&gt; <br>&gt;&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; object.do_something()<br>&gt;&gt; &gt; object.do_somethind_else()<br>&gt;&gt; &gt; object.prop1 = value<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; becomes<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; do with object // or with object do<br>&gt;&gt; &gt; {<br>&gt;&gt; &gt;   do_something()<br>&gt;&gt; &gt;   do_somethind_else()<br>&gt;&gt; &gt;   prop1 = value<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   do with self {}<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Best,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Taras<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/b3279c0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 27, 2015 at 03:00:00pm</p></header><div class="content"><p>I believe this has popped up on-list a few times. Search for method cascades:<br></p><p>cascading site:https://lists.swift.org/pipermail/swift-evolution/<br></p><p>https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F<br></p><p>Other search terms include dart, initializers, &quot;..&quot; (although that may be hard to look for)<br></p><p>-- E<br></p><p><br>&gt; On Dec 27, 2015, at 2:34 PM, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Please find my comment in body:<br>&gt; <br>&gt; BR,<br>&gt; Radek Smogura<br>&gt;&gt; On 27 Dec 2015, at 22:08, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Dec 2015, at 21:55, Mosab Elagha &lt;mosabelagha at gmail.com &lt;mailto:mosabelagha at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agreed, this seems like a great idea. Looks like it would also allow for a lot of customization - for example out of one &quot;template&quot; object.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would the object have to already be initialized or could you initialize it from this? IMO it would have to already be initialized or else it might lead to confusion.<br>&gt;&gt; <br>&gt;&gt; The object could be any kind of valid Swift entity that has members (where you would usually use . to access them): object instance, type, struct etc. I can also imagine combining it with assignment, e.g. instead of <br>&gt;&gt; <br>&gt;&gt; let obj = MyClass()<br>&gt;&gt; do with obj {<br>&gt;&gt;   prop1 = v1<br>&gt;&gt;   setup2()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; a combined assignment form such as <br>&gt;&gt; <br>&gt;&gt; do with let obj = MyClass() {<br>&gt;&gt;   prop1 = v1<br>&gt;&gt;   setup2()<br>&gt;&gt; }<br>&gt; I think in this case it’s important to define scope of obj - it should be only “do with”, not the the outer one?<br>&gt; <br>&gt;&gt; But this clashes with optional binding, so it might be not a good idea. <br>&gt;&gt; <br>&gt;&gt;&gt; Also, would this be limited to instance methods?<br>&gt;&gt; <br>&gt;&gt; Anything you can access with the dot notation. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Mosab Elagha<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s a great idea!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt; Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; object.do_something()<br>&gt;&gt;&gt; &gt; object.do_somethind_else()<br>&gt;&gt;&gt; &gt; object.prop1 = value<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; becomes<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; do with object // or with object do<br>&gt;&gt;&gt; &gt; {<br>&gt;&gt;&gt; &gt;   do_something()<br>&gt;&gt;&gt; &gt;   do_somethind_else()<br>&gt;&gt;&gt; &gt;   prop1 = value<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;   do with self {}<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Best,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Taras<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/019e0b6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 28, 2015 at 12:00:00pm</p></header><div class="content"><p>-1 doesn&#39;t seem worth adding it is not a lot of trouble to type `obj.` at the start of every line.  Also if an API is intended to be used like that its methods would return `self` and it would be used in a FLUENT style.<br></p><p>Sent from my iPad<br></p><p>&gt; On 28 Dec 2015, at 9:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe this has popped up on-list a few times. Search for method cascades:<br>&gt; <br>&gt; cascading site:https://lists.swift.org/pipermail/swift-evolution/<br>&gt; <br>&gt; https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F<br>&gt; <br>&gt; Other search terms include dart, initializers, &quot;..&quot; (although that may be hard to look for)<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 2:34 PM, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Please find my comment in body:<br>&gt;&gt; <br>&gt;&gt; BR,<br>&gt;&gt; Radek Smogura<br>&gt;&gt;&gt;&gt; On 27 Dec 2015, at 22:08, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Dec 2015, at 21:55, Mosab Elagha &lt;mosabelagha at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed, this seems like a great idea. Looks like it would also allow for a lot of customization - for example out of one &quot;template&quot; object.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would the object have to already be initialized or could you initialize it from this? IMO it would have to already be initialized or else it might lead to confusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The object could be any kind of valid Swift entity that has members (where you would usually use . to access them): object instance, type, struct etc. I can also imagine combining it with assignment, e.g. instead of <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let obj = MyClass()<br>&gt;&gt;&gt; do with obj {<br>&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a combined assignment form such as <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; do with let obj = MyClass() {<br>&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt; }<br>&gt;&gt; I think in this case it’s important to define scope of obj - it should be only “do with”, not the the outer one?<br>&gt;&gt; <br>&gt;&gt;&gt; But this clashes with optional binding, so it might be not a good idea. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, would this be limited to instance methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anything you can access with the dot notation. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Mosab Elagha<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s a great idea!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt;&gt;&gt; Radek<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; object.do_something()<br>&gt;&gt;&gt;&gt;&gt; &gt; object.do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt; &gt; object.prop1 = value<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; becomes<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; do with object // or with object do<br>&gt;&gt;&gt;&gt;&gt; &gt; {<br>&gt;&gt;&gt;&gt;&gt; &gt;   do_something()<br>&gt;&gt;&gt;&gt;&gt; &gt;   do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt; &gt;   prop1 = value<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;   do with self {}<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Best,<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Taras<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/e5d08be5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 27, 2015 at 06:00:00pm</p></header><div class="content"><p>The most common use-case for this is with Cocoa classes, which are not set up for fluent implementation.  A preliminary proposal (which I am not updating since the matter was referred to the bug report system) is here: https://gist.github.com/erica/6794d48d917e2084d6ed Hopefully it explains the reason this would add to the Apple development ecosystem. The bug report is here: https://bugs.swift.org/browse/SR-160<br></p><p>-- E<br></p><p><br>&gt; On Dec 27, 2015, at 6:24 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; -1 doesn&#39;t seem worth adding it is not a lot of trouble to type `obj.` at the start of every line.  Also if an API is intended to be used like that its methods would return `self` and it would be used in a FLUENT style.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 28 Dec 2015, at 9:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I believe this has popped up on-list a few times. Search for method cascades:<br>&gt;&gt; <br>&gt;&gt; cascading site:https://lists.swift.org/pipermail/swift-evolution/ &lt;http://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt; <br>&gt;&gt; https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F &lt;https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F&gt;<br>&gt;&gt; <br>&gt;&gt; Other search terms include dart, initializers, &quot;..&quot; (although that may be hard to look for)<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 2:34 PM, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please find my comment in body:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; BR,<br>&gt;&gt;&gt; Radek Smogura<br>&gt;&gt;&gt;&gt; On 27 Dec 2015, at 22:08, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Dec 2015, at 21:55, Mosab Elagha &lt;mosabelagha at gmail.com &lt;mailto:mosabelagha at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Agreed, this seems like a great idea. Looks like it would also allow for a lot of customization - for example out of one &quot;template&quot; object.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would the object have to already be initialized or could you initialize it from this? IMO it would have to already be initialized or else it might lead to confusion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The object could be any kind of valid Swift entity that has members (where you would usually use . to access them): object instance, type, struct etc. I can also imagine combining it with assignment, e.g. instead of <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let obj = MyClass()<br>&gt;&gt;&gt;&gt; do with obj {<br>&gt;&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a combined assignment form such as <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do with let obj = MyClass() {<br>&gt;&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; I think in this case it’s important to define scope of obj - it should be only “do with”, not the the outer one?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But this clashes with optional binding, so it might be not a good idea. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, would this be limited to instance methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anything you can access with the dot notation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Mosab Elagha<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s a great idea!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt;&gt;&gt; Radek<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; object.do_something()<br>&gt;&gt;&gt;&gt;&gt; &gt; object.do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt; &gt; object.prop1 = value<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; becomes<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; do with object // or with object do<br>&gt;&gt;&gt;&gt;&gt; &gt; {<br>&gt;&gt;&gt;&gt;&gt; &gt;   do_something()<br>&gt;&gt;&gt;&gt;&gt; &gt;   do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt; &gt;   prop1 = value<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;   do with self {}<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Best,<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Taras<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/338570eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 28, 2015 at 04:00:00am</p></header><div class="content"><p>Ah, thank you for pointing this out! I think I would suggest a change or two to your proposal, but I need to flesh them out first. Is it possible to leave comments on the bug site? BTW, why was it delegated to the bug report system in the first place? <br></p><p><br>&gt; On 28 Dec 2015, at 02:28, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The most common use-case for this is with Cocoa classes, which are not set up for fluent implementation.  A preliminary proposal (which I am not updating since the matter was referred to the bug report system) is here: https://gist.github.com/erica/6794d48d917e2084d6ed &lt;https://gist.github.com/erica/6794d48d917e2084d6ed&gt; Hopefully it explains the reason this would add to the Apple development ecosystem. The bug report is here: https://bugs.swift.org/browse/SR-160 &lt;https://bugs.swift.org/browse/SR-160&gt;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 6:24 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 doesn&#39;t seem worth adding it is not a lot of trouble to type `obj.` at the start of every line.  Also if an API is intended to be used like that its methods would return `self` and it would be used in a FLUENT style.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On 28 Dec 2015, at 9:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I believe this has popped up on-list a few times. Search for method cascades:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; cascading site:https://lists.swift.org/pipermail/swift-evolution/ &lt;http://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F &lt;https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other search terms include dart, initializers, &quot;..&quot; (although that may be hard to look for)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 27, 2015, at 2:34 PM, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please find my comment in body:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; BR,<br>&gt;&gt;&gt;&gt; Radek Smogura<br>&gt;&gt;&gt;&gt;&gt; On 27 Dec 2015, at 22:08, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 27 Dec 2015, at 21:55, Mosab Elagha &lt;mosabelagha at gmail.com &lt;mailto:mosabelagha at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Agreed, this seems like a great idea. Looks like it would also allow for a lot of customization - for example out of one &quot;template&quot; object.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Would the object have to already be initialized or could you initialize it from this? IMO it would have to already be initialized or else it might lead to confusion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The object could be any kind of valid Swift entity that has members (where you would usually use . to access them): object instance, type, struct etc. I can also imagine combining it with assignment, e.g. instead of <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let obj = MyClass()<br>&gt;&gt;&gt;&gt;&gt; do with obj {<br>&gt;&gt;&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a combined assignment form such as <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; do with let obj = MyClass() {<br>&gt;&gt;&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; I think in this case it’s important to define scope of obj - it should be only “do with”, not the the outer one?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But this clashes with optional binding, so it might be not a good idea. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Also, would this be limited to instance methods?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anything you can access with the dot notation. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Mosab Elagha<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s a great idea!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; Radek<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; object.do_something()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; object.do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; object.prop1 = value<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; becomes<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; do with object // or with object do<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   do_something()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   prop1 = value<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   do with self {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Taras<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/89dff033/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7b4f0271043628eecd950f1e3cdd1a84?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at googlemail.com&gt;<p>December 28, 2015 at 04:00:00am</p></header><div class="content"><p>Ah, thank you for pointing this out! I think I would suggest a change or two to your proposal, but I need to flesh them out first. Is it possible to leave comments on the bug site? BTW, why was it delegated to the bug report system in the first place? <br></p><p><br></p><p>&gt; On 28 Dec 2015, at 02:28, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The most common use-case for this is with Cocoa classes, which are not set up for fluent implementation.  A preliminary proposal (which I am not updating since the matter was referred to the bug report system) is here: https://gist.github.com/erica/6794d48d917e2084d6ed &lt;https://gist.github.com/erica/6794d48d917e2084d6ed&gt; Hopefully it explains the reason this would add to the Apple development ecosystem. The bug report is here: https://bugs.swift.org/browse/SR-160 &lt;https://bugs.swift.org/browse/SR-160&gt;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 6:24 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 doesn&#39;t seem worth adding it is not a lot of trouble to type `obj.` at the start of every line.  Also if an API is intended to be used like that its methods would return `self` and it would be used in a FLUENT style.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On 28 Dec 2015, at 9:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I believe this has popped up on-list a few times. Search for method cascades:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; cascading site:https://lists.swift.org/pipermail/swift-evolution/ &lt;http://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F &lt;https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other search terms include dart, initializers, &quot;..&quot; (although that may be hard to look for)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 27, 2015, at 2:34 PM, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please find my comment in body:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; BR,<br>&gt;&gt;&gt;&gt; Radek Smogura<br>&gt;&gt;&gt;&gt;&gt; On 27 Dec 2015, at 22:08, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 27 Dec 2015, at 21:55, Mosab Elagha &lt;mosabelagha at gmail.com &lt;mailto:mosabelagha at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Agreed, this seems like a great idea. Looks like it would also allow for a lot of customization - for example out of one &quot;template&quot; object.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Would the object have to already be initialized or could you initialize it from this? IMO it would have to already be initialized or else it might lead to confusion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The object could be any kind of valid Swift entity that has members (where you would usually use . to access them): object instance, type, struct etc. I can also imagine combining it with assignment, e.g. instead of <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let obj = MyClass()<br>&gt;&gt;&gt;&gt;&gt; do with obj {<br>&gt;&gt;&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a combined assignment form such as <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; do with let obj = MyClass() {<br>&gt;&gt;&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; I think in this case it’s important to define scope of obj - it should be only “do with”, not the the outer one?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But this clashes with optional binding, so it might be not a good idea. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Also, would this be limited to instance methods?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anything you can access with the dot notation. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Mosab Elagha<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s a great idea!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; Radek<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; object.do_something()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; object.do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; object.prop1 = value<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; becomes<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; do with object // or with object do<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   do_something()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   prop1 = value<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;   do with self {}<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Taras<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/738d68df/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 28, 2015 at 04:00:00am</p></header><div class="content"><p>Same is true for the implicit self, and yet we’ve seen how people react to making self explicit. There are many places in contemporary Apple programming where this could be of great utility. For instance, I miss a lexical scope construction every time I work with Metal. <br></p><p><br>&gt; On 28 Dec 2015, at 02:24, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1 doesn&#39;t seem worth adding it is not a lot of trouble to type `obj.` at the start of every line.  Also if an API is intended to be used like that its methods would return `self` and it would be used in a FLUENT style.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 28 Dec 2015, at 9:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I believe this has popped up on-list a few times. Search for method cascades:<br>&gt;&gt; <br>&gt;&gt; cascading site:https://lists.swift.org/pipermail/swift-evolution/ &lt;http://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt; <br>&gt;&gt; https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F &lt;https://www.google.com/?gws_rd=ssl#q=cascading+site:https:%2F%2Flists.swift.org%2Fpipermail%2Fswift-evolution%2F&gt;<br>&gt;&gt; <br>&gt;&gt; Other search terms include dart, initializers, &quot;..&quot; (although that may be hard to look for)<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 2:34 PM, Radosław Smogura via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please find my comment in body:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; BR,<br>&gt;&gt;&gt; Radek Smogura<br>&gt;&gt;&gt;&gt; On 27 Dec 2015, at 22:08, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Dec 2015, at 21:55, Mosab Elagha &lt;mosabelagha at gmail.com &lt;mailto:mosabelagha at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Agreed, this seems like a great idea. Looks like it would also allow for a lot of customization - for example out of one &quot;template&quot; object.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would the object have to already be initialized or could you initialize it from this? IMO it would have to already be initialized or else it might lead to confusion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The object could be any kind of valid Swift entity that has members (where you would usually use . to access them): object instance, type, struct etc. I can also imagine combining it with assignment, e.g. instead of <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let obj = MyClass()<br>&gt;&gt;&gt;&gt; do with obj {<br>&gt;&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a combined assignment form such as <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; do with let obj = MyClass() {<br>&gt;&gt;&gt;&gt;   prop1 = v1<br>&gt;&gt;&gt;&gt;   setup2()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; I think in this case it’s important to define scope of obj - it should be only “do with”, not the the outer one?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But this clashes with optional binding, so it might be not a good idea. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, would this be limited to instance methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anything you can access with the dot notation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Mosab Elagha<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Dec 27, 2015 at 3:13 PM, Radosław Smogura &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s a great idea!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt;&gt;&gt; Radek<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On 27 Dec 2015, at 21:10, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Quite often, one needs to perform a number of operations on a single object (e.g. call up a bunch of configuration or action methods). This proposal is to extend the ‘do&#39; statement  with an explicit lexical scope feature. For instance, this piece of code<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; object.do_something()<br>&gt;&gt;&gt;&gt;&gt; &gt; object.do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt; &gt; object.prop1 = value<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; becomes<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; do with object // or with object do<br>&gt;&gt;&gt;&gt;&gt; &gt; {<br>&gt;&gt;&gt;&gt;&gt; &gt;   do_something()<br>&gt;&gt;&gt;&gt;&gt; &gt;   do_somethind_else()<br>&gt;&gt;&gt;&gt;&gt; &gt;   prop1 = value<br>&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Essentially, this construct would introduce a level of lexical scope — explicitly controlled by the programmer, in addition to the implicit scope dictated by statement blocks, closures and self.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The advantage of this construct is that it allows one to remove boilerplate code for initialisation/configuration as well as adds clear logical separation to the code. Disadvantage is potential shadowing of identifiers in the scope, but this should to be a big issue because the syntax is explicit rather then implicit, meaning that its the programmers job to make sure that no shadowing occurs (btw, compiler could warn about shadowing). The additions to the language syntax is minimal and the implementation should be straightforward (its essentially the same logic as for self).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Note that this proposal is close to the discussion about popular the implicit self on this mailing list. A body of any method could be understood as wrapped into an implicit<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;   do with self {}<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Finally, this construct exists in a very similar form in Pascal (no idea if Wirth was inspired by some other feature or not here) and is also present in a bunch of languages that have dynamic scope. Personally, I use it all the time in R and I am loving it.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; If the community thinks this could be a nice addition to the language, I am ready to draft a proposal. Also, apologies if this has been suggested before — it is impossible to keep up with this list.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Best,<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Taras<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/1a0c796c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Lexical scope statement (with .. do)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; method cascades<br>I thought there was some sort of showstopper that ended further discussion for Swift 3 — but seems it wasn&#39;t the fault of the archive that I didn&#39;t find that reason ;-)<br></p><p>I&#39;ll use the opportunity to talk about my major motivation to want cascades in Swift:<br>Several years ago, I was quite bored by Objective-C and did an inquiry what other languages I might like.<br>I considered exotic choices like Vala (reference counted, compiled), but despite my dislike for garbage-collected systems, I also looked at the JVM.<br>At that time, my feeling was that many people were deeply impressed by some goodies Groovy had to offer, but didn&#39;t want to give up the benefits of type safety.<br>One of the major selling point for a nice contender called &quot;Kotlin&quot; has been &quot;type safe, Groovy-style builders&quot;, and their use case might become very important for Swift as well.<br></p><p>I&#39;ll just show an example:<br>let page = HTML().{<br>  body.{<br>    table.{<br>      tr.{<br>        td.text(&quot;Cell content&quot;)<br>        td.text(&quot;Another cell&quot;)<br>      }<br>    }<br>    div(color: .redColor()).text(&quot;Some text&quot;)<br>  }<br>}<br></p><p>// basic principle: directly start a method cascade on computed properties<br></p><p>This piece of code (I&#39;m not using the proposed &quot;with&quot;-syntax but a light-weight alternative that I&#39;d prefer) could generate a complete HTML-page, ready to be send to a browser — and the syntax is much easier than the generated markup itself!<br></p><p>With Swift on Linux, I&#39;m quite sure generating HTML will become a very important task for the language.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/1f8b907d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
