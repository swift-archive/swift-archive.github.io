<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0052: Change IteratorType post-nil guarantee&quot; begins now and runs through May 3. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; The review of &quot;SE-0052: Change IteratorType post-nil guarantee&quot; begins now and runs through May 3. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md<br></p><p><br>• What is your evaluation of the proposal?<br></p><p>I&#39;m -1.<br></p><p>I agree with Patrick Pijnappel that it is too easy to write code that assumes that iterators end with nil for good, and breaks when this assumption happens to be false.<br></p><p>I agree as well that the precondition that when calling next(), no preceding call to next() should have returned nil is not observed enough.<br></p><p>I agree that algorithms need guarantees and API contracts.<br></p><p>Yet I have three arguments against the proposal:<br></p><p>1. Obscurity argument: Both the existing precondition, and the proposed convention are non-enforceable, non-testable, not well-known enough, and generally too weak to be efficient in any way. People don&#39;t write custom iterators often enough, and I don&#39;t expect those rules to eventually percolate through Swift culture.<br></p><p>2. Social argument: when a user complains that my library crashes when fed with a third-party iterator that does not behave, I, as a library author, have better make my code robust and accept non-conforming iterators than whining about the third-party. It&#39;s just faster and more efficient.<br></p><p>3. Iterator autonomy argument : Iterator is easily seen as a type that exists to support Sequence. In this case, we&#39;d like Iterator to end for good (finite sequence), or never end (infinite sequence). However, one could argue that Iterator is an autonomous type that happens to support Sequence, but may have other uses, like message queues. In such a context, requiring post-nil guarantees has no meaning.<br></p><p>I&#39;d thus remove the existing precondition, and support the following alternatives:<br></p><p>- the FuseIterator Patrick&#39;s proposal (and we could discuss its name).<br>- a new StoppingIterator protocol which does explicitly provide the post-nil guarantee. Algorithms could then use this guarantee.<br></p><p><br>• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, because algorithms need guarantees and API contracts. I&#39;m totally with the proposal author here. But I don&#39;t think the proposed changes are the right solution.<br></p><p><br>• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>This proposal has opened my eyes on a subtle problem with iterators that had not yet bitten me in any language I have used before. Or if it had, I guess just made my code more robust without much second thought.<br></p><p><br>• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>The best I could to expose my points :-)<br></p><p>Gwendal Roué<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/c0a31720/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>April 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Le 29 avr. 2016 à 08:18, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; a écrit :<br>&gt; <br>&gt;&gt; The review of &quot;SE-0052: Change IteratorType post-nil guarantee&quot; begins now and runs through May 3. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md&gt;<br>&gt; I&#39;d thus […] support the following alternatives:<br>&gt; <br>&gt; - the FuseIterator Patrick&#39;s proposal (and we could discuss its name).<br>&gt; - a new StoppingIterator protocol which does explicitly provide the post-nil guarantee. Algorithms could then use this guarantee.<br></p><p>Actually, a StoppingIterator protocol is not a good idea, because this concept should go up the type hierarchy up to Collection in order to let sequence and collection methods use static type information in order to choose the correct iterator algorithm.<br></p><p>I&#39;d prefer a FuseIterator that eventually returns nil forever as soon as it underlying iterator returns nil. Yes, fuseIterator would not apply the &quot;when calling next(), no preceding call to next() should have returned nil&quot; precondition. This precondition would be removed from the Iterator documentation. The FuseIterator would be the easy-going iterator, the one that has no surprise, and makes it easy to write algorithms.<br></p><p>When one needs a &quot;simple&quot; iterator, one just has to derive a FuseIterator from it. Its implementation could look like:<br></p><p>struct FuseIterator&lt;Element&gt; : Iterator {<br>    let baseNext: () -&gt; Element?<br>    var ended: Bool = false<br>    init&lt;I: Iterator where G.Element == Element&gt;(_ baseIterator: I) {<br>        var baseIterator = baseIterator<br>        baseNext = { baseIterator.next() }<br>    }<br>    mutating func next() -&gt; Element? {<br>        if ended {<br>            return nil<br>        } else if let element = baseNext() {<br>            return element<br>        } else {<br>            ended = true<br>            return nil<br>        }<br>    }<br>}<br></p><p>We would maybe also need a FuseSequence, in order to iterate a wild base iterator with a `for` loop until its first nil.<br></p><p>Last, forgive my non-native English, but when I look at &quot;fuse&quot; in a Thesaurus, I don&#39;t quite see the meaning of &quot;consume until first exhaustion&quot;. It looks like any one of &quot;BoundedIterator&quot;, &quot;ClosedIterator&quot;, &quot;CompactIterator&quot;, &quot;TerminatingIterator&quot; would better communicate its nature. &quot;ClosedIterator&quot; looks like the new &quot;ClosedRange&quot; types introduced by SE-0065 and is my current favorite.<br></p><p>Gwendal Roué<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/1f909b31/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 29, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think it&#39;s a good idea.<br></p><p>This is a particularly sharp edge in the standard library: people have a completely reasonable expectation about `next()`&#39;s behavior which is usually, but not always, borne out. And the vast majority of iterators can provide this feature for free. Only a few would pay any price, and that price would be minimal—it could easily be the cheapest statements in the method.<br></p><p>Nor do I think the FuseIterator solution will actually help. If you know about FuseIterator, you don&#39;t really need it, because you know about `next()`&#39;s nil behavior and can code around it. This is an attempt to protect the people who *don&#39;t* know about the problem.<br></p><p>There are languages so averse to trading anything for efficiency that they refuse to provide simple improvements to help with these kinds of issues. I don&#39;t think Swift should be one of them.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I think so. One of the major themes of Swift 3 is cleaning up the standard library.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I haven&#39;t, but some of the previous discussions on this issue have brought up Rust, which uses the FuseIterator solution. It seems like a pretty lousy one to me.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading this time, but I participated the previous discussion.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>May  1, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks for the feedback! Some comments:<br></p><p>1. *Obscurity argument*: Both the existing precondition, and the proposed<br>&gt; convention are non-enforceable, non-testable, not well-known enough, and<br>&gt; generally too weak to be efficient in any way. People don&#39;t write custom<br>&gt; iterators often enough, and I don&#39;t expect those rules to eventually<br>&gt; percolate through Swift culture.<br></p><p><br>To some degree true, but I&#39;d argue the current guarantee is significantly<br>more obscure than the proposed alternative:<br>- All standard library iterators return nil indefinitely.<br>- Iterators return nil if they&#39;re exhausted, i.e. no next element exists.<br>If I call next() again, it is still exhausted, still no next element<br>exists, so you&#39;d probably expect it to return nil again.<br></p><p>3. *Iterator autonomy argument* : Iterator is easily seen as a type that<br>&gt; exists to support Sequence. In this case, we&#39;d like Iterator to end for<br>&gt; good (finite sequence), or never end (infinite sequence). However, one<br>&gt; could argue that Iterator is an autonomous type that happens to support<br>&gt; Sequence, but may have other uses, like message queues. In such a context,<br>&gt; requiring post-nil guarantees has no meaning.<br></p><p><br>IteratorProtocol does explicitly describe itself as iterating over a<br>sequence though:<br>/// A type that supplies the values of a sequence one at a time.<br>I&#39;m not sure IteratorProtocol is intended to be used for such cases (where<br>the sequence changes length underneath). If it is, we could consider<br>changing the guarantee to return nil as long as the underlying sequence is<br>empty (i.e. allowing restarts). It&#39;s worth noting too that the current<br>guarantee also doesn&#39;t support sequences changing length.<br></p><p>On Fri, Apr 29, 2016 at 2:40 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; I think it&#39;s a good idea.<br>&gt;<br>&gt; This is a particularly sharp edge in the standard library: people have a<br>&gt; completely reasonable expectation about `next()`&#39;s behavior which is<br>&gt; usually, but not always, borne out. And the vast majority of iterators can<br>&gt; provide this feature for free. Only a few would pay any price, and that<br>&gt; price would be minimal—it could easily be the cheapest statements in the<br>&gt; method.<br>&gt;<br>&gt; Nor do I think the FuseIterator solution will actually help. If you know<br>&gt; about FuseIterator, you don&#39;t really need it, because you know about<br>&gt; `next()`&#39;s nil behavior and can code around it. This is an attempt to<br>&gt; protect the people who *don&#39;t* know about the problem.<br>&gt;<br>&gt; There are languages so averse to trading anything for efficiency that they<br>&gt; refuse to provide simple improvements to help with these kinds of issues. I<br>&gt; don&#39;t think Swift should be one of them.<br>&gt;<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; I think so. One of the major themes of Swift 3 is cleaning up the standard<br>&gt; library.<br>&gt;<br>&gt; &gt;       * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; I haven&#39;t, but some of the previous discussions on this issue have brought<br>&gt; up Rust, which uses the FuseIterator solution. It seems like a pretty lousy<br>&gt; one to me.<br>&gt;<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; Quick reading this time, but I participated the previous discussion.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/fd11452e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May  2, 2016 at 09:00:00pm</p></header><div class="content"><p>comments below.<br></p><p>&gt; Am 28.04.2016 um 20:12 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0052: Change IteratorType post-nil guarantee&quot; begins now and runs through May 3. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think it&#39;s good<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, it will demand safe and well-defined behavior from Iterators.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Swift is already a very safe language, and producing undefined behavior if someone calls the iterator too often is not nice. Since most iterators already behave nicely (or maybe all?) this shouldn&#39;t be a big issue.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>not sure<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal.<br></p><p>-Michael<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>May  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>We discussed the proposal with the members of the standard library team and we tend to +1 it (or +3 if you like).<br></p><p>It does not introduce any new costs to the implementations currently available in the standard library, and even in the case of `TakeWhileIterator` the extra branches are likely to be eliminated by the optimizer.<br>We also believe that moving the burden of adhering to the API contract from the user of the API to its developer is a valuable change.<br></p><p>max<br></p><p><br></p><p>&gt; On Apr 28, 2016, at 11:12 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0052: Change IteratorType post-nil guarantee&quot; begins now and runs through May 3. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May  2, 2016 at 11:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016, at 11:12 AM, Chris Lattner via swift-evolution wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0052: Change IteratorType post-nil guarantee&quot; begins now and runs through May 3. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I was originally strongly -1 on this (as can be seen from my previous messages on this ML about this topic), both for the reasons that Gwendal Roué wrote as well as my belief that the vast majority of users never even write code that hits this case at all and my own experience in that it&#39;s actually more common for me as an author of a custom Iterator to have to worry about meeting this guarantee than it is for anyone using my Iterator to rely on the behavior.<br></p><p>However, if there really is a 25% speedup on UTF-8 decoding for ASCII input, that&#39;s a pretty significant point in favor of the change. I saw the gist that was used to come up with this 25% number. But I do have to ask, does the 25% increase still hold when talking about String.UTF8View, or is that significant speedup only shown when using the UTF8 type to transcode? And similarly, what&#39;s the effect on performance for non-ASCII input?<br></p><p>Similarly, do we have any numbers for the effect on performance for a custom Iterator that now has to track state which it otherwise wouldn&#39;t? TakeWhileIterator would be a good candidate for testing, except it hasn&#39;t been implemented yet (though it shouldn&#39;t be hard to whip up a sample implementation for that).<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. The current defined behavior is pretty much the worst of all options since it encourages library authors to deliberately crash, and yet no stdlib type actually does crash, so it makes it easy to write code that works for stdlib iterators but will fail when given a third-party iterator.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Rust&#39;s equivalent Iterator type is defined such that after a previous call to next() has returned None, Iterators are allowed to return either None or Some(Item) from subsequent calls to next() (but shouldn&#39;t crash). And Rust has a FuseIterator (and a corresponding .fuse() method). This matches the first alternative in the proposal. And with this approach, it&#39;s true that it&#39;s extremely rare for people to call .fuse() (but this just demonstrates that very few people write code where post-nil behavior matters), but it does simplify many Iterator implementations, and AFAIK nobody&#39;s complained about this behavior.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>An in-depth study.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Review] SE-0052: Change IteratorType post-nil guarantee</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>May  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; However, if there really is a 25% speedup on UTF-8 decoding for ASCII<br>&gt; input, that&#39;s a pretty significant point in favor of the change. I saw the<br>&gt; gist that was used to come up with this 25% number. But I do have to ask,<br>&gt; does the 25% increase still hold when talking about String.UTF8View, or is<br>&gt; that significant speedup only shown when using the UTF8 type to transcode?<br>&gt; And similarly, what&#39;s the effect on performance for non-ASCII input?<br></p><p><br>The mentioned results are for decoding, i.e. UTF8 in, while UTF8View is<br>about transcoding/encoding, i.e. UTF8 out. But any thin wrapper around UTF8<br>decode (e.g. String(cString:)) should see basically the same speed-ups. I<br>haven&#39;t tested UTF16 decode, but the code path for all non-surrogates is<br>very similar to UTF8&#39;s ASCII decode and should the same similar gains –<br>which should translate directly into gains for e.g. iterating over a<br>UnicodeScalarView.<br></p><p>As for non-ascii input, the extra branch is a smaller slice of the total,<br>making the speed-up ~10%.<br></p><p>Similarly, do we have any numbers for the effect on performance for a<br>&gt; custom Iterator that now has to track state which it otherwise wouldn&#39;t?<br>&gt; TakeWhileIterator would be a good candidate for testing, except it hasn&#39;t<br>&gt; been implemented yet (though it shouldn&#39;t be hard to whip up a sample<br>&gt; implementation for that).<br></p><p><br>In the common cases I tested so far (where post-nil isn&#39;t used) the branch<br>is optimized away, but probably you could thwart the optimizer somehow. The<br>performance hit then would be likely be (very) roughly speaking the 1 over<br>the total number of branches in the loop.<br></p><p>On Tue, May 3, 2016 at 8:24 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Apr 28, 2016, at 11:12 AM, Chris Lattner via swift-evolution wrote:<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0052: Change IteratorType post-nil guarantee&quot; begins<br>&gt; now and runs through May 3. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0052-iterator-post-nil-guarantee.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; I was originally strongly -1 on this (as can be seen from my previous<br>&gt; messages on this ML about this topic), both for the reasons that Gwendal<br>&gt; Roué wrote as well as my belief that the vast majority of users never even<br>&gt; write code that hits this case at all and my own experience in that it&#39;s<br>&gt; actually more common for me as an author of a custom Iterator to have to<br>&gt; worry about meeting this guarantee than it is for anyone using my Iterator<br>&gt; to rely on the behavior.<br>&gt;<br>&gt; However, if there really is a 25% speedup on UTF-8 decoding for ASCII<br>&gt; input, that&#39;s a pretty significant point in favor of the change. I saw the<br>&gt; gist that was used to come up with this 25% number. But I do have to ask,<br>&gt; does the 25% increase still hold when talking about String.UTF8View, or is<br>&gt; that significant speedup only shown when using the UTF8 type to transcode?<br>&gt; And similarly, what&#39;s the effect on performance for non-ASCII input?<br>&gt;<br>&gt; Similarly, do we have any numbers for the effect on performance for a<br>&gt; custom Iterator that now has to track state which it otherwise wouldn&#39;t?<br>&gt; TakeWhileIterator would be a good candidate for testing, except it hasn&#39;t<br>&gt; been implemented yet (though it shouldn&#39;t be hard to whip up a sample<br>&gt; implementation for that).<br>&gt;<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; Yes. The current defined behavior is pretty much the worst of all options<br>&gt; since it encourages library authors to deliberately crash, and yet no<br>&gt; stdlib type actually does crash, so it makes it easy to write code that<br>&gt; works for stdlib iterators but will fail when given a third-party iterator.<br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt; &gt;       * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; Rust&#39;s equivalent Iterator type is defined such that after a previous call<br>&gt; to next() has returned None, Iterators are allowed to return either None or<br>&gt; Some(Item) from subsequent calls to next() (but shouldn&#39;t crash). And Rust<br>&gt; has a FuseIterator (and a corresponding .fuse() method). This matches the<br>&gt; first alternative in the proposal. And with this approach, it&#39;s true that<br>&gt; it&#39;s extremely rare for people to call .fuse() (but this just demonstrates<br>&gt; that very few people write code where post-nil behavior matters), but it<br>&gt; does simplify many Iterator implementations, and AFAIK nobody&#39;s complained<br>&gt; about this behavior.<br>&gt;<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; An in-depth study.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/749064b2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
