<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br></p><p>Consider:<br></p><p>struct MyStruct {<br>    static func foo() { print(&quot;foo&quot;) }<br>    func bar() {<br>        MyStruct.foo() // works<br>        self.dynamicType.foo() // works<br>        Self.foo() // error<br>    }<br>}<br></p><p>Obviously, you can always name a type directly or use `self.dynamicType` but<br>neither solution does any favors for readability. Both approaches obscure intent, <br>especially as type names grow large: `MyExtremelyLargeTypeName.staticMember`,<br>for example. Plus, as Kevin B pointed out to me,  `self.dynamicType.classMember`  <br>and `TypeName.classMember` may not be synonyms in class types with non-final members.<br></p><p>I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br></p><p>Thoughts?<br></p><p>-- E<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/22b0fc37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April  4, 2016 at 01:00:00pm</p></header><div class="content"><p>I’ve wondered this as well. Using “self.dynamicType” is noisy and somewhat esoteric, and using “MyStruct.foo” is bad the moment you want to rename “MyStruct”.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Apr 4, 2016, at 1:00 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br>&gt; <br>&gt; Consider:<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     static func foo() { print(&quot;foo&quot;) }<br>&gt;     func bar() {<br>&gt;         MyStruct.foo() // works<br>&gt;         self.dynamicType.foo() // works<br>&gt;         Self.foo() // error<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Obviously, you can always name a type directly or use `self.dynamicType` but<br>&gt; neither solution does any favors for readability. Both approaches obscure intent, <br>&gt; especially as type names grow large: `MyExtremelyLargeTypeName.staticMember`,<br>&gt; for example. Plus, as Kevin B pointed out to me,  `self.dynamicType.classMember`  <br>&gt; and `TypeName.classMember` may not be synonyms in class types with non-final members.<br>&gt; <br>&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 11:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br>&gt; <br>&gt; Consider:<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     static func foo() { print(&quot;foo&quot;) }<br>&gt;     func bar() {<br>&gt;         MyStruct.foo() // works<br>&gt;         self.dynamicType.foo() // works<br>&gt;         Self.foo() // error<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Obviously, you can always name a type directly or use `self.dynamicType` but<br>&gt; neither solution does any favors for readability. Both approaches obscure intent, <br>&gt; especially as type names grow large: `MyExtremelyLargeTypeName.staticMember`,<br>&gt; for example. Plus, as Kevin B pointed out to me,  `self.dynamicType.classMember`  <br>&gt; and `TypeName.classMember` may not be synonyms in class types with non-final members.<br>&gt; <br>&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br></p><p>There&#39;s the wrinkle of inheritance, as there so often is. `Self` inside a class scope already means &quot;the dynamic class of &#39;self&#39;&quot;, not &quot;the type this declaration statically appears within&quot;. Now, we really ought to allow you to utter Self in the bodies of class methods too. It would be consistent to extend that courtesy to value types, where dynamic `Self` always matches the static type, from that principle.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 12:13 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 4, 2016, at 11:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br>&gt;&gt; <br>&gt;&gt; Consider:<br>&gt;&gt; <br>&gt;&gt; struct MyStruct {<br>&gt;&gt;    static func foo() { print(&quot;foo&quot;) }<br>&gt;&gt;    func bar() {<br>&gt;&gt;        MyStruct.foo() // works<br>&gt;&gt;        self.dynamicType.foo() // works<br>&gt;&gt;        Self.foo() // error<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Obviously, you can always name a type directly or use `self.dynamicType` but<br>&gt;&gt; neither solution does any favors for readability. Both approaches obscure intent, <br>&gt;&gt; especially as type names grow large: `MyExtremelyLargeTypeName.staticMember`,<br>&gt;&gt; for example. Plus, as Kevin B pointed out to me,  `self.dynamicType.classMember`  <br>&gt;&gt; and `TypeName.classMember` may not be synonyms in class types with non-final members.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br>&gt; <br>&gt; There&#39;s the wrinkle of inheritance, as there so often is. `Self` inside a class scope already means &quot;the dynamic class of &#39;self&#39;&quot;, not &quot;the type this declaration statically appears within&quot;. Now, we really ought to allow you to utter Self in the bodies of class methods too. It would be consistent to extend that courtesy to value types, where dynamic `Self` always matches the static type, from that principle.<br>&gt; <br>&gt; -Joe<br></p><p>Would using another word or symbol fix that problem?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/4f7a47dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  4, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 11:17 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 4, 2016, at 12:13 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 4, 2016, at 11:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MyStruct {<br>&gt;&gt;&gt;    static func foo() { print(&quot;foo&quot;) }<br>&gt;&gt;&gt;    func bar() {<br>&gt;&gt;&gt;        MyStruct.foo() // works<br>&gt;&gt;&gt;        self.dynamicType.foo() // works<br>&gt;&gt;&gt;        Self.foo() // error<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviously, you can always name a type directly or use `self.dynamicType` but<br>&gt;&gt;&gt; neither solution does any favors for readability. Both approaches obscure intent, <br>&gt;&gt;&gt; especially as type names grow large: `MyExtremelyLargeTypeName.staticMember`,<br>&gt;&gt;&gt; for example. Plus, as Kevin B pointed out to me,  `self.dynamicType.classMember`  <br>&gt;&gt;&gt; and `TypeName.classMember` may not be synonyms in class types with non-final members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br>&gt;&gt; <br>&gt;&gt; There&#39;s the wrinkle of inheritance, as there so often is. `Self` inside a class scope already means &quot;the dynamic class of &#39;self&#39;&quot;, not &quot;the type this declaration statically appears within&quot;. Now, we really ought to allow you to utter Self in the bodies of class methods too. It would be consistent to extend that courtesy to value types, where dynamic `Self` always matches the static type, from that principle.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; Would using another word or symbol fix that problem?<br></p><p>My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  4, 2016 at 08:00:00pm</p></header><div class="content"><p>On Apr 4, 2016, at 8:13 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; On Apr 4, 2016, at 11:17 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; On Apr 4, 2016, at 12:13 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Apr 4, 2016, at 11:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct MyStruct {<br>&gt;&gt;&gt;&gt;   static func foo() { print(&quot;foo&quot;) }<br>&gt;&gt;&gt;&gt;   func bar() {<br>&gt;&gt;&gt;&gt;       MyStruct.foo() // works<br>&gt;&gt;&gt;&gt;       self.dynamicType.foo() // works<br>&gt;&gt;&gt;&gt;       Self.foo() // error<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Obviously, you can always name a type directly or use `self.dynamicType` but<br>&gt;&gt;&gt;&gt; neither solution does any favors for readability. Both approaches obscure intent, <br>&gt;&gt;&gt;&gt; especially as type names grow large: `MyExtremelyLargeTypeName.staticMember`,<br>&gt;&gt;&gt;&gt; for example. Plus, as Kevin B pointed out to me,  `self.dynamicType.classMember`  <br>&gt;&gt;&gt;&gt; and `TypeName.classMember` may not be synonyms in class types with non-final members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s the wrinkle of inheritance, as there so often is. `Self` inside a class scope already means &quot;the dynamic class of &#39;self&#39;&quot;, not &quot;the type this declaration statically appears within&quot;. Now, we really ought to allow you to utter Self in the bodies of class methods too. It would be consistent to extend that courtesy to value types, where dynamic `Self` always matches the static type, from that principle.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; Would using another word or symbol fix that problem?<br>&gt; <br>&gt; My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br>&gt; <br>&gt; -Joe<br></p><p>There&#39;s a pleasing simplicity to that approach.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/df5a8734/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br></p><p>+1. There&#39;s just no way we want to explain two kinds of Selves to people.<br></p><p>However, we need to make sure it works in these contexts:<br></p><p>1) #selector<br>2) getting an unbound method<br>3) referring to static methods (including private ones)<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/60250ec2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April  5, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 7:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Would using another word or symbol fix that problem?<br>&gt; <br>&gt; My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br></p><p>I would agree that Self should remain the dynamic version, but adding StaticSelf (however it is spelled) adds the safety of being able to refactor code w/o forgetting to rename an explicit class name. It adds the ability to more clearly express what you mean (“the containing class/struct, whatever it happens to be”), and it would reduce effort while reading code (in that you could see quickly that it was StaticSelf instead of having to look to see whether it was the same name as the enclosing type every time you read the code).<br></p><p>My support for StaticSelf isn’t at all about it being too hard to type ClassName.foo the first time, but about being able to read and maintain code after the fact.<br></p><p>And, of course, the argument that writing ClassName.foo isn’t onerous is dangerously close to an argument for dropping “.foo” with a type inferred by the call site... =)<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/7d1ad6e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 7:34 AM, Timothy Wood via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 4, 2016, at 7:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Would using another word or symbol fix that problem?<br>&gt;&gt; <br>&gt;&gt; My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br>&gt; <br>&gt; I would agree that Self should remain the dynamic version, but adding StaticSelf (however it is spelled) adds the safety of being able to refactor code w/o forgetting to rename an explicit class name. It adds the ability to more clearly express what you mean (“the containing class/struct, whatever it happens to be”), and it would reduce effort while reading code (in that you could see quickly that it was StaticSelf instead of having to look to see whether it was the same name as the enclosing type every time you read the code).<br>&gt; <br>&gt; My support for StaticSelf isn’t at all about it being too hard to type ClassName.foo the first time, but about being able to read and maintain code after the fact.<br></p><p>I think you have a good point with your `#Self` idea—there&#39;s definitely an analogy there to other magic constants like #function.<br></p><p>&gt; And, of course, the argument that writing ClassName.foo isn’t onerous is dangerously close to an argument for dropping “.foo” with a type inferred by the call site... =)<br></p><p>From my own experience with C++11, if it weren&#39;t for code completion, having to utter &#39;EnumName::Case&#39; over and over again when working with `enum class`es would drive me up the wall.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 10:06 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 5, 2016, at 7:34 AM, Timothy Wood via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 4, 2016, at 7:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Would using another word or symbol fix that problem?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br>&gt;&gt; <br>&gt;&gt; I would agree that Self should remain the dynamic version, but adding StaticSelf (however it is spelled) adds the safety of being able to refactor code w/o forgetting to rename an explicit class name. It adds the ability to more clearly express what you mean (“the containing class/struct, whatever it happens to be”), and it would reduce effort while reading code (in that you could see quickly that it was StaticSelf instead of having to look to see whether it was the same name as the enclosing type every time you read the code).<br>&gt;&gt; <br>&gt;&gt; My support for StaticSelf isn’t at all about it being too hard to type ClassName.foo the first time, but about being able to read and maintain code after the fact.<br>&gt; <br>&gt; I think you have a good point with your `#Self` idea—there&#39;s definitely an analogy there to other magic constants like #function.<br></p><p>This also falls nicely into my list of &quot;debug literals we discussed on-list as wanting to see but did nothing about&quot;. (I would also like to see #function upgraded to use full gregorized naming with arguments. )<br></p><p>-- E<br></p><p>&gt; <br>&gt;&gt; And, of course, the argument that writing ClassName.foo isn’t onerous is dangerously close to an argument for dropping “.foo” with a type inferred by the call site... =)<br>&gt; <br>&gt; From my own experience with C++11, if it weren&#39;t for code completion, having to utter &#39;EnumName::Case&#39; over and over again when working with `enum class`es would drive me up the wall.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/ba5eb888/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>April  5, 2016 at 10:00:00am</p></header><div class="content"><p>I too would like a #Self. In my (subjective, biased) experience, sufficiently descriptive type names are usually long enough to make working with static members painfully onerous.<br></p><p>If there&#39;s still the risk of confusion (compile-time type versus runtime type), maybe #Self can be limited to instances where the type it references cannot change at runtime (e.g. a struct, enum, or final class). I don&#39;t know if this will actually be necessary, though - just throwing ideas out there.<br></p><p>Austin<br></p><p>&gt; On Apr 5, 2016, at 9:06 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 5, 2016, at 7:34 AM, Timothy Wood via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 4, 2016, at 7:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Would using another word or symbol fix that problem?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br>&gt;&gt; <br>&gt;&gt; I would agree that Self should remain the dynamic version, but adding StaticSelf (however it is spelled) adds the safety of being able to refactor code w/o forgetting to rename an explicit class name. It adds the ability to more clearly express what you mean (“the containing class/struct, whatever it happens to be”), and it would reduce effort while reading code (in that you could see quickly that it was StaticSelf instead of having to look to see whether it was the same name as the enclosing type every time you read the code).<br>&gt;&gt; <br>&gt;&gt; My support for StaticSelf isn’t at all about it being too hard to type ClassName.foo the first time, but about being able to read and maintain code after the fact.<br>&gt; <br>&gt; I think you have a good point with your `#Self` idea—there&#39;s definitely an analogy there to other magic constants like #function.<br>&gt; <br>&gt;&gt; And, of course, the argument that writing ClassName.foo isn’t onerous is dangerously close to an argument for dropping “.foo” with a type inferred by the call site... =)<br>&gt; <br>&gt; From my own experience with C++11, if it weren&#39;t for code completion, having to utter &#39;EnumName::Case&#39; over and over again when working with `enum class`es would drive me up the wall.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>April  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 7:34 AM, Timothy Wood via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 4, 2016, at 7:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Would using another word or symbol fix that problem?<br>&gt;&gt; <br>&gt;&gt; My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br>&gt; <br>&gt; I would agree that Self should remain the dynamic version, but adding StaticSelf (however it is spelled) adds the safety of being able to refactor code w/o forgetting to rename an explicit class name. It adds the ability to more clearly express what you mean (“the containing class/struct, whatever it happens to be”), and it would reduce effort while reading code (in that you could see quickly that it was StaticSelf instead of having to look to see whether it was the same name as the enclosing type every time you read the code).<br></p><p>But if you don’t want subclasses to override it then why are you making it internal/public in the first place?<br></p><p>I’m not sure the only-classes case of exposing a class/static publicly but also not wanting subclasses to override it justifies a new language construct. Accessing these things via Self (aka self.dynamicType) seems good enough to me.<br></p><p><br>Russ<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/9cad959d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 11:41 AM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; But if you don’t want subclasses to override it then why are you making it internal/public in the first place?<br></p><p>I&#39;m wan’t talking about overriding it… In my earlier posts I was talking about subclasses being able to call a utility function on their superclass and have a generic be expanded to the subclass type (whatever it is) by using `#Self`.<br></p><p>So, if the superclass `PropertyOwner ` has something like this (excusing typos since this code can’t be compiled right now, obviously =) ...<br></p><p>	static func property&lt;Owner: PropertyOwner, ValueType&gt;(ownerType: Owner.Type = #Self.self, name: String, value: ValueType)<br></p><p>then a subclass `Sub` could do:<br></p><p>	static let foozle = property(name: “foozle”, value: Int(3))<br></p><p>and end up with `foozle` being configured with ownerType = Sub.self. If later this property is moved to a different class, its ownerType would automatically change based on its new scope.<br></p><p>-tim<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  5, 2016 at 04:00:00pm</p></header><div class="content"><p>As the discussion seems to be quieting down, I&#39;ve tried to summarize the on-list discussion and distill it into a preliminary proposal draft. Please let me know if this covers what you think it should or if I&#39;ve entirely missed the mark. (It wouldn&#39;t be the first time.)<br></p><p>Regards,  -- Erica<br></p><p>Adding a #Self literal to Swift<br></p><p>Proposal: SE-XXXX &lt;https://gist.github.com/erica/5a26d523f3d6ffb74e34d179740596f7&gt;<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227#introduction&gt;Introduction<br></p><p>This proposal introduces #Self, a new literal that expands to self.dynamicType.<br></p><p>This proposal was discussed on the Swift Evolution list in the [Pitch] Adding a Self type name shortcut for static member access &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13708/focus=13712&gt; thread.<br></p><p> &lt;https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227#motivation&gt;Motivation<br></p><p>It is common in Swift to reference an instance&#39;s type, whether for accessing a static member or passing a type for an unsafe bitcast, among other uses. At this time, you can either fully specify a type by name or use self.dynamicType to access an instance&#39;s dynamic runtime type as a value. <br></p><p>struct MyStruct {<br>    static func staticMethod() { ... }<br>    func instanceMethod() {<br>        MyStruct.staticMethod()<br>        self.dynamicType.staticMethod()<br>    }<br>}<br>As type names grow large, readability suffers, for example MyExtremelyLargeTypeName.staticMember<br>Code using hardwired type names is less portable than code that automatically knows its type.<br>Renaming a type means updating any TypeName references in code.<br>Using self.dynamicType fights against Swift&#39;s goals of concision and clarity; it is both noisy and esoteric.<br>self.dynamicType.classMember and TypeName.classMember may not be synonyms in class types with non-final members.<br>Joe Groff points out, Self inside a class scope already means &quot;the dynamic class of &#39;self&#39;&quot;, not &quot;the type this declaration statically appears within...Swift ought to allow developers to utter Self in the bodies of class methods. It would be consistent to extend that courtesy to value types, where dynamic Self always matches the static type, from that principle&quot;<br> &lt;https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227#detail-design&gt;Detail Design<br></p><p>In this proposal, #Self expands to the dynamic type of self and only the dynamic type of self. Joe Groff writes, &quot;I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.&quot;<br></p><p> &lt;https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227#alternatives-considered&gt;Alternatives Considered<br></p><p>Not at this time<br></p><p> &lt;https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227#acknowlegements&gt;Acknowlegements<br></p><p>Thanks Sean Heber, Kevin Ballard, Joe Groff, Timothy Wood, Brent Royal-Gordon, Andrey Tarantsov, Austin Zheng<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/b775c8a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 3:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; As the discussion seems to be quieting down, I&#39;ve tried to summarize the on-list discussion and distill it into a preliminary proposal draft. Please let me know if this covers what you think it should or if I&#39;ve entirely missed the mark. (It wouldn&#39;t be the first time.)<br>&gt; <br>&gt; Regards,  -- Erica<br>&gt; <br>&gt; Adding a #Self literal to Swift<br>&gt; <br>&gt; 	• Proposal: SE-XXXX<br>&gt; 	• Author(s): Erica Sadun<br>&gt; 	• Status: TBD<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces #Self, a new literal that expands to self.dynamicType.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the [Pitch] Adding a Self type name shortcut for static member access thread.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; It is common in Swift to reference an instance&#39;s type, whether for accessing a static member or passing a type for an unsafe bitcast, among other uses. At this time, you can either fully specify a type by name or use self.dynamicType to access an instance&#39;s dynamic runtime type as a value. <br>&gt; <br>&gt; struct MyStruct {<br>&gt;     static func staticMethod() { ... }<br>&gt;     func instanceMethod() {<br>&gt;         MyStruct.staticMethod()<br>&gt;         self.dynamicType.staticMethod()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; 	• As type names grow large, readability suffers, for example MyExtremelyLargeTypeName.staticMember<br>&gt; 	• Code using hardwired type names is less portable than code that automatically knows its type.<br>&gt; 	• Renaming a type means updating any TypeName references in code.<br>&gt; 	• Using self.dynamicType fights against Swift&#39;s goals of concision and clarity; it is both noisy and esoteric.<br>&gt; 	• self.dynamicType.classMember and TypeName.classMember may not be synonyms in class types with non-final members.<br>&gt; 	• Joe Groff points out, Self inside a class scope already means &quot;the dynamic class of &#39;self&#39;&quot;, not &quot;the type this declaration statically appears within...Swift ought to allow developers to utter Self in the bodies of class methods. It would be consistent to extend that courtesy to value types, where dynamic Self always matches the static type, from that principle&quot;<br>&gt; Detail Design<br>&gt; <br>&gt; In this proposal, #Self expands to the dynamic type of self and only the dynamic type of self. Joe Groff writes, &quot;I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.&quot;<br></p><p>What you&#39;re describing should be spelled `Self`, IMO. I think Tim intended `#Self` to mean the *static* type the code is declared inside (which is the same as Self unless you&#39;re in a class).<br></p><p>-Joe<br></p><p>&gt; Alternatives Considered<br>&gt; <br>&gt; Not at this time<br>&gt; <br>&gt; Acknowlegements<br>&gt; <br>&gt; Thanks Sean Heber, Kevin Ballard, Joe Groff, Timothy Wood, Brent Royal-Gordon, Andrey Tarantsov, Austin Zheng<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  5, 2016 at 04:00:00pm</p></header><div class="content"><p>Updating. Gist here: https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227<br></p><p>-- E<br></p><p>&gt; On Apr 5, 2016, at 4:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 5, 2016, at 3:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As the discussion seems to be quieting down, I&#39;ve tried to summarize the on-list discussion and distill it into a preliminary proposal draft. Please let me know if this covers what you think it should or if I&#39;ve entirely missed the mark. (It wouldn&#39;t be the first time.)<br>&gt;&gt; <br>&gt;&gt; Regards,  -- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/baf81d8d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 3:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What you&#39;re describing should be spelled `Self`, IMO. I think Tim intended `#Self` to mean the *static* type the code is declared inside (which is the same as Self unless you&#39;re in a class).<br></p><p>Yes, that is what I was aiming for. `#Self` would be a pretty much textual replacement just like #file, etc. That is, I could imaging it being used in a bunch of cases (not useful here, but just intending to enumerate the possible uses I see):<br></p><p>class Foo {<br>	static let myClass: #Self.Type = #Self.self<br>	static let anInstance: #Self = #Self()<br></p><p>	static let defaultState = …<br></p><p>	var state = #Self.defaultState	<br>}<br></p><p>The extra bit I was suggesting for allowing passing it in as a default argument like #file is for assert/precondition would be useful to me too:<br></p><p>func globalFunc&lt;SomeType: SomeProtocol&gt;(callerType: SomeType.Type = #Self.self, …)<br></p><p>which would only be callable inside a class/struct/enum context that conformed to SomeProtocol (unless you explicitly passed a callerType that met the requirements, of course). I’ve no idea if this latter bit is hard enough or controversial enough to be its own proposal =)<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/7d3ebbd5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 4:17 PM, Timothy Wood &lt;tjw at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 5, 2016, at 3:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What you&#39;re describing should be spelled `Self`, IMO. I think Tim intended `#Self` to mean the *static* type the code is declared inside (which is the same as Self unless you&#39;re in a class).<br>&gt; <br>&gt; Yes, that is what I was aiming for. `#Self` would be a pretty much textual replacement just like #file, etc. That is, I could imaging it being used in a bunch of cases (not useful here, but just intending to enumerate the possible uses I see):<br></p><p>Please check to ensure that the changes I just made match your expectations:<br></p><p>https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227 &lt;https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227&gt;<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/0ea82b27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 3:21 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Please check to ensure that the changes I just made match your expectations:<br>&gt; <br>&gt; https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227 &lt;https://gist.github.com/erica/c60c7d51809889f3dfd47cdb482d6227&gt;<br>That looks good to me — thanks Erica!<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/c073fccb/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 4:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 5, 2016, at 3:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As the discussion seems to be quieting down, I&#39;ve tried to summarize the on-list discussion and distill it into a preliminary proposal draft. Please let me know if this covers what you think it should or if I&#39;ve entirely missed the mark. (It wouldn&#39;t be the first time.)<br>&gt;&gt; <br>&gt;&gt; Regards,  -- Erica<br></p><p><br>Pull Request 248: https://github.com/apple/swift-evolution/pull/248 &lt;https://github.com/apple/swift-evolution/pull/248&gt;<br></p><p>Within a class scope, Self means &quot;the dynamic class of self&quot;. This proposal extends that courtesy to value types, where dynamic Self will match a construct&#39;s static type, and to the bodies of class members, where it may not. It also introduces a static variation, #Self that expands to static type of the code it appears within.<br></p><p>This proposal was discussed on the Swift Evolution list in the [Pitch] Adding a Self type name shortcut for static member access &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13708/focus=13712&gt; thread.<br></p><p>Thanks, -- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/0112d9e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April  7, 2016 at 08:00:00am</p></header><div class="content"><p>There&#39;s something I find very confusing with this proposal, and it&#39;s how Self is already used in protocol definitions to represent the STATIC type of the type that conforms to the protocol. I think people will be potentially very confused by how Self represents different types in different contexts:<br></p><p>protocol Copyable {<br>    func copy() -&gt; Self<br>}<br></p><p>class Animal : Copyable {<br>    init() {}<br>    func copy() -&gt; Animal {<br>        return Self.init()<br>    }<br>}<br></p><p>class Cat : Animal {}<br></p><p>In the previous sample, wouldn&#39;t it be confusing to people if Self in the protocol means Animal in the Animal type, but Self in the Animal type may mean Cat?<br></p><p>Sent from my iPad<br>&gt; On 06 Apr 2016, at 18:51, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Apr 5, 2016, at 4:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 5, 2016, at 3:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As the discussion seems to be quieting down, I&#39;ve tried to summarize the on-list discussion and distill it into a preliminary proposal draft. Please let me know if this covers what you think it should or if I&#39;ve entirely missed the mark. (It wouldn&#39;t be the first time.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,  -- Erica<br>&gt; <br>&gt; <br>&gt; Pull Request 248: https://github.com/apple/swift-evolution/pull/248<br>&gt; <br>&gt; Within a class scope, Self means &quot;the dynamic class of self&quot;. This proposal extends that courtesy to value types, where dynamic Self will match a construct&#39;s static type, and to the bodies of class members, where it may not. It also introduces a static variation, #Self that expands to static type of the code it appears within.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the [Pitch] Adding a Self type name shortcut for static member access thread.<br>&gt; <br>&gt; Thanks, -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/f69ce6df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  7, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:09 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; There&#39;s something I find very confusing with this proposal, and it&#39;s how Self is already used in protocol definitions to represent the STATIC type of the type that conforms to the protocol. I think people will be potentially very confused by how Self represents different types in different contexts:<br>&gt; <br>&gt; protocol Copyable {<br>&gt;     func copy() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class Animal : Copyable {<br>&gt;     init() {}<br>&gt;     func copy() -&gt; Animal {<br>&gt;         return Self.init()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Cat : Animal {}<br>&gt; <br>&gt; In the previous sample, wouldn&#39;t it be confusing to people if Self in the protocol means Animal in the Animal type, but Self in the Animal type may mean Cat?<br></p><p>Protocol conformances are inherited, so that&#39;s not a valid conformance, and protocol Self is synonymous with class Self when a class conforms. Animal.copy() would have to return Self to conform to Copyable.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April  9, 2016 at 06:00:00am</p></header><div class="content"><p>On Apr 4, 2016, at 7:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Apr 4, 2016, at 11:17 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; On Apr 4, 2016, at 12:13 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 4, 2016, at 11:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct MyStruct {<br>&gt;&gt;&gt;&gt;   static func foo() { print(&quot;foo&quot;) }<br>&gt;&gt;&gt;&gt;   func bar() {<br>&gt;&gt;&gt;&gt;       MyStruct.foo() // works<br>&gt;&gt;&gt;&gt;       self.dynamicType.foo() // works<br>&gt;&gt;&gt;&gt;       Self.foo() // error<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Obviously, you can always name a type directly or use `self.dynamicType` but<br>&gt;&gt;&gt;&gt; neither solution does any favors for readability. Both approaches obscure intent, <br>&gt;&gt;&gt;&gt; especially as type names grow large: `MyExtremelyLargeTypeName.staticMember`,<br>&gt;&gt;&gt;&gt; for example. Plus, as Kevin B pointed out to me,  `self.dynamicType.classMember`  <br>&gt;&gt;&gt;&gt; and `TypeName.classMember` may not be synonyms in class types with non-final members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s the wrinkle of inheritance, as there so often is. `Self` inside a class scope already means &quot;the dynamic class of &#39;self&#39;&quot;, not &quot;the type this declaration statically appears within&quot;. Now, we really ought to allow you to utter Self in the bodies of class methods too. It would be consistent to extend that courtesy to value types, where dynamic `Self` always matches the static type, from that principle.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; Would using another word or symbol fix that problem?<br>&gt; <br>&gt; My preference would be for there to be only one Self, and have it always be the dynamic type of &#39;self&#39;. Some people disagree, but I don&#39;t think it&#39;s all that onerous to have to write ClassName.foo if that&#39;s really what you specifically mean.<br></p><p>I agree with this, with the clarification that “Self” should be valid inside of structs and enums, where it is unambiguous what it refers to.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 11:00 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br>&gt; <br>[...]<br>&gt; <br>&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br></p><p>I would love to see a way to get the type of the &quot;enclosing thing at compile time”. In my particular case, I’m using the type as a generic parameter to tag a created resource with something like:<br></p><p>class Client: PropertyOwner {<br>	let intProperty = Client.property(“name”, Int(0))<br>}<br></p><p>where PropertyOwner has a static property&lt;Owner, DataType&gt;(...)<br></p><p>With `Self` meaning the static version of the thing being compiled, I could at least write:<br></p><p>class Client: PropertyOwner {<br>	let intProperty = Self.property(“name”, Int(0))<br>}<br></p><p>which would have the benefit of being harder to mess up due to copy-pasting between different PropertyOwner implementors.<br></p><p>I would love to be able to omit the `Self.` entirely, but instances can’t call functions on themselves at init time, and instances don’t see static funcs, so that probably won’t fly =)<br></p><p>The particular spelling of ‘static self` doesn’t matter too much to me, so if `Self` needs to be the runtime type of the executing class then maybe `StaticSelf` could be added.<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/55dbd76c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April  5, 2016 at 06:00:00am</p></header><div class="content"><p>If the `.StaticMember` (no type name) notation discussed already at least<br>twice, in the context of expanding the `.EnumCase` syntax, was accepted,<br>this would eleviate the problem.<br></p><p>On Tuesday, 5 April 2016, Timothy Wood via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 4, 2016, at 11:00 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s<br>&gt; type name?<br>&gt;<br>&gt; [...]<br>&gt;<br>&gt;<br>&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for<br>&gt; `TypeName.staticMember`.<br>&gt;<br>&gt;<br>&gt; I would love to see a way to get the type of the &quot;enclosing thing at<br>&gt; compile time”. In my particular case, I’m using the type as a generic<br>&gt; parameter to tag a created resource with something like:<br>&gt;<br>&gt; class Client: PropertyOwner {<br>&gt; let intProperty = Client.property(“name”, Int(0))<br>&gt; }<br>&gt;<br>&gt;<br>&gt; where PropertyOwner has a static property&lt;Owner, DataType&gt;(...)<br>&gt;<br>&gt; With `Self` meaning the static version of the thing being compiled, I<br>&gt; could at least write:<br>&gt;<br>&gt; class Client: PropertyOwner {<br>&gt; let intProperty = Self.property(“name”, Int(0))<br>&gt; }<br>&gt;<br>&gt;<br>&gt; which would have the benefit of being harder to mess up due to<br>&gt; copy-pasting between different PropertyOwner implementors.<br>&gt;<br>&gt; I would love to be able to omit the `Self.` entirely, but instances can’t<br>&gt; call functions on themselves at init time, and instances don’t see static<br>&gt; funcs, so that probably won’t fly =)<br>&gt;<br>&gt; The particular spelling of ‘static self` doesn’t matter too much to me, so<br>&gt; if `Self` needs to be the runtime type of the executing class then maybe<br>&gt; `StaticSelf` could be added.<br>&gt;<br>&gt; -tim<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160405/cf11d7d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06130940a44c84dfc6c5aeabfd8482f8?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Timothy Wood</string> &lt;tjw at me.com&gt;<p>April  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 4, 2016, at 1:39 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; If the `.StaticMember` (no type name) notation discussed already at least twice, in the context of expanding the `.EnumCase` syntax, was accepted, this would eleviate the problem. <br></p><p>I was thinking about the syntax a bit further and it seems like the capability that would be added is like #file, in that it does some compile-time textual replacement. So, perhaps #Self would work?<br></p><p>Also, along these lines, I would find use for call-site interpolation like #file has. I could then do a free function version of my property() call that was something like:<br></p><p>	func property(ownerType: PropertyOwner.Type = #Self, ...) { }<br></p><p>which would only be callable from w/in things conforming to or subclassing PropertyOwner.<br></p><p>-tim<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/49029131/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Adding a Self type name shortcut for static member access</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  4, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Are there reasons that prevent using `Self` as a synonym for an instance&#39;s type name?<br>&gt; <br>&gt; Consider:<br>&gt; <br>&gt; struct MyStruct {<br>&gt;     static func foo() { print(&quot;foo&quot;) }<br>&gt;     func bar() {<br>&gt;         MyStruct.foo() // works<br>&gt;         self.dynamicType.foo() // works<br>&gt;         Self.foo() // error<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Obviously, you can always name a type directly or use `self.dynamicType` but<br>&gt; neither solution does any favors for readability. Both approaches obscure intent, <br>&gt; especially as type names grow large: `MyExtremelyLargeTypeName.staticMember`,<br>&gt; for example. Plus, as Kevin B pointed out to me,  `self.dynamicType.classMember`  <br>&gt; and `TypeName.classMember` may not be synonyms in class types with non-final members.<br>&gt; <br>&gt; I&#39;d like to see `Self.staticMember` introduced as a synonym for `TypeName.staticMember`.<br>&gt; <br>&gt; Thoughts?<br></p><p>I&#39;m kind of struggling with how best to design this. Here&#39;s the most coherent design I&#39;ve been able to come up with so far.<br></p><p>* Adopt the proposal to no longer require `.self` on types to get the type instance. Using a type name in expression context gives you the type instance.<br>* Every variable `foo` has a typealias attached to it, `foo.Self`. This is the static (compile-time declared or inferred) type of that instance. You can use it anywhere you can use a type name, including in declarations. If it&#39;s used in an expression, it becomes the type instance of the variable&#39;s static type.<br>* Every variable `foo` has a special typealias attached to it, `foo.DynamicSelf`. This is the dynamic (runtime assigned) type of that instance. In theory you can use it anywhere you can use a type name, though in practice there are probably significant limitations. If it&#39;s used an expression, it become the type instance of the variable&#39;s dynamic type.<br>* A bare `Self` or `DynamicSelf` is a shorthand for `self.Self` or `self.DynamicSelf`.<br></p><p>`DynamicSelf` subsumes the roles of both the old `Self` and `dynamicType`. `Self` is both an alias for the declared type and a way to get its type instance.<br></p><p>This gives us a number of new abilities:<br></p><p>	Self.classMember()				// Instead of ReallyLongClassName.classMember()<br>	foo.Self.classMember()			// Likewise, but for a different variable<br>	<br>	let self2: Self					// Match the static type of self<br>	let foo2: foo.Self				// Match the static type of a different variable<br>	<br>	DynamicSelf.classMember()		// Instead of self.dynamicType.classMember()<br>	foo.DynamicSelf.classMember()	// Likewise<br></p><p>	let self3: DynamicSelf			// Match the dynamic type of self<br>	let foo3: foo.DynamicSelf		// Match the dynamic type of a different variable<br>	// (Those would probably require certain restrictions, like the base variable has to be <br>	// immutable and the assignment has to come from a function returning a DynamicSelf<br>	// derived from `self`/`foo`.)<br>	<br>	// Make promises about matching dynamic types of parameters besides `self`:<br>	func tenMinutesAfter(date: NSDate) -&gt; date.DynamicSelf {<br>		return date.adding(10 * 60)		// Note that `adding(_: NSTimeInterval)` returns DynamicSelf<br>	}<br>	<br>	// Possible alternative to generic syntax:<br>	func removingCommonPrefix(_ one: Collection, _ two: Collection) -&gt; (one.Self.SubSequence, two.Self.SubSequence) where one.Self.Element == two.Self.Element, one.Self.Element: Equatable {<br>		for (oneIndex, twoIndex) in zip(one.indices + [one.endIndex], two.indices + [two.endIndex]) {<br>			if oneIndex == one.endIndex || twoIndex == two.endIndex || one[oneIndex] != two[twoIndex] {<br>				return (one.suffixFrom(oneIndex), two.suffixFrom(twoIndex))<br>			}<br>		}<br>		fatalError(&quot;Can&#39;t get here&quot;)<br>	}<br></p><p>The only disadvantage I see to this approach is that code which currently uses `Self` will be longer. But there may be other problems as well. I&#39;m not entirely sure I have a good handle on the existing `Self` vs. `dynamicType`; it&#39;s possible the connection I see between them is spurious or ill-defined.<br></p><p>By the way, an alternative would be to leave the dynamic type as `Self` and call the static type `Type`, which I *think* would generalize the existing notion of the metatype being accessible as `Type`. In other words:<br></p><p>	Type.classMember()				// Instead of ReallyLongClassName.classMember()<br>	foo.Type.classMember()			// Likewise, but for a different variable<br>	<br>	let self2: Type					// Match the static type of self<br>	let foo2: foo.Type				// Match the static type of a different variable<br>	<br>	Self.classMember()				// Instead of self.dynamicType.classMember()<br>	foo.Self.classMember()			// Likewise<br></p><p>	let self3: Self					// Match the dynamic type of self<br>	let foo3: foo.Self				// Match the dynamic type of a different variable<br>	// (Those would probably require certain restrictions, like the base variable has to be <br>	// immutable and the assignment has to come from a function returning a Self<br>	// derived from `self`/`foo`.)<br>	<br>	// Make promises about matching dynamic types of parameters besides `self`:<br>	func tenMinutesAfter(date: NSDate) -&gt; date.Self {<br>		return date.adding(10 * 60)		// Note that `adding(_: NSTimeInterval)` returns Self<br>	}<br>	<br>	// Possible alternative to generic syntax:<br>	func removingCommonPrefix(_ one: Collection, _ two: Collection) -&gt; (one.Type.SubSequence, two.Type.SubSequence) where one.Type.Element == two.Type.Element, one.Type.Element: Equatable {<br>		for (oneIndex, twoIndex) in zip(one.indices + [one.endIndex], two.indices + [two.endIndex]) {<br>			if oneIndex == one.endIndex || twoIndex == two.endIndex || one[oneIndex] != two[twoIndex] {<br>				return (one.suffixFrom(oneIndex), two.suffixFrom(twoIndex))<br>			}<br>		}<br>		fatalError(&quot;Can&#39;t get here&quot;)<br>	}<br></p><p>But I&#39;m even *less* certain that `someVariable.Type` and `SomeClass.Type` are similar in any real sense, so I have my doubts about the wisdom of that one.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
