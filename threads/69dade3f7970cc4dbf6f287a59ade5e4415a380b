<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff7b13b7925cd296f0492251f6d700b4?s=50"></div><header><strong>Support for pure setters</strong> from <string>David James</string> &lt;davidbjames1 at gmail.com&gt;<p>January  7, 2016 at 04:00:00pm</p></header><div class="content"><p>Currently Swift has computed properties that support get or get and set, but not set only. There are use cases where we would want set only. <br></p><p>For example, toggling a boolean which changes another stored property where it would be overkill to make a method for that. It&#39;s more intuitive to just assign a boolean. e.g. myObject.myBoolean = true<br></p><p>Another example, setting an object that is introspected in order to create a new object which is then stored on a different property. The property that is stored could be readonly/get, for example. A method for the setter (e.g. setSomething) would not be as intuitive as just a plain assignment (e.g. myObject.something = ..). <br></p><p>Another consideration is that a pure setter would support better information hiding. You may not want the parent object to expose the property. Example scenario: set a property on an object (via assignment), which creates/modifies a stored property based on the passed (set) value, and then pass the parent object to another part of the system which can than read the stored property but not the original set property — i.e. you may not want to expose the original set property to another part of the system.<br></p><p>Example:<br></p><p>var myProperty:MyClass {<br>    set {<br>        …<br>    }<br>}<br></p><p>One concern is that without ‘get’ there really is no property at all, and perhaps this is the reason that pure setter was never included. However, this does not invalidate the above.<br></p><p>As an alternative (to make it more semantically sensible) we could introduce a new keyword ‘set’, so:<br></p><p>set myProperty:MyClass {<br>    ...<br>}<br></p><p>Which would support simple assignment:<br></p><p>myObject.myProperty = myOtherObject<br></p><p>Finally, it’s important to know that this is still “computed&quot;, but only computed on the input, not on the output side.<br></p><p>David James<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/69da380b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Support for pure setters</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>.NET has them and I never felt that I needed them. For me, a property implies something that can be looked up.<br></p><p>What&#39;s the downside of using a method?<br></p><p>Félix<br></p><p>&gt; Le 7 janv. 2016 à 10:47:20, David James via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Currently Swift has computed properties that support get or get and set, but not set only. There are use cases where we would want set only. <br>&gt; <br>&gt; For example, toggling a boolean which changes another stored property where it would be overkill to make a method for that. It&#39;s more intuitive to just assign a boolean. e.g. myObject.myBoolean = true<br>&gt; <br>&gt; Another example, setting an object that is introspected in order to create a new object which is then stored on a different property. The property that is stored could be readonly/get, for example. A method for the setter (e.g. setSomething) would not be as intuitive as just a plain assignment (e.g. myObject.something = ..). <br>&gt; <br>&gt; Another consideration is that a pure setter would support better information hiding. You may not want the parent object to expose the property. Example scenario: set a property on an object (via assignment), which creates/modifies a stored property based on the passed (set) value, and then pass the parent object to another part of the system which can than read the stored property but not the original set property — i.e. you may not want to expose the original set property to another part of the system.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; var myProperty:MyClass {<br>&gt;     set {<br>&gt;         …<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; One concern is that without ‘get’ there really is no property at all, and perhaps this is the reason that pure setter was never included. However, this does not invalidate the above.<br>&gt; <br>&gt; As an alternative (to make it more semantically sensible) we could introduce a new keyword ‘set’, so:<br>&gt; <br>&gt; set myProperty:MyClass {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; Which would support simple assignment:<br>&gt; <br>&gt; myObject.myProperty = myOtherObject<br>&gt; <br>&gt; Finally, it’s important to know that this is still “computed&quot;, but only computed on the input, not on the output side.<br>&gt; <br>&gt; David James<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/d8a6e8d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff7b13b7925cd296f0492251f6d700b4?s=50"></div><header><strong>Support for pure setters</strong> from <string>David James</string> &lt;davidbjames1 at gmail.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Perhaps “pure setters” is a misnomer. Probably more accurate would be to call it a “computed setter”?<br></p><p>To your point about properties being for lookup, understandable. That’s why I suggested introducing the “set” keyword instead of using var .. set.<br></p><p>The downside of using a method is it’s just not as convenient/elegant to use than simple assignment.<br></p><p>David<br></p><p>&gt; On Jan 7, 2016, at 6:16 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; .NET has them and I never felt that I needed them. For me, a property implies something that can be looked up.<br>&gt; <br>&gt; What&#39;s the downside of using a method?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 7 janv. 2016 à 10:47:20, David James via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Currently Swift has computed properties that support get or get and set, but not set only. There are use cases where we would want set only. <br>&gt;&gt; <br>&gt;&gt; For example, toggling a boolean which changes another stored property where it would be overkill to make a method for that. It&#39;s more intuitive to just assign a boolean. e.g. myObject.myBoolean = true<br>&gt;&gt; <br>&gt;&gt; Another example, setting an object that is introspected in order to create a new object which is then stored on a different property. The property that is stored could be readonly/get, for example. A method for the setter (e.g. setSomething) would not be as intuitive as just a plain assignment (e.g. myObject.something = ..). <br>&gt;&gt; <br>&gt;&gt; Another consideration is that a pure setter would support better information hiding. You may not want the parent object to expose the property. Example scenario: set a property on an object (via assignment), which creates/modifies a stored property based on the passed (set) value, and then pass the parent object to another part of the system which can than read the stored property but not the original set property — i.e. you may not want to expose the original set property to another part of the system.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; var myProperty:MyClass {<br>&gt;&gt;     set {<br>&gt;&gt;         …<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One concern is that without ‘get’ there really is no property at all, and perhaps this is the reason that pure setter was never included. However, this does not invalidate the above.<br>&gt;&gt; <br>&gt;&gt; As an alternative (to make it more semantically sensible) we could introduce a new keyword ‘set’, so:<br>&gt;&gt; <br>&gt;&gt; set myProperty:MyClass {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which would support simple assignment:<br>&gt;&gt; <br>&gt;&gt; myObject.myProperty = myOtherObject<br>&gt;&gt; <br>&gt;&gt; Finally, it’s important to know that this is still “computed&quot;, but only computed on the input, not on the output side.<br>&gt;&gt; <br>&gt;&gt; David James<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>David James<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/07e5d261/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff7b13b7925cd296f0492251f6d700b4?s=50"></div><header><strong>Support for pure setters</strong> from <string>David James</string> &lt;davidbjames1 at gmail.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Sorry, there already is “set” keyword, but allow it to be used in place of “var”.<br></p><p>&gt; On Jan 7, 2016, at 6:31 PM, David James &lt;davidbjames1 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Perhaps “pure setters” is a misnomer. Probably more accurate would be to call it a “computed setter”?<br>&gt; <br>&gt; To your point about properties being for lookup, understandable. That’s why I suggested introducing the “set” keyword instead of using var .. set.<br>&gt; <br>&gt; The downside of using a method is it’s just not as convenient/elegant to use than simple assignment.<br>&gt; <br>&gt; David<br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 6:16 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; .NET has them and I never felt that I needed them. For me, a property implies something that can be looked up.<br>&gt;&gt; <br>&gt;&gt; What&#39;s the downside of using a method?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 7 janv. 2016 à 10:47:20, David James via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently Swift has computed properties that support get or get and set, but not set only. There are use cases where we would want set only. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, toggling a boolean which changes another stored property where it would be overkill to make a method for that. It&#39;s more intuitive to just assign a boolean. e.g. myObject.myBoolean = true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another example, setting an object that is introspected in order to create a new object which is then stored on a different property. The property that is stored could be readonly/get, for example. A method for the setter (e.g. setSomething) would not be as intuitive as just a plain assignment (e.g. myObject.something = ..). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another consideration is that a pure setter would support better information hiding. You may not want the parent object to expose the property. Example scenario: set a property on an object (via assignment), which creates/modifies a stored property based on the passed (set) value, and then pass the parent object to another part of the system which can than read the stored property but not the original set property — i.e. you may not want to expose the original set property to another part of the system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var myProperty:MyClass {<br>&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;         …<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One concern is that without ‘get’ there really is no property at all, and perhaps this is the reason that pure setter was never included. However, this does not invalidate the above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As an alternative (to make it more semantically sensible) we could introduce a new keyword ‘set’, so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; set myProperty:MyClass {<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which would support simple assignment:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; myObject.myProperty = myOtherObject<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, it’s important to know that this is still “computed&quot;, but only computed on the input, not on the output side.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David James<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; David James<br>&gt; <br></p><p>David James<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/787dbe06/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Support for pure setters</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  8, 2016 at 08:00:00am</p></header><div class="content"><p>Set-only properties are problematic for Swift, because it relies on being able to do writeback in many more cases than Objective-C. A set-only property will be constrained in several surprising ways. For instance, it would be impossible to drill down to a component of a set-only value type property, because this:<br></p><p>var foo: Struct { get { ... } set { ... } }<br>foo.x = value<br></p><p>is really performing this behind the scenes:<br></p><p>var tmp = foo // invoke getter<br>tmp.x = value<br>foo = tmp // invoke setter<br></p><p>but we would have no getter in this case to initialize the temporary with. You also wouldn&#39;t be able to use the property as an &#39;inout&#39; parameter or do many of the other things you expect to be able to do with a mutable property. A set-only property is so limited I don&#39;t think it really feels like a property at all anymore. These restrictions are far more obvious if you express the interface as a function rather than a property.<br></p><p>-Joe<br></p><p>&gt; On Jan 7, 2016, at 7:47 AM, David James via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently Swift has computed properties that support get or get and set, but not set only. There are use cases where we would want set only. <br>&gt; <br>&gt; For example, toggling a boolean which changes another stored property where it would be overkill to make a method for that. It&#39;s more intuitive to just assign a boolean. e.g. myObject.myBoolean = true<br>&gt; <br>&gt; Another example, setting an object that is introspected in order to create a new object which is then stored on a different property. The property that is stored could be readonly/get, for example. A method for the setter (e.g. setSomething) would not be as intuitive as just a plain assignment (e.g. myObject.something = ..). <br>&gt; <br>&gt; Another consideration is that a pure setter would support better information hiding. You may not want the parent object to expose the property. Example scenario: set a property on an object (via assignment), which creates/modifies a stored property based on the passed (set) value, and then pass the parent object to another part of the system which can than read the stored property but not the original set property — i.e. you may not want to expose the original set property to another part of the system.<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; var myProperty:MyClass {<br>&gt;     set {<br>&gt;         …<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; One concern is that without ‘get’ there really is no property at all, and perhaps this is the reason that pure setter was never included. However, this does not invalidate the above.<br>&gt; <br>&gt; As an alternative (to make it more semantically sensible) we could introduce a new keyword ‘set’, so:<br>&gt; <br>&gt; set myProperty:MyClass {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; Which would support simple assignment:<br>&gt; <br>&gt; myObject.myProperty = myOtherObject<br>&gt; <br>&gt; Finally, it’s important to know that this is still “computed&quot;, but only computed on the input, not on the output side.<br>&gt; <br>&gt; David James<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/128c0f61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff7b13b7925cd296f0492251f6d700b4?s=50"></div><header><strong>Support for pure setters</strong> from <string>David James</string> &lt;davidbjames1 at gmail.com&gt;<p>January  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Is this true even if there is a getter that is private? e.g. private(get) (see my latest reply before this one)<br></p><p>&gt; On Jan 8, 2016, at 5:51 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Set-only properties are problematic for Swift, because it relies on being able to do writeback in many more cases than Objective-C. A set-only property will be constrained in several surprising ways. For instance, it would be impossible to drill down to a component of a set-only value type property, because this:<br>&gt; <br>&gt; var foo: Struct { get { ... } set { ... } }<br>&gt; foo.x = value<br>&gt; <br>&gt; is really performing this behind the scenes:<br>&gt; <br>&gt; var tmp = foo // invoke getter<br>&gt; tmp.x = value<br>&gt; foo = tmp // invoke setter<br>&gt; <br>&gt; but we would have no getter in this case to initialize the temporary with. You also wouldn&#39;t be able to use the property as an &#39;inout&#39; parameter or do many of the other things you expect to be able to do with a mutable property. A set-only property is so limited I don&#39;t think it really feels like a property at all anymore. These restrictions are far more obvious if you express the interface as a function rather than a property.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 7:47 AM, David James via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently Swift has computed properties that support get or get and set, but not set only. There are use cases where we would want set only. <br>&gt;&gt; <br>&gt;&gt; For example, toggling a boolean which changes another stored property where it would be overkill to make a method for that. It&#39;s more intuitive to just assign a boolean. e.g. myObject.myBoolean = true<br>&gt;&gt; <br>&gt;&gt; Another example, setting an object that is introspected in order to create a new object which is then stored on a different property. The property that is stored could be readonly/get, for example. A method for the setter (e.g. setSomething) would not be as intuitive as just a plain assignment (e.g. myObject.something = ..). <br>&gt;&gt; <br>&gt;&gt; Another consideration is that a pure setter would support better information hiding. You may not want the parent object to expose the property. Example scenario: set a property on an object (via assignment), which creates/modifies a stored property based on the passed (set) value, and then pass the parent object to another part of the system which can than read the stored property but not the original set property — i.e. you may not want to expose the original set property to another part of the system.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; var myProperty:MyClass {<br>&gt;&gt;     set {<br>&gt;&gt;         …<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One concern is that without ‘get’ there really is no property at all, and perhaps this is the reason that pure setter was never included. However, this does not invalidate the above.<br>&gt;&gt; <br>&gt;&gt; As an alternative (to make it more semantically sensible) we could introduce a new keyword ‘set’, so:<br>&gt;&gt; <br>&gt;&gt; set myProperty:MyClass {<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which would support simple assignment:<br>&gt;&gt; <br>&gt;&gt; myObject.myProperty = myOtherObject<br>&gt;&gt; <br>&gt;&gt; Finally, it’s important to know that this is still “computed&quot;, but only computed on the input, not on the output side.<br>&gt;&gt; <br>&gt;&gt; David James<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>David James<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/72902ecd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Support for pure setters</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 9:23 AM, David James &lt;davidbjames1 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Is this true even if there is a getter that is private? e.g. private(get) (see my latest reply before this one)<br></p><p>Yeah. If you can&#39;t see the getter, then the property is effectively set-only to you and has all the same problems.<br></p><p>-Joe<br></p><p>&gt;&gt; On Jan 8, 2016, at 5:51 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Set-only properties are problematic for Swift, because it relies on being able to do writeback in many more cases than Objective-C. A set-only property will be constrained in several surprising ways. For instance, it would be impossible to drill down to a component of a set-only value type property, because this:<br>&gt;&gt; <br>&gt;&gt; var foo: Struct { get { ... } set { ... } }<br>&gt;&gt; foo.x = value<br>&gt;&gt; <br>&gt;&gt; is really performing this behind the scenes:<br>&gt;&gt; <br>&gt;&gt; var tmp = foo // invoke getter<br>&gt;&gt; tmp.x = value<br>&gt;&gt; foo = tmp // invoke setter<br>&gt;&gt; <br>&gt;&gt; but we would have no getter in this case to initialize the temporary with. You also wouldn&#39;t be able to use the property as an &#39;inout&#39; parameter or do many of the other things you expect to be able to do with a mutable property. A set-only property is so limited I don&#39;t think it really feels like a property at all anymore. These restrictions are far more obvious if you express the interface as a function rather than a property.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 7:47 AM, David James via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently Swift has computed properties that support get or get and set, but not set only. There are use cases where we would want set only. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, toggling a boolean which changes another stored property where it would be overkill to make a method for that. It&#39;s more intuitive to just assign a boolean. e.g. myObject.myBoolean = true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another example, setting an object that is introspected in order to create a new object which is then stored on a different property. The property that is stored could be readonly/get, for example. A method for the setter (e.g. setSomething) would not be as intuitive as just a plain assignment (e.g. myObject.something = ..). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another consideration is that a pure setter would support better information hiding. You may not want the parent object to expose the property. Example scenario: set a property on an object (via assignment), which creates/modifies a stored property based on the passed (set) value, and then pass the parent object to another part of the system which can than read the stored property but not the original set property — i.e. you may not want to expose the original set property to another part of the system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var myProperty:MyClass {<br>&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;         …<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One concern is that without ‘get’ there really is no property at all, and perhaps this is the reason that pure setter was never included. However, this does not invalidate the above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As an alternative (to make it more semantically sensible) we could introduce a new keyword ‘set’, so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; set myProperty:MyClass {<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which would support simple assignment:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; myObject.myProperty = myOtherObject<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, it’s important to know that this is still “computed&quot;, but only computed on the input, not on the output side.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David James<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; David James<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/61383034/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff7b13b7925cd296f0492251f6d700b4?s=50"></div><header><strong>Support for pure setters</strong> from <string>David James</string> &lt;davidbjames1 at gmail.com&gt;<p>January  8, 2016 at 07:00:00pm</p></header><div class="content"><p>Let me ask you this. If the drawbacks in implementation did not exist, would this be an improvement worth adding?<br></p><p>My sense is yes, since it fills out functionality already half-way there (via private(set)).<br></p><p>&gt; On Jan 8, 2016, at 7:00 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 9:23 AM, David James &lt;davidbjames1 at gmail.com &lt;mailto:davidbjames1 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is this true even if there is a getter that is private? e.g. private(get) (see my latest reply before this one)<br>&gt; <br>&gt; Yeah. If you can&#39;t see the getter, then the property is effectively set-only to you and has all the same problems.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 5:51 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Set-only properties are problematic for Swift, because it relies on being able to do writeback in many more cases than Objective-C. A set-only property will be constrained in several surprising ways. For instance, it would be impossible to drill down to a component of a set-only value type property, because this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var foo: Struct { get { ... } set { ... } }<br>&gt;&gt;&gt; foo.x = value<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is really performing this behind the scenes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var tmp = foo // invoke getter<br>&gt;&gt;&gt; tmp.x = value<br>&gt;&gt;&gt; foo = tmp // invoke setter<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but we would have no getter in this case to initialize the temporary with. You also wouldn&#39;t be able to use the property as an &#39;inout&#39; parameter or do many of the other things you expect to be able to do with a mutable property. A set-only property is so limited I don&#39;t think it really feels like a property at all anymore. These restrictions are far more obvious if you express the interface as a function rather than a property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 7:47 AM, David James via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently Swift has computed properties that support get or get and set, but not set only. There are use cases where we would want set only. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, toggling a boolean which changes another stored property where it would be overkill to make a method for that. It&#39;s more intuitive to just assign a boolean. e.g. myObject.myBoolean = true<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another example, setting an object that is introspected in order to create a new object which is then stored on a different property. The property that is stored could be readonly/get, for example. A method for the setter (e.g. setSomething) would not be as intuitive as just a plain assignment (e.g. myObject.something = ..). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another consideration is that a pure setter would support better information hiding. You may not want the parent object to expose the property. Example scenario: set a property on an object (via assignment), which creates/modifies a stored property based on the passed (set) value, and then pass the parent object to another part of the system which can than read the stored property but not the original set property — i.e. you may not want to expose the original set property to another part of the system.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var myProperty:MyClass {<br>&gt;&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;&gt;         …<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One concern is that without ‘get’ there really is no property at all, and perhaps this is the reason that pure setter was never included. However, this does not invalidate the above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As an alternative (to make it more semantically sensible) we could introduce a new keyword ‘set’, so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; set myProperty:MyClass {<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which would support simple assignment:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; myObject.myProperty = myOtherObject<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, it’s important to know that this is still “computed&quot;, but only computed on the input, not on the output side.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David James<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; David James<br>&gt; <br></p><p>David James<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/efc7af64/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Support for pure setters</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 10:45 AM, David James via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Let me ask you this. If the drawbacks in implementation did not exist, would this be an improvement worth adding?<br></p><p>These are drawbacks in design, not implementation. Swift fundamentally assumes that something mutable can also be read.  Making the model more complex to serve a very narrow use case is not worth it.<br></p><p>&gt; My sense is yes, since it fills out functionality already half-way there (via private(set)).<br></p><p>I see it the opposite way: private(set) gets you so close that there is even less reason to do something here.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
