<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Say you wanted to stride through a singly-linked list, it would actually be beneficial to support only forward strides, the same is true of sequences, as you either may not know what the endpoint is, or would have to step through the whole sequence to find it (plus buffer every value in order to do-so safely).<br>What if you are already somewhere in the middle (perhaps landed there by means of some other reference/link) of that linked list and want to stride backward? <br></p><p><br>&gt;&gt; A consistent behavior with signed distances is so important that we are currently struggling with an interesting issue with floating point types, which is that due to rounding error 10.0 + a - a != 10.0 for some values of a.<br>Of course ! <br>This is known (in computer domain) since ca. 1938.. (Konrad Zuse, with 22-bit floats) <br>(btw I am glad that computer development in this critical war times especially in<br>nazi-Germany was extremely slow, relatively speaking, just imagine...) <br></p><p>So, this should come as no surprise. <br>Precision loss occurs with all arithmetic operations on floats. <br>(in the above case probably the intermediate <br>expression evaluation around the  !=  ,  <br>Compiler optimization may also cause<br>even further reduction of floating point precision )<br></p><p>Obviously, when working with floating point numbers <br>one must always be aware of this and design/program <br>accordingly.  This should become second nature.<br></p><p>E.g. it is perfectly acceptable and known (also in classical for-loops) <br>that  <br>    (0.0…1.0).by(0.1)<br>is not guaranteed to reach the humanly expected value of 1.0.<br></p><p>Due to the nature of what mostly is done in the floating point numbers domain, <br>this does not often cause problems (e.g like working with a slide ruler) <br></p><p>if it is important to reach the “expected end” then one could<br>-add a precision loss compensating value like so <br>      (v1…v2 + 0.1) <br>-or generate the desired float sequence within an integer loop **<br></p><p>The whole point with stride() here is perhaps because the attempt<br>to treat Continuous Data (floats)   as   Discrete Data (Integers) ?  <br></p><p>What about range operator?   <br>   with floats,  (a…b)  will never work correctly    (accept this as normal, inherent with floats) <br></p><p>I’d suggest <br>    (a&lt;.&lt;b)  or  (b&lt;..&lt;a) ,  depending on whether a &lt; b or b &lt; a<br></p><p>In the stride function, swap a and b depending on the sign of the step value <br>(see a previous email from me for an example, I also had<br>a bounds tolerance factor implemented in that code<br>as an attempt to cope with float boundary “problems” )<br></p><p>** The whole problem would disappear  if one would generate the desired float collection within an integer iteration<br>e.g.<br></p><p>   for i in 0..&lt;10 <br>   {<br>       ar.append(vstart + Double(i) * vstep)<br>   }<br></p><p><br>https://en.wikipedia.org/wiki/Floating_point,<br>especially the topic &quot;Minimizing the effect of accuracy problems” might be interesting here.<br></p><p>n.b. in Pascal, the for loop has also a “downto” keyword.<br></p><p><br>Kind regards<br></p><p>TedvG<br></p><p><br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160410/000b3876/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 10 Apr 2016, at 22:44, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Say you wanted to stride through a singly-linked list, it would actually be beneficial to support only forward strides, the same is true of sequences, as you either may not know what the endpoint is, or would have to step through the whole sequence to find it (plus buffer every value in order to do-so safely).<br>&gt; What if you are already somewhere in the middle (perhaps landed there by means of some other reference/link) of that linked list and want to stride backward? <br></p><p>You can’t; if it’s singly-linked then there’s no way to do that directly with the target of O(1) complexity, i.e- for every step backward you’d have to start again from the beginning of the list and step forward till you reach the correct element, which would make it O(n) performance. For this reason, a singly linked list would want to provide only a ForwardIndex, as it isn’t suited to stepping backwards through its elements (that’s what a doubly-linked list is for, at the cost of even more overhead).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April 11, 2016 at 11:00:00am</p></header><div class="content"><p>ah, you&#39;re right about that! <br>somehow there was a doubly linked list in my head, sorry.<br></p><p>TedvG<br></p><p>&gt; On 11 Apr 2016, at 11:20, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 10 Apr 2016, at 22:44, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Say you wanted to stride through a singly-linked list, it would actually be beneficial to support only forward strides, the same is true of sequences, as you either may not know what the endpoint is, or would have to step through the whole sequence to find it (plus buffer every value in order to do-so safely).<br>&gt;&gt; What if you are already somewhere in the middle (perhaps landed there by means of some other reference/link) of that linked list and want to stride backward?<br>&gt; <br>&gt; You can’t; if it’s singly-linked then there’s no way to do that directly with the target of O(1) complexity, i.e- for every step backward you’d have to start again from the beginning of the list and step forward till you reach the correct element, which would make it O(n) performance. For this reason, a singly linked list would want to provide only a ForwardIndex, as it isn’t suited to stepping backwards through its elements (that’s what a doubly-linked list is for, at the cost of even more overhead).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/8154f6bd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
