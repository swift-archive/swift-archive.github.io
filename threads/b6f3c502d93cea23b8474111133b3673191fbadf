<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Feb 02 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Awesome for putting this together. I think the rules add some needed<br>&gt; clarity, but they have the bias that the first argument *should* have<br>&gt; a defaulted empty parameter label. <br></p><p>I disagree with this as a premise.  IMO they don&#39;t have any such bias.<br>The guideline says, only under these very specific conditions does one<br>omit an argument label.  That would indicate, if anything, a bias<br>towards *having* a label.<br></p><p>Since you used the phrase “a defaulted empty parameter label,” it sounds<br>like you&#39;re talking about language rules for deciding whether there&#39;s an<br>argument label based on what you write in the declaration.  I *really*<br>don&#39;t want to discuss that in this thread.<br></p><p>Between the two points above, I don&#39;t know whether to try to analyze<br>what you wrote below.  Have I misunderstood?  Please advise.<br></p><p>&gt; Instead, if the premise was that the first argument is treated no<br>&gt; differently then other arguments, then the rule becomes simply a list<br>&gt; of exceptions on when the label is not necessary:<br>&gt;<br>&gt; If the argument&#39;s purpose in the primary semantics is clear from the<br>&gt; name of the function, then no argument label is required (regardless<br>&gt; of argument position).<br>&gt;<br>&gt; To be clear, this rule does not change the API guidelines statement<br>&gt; that all labelled arguments should be placed after non-labelled<br>&gt; arguments.<br>&gt;<br>&gt; Examples:<br>&gt;<br>&gt; Remove Label(s)<br>&gt;<br>&gt; a.contains(b) // the question of containment of b in a is the primary<br>&gt; semantic<br>&gt; a.merging(b)   // combining b with a is the primary semantic<br>&gt;<br>&gt; a.moveTo(300, 400) // moving to coordinates is a primary semantic of a<br>&gt;                     // the labels can be removed when a has a clear<br>&gt; semantic<br>&gt;                     // limitation of a two-pair coordinate system<br>&gt;<br>&gt; a.readFrom(u, ofType: b) // u is clearly the target of the primary<br>&gt; semantic<br>&gt;                           // &quot;reading&quot;, ofType labeled as it&#39;s a<br>&gt; modifier<br>&gt;<br>&gt; Keep Label(s) - the default behavior<br>&gt;<br>&gt; a.dismiss(animated: b)  // dismissal is the primary semantic;<br>&gt;                         // `animated` is a modifier to that semantic,<br>&gt; so<br>&gt;                         // keep the label<br>&gt;<br>&gt; a.moveTo(x: 300, y: 400) // moving is the primary semantic, however a<br>&gt;                           // has no clear semantic limitation to a 2D<br>&gt;                           // coordinate context so keep the labels<br>&gt;<br>&gt; a.read(from: u, ofType: b) // keep from as there is no non-ambiguous<br>&gt; semantic<br>&gt;                             // relationship between u and what is<br>&gt; being read<br>&gt;                             // without the label. e.g. without from,<br>&gt; it&#39;s not<br>&gt;                             // clear that read is reading from u, it<br>&gt; could read<br>&gt;                             // from stdin.<br>&gt;<br>&gt; The `moveTo` example is also an illustration of why `max` would have<br>&gt; no labels:<br>&gt;<br>&gt; max(x, y)  // maximum value is primary semantic of the parameter set<br>&gt;<br>&gt; I put the `a.readFrom(_:ofType:)` and `a.read(from:ofType:)` as an<br>&gt; illustration of two valid API names that would have different<br>&gt; applications of the rule depending on choice of the first part of the<br>&gt; function identifier. I&#39;ll argue below which I think is better, in the<br>&gt; general case, and the modification of rule #2 to support it.<br>&gt;<br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;<br>&gt;&gt;   should go in the base name rather than in a label:<br>&gt;&gt; <br>&gt;&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt; <br>&gt;&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; <br>&gt;&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;   ambiguous]<br>&gt;&gt; <br>&gt;&gt; Words that describe attributes of an instance *to be created* should<br>&gt;&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;&gt;   initializers):<br>&gt;&gt; <br>&gt;&gt; AudioTrack(mediaType: &quot;BetaMax&quot;) // initializer<br>&gt;&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;<br>&gt; I see this rule as more about how to name the APIs instead of being<br>&gt; about the argument labels. This is also strikes at the root of our<br>&gt; fundamental disagreement that we cannot seem to resolve. =)<br>&gt;<br>&gt; You seem to treat the entire function identifier to two disjoint parts<br>&gt; (please correct me if I&#39;m misunderstanding you): the base name,<br>&gt; including the relationship to the first parameter, and the supporting<br>&gt; labels. The base name is the primary indicator of what the function<br>&gt; does, with the inclusion of how the first argument relates to that<br>&gt; semantic. The remaining argument labels are there mostly as secondary<br>&gt; information.<br>&gt;<br>&gt; a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)<br>&gt; // identifier: tracksHavingMediaType(_:)<br>&gt;<br>&gt; However, I treat the entire identifier as a complete whole with no<br>&gt; real deference to the base name over the argument labels. So the above<br>&gt; example would be broken down like this:<br>&gt;<br>&gt; a.tracksHaving(mediaType: &quot;Wax Cylinder&quot;)<br>&gt; // identifier: tracksHaving(mediaType:)<br>&gt;<br>&gt; **IF** we start with the premise that argument labels are required by<br>&gt; default, the simplified ruleset I used above already answers how to<br>&gt; put the label on regardless of which &quot;base name&quot; you chose.<br>&gt;<br>&gt; I would then change rule #2 to this: the &quot;base name&quot; of the function<br>&gt; describes the semantic intention while the argument labels are used to<br>&gt; describe their relationship to that semantic intention or modification<br>&gt; of how that intent is to be carried out.<br>&gt;<br>&gt; a.tracksHavingMediaType(&quot;Wax Cylinder&quot;) // no, `MediaType` relates to<br>&gt; the argument, not<br>&gt;                                            // primary intent of the<br>&gt; function.<br>&gt;<br>&gt; a.tracksHaving(mediaType: &quot;Wax Cylinder&quot;) // yes, the primary intent<br>&gt; is to find tracks<br>&gt;                                            // based on some criteria.<br>&gt;<br>&gt; No special rules or exceptions are necessary.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;   describe it in the base name.<br>&gt;&gt; <br>&gt;&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt; <br>&gt;&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;<br>&gt; The labelling piece is already covered by the simplified rule #1 above<br>&gt; and by my modified rule #2, so this rule is<br>&gt; redundant. `WithIdentifier` and `WithName` should never be present<br>&gt; because they belong to the first parameter, not to the semantic<br>&gt; intention of the function.<br>&gt;<br>&gt; The choice between `transitionToScene(_:)`, `transitionTo(_:)`, or<br>&gt; even `transitionTo(scene:)` is an interesting one. I do not think<br>&gt; there is an objectively clear winner based on the limited sample<br>&gt; context. Though if we followed the more direct guidance of the<br>&gt; modified rule #2, the only real options left would be:<br>&gt; `transitionTo(_:)` and `transitionTo(scene:)`.<br>&gt;<br>&gt; If `a` were a scene manager and the only transitioning that would take<br>&gt; place, it could be argued that `transitionTo(_:)` is enough.<br>&gt; If `a` were a general transitioning engine, then<br>&gt; `transitionTo(scene:)` would be the choice based on the modified rules<br>&gt; #1 and #2 as the semantic intention of transitioning is clear, but the<br>&gt; target would not be, so the `scene` label would be kept.<br>&gt;<br>&gt; For clarity: `transitionToScene(_:)` would not be a candidate as rule<br>&gt; #2 states that qualifiers for arguments, in this case `Scene`, belong<br>&gt; with the argument itself.<br>&gt;<br>&gt; In the very least, I hope this better articulates why I don&#39;t prefer<br>&gt; the treatment of the first argument as special, and why I do not put<br>&gt; first argument information into the &quot;base name&quot; of the function.<br>&gt;<br>&gt; Cheers!<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February  4, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 2:42 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Feb 02 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Awesome for putting this together. I think the rules add some needed<br>&gt;&gt; clarity, but they have the bias that the first argument *should* have<br>&gt;&gt; a defaulted empty parameter label. <br>&gt; <br>&gt; I disagree with this as a premise.  IMO they don&#39;t have any such bias.<br>&gt; The guideline says, only under these very specific conditions does one<br>&gt; omit an argument label.  That would indicate, if anything, a bias<br>&gt; towards *having* a label.<br></p><p>In one respect, I agree that the guidelines are written with the intention to be more open on the existence of the first argument label. However, when you apply the guidelines, the “very specific conditions” seem to qualify the vast majority of cases. <br></p><p>Plus, there is this:<br></p><p>&gt; For better or worse, it is a requirement that Cocoa as imported very<br>&gt; closely approximates full conformance to the guidelines we choose.  We<br>&gt; are shooting for consistency across APIs used in swift.<br></p><p>And all of the following conversations around it. This is why I say there seems to be a bias towards APIs with not having an argument label.<br></p><p>All that being sad said, my post was really about two things:<br></p><p>  1. clarifying the usage of labels in more than just the first parameter&#39;s slot while also simplifying the rule landscape, and<br>  2. debating rule #2, which really seems about naming APIs, not really about argument label usage<br></p><p>I think my critique is still valid, but I&#39;ll focus it directly on when the label should be present and leave the debate for rule #2 elsewhere. I think the two are orthogonal issues, and sometimes the “better choice&quot; is really subjective to the APIs being built. However, whether the argument label should exist is actually a much more straight forward issue to address.<br></p><p>The stated goals of the proposal were these:<br></p><p>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br></p><p>I think the proposal falls short of the first point: the proposal really only addresses the first argument. There are cases when the other arguments should not be present as well.<br></p><p>If we start with the premise that all parameters should be labeled, then we can have a set of exclusionary rules to help guide the process. I start here because I believe it’s easier to state the cases on when to remove the labels instead of trying to provide rules for both sides.<br></p><p>The rules:<br></p><p>The purpose of an argument label is to provide clear context of the argument’s role within the function. <br></p><p>No argument labels are necessary when:<br></p><p>  1. The parameters have a unambiguous meaning with the intent of the function<br>  2. The label would simply be repeating information that is already explicitly or implicitly derived from the function’s name regarding it’s intent<br></p><p><br>Here are then the examples of good use cases:<br></p><p>No First Argument Labels<br></p><p>a.contains(b)          // yes, satisfies rules 1 and 2<br>a.contains(object: b)  // no, object is adds no value: it’s implicitly there<br></p><p>a.merging(b)         // yes, satisfies rules 1 and 2<br>a.merging(items: b)  // no, items adds no value: it’s implicitly there<br></p><p>a.readFrom(u, ofType: b)          // yes, satisfies rules 1 and 2<br>a.readFrom(source: u, ofType: b)  // no, source is explicitly derived by “From”<br></p><p>a.addObserver(o)            // yes, o has a clear role<br>a.addObserver(observer: o)  // no, duplicating info <br></p><p>a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)             // yes, the first param’s role is clear<br>a.tracksHavingMediaType(mediaType: &quot;Wax Cylinder&quot;)  // no, duplicating info<br></p><p>Keep First Argument Labels Labels<br></p><p>a.dismiss(b)            // no, this seems to be dismissing b<br>a.dismiss(animated: b)  // yes, intent is to dismiss; b is a modifier on how to animate.<br></p><p>a.read(u, ofType: b)          // no, it’s not clear what u’s role is<br>a.read(source: u, ofType: b)  // yes, the source being read is not clear, it could be stdin,<br>                              // or it could be reading from a, etc…<br></p><p>a.tracksHaving(&quot;Wax Cylinder&quot;)             // no, the param’s role is not clear<br>a.tracksHaving(mediaType: &quot;Wax Cylinder&quot;)  // yes, provides clear context for the param<br></p><p>Ambiguous Argument Labels - Really up to the API surface<br></p><p>a.moveTo(x: 300, y: 400)  // it may not be clear that (x,y) is the movement plane<br>a.moveTo(300, 400)        // a may provide explicit context for a 2D plane or coordinates<br></p><p>The non-labeled `moveTo` example is also an illustration of why `max` would have no labels:<br></p><p>max(x, y)        // yes, x&#39;s and y’s role is unambiguous<br>max(a: x, b: y)  // no, there is a clear role for each argument<br></p><p>I think this ruleset is clearer and provides guidance for the various choices that are before us with your rule #2. I also think that arguments on how to name an API like “tracksHavingMediaType” are better left elsewhere. These guidelines still help you decide on the argument placement though regardless of which API works best for your purposes.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/da1b4380/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  5, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Here are then the examples of good use cases:<br>&gt; <br>&gt; No First Argument Labels<br>&gt; <br>&gt; a.readFrom(u, ofType: b)          // yes, satisfies rules 1 and 2<br>&gt; a.readFrom(source: u, ofType: b)  // no, source is explicitly derived by “From”<br>&gt; <br>&gt; Keep First Argument Labels Labels<br>&gt; <br>&gt; a.read(u, ofType: b)          // no, it’s not clear what u’s role is<br>&gt; a.read(source: u, ofType: b)  // yes, the source being read is not clear, it could be stdin,<br></p><p>Okay, but which should it be? `readFrom(_:...)` or `read(source:...)`? These two APIs have very different flavors, and you seem to be saying that either one is okay. That&#39;s not a very good thing if we&#39;re trying to define what &quot;Swifty&quot; APIs look like.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>February  5, 2016 at 06:00:00am</p></header><div class="content"><p>I believe David is saying that&#39;s an orthogonal issue. i.e.<br></p><p>a.readFromSource(u, ofType: b)<br>vs.<br>a.readFrom(source: u, ofType: b)<br>vs.<br>a.read(fromSource: u, ofType: b)<br></p><p>Is a separable issue from:<br></p><p>a.readFrom(source: u, ofType: b)<br>vs.<br>a.readFrom(u, ofType: b)<br></p><p>-or-<br></p><p>a.read(source: u, ofType: b)<br>vs.<br>a.read(u, ofType: b)<br></p><p>I don&#39;t agree they are completely orthogonal since I think we potentially end up with different results based on which order these two issues are addressed, but I still think David&#39;s point is valuable in thinking about What the guidelines should be.<br></p><p><br>On Feb 5, 2016, at 03:37, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Here are then the examples of good use cases:<br>&gt;&gt; <br>&gt;&gt; No First Argument Labels<br>&gt;&gt; <br>&gt;&gt; a.readFrom(u, ofType: b)          // yes, satisfies rules 1 and 2<br>&gt;&gt; a.readFrom(source: u, ofType: b)  // no, source is explicitly derived by “From”<br>&gt;&gt; <br>&gt;&gt; Keep First Argument Labels Labels<br>&gt;&gt; <br>&gt;&gt; a.read(u, ofType: b)          // no, it’s not clear what u’s role is<br>&gt;&gt; a.read(source: u, ofType: b)  // yes, the source being read is not clear, it could be stdin,<br>&gt; <br>&gt; Okay, but which should it be? `readFrom(_:...)` or `read(source:...)`? These two APIs have very different flavors, and you seem to be saying that either one is okay. That&#39;s not a very good thing if we&#39;re trying to define what &quot;Swifty&quot; APIs look like.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February  5, 2016 at 07:00:00am</p></header><div class="content"><p>I&#39;m saying that which one doesn&#39;t matter for how argument labels should be used. <br></p><p>I think the question of which is more &quot;swifty&quot; is a good one to ask. However, I also do not think it always has the same answer. <br></p><p>Sent from my iPhone<br></p><p>On Feb 5, 2016, at 12:37 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Here are then the examples of good use cases:<br>&gt;&gt; <br>&gt;&gt; No First Argument Labels<br>&gt;&gt; <br>&gt;&gt; a.readFrom(u, ofType: b)          // yes, satisfies rules 1 and 2<br>&gt;&gt; a.readFrom(source: u, ofType: b)  // no, source is explicitly derived by “From”<br>&gt;&gt; <br>&gt;&gt; Keep First Argument Labels Labels<br>&gt;&gt; <br>&gt;&gt; a.read(u, ofType: b)          // no, it’s not clear what u’s role is<br>&gt;&gt; a.read(source: u, ofType: b)  // yes, the source being read is not clear, it could be stdin,<br>&gt; <br>&gt; Okay, but which should it be? `readFrom(_:...)` or `read(source:...)`? These two APIs have very different flavors, and you seem to be saying that either one is okay. That&#39;s not a very good thing if we&#39;re trying to define what &quot;Swifty&quot; APIs look like.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
