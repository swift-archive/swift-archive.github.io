<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 12, 2016 at 10:00:00pm</p></header><div class="content"><p>on Tue Oct 11 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Introduction<br>&gt;<br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It<br>&gt; introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt;<br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access<br>&gt; to dictionary values, enabling updates to be performed in-place and allowing copy-on-write<br>&gt; optimization of stored values.<br></p><p>Doing this is a good idea for resilience reasons, if nothing else, as it<br>will allow us to adjust the implementations of these collections without<br>breaking clients.<br></p><p>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt;<br>&gt; This proposal address two problems:<br>&gt;<br>&gt; The Dictionary type keys implementation is inefficient, because<br>&gt; LazyMapCollection doesn&#39;t know how to forward lookups to the<br>&gt; underlying dictionary storage.<br></p><p>I don&#39;t see why traversing a collection of keys should require<br>“lookups,” at least in the normal meaning of the word, which refers to<br>locating a hash entry given a key.<br></p><p>&gt; Dictionaries do not offer value-mutating APIs. <br></p><p>Subscript is a value-mutating API:<br></p><p>  var b = [1:&quot;one&quot;]<br>  b[1]! += &quot;!&quot;<br>  print(b[1]) // &quot;one!&quot;<br>  <br>&gt; The mutating key-based subscript wraps values in an Optional. This<br>&gt; prevents types with copy-on-write optimizations from recognizing they<br>&gt; are singly referenced.  <br></p><p>Yes, that&#39;s an efficiency problem.  I&#39;m not making promises here, but I<br>have good reasons to think we&#39;ll address this issue by fixing the way<br>inout works.  Specifically, we&#39;d prevent (statically where possible)<br>aliased accesses to references that are participating in inout access<br>and thus be able to avoid incrementing their reference counts in these<br>scenarios.<br></p><p>&gt; This proposal uses the following [String: [Int]] dictionary to<br>&gt; demonstrate these problems:<br>&gt;<br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient<br>&gt; dict.keys Search<br>&gt;<br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt;<br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }<br>&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well<br>&gt; nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this<br>&gt; approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt;<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br></p><p>Heh.  dict.keys could get you a Set&lt;Key&gt;<br></p><p>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt;<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient<br>&gt; Value Mutation<br>&gt;<br>&gt; Dictionary values can be modified through the keyed subscript by<br>&gt; direct reassignment or by using optional chaining. Both of these<br>&gt; statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt;<br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt;<br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;<br>&gt; Both approaches present problems. The first is complex and hard to<br>&gt; read. The second ignores the case where &quot;one&quot; is not a key in the<br>&gt; dictionary. <br></p><p>IMO the right way to phrase this is that the semantics of the first<br>approach are much more commonly useful than those of the second.<br></p><p>&gt; It forces its check into a higher branch and encourages forced<br>&gt; unwrapping. <br></p><p>I don&#39;t think that&#39;s a valid argument against anything.  There&#39;s nothing<br>wrong with forced unwrapping.<br></p><p>&gt; Furthermore, neither approach allows the array to grow in place. They<br>&gt; introduce an unnecessary copy of the array&#39;s contents even though dict<br>&gt; is the sole holder of its storage.<br></p><p>Yes.  Here&#39;s the horrible-but-reasonably-efficient way to do this today:<br></p><p> var x: [Int]? = []<br> swap(&amp;x, &amp;dict[&quot;one&quot;])<br> x = x ?? Array(minimumCapacity: 1)<br> x!.append(1)<br> swap(&amp;x, &amp;dict[&quot;one&quot;])<br></p><p>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at<br>&gt; a particular index would almost certainly modify its hash value, rendering the index incorrect. This<br>&gt; violates the requirements of the MutableCollection protocol.<br>&gt;<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; This proposal adds a custom collection for the keys and values<br>&gt; dictionary properties. This follows the example set by String, which<br>&gt; presents multiple views of its contents. A new DictionaryKeys<br>&gt; collection introduces efficient key lookup, while a new<br>&gt; DictionaryValues collection provides a mutable collection interface to<br>&gt; dictionary values.<br>&gt;<br>&gt; These changes introduce a simple and efficient way of checking whether<br>&gt; a dictionary includes a key:<br>&gt;<br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; As a mutable collection, values enables modification without copies or<br>&gt; clumsy code:<br>&gt;<br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br></p><p>Well, I find that a bit clumsy still, but it&#39;s better than what we&#39;ve<br>got.  There&#39;s no reason dict.values shoudn&#39;t be a MutableCollection.<br></p><p>&gt; Both the keys and values collections share the same index type as<br>&gt; Dictionary. This allows the above sample to be rewritten as:<br>&gt;<br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed<br>&gt; design<br></p><p>That is a good point.  It makes me inclined to deprecate index(forKey:)<br></p><p>&gt; The standard library introduces two new collection types:<br>&gt; DictionaryKeys and DictionaryValues.  A Dictionary&#39;s keys and values<br>&gt; property types change from LazyMapCollection to these new types.  The<br>&gt; new collection types are not directly constructable. They are<br>&gt; presented only as views into a dictionary.<br>&gt;<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;<br>&gt;     // Remaining declarations<br>&gt; }<br>&gt;<br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;<br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt;<br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;<br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt;<br>&gt; A sample implementation of this proposal can be found in this branch<br>&gt; &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt;<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The performance improvements of using the new DictionaryKeys type and<br>&gt; the mutability of the DictionaryValuescollection are both additive in<br>&gt; nature.<br>&gt;<br>&gt; Most uses of these properties are transitory in nature. Adopting this<br>&gt; proposal should not produce a major impact on existing code. The only<br>&gt; impact on existing code exists where a program explicitly specifies<br>&gt; the type of a dictionary&#39;s keysor values property. The fix is to<br>&gt; change the specified type.<br>&gt;<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The Generics Manifesto<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt;<br>&gt; lists nested generics as a goal. This could impact the naming and<br>&gt; structure of these new collection types.<br>&gt;<br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and <br>&gt; DictionaryValues&lt;Key, Value&gt;, these types <br>&gt; could be Dictionary&lt;Key, Value&gt;.Keys and<br>&gt; Dictionary&lt;Key, Value&gt;.Values. However, because many types in the<br>&gt; standard library may be revisited once such a feature is available<br>&gt; (indices, iterators, etc.), the current lack of nesting shouldn&#39;t<br>&gt; prevent consideration of this proposal.<br>&gt;<br>&gt; It could be possible to add additional compiler features that manage<br>&gt; mutation through existing key-based subscripting without the<br>&gt; copy-on-write problems of the current implementation. I don&#39;t know<br>&gt; enough about how that would be implemented to speak to its feasibility<br>&gt; or level of effort. Such a feature would reduce the need for a mutable<br>&gt; DictionaryValues collection.<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
