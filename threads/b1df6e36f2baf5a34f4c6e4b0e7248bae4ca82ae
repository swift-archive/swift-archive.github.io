<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>August  9, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;d like to inquire as to what the Swift team thoughts on Go&#39;s concurrency model are?  I&#39;m not referring to convenience of the &#39;go&#39; keyword and nor am I referring to how the language handles Channels, both of which being what most folks associate with it.  Rather, I&#39;d like to ask about the language&#39;s use of Green Threads and how the runtime handles the heavy lifting of multiplexing and scheduling them.  What are some of the strengths and weaknesses the Swift team sees to Go&#39;s approach?<br></p><p>Dan<br></p><p>(DISCLAIMER: I&#39;m posting this for academic reasons, not as a pitch.  While the Swift team&#39;s responses may inform opinions on the matter, I do not want this to turn into a &#39;this is how I think Swift should do concurrency&#39; debate.  That discussion will come when it comes.)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  9, 2016 at 01:00:00pm</p></header><div class="content"><p>The Rust language used to use a green thread model like Go (actually it exposed a configurable threading interface so you could choose green threads or OS threads). It also used segmented stacks like Go did. Over time, Rust ended up dropping the segmented stacks because it significantly complicated FFI without providing much, if any, benefit (and IIRC Go followed suite and dropped segmented stacks somewhere around version 1.5), and then a little while later Rust dropped green threads entirely. If you can find them, there are lots of discussions of the pros and cons that were documented during this process (on mailing lists, in IRC, possibly on Discourse, there&#39;s probably at least one post about it in the Rust subreddit, etc). But ultimately, it was determined that keeping this ability significantly complicated the Rust runtime and it provided almost no benefit. The OS is already really good at scheduling threads, and there&#39;s no memory savings without segmented stacks (though the OS will map virtual pages for the stack and only allocate the backing physical pages as the memory is touched, so even if you have a 2MB stack, a new thread will only actually allocate something like 8kb). And there are some pretty big downsides to green threads, such as the fact that it significantly complicates the runtime since all I/O everywhere has to be nonblocking and it has to be transparent to the code, and FFI ends up as a major problem (even without segmented stacks), because you have no idea if an FFI call will block. Green threading libraries end up having to allocate extra OS threads just to continue servicing the green threads when the existing threads are potentially blocked in FFI.<br></p><p>So ultimately, green threads really only make sense when you control the entire ecosystem, so you can ensure the whole stack is compatible with green threads and won&#39;t ever issue blocking calls, and even there there&#39;s not much benefit and there&#39;s a lot of complexity involved.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Aug 9, 2016, at 12:04 PM, Dan Stenmark via swift-evolution wrote:<br>&gt; I&#39;d like to inquire as to what the Swift team thoughts on Go&#39;s concurrency model are?  I&#39;m not referring to convenience of the &#39;go&#39; keyword and nor am I referring to how the language handles Channels, both of which being what most folks associate with it.  Rather, I&#39;d like to ask about the language&#39;s use of Green Threads and how the runtime handles the heavy lifting of multiplexing and scheduling them.  What are some of the strengths and weaknesses the Swift team sees to Go&#39;s approach?<br>&gt; <br>&gt; Dan<br>&gt; <br>&gt; (DISCLAIMER: I&#39;m posting this for academic reasons, not as a pitch.  While the Swift team&#39;s responses may inform opinions on the matter, I do not want this to turn into a &#39;this is how I think Swift should do concurrency&#39; debate.  That discussion will come when it comes.)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 1:28 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The Rust language used to use a green thread model like Go (actually it exposed a configurable threading interface so you could choose green threads or OS threads). It also used segmented stacks like Go did. Over time, Rust ended up dropping the segmented stacks because it significantly complicated FFI without providing much, if any, benefit (and IIRC Go followed suite and dropped segmented stacks somewhere around version 1.5), and then a little while later Rust dropped green threads entirely. If you can find them, there are lots of discussions of the pros and cons that were documented during this process (on mailing lists, in IRC, possibly on Discourse, there&#39;s probably at least one post about it in the Rust subreddit, etc). But ultimately, it was determined that keeping this ability significantly complicated the Rust runtime and it provided almost no benefit. The OS is already really good at scheduling threads, and there&#39;s no memory savings without segmented stacks (though the OS will map virtual pages for the stack and only allocate the backing physical pages as the memory is touched, so even if you have a 2MB stack, a new thread will only actually allocate something like 8kb). And there are some pretty big downsides to green threads, such as the fact that it significantly complicates the runtime since all I/O everywhere has to be nonblocking and it has to be transparent to the code, and FFI ends up as a major problem (even without segmented stacks), because you have no idea if an FFI call will block. Green threading libraries end up having to allocate extra OS threads just to continue servicing the green threads when the existing threads are potentially blocked in FFI.<br>&gt; <br>&gt; So ultimately, green threads really only make sense when you control the entire ecosystem, so you can ensure the whole stack is compatible with green threads and won&#39;t ever issue blocking calls, and even there there&#39;s not much benefit and there&#39;s a lot of complexity involved.<br></p><p>In addition to FFI, there&#39;s also no way for memory-mapped IO to be non-blocking (a page fault can only be handled by the kernel, after all).<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>August  9, 2016 at 10:00:00pm</p></header><div class="content"><p>Talking about green threads, are they similar to fibers? http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine<br></p><p>Sent from my iPhone<br></p><p>&gt; On 9 Aug 2016, at 21:59, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 9, 2016, at 1:28 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The Rust language used to use a green thread model like Go (actually it exposed a configurable threading interface so you could choose green threads or OS threads). It also used segmented stacks like Go did. Over time, Rust ended up dropping the segmented stacks because it significantly complicated FFI without providing much, if any, benefit (and IIRC Go followed suite and dropped segmented stacks somewhere around version 1.5), and then a little while later Rust dropped green threads entirely. If you can find them, there are lots of discussions of the pros and cons that were documented during this process (on mailing lists, in IRC, possibly on Discourse, there&#39;s probably at least one post about it in the Rust subreddit, etc). But ultimately, it was determined that keeping this ability significantly complicated the Rust runtime and it provided almost no benefit. The OS is already really good at scheduling threads, and there&#39;s no memory savings without segmented stacks (though the OS will map virtual pages for the stack and only allocate the backing physical pages as the memory is touched, so even if you have a 2MB stack, a new thread will only actually allocate something like 8kb). And there are some pretty big downsides to green threads, such as the fact that it significantly complicates the runtime since all I/O everywhere has to be nonblocking and it has to be transparent to the code, and FFI ends up as a major problem (even without segmented stacks), because you have no idea if an FFI call will block. Green threading libraries end up having to allocate extra OS threads just to continue servicing the green threads when the existing threads are potentially blocked in FFI.<br>&gt;&gt; <br>&gt;&gt; So ultimately, green threads really only make sense when you control the entire ecosystem, so you can ensure the whole stack is compatible with green threads and won&#39;t ever issue blocking calls, and even there there&#39;s not much benefit and there&#39;s a lot of complexity involved.<br>&gt; <br>&gt; In addition to FFI, there&#39;s also no way for memory-mapped IO to be non-blocking (a page fault can only be handled by the kernel, after all).<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/836cd456/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 10, 2016 at 07:00:00am</p></header><div class="content"><p>According to http://c9x.me/art/gthreads/intro.html &lt;http://c9x.me/art/gthreads/intro.html&gt; I would guess so - pretty much userland threads - swapping context without kernel.<br></p><p><br>&gt; On Aug 9, 2016, at 11:07 PM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Talking about green threads, are they similar to fibers? http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine &lt;http://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine&gt;<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 9 Aug 2016, at 21:59, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 9, 2016, at 1:28 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Rust language used to use a green thread model like Go (actually it exposed a configurable threading interface so you could choose green threads or OS threads). It also used segmented stacks like Go did. Over time, Rust ended up dropping the segmented stacks because it significantly complicated FFI without providing much, if any, benefit (and IIRC Go followed suite and dropped segmented stacks somewhere around version 1.5), and then a little while later Rust dropped green threads entirely. If you can find them, there are lots of discussions of the pros and cons that were documented during this process (on mailing lists, in IRC, possibly on Discourse, there&#39;s probably at least one post about it in the Rust subreddit, etc). But ultimately, it was determined that keeping this ability significantly complicated the Rust runtime and it provided almost no benefit. The OS is already really good at scheduling threads, and there&#39;s no memory savings without segmented stacks (though the OS will map virtual pages for the stack and only allocate the backing physical pages as the memory is touched, so even if you have a 2MB stack, a new thread will only actually allocate something like 8kb). And there are some pretty big downsides to green threads, such as the fact that it significantly complicates the runtime since all I/O everywhere has to be nonblocking and it has to be transparent to the code, and FFI ends up as a major problem (even without segmented stacks), because you have no idea if an FFI call will block. Green threading libraries end up having to allocate extra OS threads just to continue servicing the green threads when the existing threads are potentially blocked in FFI.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So ultimately, green threads really only make sense when you control the entire ecosystem, so you can ensure the whole stack is compatible with green threads and won&#39;t ever issue blocking calls, and even there there&#39;s not much benefit and there&#39;s a lot of complexity involved.<br>&gt;&gt; <br>&gt;&gt; In addition to FFI, there&#39;s also no way for memory-mapped IO to be non-blocking (a page fault can only be handled by the kernel, after all).<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160810/8f27c920/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 1:59 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 9, 2016, at 1:28 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The Rust language used to use a green thread model like Go (actually it exposed a configurable threading interface so you could choose green threads or OS threads). It also used segmented stacks like Go did. Over time, Rust ended up dropping the segmented stacks because it significantly complicated FFI without providing much, if any, benefit (and IIRC Go followed suite and dropped segmented stacks somewhere around version 1.5), and then a little while later Rust dropped green threads entirely. If you can find them, there are lots of discussions of the pros and cons that were documented during this process (on mailing lists, in IRC, possibly on Discourse, there&#39;s probably at least one post about it in the Rust subreddit, etc). But ultimately, it was determined that keeping this ability significantly complicated the Rust runtime and it provided almost no benefit. The OS is already really good at scheduling threads, and there&#39;s no memory savings without segmented stacks (though the OS will map virtual pages for the stack and only allocate the backing physical pages as the memory is touched, so even if you have a 2MB stack, a new thread will only actually allocate something like 8kb). And there are some pretty big downsides to green threads, such as the fact that it significantly complicates the runtime since all I/O everywhere has to be nonblocking and it has to be transparent to the code, and FFI ends up as a major problem (even without segmented stacks), because you have no idea if an FFI call will block. Green threading libraries end up having to allocate extra OS threads just to continue servicing the green threads when the existing threads are potentially blocked in FFI.<br>&gt;&gt; <br>&gt;&gt; So ultimately, green threads really only make sense when you control the entire ecosystem, so you can ensure the whole stack is compatible with green threads and won&#39;t ever issue blocking calls, and even there there&#39;s not much benefit and there&#39;s a lot of complexity involved.<br>&gt; <br>&gt; In addition to FFI, there&#39;s also no way for memory-mapped IO to be non-blocking (a page fault can only be handled by the kernel, after all).<br></p><p>Even buffered file I/O via read(2) and write(2) is blocking on most *nix platforms. AFAIK there&#39;s some work being done on non-blocking buffered reads on Linux, but it appears to be a completely new API distinct from the existing epoll for sockets or aio_* for direct file I/O, and of course Darwin doesn&#39;t have an equivalent.<br></p><p>Slava<br></p><p>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160810/79647235/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August 11, 2016 at 10:00:00am</p></header><div class="content"><p>For anyone interested in reading more about Rust&#39;s decisions, here&#39;s two links:<br></p><p>The email about abandoning segmented stacks: https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html<br></p><p>The RFC to remove green threading, with motivation: https://github.com/aturon/rfcs/blob/remove-runtime/active/0000-remove-runtime.md<br></p><p>-Kevin Ballard<br></p><p>On Tue, Aug 9, 2016, at 01:28 PM, Kevin Ballard wrote:<br>&gt; The Rust language used to use a green thread model like Go (actually it exposed a configurable threading interface so you could choose green threads or OS threads). It also used segmented stacks like Go did. Over time, Rust ended up dropping the segmented stacks because it significantly complicated FFI without providing much, if any, benefit (and IIRC Go followed suite and dropped segmented stacks somewhere around version 1.5), and then a little while later Rust dropped green threads entirely. If you can find them, there are lots of discussions of the pros and cons that were documented during this process (on mailing lists, in IRC, possibly on Discourse, there&#39;s probably at least one post about it in the Rust subreddit, etc). But ultimately, it was determined that keeping this ability significantly complicated the Rust runtime and it provided almost no benefit. The OS is already really good at scheduling threads, and there&#39;s no memory savings without segmented stacks (though the OS will map virtual pages for the stack and only allocate the backing physical pages as the memory is touched, so even if you have a 2MB stack, a new thread will only actually allocate something like 8kb). And there are some pretty big downsides to green threads, such as the fact that it significantly complicates the runtime since all I/O everywhere has to be nonblocking and it has to be transparent to the code, and FFI ends up as a major problem (even without segmented stacks), because you have no idea if an FFI call will block. Green threading libraries end up having to allocate extra OS threads just to continue servicing the green threads when the existing threads are potentially blocked in FFI.<br>&gt; <br>&gt; So ultimately, green threads really only make sense when you control the entire ecosystem, so you can ensure the whole stack is compatible with green threads and won&#39;t ever issue blocking calls, and even there there&#39;s not much benefit and there&#39;s a lot of complexity involved.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Tue, Aug 9, 2016, at 12:04 PM, Dan Stenmark via swift-evolution wrote:<br>&gt; &gt; I&#39;d like to inquire as to what the Swift team thoughts on Go&#39;s concurrency model are?  I&#39;m not referring to convenience of the &#39;go&#39; keyword and nor am I referring to how the language handles Channels, both of which being what most folks associate with it.  Rather, I&#39;d like to ask about the language&#39;s use of Green Threads and how the runtime handles the heavy lifting of multiplexing and scheduling them.  What are some of the strengths and weaknesses the Swift team sees to Go&#39;s approach?<br>&gt; &gt; <br>&gt; &gt; Dan<br>&gt; &gt; <br>&gt; &gt; (DISCLAIMER: I&#39;m posting this for academic reasons, not as a pitch.  While the Swift team&#39;s responses may inform opinions on the matter, I do not want this to turn into a &#39;this is how I think Swift should do concurrency&#39; debate.  That discussion will come when it comes.)<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>August 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks Kevin, I think they have accepted that they do not need to enter<br>every segment of computing so the extra performance they could get on some<br>devices is not worth the risk and the complexity it brings. Not everyone is<br>trying to cram complex 3D experiences at 60-90+ FPS on a console like<br>constrained devices and I guess Rust is not targeting that right now :).<br></p><p>On Thu, Aug 11, 2016 at 6:12 PM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; For anyone interested in reading more about Rust&#39;s decisions, here&#39;s two<br>&gt; links:<br>&gt;<br>&gt; The email about abandoning segmented stacks: https://mail.mozilla.org/<br>&gt; pipermail/rust-dev/2013-November/006314.html<br>&gt;<br>&gt; The RFC to remove green threading, with motivation:<br>&gt; https://github.com/aturon/rfcs/blob/remove-runtime/<br>&gt; active/0000-remove-runtime.md<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Tue, Aug 9, 2016, at 01:28 PM, Kevin Ballard wrote:<br>&gt; &gt; The Rust language used to use a green thread model like Go (actually it<br>&gt; exposed a configurable threading interface so you could choose green<br>&gt; threads or OS threads). It also used segmented stacks like Go did. Over<br>&gt; time, Rust ended up dropping the segmented stacks because it significantly<br>&gt; complicated FFI without providing much, if any, benefit (and IIRC Go<br>&gt; followed suite and dropped segmented stacks somewhere around version 1.5),<br>&gt; and then a little while later Rust dropped green threads entirely. If you<br>&gt; can find them, there are lots of discussions of the pros and cons that were<br>&gt; documented during this process (on mailing lists, in IRC, possibly on<br>&gt; Discourse, there&#39;s probably at least one post about it in the Rust<br>&gt; subreddit, etc). But ultimately, it was determined that keeping this<br>&gt; ability significantly complicated the Rust runtime and it provided almost<br>&gt; no benefit. The OS is already really good at scheduling threads, and<br>&gt; there&#39;s no memory savings without segmented stacks (though the OS will map<br>&gt; virtual pages for the stack and only allocate the backing physical pages as<br>&gt; the memory is touched, so even if you have a 2MB stack, a new thread will<br>&gt; only actually allocate something like 8kb). And there are some pretty big<br>&gt; downsides to green threads, such as the fact that it significantly<br>&gt; complicates the runtime since all I/O everywhere has to be nonblocking and<br>&gt; it has to be transparent to the code, and FFI ends up as a major problem<br>&gt; (even without segmented stacks), because you have no idea if an FFI call<br>&gt; will block. Green threading libraries end up having to allocate extra OS<br>&gt; threads just to continue servicing the green threads when the existing<br>&gt; threads are potentially blocked in FFI.<br>&gt; &gt;<br>&gt; &gt; So ultimately, green threads really only make sense when you control the<br>&gt; entire ecosystem, so you can ensure the whole stack is compatible with<br>&gt; green threads and won&#39;t ever issue blocking calls, and even there there&#39;s<br>&gt; not much benefit and there&#39;s a lot of complexity involved.<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt;<br>&gt; &gt; On Tue, Aug 9, 2016, at 12:04 PM, Dan Stenmark via swift-evolution wrote:<br>&gt; &gt; &gt; I&#39;d like to inquire as to what the Swift team thoughts on Go&#39;s<br>&gt; concurrency model are?  I&#39;m not referring to convenience of the &#39;go&#39;<br>&gt; keyword and nor am I referring to how the language handles Channels, both<br>&gt; of which being what most folks associate with it.  Rather, I&#39;d like to ask<br>&gt; about the language&#39;s use of Green Threads and how the runtime handles the<br>&gt; heavy lifting of multiplexing and scheduling them.  What are some of the<br>&gt; strengths and weaknesses the Swift team sees to Go&#39;s approach?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Dan<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; (DISCLAIMER: I&#39;m posting this for academic reasons, not as a pitch.<br>&gt; While the Swift team&#39;s responses may inform opinions on the matter, I do<br>&gt; not want this to turn into a &#39;this is how I think Swift should do<br>&gt; concurrency&#39; debate.  That discussion will come when it comes.)<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/319c59ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August 11, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;m confused by your email. Rust is all about performance, and embedded<br>devices are one of the targets for Rust. And I can&#39;t think of any<br>language that uses green threading that is appropriate for constrained<br>devices (e.g. Go definitely isn&#39;t appropriate for that). One of the<br>arguments for getting rid of green threading in Rust is that the extra<br>runtime complexity imposed a performance cost.<br></p><p>-Kevin<br></p><p>On Thu, Aug 11, 2016, at 10:36 AM, Goffredo Marocchi wrote:<br>&gt; Thanks Kevin, I think they have accepted that they do not need to<br>&gt; enter every segment of computing so the extra performance they could<br>&gt; get on some devices is not worth the risk and the complexity it<br>&gt; brings. Not everyone is trying to cram complex 3D experiences at 60-<br>&gt; 90+ FPS on a console like constrained devices and I guess Rust is not<br>&gt; targeting that right now :).<br>&gt;<br>&gt; On Thu, Aug 11, 2016 at 6:12 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; For anyone interested in reading more about Rust&#39;s decisions, here&#39;s<br>&gt;&gt; two links:<br>&gt;&gt;<br>&gt;&gt;  The email about abandoning segmented stacks:<br>&gt;&gt;  https://mail.mozilla.org/pipermail/rust-dev/2013-November/006314.html<br>&gt;&gt;<br>&gt;&gt;  The RFC to remove green threading, with motivation:<br>&gt;&gt;  https://github.com/aturon/rfcs/blob/remove-runtime/active/0000-remove-runtime.md<br>&gt;&gt;<br>&gt;&gt;  -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 9, 2016, at 01:28 PM, Kevin Ballard wrote:<br>&gt;&gt;  &gt; The Rust language used to use a green thread model like Go<br>&gt;&gt;  &gt; (actually it exposed a configurable threading interface so you<br>&gt;&gt;  &gt; could choose green threads or OS threads). It also used segmented<br>&gt;&gt;  &gt; stacks like Go did. Over time, Rust ended up dropping the<br>&gt;&gt;  &gt; segmented stacks because it significantly complicated FFI without<br>&gt;&gt;  &gt; providing much, if any, benefit (and IIRC Go followed suite and<br>&gt;&gt;  &gt; dropped segmented stacks somewhere around version 1.5), and then a<br>&gt;&gt;  &gt; little while later Rust dropped green threads entirely. If you can<br>&gt;&gt;  &gt; find them, there are lots of discussions of the pros and cons that<br>&gt;&gt;  &gt; were documented during this process (on mailing lists, in IRC,<br>&gt;&gt;  &gt; possibly on Discourse, there&#39;s probably at least one post about it<br>&gt;&gt;  &gt; in the Rust subreddit, etc). But ultimately, it was determined<br>&gt;&gt;  &gt; that keeping this ability significantly complicated the Rust<br>&gt;&gt;  &gt; runtime and it provided almost no benefit. The OS is already<br>&gt;&gt;  &gt; really good at scheduling threads, and there&#39;s no memory savings<br>&gt;&gt;  &gt; without segmented stacks (though the OS will map virtual pages for<br>&gt;&gt;  &gt; the stack and only allocate the backing physical pages as the<br>&gt;&gt;  &gt; memory is touched, so even if you have a 2MB stack, a new thread<br>&gt;&gt;  &gt; will only actually allocate something like 8kb). And there are<br>&gt;&gt;  &gt; some pretty big downsides to green threads, such as the fact that<br>&gt;&gt;  &gt; it significantly complicates the runtime since all I/O everywhere<br>&gt;&gt;  &gt; has to be nonblocking and it has to be transparent to the code,<br>&gt;&gt;  &gt; and FFI ends up as a major problem (even without segmented<br>&gt;&gt;  &gt; stacks), because you have no idea if an FFI call will block. Green<br>&gt;&gt;  &gt; threading libraries end up having to allocate extra OS threads<br>&gt;&gt;  &gt; just to continue servicing the green threads when the existing<br>&gt;&gt;  &gt; threads are potentially blocked in FFI.<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; So ultimately, green threads really only make sense when you<br>&gt;&gt;  &gt; control the entire ecosystem, so you can ensure the whole stack is<br>&gt;&gt;  &gt; compatible with green threads and won&#39;t ever issue blocking calls,<br>&gt;&gt;  &gt; and even there there&#39;s not much benefit and there&#39;s a lot of<br>&gt;&gt;  &gt; complexity involved.<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; -Kevin Ballard<br>&gt;&gt;  &gt;<br>&gt;&gt;  &gt; On Tue, Aug 9, 2016, at 12:04 PM, Dan Stenmark via swift-evolution<br>&gt;&gt;  &gt; wrote:<br>&gt;&gt;  &gt; &gt; I&#39;d like to inquire as to what the Swift team thoughts on Go&#39;s<br>&gt;&gt;  &gt; &gt; concurrency model are?  I&#39;m not referring to convenience of the<br>&gt;&gt;  &gt; &gt; &#39;go&#39; keyword and nor am I referring to how the language handles<br>&gt;&gt;  &gt; &gt; Channels, both of which being what most folks associate with it.<br>&gt;&gt;  &gt; &gt; Rather, I&#39;d like to ask about the language&#39;s use of Green<br>&gt;&gt;  &gt; &gt; Threads and how the runtime handles the heavy lifting of<br>&gt;&gt;  &gt; &gt; multiplexing and scheduling them.  What are some of the<br>&gt;&gt;  &gt; &gt; strengths and weaknesses the Swift team sees to Go&#39;s approach?<br>&gt;&gt;  &gt; &gt;<br>&gt;&gt;  &gt; &gt; Dan<br>&gt;&gt;  &gt; &gt;<br>&gt;&gt;  &gt; &gt; (DISCLAIMER: I&#39;m posting this for academic reasons, not as a<br>&gt;&gt;  &gt; &gt; pitch.  While the Swift team&#39;s responses may inform opinions on<br>&gt;&gt;  &gt; &gt; the matter, I do not want this to turn into a &#39;this is how I<br>&gt;&gt;  &gt; &gt; think Swift should do concurrency&#39; debate.  That discussion will<br>&gt;&gt;  &gt; &gt; come when it comes.)<br>&gt;&gt;  &gt; &gt; _______________________________________________<br>&gt;&gt;  &gt; &gt; swift-evolution mailing list<br>&gt;&gt;  &gt; &gt; swift-evolution at swift.org<br>&gt;&gt;  &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt;  swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/f1e31cc0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Dan,<br></p><p>As I understand it, a big weakness of Go&#39;s model is that it does not actually prevent data races. There&#39;s nothing preventing you from sharing pointers to mutable values between tasks, but I could be wrong about this.<br></p><p>Slava<br></p><p>&gt; On Aug 9, 2016, at 12:04 PM, Dan Stenmark via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to inquire as to what the Swift team thoughts on Go&#39;s concurrency model are?  I&#39;m not referring to convenience of the &#39;go&#39; keyword and nor am I referring to how the language handles Channels, both of which being what most folks associate with it.  Rather, I&#39;d like to ask about the language&#39;s use of Green Threads and how the runtime handles the heavy lifting of multiplexing and scheduling them.  What are some of the strengths and weaknesses the Swift team sees to Go&#39;s approach?<br>&gt; <br>&gt; Dan<br>&gt; <br>&gt; (DISCLAIMER: I&#39;m posting this for academic reasons, not as a pitch.  While the Swift team&#39;s responses may inform opinions on the matter, I do not want this to turn into a &#39;this is how I think Swift should do concurrency&#39; debate.  That discussion will come when it comes.)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 10, 2016, at 4:48 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As I understand it, a big weakness of Go&#39;s model is that it does not actually prevent data races. There&#39;s nothing preventing you from sharing pointers to mutable values between tasks, but I could be wrong about this.<br>Is that bad? Sharing pointers seems like a cheap way to share data, and as long as you know what you’re doing, why should the language get in the way? Now, if said code really does have performance advantages over the “safer” methods, and it really is safe because for whatever reason the race condition can’t actually happen, the language (or library) ought to have a way to express that without having to write “unsafe” code. In the meantime, though, you’ve gotta ship something that runs and meets performance requirements.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 10, 2016, at 3:22 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 10, 2016, at 4:48 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As I understand it, a big weakness of Go&#39;s model is that it does not actually prevent data races. There&#39;s nothing preventing you from sharing pointers to mutable values between tasks, but I could be wrong about this.<br>&gt; Is that bad? Sharing pointers seems like a cheap way to share data, and as long as you know what you’re doing, why should the language get in the way? Now, if said code really does have performance advantages over the “safer” methods, and it really is safe because for whatever reason the race condition can’t actually happen, the language (or library) ought to have a way to express that without having to write “unsafe” code. In the meantime, though, you’ve gotta ship something that runs and meets performance requirements.<br></p><p>Well, ideally, the type system would be able to enforce that values passed across thread boundaries are immutable. Rust&#39;s model allows this, I believe.<br></p><p>The possibility of mutating shared state in an unprincipled manner is &quot;bad&quot; in the same sense that being able to call free() in C is &quot;bad&quot; -- it&#39;s an abstraction violation if you get it wrong. Compared to languages with automatic memory management, there are advantages (control over memory management) and disadvantages (fewer static guarantees).<br></p><p><br>&gt; <br>&gt; - Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>August 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Would this prevent an object from being “known&quot; to multiple threads? …multiple queues? If so, it would be overly restrictive for a general-purpose language. I assume that the plan includes a way to allow “unsafe” behavior to support other concurrency models.<br></p><p><br>&gt; On Aug 10, 2016, at 4:24 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 10, 2016, at 3:22 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 10, 2016, at 4:48 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I understand it, a big weakness of Go&#39;s model is that it does not actually prevent data races. There&#39;s nothing preventing you from sharing pointers to mutable values between tasks, but I could be wrong about this.<br>&gt;&gt; Is that bad? Sharing pointers seems like a cheap way to share data, and as long as you know what you’re doing, why should the language get in the way? Now, if said code really does have performance advantages over the “safer” methods, and it really is safe because for whatever reason the race condition can’t actually happen, the language (or library) ought to have a way to express that without having to write “unsafe” code. In the meantime, though, you’ve gotta ship something that runs and meets performance requirements.<br>&gt; <br>&gt; Well, ideally, the type system would be able to enforce that values passed across thread boundaries are immutable. Rust&#39;s model allows this, I believe.<br>&gt; <br>&gt; The possibility of mutating shared state in an unprincipled manner is &quot;bad&quot; in the same sense that being able to call free() in C is &quot;bad&quot; -- it&#39;s an abstraction violation if you get it wrong. Compared to languages with automatic memory management, there are advantages (control over memory management) and disadvantages (fewer static guarantees).<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 10, 2016, at 3:34 PM, Christopher Kornher &lt;ckornher at me.com&gt; wrote:<br>&gt; <br>&gt; Would this prevent an object from being “known&quot; to multiple threads? …multiple queues? If so, it would be overly restrictive for a general-purpose language. I assume that the plan includes a way to allow “unsafe” behavior to support other concurrency models.<br>&gt; <br></p><p>To be clear I&#39;m not presenting any ideas for Swift here, just critiquing Go&#39;s model.<br></p><p>Yes, I&#39;m just talking about &#39;safe&#39; language features for passing immutable data between threads. This would not preclude other forms of concurrency from existing in the language, such as locks, atomics, etc. But I think if a user writes code with only message passing, the language should ensure that the result is free from data races. Go does not do that, which is unfortunate.<br></p><p>Slava<br></p><p>&gt; <br>&gt;&gt; On Aug 10, 2016, at 4:24 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 10, 2016, at 3:22 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 10, 2016, at 4:48 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As I understand it, a big weakness of Go&#39;s model is that it does not actually prevent data races. There&#39;s nothing preventing you from sharing pointers to mutable values between tasks, but I could be wrong about this.<br>&gt;&gt;&gt; Is that bad? Sharing pointers seems like a cheap way to share data, and as long as you know what you’re doing, why should the language get in the way? Now, if said code really does have performance advantages over the “safer” methods, and it really is safe because for whatever reason the race condition can’t actually happen, the language (or library) ought to have a way to express that without having to write “unsafe” code. In the meantime, though, you’ve gotta ship something that runs and meets performance requirements.<br>&gt;&gt; <br>&gt;&gt; Well, ideally, the type system would be able to enforce that values passed across thread boundaries are immutable. Rust&#39;s model allows this, I believe.<br>&gt;&gt; <br>&gt;&gt; The possibility of mutating shared state in an unprincipled manner is &quot;bad&quot; in the same sense that being able to call free() in C is &quot;bad&quot; -- it&#39;s an abstraction violation if you get it wrong. Compared to languages with automatic memory management, there are advantages (control over memory management) and disadvantages (fewer static guarantees).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 10, 2016, at 5:36 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 10, 2016, at 3:34 PM, Christopher Kornher &lt;ckornher at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would this prevent an object from being “known&quot; to multiple threads? …multiple queues? If so, it would be overly restrictive for a general-purpose language. I assume that the plan includes a way to allow “unsafe” behavior to support other concurrency models.<br>&gt;&gt; <br>&gt; <br>&gt; To be clear I&#39;m not presenting any ideas for Swift here, just critiquing Go&#39;s model.<br>&gt; <br>&gt; Yes, I&#39;m just talking about &#39;safe&#39; language features for passing immutable data between threads. This would not preclude other forms of concurrency from existing in the language, such as locks, atomics, etc. But I think if a user writes code with only message passing, the language should ensure that the result is free from data races. Go does not do that, which is unfortunate.<br>&gt; <br>Oh, *that* I’ll agree with… I was just talking about situations where there is no “safe” way to do it (for whatever your language’s/compiler’s idea of “safe” is). For example, maybe you really do need to interpret a 64-bit chunk of data as an Int64, even though the compiler is convinced it’s a Double. We can do that in Swift through the various “unsafe” functions, which is where they belong because 99.99% of the time that’s a bad idea. That 0.01% though…<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>August 10, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Aug 10, 2016 at 3:50 PM, David Sweeris via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; For example, maybe you really do need to interpret a 64-bit chunk of data as an Int64, even though the compiler is convinced it’s a Double. We can do that in Swift through the various “unsafe” functions, which is where they belong because 99.99% of the time that’s a bad idea.<br></p><p>&quot;42.0.bitPattern&quot;.  Why do you think this conversion is unsafe?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 12:04 PM, Dan Stenmark via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to inquire as to what the Swift team thoughts on Go&#39;s concurrency model are?  I&#39;m not referring to convenience of the &#39;go&#39; keyword and nor am I referring to how the language handles Channels, both of which being what most folks associate with it.  Rather, I&#39;d like to ask about the language&#39;s use of Green Threads and how the runtime handles the heavy lifting of multiplexing and scheduling them.  What are some of the strengths and weaknesses the Swift team sees to Go&#39;s approach?<br></p><p>Hi Dan,<br></p><p>There are many folks interested in concurrency topics related to this, but we need to stay focused on finishing Swift 3 and then moving on to Swift 4 stage 1 goals.  As that work is cresting, we’ll start discussions of concurrency, and may even be so bold as to start a new mailing list dedicated to the topic, since it is such a wide reaching topic.<br></p><p>Until we get to that point, please resist the urge to jump ahead :-)<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>What&#39;re the Swift team&#39;s thoughts on Go&#39;s concurrency?</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>August 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Aug 10, 2016, at 10:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Dan,<br>&gt; <br>&gt; There are many folks interested in concurrency topics related to this, but we need to stay focused on finishing Swift 3 and then moving on to Swift 4 stage 1 goals.  As that work is cresting, we’ll start discussions of concurrency, and may even be so bold as to start a new mailing list dedicated to the topic, since it is such a wide reaching topic.<br>&gt; <br>&gt; Until we get to that point, please resist the urge to jump ahead :-)<br>&gt; <br>&gt; -Chris<br></p><p>Chris, many apologies if this came across the wrong way!  As I attempted to explain in the opening email, I&#39;m inquiring for purely academic reasons and to better my understanding of concurrency as part of language design in general, not to pitch anything for Swift.  In retrospect, perhaps -users would&#39;ve been a better fit for this question rather than -evolution.<br></p><p><br>&gt; On Aug 9, 2016, at 1:59 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 9, 2016, at 1:28 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The Rust language used to use a green thread model like Go (actually it exposed a configurable threading interface so you could choose green threads or OS threads). It also used segmented stacks like Go did. Over time, Rust ended up dropping the segmented stacks because it significantly complicated FFI without providing much, if any, benefit (and IIRC Go followed suite and dropped segmented stacks somewhere around version 1.5), and then a little while later Rust dropped green threads entirely. If you can find them, there are lots of discussions of the pros and cons that were documented during this process (on mailing lists, in IRC, possibly on Discourse, there&#39;s probably at least one post about it in the Rust subreddit, etc). But ultimately, it was determined that keeping this ability significantly complicated the Rust runtime and it provided almost no benefit. The OS is already really good at scheduling threads, and there&#39;s no memory savings without segmented stacks (though the OS will map virtual pages for the stack and only allocate the backing physical pages as the memory is touched, so even if you have a 2MB stack, a new thread will only actually allocate something like 8kb). And there are some pretty big downsides to green threads, such as the fact that it significantly complicates the runtime since all I/O everywhere has to be nonblocking and it has to be transparent to the code, and FFI ends up as a major problem (even without segmented stacks), because you have no idea if an FFI call will block. Green threading libraries end up having to allocate extra OS threads just to continue servicing the green threads when the existing threads are potentially blocked in FFI.<br>&gt;&gt; <br>&gt;&gt; So ultimately, green threads really only make sense when you control the entire ecosystem, so you can ensure the whole stack is compatible with green threads and won&#39;t ever issue blocking calls, and even there there&#39;s not much benefit and there&#39;s a lot of complexity involved.<br>&gt; <br>&gt; In addition to FFI, there&#39;s also no way for memory-mapped IO to be non-blocking (a page fault can only be handled by the kernel, after all).<br></p><p>This right here is what I was looking for.  Thanks, guys!<br></p><p>Dan<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
