<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>on Tue Oct 18 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt;&gt; On Oct 17, 2016, at 10:21 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Oct 17 2016, Erik Eckstein &lt;eeckstein-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; On Oct 16, 2016, at 2:05 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The SIL-level design seems sensible to me at a glance. At the language<br>&gt;&gt;&gt;&gt;&gt; level, I think it would make more sense to treat this as an attribute<br>&gt;&gt;&gt;&gt;&gt; on class types rather than on properties in structs using the class. I<br>&gt;&gt;&gt;&gt;&gt; don&#39;t think many people reuse class definitions as both shared<br>&gt;&gt;&gt;&gt;&gt; reference types and as value type payloads, <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Foundation does, or would if they could.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; but beyond that, I think that making it an attribute of classes would<br>&gt;&gt;&gt;&gt;&gt; put us into a better position to leverage the borrow model to enforce<br>&gt;&gt;&gt;&gt;&gt; the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John<br>&gt;&gt;&gt;&gt;&gt; alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer<br>&gt;&gt;&gt;&gt;&gt;&gt; references a move-only type, so that as long as you were just<br>&gt;&gt;&gt;&gt;&gt;&gt; working with the raw reference (as opposed to the CoW aggregate,<br>&gt;&gt;&gt;&gt;&gt;&gt; which would remain copyable) it wouldn&#39;t get implicitly copied<br>&gt;&gt;&gt;&gt;&gt;&gt; anymore.  You could have mutable and immutable buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt; types, both move-only, and there could be a consuming checkUnique<br>&gt;&gt;&gt;&gt;&gt;&gt; operation on the immutable one that, I dunno, returned an Either of<br>&gt;&gt;&gt;&gt;&gt;&gt; the mutable and immutable versions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field<br>&gt;&gt;&gt;&gt;&gt;&gt; to make sure that the CoW attribute was still copyable.  Within the<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of the type, though, you would be projecting out the<br>&gt;&gt;&gt;&gt;&gt;&gt; reference immediately, and thereafter you&#39;d be certain that you were<br>&gt;&gt;&gt;&gt;&gt;&gt; borrowing / moving it around as appropriate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish<br>&gt;&gt;&gt;&gt;&gt; unique and nonunique references to the class. A unique reference would<br>&gt;&gt;&gt;&gt;&gt; act like a move-only type to prevent accidental loss of uniqueness. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We can also allow a copy-on-write class to have &quot;mutating&quot; methods,<br>&gt;&gt;&gt;&gt;&gt; and only allow mutation on unique references. It seems to me like,<br>&gt;&gt;&gt;&gt;&gt; exploring this direction, we could also come up with a way for the<br>&gt;&gt;&gt;&gt;&gt; high-level value-semantics operations on the struct to statically<br>&gt;&gt;&gt;&gt;&gt; indicate which methods are known to leave the value&#39;s buffers in a<br>&gt;&gt;&gt;&gt;&gt; unique state, or which return values that are uniquely owned, which<br>&gt;&gt;&gt;&gt;&gt; would give the optimizer more ability to avoid uniqueness checks<br>&gt;&gt;&gt;&gt;&gt; across calls without relying on inlining and IPO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s pretty cool.  However, I think there&#39;s nothing to prevent any<br>&gt;&gt;&gt;&gt; mutating method from storing a copy of self in a global, so I think we&#39;d<br>&gt;&gt;&gt;&gt; need some participation from the programmer (either an agreement not to<br>&gt;&gt;&gt;&gt; do that, or an explicit claim of uniqueness on exit) in order to<br>&gt;&gt;&gt;&gt; identify operations that create/preserve uniqueness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a mutating reference (like self in a mutating method) is move-only<br>&gt;&gt;&gt; then you would not be able to “copy” it to a global.<br>&gt;&gt; <br>&gt;&gt; Yes, a reference to a move-only type would work for this purpose.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:01 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; :orphan:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; .. highlight:: sil<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; .. contents::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Overview<br>&gt;&gt;&gt;&gt;&gt; ========<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;&gt;&gt;&gt; of it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt;&gt;&gt;&gt; in the same way as a programmer can do.<br>&gt;&gt;&gt;&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt;&gt;&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;   In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;&gt;&gt;&gt;   It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; COW Types<br>&gt;&gt;&gt;&gt;&gt; =========<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   class COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;     var someData: Int<br>&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   struct COWType {<br>&gt;&gt;&gt;&gt;&gt;     var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     mutating func change_it() {<br>&gt;&gt;&gt;&gt;&gt;       if (!isUniquelyReferenced(b)) {<br>&gt;&gt;&gt;&gt;&gt;         b = copy_buffer(b)<br>&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt;       b.someData = ...<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt;&gt;&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt;&gt;&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func foo(arr : [Int]) {<br>&gt;&gt;&gt;&gt;&gt;     x = arr[0]<br>&gt;&gt;&gt;&gt;&gt;     opaque_function()<br>&gt;&gt;&gt;&gt;&gt;     y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt;&gt;&gt;&gt; has to copy it. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...or determine that it&#39;s uniquely-referenced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this specific example, if opqaue_function holds a reference to arr’s buffer, the buffer is not<br>&gt;&gt;&gt; uniquely-referenced.<br>&gt;&gt; <br>&gt;&gt; Right.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt;&gt;&gt;&gt;&gt; that opaque_function() will write to the location of arr[0].<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt;&gt;&gt;&gt; =================================<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift Syntax<br>&gt;&gt;&gt;&gt;&gt; ------------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt;&gt;&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   struct COWType {<br>&gt;&gt;&gt;&gt;&gt;     copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt;&gt;&gt;&gt; It does not change the semantics of the program.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Presumably, it changes what code you can execute on `b` without invoking<br>&gt;&gt;&gt;&gt; traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>&gt;&gt;&gt;&gt; to do anything differently to take advantage of the annotation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s true.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What are the rules for writing code that uses `copy_on_write`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See below (&quot;The rules for using ``copy_on_write`` and the built-ins are:”)<br>&gt;&gt; <br>&gt;&gt; Yeah, I got there, eventually.  But just saying “doesn&#39;t change<br>&gt;&gt; semantics” at this point in the proposal leaves a gap, because it does<br>&gt;&gt; change semantic *requirements*.  You should mention that.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;&gt;&gt;&gt; Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;&gt;&gt;&gt; Another question is if we should open this attribute for the public or just<br>&gt;&gt;&gt;&gt;&gt; use it internally in the library, because violating the implied rules<br>&gt;&gt;&gt;&gt;&gt; (see below) could break memory safety.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Implementation<br>&gt;&gt;&gt;&gt;&gt; --------------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt;&gt;&gt;&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt;&gt;&gt;&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt;&gt;&gt;&gt; buffer class type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt;&gt;&gt;&gt; type to a regular reference type::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   cow_to_ref<br>&gt;&gt;&gt;&gt;&gt;   ref_to_cow<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example the SIL code for::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var c: COWType<br>&gt;&gt;&gt;&gt;&gt;   let x = c.b.someData<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would be::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;&gt;&gt;&gt;   %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;   %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;&gt;&gt;&gt;   %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt;&gt;&gt;&gt; COW type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt;&gt;&gt;&gt; =============================<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;&gt;&gt;&gt; during the lifetime of the reference.*<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems like much too broad a rule to allow inplace mutations of<br>&gt;&gt;&gt;&gt; uniquely referenced buffers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The point is that all mutations must be guarded by an is_unique, which<br>&gt;&gt;&gt; takes the _address_ of the buffer reference as argument.<br>&gt;&gt;&gt; And the optimizer considers this instruction as a potential write to the buffer reference.<br>&gt;&gt;&gt; The effect is that the lifetime of a buffer reference (as a SIL value)<br>&gt;&gt;&gt; will not outlive a is_unique - regardless if this is inside a called<br>&gt;&gt;&gt; function or inlined.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how that allows me to mutate a uniquely referenced buffer held<br>&gt;&gt; in a @sil_cow reference, given what you wrote above.<br>&gt;<br>&gt; You would not be able to get a reference to a mutable buffer by<br>&gt; reading the COW type’s @sil_cow field.  Instead you would only get<br>&gt; such a reference as a result of the is_unique instruction/builtin. Or,<br>&gt; of course, by creating a new buffer.<br>&gt;<br>&gt; I’m not sure if this was the question, though.<br></p><p>I think it just comes down to precise phrasing.  AFAICT, what you really<br>mean to say is something like<br></p><p>  A buffer cannot be directly mutated through a @sil_cow reference;<br>  instead one must mutate it indirectly via the result of is_unique or<br>  start_unique.<br></p><p>Saying that the buffer is “considered to be immmutable during the<br>lifetime of the reference” could be taken to mean that the compiler will<br>assume no mutations of the buffer can occur while the reference exists.<br>IIUC you are not planning to formally end the reference&#39;s lifetime at<br>the moment is_unique/start_unique returns.<br></p><p>&gt;<br>&gt; Plus: we will have an explicit conversion instruction (start_unique) to convert an immutable<br>&gt; reference to a mutable referece.<br>&gt; A SIL optimization can replace an is_unique with this instruction if it can prove that the reference<br>&gt; is already unique at that point.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless you mean the reference is<br>&gt;&gt;&gt;&gt; immutable, rather than the storage being referred to by it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt;&gt;&gt;&gt; considered to point to immutable memory.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt;&gt;&gt;&gt; representation in SIL:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Redundant load elimination<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; RLE can assume that opaque code does not modify a COW buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How do you distinguish “opaque code” from “code that is meant to<br>&gt;&gt;&gt;&gt; modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, the is_unique which takes the address of the reference, will<br>&gt;&gt;&gt; guarantee that during the lifetime of a buffer there are no<br>&gt;&gt;&gt; modifications of the buffer.<br>&gt;&gt; <br>&gt;&gt; Again, that sounds like it rules out inplace modification of uniquely<br>&gt;&gt; referenced buffers.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;     %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;     %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;     %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;&gt;&gt;&gt;     %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;&gt;&gt;&gt; like array count propagation. These hacks would not be needed<br>&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; W0000000000000000000000t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;&gt;&gt;&gt; projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;&gt;&gt;&gt; memory.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - CSE, loop hoisting<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;&gt;&gt;&gt; COW buffer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Same question here as above, then.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - ARC optimization<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;&gt;&gt;&gt; can remove retain/release pairs across such code::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;     %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;&gt;&gt;&gt;     %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;&gt;&gt;&gt;     %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;&gt;&gt;&gt;     // Use %4<br>&gt;&gt;&gt;&gt;&gt;     destroy_value %4 : $MyClass<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Scoping instructions<br>&gt;&gt;&gt;&gt;&gt; --------------------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt;&gt;&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt;&gt;&gt;&gt; buffer reference. For example::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;&gt;&gt;&gt;   // load something from %b1<br>&gt;&gt;&gt;&gt;&gt;   %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;   %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;&gt;&gt;&gt;   // load something from %b2<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt;&gt;&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt;&gt;&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt;&gt;&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt;&gt;&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt;&gt;&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looks reasonable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt;&gt;&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt;&gt;&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // there should be a begin-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;   %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;   store %x to %mut_b    // modification of the buffer<br>&gt;&gt;&gt;&gt;&gt;   // there should be a end-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   loop {<br>&gt;&gt;&gt;&gt;&gt;     %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;     %y = load %b        // load from the buffer<br>&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;   %b = load %baddr        // moved out of the loop<br>&gt;&gt;&gt;&gt;&gt;   store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   loop {<br>&gt;&gt;&gt;&gt;&gt;     %y = load %b<br>&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt;&gt;&gt;&gt; also hoist the load::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;   %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;   %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;&gt;&gt;&gt;   store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   loop {<br>&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt;&gt;&gt;&gt; -----------------------------------------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; SIL instructions<br>&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   bb0:<br>&gt;&gt;&gt;&gt;&gt;     is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;&gt;&gt;&gt;   bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;&gt;&gt;&gt;     // usually empty<br>&gt;&gt;&gt;&gt;&gt;     br bb3(%1 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;   bb2:                  // the false-block<br>&gt;&gt;&gt;&gt;&gt;     // usually contains:<br>&gt;&gt;&gt;&gt;&gt;     %2 = apply %copy_buffer<br>&gt;&gt;&gt;&gt;&gt;     %3 = cow_to_ref %2<br>&gt;&gt;&gt;&gt;&gt;     store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;     br bb3(%2 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;   bb3(%4 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;     // Modify the buffer referenced by %4<br>&gt;&gt;&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   end_unique_addr %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt;&gt;&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt;&gt;&gt;&gt; verifier.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt;&gt;&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt;&gt;&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt;&gt;&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt;&gt;&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt;&gt;&gt;&gt; across these instructions.<br>&gt;&gt;&gt;&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt;&gt;&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;   // do something with %1<br>&gt;&gt;&gt;&gt;&gt;   …<br>&gt;&gt;&gt;&gt;&gt;   is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;   …<br>&gt;&gt;&gt;&gt;&gt;   %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt;&gt;&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt;&gt;&gt;&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt;&gt;&gt;&gt; from the COWType.<br>&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt; %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt; %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt; store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt;&gt;&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt;&gt;&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt;&gt;&gt;&gt; ``end_unique_addr``.<br>&gt;&gt;&gt;&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt;&gt;&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func foo(arr : [Int], x: Int) {<br>&gt;&gt;&gt;&gt;&gt;     arr[0] = 27<br>&gt;&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;&gt;     y = arr[x]<br>&gt;&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt;&gt;&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   bb0:<br>&gt;&gt;&gt;&gt;&gt;     is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;&gt;&gt;&gt;   bb1(%1 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;     … // main control flow continues here<br>&gt;&gt;&gt;&gt;&gt;   bb2:<br>&gt;&gt;&gt;&gt;&gt;     unreachable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt;&gt;&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Built-ins<br>&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;&gt;&gt;&gt;   func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   struct COWType {<br>&gt;&gt;&gt;&gt;&gt;     copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;       if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;&gt;&gt;&gt;         return uniqueBuffer<br>&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt;       let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;&gt;&gt;&gt;       self.b = copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;       return copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;       let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;       uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;       endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems reasonable, but it also looks like the compiler could do the<br>&gt;&gt;&gt;&gt; `endUnique` dance for us based, e.g., on the mutability of methods.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree, that would be ideal, e.g. the compiler could insert the endUnique at the end of an inout<br>&gt;&gt;&gt; scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt;&gt;&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt;&gt;&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt;&gt;&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt;&gt;&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt;&gt;&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt;&gt;&gt;&gt; a unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt;&gt;&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt;&gt;&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt;&gt;&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt; This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;&gt;&gt;&gt; problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;&gt;&gt;&gt; the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;&gt;&gt;&gt; can do its job).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know what the implications of these diamonds and the problem<br>&gt;&gt;&gt;&gt; described above might be, FWIW.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;  same function.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;&gt;&gt;&gt;  pair.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;&gt;&gt;&gt;  reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;&gt;&gt;&gt;  part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;&gt;&gt;&gt;  of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;&gt;&gt;&gt;  for the purpose of copying.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Examples::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;     let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;     uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;     // violates rule 1<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;     makeMutable()<br>&gt;&gt;&gt;&gt;&gt;     self.b.someData = x // violates rule 2<br>&gt;&gt;&gt;&gt;&gt;     endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;     let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;     uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;     endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;     uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   mutating func incrementSomeData() {<br>&gt;&gt;&gt;&gt;&gt;     let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;     uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;&gt;&gt;&gt;     endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be instructive to write down the *correct* code for these<br>&gt;&gt;&gt;&gt; operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; added to my todo list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt;&gt;&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt;&gt;&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt;&gt;&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt;&gt;&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt;&gt;&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt;&gt;&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt;&gt;&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt;&gt;&gt;&gt; the unique buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No big deal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt;&gt;&gt;&gt; --------------------------------------------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt;&gt;&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt;&gt;&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt;&gt;&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt;&gt;&gt;&gt; scope of a COW buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   begin_exclusive<br>&gt;&gt;&gt;&gt;&gt;   end_exclusive<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt;&gt;&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt;&gt;&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt;&gt;&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt;&gt;&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt;&gt;&gt;&gt; done in mutating functions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;   // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;&gt;&gt;&gt;   sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;&gt;&gt;&gt;   bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // &gt;   makeMutable() (inlined)<br>&gt;&gt;&gt;&gt;&gt;   // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;&gt;&gt;&gt;   // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;   begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;&gt;&gt;&gt;   // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;&gt;&gt;&gt;   // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;&gt;&gt;&gt;   // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;&gt;&gt;&gt;   %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;&gt;&gt;&gt;   // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;&gt;&gt;&gt;   // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;&gt;&gt;&gt;   // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;&gt;&gt;&gt;   %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;   end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   br %isuniq, bb_continue, bb_slow<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   bb_slow:<br>&gt;&gt;&gt;&gt;&gt;   // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;&gt;&gt;&gt;   // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;&gt;&gt;&gt;   %copied_storage_class = alloc_ref ...<br>&gt;&gt;&gt;&gt;&gt;   // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;&gt;&gt;&gt;   store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;&gt;&gt;&gt;   br bb_continue<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   bb_continue:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;&gt;&gt;&gt;   // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;&gt;&gt;&gt;   // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;&gt;&gt;&gt;   // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;&gt;&gt;&gt;   // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;&gt;&gt;&gt;   // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;&gt;&gt;&gt;   // they must be consumed within this scope.<br>&gt;&gt;&gt;&gt;&gt;   end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // &gt;    self._storage.someData = x<br>&gt;&gt;&gt;&gt;&gt;   // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;&gt;&gt;&gt;   %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;&gt;&gt;&gt;   %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;   %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // Write some data into the CoW buffer.<br>&gt;&gt;&gt;&gt;&gt;   // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;&gt;&gt;&gt;   // A single-use _addr instruction, so no scope.<br>&gt;&gt;&gt;&gt;&gt;   %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;&gt;&gt;&gt;   // A store with an implicit [exclusive] scope.<br>&gt;&gt;&gt;&gt;&gt;   store [assign] %x to %somedata_addr<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;&gt;&gt;&gt;   // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;&gt;&gt;&gt;   end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt;&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>&gt;&gt;&gt;&gt; generates this SIL.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But it depends on implementing the general feature to insert the inout<br>&gt;&gt;&gt;&gt;&gt; scoping instructions.  Also, we still have to think through all the<br>&gt;&gt;&gt;&gt;&gt; details of this approach.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, I am convinced we will need (and get) a stricter inout model that<br>&gt;&gt;&gt;&gt; would be conducive to inserting the scoping instructions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt;&gt;&gt;&gt; --------------------------------------------------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can only have a dependency between two things, but as phrased “a<br>&gt;&gt;&gt;&gt; buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>&gt;&gt;&gt;&gt; would fix it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt;&gt;&gt;&gt; to a scope-begin instruction::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;   %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;   %x = load %b             // No dependency between this...<br>&gt;&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;&gt;   begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;   %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;&gt;   begin_exclusive %baddr<br>&gt;&gt;&gt;&gt;&gt;   %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;&gt;&gt;&gt; the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;&gt;&gt;&gt; reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Preconditions<br>&gt;&gt;&gt;&gt;&gt; =============<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt;&gt;&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt;&gt;&gt;&gt; buffer. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>&gt;&gt;&gt;&gt; why this would be dependent on it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could use copy_on_write with eager bridging, but I don’t think it will give any benefits to the<br>&gt;&gt;&gt; optimizer.<br>&gt;&gt;&gt; For example, the SIL code to get from an Array to a native<br>&gt;&gt;&gt; ContiguousArrayStorage reference is pretty hard to understand for the<br>&gt;&gt;&gt; optimizer (involves low level bit operations, etc.).<br>&gt;&gt; <br>&gt;&gt; It wouldn&#39;t need to do low-level bit operations if our enums were<br>&gt;&gt; capable/controllable enough.  I&#39;m just saying, there&#39;s no reason we<br>&gt;&gt; couldn&#39;t give the optimizer something to work with that has higher level<br>&gt;&gt; semantics than what we currently do.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; At least for Array this is implemented as low-level bit operations and<br>&gt;&gt;&gt;&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt;&gt;&gt;&gt;&gt; RC-root for the buffer reference).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt;&gt;&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt;&gt;&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt;&gt;&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt;&gt;&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var arr = [MyClass()]  // a global array<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;     let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;&gt;&gt;&gt;     let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;&gt;&gt;&gt;     arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;&gt;&gt;&gt;     return r.i        // use-after-free!<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I only know of one way to resolve inout and pinning:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Semantically, references are replaced with a trap value when entering<br>&gt;&gt;&gt;&gt; an inout context so that all inout values are provably unique<br>&gt;&gt;&gt;&gt; references in the absence of unsafe code.  We drop pinning and provide<br>&gt;&gt;&gt;&gt; explicit operations that provide simultaneous lvalue accesses to<br>&gt;&gt;&gt;&gt; distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>&gt;&gt;&gt;&gt; should probably decide that this is what we&#39;re doing so that we can move<br>&gt;&gt;&gt;&gt; forward without this looming uncertainty.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 10:13 AM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Oct 18 2016, Erik Eckstein &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Oct 17, 2016, at 10:21 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Oct 17 2016, Erik Eckstein &lt;eeckstein-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:05 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The SIL-level design seems sensible to me at a glance. At the language<br>&gt;&gt;&gt;&gt;&gt;&gt; level, I think it would make more sense to treat this as an attribute<br>&gt;&gt;&gt;&gt;&gt;&gt; on class types rather than on properties in structs using the class. I<br>&gt;&gt;&gt;&gt;&gt;&gt; don&#39;t think many people reuse class definitions as both shared<br>&gt;&gt;&gt;&gt;&gt;&gt; reference types and as value type payloads, <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Foundation does, or would if they could.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; but beyond that, I think that making it an attribute of classes would<br>&gt;&gt;&gt;&gt;&gt;&gt; put us into a better position to leverage the borrow model to enforce<br>&gt;&gt;&gt;&gt;&gt;&gt; the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John<br>&gt;&gt;&gt;&gt;&gt;&gt; alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; references a move-only type, so that as long as you were just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; working with the raw reference (as opposed to the CoW aggregate,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would remain copyable) it wouldn&#39;t get implicitly copied<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anymore.  You could have mutable and immutable buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types, both move-only, and there could be a consuming checkUnique<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operation on the immutable one that, I dunno, returned an Either of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the mutable and immutable versions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to make sure that the CoW attribute was still copyable.  Within the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of the type, though, you would be projecting out the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference immediately, and thereafter you&#39;d be certain that you were<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; borrowing / moving it around as appropriate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish<br>&gt;&gt;&gt;&gt;&gt;&gt; unique and nonunique references to the class. A unique reference would<br>&gt;&gt;&gt;&gt;&gt;&gt; act like a move-only type to prevent accidental loss of uniqueness. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We can also allow a copy-on-write class to have &quot;mutating&quot; methods,<br>&gt;&gt;&gt;&gt;&gt;&gt; and only allow mutation on unique references. It seems to me like,<br>&gt;&gt;&gt;&gt;&gt;&gt; exploring this direction, we could also come up with a way for the<br>&gt;&gt;&gt;&gt;&gt;&gt; high-level value-semantics operations on the struct to statically<br>&gt;&gt;&gt;&gt;&gt;&gt; indicate which methods are known to leave the value&#39;s buffers in a<br>&gt;&gt;&gt;&gt;&gt;&gt; unique state, or which return values that are uniquely owned, which<br>&gt;&gt;&gt;&gt;&gt;&gt; would give the optimizer more ability to avoid uniqueness checks<br>&gt;&gt;&gt;&gt;&gt;&gt; across calls without relying on inlining and IPO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s pretty cool.  However, I think there&#39;s nothing to prevent any<br>&gt;&gt;&gt;&gt;&gt; mutating method from storing a copy of self in a global, so I think we&#39;d<br>&gt;&gt;&gt;&gt;&gt; need some participation from the programmer (either an agreement not to<br>&gt;&gt;&gt;&gt;&gt; do that, or an explicit claim of uniqueness on exit) in order to<br>&gt;&gt;&gt;&gt;&gt; identify operations that create/preserve uniqueness.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If a mutating reference (like self in a mutating method) is move-only<br>&gt;&gt;&gt;&gt; then you would not be able to “copy” it to a global.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, a reference to a move-only type would work for this purpose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:01 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; :orphan:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .. highlight:: sil<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .. contents::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Overview<br>&gt;&gt;&gt;&gt;&gt;&gt; ========<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;&gt;&gt;&gt;&gt; of it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt;&gt;&gt;&gt;&gt; in the same way as a programmer can do.<br>&gt;&gt;&gt;&gt;&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt;&gt;&gt;&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;  In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;&gt;&gt;&gt;&gt;  It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; COW Types<br>&gt;&gt;&gt;&gt;&gt;&gt; =========<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  class COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;&gt;    var someData: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;    var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    mutating func change_it() {<br>&gt;&gt;&gt;&gt;&gt;&gt;      if (!isUniquelyReferenced(b)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;        b = copy_buffer(b)<br>&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;      b.someData = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt;&gt;&gt;&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  func foo(arr : [Int]) {<br>&gt;&gt;&gt;&gt;&gt;&gt;    x = arr[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;    opaque_function()<br>&gt;&gt;&gt;&gt;&gt;&gt;    y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt;&gt;&gt;&gt;&gt; has to copy it. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ...or determine that it&#39;s uniquely-referenced.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this specific example, if opqaue_function holds a reference to arr’s buffer, the buffer is not<br>&gt;&gt;&gt;&gt; uniquely-referenced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt;&gt;&gt;&gt;&gt;&gt; that opaque_function() will write to the location of arr[0].<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt;&gt;&gt;&gt;&gt; =================================<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift Syntax<br>&gt;&gt;&gt;&gt;&gt;&gt; ------------<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;    copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt;&gt;&gt;&gt;&gt; It does not change the semantics of the program.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Presumably, it changes what code you can execute on `b` without invoking<br>&gt;&gt;&gt;&gt;&gt; traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>&gt;&gt;&gt;&gt;&gt; to do anything differently to take advantage of the annotation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s true.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What are the rules for writing code that uses `copy_on_write`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See below (&quot;The rules for using ``copy_on_write`` and the built-ins are:”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, I got there, eventually.  But just saying “doesn&#39;t change<br>&gt;&gt;&gt; semantics” at this point in the proposal leaves a gap, because it does<br>&gt;&gt;&gt; change semantic *requirements*.  You should mention that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;&gt;&gt;&gt;&gt; Another question is if we should open this attribute for the public or just<br>&gt;&gt;&gt;&gt;&gt;&gt; use it internally in the library, because violating the implied rules<br>&gt;&gt;&gt;&gt;&gt;&gt; (see below) could break memory safety.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; --------------<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt;&gt;&gt;&gt;&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt;&gt;&gt;&gt;&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer class type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt;&gt;&gt;&gt;&gt; type to a regular reference type::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  cow_to_ref<br>&gt;&gt;&gt;&gt;&gt;&gt;  ref_to_cow<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example the SIL code for::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  var c: COWType<br>&gt;&gt;&gt;&gt;&gt;&gt;  let x = c.b.someData<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would be::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;&gt;&gt;&gt;&gt;  %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;  %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;&gt;&gt;&gt;&gt;  %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt;&gt;&gt;&gt;&gt; COW type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt;&gt;&gt;&gt;&gt; =============================<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;&gt;&gt;&gt;&gt; during the lifetime of the reference.*<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems like much too broad a rule to allow inplace mutations of<br>&gt;&gt;&gt;&gt;&gt; uniquely referenced buffers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The point is that all mutations must be guarded by an is_unique, which<br>&gt;&gt;&gt;&gt; takes the _address_ of the buffer reference as argument.<br>&gt;&gt;&gt;&gt; And the optimizer considers this instruction as a potential write to the buffer reference.<br>&gt;&gt;&gt;&gt; The effect is that the lifetime of a buffer reference (as a SIL value)<br>&gt;&gt;&gt;&gt; will not outlive a is_unique - regardless if this is inside a called<br>&gt;&gt;&gt;&gt; function or inlined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how that allows me to mutate a uniquely referenced buffer held<br>&gt;&gt;&gt; in a @sil_cow reference, given what you wrote above.<br>&gt;&gt; <br>&gt;&gt; You would not be able to get a reference to a mutable buffer by<br>&gt;&gt; reading the COW type’s @sil_cow field.  Instead you would only get<br>&gt;&gt; such a reference as a result of the is_unique instruction/builtin. Or,<br>&gt;&gt; of course, by creating a new buffer.<br>&gt;&gt; <br>&gt;&gt; I’m not sure if this was the question, though.<br>&gt; <br>&gt; I think it just comes down to precise phrasing.  AFAICT, what you really<br>&gt; mean to say is something like<br>&gt; <br>&gt;  A buffer cannot be directly mutated through a @sil_cow reference;<br>&gt;  instead one must mutate it indirectly via the result of is_unique or<br>&gt;  start_unique.<br>&gt; <br>&gt; Saying that the buffer is “considered to be immmutable during the<br>&gt; lifetime of the reference” could be taken to mean that the compiler will<br>&gt; assume no mutations of the buffer can occur while the reference exists.<br>&gt; IIUC you are not planning to formally end the reference&#39;s lifetime at<br>&gt; the moment is_unique/start_unique returns.<br></p><p>To clarify: I proposed an alternate approach in which the @sil_cow reference is only mutable during the Array’s @inout scope—to be automatically enforced by the compiler once @inout scopes are enforced. But the text in question is not referring to that approach, so your comments are on target.<br></p><p>-Andy <br></p><p>&gt;&gt; <br>&gt;&gt; Plus: we will have an explicit conversion instruction (start_unique) to convert an immutable<br>&gt;&gt; reference to a mutable referece.<br>&gt;&gt; A SIL optimization can replace an is_unique with this instruction if it can prove that the reference<br>&gt;&gt; is already unique at that point.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unless you mean the reference is<br>&gt;&gt;&gt;&gt;&gt; immutable, rather than the storage being referred to by it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt;&gt;&gt;&gt;&gt; considered to point to immutable memory.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt;&gt;&gt;&gt;&gt; representation in SIL:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Redundant load elimination<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; RLE can assume that opaque code does not modify a COW buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How do you distinguish “opaque code” from “code that is meant to<br>&gt;&gt;&gt;&gt;&gt; modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Again, the is_unique which takes the address of the reference, will<br>&gt;&gt;&gt;&gt; guarantee that during the lifetime of a buffer there are no<br>&gt;&gt;&gt;&gt; modifications of the buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, that sounds like it rules out inplace modification of uniquely<br>&gt;&gt;&gt; referenced buffers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;    %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;    %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;&gt;&gt;&gt;&gt;    %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;&gt;&gt;&gt;&gt; like array count propagation. These hacks would not be needed<br>&gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; W0000000000000000000000t.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;&gt;&gt;&gt;&gt; projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;&gt;&gt;&gt;&gt; memory.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - CSE, loop hoisting<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;&gt;&gt;&gt;&gt; COW buffer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Same question here as above, then.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - ARC optimization<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt; can remove retain/release pairs across such code::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;&gt;&gt;&gt;&gt;    %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;&gt;&gt;&gt;&gt;    %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;&gt;&gt;&gt;&gt;    // Use %4<br>&gt;&gt;&gt;&gt;&gt;&gt;    destroy_value %4 : $MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Scoping instructions<br>&gt;&gt;&gt;&gt;&gt;&gt; --------------------<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt;&gt;&gt;&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer reference. For example::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;  // load something from %b1<br>&gt;&gt;&gt;&gt;&gt;&gt;  %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;  %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;&gt;&gt;&gt;&gt;  // load something from %b2<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt;&gt;&gt;&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt;&gt;&gt;&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt;&gt;&gt;&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt;&gt;&gt;&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Looks reasonable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt;&gt;&gt;&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt;&gt;&gt;&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // there should be a begin-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b    // modification of the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;  // there should be a end-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;    %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;    %y = load %b        // load from the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;  %b = load %baddr        // moved out of the loop<br>&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;    %y = load %b<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt;&gt;&gt;&gt;&gt; also hoist the load::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;  %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;  %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt;&gt;&gt;&gt;&gt; -----------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; SIL instructions<br>&gt;&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  bb0:<br>&gt;&gt;&gt;&gt;&gt;&gt;    is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;  bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;&gt;&gt;&gt;&gt;    // usually empty<br>&gt;&gt;&gt;&gt;&gt;&gt;    br bb3(%1 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;  bb2:                  // the false-block<br>&gt;&gt;&gt;&gt;&gt;&gt;    // usually contains:<br>&gt;&gt;&gt;&gt;&gt;&gt;    %2 = apply %copy_buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;    %3 = cow_to_ref %2<br>&gt;&gt;&gt;&gt;&gt;&gt;    store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;    br bb3(%2 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;  bb3(%4 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;&gt;    // Modify the buffer referenced by %4<br>&gt;&gt;&gt;&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  end_unique_addr %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt;&gt;&gt;&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt;&gt;&gt;&gt;&gt; verifier.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt;&gt;&gt;&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt;&gt;&gt;&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt;&gt;&gt;&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt;&gt;&gt;&gt;&gt; across these instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt;&gt;&gt;&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something with %1<br>&gt;&gt;&gt;&gt;&gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;  is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;  %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt;&gt;&gt;&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt;&gt;&gt;&gt;&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt;&gt;&gt;&gt;&gt; from the COWType.<br>&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt; %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt; %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt; store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt;&gt;&gt;&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt;&gt;&gt;&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt;&gt;&gt;&gt;&gt; ``end_unique_addr``.<br>&gt;&gt;&gt;&gt;&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt;&gt;&gt;&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  func foo(arr : [Int], x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;    arr[0] = 27<br>&gt;&gt;&gt;&gt;&gt;&gt;    …<br>&gt;&gt;&gt;&gt;&gt;&gt;    y = arr[x]<br>&gt;&gt;&gt;&gt;&gt;&gt;    …<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt;&gt;&gt;&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  bb0:<br>&gt;&gt;&gt;&gt;&gt;&gt;    is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;&gt;&gt;&gt;&gt;  bb1(%1 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;&gt;    … // main control flow continues here<br>&gt;&gt;&gt;&gt;&gt;&gt;  bb2:<br>&gt;&gt;&gt;&gt;&gt;&gt;    unreachable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt;&gt;&gt;&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Built-ins<br>&gt;&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;&gt;&gt;&gt;&gt;  func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;    copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;&gt;      if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;&gt;&gt;&gt;&gt;        return uniqueBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;      let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;      self.b = copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;      return copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems reasonable, but it also looks like the compiler could do the<br>&gt;&gt;&gt;&gt;&gt; `endUnique` dance for us based, e.g., on the mutability of methods.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree, that would be ideal, e.g. the compiler could insert the endUnique at the end of an inout<br>&gt;&gt;&gt;&gt; scope.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt;&gt;&gt;&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt;&gt;&gt;&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt;&gt;&gt;&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt;&gt;&gt;&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt;&gt;&gt;&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt;&gt;&gt;&gt;&gt; a unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt;&gt;&gt;&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt;&gt;&gt;&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt; This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;&gt;&gt;&gt;&gt; problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;&gt;&gt;&gt;&gt; the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;&gt;&gt;&gt;&gt; can do its job).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know what the implications of these diamonds and the problem<br>&gt;&gt;&gt;&gt;&gt; described above might be, FWIW.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;&gt;&gt;&gt;&gt; pair.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt; reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;&gt;&gt;&gt;&gt; part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;&gt;&gt;&gt;&gt; of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;&gt;&gt;&gt;&gt; for the purpose of copying.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Examples::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;    // violates rule 1<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;    makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;    self.b.someData = x // violates rule 2<br>&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  mutating func incrementSomeData() {<br>&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be instructive to write down the *correct* code for these<br>&gt;&gt;&gt;&gt;&gt; operations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; added to my todo list.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt;&gt;&gt;&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt;&gt;&gt;&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt;&gt;&gt;&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt;&gt;&gt;&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt;&gt;&gt;&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt;&gt;&gt;&gt;&gt; the unique buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No big deal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt;&gt;&gt;&gt;&gt; --------------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt;&gt;&gt;&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt;&gt;&gt;&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt;&gt;&gt;&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt;&gt;&gt;&gt;&gt; scope of a COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt;&gt;&gt;&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt;&gt;&gt;&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt;&gt;&gt;&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt;&gt;&gt;&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt;&gt;&gt;&gt;&gt; done in mutating functions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;&gt;&gt;&gt;&gt;  sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;&gt;&gt;&gt;&gt;  bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;   makeMutable() (inlined)<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;  // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;  // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;  // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;  // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;&gt;&gt;&gt;&gt;  // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;&gt;&gt;&gt;&gt;  %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  br %isuniq, bb_continue, bb_slow<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  bb_slow:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;&gt;&gt;&gt;&gt;  // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt;  %copied_storage_class = alloc_ref ...<br>&gt;&gt;&gt;&gt;&gt;&gt;  // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;&gt;&gt;&gt;&gt;  store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;&gt;&gt;&gt;&gt;  br bb_continue<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  bb_continue:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;&gt;&gt;&gt;&gt;  // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;&gt;&gt;&gt;&gt;  // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;&gt;&gt;&gt;&gt;  // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;&gt;&gt;&gt;&gt;  // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;&gt;&gt;&gt;&gt;  // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;&gt;&gt;&gt;&gt;  // they must be consumed within this scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;    self._storage.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;  // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // Write some data into the CoW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;  // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;&gt;&gt;&gt;&gt;  // A single-use _addr instruction, so no scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;  %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;  // A store with an implicit [exclusive] scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;  store [assign] %x to %somedata_addr<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;  // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt;&gt;&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>&gt;&gt;&gt;&gt;&gt; generates this SIL.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But it depends on implementing the general feature to insert the inout<br>&gt;&gt;&gt;&gt;&gt;&gt; scoping instructions.  Also, we still have to think through all the<br>&gt;&gt;&gt;&gt;&gt;&gt; details of this approach.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FWIW, I am convinced we will need (and get) a stricter inout model that<br>&gt;&gt;&gt;&gt;&gt; would be conducive to inserting the scoping instructions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt;&gt;&gt;&gt;&gt; --------------------------------------------------------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can only have a dependency between two things, but as phrased “a<br>&gt;&gt;&gt;&gt;&gt; buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>&gt;&gt;&gt;&gt;&gt; would fix it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt; to a scope-begin instruction::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;  %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;  %x = load %b             // No dependency between this...<br>&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;  %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;  %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;&gt;&gt;&gt;&gt; the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;&gt;&gt;&gt;&gt; reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Preconditions<br>&gt;&gt;&gt;&gt;&gt;&gt; =============<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt;&gt;&gt;&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>&gt;&gt;&gt;&gt;&gt; why this would be dependent on it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could use copy_on_write with eager bridging, but I don’t think it will give any benefits to the<br>&gt;&gt;&gt;&gt; optimizer.<br>&gt;&gt;&gt;&gt; For example, the SIL code to get from an Array to a native<br>&gt;&gt;&gt;&gt; ContiguousArrayStorage reference is pretty hard to understand for the<br>&gt;&gt;&gt;&gt; optimizer (involves low level bit operations, etc.).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It wouldn&#39;t need to do low-level bit operations if our enums were<br>&gt;&gt;&gt; capable/controllable enough.  I&#39;m just saying, there&#39;s no reason we<br>&gt;&gt;&gt; couldn&#39;t give the optimizer something to work with that has higher level<br>&gt;&gt;&gt; semantics than what we currently do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; At least for Array this is implemented as low-level bit operations and<br>&gt;&gt;&gt;&gt;&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt;&gt;&gt;&gt;&gt;&gt; RC-root for the buffer reference).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt;&gt;&gt;&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt;&gt;&gt;&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt;&gt;&gt;&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt;&gt;&gt;&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  var arr = [MyClass()]  // a global array<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;    let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;&gt;&gt;&gt;&gt;    let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;&gt;&gt;&gt;&gt;    arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;&gt;&gt;&gt;&gt;    return r.i        // use-after-free!<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I only know of one way to resolve inout and pinning:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Semantically, references are replaced with a trap value when entering<br>&gt;&gt;&gt;&gt;&gt; an inout context so that all inout values are provably unique<br>&gt;&gt;&gt;&gt;&gt; references in the absence of unsafe code.  We drop pinning and provide<br>&gt;&gt;&gt;&gt;&gt; explicit operations that provide simultaneous lvalue accesses to<br>&gt;&gt;&gt;&gt;&gt; distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>&gt;&gt;&gt;&gt;&gt; should probably decide that this is what we&#39;re doing so that we can move<br>&gt;&gt;&gt;&gt;&gt; forward without this looming uncertainty.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161019/7891a0d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 20, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 6:36 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 19, 2016, at 10:13 AM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Oct 18 2016, Erik Eckstein &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 17, 2016, at 10:21 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Oct 17 2016, Erik Eckstein &lt;eeckstein-AT-apple.com &lt;http://eeckstein-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:05 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt; &lt;http://swift-dev-at-swift.org/ &lt;http://swift-dev-at-swift.org/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The SIL-level design seems sensible to me at a glance. At the language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; level, I think it would make more sense to treat this as an attribute<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on class types rather than on properties in structs using the class. I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; don&#39;t think many people reuse class definitions as both shared<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference types and as value type payloads, <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Foundation does, or would if they could.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but beyond that, I think that making it an attribute of classes would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; put us into a better position to leverage the borrow model to enforce<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; references a move-only type, so that as long as you were just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; working with the raw reference (as opposed to the CoW aggregate,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would remain copyable) it wouldn&#39;t get implicitly copied<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anymore.  You could have mutable and immutable buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types, both move-only, and there could be a consuming checkUnique<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operation on the immutable one that, I dunno, returned an Either of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the mutable and immutable versions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to make sure that the CoW attribute was still copyable.  Within the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of the type, though, you would be projecting out the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference immediately, and thereafter you&#39;d be certain that you were<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; borrowing / moving it around as appropriate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique and nonunique references to the class. A unique reference would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; act like a move-only type to prevent accidental loss of uniqueness. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We can also allow a copy-on-write class to have &quot;mutating&quot; methods,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and only allow mutation on unique references. It seems to me like,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploring this direction, we could also come up with a way for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; high-level value-semantics operations on the struct to statically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; indicate which methods are known to leave the value&#39;s buffers in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique state, or which return values that are uniquely owned, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would give the optimizer more ability to avoid uniqueness checks<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; across calls without relying on inlining and IPO.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s pretty cool.  However, I think there&#39;s nothing to prevent any<br>&gt;&gt;&gt;&gt;&gt;&gt; mutating method from storing a copy of self in a global, so I think we&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt; need some participation from the programmer (either an agreement not to<br>&gt;&gt;&gt;&gt;&gt;&gt; do that, or an explicit claim of uniqueness on exit) in order to<br>&gt;&gt;&gt;&gt;&gt;&gt; identify operations that create/preserve uniqueness.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If a mutating reference (like self in a mutating method) is move-only<br>&gt;&gt;&gt;&gt;&gt; then you would not be able to “copy” it to a global.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, a reference to a move-only type would work for this purpose.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:01 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; :orphan:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. highlight:: sil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. contents::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overview<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ========<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the same way as a programmer can do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW Types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; =========<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  class COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var someData: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func change_it() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      if (!isUniquelyReferenced(b)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        b = copy_buffer(b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      b.someData = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(arr : [Int]) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    x = arr[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    opaque_function()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; has to copy it. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ...or determine that it&#39;s uniquely-referenced.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this specific example, if opqaue_function holds a reference to arr’s buffer, the buffer is not<br>&gt;&gt;&gt;&gt;&gt; uniquely-referenced.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that opaque_function() will write to the location of arr[0].<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; =================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift Syntax<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It does not change the semantics of the program.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Presumably, it changes what code you can execute on `b` without invoking<br>&gt;&gt;&gt;&gt;&gt;&gt; traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>&gt;&gt;&gt;&gt;&gt;&gt; to do anything differently to take advantage of the annotation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s true.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What are the rules for writing code that uses `copy_on_write`?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; See below (&quot;The rules for using ``copy_on_write`` and the built-ins are:”)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, I got there, eventually.  But just saying “doesn&#39;t change<br>&gt;&gt;&gt;&gt; semantics” at this point in the proposal leaves a gap, because it does<br>&gt;&gt;&gt;&gt; change semantic *requirements*.  You should mention that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another question is if we should open this attribute for the public or just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; use it internally in the library, because violating the implied rules<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (see below) could break memory safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer class type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type to a regular reference type::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  cow_to_ref<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ref_to_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example the SIL code for::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  var c: COWType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  let x = c.b.someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would be::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; =============================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; during the lifetime of the reference.*<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This seems like much too broad a rule to allow inplace mutations of<br>&gt;&gt;&gt;&gt;&gt;&gt; uniquely referenced buffers.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The point is that all mutations must be guarded by an is_unique, which<br>&gt;&gt;&gt;&gt;&gt; takes the _address_ of the buffer reference as argument.<br>&gt;&gt;&gt;&gt;&gt; And the optimizer considers this instruction as a potential write to the buffer reference.<br>&gt;&gt;&gt;&gt;&gt; The effect is that the lifetime of a buffer reference (as a SIL value)<br>&gt;&gt;&gt;&gt;&gt; will not outlive a is_unique - regardless if this is inside a called<br>&gt;&gt;&gt;&gt;&gt; function or inlined.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see how that allows me to mutate a uniquely referenced buffer held<br>&gt;&gt;&gt;&gt; in a @sil_cow reference, given what you wrote above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You would not be able to get a reference to a mutable buffer by<br>&gt;&gt;&gt; reading the COW type’s @sil_cow field.  Instead you would only get<br>&gt;&gt;&gt; such a reference as a result of the is_unique instruction/builtin. Or,<br>&gt;&gt;&gt; of course, by creating a new buffer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure if this was the question, though.<br>&gt;&gt; <br>&gt;&gt; I think it just comes down to precise phrasing.  AFAICT, what you really<br>&gt;&gt; mean to say is something like<br>&gt;&gt; <br>&gt;&gt;  A buffer cannot be directly mutated through a @sil_cow reference;<br>&gt;&gt;  instead one must mutate it indirectly via the result of is_unique or<br>&gt;&gt;  start_unique.<br></p><p>Exactly, that’s what I wanted to say.<br></p><p>&gt;&gt; <br>&gt;&gt; Saying that the buffer is “considered to be immmutable during the<br>&gt;&gt; lifetime of the reference” could be taken to mean that the compiler will<br>&gt;&gt; assume no mutations of the buffer can occur while the reference exists.<br>&gt;&gt; IIUC you are not planning to formally end the reference&#39;s lifetime at<br>&gt;&gt; the moment is_unique/start_unique returns.<br>&gt; <br>&gt; To clarify: I proposed an alternate approach in which the @sil_cow reference is only mutable during the Array’s @inout scope—to be automatically enforced by the compiler once @inout scopes are enforced. But the text in question is not referring to that approach, so your comments are on target.<br></p><p>After thinking about Joe’s suggestion (having the cow attribute on the class type and make a reference to that type move-only), I’m more inclined to go with the isUnique builtin. If such a reference can only be returned by isUnique, it is really guaranteed that only a uniquely referenced buffer can be mutated. With the inout approach, the programmer is not forced to make the uniqueness check before modifying the buffer.<br></p><p>&gt; -Andy <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Plus: we will have an explicit conversion instruction (start_unique) to convert an immutable<br>&gt;&gt;&gt; reference to a mutable referece.<br>&gt;&gt;&gt; A SIL optimization can replace an is_unique with this instruction if it can prove that the reference<br>&gt;&gt;&gt; is already unique at that point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Unless you mean the reference is<br>&gt;&gt;&gt;&gt;&gt;&gt; immutable, rather than the storage being referred to by it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; considered to point to immutable memory.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; representation in SIL:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Redundant load elimination<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; RLE can assume that opaque code does not modify a COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How do you distinguish “opaque code” from “code that is meant to<br>&gt;&gt;&gt;&gt;&gt;&gt; modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Again, the is_unique which takes the address of the reference, will<br>&gt;&gt;&gt;&gt;&gt; guarantee that during the lifetime of a buffer there are no<br>&gt;&gt;&gt;&gt;&gt; modifications of the buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Again, that sounds like it rules out inplace modification of uniquely<br>&gt;&gt;&gt;&gt; referenced buffers.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; like array count propagation. These hacks would not be needed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; W0000000000000000000000t.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; memory.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - CSE, loop hoisting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Same question here as above, then.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - ARC optimization<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can remove retain/release pairs across such code::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // Use %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    destroy_value %4 : $MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer reference. For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // load something from %b1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // load something from %b2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Looks reasonable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // there should be a begin-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b    // modification of the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // there should be a end-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %y = load %b        // load from the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = load %baddr        // moved out of the loop<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %y = load %b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; also hoist the load::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -----------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb0:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // usually empty<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    br bb3(%1 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb2:                  // the false-block<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // usually contains:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = apply %copy_buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = cow_to_ref %2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    br bb3(%2 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb3(%4 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // Modify the buffer referenced by %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_unique_addr %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; verifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; across these instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // do something with %1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; from the COWType.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``end_unique_addr``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(arr : [Int], x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    arr[0] = 27<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    y = arr[x]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb0:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb1(%1 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    … // main control flow continues here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    unreachable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Built-ins<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;        return uniqueBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      self.b = copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      return copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This seems reasonable, but it also looks like the compiler could do the<br>&gt;&gt;&gt;&gt;&gt;&gt; `endUnique` dance for us based, e.g., on the mutability of methods.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree, that would be ideal, e.g. the compiler could insert the endUnique at the end of an inout<br>&gt;&gt;&gt;&gt;&gt; scope.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can do its job).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what the implications of these diamonds and the problem<br>&gt;&gt;&gt;&gt;&gt;&gt; described above might be, FWIW.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; pair.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the purpose of copying.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Examples::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // violates rule 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    self.b.someData = x // violates rule 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func incrementSomeData() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It would be instructive to write down the *correct* code for these<br>&gt;&gt;&gt;&gt;&gt;&gt; operations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; added to my todo list.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the unique buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No big deal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; scope of a COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; done in mutating functions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;   makeMutable() (inlined)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  br %isuniq, bb_continue, bb_slow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_slow:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %copied_storage_class = alloc_ref ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  br bb_continue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_continue:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // they must be consumed within this scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;    self._storage.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Write some data into the CoW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A single-use _addr instruction, so no scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A store with an implicit [exclusive] scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store [assign] %x to %somedata_addr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>&gt;&gt;&gt;&gt;&gt;&gt; generates this SIL.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But it depends on implementing the general feature to insert the inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; scoping instructions.  Also, we still have to think through all the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; details of this approach.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I am convinced we will need (and get) a stricter inout model that<br>&gt;&gt;&gt;&gt;&gt;&gt; would be conducive to inserting the scoping instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You can only have a dependency between two things, but as phrased “a<br>&gt;&gt;&gt;&gt;&gt;&gt; buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>&gt;&gt;&gt;&gt;&gt;&gt; would fix it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a scope-begin instruction::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %x = load %b             // No dependency between this...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Preconditions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; =============<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>&gt;&gt;&gt;&gt;&gt;&gt; why this would be dependent on it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could use copy_on_write with eager bridging, but I don’t think it will give any benefits to the<br>&gt;&gt;&gt;&gt;&gt; optimizer.<br>&gt;&gt;&gt;&gt;&gt; For example, the SIL code to get from an Array to a native<br>&gt;&gt;&gt;&gt;&gt; ContiguousArrayStorage reference is pretty hard to understand for the<br>&gt;&gt;&gt;&gt;&gt; optimizer (involves low level bit operations, etc.).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It wouldn&#39;t need to do low-level bit operations if our enums were<br>&gt;&gt;&gt;&gt; capable/controllable enough.  I&#39;m just saying, there&#39;s no reason we<br>&gt;&gt;&gt;&gt; couldn&#39;t give the optimizer something to work with that has higher level<br>&gt;&gt;&gt;&gt; semantics than what we currently do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; At least for Array this is implemented as low-level bit operations and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; RC-root for the buffer reference).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  var arr = [MyClass()]  // a global array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    return r.i        // use-after-free!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I only know of one way to resolve inout and pinning:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Semantically, references are replaced with a trap value when entering<br>&gt;&gt;&gt;&gt;&gt;&gt; an inout context so that all inout values are provably unique<br>&gt;&gt;&gt;&gt;&gt;&gt; references in the absence of unsafe code.  We drop pinning and provide<br>&gt;&gt;&gt;&gt;&gt;&gt; explicit operations that provide simultaneous lvalue accesses to<br>&gt;&gt;&gt;&gt;&gt;&gt; distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>&gt;&gt;&gt;&gt;&gt;&gt; should probably decide that this is what we&#39;re doing so that we can move<br>&gt;&gt;&gt;&gt;&gt;&gt; forward without this looming uncertainty.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/ddb41800/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 20, 2016 at 08:00:00am</p></header><div class="content"><p>We might want to leave some room in the design for a shared atomic cache reference to live in the buffer, FWIW. It would have to be mutable even when the buffer was multiply-referenced <br></p><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Oct 20, 2016, at 8:41 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 6:36 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 10:13 AM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Oct 18 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 17, 2016, at 10:21 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Mon Oct 17 2016, Erik Eckstein &lt;eeckstein-AT-apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:05 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The SIL-level design seems sensible to me at a glance. At the language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; level, I think it would make more sense to treat this as an attribute<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on class types rather than on properties in structs using the class. I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; don&#39;t think many people reuse class definitions as both shared<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference types and as value type payloads, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Foundation does, or would if they could.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but beyond that, I think that making it an attribute of classes would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; put us into a better position to leverage the borrow model to enforce<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; references a move-only type, so that as long as you were just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; working with the raw reference (as opposed to the CoW aggregate,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would remain copyable) it wouldn&#39;t get implicitly copied<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anymore.  You could have mutable and immutable buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types, both move-only, and there could be a consuming checkUnique<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operation on the immutable one that, I dunno, returned an Either of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the mutable and immutable versions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to make sure that the CoW attribute was still copyable.  Within the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of the type, though, you would be projecting out the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference immediately, and thereafter you&#39;d be certain that you were<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; borrowing / moving it around as appropriate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique and nonunique references to the class. A unique reference would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; act like a move-only type to prevent accidental loss of uniqueness. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We can also allow a copy-on-write class to have &quot;mutating&quot; methods,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and only allow mutation on unique references. It seems to me like,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploring this direction, we could also come up with a way for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; high-level value-semantics operations on the struct to statically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; indicate which methods are known to leave the value&#39;s buffers in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique state, or which return values that are uniquely owned, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would give the optimizer more ability to avoid uniqueness checks<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; across calls without relying on inlining and IPO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s pretty cool.  However, I think there&#39;s nothing to prevent any<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating method from storing a copy of self in a global, so I think we&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; need some participation from the programmer (either an agreement not to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; do that, or an explicit claim of uniqueness on exit) in order to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; identify operations that create/preserve uniqueness.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If a mutating reference (like self in a mutating method) is move-only<br>&gt;&gt;&gt;&gt;&gt;&gt; then you would not be able to “copy” it to a global.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, a reference to a move-only type would work for this purpose.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:01 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; :orphan:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. highlight:: sil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. contents::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overview<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ========<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the same way as a programmer can do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW Types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =========<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  class COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var someData: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func change_it() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      if (!isUniquelyReferenced(b)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;        b = copy_buffer(b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      b.someData = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(arr : [Int]) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    x = arr[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    opaque_function()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; has to copy it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ...or determine that it&#39;s uniquely-referenced.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this specific example, if opqaue_function holds a reference to arr’s buffer, the buffer is not<br>&gt;&gt;&gt;&gt;&gt;&gt; uniquely-referenced.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that opaque_function() will write to the location of arr[0].<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift Syntax<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It does not change the semantics of the program.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Presumably, it changes what code you can execute on `b` without invoking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to do anything differently to take advantage of the annotation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s true.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What are the rules for writing code that uses `copy_on_write`?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; See below (&quot;The rules for using ``copy_on_write`` and the built-ins are:”)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah, I got there, eventually.  But just saying “doesn&#39;t change<br>&gt;&gt;&gt;&gt;&gt; semantics” at this point in the proposal leaves a gap, because it does<br>&gt;&gt;&gt;&gt;&gt; change semantic *requirements*.  You should mention that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another question is if we should open this attribute for the public or just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; use it internally in the library, because violating the implied rules<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (see below) could break memory safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer class type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type to a regular reference type::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  cow_to_ref<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ref_to_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example the SIL code for::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  var c: COWType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  let x = c.b.someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would be::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =============================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; during the lifetime of the reference.*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seems like much too broad a rule to allow inplace mutations of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; uniquely referenced buffers.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The point is that all mutations must be guarded by an is_unique, which<br>&gt;&gt;&gt;&gt;&gt;&gt; takes the _address_ of the buffer reference as argument.<br>&gt;&gt;&gt;&gt;&gt;&gt; And the optimizer considers this instruction as a potential write to the buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt; The effect is that the lifetime of a buffer reference (as a SIL value)<br>&gt;&gt;&gt;&gt;&gt;&gt; will not outlive a is_unique - regardless if this is inside a called<br>&gt;&gt;&gt;&gt;&gt;&gt; function or inlined.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t see how that allows me to mutate a uniquely referenced buffer held<br>&gt;&gt;&gt;&gt;&gt; in a @sil_cow reference, given what you wrote above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You would not be able to get a reference to a mutable buffer by<br>&gt;&gt;&gt;&gt; reading the COW type’s @sil_cow field.  Instead you would only get<br>&gt;&gt;&gt;&gt; such a reference as a result of the is_unique instruction/builtin. Or,<br>&gt;&gt;&gt;&gt; of course, by creating a new buffer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure if this was the question, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it just comes down to precise phrasing.  AFAICT, what you really<br>&gt;&gt;&gt; mean to say is something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  A buffer cannot be directly mutated through a @sil_cow reference;<br>&gt;&gt;&gt;  instead one must mutate it indirectly via the result of is_unique or<br>&gt;&gt;&gt;  start_unique.<br>&gt; <br>&gt; Exactly, that’s what I wanted to say.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Saying that the buffer is “considered to be immmutable during the<br>&gt;&gt;&gt; lifetime of the reference” could be taken to mean that the compiler will<br>&gt;&gt;&gt; assume no mutations of the buffer can occur while the reference exists.<br>&gt;&gt;&gt; IIUC you are not planning to formally end the reference&#39;s lifetime at<br>&gt;&gt;&gt; the moment is_unique/start_unique returns.<br>&gt;&gt; <br>&gt;&gt; To clarify: I proposed an alternate approach in which the @sil_cow reference is only mutable during the Array’s @inout scope—to be automatically enforced by the compiler once @inout scopes are enforced. But the text in question is not referring to that approach, so your comments are on target.<br>&gt; <br>&gt; After thinking about Joe’s suggestion (having the cow attribute on the class type and make a reference to that type move-only), I’m more inclined to go with the isUnique builtin. If such a reference can only be returned by isUnique, it is really guaranteed that only a uniquely referenced buffer can be mutated. With the inout approach, the programmer is not forced to make the uniqueness check before modifying the buffer.<br>&gt; <br>&gt;&gt; -Andy <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Plus: we will have an explicit conversion instruction (start_unique) to convert an immutable<br>&gt;&gt;&gt;&gt; reference to a mutable referece.<br>&gt;&gt;&gt;&gt; A SIL optimization can replace an is_unique with this instruction if it can prove that the reference<br>&gt;&gt;&gt;&gt; is already unique at that point.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unless you mean the reference is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; immutable, rather than the storage being referred to by it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; considered to point to immutable memory.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; representation in SIL:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Redundant load elimination<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; RLE can assume that opaque code does not modify a COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How do you distinguish “opaque code” from “code that is meant to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Again, the is_unique which takes the address of the reference, will<br>&gt;&gt;&gt;&gt;&gt;&gt; guarantee that during the lifetime of a buffer there are no<br>&gt;&gt;&gt;&gt;&gt;&gt; modifications of the buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Again, that sounds like it rules out inplace modification of uniquely<br>&gt;&gt;&gt;&gt;&gt; referenced buffers.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like array count propagation. These hacks would not be needed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; W0000000000000000000000t.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; memory.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - CSE, loop hoisting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Same question here as above, then.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - ARC optimization<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can remove retain/release pairs across such code::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // Use %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    destroy_value %4 : $MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer reference. For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // load something from %b1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // load something from %b2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Looks reasonable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // there should be a begin-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b    // modification of the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // there should be a end-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %y = load %b        // load from the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = load %baddr        // moved out of the loop<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %y = load %b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; also hoist the load::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -----------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb0:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // usually empty<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    br bb3(%1 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb2:                  // the false-block<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // usually contains:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = apply %copy_buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = cow_to_ref %2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    br bb3(%2 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb3(%4 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // Modify the buffer referenced by %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_unique_addr %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; verifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; across these instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // do something with %1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from the COWType.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``end_unique_addr``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(arr : [Int], x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    arr[0] = 27<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    y = arr[x]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb0:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb1(%1 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    … // main control flow continues here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    unreachable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Built-ins<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;        return uniqueBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      self.b = copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      return copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seems reasonable, but it also looks like the compiler could do the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `endUnique` dance for us based, e.g., on the mutability of methods.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree, that would be ideal, e.g. the compiler could insert the endUnique at the end of an inout<br>&gt;&gt;&gt;&gt;&gt;&gt; scope.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can do its job).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what the implications of these diamonds and the problem<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; described above might be, FWIW.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pair.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the purpose of copying.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Examples::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // violates rule 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    self.b.someData = x // violates rule 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func incrementSomeData() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be instructive to write down the *correct* code for these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; added to my todo list.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the unique buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No big deal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; scope of a COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; done in mutating functions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;   makeMutable() (inlined)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  br %isuniq, bb_continue, bb_slow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_slow:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %copied_storage_class = alloc_ref ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  br bb_continue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_continue:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // they must be consumed within this scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;    self._storage.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Write some data into the CoW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A single-use _addr instruction, so no scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A store with an implicit [exclusive] scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store [assign] %x to %somedata_addr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; generates this SIL.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But it depends on implementing the general feature to insert the inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; scoping instructions.  Also, we still have to think through all the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; details of this approach.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I am convinced we will need (and get) a stricter inout model that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would be conducive to inserting the scoping instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You can only have a dependency between two things, but as phrased “a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would fix it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a scope-begin instruction::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %x = load %b             // No dependency between this...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Preconditions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =============<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; why this would be dependent on it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We could use copy_on_write with eager bridging, but I don’t think it will give any benefits to the<br>&gt;&gt;&gt;&gt;&gt;&gt; optimizer.<br>&gt;&gt;&gt;&gt;&gt;&gt; For example, the SIL code to get from an Array to a native<br>&gt;&gt;&gt;&gt;&gt;&gt; ContiguousArrayStorage reference is pretty hard to understand for the<br>&gt;&gt;&gt;&gt;&gt;&gt; optimizer (involves low level bit operations, etc.).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It wouldn&#39;t need to do low-level bit operations if our enums were<br>&gt;&gt;&gt;&gt;&gt; capable/controllable enough.  I&#39;m just saying, there&#39;s no reason we<br>&gt;&gt;&gt;&gt;&gt; couldn&#39;t give the optimizer something to work with that has higher level<br>&gt;&gt;&gt;&gt;&gt; semantics than what we currently do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; At least for Array this is implemented as low-level bit operations and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; RC-root for the buffer reference).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  var arr = [MyClass()]  // a global array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    return r.i        // use-after-free!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I only know of one way to resolve inout and pinning:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Semantically, references are replaced with a trap value when entering<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an inout context so that all inout values are provably unique<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; references in the absence of unsafe code.  We drop pinning and provide<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; explicit operations that provide simultaneous lvalue accesses to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should probably decide that this is what we&#39;re doing so that we can move<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; forward without this looming uncertainty.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/c23591c8/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 8:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; We might want to leave some room in the design for a shared atomic cache reference to live in the buffer, FWIW. It would have to be mutable even when the buffer was multiply-referenced <br></p><p>Should be no problem with an attribute on that field. Like ‘mutable&#39; in C++.<br>&gt; <br>&gt; Sent from my moss-covered three-handled family gradunza<br>&gt; <br>&gt; On Oct 20, 2016, at 8:41 AM, Erik Eckstein &lt;eeckstein at apple.com &lt;mailto:eeckstein at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 6:36 PM, Andrew Trick via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 19, 2016, at 10:13 AM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Oct 18 2016, Erik Eckstein &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 17, 2016, at 10:21 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Mon Oct 17 2016, Erik Eckstein &lt;eeckstein-AT-apple.com &lt;http://eeckstein-at-apple.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:05 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt; &lt;http://swift-dev-at-swift.org/ &lt;http://swift-dev-at-swift.org/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 4:48 PM, Erik Eckstein via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;CopyOnWrite.rst&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you have any comments, please let me know.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The SIL-level design seems sensible to me at a glance. At the language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; level, I think it would make more sense to treat this as an attribute<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on class types rather than on properties in structs using the class. I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; don&#39;t think many people reuse class definitions as both shared<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference types and as value type payloads, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Foundation does, or would if they could.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but beyond that, I think that making it an attribute of classes would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; put us into a better position to leverage the borrow model to enforce<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the &quot;mutable-only-when-unique&quot; aspect of COW implementations. John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alluded to this in the &quot;SIL address types and borrowing&quot; thread:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wonder if it would make more sense to make copy-on-write buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; references a move-only type, so that as long as you were just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; working with the raw reference (as opposed to the CoW aggregate,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would remain copyable) it wouldn&#39;t get implicitly copied<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anymore.  You could have mutable and immutable buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types, both move-only, and there could be a consuming checkUnique<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operation on the immutable one that, I dunno, returned an Either of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the mutable and immutable versions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For CoW aggregates, you&#39;d need some @copied attribute on the field<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to make sure that the CoW attribute was still copyable.  Within the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of the type, though, you would be projecting out the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference immediately, and thereafter you&#39;d be certain that you were<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; borrowing / moving it around as appropriate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If &#39;copy-on-write&#39; were a trait on classes, then we could distinguish<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique and nonunique references to the class. A unique reference would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; act like a move-only type to prevent accidental loss of uniqueness. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We can also allow a copy-on-write class to have &quot;mutating&quot; methods,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and only allow mutation on unique references. It seems to me like,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exploring this direction, we could also come up with a way for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; high-level value-semantics operations on the struct to statically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; indicate which methods are known to leave the value&#39;s buffers in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique state, or which return values that are uniquely owned, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would give the optimizer more ability to avoid uniqueness checks<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; across calls without relying on inlining and IPO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s pretty cool.  However, I think there&#39;s nothing to prevent any<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating method from storing a copy of self in a global, so I think we&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need some participation from the programmer (either an agreement not to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do that, or an explicit claim of uniqueness on exit) in order to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identify operations that create/preserve uniqueness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If a mutating reference (like self in a mutating method) is move-only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; then you would not be able to “copy” it to a global.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, a reference to a move-only type would work for this purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 2:01 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Oct 11 2016, Erik Eckstein &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is a proposal for representing copy-on-write buffers in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL. Actually it’s still a draft for a proposal. It also heavily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; depends on how we move forward with SIL ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; :orphan:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. highlight:: sil<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Copy-On-Write Representation in SIL<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ===================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. contents::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overview<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ========<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - An ownership attribute to define copy-on-write (COW) buffers in Swift data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - A representation of COW buffers in SIL so that optimizations can take benefit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic idea is to enable the SIL optimizer to reason about COW data types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in the same way as a programmer can do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means: a COW buffer can only be modified by its owning SIL value, because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either it&#39;s uniquely referenced or the buffer is copied before modified.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  In the following the term &quot;buffer&quot; refers to a Swift heap object.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  It can be any heap object, not necessarily a “buffer” with e.g. tail-allocated elements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW Types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =========<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic structure of COW data types can be simplified as follows::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  class COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var someData: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func change_it() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      if (!isUniquelyReferenced(b)) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;        b = copy_buffer(b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      b.someData = ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently the COW behavior of such types is just defined by their implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But there is no representation of this special behavior in the SIL.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So the SIL optimizer has no clue about it and cannot take advantage of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(arr : [Int]) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    x = arr[0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    opaque_function()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    y = arr[0] // can RLE replace this with y = x?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If opaque_function() wants to change the contents of the array buffer it first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; has to copy it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ...or determine that it&#39;s uniquely-referenced.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In this specific example, if opqaue_function holds a reference to arr’s buffer, the buffer is not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; uniquely-referenced.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But the optimizer does not know it so it has to conservatively assume<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that opaque_function() will write to the location of arr[0].<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Copy-on-write Ownership Attribute<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =================================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This section proposes an ownership attribute to define a copy-on-write buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift Syntax<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A COW buffer reference can be defined with a new ownership attribute for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer variable declaration (similar to “weak” and “unowned”)::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` attribute is purely used for optimization purposes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It does not change the semantics of the program.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Presumably, it changes what code you can execute on `b` without invoking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; traps or undefined behavior.  Otherwise, the optimizer wouldn&#39;t be able<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to do anything differently to take advantage of the annotation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s true.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What are the rules for writing code that uses `copy_on_write`?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; See below (&quot;The rules for using ``copy_on_write`` and the built-ins are:”)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah, I got there, eventually.  But just saying “doesn&#39;t change<br>&gt;&gt;&gt;&gt;&gt;&gt; semantics” at this point in the proposal leaves a gap, because it does<br>&gt;&gt;&gt;&gt;&gt;&gt; change semantic *requirements*.  You should mention that.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “copy_on_write” is a  working title. TODO: decide on the name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe it should be a @-attribute, like @copy_on_write?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another question is if we should open this attribute for the public or just<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; use it internally in the library, because violating the implied rules<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (see below) could break memory safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``copy_on_write`` references can be represented in the AST as a special<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``StorageType``, just like how ``unowned`` and ``weak`` is represented.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The canonical type of a ``CopyOnWriteStorageType`` would be the referenced<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer class type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In SIL the buffer reference will have type::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where ``COWBuffer`` is the type of the referenced heap object.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Two conversion instructions are needed to convert from a ``@sil_cow`` reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type to a regular reference type::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  cow_to_ref<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ref_to_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Again, this is similar to ``ref_to_unowned`` and ``unowned_to_ref``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example the SIL code for::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  var c: COWType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  let x = c.b.someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would be::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = struct_extract %1 : COWType, #COWType.b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %3 = ref_element_addr %2 : $COWBuffer, #COWBuffer.someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``ref_to_cow`` instruction is needed to store a new buffer reference into a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW Buffers and the Optimizer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =============================<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A reference to a COW buffer gives the optimizer additional information:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *A buffer, referenced by a @sil_cow reference is considered to be immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; during the lifetime of the reference.*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seems like much too broad a rule to allow inplace mutations of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; uniquely referenced buffers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The point is that all mutations must be guarded by an is_unique, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; takes the _address_ of the buffer reference as argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the optimizer considers this instruction as a potential write to the buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The effect is that the lifetime of a buffer reference (as a SIL value)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; will not outlive a is_unique - regardless if this is inside a called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function or inlined.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t see how that allows me to mutate a uniquely referenced buffer held<br>&gt;&gt;&gt;&gt;&gt;&gt; in a @sil_cow reference, given what you wrote above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You would not be able to get a reference to a mutable buffer by<br>&gt;&gt;&gt;&gt;&gt; reading the COW type’s @sil_cow field.  Instead you would only get<br>&gt;&gt;&gt;&gt;&gt; such a reference as a result of the is_unique instruction/builtin. Or,<br>&gt;&gt;&gt;&gt;&gt; of course, by creating a new buffer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure if this was the question, though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it just comes down to precise phrasing.  AFAICT, what you really<br>&gt;&gt;&gt;&gt; mean to say is something like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  A buffer cannot be directly mutated through a @sil_cow reference;<br>&gt;&gt;&gt;&gt;  instead one must mutate it indirectly via the result of is_unique or<br>&gt;&gt;&gt;&gt;  start_unique.<br>&gt;&gt; <br>&gt;&gt; Exactly, that’s what I wanted to say.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Saying that the buffer is “considered to be immmutable during the<br>&gt;&gt;&gt;&gt; lifetime of the reference” could be taken to mean that the compiler will<br>&gt;&gt;&gt;&gt; assume no mutations of the buffer can occur while the reference exists.<br>&gt;&gt;&gt;&gt; IIUC you are not planning to formally end the reference&#39;s lifetime at<br>&gt;&gt;&gt;&gt; the moment is_unique/start_unique returns.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To clarify: I proposed an alternate approach in which the @sil_cow reference is only mutable during the Array’s @inout scope—to be automatically enforced by the compiler once @inout scopes are enforced. But the text in question is not referring to that approach, so your comments are on target.<br>&gt;&gt; <br>&gt;&gt; After thinking about Joe’s suggestion (having the cow attribute on the class type and make a reference to that type move-only), I’m more inclined to go with the isUnique builtin. If such a reference can only be returned by isUnique, it is really guaranteed that only a uniquely referenced buffer can be mutated. With the inout approach, the programmer is not forced to make the uniqueness check before modifying the buffer.<br>&gt;&gt; <br>&gt;&gt;&gt; -Andy <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Plus: we will have an explicit conversion instruction (start_unique) to convert an immutable<br>&gt;&gt;&gt;&gt;&gt; reference to a mutable referece.<br>&gt;&gt;&gt;&gt;&gt; A SIL optimization can replace an is_unique with this instruction if it can prove that the reference<br>&gt;&gt;&gt;&gt;&gt; is already unique at that point.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unless you mean the reference is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; immutable, rather than the storage being referred to by it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means any address derived from a ``cow_to_ref`` instruction can be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; considered to point to immutable memory.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some examples of optimizations which will benefit from copy-on-write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; representation in SIL:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Redundant load elimination<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; RLE can assume that opaque code does not modify a COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How do you distinguish “opaque code” from “code that is meant to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; modify the buffer and might do so in place if it&#39;s uniquely-referenced?”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Again, the is_unique which takes the address of the reference, will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guarantee that during the lifetime of a buffer there are no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; modifications of the buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Again, that sounds like it rules out inplace modification of uniquely<br>&gt;&gt;&gt;&gt;&gt;&gt; referenced buffers.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %4 = load %3 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %5 = apply %foo()                        // Cannot overwrite memory location %3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %6 = load %3 : $*Int                     // Can be replaced by %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently we do some ad-hoc optimizations for array, based on semantics,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like array count propagation. These hacks would not be needed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; W0000000000000000000000t.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that it’s not required to check if a ``cow_to_ref`` reference (or a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; projected address) escapes. Even if it escapes, it will reference immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; memory.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - CSE, loop hoisting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Similar to RLE: the optimizer can assume that opaque code cannot modify a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Same question here as above, then.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - ARC optimization<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Knowing that some opaque code cannot overwrite a reference in the COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can remove retain/release pairs across such code::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = ref_element_addr %2 : $COWBuffer, #someRef<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %4 = load_strong %3 : $*MyClass          // Can do a load_strong [guarantee]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %5 = apply %foo()                        // Cannot overwrite someRef and dealloc the object<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // Use %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    destroy_value %4 : $MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To let the optimizer reason about the immutability of the COW buffer, it is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; important to *bind* the lifetime of the buffer content to the lifetime of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer reference. For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b1 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // load something from %b1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %a = apply %foo(%baddr : $@sil_cow COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b2 = load %baddr : $@sil_cow COWBuffer  // load the buffer reference again<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // load something from %b2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The question is: can RLE forward the load of the buffer reference and replace<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``%b2`` with ``%b1``? It must not be able to do so if ``foo()`` modifies the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To enforce this restriction, the scope of any buffer modification must be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enclosed in a pair of SIL instructions. Those instructions define the scope<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the mutation. Both instructions take the *address* of the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference as operand and act as a potential write to the buffer reference. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The purpose of the scoping instructions is to strictly separate the liferanges<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of references to an immutable buffer and references to the mutable buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Looks reasonable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following example shows why the scoping instructions (specifically the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end-of-scope instruction) are required to prevent loop-hoisting from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interleaving mutable and immutable liferanges::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // there should be a begin-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b    // modification of the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // there should be a end-of-scope %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %y = load %b        // load from the buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If there is no end-of-scope instruction, loop hoisting could do::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = load %baddr        // moved out of the loop<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %y = load %b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now the optimizer assumes that ``%b`` references an immutable buffer, so it could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; also hoist the load::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %mut_b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %y = load %b          // Wrong! Will be overwritten by the following store<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store %x to %mut_b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  loop {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The following sections describe two alternatives to implement the scoping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping Alternative 1: Explicit Built-ins<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -----------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; SIL instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The existing ``is_unique`` instruction is changed to a terminator instruction::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb0:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    is_unique_addr_br %0 : $*@sil_cow COWBuffer, bb1, bb2  // %0 is the address of the COWBuffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb1(%1 : $COWBuffer): // the true-block. The payload %1 is the unique reference. Physically identical to &quot;load %0”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // usually empty<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    br bb3(%1 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb2:                  // the false-block<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // usually contains:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %2 = apply %copy_buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    %3 = cow_to_ref %2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    store_strong %3 to %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    br bb3(%2 : $COWBuffer)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb3(%4 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // Modify the buffer referenced by %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The end-of-scope instruction is::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_unique_addr %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is important that the references to the unique buffers (``%1``, ``%2``) must<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not outlive ``end_unique_addr``. In most cases this can be check by the SIL<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; verifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The two instructions must be paired properly but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The purpose of an ``is_unique_addr_br`` - ``end_unique_addr`` pair is to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; separate the lifetimes of mutable and immutable accesses to the COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Both instructions take an address to the COW buffer reference and are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; considered as potential stores to the reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sure that the SIL optimizer cannot mix-up buffer reference lifetimes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; across these instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, RLE cannot combine two buffer loads which are interleaved with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a ``is_unique_addr_br``::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = load_strong %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // do something with %1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  is_unique_addr_br %0 : $*@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %2 = load_strong %0 : $*@sil_cow COWBuffer // RLE cannot replace this with %1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another important thing is that the COW buffer can only be mutated by using the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference of the ``is_unique_addr_br`` true-block argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The COW buffer cannot be modified by simply loading/extracting the reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from the COWType.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %1 = load_strong %0 : $*COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %2 = cow_to_ref %1 : $@sil_cow COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %3 = ref_element_addr %2 : $COWBuffer, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; store %7 : $Int to %3 : $*Int            // Violation!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Most obvious violations to this constraint can be catched by the SILVerifier.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``_addr`` variants of the instructions also have a non-addr counterpart::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  is_unique_br %0 : $COWBuffer, bb1, bb2.  // consumes %0 and produces the true-block arg as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = end_unique %0 : $COWBuffer // consumes %0 and produces %1 as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; These instructions are generated by Mem2reg (or a similar optimization)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in case the COW value is stored (in a temporary alloc_stack location)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; just for the sake of passing an address to ``is_unique_addr_br`` and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``end_unique_addr``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example in the following code, where the COW data is passed as-value and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; all the mutating functions are inlined::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(arr : [Int], x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    arr[0] = 27<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    y = arr[x]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally it’s probably a good idea to add an instruction for converting an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; immutable reference to a mutable reference::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %1 = start_unique %0 : $COWBuffer // consumes %0 and produces %1 : $COWBuffer as owned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is basically just a simpler representation of the following pattern::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb0:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    is_unique_br %0 : $@sil_cow COWBuffer, bb1, bb2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb1(%1 : $COWBuffer):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    … // main control flow continues here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    unreachable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; An optimizations, which eliminate uniqueness checks, would replace a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ``is_unique_br`` by a ``start_unique``.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Built-ins<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ^^^^^^^^^<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A COW type implementor can generate the new instructions by using a set of built-ins::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func isUnique&lt;BufferType&gt;(_ buffer: inout BufferType) -&gt; BufferType?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func endUnique&lt;BufferType&gt;(_ buffer: inout BufferType)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  struct COWType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    copy_on_write var b : COWBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func makeMutable() -&gt; COWBuffer {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      if let uniqueBuffer = isUnique(&amp;self.b) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;        return uniqueBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let copiedBuffer = copyBuffer(self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      self.b = copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      return copiedBuffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seems reasonable, but it also looks like the compiler could do the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `endUnique` dance for us based, e.g., on the mutability of methods.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree, that would be ideal, e.g. the compiler could insert the endUnique at the end of an inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in returns an optional unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Physically this is the COW buffer which is passed as the inout argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The result is nil if the buffer is not uniquely referenced.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In this case usually the original buffer is copied and the reference to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; copy is written back to the original buffer reference location<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (``self.b = copiedBuffer``).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Starting at the point of the write-back, the reference to the copy also becomes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ``isUnique`` built-in is lowered to the ``is_unique_addr_br`` pattern which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constructs the Optional in the successor blocks. Using ``isUnique`` in an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if-let (as shown above) will end up in two consecutive CFG &quot;diamonds&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Simplify-CFG can combine those into a single ``is_unique_addr_br`` diamond.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. note::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes the definition of the unique buffer location lifetime a little bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; problematic, because the false-branch of ``isUnique`` is not equivalent to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the false-branch of the ``is_unique_addr_br`` instruction (before SimplifyCFG<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can do its job).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what the implications of these diamonds and the problem<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; described above might be, FWIW.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The rules for using ``copy_on_write`` and the built-ins are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. ``isUnique`` must be paired with ``endUnique``, but not necessarily in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; same function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. The COW buffer may only be mutated by using the unique buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. The COW buffer must not be mutated outside the ``isUnique`` - ``endUnique``<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pair.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4. During the lifetime of the unique buffer reference, the original COW buffer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference must not be used in any way, e.g. for reading from the buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that the lifetime of the unique buffer reference does not include the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; part between the begin of the ``isUnique`` false-branch and the write-back<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the copy. This means is okay to read from the buffer (using ``self.b``)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the purpose of copying.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Examples::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    // violates rule 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    self.b.someData = x // violates rule 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = 27 // violates rule 3<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  mutating func incrementSomeData() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let uniqueBuffer = makeMutable()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    uniqueBuffer.someData = self.b.someData + 1 // violates rule 4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    endUnique(&amp;self.b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be instructive to write down the *correct* code for these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; added to my todo list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The intention of the rules is to ensure that there is no overlap of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;read-only&quot; life-range with a &quot;mutable&quot; life-range of the buffer reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s the responsibility of the implementor to follow the rules.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But the compiler (a mandatory diagnostics pass and the SIL verifier) can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statically detect rule violations in obvious cases (with inter-procedural<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; analysis maybe even in most cases).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This approach would require to change some of the internals of our<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; current COW data structures in the stdlib (Array, Dictionary, etc.).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, the Array make_mutable semantic functions currently do not return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the unique buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No big deal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Scoping Alternative 2: Implicit Inout Scopes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is an idea (proposal?) to change the representation of inout variables<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in SIL. This is independent of this proposal, but can be helpful for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; purpose of defining the scope of a COW mutation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The basic idea is that SILGen inserts scoping instructions for *all* inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; variables. And those scoping instructions can be used to define the mutating<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; scope of a COW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The scoping instructions which are inserted by SILGen for an inout scope are::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Simliar to ``is_unique_addr_br`` and ``end_unique_addr``, those instructions take the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; address of the inout variable as argument. For the optimizer those instructions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; look like potential writes to the inout variable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The implementor of a COW type has to follow the rule that the COW buffer may<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only be modified in mutating functions of the COW type. But this is the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anyway because any modification needs a uniqueness check and this can only be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; done in mutating functions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt; mutating func setSomeData(x: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Accepts a unique reference to the array value (avoiding refcount operations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  sil @setSomeData : $(Int, @inout Array) -&gt; () {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_entry(%x : Int, %arrayref : $*Array&lt;T&gt;) // Begin scope #0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;   makeMutable() (inlined)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Forward the unique reference to the `self` array value, still avoiding refcount operations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Begin the inlined exclusive scope (could be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %arrayref : $*Array&lt;T&gt; // Begin scope #1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;    if !isUnique(&amp;self._storage) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Extract a unique inout reference to the class reference to the array storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // This begins the isUnique() argument&#39;s exclusive scope. The memory is already exclusive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // but the scope helps ensure this is the only alias to _storage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storageref = struct_element_addr [exclusive] %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Uniqueness checking requires an inout reference to the class reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // The is_unique instruction does not need to create a new storage reference.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // It&#39;s only purpose is to check the RC count, ensure that the checked reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // is inout, and prevent the inout scope from being optimized away.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %isuniq = is_unique %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // End the isUnique argument&#39;s exclusive scope (can also be trivially removed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref._storageref : $*@sil_cow ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  br %isuniq, bb_continue, bb_slow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_slow:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;      self._storage = copyBuffer(self._storage)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Produce a new class reference to storage with verifiably unique RC semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %copied_storage_class = alloc_ref ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A begin/end exclusive scope is implicit in store [assign].<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store [assign] %copied_storage_class to %arrayref._storageref<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  br bb_continue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  bb_continue:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // This marks the end of makeMutable&#39;s inout `self` scope. Because Array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // contains a &quot;copy_on_write&quot; property, the SIL verifier needs to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // prove that %arrayref.#_storage has not escaped at this point. This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // is equivalent to checking that %arrayref itself is not copied, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // checking each projection of the &quot;copy_on_write&quot; storage property<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // (%arrayref._storageref) is not copied. Or, if any copies are present,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // they must be consumed within this scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // &gt;    self._storage.someData = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // An _addr instruction with one load/store use doesn&#39;t really need its own scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storageref = struct_element_addr %arrayref, #Array._storage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // ARC optimization can promote this to a borrow, replacing strong_release with end_borrow.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref.cow_storage = load [copy] %arrayref._storageref : $*@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %arrayref._storage = cow_to_ref %arrayref.cow_storage : $@sil_cow ArrayStorage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // Write some data into the CoW buffer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // (For simplicity, pretend ArrayStorage has a &quot;someData&quot; field).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A single-use _addr instruction, so no scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %somedata_addr = ref_element_addr %arrayref._storage, #someData<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // A store with an implicit [exclusive] scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  store [assign] %x to %somedata_addr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  strong_release %arrayref._storage : $*ArrayStorage&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // End the isUnique argument&#39;s exclusive scope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  // The same verification is needed here, but the inner scope would be eliminated.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  end_exclusive %arrayref : $*Array&lt;T&gt; // End scope #0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In general this approach looks more &quot;user-friendly&quot; than the first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Well, I can&#39;t really tell, because you haven&#39;t shown the Swift code that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generates this SIL.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But it depends on implementing the general feature to insert the inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; scoping instructions.  Also, we still have to think through all the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; details of this approach.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I am convinced we will need (and get) a stricter inout model that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would be conducive to inserting the scoping instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dependency between a buffer reference to the scope-begin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --------------------------------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; You can only have a dependency between two things, but as phrased “a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer reference to the scope-begin” sounds like one thing.  s/to/and/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would fix it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With both alternatives there is no explicit dependency from a buffer reference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a scope-begin instruction::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %x = load %b             // No dependency between this...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %baddr   // ... and this instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So in theory the optimizer is free to reschedule the instructions::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b_cow = load %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %b = cow_to_ref %b_cow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  begin_exclusive %baddr<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  %x = load %b             // Wrong! Buffer could be modified here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We still have to figure out how to cope with this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - We could add an end-of-lifetime instruction for a COW buffer reference, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the optimizer may not move over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Or we just define the implicit rule for the optimizer that any use of a COW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference may not be moved over a begin-of-scope instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Preconditions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =============<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To benefit from COW optimizations in the stdlib Array, Set and Dictionary data<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; structures we first need eager bridging, meaning getting rid of the bridged<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; buffer. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As you know I&#39;m very much in favor of eager bridging, but I don&#39;t see<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; why this would be dependent on it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could use copy_on_write with eager bridging, but I don’t think it will give any benefits to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimizer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example, the SIL code to get from an Array to a native<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ContiguousArrayStorage reference is pretty hard to understand for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimizer (involves low level bit operations, etc.).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It wouldn&#39;t need to do low-level bit operations if our enums were<br>&gt;&gt;&gt;&gt;&gt;&gt; capable/controllable enough.  I&#39;m just saying, there&#39;s no reason we<br>&gt;&gt;&gt;&gt;&gt;&gt; couldn&#39;t give the optimizer something to work with that has higher level<br>&gt;&gt;&gt;&gt;&gt;&gt; semantics than what we currently do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; At least for Array this is implemented as low-level bit operations and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optimizations cannot reason about it (e.g. finding a reasonable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; RC-root for the buffer reference).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another thing is that we currently cannot use ``copy_on_write`` for Array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; because of pinning. Array pins it’s buffer when passing an element address to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an inout parameter. This allows the array buffer to be modified even if its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference count is &gt; 1. With ``copy_on_write``, a programmer could break memory<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safety when violating the inout rule. Example::<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  var arr = [MyClass()]  // a global array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  foo(&amp;arr[0])        // Pins the buffer of arr during the call<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  func foo(_ x: inout MyClass) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let b = arr       // The ref-count of the buffer is not incremented, because it is pinned!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let r = b[0]      // optimizer removes the retain of r because it thinks the following code cannot modify b<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    arr.removeAll()   // does not copy the array buffer and thus de-allocates r<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    return r.i        // use-after-free!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I only know of one way to resolve inout and pinning:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Semantically, references are replaced with a trap value when entering<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an inout context so that all inout values are provably unique<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; references in the absence of unsafe code.  We drop pinning and provide<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; explicit operations that provide simultaneous lvalue accesses to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; distinct regions, e.g. c.swap(i1, i2) where i1 and i2 are indices.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If there are other ideas out there, I&#39;d like to hear them.  If not, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should probably decide that this is what we&#39;re doing so that we can move<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forward without this looming uncertainty.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/004a47f6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 8:41 AM, Erik Eckstein &lt;eeckstein at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; To clarify: I proposed an alternate approach in which the @sil_cow reference is only mutable during the Array’s @inout scope—to be automatically enforced by the compiler once @inout scopes are enforced. But the text in question is not referring to that approach, so your comments are on target.<br>&gt; <br>&gt; After thinking about Joe’s suggestion (having the cow attribute on the class type and make a reference to that type move-only), I’m more inclined to go with the isUnique builtin. If such a reference can only be returned by isUnique, it is really guaranteed that only a uniquely referenced buffer can be mutated. With the inout approach, the programmer is not forced to make the uniqueness check before modifying the buffer.<br></p><p><br>In my mind, relying on a move-only reference type is exactly what I was advocating for, but relies on a language feature rather than a “special” compiler verification. This all still needs to work with an ‘inout’ Array. The compiler will effectively be doing the same verification that I was proposing but as a side effect of move-only semantics (type system support makes it much easier). The isUnique builtin would just be a mechanism to get the mutable type, and the endUnique builtin is the mechanism to move the type back. As Dave pointed out, we could provide additional mechanisms for mutation that don’t depend on uniqueness. But the SIL optimizer doesn’t need to be explicitly taught about any of those builtin mechanisms for correctness. More importantly, the user is no longer responsible for some easy-to-violate, unverified property of the data type as a whole.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/d29f9f4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>copy-on-write proposal</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 10:11 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 20, 2016, at 8:41 AM, Erik Eckstein &lt;eeckstein at apple.com &lt;mailto:eeckstein at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; To clarify: I proposed an alternate approach in which the @sil_cow reference is only mutable during the Array’s @inout scope—to be automatically enforced by the compiler once @inout scopes are enforced. But the text in question is not referring to that approach, so your comments are on target.<br>&gt;&gt; <br>&gt;&gt; After thinking about Joe’s suggestion (having the cow attribute on the class type and make a reference to that type move-only), I’m more inclined to go with the isUnique builtin. If such a reference can only be returned by isUnique, it is really guaranteed that only a uniquely referenced buffer can be mutated. With the inout approach, the programmer is not forced to make the uniqueness check before modifying the buffer.<br>&gt; <br>&gt; <br>&gt; In my mind, relying on a move-only reference type is exactly what I was advocating for, but relies on a language feature rather than a “special” compiler verification.<br></p><p>Well, I think we are not blocked on this. We could just add a mandatory pass to check that there are no move-only violations. In the future a language feature might do this in a more elegant way in the type checker or whatever. But for now I believe we don’t need more than the attributes on the class type and the COW reference field.<br></p><p>&gt; This all still needs to work with an ‘inout’ Array. The compiler will effectively be doing the same verification that I was proposing but as a side effect of move-only semantics (type system support makes it much easier). The isUnique builtin would just be a mechanism to get the mutable type, and the endUnique builtin is the mechanism to move the type back. As Dave pointed out, we could provide additional mechanisms for mutation that don’t depend on uniqueness. But the SIL optimizer doesn’t need to be explicitly taught about any of those builtin mechanisms for correctness. More importantly, the user is no longer responsible for some easy-to-violate, unverified property of the data type as a whole.<br></p><p>I think we are more or less on the same page. All I’m saying is that the mutable reference can only be obtained by the isUnique/is_unique builtin/instruction (or by creating a new buffer).<br></p><p>&gt; <br>&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161020/30d54a59/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
