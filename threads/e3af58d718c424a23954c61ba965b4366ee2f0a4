<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 13, 2016 at 09:00:00pm</p></header><div class="content"><p>I think the idea is good, but I think it would be bad for the language overall.<br></p><p>-1<br></p><p>As a plus, it makes code easier to write, sometimes; or at least it seems so. On the other hand, I think it makes code harder to comprehend. A `with` statement introduces a new scope in which it is not obvious what exactly happens. For example:<br></p><p>with(someObject) {<br>    foo()<br>}<br></p><p>what does it do? The mere fact that I wrote `with(someObject)` suggests that `someObject.foo()` is what should happen. But it could also mean `self.foo()` or just the global function `foo()`.<br></p><p>Usually, you can see from the lexical surrounding of a call, what is happening. `foo()` means either `self.foo()`, or it means `foo()`. It&#39;s okay that I, as the class author know if my class has a `foo()` method or not. But do I have to know the API of someObject completely, including any future changes to its API?<br></p><p>For example: Suppose I have a class Foo, which has a method foo(). A remote co-worker wrote class Bar, which has a method bar(). Because I need bar a lot recently, I decided to use the with() form:<br></p><p>with(someBarObject) {<br>   ...<br>   foo()<br>   ...<br>   bar()<br>   ...<br>   bar()<br>   ...<br>   foo()<br>}<br></p><p>All is fine, it&#39;s clear that foo() calls my method and bar() calls that method on the someBarObject object. Then, suddenly, my co-worker had a great idea! He also implements foo() - it cannot break any existing code doing so, because existing code will not call foo(), because up until now class Bar did not implement foo(), after all...<br></p><p>Suddenly, my Foo class breaks, because my co-worker implemented foo() in his own class :-o<br></p><p>Such a thing really shouldn&#39;t happen. I am arguing that `with` is an inherently unsafe language feature! I also think it doesn&#39;t make the code actually easier to read. It may be an advantage if you have some reallyReallyLongAndFunnyVariableNames_withUnderscores_andSpecialTypeAnnotations, but even then I think it isn&#39;t worth it. I prefer easy-to-read over easy-to-write.<br></p><p>I like it when I can know what some code does, just by looking at it locally. These are syntactic guarantees that I can depend on. E.g. when I read something like<br></p><p>    x.bar()<br>    foo()<br></p><p>I know that there is an x variable somewhere (either in the current instance, or globally, or a local variable; a global variable is unlikely, because no one should dare to call a local variable just x.)<br>I know that the bar() method is called on that variable x, so x implements the bar() method. Either itself, or through an extension.<br>foo() is either a global method, or an instance method, or a static method.<br>All of these questions can be answered if I just know the class that I am currently implementing. If I know that my class didn&#39;t implement foo(), then foo() must be global. If x is a local var, an iVar or a static var, I can tell just by looking at the surrounding code. If it isn&#39;t =&gt; it must be global.<br>This (let me call it) &quot;lexical decidability&quot; is reduced by a `with`-operator, and this is the primary reason why I don&#39;t like it. For exactly this reason, I use a convention when writing Objective C code, that iVars should always be prefixed by an underscore, static and global vars always start with an uppercase letter, and all local vars and parameters start with a lowercase letter.<br></p><p>***<br></p><p>Even if we use .bar() instead of just bar() when calling from within a `with` block, I still don&#39;t like it. How many keystrokes are we sparing? If the variable has two letters, e.g. it&#39;s named `br`, we have `with(br){` (9 characters, 1 newline) and `}` (1 character, 1 newline) compared to 2 keystrokes for each time you may omit `br`. If you count the newlines as characters, you have to use the variable br 7 times in order for the `with` statement to pay off.<br></p><p>***<br></p><p>Using { $0.bar() } is interesting too. But why?? Just give the variable a short name, call it x0, for example, and you are saving even more keystrokes.<br></p><p>***<br></p><p>IMHO, saving sourecode-bits is not everything; readable code is everything. Therefore, a -1 from me.<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 14, 2016 at 12:00:00pm</p></header><div class="content"><p>Yes, I agree, that &quot;implicit&quot; &quot;with&quot;, where we can&#39;t say if method belongs <br>to the target instance or not, is very bad idea. I strongly agains it.<br></p><p>But the proposal is for &quot;explicit&quot; &quot;with&quot;, where it is clear what <br>method/property belongs to target instance, and which don&#39;t. So most of <br>your notes regarding problems with &quot;with&quot; are not related to &quot;external&quot; <br>with, but to &quot;internal&quot; &quot;with&quot;, that was not even introduced by the proposal.<br></p><p>As for your notes regarding implicit &quot;self.&quot; when you writing code inside <br>class. No, you not always know what exact methods is in class and what is <br>external functions: in case you are extending some class from some library <br>or inherit from such class. And I think we actually have this problem when <br>writing class code : I believe we need &quot;explicit&quot; marker that some <br>method/property belongs to our class. Personally I think &quot;self.&quot; should be <br>necessarily to use in our code.<br></p><p> &gt;Even if we use .bar() instead of just bar() when calling from within.....<br></p><p>It is not about saving the space in code. It is about more readable and (I <br>insist) more stable(with less errors) code.<br></p><p>Let&#39;s get your example with br. Let&#39;s say you have additionally bt <br>instance. Take into account code-completion feature of your editor. Take <br>into account copy-paste errors(when you copy code of br, wants to use for bt).<br></p><p>br = ..<br>br.one = ..<br>br.two = ...<br>br.three = ...<br>some1 = br.four()<br></p><p>bt = ..<br>bt.one = ..<br>bt.two = ...<br>br.three = ...<br>some2 = bt.four()<br></p><p>oops.. &quot;br.three = ...&quot; instead of &quot;bt.three&quot;<br></p><p>but let&#39;s compare :<br></p><p>with br {<br>   .one = ..<br>   .two = ...<br>   .three = ...<br>   some1 = .four()<br>}<br></p><p>with bt {<br>   .one = ..<br>   .two = ...<br>   .three = ...<br>   some2 = .four()<br>}<br></p><p>Much less possibilities for copy-paste errors. Wrong code completion <br>suggestion(by editor) can not produce error. It is explicit and clear, it <br>has much less noise in code. IMO it just better in any ways.<br></p><p><br> &gt; IMHO, saving sourecode-bits is not everything; readable code is<br> &gt; everything. Therefore, a -1 from me.<br></p><p>This proposal is not about saving bits. And it is about more readable code. <br>As I understand you are -1 for &quot;implicit&quot; &quot;where&quot;. I&#39;m too.<br></p><p>On 13.04.2016 22:48, Michael Peternell via swift-evolution wrote:<br>&gt; I think the idea is good, but I think it would be bad for the language overall.<br>&gt;<br>&gt; -1<br>&gt;<br>&gt; As a plus, it makes code easier to write, sometimes; or at least it seems so. On the other hand, I think it makes code harder to comprehend. A `with` statement introduces a new scope in which it is not obvious what exactly happens. For example:<br>&gt;<br>&gt; with(someObject) {<br>&gt;      foo()<br>&gt; }<br>&gt;<br>&gt; what does it do? The mere fact that I wrote `with(someObject)` suggests that `someObject.foo()` is what should happen. But it could also mean `self.foo()` or just the global function `foo()`.<br>&gt;<br>&gt; Usually, you can see from the lexical surrounding of a call, what is happening. `foo()` means either `self.foo()`, or it means `foo()`. It&#39;s okay that I, as the class author know if my class has a `foo()` method or not. But do I have to know the API of someObject completely, including any future changes to its API?<br>&gt;<br>&gt; For example: Suppose I have a class Foo, which has a method foo(). A remote co-worker wrote class Bar, which has a method bar(). Because I need bar a lot recently, I decided to use the with() form:<br>&gt;<br>&gt; with(someBarObject) {<br>&gt;     ...<br>&gt;     foo()<br>&gt;     ...<br>&gt;     bar()<br>&gt;     ...<br>&gt;     bar()<br>&gt;     ...<br>&gt;     foo()<br>&gt; }<br>&gt;<br>&gt; All is fine, it&#39;s clear that foo() calls my method and bar() calls that method on the someBarObject object. Then, suddenly, my co-worker had a great idea! He also implements foo() - it cannot break any existing code doing so, because existing code will not call foo(), because up until now class Bar did not implement foo(), after all...<br>&gt;<br>&gt; Suddenly, my Foo class breaks, because my co-worker implemented foo() in his own class :-o<br>&gt;<br>&gt; Such a thing really shouldn&#39;t happen. I am arguing that `with` is an inherently unsafe language feature! I also think it doesn&#39;t make the code actually easier to read. It may be an advantage if you have some reallyReallyLongAndFunnyVariableNames_withUnderscores_andSpecialTypeAnnotations, but even then I think it isn&#39;t worth it. I prefer easy-to-read over easy-to-write.<br>&gt;<br>&gt; I like it when I can know what some code does, just by looking at it locally. These are syntactic guarantees that I can depend on. E.g. when I read something like<br>&gt;<br>&gt;      x.bar()<br>&gt;      foo()<br>&gt;<br>&gt; I know that there is an x variable somewhere (either in the current instance, or globally, or a local variable; a global variable is unlikely, because no one should dare to call a local variable just x.)<br>&gt; I know that the bar() method is called on that variable x, so x implements the bar() method. Either itself, or through an extension.<br>&gt; foo() is either a global method, or an instance method, or a static method.<br>&gt; All of these questions can be answered if I just know the class that I am currently implementing. If I know that my class didn&#39;t implement foo(), then foo() must be global. If x is a local var, an iVar or a static var, I can tell just by looking at the surrounding code. If it isn&#39;t =&gt; it must be global.<br>&gt; This (let me call it) &quot;lexical decidability&quot; is reduced by a `with`-operator, and this is the primary reason why I don&#39;t like it. For exactly this reason, I use a convention when writing Objective C code, that iVars should always be prefixed by an underscore, static and global vars always start with an uppercase letter, and all local vars and parameters start with a lowercase letter.<br>&gt;<br>&gt; ***<br>&gt;<br>&gt; Even if we use .bar() instead of just bar() when calling from within a `with` block, I still don&#39;t like it. How many keystrokes are we sparing? If the variable has two letters, e.g. it&#39;s named `br`, we have `with(br){` (9 characters, 1 newline) and `}` (1 character, 1 newline) compared to 2 keystrokes for each time you may omit `br`. If you count the newlines as characters, you have to use the variable br 7 times in order for the `with` statement to pay off.<br>&gt;<br>&gt; ***<br>&gt;<br>&gt; Using { $0.bar() } is interesting too. But why?? Just give the variable a short name, call it x0, for example, and you are saving even more keystrokes.<br>&gt;<br>&gt; ***<br>&gt;<br>&gt; IMHO, saving sourecode-bits is not everything; readable code is everything. Therefore, a -1 from me.<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; As a plus, it makes code easier to write, sometimes; or at least it seems so. On the other hand, I think it makes code harder to comprehend. A `with` statement introduces a new scope in which it is not obvious what exactly happens. For example:<br>&gt; <br>&gt; with(someObject) {<br>&gt;    foo()<br>&gt; }<br>&gt; <br>&gt; what does it do? The mere fact that I wrote `with(someObject)` suggests that `someObject.foo()` is what should happen. But it could also mean `self.foo()` or just the global function `foo()`.<br></p><p>I support having two separate, but interlocking, features:<br></p><p>* A `with(_:user:)` function in the standard library which can access, and perhaps modify, a value.<br>* The ability to name a closure parameter `self`, which would make bare method calls be directed to that parameter.<br></p><p>So if your code said:<br></p><p>	with(someBarObject) { self in<br>	  ...<br>	  foo()<br>	  ...<br>	  bar()<br>	  ...<br>	  bar()<br>	  ...<br>	  foo()<br>	}<br></p><p>Then the foo() and bar() calls would definitely be either on someBarObject, or to global functions, whereas if you said:<br></p><p>	with(someBarObject) { value in<br>	  ...<br>	  foo()<br>	  ...<br>	  bar()<br>	  ...<br>	  bar()<br>	  ...<br>	  foo()<br>	}<br></p><p>Then they would definitely be on either the closed-over `self`, or to global functions.<br></p><p>(In no case, however, should it be possible that a call could refer to any of the three.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 14, 2016 at 05:00:00pm</p></header><div class="content"><p>On Apr 14, 2016, at 2:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; * The ability to name a closure parameter `self`, which would make bare method calls be directed to that parameter.<br></p><p>Could this would this tie into the weak-strong dance? And if so, how?<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>What about a VBA style with Statement?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 14, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; * The ability to name a closure parameter `self`, which would make bare method calls be directed to that parameter.<br>&gt; <br>&gt; Could this would this tie into the weak-strong dance? And if so, how?<br></p><p>Actually, one of my motivations for wanting `self` parameters is the block-based undo registration API:<br></p><p>	func add(_ amount: Int) {<br>		value += amount<br>		undoManager.registerUndo(target: self) { self in subtract(amount) }<br>	}<br></p><p>Since undo managers reference targets weakly, this API encapsulates the weak-strong dance for you. But without `self` parameters, you end up having to invent a different name:<br></p><p>	func add(_ amount: Int) {<br>		value += amount<br>		undoManager.registerUndo(target: self) { target in target.subtract(amount) }<br>	}<br></p><p>And if you forget and accidentally use `self`, the block references `self` strongly, which could create a retain cycle. So `self` parameters would make this pattern—which is really the best way to handle a weak-strong dance—safer and cleaner, encouraging its use.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
