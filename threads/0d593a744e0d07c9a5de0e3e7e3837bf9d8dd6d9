<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/da9f75a4fcb68abcaa6a123959754be4?s=50"></div><header><strong>Failable Initializer Suggestion</strong> from <string>Manfred Lau</string> &lt;wezzardlau at gmail.com&gt;<p>December 27, 2015 at 09:00:00pm</p></header><div class="content"><p>Hello.<br></p><p>I just found that the design of failable initializer is redundant in Swift 2. Because native error handling already has been introduced in Swift 2, and failable initializer indeed could be achieved by following codes:<br></p><p>	class AClass {<br>		init() throws {<br>			// initialize and throw error when failed<br>		}<br>	}<br></p><p>	let anInstance = try? AClass()<br></p><p>And you can get the reason why the initialization was failed to guide your following recovering by using codes below, which is not able to be done with failable initializer:<br></p><p>	do { <br>		let anInstance = try AClass()<br>	} catch let error {<br>		// recover from the error<br>	}<br></p><p>Probably the heaviest impact to current code done by removing failable initializer is the consequential changes of NSCoding protocol’s designated initializer.<br></p><p>As NSCoding protocol defines a designated initializer which unarchives the object graph from the archived data which could be invalid (by a wrong treating during a previous encoding), expired (by a software upgrade) or corrupted (by a disk error or user corrupting), the initialization might be failed respectively. But according the Objective-C’s design, such a failure is implicit and no error info would be thrown. So for NSCoding defined initializers implemented in Objective-C, it should add a default error to them when bridging them to Swift if the failable initializer was removed and the designated initializer in NSCoding was re-defined with an initializer throws error info.<br></p><p>How do you guys think of that?<br></p><p>Thanks for reading.<br></p><p>WeZZard<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/0d59d6d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Failable Initializer Suggestion</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 27, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; How do you guys think of that?<br>Makes sense.<br>Failable init has its roots in Objective-C, throws is a better fit for Swift — but it is not trivial to change all Cocoa class to throw instead of returning nil (at least in theory — most likely many classes don&#39;t have that many reasons for a possible error).<br>Imho failable init should be removed again (but in a timeframe beyond the normal range of this list ;-)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/70a55a79/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Failable Initializer Suggestion</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 27, 2015 at 09:00:00am</p></header><div class="content"><p>On Dec 27, 2015, at 5:22 AM, Manfred Lau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I just found that the design of failable initializer is redundant in Swift 2. Because native error handling already has been introduced in Swift 2, and failable initializer indeed could be achieved by following codes:<br></p><p>I’d be opposed to removing failable initializers.  Failable inits introduce a symmetry into the language for initializers, which make them possible to do (almost) all of what you can do with a normal method.  This capability is key for them to be able to replace “factory” static methods, which allows Swift to offer a consistent initialization pattern for clients of types.<br></p><p>If we forced people to use error handling for anything that could return nil, then things like String to Int conversions would most likely not use initialization syntax.<br></p><p>Besides that, over use of error handling waters it down and makes it less valuable in itself.  For more information on this, please see the design discussion for error handling:<br>https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/390e5c14/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Failable Initializer Suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 06:00:00am</p></header><div class="content"><p>+1 for keeping failable initializers. Error handling should be reserved for errors and not be used for control flow or logic.<br></p><p>-Thorsten <br></p><p>&gt; Am 27.12.2015 um 18:11 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 5:22 AM, Manfred Lau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I just found that the design of failable initializer is redundant in Swift 2. Because native error handling already has been introduced in Swift 2, and failable initializer indeed could be achieved by following codes:<br>&gt; <br>&gt; I’d be opposed to removing failable initializers.  Failable inits introduce a symmetry into the language for initializers, which make them possible to do (almost) all of what you can do with a normal method.  This capability is key for them to be able to replace “factory” static methods, which allows Swift to offer a consistent initialization pattern for clients of types.<br>&gt; <br>&gt; If we forced people to use error handling for anything that could return nil, then things like String to Int conversions would most likely not use initialization syntax.<br>&gt; <br>&gt; Besides that, over use of error handling waters it down and makes it less valuable in itself.  For more information on this, please see the design discussion for error handling:<br>&gt; https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/8868e02b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Failable Initializer Suggestion</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January  5, 2016 at 04:00:00pm</p></header><div class="content"><p>My initial stance several months ago was that initializers should throw<br>instead of returning nil, but I&#39;ve changed it as a result of the error<br>handling rationale (same document as Chris linked).<br></p><p>Specifically this section, taken from ErrorHandlingRationale.rst:<br></p><p>Simple domain errors<br></p><p>A simple domain error is something like calling String.toInt() on a string<br>that isn&#39;t an integer. The operation has an obvious precondition about its<br>arguments, but it&#39;s useful to be able to pass other values to test whether<br>they&#39;re okay. The client will often handle the error immediately.<br></p><p>Conditions like this are best modeled with an optional return value. They<br>don&#39;t benefit from a more complex error-handling model, and using one would<br>make common code unnecessarily awkward. For example, speculatively trying<br>to parse aString as an integer in Java requires catching an exception,<br>which is far more syntactically heavyweight (and inefficient without<br>optimization).<br></p><p>Because Swift already has good support for optionals, these conditions do<br>not need to be a focus of this proposal.<br></p><p>In constructors, the most common (and I would posit the only common) case<br>of error would be a simple domain error, so failable initializers suffice.<br></p><p>On Tue, Jan 5, 2016 at 12:52 AM Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for keeping failable initializers. Error handling should be reserved<br>&gt; for errors and not be used for control flow or logic.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 27.12.2015 um 18:11 schrieb Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; On Dec 27, 2015, at 5:22 AM, Manfred Lau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I just found that the design of failable initializer is redundant in Swift<br>&gt; 2. Because native error handling already has been introduced in Swift 2,<br>&gt; and failable initializer indeed could be achieved by following codes:<br>&gt;<br>&gt;<br>&gt; I’d be opposed to removing failable initializers.  Failable inits<br>&gt; introduce a symmetry into the language for initializers, which make them<br>&gt; possible to do (almost) all of what you can do with a normal method.  This<br>&gt; capability is key for them to be able to replace “factory” static methods,<br>&gt; which allows Swift to offer a consistent initialization pattern for clients<br>&gt; of types.<br>&gt;<br>&gt; If we forced people to use error handling for anything that could return<br>&gt; nil, then things like String to Int conversions would most likely not use<br>&gt; initialization syntax.<br>&gt;<br>&gt; Besides that, over use of error handling waters it down and makes it less<br>&gt; valuable in itself.  For more information on this, please see the design<br>&gt; discussion for error handling:<br>&gt; https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/64cc04d7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
