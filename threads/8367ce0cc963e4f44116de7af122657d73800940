<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>December 15, 2015 at 11:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I&#39;m a new member of the list, so apologies if this is a duplicate of an<br>existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve<br>missed.<br></p><p>In Objective C, and C-like languages, an initialiser function represents a<br>stage after allocation of memory where properties are given values. In<br>Swift, init appears to precede (or overlap with) allocation. The benefit of<br>this is that for type-safety reasons, all properties of a type (or new<br>properties of a derived type) can be verified as having values. The<br>disadvantage, and one of the stumbling blocks for those who learned<br>Objective-C, is that until all the properties have values, the instance<br>does not exist and instance functions cannot be called.<br></p><p>There&#39;s an invisible threshold in Swift init() functions marking this<br>transition. In derived classes it&#39;s the point where super.init() is called<br>- after the derived type has provided initial values, but before any type<br>functions can be called.<br></p><p>Some types have multiple initialisers, and may be duplicating a lot of code<br>in those distinct inits before they cross the threshold. This code can&#39;t be<br>refactored into an instance function because the instance doesn&#39;t exist<br>yet. The instance function may not even require the use of any properties<br>of the type.<br></p><p>If the compiler can read an init function and its varied control flow and<br>determine a threshold where all properties have values, presumably it can<br>read the code of any function called before that threshold, determine which<br>properties they read and which they assign to, and provide a warning if a<br>path assigns to a constant a second time, etc.. But this isn&#39;t currently<br>happening.<br></p><p>I&#39;m guessing there are multiple contributing factors for this: the<br>combinatorial explosion of possible control flow paths with functions<br>(particularly if they&#39;re recursive); the possibility that the function<br>calls are used by the compiler to mark the end of a control flow path, by<br>which point it can determine whether everything has a value; the function<br>genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d<br>be interested to learn them.<br></p><p>I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be called<br>before the threshold. It either only uses local properties or properties<br>belonging to the type - never to the &#39;super&#39; type (in the case of a derived<br>class). It can&#39;t call any instance functions which aren&#39;t themselves<br>selfless.<br></p><p>Example of use:<br>class FooView : UIView<br>{<br>    var property : Int<br></p><p>    init()<br>    {<br>        initialiseProperty()<br>        super.init()<br>    }<br></p><p>    init(frame:CGRect)<br>    {<br>        initialiseProperty()<br>        super.init(frame)<br>    }<br></p><p>    selfless func initialiseProperty()<br>    {<br>        property = 4<br>    }<br>}<br></p><p>Is this something of interest?<br></p><p>Regards,<br>Ross O&#39;Brien<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/83670940/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 5:59 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;m a new member of the list, so apologies if this is a duplicate of an existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve missed.<br>&gt; <br>&gt; In Objective C, and C-like languages, an initialiser function represents a stage after allocation of memory where properties are given values. In Swift, init appears to precede (or overlap with) allocation. The benefit of this is that for type-safety reasons, all properties of a type (or new properties of a derived type) can be verified as having values. The disadvantage, and one of the stumbling blocks for those who learned Objective-C, is that until all the properties have values, the instance does not exist and instance functions cannot be called.<br>&gt; <br>&gt; There&#39;s an invisible threshold in Swift init() functions marking this transition. In derived classes it&#39;s the point where super.init() is called - after the derived type has provided initial values, but before any type functions can be called.<br>&gt; <br>&gt; Some types have multiple initialisers, and may be duplicating a lot of code in those distinct inits before they cross the threshold. This code can&#39;t be refactored into an instance function because the instance doesn&#39;t exist yet. The instance function may not even require the use of any properties of the type.<br>&gt; <br>&gt; If the compiler can read an init function and its varied control flow and determine a threshold where all properties have values, presumably it can read the code of any function called before that threshold, determine which properties they read and which they assign to, and provide a warning if a path assigns to a constant a second time, etc.. But this isn&#39;t currently happening.<br>&gt; <br>&gt; I&#39;m guessing there are multiple contributing factors for this: the combinatorial explosion of possible control flow paths with functions (particularly if they&#39;re recursive); the possibility that the function calls are used by the compiler to mark the end of a control flow path, by which point it can determine whether everything has a value; the function genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d be interested to learn them.<br>&gt; <br>&gt; I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be called before the threshold. It either only uses local properties or properties belonging to the type - never to the &#39;super&#39; type (in the case of a derived class). It can&#39;t call any instance functions which aren&#39;t themselves selfless.<br>&gt; <br>&gt; Example of use:<br>&gt; class FooView : UIView<br>&gt; {<br>&gt;     var property : Int<br>&gt; <br>&gt;     init()<br>&gt;     {<br>&gt;         initialiseProperty()<br>&gt;         super.init()<br>&gt;     }<br>&gt; <br>&gt;     init(frame:CGRect)<br>&gt;     {<br>&gt;         initialiseProperty()<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; <br>&gt;     selfless func initialiseProperty()<br>&gt;     {<br>&gt;         property = 4<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Is this something of interest?<br>&gt; <br>&gt; Regards,<br>&gt; Ross O&#39;Brien<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>+1. This is something that I was planning to propose. It comes up particularly often in Cocoa objects that implement NSCoding, where you have to implement both init(coder:) and the designated initializer. Currently, if you have a bunch of complicated code involved in setting defaults for your properties, in a manner that’s too complex to solve with simple default values, you end up with a lot of copy-paste code in the two initializers, which can easily get out of sync if one is edited without being diligent about editing the other one in the same way. The exception, of course, if if you make init(coder:) a convenience initializer, but then subclasses cannot call super’s implementation of init(coder:), which makes this unworkable in a lot of circumstances.<br></p><p>I’m not sure “selfless” is the right keyword for this, but some sort of feature along these lines would be incredibly helpful.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/c1991c43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 02:00:00am</p></header><div class="content"><p>In its current state with the initial example -1 from me for the proposal.<br></p><p>The example could easily be written like this:<br></p><p>class FooView: UIView {<br></p><p>    var property = 4<br></p><p>    init() {<br>        super.init()<br>    }<br></p><p>    init(frame: CGRect) {<br>        super.init(frame)<br>    }<br>}<br></p><p><br>In cases where the initially value is computed in a complex way a closure<br>can be used:<br></p><p>class FooView: UIView {<br></p><p>    var property: Int = {<br>        // some complicated computation<br>        return value<br>    }()<br></p><p>    init() {<br>        super.init()<br>    }<br></p><p>    init(frame: CGRect) {<br>        super.init(frame)<br>    }<br>}<br></p><p>And that value could even delegate computation to static methods of the<br>class.<br></p><p>In cases where the computation is even more complex and refers to other<br>properties a lazy var can be used, which even allows the value to refer to<br>self:<br></p><p>class FooView: UIView {<br></p><p>    private(set) lazy var property: Int = {<br>        // some complicated computation which can use self<br>        return value<br>    }()<br></p><p>    init() {<br>        super.init()<br>    }<br></p><p>    init(frame: CGRect) {<br>        super.init(frame)<br>    }<br>}<br></p><p><br></p><p>On Wed, Dec 16, 2015 at 1:30 AM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 15, 2015, at 5:59 PM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I&#39;m a new member of the list, so apologies if this is a duplicate of an<br>&gt; existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve<br>&gt; missed.<br>&gt;<br>&gt; In Objective C, and C-like languages, an initialiser function represents a<br>&gt; stage after allocation of memory where properties are given values. In<br>&gt; Swift, init appears to precede (or overlap with) allocation. The benefit of<br>&gt; this is that for type-safety reasons, all properties of a type (or new<br>&gt; properties of a derived type) can be verified as having values. The<br>&gt; disadvantage, and one of the stumbling blocks for those who learned<br>&gt; Objective-C, is that until all the properties have values, the instance<br>&gt; does not exist and instance functions cannot be called.<br>&gt;<br>&gt; There&#39;s an invisible threshold in Swift init() functions marking this<br>&gt; transition. In derived classes it&#39;s the point where super.init() is called<br>&gt; - after the derived type has provided initial values, but before any type<br>&gt; functions can be called.<br>&gt;<br>&gt; Some types have multiple initialisers, and may be duplicating a lot of<br>&gt; code in those distinct inits before they cross the threshold. This code<br>&gt; can&#39;t be refactored into an instance function because the instance doesn&#39;t<br>&gt; exist yet. The instance function may not even require the use of any<br>&gt; properties of the type.<br>&gt;<br>&gt; If the compiler can read an init function and its varied control flow and<br>&gt; determine a threshold where all properties have values, presumably it can<br>&gt; read the code of any function called before that threshold, determine which<br>&gt; properties they read and which they assign to, and provide a warning if a<br>&gt; path assigns to a constant a second time, etc.. But this isn&#39;t currently<br>&gt; happening.<br>&gt;<br>&gt; I&#39;m guessing there are multiple contributing factors for this: the<br>&gt; combinatorial explosion of possible control flow paths with functions<br>&gt; (particularly if they&#39;re recursive); the possibility that the function<br>&gt; calls are used by the compiler to mark the end of a control flow path, by<br>&gt; which point it can determine whether everything has a value; the function<br>&gt; genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d<br>&gt; be interested to learn them.<br>&gt;<br>&gt; I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be called<br>&gt; before the threshold. It either only uses local properties or properties<br>&gt; belonging to the type - never to the &#39;super&#39; type (in the case of a derived<br>&gt; class). It can&#39;t call any instance functions which aren&#39;t themselves<br>&gt; selfless.<br>&gt;<br>&gt; Example of use:<br>&gt; class FooView : UIView<br>&gt; {<br>&gt;     var property : Int<br>&gt;<br>&gt;     init()<br>&gt;     {<br>&gt;         initialiseProperty()<br>&gt;         super.init()<br>&gt;     }<br>&gt;<br>&gt;     init(frame:CGRect)<br>&gt;     {<br>&gt;         initialiseProperty()<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt;<br>&gt;     selfless func initialiseProperty()<br>&gt;     {<br>&gt;         property = 4<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Is this something of interest?<br>&gt;<br>&gt; Regards,<br>&gt; Ross O&#39;Brien<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; +1. This is something that I was planning to propose. It comes up<br>&gt; particularly often in Cocoa objects that implement NSCoding, where you have<br>&gt; to implement both init(coder:) and the designated initializer. Currently,<br>&gt; if you have a bunch of complicated code involved in setting defaults for<br>&gt; your properties, in a manner that’s too complex to solve with simple<br>&gt; default values, you end up with a lot of copy-paste code in the two<br>&gt; initializers, which can easily get out of sync if one is edited without<br>&gt; being diligent about editing the other one in the same way. The exception,<br>&gt; of course, if if you make init(coder:) a convenience initializer, but then<br>&gt; subclasses cannot call super’s implementation of init(coder:), which makes<br>&gt; this unworkable in a lot of circumstances.<br>&gt;<br>&gt; I’m not sure “selfless” is the right keyword for this, but some sort of<br>&gt; feature along these lines would be incredibly helpful.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/4e7e5844/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fa2575f192bfdb93dd4cb043545a5df4?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium at gmail.com&gt;<p>December 16, 2015 at 01:00:00am</p></header><div class="content"><p>Lazy properties can&#39;t make use of parameters of the init() without storing<br>them, and can&#39;t calculate parameters to be used in a super.init() (or<br>decide which super.init() is called, if there are several to choose from).<br>Part of the idea of the selfless function is to keep local lets/vars at<br>local scope rather than type scope, and allow functions which perform<br>calculations in an initialisation to be reusable.<br>Static functions can perform these calculations but can&#39;t set instance<br>properties.<br>At the moment, for an init() to use initial parameters without storing<br>them, all the code for setting properties has to be in the init; I don&#39;t<br>think there&#39;s a way to break an init up into a sequence of smaller function<br>calls, each dealing with a lower level of abstraction of the init. i.e.<br>something like this:<br></p><p>init(&lt;initial arguments&gt;)<br>{<br>    initialiseColor(&lt;subset of arguments&gt;)<br>    initialiseSize(&lt;subset of arguments&gt;)<br>    initialiseFont(&lt;subset of arguments&gt;)<br>}<br></p><p><br>On Wed, Dec 16, 2015 at 1:06 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; In its current state with the initial example -1 from me for the proposal.<br>&gt;<br>&gt; The example could easily be written like this:<br>&gt;<br>&gt; class FooView: UIView {<br>&gt;<br>&gt;     var property = 4<br>&gt;<br>&gt;     init() {<br>&gt;         super.init()<br>&gt;     }<br>&gt;<br>&gt;     init(frame: CGRect) {<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; In cases where the initially value is computed in a complex way a closure<br>&gt; can be used:<br>&gt;<br>&gt; class FooView: UIView {<br>&gt;<br>&gt;     var property: Int = {<br>&gt;         // some complicated computation<br>&gt;         return value<br>&gt;     }()<br>&gt;<br>&gt;     init() {<br>&gt;         super.init()<br>&gt;     }<br>&gt;<br>&gt;     init(frame: CGRect) {<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; And that value could even delegate computation to static methods of the<br>&gt; class.<br>&gt;<br>&gt; In cases where the computation is even more complex and refers to other<br>&gt; properties a lazy var can be used, which even allows the value to refer<br>&gt; to self:<br>&gt;<br>&gt; class FooView: UIView {<br>&gt;<br>&gt;     private(set) lazy var property: Int = {<br>&gt;         // some complicated computation which can use self<br>&gt;         return value<br>&gt;     }()<br>&gt;<br>&gt;     init() {<br>&gt;         super.init()<br>&gt;     }<br>&gt;<br>&gt;     init(frame: CGRect) {<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 1:30 AM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Dec 15, 2015, at 5:59 PM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; I&#39;m a new member of the list, so apologies if this is a duplicate of an<br>&gt;&gt; existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve<br>&gt;&gt; missed.<br>&gt;&gt;<br>&gt;&gt; In Objective C, and C-like languages, an initialiser function represents<br>&gt;&gt; a stage after allocation of memory where properties are given values. In<br>&gt;&gt; Swift, init appears to precede (or overlap with) allocation. The benefit of<br>&gt;&gt; this is that for type-safety reasons, all properties of a type (or new<br>&gt;&gt; properties of a derived type) can be verified as having values. The<br>&gt;&gt; disadvantage, and one of the stumbling blocks for those who learned<br>&gt;&gt; Objective-C, is that until all the properties have values, the instance<br>&gt;&gt; does not exist and instance functions cannot be called.<br>&gt;&gt;<br>&gt;&gt; There&#39;s an invisible threshold in Swift init() functions marking this<br>&gt;&gt; transition. In derived classes it&#39;s the point where super.init() is called<br>&gt;&gt; - after the derived type has provided initial values, but before any type<br>&gt;&gt; functions can be called.<br>&gt;&gt;<br>&gt;&gt; Some types have multiple initialisers, and may be duplicating a lot of<br>&gt;&gt; code in those distinct inits before they cross the threshold. This code<br>&gt;&gt; can&#39;t be refactored into an instance function because the instance doesn&#39;t<br>&gt;&gt; exist yet. The instance function may not even require the use of any<br>&gt;&gt; properties of the type.<br>&gt;&gt;<br>&gt;&gt; If the compiler can read an init function and its varied control flow and<br>&gt;&gt; determine a threshold where all properties have values, presumably it can<br>&gt;&gt; read the code of any function called before that threshold, determine which<br>&gt;&gt; properties they read and which they assign to, and provide a warning if a<br>&gt;&gt; path assigns to a constant a second time, etc.. But this isn&#39;t currently<br>&gt;&gt; happening.<br>&gt;&gt;<br>&gt;&gt; I&#39;m guessing there are multiple contributing factors for this: the<br>&gt;&gt; combinatorial explosion of possible control flow paths with functions<br>&gt;&gt; (particularly if they&#39;re recursive); the possibility that the function<br>&gt;&gt; calls are used by the compiler to mark the end of a control flow path, by<br>&gt;&gt; which point it can determine whether everything has a value; the function<br>&gt;&gt; genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d<br>&gt;&gt; be interested to learn them.<br>&gt;&gt;<br>&gt;&gt; I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be called<br>&gt;&gt; before the threshold. It either only uses local properties or properties<br>&gt;&gt; belonging to the type - never to the &#39;super&#39; type (in the case of a derived<br>&gt;&gt; class). It can&#39;t call any instance functions which aren&#39;t themselves<br>&gt;&gt; selfless.<br>&gt;&gt;<br>&gt;&gt; Example of use:<br>&gt;&gt; class FooView : UIView<br>&gt;&gt; {<br>&gt;&gt;     var property : Int<br>&gt;&gt;<br>&gt;&gt;     init()<br>&gt;&gt;     {<br>&gt;&gt;         initialiseProperty()<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     init(frame:CGRect)<br>&gt;&gt;     {<br>&gt;&gt;         initialiseProperty()<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     selfless func initialiseProperty()<br>&gt;&gt;     {<br>&gt;&gt;         property = 4<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Is this something of interest?<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt; Ross O&#39;Brien<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; +1. This is something that I was planning to propose. It comes up<br>&gt;&gt; particularly often in Cocoa objects that implement NSCoding, where you have<br>&gt;&gt; to implement both init(coder:) and the designated initializer. Currently,<br>&gt;&gt; if you have a bunch of complicated code involved in setting defaults for<br>&gt;&gt; your properties, in a manner that’s too complex to solve with simple<br>&gt;&gt; default values, you end up with a lot of copy-paste code in the two<br>&gt;&gt; initializers, which can easily get out of sync if one is edited without<br>&gt;&gt; being diligent about editing the other one in the same way. The exception,<br>&gt;&gt; of course, if if you make init(coder:) a convenience initializer, but then<br>&gt;&gt; subclasses cannot call super’s implementation of init(coder:), which makes<br>&gt;&gt; this unworkable in a lot of circumstances.<br>&gt;&gt;<br>&gt;&gt; I’m not sure “selfless” is the right keyword for this, but some sort of<br>&gt;&gt; feature along these lines would be incredibly helpful.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/f993f982/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 16, 2015 at 08:00:00am</p></header><div class="content"><p>You can do<br></p><p><br>init(&lt;initial arguments&gt;)<br>{<br>    color = initialiseColor(&lt;subset of arguments&gt;)<br>    size = initialiseSize(&lt;subset of arguments&gt;)<br>    font = initialiseFont(&lt;subset of arguments&gt;)<br>}<br></p><p>On Wed, Dec 16, 2015 at 04:36 Ross O&#39;Brien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Lazy properties can&#39;t make use of parameters of the init() without storing<br>&gt; them, and can&#39;t calculate parameters to be used in a super.init() (or<br>&gt; decide which super.init() is called, if there are several to choose from).<br>&gt; Part of the idea of the selfless function is to keep local lets/vars at<br>&gt; local scope rather than type scope, and allow functions which perform<br>&gt; calculations in an initialisation to be reusable.<br>&gt; Static functions can perform these calculations but can&#39;t set instance<br>&gt; properties.<br>&gt; At the moment, for an init() to use initial parameters without storing<br>&gt; them, all the code for setting properties has to be in the init; I don&#39;t<br>&gt; think there&#39;s a way to break an init up into a sequence of smaller function<br>&gt; calls, each dealing with a lower level of abstraction of the init. i.e.<br>&gt; something like this:<br>&gt;<br>&gt; init(&lt;initial arguments&gt;)<br>&gt; {<br>&gt;     initialiseColor(&lt;subset of arguments&gt;)<br>&gt;     initialiseSize(&lt;subset of arguments&gt;)<br>&gt;     initialiseFont(&lt;subset of arguments&gt;)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 1:06 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; In its current state with the initial example -1 from me for the proposal.<br>&gt;&gt;<br>&gt;&gt; The example could easily be written like this:<br>&gt;&gt;<br>&gt;&gt; class FooView: UIView {<br>&gt;&gt;<br>&gt;&gt;     var property = 4<br>&gt;&gt;<br>&gt;&gt;     init() {<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; In cases where the initially value is computed in a complex way a closure<br>&gt;&gt; can be used:<br>&gt;&gt;<br>&gt;&gt; class FooView: UIView {<br>&gt;&gt;<br>&gt;&gt;     var property: Int = {<br>&gt;&gt;         // some complicated computation<br>&gt;&gt;         return value<br>&gt;&gt;     }()<br>&gt;&gt;<br>&gt;&gt;     init() {<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; And that value could even delegate computation to static methods of the<br>&gt;&gt; class.<br>&gt;&gt;<br>&gt;&gt; In cases where the computation is even more complex and refers to other<br>&gt;&gt; properties a lazy var can be used, which even allows the value to refer<br>&gt;&gt; to self:<br>&gt;&gt;<br>&gt;&gt; class FooView: UIView {<br>&gt;&gt;<br>&gt;&gt;     private(set) lazy var property: Int = {<br>&gt;&gt;         // some complicated computation which can use self<br>&gt;&gt;         return value<br>&gt;&gt;     }()<br>&gt;&gt;<br>&gt;&gt;     init() {<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 1:30 AM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 15, 2015, at 5:59 PM, Ross O&#39;Brien via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m a new member of the list, so apologies if this is a duplicate of an<br>&gt;&gt;&gt; existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve<br>&gt;&gt;&gt; missed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In Objective C, and C-like languages, an initialiser function represents<br>&gt;&gt;&gt; a stage after allocation of memory where properties are given values. In<br>&gt;&gt;&gt; Swift, init appears to precede (or overlap with) allocation. The benefit of<br>&gt;&gt;&gt; this is that for type-safety reasons, all properties of a type (or new<br>&gt;&gt;&gt; properties of a derived type) can be verified as having values. The<br>&gt;&gt;&gt; disadvantage, and one of the stumbling blocks for those who learned<br>&gt;&gt;&gt; Objective-C, is that until all the properties have values, the instance<br>&gt;&gt;&gt; does not exist and instance functions cannot be called.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There&#39;s an invisible threshold in Swift init() functions marking this<br>&gt;&gt;&gt; transition. In derived classes it&#39;s the point where super.init() is called<br>&gt;&gt;&gt; - after the derived type has provided initial values, but before any type<br>&gt;&gt;&gt; functions can be called.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Some types have multiple initialisers, and may be duplicating a lot of<br>&gt;&gt;&gt; code in those distinct inits before they cross the threshold. This code<br>&gt;&gt;&gt; can&#39;t be refactored into an instance function because the instance doesn&#39;t<br>&gt;&gt;&gt; exist yet. The instance function may not even require the use of any<br>&gt;&gt;&gt; properties of the type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the compiler can read an init function and its varied control flow<br>&gt;&gt;&gt; and determine a threshold where all properties have values, presumably it<br>&gt;&gt;&gt; can read the code of any function called before that threshold, determine<br>&gt;&gt;&gt; which properties they read and which they assign to, and provide a warning<br>&gt;&gt;&gt; if a path assigns to a constant a second time, etc.. But this isn&#39;t<br>&gt;&gt;&gt; currently happening.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m guessing there are multiple contributing factors for this: the<br>&gt;&gt;&gt; combinatorial explosion of possible control flow paths with functions<br>&gt;&gt;&gt; (particularly if they&#39;re recursive); the possibility that the function<br>&gt;&gt;&gt; calls are used by the compiler to mark the end of a control flow path, by<br>&gt;&gt;&gt; which point it can determine whether everything has a value; the function<br>&gt;&gt;&gt; genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d<br>&gt;&gt;&gt; be interested to learn them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be<br>&gt;&gt;&gt; called before the threshold. It either only uses local properties or<br>&gt;&gt;&gt; properties belonging to the type - never to the &#39;super&#39; type (in the case<br>&gt;&gt;&gt; of a derived class). It can&#39;t call any instance functions which aren&#39;t<br>&gt;&gt;&gt; themselves selfless.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Example of use:<br>&gt;&gt;&gt; class FooView : UIView<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     var property : Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     init()<br>&gt;&gt;&gt;     {<br>&gt;&gt;&gt;         initialiseProperty()<br>&gt;&gt;&gt;         super.init()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     init(frame:CGRect)<br>&gt;&gt;&gt;     {<br>&gt;&gt;&gt;         initialiseProperty()<br>&gt;&gt;&gt;         super.init(frame)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     selfless func initialiseProperty()<br>&gt;&gt;&gt;     {<br>&gt;&gt;&gt;         property = 4<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is this something of interest?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; Ross O&#39;Brien<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1. This is something that I was planning to propose. It comes up<br>&gt;&gt;&gt; particularly often in Cocoa objects that implement NSCoding, where you have<br>&gt;&gt;&gt; to implement both init(coder:) and the designated initializer. Currently,<br>&gt;&gt;&gt; if you have a bunch of complicated code involved in setting defaults for<br>&gt;&gt;&gt; your properties, in a manner that’s too complex to solve with simple<br>&gt;&gt;&gt; default values, you end up with a lot of copy-paste code in the two<br>&gt;&gt;&gt; initializers, which can easily get out of sync if one is edited without<br>&gt;&gt;&gt; being diligent about editing the other one in the same way. The exception,<br>&gt;&gt;&gt; of course, if if you make init(coder:) a convenience initializer, but then<br>&gt;&gt;&gt; subclasses cannot call super’s implementation of init(coder:), which makes<br>&gt;&gt;&gt; this unworkable in a lot of circumstances.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m not sure “selfless” is the right keyword for this, but some sort of<br>&gt;&gt;&gt; feature along these lines would be incredibly helpful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/f9204647/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 15, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 7:06 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; In its current state with the initial example -1 from me for the proposal.<br>&gt; <br>&gt; The example could easily be written like this:<br>&gt; <br>&gt; class FooView: UIView {<br>&gt; <br>&gt;     var property = 4<br>&gt; <br>&gt;     init() {<br>&gt;         super.init()<br>&gt;     }<br>&gt; <br>&gt;     init(frame: CGRect) {<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; In cases where the initially value is computed in a complex way a closure can be used:<br>&gt; <br>&gt; class FooView: UIView {<br>&gt; <br>&gt;     var property: Int = {<br>&gt;         // some complicated computation<br>&gt;         return value<br>&gt;     }()<br>&gt; <br>&gt;     init() {<br>&gt;         super.init()<br>&gt;     }<br>&gt; <br>&gt;     init(frame: CGRect) {<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; }<br></p><p>That works for simplistic cases such as this. However, if you have a large number of properties that all need to be set, and if their values are all interconnected in some way, dependent on some of the initializer’s parameters, or dependent on some value computed at runtime, this pattern cannot accomplish the task cleanly.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/404daadc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 02:00:00am</p></header><div class="content"><p>Although I understand your concerns (Charles and Ross) I think an extensive<br>example is still necessary to properly discuss this proposal. We&#39;d have to<br>figure out what exactly causes the limitation, if there are alternatives<br>and if there is no alternative which would render the change unnecessary.<br>So far this is a very theoretical discussion.<br></p><p><br>On Wed, Dec 16, 2015 at 2:48 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Dec 15, 2015, at 7:06 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;<br>&gt; In its current state with the initial example -1 from me for the proposal.<br>&gt;<br>&gt; The example could easily be written like this:<br>&gt;<br>&gt; class FooView: UIView {<br>&gt;<br>&gt;     var property = 4<br>&gt;<br>&gt;     init() {<br>&gt;         super.init()<br>&gt;     }<br>&gt;<br>&gt;     init(frame: CGRect) {<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; In cases where the initially value is computed in a complex way a closure<br>&gt; can be used:<br>&gt;<br>&gt; class FooView: UIView {<br>&gt;<br>&gt;     var property: Int = {<br>&gt;         // some complicated computation<br>&gt;         return value<br>&gt;     }()<br>&gt;<br>&gt;     init() {<br>&gt;         super.init()<br>&gt;     }<br>&gt;<br>&gt;     init(frame: CGRect) {<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; That works for simplistic cases such as this. However, if you have a large<br>&gt; number of properties that all need to be set, and if their values are all<br>&gt; interconnected in some way, dependent on some of the initializer’s<br>&gt; parameters, or dependent on some value computed at runtime, this pattern<br>&gt; cannot accomplish the task cleanly.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/8f26d509/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>In UIKIt a view can have two primary methods of initialization: initWithCoder and initWithFrame. initWithCoder is special in that it will not call up to initWithFrame, while any other initializer will use initWthFrame as it’s base initializer.<br></p><p>A common issue is that you might want to set defaults based on runtime information, so you define a common “setup” function that each one of the initializers calls. Again, I haven’t run into this case yet in Swift, but my understanding is that this would not work because the initializers would not be able to call a function on themselves until initialization was complete.<br></p><p>There is one possible way out. NIB outlets are declared implicitly unwrapped to work around this exact problem. A NIB can’t be loaded until after the object’s initialization is complete, and therefore the outlet properties of the object can’t be populated at init time. Any properties that need to have common setup between the two initializers could be declared as implicitly unwrapped. You’d lose some safety, but any issues could probably be quickly caught. This would work around the problem of needing to populate all the properties of the object before calling to the super’s init.<br></p><p>&gt; On Dec 15, 2015, at 5:51 PM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Although I understand your concerns (Charles and Ross) I think an extensive example is still necessary to properly discuss this proposal. We&#39;d have to figure out what exactly causes the limitation, if there are alternatives and if there is no alternative which would render the change unnecessary.<br>&gt; So far this is a very theoretical discussion.<br>&gt; <br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 2:48 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Dec 15, 2015, at 7:06 PM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In its current state with the initial example -1 from me for the proposal.<br>&gt;&gt; <br>&gt;&gt; The example could easily be written like this:<br>&gt;&gt; <br>&gt;&gt; class FooView: UIView {<br>&gt;&gt; <br>&gt;&gt;     var property = 4<br>&gt;&gt; <br>&gt;&gt;     init() {<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In cases where the initially value is computed in a complex way a closure can be used:<br>&gt;&gt; <br>&gt;&gt; class FooView: UIView {<br>&gt;&gt; <br>&gt;&gt;     var property: Int = {<br>&gt;&gt;         // some complicated computation<br>&gt;&gt;         return value<br>&gt;&gt;     }()<br>&gt;&gt; <br>&gt;&gt;     init() {<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; That works for simplistic cases such as this. However, if you have a large number of properties that all need to be set, and if their values are all interconnected in some way, dependent on some of the initializer’s parameters, or dependent on some value computed at runtime, this pattern cannot accomplish the task cleanly.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/c716bbee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 03:00:00am</p></header><div class="content"><p>initWithCoder(_:) is exactly such an example you can solve using<br>initialization closures and/or lazy vars I mentioned earlier.<br></p><p>The only limitation would be that properties must be initialized<br>independently from each other.<br>If they really depend on each other then using a struct for them probably<br>makes sense since that can be initialized as a whole.<br></p><p>On Wed, Dec 16, 2015 at 3:00 AM, Colin Cornaby &lt;colin.cornaby at mac.com&gt;<br>wrote:<br></p><p>&gt; In UIKIt a view can have two primary methods of initialization:<br>&gt; initWithCoder and initWithFrame. initWithCoder is special in that it will<br>&gt; not call up to initWithFrame, while any other initializer will use<br>&gt; initWthFrame as it’s base initializer.<br>&gt;<br>&gt; A common issue is that you might want to set defaults based on runtime<br>&gt; information, so you define a common “setup” function that each one of the<br>&gt; initializers calls. Again, I haven’t run into this case yet in Swift, but<br>&gt; my understanding is that this would not work because the initializers would<br>&gt; not be able to call a function on themselves until initialization was<br>&gt; complete.<br>&gt;<br>&gt; There is one possible way out. NIB outlets are declared implicitly<br>&gt; unwrapped to work around this exact problem. A NIB can’t be loaded until<br>&gt; after the object’s initialization is complete, and therefore the outlet<br>&gt; properties of the object can’t be populated at init time. Any properties<br>&gt; that need to have common setup between the two initializers could be<br>&gt; declared as implicitly unwrapped. You’d lose some safety, but any issues<br>&gt; could probably be quickly caught. This would work around the problem of<br>&gt; needing to populate all the properties of the object before calling to the<br>&gt; super’s init.<br>&gt;<br>&gt; On Dec 15, 2015, at 5:51 PM, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Although I understand your concerns (Charles and Ross) I think an<br>&gt; extensive example is still necessary to properly discuss this proposal.<br>&gt; We&#39;d have to figure out what exactly causes the limitation, if there are<br>&gt; alternatives and if there is no alternative which would render the change<br>&gt; unnecessary.<br>&gt; So far this is a very theoretical discussion.<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 2:48 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;&gt; On Dec 15, 2015, at 7:06 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; In its current state with the initial example -1 from me for the proposal.<br>&gt;&gt;<br>&gt;&gt; The example could easily be written like this:<br>&gt;&gt;<br>&gt;&gt; class FooView: UIView {<br>&gt;&gt;<br>&gt;&gt;     var property = 4<br>&gt;&gt;<br>&gt;&gt;     init() {<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; In cases where the initially value is computed in a complex way a closure<br>&gt;&gt; can be used:<br>&gt;&gt;<br>&gt;&gt; class FooView: UIView {<br>&gt;&gt;<br>&gt;&gt;     var property: Int = {<br>&gt;&gt;         // some complicated computation<br>&gt;&gt;         return value<br>&gt;&gt;     }()<br>&gt;&gt;<br>&gt;&gt;     init() {<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That works for simplistic cases such as this. However, if you have a<br>&gt;&gt; large number of properties that all need to be set, and if their values are<br>&gt;&gt; all interconnected in some way, dependent on some of the initializer’s<br>&gt;&gt; parameters, or dependent on some value computed at runtime, this pattern<br>&gt;&gt; cannot accomplish the task cleanly.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2c5e4321/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 03:00:00am</p></header><div class="content"><p>Well lazy vars actually can refer to each other during their initialization.<br>Just make sure you don&#39;t create any cycles or else you&#39;ll end up in an<br>endless recursion.<br></p><p>On Wed, Dec 16, 2015 at 3:06 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; initWithCoder(_:) is exactly such an example you can solve using<br>&gt; initialization closures and/or lazy vars I mentioned earlier.<br>&gt;<br>&gt; The only limitation would be that properties must be initialized<br>&gt; independently from each other.<br>&gt; If they really depend on each other then using a struct for them probably<br>&gt; makes sense since that can be initialized as a whole.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 3:00 AM, Colin Cornaby &lt;colin.cornaby at mac.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; In UIKIt a view can have two primary methods of initialization:<br>&gt;&gt; initWithCoder and initWithFrame. initWithCoder is special in that it will<br>&gt;&gt; not call up to initWithFrame, while any other initializer will use<br>&gt;&gt; initWthFrame as it’s base initializer.<br>&gt;&gt;<br>&gt;&gt; A common issue is that you might want to set defaults based on runtime<br>&gt;&gt; information, so you define a common “setup” function that each one of the<br>&gt;&gt; initializers calls. Again, I haven’t run into this case yet in Swift, but<br>&gt;&gt; my understanding is that this would not work because the initializers would<br>&gt;&gt; not be able to call a function on themselves until initialization was<br>&gt;&gt; complete.<br>&gt;&gt;<br>&gt;&gt; There is one possible way out. NIB outlets are declared implicitly<br>&gt;&gt; unwrapped to work around this exact problem. A NIB can’t be loaded until<br>&gt;&gt; after the object’s initialization is complete, and therefore the outlet<br>&gt;&gt; properties of the object can’t be populated at init time. Any properties<br>&gt;&gt; that need to have common setup between the two initializers could be<br>&gt;&gt; declared as implicitly unwrapped. You’d lose some safety, but any issues<br>&gt;&gt; could probably be quickly caught. This would work around the problem of<br>&gt;&gt; needing to populate all the properties of the object before calling to the<br>&gt;&gt; super’s init.<br>&gt;&gt;<br>&gt;&gt; On Dec 15, 2015, at 5:51 PM, Marc Knaup via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Although I understand your concerns (Charles and Ross) I think an<br>&gt;&gt; extensive example is still necessary to properly discuss this proposal.<br>&gt;&gt; We&#39;d have to figure out what exactly causes the limitation, if there are<br>&gt;&gt; alternatives and if there is no alternative which would render the change<br>&gt;&gt; unnecessary.<br>&gt;&gt; So far this is a very theoretical discussion.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 2:48 AM, Charles Srstka &lt;cocoadev at charlessoft.com<br>&gt;&gt; &gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 15, 2015, at 7:06 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In its current state with the initial example -1 from me for the<br>&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The example could easily be written like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class FooView: UIView {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var property = 4<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     init() {<br>&gt;&gt;&gt;         super.init()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;&gt;         super.init(frame)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In cases where the initially value is computed in a complex way a<br>&gt;&gt;&gt; closure can be used:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class FooView: UIView {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var property: Int = {<br>&gt;&gt;&gt;         // some complicated computation<br>&gt;&gt;&gt;         return value<br>&gt;&gt;&gt;     }()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     init() {<br>&gt;&gt;&gt;         super.init()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;&gt;         super.init(frame)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That works for simplistic cases such as this. However, if you have a<br>&gt;&gt;&gt; large number of properties that all need to be set, and if their values are<br>&gt;&gt;&gt; all interconnected in some way, dependent on some of the initializer’s<br>&gt;&gt;&gt; parameters, or dependent on some value computed at runtime, this pattern<br>&gt;&gt;&gt; cannot accomplish the task cleanly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/41de56bf/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>Yeah, thinking this one through… The use case below also mentioned the possibility of a setup function that had parameters to base it’s setup on. A lazy loading variable doesn’t necessarily cleanly replace that sort of usage without adding more variables to hold the parameters for lazy initialization… But I’m not sure if that’s realistic. Anything that’s part of an initWithCoder serialization /deserialization pattern is probably going to be a variable on the object anyway. Maybe someone else can come up with a better counterexample.<br></p><p>At least this list is a great way to touch on all the different corners of Swift. :)<br></p><p>&gt; On Dec 15, 2015, at 6:14 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; Well lazy vars actually can refer to each other during their initialization.<br>&gt; Just make sure you don&#39;t create any cycles or else you&#39;ll end up in an endless recursion.<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 3:06 AM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt; initWithCoder(_:) is exactly such an example you can solve using initialization closures and/or lazy vars I mentioned earlier.<br>&gt; <br>&gt; The only limitation would be that properties must be initialized independently from each other.<br>&gt; If they really depend on each other then using a struct for them probably makes sense since that can be initialized as a whole.<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 3:00 AM, Colin Cornaby &lt;colin.cornaby at mac.com &lt;mailto:colin.cornaby at mac.com&gt;&gt; wrote:<br>&gt; In UIKIt a view can have two primary methods of initialization: initWithCoder and initWithFrame. initWithCoder is special in that it will not call up to initWithFrame, while any other initializer will use initWthFrame as it’s base initializer.<br>&gt; <br>&gt; A common issue is that you might want to set defaults based on runtime information, so you define a common “setup” function that each one of the initializers calls. Again, I haven’t run into this case yet in Swift, but my understanding is that this would not work because the initializers would not be able to call a function on themselves until initialization was complete.<br>&gt; <br>&gt; There is one possible way out. NIB outlets are declared implicitly unwrapped to work around this exact problem. A NIB can’t be loaded until after the object’s initialization is complete, and therefore the outlet properties of the object can’t be populated at init time. Any properties that need to have common setup between the two initializers could be declared as implicitly unwrapped. You’d lose some safety, but any issues could probably be quickly caught. This would work around the problem of needing to populate all the properties of the object before calling to the super’s init.<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 5:51 PM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Although I understand your concerns (Charles and Ross) I think an extensive example is still necessary to properly discuss this proposal. We&#39;d have to figure out what exactly causes the limitation, if there are alternatives and if there is no alternative which would render the change unnecessary.<br>&gt;&gt; So far this is a very theoretical discussion.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 2:48 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Dec 15, 2015, at 7:06 PM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In its current state with the initial example -1 from me for the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The example could easily be written like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class FooView: UIView {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var property = 4<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init() {<br>&gt;&gt;&gt;         super.init()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;&gt;         super.init(frame)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In cases where the initially value is computed in a complex way a closure can be used:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class FooView: UIView {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var property: Int = {<br>&gt;&gt;&gt;         // some complicated computation<br>&gt;&gt;&gt;         return value<br>&gt;&gt;&gt;     }()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init() {<br>&gt;&gt;&gt;         super.init()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(frame: CGRect) {<br>&gt;&gt;&gt;         super.init(frame)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That works for simplistic cases such as this. However, if you have a large number of properties that all need to be set, and if their values are all interconnected in some way, dependent on some of the initializer’s parameters, or dependent on some value computed at runtime, this pattern cannot accomplish the task cleanly.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/ce196ea7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>Proposal: &#39;selfless&#39; keyword for refactoring duplicate code from initialisers</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>+1 on not being sure selfless is the right keyword, but liking the direction of this proposal. I haven’t hit this issue yet in my Swift projects, but I see this pattern all the time in Obj-C.<br></p><p>I’m trying to play devils advocate with myself and figure out if there is a way around without adding a new concept to the language… Not coming up with much so far.<br></p><p>&gt; On Dec 15, 2015, at 4:30 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 5:59 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I&#39;m a new member of the list, so apologies if this is a duplicate of an existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve missed.<br>&gt;&gt; <br>&gt;&gt; In Objective C, and C-like languages, an initialiser function represents a stage after allocation of memory where properties are given values. In Swift, init appears to precede (or overlap with) allocation. The benefit of this is that for type-safety reasons, all properties of a type (or new properties of a derived type) can be verified as having values. The disadvantage, and one of the stumbling blocks for those who learned Objective-C, is that until all the properties have values, the instance does not exist and instance functions cannot be called.<br>&gt;&gt; <br>&gt;&gt; There&#39;s an invisible threshold in Swift init() functions marking this transition. In derived classes it&#39;s the point where super.init() is called - after the derived type has provided initial values, but before any type functions can be called.<br>&gt;&gt; <br>&gt;&gt; Some types have multiple initialisers, and may be duplicating a lot of code in those distinct inits before they cross the threshold. This code can&#39;t be refactored into an instance function because the instance doesn&#39;t exist yet. The instance function may not even require the use of any properties of the type.<br>&gt;&gt; <br>&gt;&gt; If the compiler can read an init function and its varied control flow and determine a threshold where all properties have values, presumably it can read the code of any function called before that threshold, determine which properties they read and which they assign to, and provide a warning if a path assigns to a constant a second time, etc.. But this isn&#39;t currently happening.<br>&gt;&gt; <br>&gt;&gt; I&#39;m guessing there are multiple contributing factors for this: the combinatorial explosion of possible control flow paths with functions (particularly if they&#39;re recursive); the possibility that the function calls are used by the compiler to mark the end of a control flow path, by which point it can determine whether everything has a value; the function genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d be interested to learn them.<br>&gt;&gt; <br>&gt;&gt; I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be called before the threshold. It either only uses local properties or properties belonging to the type - never to the &#39;super&#39; type (in the case of a derived class). It can&#39;t call any instance functions which aren&#39;t themselves selfless.<br>&gt;&gt; <br>&gt;&gt; Example of use:<br>&gt;&gt; class FooView : UIView<br>&gt;&gt; {<br>&gt;&gt;     var property : Int<br>&gt;&gt; <br>&gt;&gt;     init()<br>&gt;&gt;     {<br>&gt;&gt;         initialiseProperty()<br>&gt;&gt;         super.init()<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     init(frame:CGRect)<br>&gt;&gt;     {<br>&gt;&gt;         initialiseProperty()<br>&gt;&gt;         super.init(frame)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     selfless func initialiseProperty()<br>&gt;&gt;     {<br>&gt;&gt;         property = 4<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is this something of interest?<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; Ross O&#39;Brien<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; +1. This is something that I was planning to propose. It comes up particularly often in Cocoa objects that implement NSCoding, where you have to implement both init(coder:) and the designated initializer. Currently, if you have a bunch of complicated code involved in setting defaults for your properties, in a manner that’s too complex to solve with simple default values, you end up with a lot of copy-paste code in the two initializers, which can easily get out of sync if one is edited without being diligent about editing the other one in the same way. The exception, of course, if if you make init(coder:) a convenience initializer, but then subclasses cannot call super’s implementation of init(coder:), which makes this unworkable in a lot of circumstances.<br>&gt; <br>&gt; I’m not sure “selfless” is the right keyword for this, but some sort of feature along these lines would be incredibly helpful.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/c173a46c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>&quot;selfless&quot;, init Helpers, and NSDocument</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  9, 2016 at 07:00:00pm</p></header><div class="content"><p>Okay, resurrecting this proposal (which some may not have seen due to it having been sent over the holiday break), because I thought of a really major use case.<br></p><p>In addition to the obvious use cases, like init methods that get too long because they can’t be broken up into smaller methods, duplicated code between init() and init(coder:), and the like, I just realized that this feature, if implemented with an appropriate annotation to make it bridgeable from Objective-C headers, could make NSDocument not suck in Swift.<br></p><p>Currently we have this situation:<br></p><p>class MyDoc: NSDocument {<br>	var foo: Foo!<br>	var bar: Bar!<br></p><p>	override func readFromData(data: NSData, ofType: String) throws {<br>		self.foo = // parse something from the data<br>		self.bar = // parse something from the data<br></p><p>		// etc.<br>	}<br>}<br></p><p>There are a number of problems with this.<br></p><p>1. Since there’s no way to know what any of the document’s state is supposed to be at the time the class is initialized, pretty much everything has to be optional. And in practice, these are going to be of the implicitly-unwrapped variety much of the time, since many of these variables have no real reason to be optional once readFromData() has been called, and no one is going to want to needlessly unwrap these things Every. Damn. Time.<br></p><p>2. Unlike code in init methods, the code above will call the setters for foo and bar, *not* just set the underlying ivars directly. This means that willSets and didSets, as well as things like KVO notifications, will get fired. If the document has a decent number of properties, it is easy for properties that haven’t been initialized yet to be inadvertently called as a result of the side-effects of setting properties in readFromData(), leading to a crash.<br></p><p>3. Redesigning NSDocument to work better with Swift is an option, except that as the language currently stands, this would be hard to do and make it work similarly to how it currently does. Particularly, the current system provides several override points. If you just need the file contents, you override readFromData(). However, if you need to access file metadata or something beyond just the contents, you can override readFromURL() instead. The default implementation of readFromURL(), of course, calls readFromData(), so you can choose which override point is more appropriate and use that. The obvious solution to this would be to turn the readFrom*() methods into initializers, but for init(URL:) to call init(data:) in its default implementation, it would need to be declared as a convenience initializer—which can’t be overridden.<br></p><p>If we had a way to declare methods as init helpers, a way to annotate these in Objective-C, and an annotation to put on the designated initializer indicating which init helpers the initializer will call, this might be able to be all separated out. I’m not sure whether NSDocument could be made to conform to this as is, but a hypothetical redesigned document class could look something like this:<br></p><p>class NSHypotheticalDocument: NSObject {<br>	@uses_helper(readFromURL:ofType:) init(URL url: NSURL, ofType type: String) throws {<br>		try self.readFromURL(url, ofType: type)<br>		super.init()<br>	}<br></p><p>	@uses_helper(readFromData:ofType:) init_helper readFromURL(url: NSURL, ofType type: String) throws {<br>		let data = try NSData(contentsOfURL: url, options: [])<br>		try self.readFromData(data, ofType: type)<br>	}<br></p><p>	init_helper readFromData(data: NSData, ofType type: String) throws {<br>		throw NSCocoaError.FeatureUnsupportedError<br>	}<br></p><p>	// other stuff<br>}<br></p><p>A subclass could now override one of the two helper methods, and since the designated initializer is documented as calling these particular helpers, the compiler could know that any properties set in an overridden helper method would be set by the end of the super.init call in the subclass’s own initializer, and thus these properties would be set without side effects. This could allow properties in document classes to be safely set without unnecessary use of optionals.<br></p><p>I dunno, what do you think?<br></p><p>Charles<br></p><p>&gt; On Dec 15, 2015, at 5:59 PM, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;m a new member of the list, so apologies if this is a duplicate of an existing idea or if there&#39;s already a way to do this in Swift 2.1 that I&#39;ve missed.<br>&gt; <br>&gt; In Objective C, and C-like languages, an initialiser function represents a stage after allocation of memory where properties are given values. In Swift, init appears to precede (or overlap with) allocation. The benefit of this is that for type-safety reasons, all properties of a type (or new properties of a derived type) can be verified as having values. The disadvantage, and one of the stumbling blocks for those who learned Objective-C, is that until all the properties have values, the instance does not exist and instance functions cannot be called.<br>&gt; <br>&gt; There&#39;s an invisible threshold in Swift init() functions marking this transition. In derived classes it&#39;s the point where super.init() is called - after the derived type has provided initial values, but before any type functions can be called.<br>&gt; <br>&gt; Some types have multiple initialisers, and may be duplicating a lot of code in those distinct inits before they cross the threshold. This code can&#39;t be refactored into an instance function because the instance doesn&#39;t exist yet. The instance function may not even require the use of any properties of the type.<br>&gt; <br>&gt; If the compiler can read an init function and its varied control flow and determine a threshold where all properties have values, presumably it can read the code of any function called before that threshold, determine which properties they read and which they assign to, and provide a warning if a path assigns to a constant a second time, etc.. But this isn&#39;t currently happening.<br>&gt; <br>&gt; I&#39;m guessing there are multiple contributing factors for this: the combinatorial explosion of possible control flow paths with functions (particularly if they&#39;re recursive); the possibility that the function calls are used by the compiler to mark the end of a control flow path, by which point it can determine whether everything has a value; the function genuinely can&#39;t exist without allocation. I don&#39;t know the reasons but I&#39;d be interested to learn them.<br>&gt; <br>&gt; I&#39;m proposing the keyword &#39;selfless&#39; for a function which could be called before the threshold. It either only uses local properties or properties belonging to the type - never to the &#39;super&#39; type (in the case of a derived class). It can&#39;t call any instance functions which aren&#39;t themselves selfless.<br>&gt; <br>&gt; Example of use:<br>&gt; class FooView : UIView<br>&gt; {<br>&gt;     var property : Int<br>&gt; <br>&gt;     init()<br>&gt;     {<br>&gt;         initialiseProperty()<br>&gt;         super.init()<br>&gt;     }<br>&gt; <br>&gt;     init(frame:CGRect)<br>&gt;     {<br>&gt;         initialiseProperty()<br>&gt;         super.init(frame)<br>&gt;     }<br>&gt; <br>&gt;     selfless func initialiseProperty()<br>&gt;     {<br>&gt;         property = 4<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Is this something of interest?<br>&gt; <br>&gt; Regards,<br>&gt; Ross O&#39;Brien<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/61082208/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
