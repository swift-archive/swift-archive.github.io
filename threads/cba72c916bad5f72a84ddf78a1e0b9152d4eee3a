<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 12, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I&#39;d like to continue the discussion of the issue raised by David Waite<br>inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:<br></p><p>&gt; My main motivation for proposing this is the potential for developer confusion. As stated during one of the previous threads on the naming of map, flatMap, filter, etc. methods on Sequence, Sequence has a naming requirement not typical of the rest of the Swift standard library in that many methods on Sequence may or may not be destructive. As such, naming methods for any extensions on Sequence is challenging as the names need to not imply immutability.<br></p><p>I&#39;d like to focus on a particular point: methods on Sequence can<br>consume elements, but the APIs are not markedmutating.<br></p><p>Dave Abrahams, Max Moiseev, and I have discussed this issue and we<br>agree this problem is severe and worth solving, we also think that the<br>likely solutions would be source-breaking, so it is important that we<br>discuss it now.<br></p><p>We have discussed a few options.<br></p><p>- Rejected option: remove Sequence, let IteratorProtocol model<br>single-pass data streams<br></p><p>- Rejected option: use a syntactic marker, like sequence.consumedIn.map {}<br></p><p>- Rejected option: mutating APIs on Sequence, non-mutating APIs on Collection<br></p><p>Proposed: rename Sequence to IterableOnce or TraversableOnce. We think<br>that Sequence does not convey the single-pass restriction clearly. The<br>term &quot;sequence&quot; has been used in math (as in &quot;integer sequence&quot;), and<br>since the math domain does not have mutation, &quot;sequence&quot; can be<br>understood to mean &quot;multi-pass&quot;, since you can traverse a sequence of<br>integers an arbitrary number of times.<br></p><p>We think that only the last option is viable in the Swift language as<br>it exists now, without creating an undue burden for API vendors and<br>users.<br></p><p>For more details about rejection options, please see the full writeup:<br>https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 12, 2016 at 07:00:00pm</p></header><div class="content"><p>This more limited approach makes sense in light of the documented<br>reasoning. However, as a renaming proposal, I feel like I should raise some<br>points about the proposed name.<br></p><p>First, a naive interpretation of IterableOnce may cause a user to think<br>that a for...in loop over an IterableOnce is guaranteed to execute at least<br>once. It is not that a sequence is &quot;iterable once.&quot; It could be iterable<br>exactly zero times. Rather, after however many iterations, the iterating<br>cannot take place from the beginning again.<br></p><p>Second, the dictionary definition of &quot;once&quot; lists an ambiguity, where (at<br>least in one source) the first meaning is &quot;one time only.&quot; (See: &lt;<br>https://www.google.com/#q=define:once&gt;.) This could lead to<br>misinterpretations of the relationship where Collection is IterableOnce.<br></p><p>I would propose that perhaps Iterable is sufficient to convey the meaning.<br>There is no a priori user expectation, I think, that something iterable<br>remains unchanged on traversal.<br></p><p><br>On Tue, Jul 12, 2016 at 5:55 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I&#39;d like to continue the discussion of the issue raised by David Waite<br>&gt; inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:<br>&gt;<br>&gt; &gt; My main motivation for proposing this is the potential for developer<br>&gt; confusion. As stated during one of the previous threads on the naming of<br>&gt; map, flatMap, filter, etc. methods on Sequence, Sequence has a naming<br>&gt; requirement not typical of the rest of the Swift standard library in that<br>&gt; many methods on Sequence may or may not be destructive. As such, naming<br>&gt; methods for any extensions on Sequence is challenging as the names need to<br>&gt; not imply immutability.<br>&gt;<br>&gt; I&#39;d like to focus on a particular point: methods on Sequence can<br>&gt; consume elements, but the APIs are not markedmutating.<br>&gt;<br>&gt; Dave Abrahams, Max Moiseev, and I have discussed this issue and we<br>&gt; agree this problem is severe and worth solving, we also think that the<br>&gt; likely solutions would be source-breaking, so it is important that we<br>&gt; discuss it now.<br>&gt;<br>&gt; We have discussed a few options.<br>&gt;<br>&gt; - Rejected option: remove Sequence, let IteratorProtocol model<br>&gt; single-pass data streams<br>&gt;<br>&gt; - Rejected option: use a syntactic marker, like sequence.consumedIn.map {}<br>&gt;<br>&gt; - Rejected option: mutating APIs on Sequence, non-mutating APIs on<br>&gt; Collection<br>&gt;<br>&gt; Proposed: rename Sequence to IterableOnce or TraversableOnce. We think<br>&gt; that Sequence does not convey the single-pass restriction clearly. The<br>&gt; term &quot;sequence&quot; has been used in math (as in &quot;integer sequence&quot;), and<br>&gt; since the math domain does not have mutation, &quot;sequence&quot; can be<br>&gt; understood to mean &quot;multi-pass&quot;, since you can traverse a sequence of<br>&gt; integers an arbitrary number of times.<br>&gt;<br>&gt; We think that only the last option is viable in the Swift language as<br>&gt; it exists now, without creating an undue burden for API vendors and<br>&gt; users.<br>&gt;<br>&gt; For more details about rejection options, please see the full writeup:<br>&gt; https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/1e478876/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July 12, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 12, 2016, at 4:55 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I&#39;d like to continue the discussion of the issue raised by David Waite<br>&gt; inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:<br>&gt; <br>&gt; - Rejected option: remove Sequence, let IteratorProtocol model<br>&gt; single-pass data streams<br></p><p>I was looking into implementing this as well (although a bit slowly, was on vacation and entertaining house guests). I don’t know if it is worth taking this to a proposal now with this conclusion stated, but I will give my evaluation below:<br></p><p>I took a slightly different approach in prototyping - I made IteratorProtocol require reference types, and made iterator methods lazy by default. I also made AnyIterator a base class for the Iterator objects returned by the default implementations in the IteratorProtocol extensions.<br></p><p>With underestimatedCount and dropFirst as distinct counterexamples, most of the methods did not make sense to include as potential overrides on the protocol. As examples, map() and filter() do not give opportunities for a subclass to optimize a default behavior.<br></p><p>It still made sense for Collection to have a makeIterator, and to act like such an iterator consumed a copy of the collection. As such, an algorithm written for an Iterator could be applied to Collections relatively simply.<br></p><p>Since Iterators were lazy, the duplication wasn’t so much with Collection as with LazyCollection. Methods which took an Iterator or a Collection just called makeIterator on the collection. I felt some of the algorithmic and method duplication was offset by the removal of Sequence and LazySequence, and the ability to internalize the types returned as results from the extension methods.<br></p><p>The last remark I’ll add was that I looked at splitting out certain methods into a FiniteIteratorProtocol; methods like dropLast, suffix, count, etc. I experimented with the API for IteratorProtocol using this in places as well, such as starts(with:) taking a finite iterator as its argument. <br></p><p>This seemed to definitely lead to an explosion of API complexity, and I decided that it was probably not worth differentiating the two in the class system, and that in fact it might be worth holding off on the finite-targetted methods until it is obvious they are needed, since adding a FiniteIteratorProtocol subclass could be considered additive.<br></p><p>-DW<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 13, 2016 at 06:00:00pm</p></header><div class="content"><p>I also thought on the problem, and I agree with your solution. It keeps<br>things simple.<br>I agree with this specific name -- IterableOnce (not IterableAtLeastOnce).<br>IterableOnce contains Iterable -- and that plays very nicely with<br>IteratorProtocol name.<br>IterableOnce is not a single word, but it&#39;s not too long, compared to some<br>other options.<br>Functions working with IterableOnce will always imply single-pass, and with<br>Collections -- multi-pass. It might seem odd that Collection conforms to<br>IterableOnce, but I consider that a minor drawback.<br></p><p>2016-07-13 1:55 GMT+03:00 Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I&#39;d like to continue the discussion of the issue raised by David Waite<br>&gt; inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:<br>&gt;<br>&gt; &gt; My main motivation for proposing this is the potential for developer<br>&gt; confusion. As stated during one of the previous threads on the naming of<br>&gt; map, flatMap, filter, etc. methods on Sequence, Sequence has a naming<br>&gt; requirement not typical of the rest of the Swift standard library in that<br>&gt; many methods on Sequence may or may not be destructive. As such, naming<br>&gt; methods for any extensions on Sequence is challenging as the names need to<br>&gt; not imply immutability.<br>&gt;<br>&gt; I&#39;d like to focus on a particular point: methods on Sequence can<br>&gt; consume elements, but the APIs are not markedmutating.<br>&gt;<br>&gt; Dave Abrahams, Max Moiseev, and I have discussed this issue and we<br>&gt; agree this problem is severe and worth solving, we also think that the<br>&gt; likely solutions would be source-breaking, so it is important that we<br>&gt; discuss it now.<br>&gt;<br>&gt; We have discussed a few options.<br>&gt;<br>&gt; - Rejected option: remove Sequence, let IteratorProtocol model<br>&gt; single-pass data streams<br>&gt;<br>&gt; - Rejected option: use a syntactic marker, like sequence.consumedIn.map {}<br>&gt;<br>&gt; - Rejected option: mutating APIs on Sequence, non-mutating APIs on<br>&gt; Collection<br>&gt;<br>&gt; Proposed: rename Sequence to IterableOnce or TraversableOnce. We think<br>&gt; that Sequence does not convey the single-pass restriction clearly. The<br>&gt; term &quot;sequence&quot; has been used in math (as in &quot;integer sequence&quot;), and<br>&gt; since the math domain does not have mutation, &quot;sequence&quot; can be<br>&gt; understood to mean &quot;multi-pass&quot;, since you can traverse a sequence of<br>&gt; integers an arbitrary number of times.<br>&gt;<br>&gt; We think that only the last option is viable in the Swift language as<br>&gt; it exists now, without creating an undue burden for API vendors and<br>&gt; users.<br>&gt;<br>&gt; For more details about rejection options, please see the full writeup:<br>&gt; https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/7c02f86a/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
