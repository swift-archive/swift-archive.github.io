<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 19, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue May 10 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;ve needed these in the past and used them in other languages—any feedback on this  idea?<br>&gt;<br>&gt; ---------------------------------------------------------------------------------------------------------------------<br>&gt;<br>&gt; Add last(where:) and lastIndex(where:) Methods to Bidirectional Collections<br>&gt;<br>&gt; The standard library should include methods for finding the last element of a bidirectional collection that matches a<br>&gt; predicate, along with the index of that element.<br></p><p>Why shouldn&#39;t this work with all Collections, with an optimized version<br>for BidirectionalCollections?<br></p><p>&gt; Motivation<br>&gt;<br>&gt; The standard library currently has (or will soon have) methods that perform a linear search from the beginning of a<br>&gt; collection to find an element that matches a predicate:<br>&gt;<br>&gt; let a = [20, 30, 10, 40, 20, 30, 10, 40, 20]<br>&gt; a.first(where: { $0 &gt; 25 })         // 30<br>&gt; a.index(of: 10)                     // 2<br>&gt; a.index(where: { $0 &gt; 25 })         // 1<br></p><p>&gt; Unfortunately, there is no such method that searches from the end of a bidirectional collection. Finding the last of<br>&gt; particular kind of element has multiple applications, particularly with text, such as wrapping a long string into<br>&gt; lines of a maximum length or trimming whitespace from the beginning and end of a string.<br>&gt;<br>&gt; This limitation can be worked around by using the methods above on the reversed collection, but the resulting code is<br>&gt; truly dreadful. For example, to find the corresponding last index to a.index(where: { $0 &gt; 25 }), this unholy<br>&gt; incantation is required:<br>&gt;<br>&gt; (a.reversed().index(where: { $0 &gt; 25 })?.base).flatMap({ a.index(before: $0) })<br>&gt;<br>&gt; Wat.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; Bidirectional collections should include three new methods for symmetry with the existing forward-searching<br>&gt; APIs: last(where:), lastIndex(where:), and lastIndex(of:), specifically for collections of Equatable elements.<br>&gt;<br>&gt; These additions would remove the need for searching in a reversed collection and allow code like the following:<br>&gt;<br>&gt; a.last(where: { $0 &gt; 25 })          // 40<br>&gt; a.lastIndex(of: 10)                 // 6<br>&gt; a.lastIndex(where: { $0 &gt; 25 })     // 7<br></p><p>I think we need to consider consistency of naming more carefully in this<br>area.  If we go this route, I want:<br></p><p>  x.firstIndex(of: 10)<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Why shouldn&#39;t this work with all Collections, with an optimized version<br>&gt; for BidirectionalCollections?<br></p><p><br>Why don&#39;t we have `index(before:)` on non-BidirectionalCollections? It&#39;s not that you can&#39;t write it:<br></p><p>	func index(before index: Index) -&gt; Index {<br>		let offset = distance(from: startIndex, to: index)<br>		return index(startIndex, offsetBy: offset - 1)<br>	}<br></p><p>We don&#39;t do that because it would be so slow as to form an attractive nuisance. Similarly, we shouldn&#39;t provide operations which are going to repeatedly seek elements near the tail of the list unless we&#39;re using a type which can access that tail efficiently. `last` is one thing—it&#39;s only O(N). `lastIndex(of:)` is, I believe, O(n log n) in the case of an element that doesn&#39;t exist.<br></p><p>&gt; I think we need to consider consistency of naming more carefully in this<br>&gt; area.  If we go this route, I want:<br>&gt; <br>&gt;  x.firstIndex(of: 10)<br></p><p>I think that&#39;s actually great, because it will separate the user-facing `index(of:)` and `index(where:)` from the stdlib-facing `index(after:)`, `index(before:)`, `index(_:offsetBy:)`, etc.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 20, 2016 at 08:00:00am</p></header><div class="content"><p>on Thu May 19 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; Why shouldn&#39;t this work with all Collections, with an optimized version<br>&gt;&gt; for BidirectionalCollections?<br>&gt;<br>&gt; Why don&#39;t we have `index(before:)` on non-BidirectionalCollections? It&#39;s not that you can&#39;t write it:<br>&gt;<br>&gt; 	func index(before index: Index) -&gt; Index {<br>&gt; 		let offset = distance(from: startIndex, to: index)<br>&gt; 		return index(startIndex, offsetBy: offset - 1)<br>&gt; 	}<br>&gt;<br>&gt; We don&#39;t do that because it would be so slow as to form an attractive<br>&gt; nuisance. <br></p><p>It&#39;s O(N) worst case no matter what you do.<br></p><p>&gt; Similarly, we shouldn&#39;t provide operations which are going to<br>&gt; repeatedly seek elements near the tail of the list unless we&#39;re using<br>&gt; a type which can access that tail efficiently. `last` is one<br>&gt; thing—it&#39;s only O(N). `lastIndex(of:)` is, I believe, O(n log n) in<br>&gt; the case of an element that doesn&#39;t exist.<br></p><p>I can&#39;t imagine where your O(N log N) comes from in this case, but even<br>if it is the right complexity that wouldn&#39;t be a reason not to provide<br>the operation.  I learned last week there&#39;s an O(N log N) in-place<br>reverse() for ForwardCollections, and I think we ought to have it.  log<br>N is effectively a constant for most purposes.<br></p><p>&gt;&gt; I think we need to consider consistency of naming more carefully in this<br>&gt;&gt; area.  If we go this route, I want:<br>&gt;&gt; <br>&gt;&gt;  x.firstIndex(of: 10)<br>&gt;<br>&gt; I think that&#39;s actually great, because it will separate the<br>&gt; user-facing `index(of:)` and `index(where:)` from the stdlib-facing<br>&gt; `index(after:)`, `index(before:)`, `index(_:offsetBy:)`, etc.<br></p><p>Yes.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/67a361b77f5c6cba256d06ba641f2af8?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Nate Cook</string> &lt;nate at natecook.com&gt;<p>May 21, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:34 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu May 19 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Why shouldn&#39;t this work with all Collections, with an optimized version<br>&gt;&gt;&gt; for BidirectionalCollections?<br></p><p>This sounds fine to me. I think I got hung up on &#39;last&#39; only being available on BidirectionalCollections, but since that&#39;s a property it needs to provide O(1) access and is therefore not a good reference point. (I think &#39;removeLast&#39; might be the only method that starts with BidirectionalCollections.)<br></p><p>&gt;&gt; Why don&#39;t we have `index(before:)` on non-BidirectionalCollections? It&#39;s not that you can&#39;t write it:<br>&gt;&gt; <br>&gt;&gt;    func index(before index: Index) -&gt; Index {<br>&gt;&gt;        let offset = distance(from: startIndex, to: index)<br>&gt;&gt;        return index(startIndex, offsetBy: offset - 1)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; We don&#39;t do that because it would be so slow as to form an attractive<br>&gt;&gt; nuisance.<br>&gt; <br>&gt; It&#39;s O(N) worst case no matter what you do.<br>&gt; <br>&gt;&gt; Similarly, we shouldn&#39;t provide operations which are going to<br>&gt;&gt; repeatedly seek elements near the tail of the list unless we&#39;re using<br>&gt;&gt; a type which can access that tail efficiently. `last` is one<br>&gt;&gt; thing—it&#39;s only O(N). `lastIndex(of:)` is, I believe, O(n log n) in<br>&gt;&gt; the case of an element that doesn&#39;t exist.<br>&gt; <br>&gt; I can&#39;t imagine where your O(N log N) comes from in this case, but even<br>&gt; if it is the right complexity that wouldn&#39;t be a reason not to provide<br>&gt; the operation.  I learned last week there&#39;s an O(N log N) in-place<br>&gt; reverse() for ForwardCollections, and I think we ought to have it.  log<br>&gt; N is effectively a constant for most purposes.<br></p><p>That sounds interesting! The &#39;rotate&#39; proposal, which includes in-place reversal methods, has technically not completed review. Should we amend that to make in-place reversal available for any MutableCollection?<br></p><p>&gt;&gt;&gt; I think we need to consider consistency of naming more carefully in this<br>&gt;&gt;&gt; area.  If we go this route, I want:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x.firstIndex(of: 10)<br>&gt;&gt; <br>&gt;&gt; I think that&#39;s actually great, because it will separate the<br>&gt;&gt; user-facing `index(of:)` and `index(where:)` from the stdlib-facing<br>&gt;&gt; `index(after:)`, `index(before:)`, `index(_:offsetBy:)`, etc.<br>&gt; <br>&gt; Yes.<br></p><p>I&#39;m sold on this too. I&#39;ve updated the proposal for this that&#39;s in the PR queue:<br>https://github.com/natecook1000/swift-evolution/blob/nc-last-methods/proposals/0000-add-last-methods.md<br></p><p>Nate<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; Similarly, we shouldn&#39;t provide operations which are going to<br>&gt;&gt; repeatedly seek elements near the tail of the list unless we&#39;re using<br>&gt;&gt; a type which can access that tail efficiently. `last` is one<br>&gt;&gt; thing—it&#39;s only O(N). `lastIndex(of:)` is, I believe, O(n log n) in<br>&gt;&gt; the case of an element that doesn&#39;t exist.<br>&gt; <br>&gt; I can&#39;t imagine where your O(N log N) comes from in this case, but even<br>&gt; if it is the right complexity that wouldn&#39;t be a reason not to provide<br>&gt; the operation.<br></p><p>I&#39;m imagining an implementation something like this:<br></p><p>	func lastIndex(of value: Element) -&gt; Index? {<br>		let count = self.count<br>		<br>		for endOffset in 0..&lt;count {<br>			let offset = count - endOffset - 1<br>			let i = index(startIndex, offsetBy: offset)<br>			<br>			if self[i] == value {<br>				return i<br>			}<br>		}<br>		<br>		return nil<br>	}<br></p><p>`index(_:offsetBy:)` is O(N) for a ForwardCollection, and `offset` gets smaller as you execute the loop, so I *believe* this ends up being O(N log N). I was never that good at big-O notation, though, so I could be wrong about that. What I can say is that it would be O(N^2) if not for the decreasing size of `offset`, so it&#39;s smaller than that.<br></p><p>&gt; I learned last week there&#39;s an O(N log N) in-place<br>&gt; reverse() for ForwardCollections, and I think we ought to have it.  log<br>&gt; N is effectively a constant for most purposes.<br></p><p>If you guys think it&#39;s okay, I&#39;m not going to argue.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 21, 2016 at 02:00:00pm</p></header><div class="content"><p>on Sat May 21 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt;&gt; Similarly, we shouldn&#39;t provide operations which are going to<br>&gt;&gt;&gt; repeatedly seek elements near the tail of the list unless we&#39;re using<br>&gt;&gt;&gt; a type which can access that tail efficiently. `last` is one<br>&gt;&gt;&gt; thing—it&#39;s only O(N). `lastIndex(of:)` is, I believe, O(n log n) in<br>&gt;&gt;&gt; the case of an element that doesn&#39;t exist.<br>&gt;&gt; <br>&gt;&gt; I can&#39;t imagine where your O(N log N) comes from in this case, but even<br>&gt;&gt; if it is the right complexity that wouldn&#39;t be a reason not to provide<br>&gt;&gt; the operation.<br>&gt;<br>&gt; I&#39;m imagining an implementation something like this:<br>&gt;<br>&gt; 	func lastIndex(of value: Element) -&gt; Index? {<br>&gt; 		let count = self.count<br>&gt;<br>&gt; 		for endOffset in 0..&lt;count {<br>&gt; 			let offset = count - endOffset - 1<br>&gt; 			let i = index(startIndex, offsetBy: offset)<br>&gt;<br>&gt; 			if self[i] == value {<br>&gt; 				return i<br>&gt; 			}<br>&gt; 		}<br>&gt;<br>&gt; 		return nil<br>&gt; 	}<br></p><p><br>Oh, no!<br></p><p>    extension Collection {<br>      func lastIndex(where predicate: (Element)-&gt;Bool) -&gt; Index? {<br>        var result: Index? = nil<br>        for i in indices { <br>          if predicate(self[i]) { result = i }<br>        }<br>        return result<br>      }<br>    }<br></p><p>    extension Collection where Element : Equatable {<br>      func lastIndex(of value: Element) -&gt; Index? { <br>        return lastIndex(where: { $0 == value })<br>      }<br>    }<br></p><p>&gt; `index(_:offsetBy:)` is O(N) for a ForwardCollection, and `offset`<br>&gt; gets smaller as you execute the loop, so I *believe* this ends up<br>&gt; being O(N log N). I was never that good at big-O notation, though, so<br>&gt; I could be wrong about that. What I can say is that it would be O(N^2)<br>&gt; if not for the decreasing size of `offset`, so it&#39;s smaller than that.<br></p><p>What you wrote is still (N*(N - 1))/2 steps, i.e. O(N^2), in the worst<br>case, unless I&#39;m missing something.<br></p><p>&gt;&gt; I learned last week there&#39;s an O(N log N) in-place<br>&gt;&gt; reverse() for ForwardCollections, and I think we ought to have it.  log<br>&gt;&gt; N is effectively a constant for most purposes.<br>&gt;<br>&gt; If you guys think it&#39;s okay, I&#39;m not going to argue.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;        var result: Index? = nil<br>&gt;        for i in indices { <br>&gt;          if predicate(self[i]) { result = i }<br>&gt;        }<br>&gt;        return result<br></p><p>That is better! I didn&#39;t think to just give up on testing the minimum number of elements.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>(Draft) Add last(where:) and lastIndex(where:) methods</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Ha what a simple but great implementation! Seems obvious in retrospect.<br></p><p>&gt; On 22 May 2016, at 7:53 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat May 21 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; Similarly, we shouldn&#39;t provide operations which are going to<br>&gt;&gt;&gt;&gt; repeatedly seek elements near the tail of the list unless we&#39;re using<br>&gt;&gt;&gt;&gt; a type which can access that tail efficiently. `last` is one<br>&gt;&gt;&gt;&gt; thing—it&#39;s only O(N). `lastIndex(of:)` is, I believe, O(n log n) in<br>&gt;&gt;&gt;&gt; the case of an element that doesn&#39;t exist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t imagine where your O(N log N) comes from in this case, but even<br>&gt;&gt;&gt; if it is the right complexity that wouldn&#39;t be a reason not to provide<br>&gt;&gt;&gt; the operation.<br>&gt;&gt; <br>&gt;&gt; I&#39;m imagining an implementation something like this:<br>&gt;&gt; <br>&gt;&gt; 	func lastIndex(of value: Element) -&gt; Index? {<br>&gt;&gt; 		let count = self.count<br>&gt;&gt; <br>&gt;&gt; 		for endOffset in 0..&lt;count {<br>&gt;&gt; 			let offset = count - endOffset - 1<br>&gt;&gt; 			let i = index(startIndex, offsetBy: offset)<br>&gt;&gt; <br>&gt;&gt; 			if self[i] == value {<br>&gt;&gt; 				return i<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; <br>&gt;&gt; 		return nil<br>&gt;&gt; 	}<br>&gt; <br>&gt; <br>&gt; Oh, no!<br>&gt; <br>&gt;    extension Collection {<br>&gt;      func lastIndex(where predicate: (Element)-&gt;Bool) -&gt; Index? {<br>&gt;        var result: Index? = nil<br>&gt;        for i in indices { <br>&gt;          if predicate(self[i]) { result = i }<br>&gt;        }<br>&gt;        return result<br>&gt;      }<br>&gt;    }<br>&gt; <br>&gt;    extension Collection where Element : Equatable {<br>&gt;      func lastIndex(of value: Element) -&gt; Index? { <br>&gt;        return lastIndex(where: { $0 == value })<br>&gt;      }<br>&gt;    }<br>&gt; <br>&gt;&gt; `index(_:offsetBy:)` is O(N) for a ForwardCollection, and `offset`<br>&gt;&gt; gets smaller as you execute the loop, so I *believe* this ends up<br>&gt;&gt; being O(N log N). I was never that good at big-O notation, though, so<br>&gt;&gt; I could be wrong about that. What I can say is that it would be O(N^2)<br>&gt;&gt; if not for the decreasing size of `offset`, so it&#39;s smaller than that.<br>&gt; <br>&gt; What you wrote is still (N*(N - 1))/2 steps, i.e. O(N^2), in the worst<br>&gt; case, unless I&#39;m missing something.<br>&gt; <br>&gt;&gt;&gt; I learned last week there&#39;s an O(N log N) in-place<br>&gt;&gt;&gt; reverse() for ForwardCollections, and I think we ought to have it.  log<br>&gt;&gt;&gt; N is effectively a constant for most purposes.<br>&gt;&gt; <br>&gt;&gt; If you guys think it&#39;s okay, I&#39;m not going to argue.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
