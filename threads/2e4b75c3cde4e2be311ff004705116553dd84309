<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>More questions about protocol/value programming</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  1, 2016 at 01:00:00pm</p></header><div class="content"><p>In my schematic capture app, I had a class hierarchy that started with Element. From that I derived PartDefinition and PartInstance. Element has an immutable UUID, name, and description. Element knows how to encode itself as XML by conforming to an XMLCoding protocol.<br></p><p>Now I&#39;m trying to make Element into a Protocol, and make PartDefinition and PartInstance into structs. But I can&#39;t quite figure out how to inherit the XMLCoding implementation for Element. That is, Element can encode/decode its UUID, name, and desc. It does the decode in a convenience init(xml:) method that takes an XMLNode to parse.<br></p><p>So how to I add another init(xml:) method to one of my structs (like PartDefinition), and have it call the init(xml:) method on Element? With class inheritance, I was able to do this with a call to super. It&#39;s not clear to me how to do this with Protocols.<br></p><p>It needs to be in init() because I want some of the instance variables to be let and non-optional. Not actually sure how to do this.<br></p><p>protocol Element<br>{<br>    var uuid    :	UUID { get }<br>    var name    :	String?  { get }<br>    var desc    :	String?  { get }<br>}<br></p><p>extension Element<br>{<br>    init(xml inElement: XMLElement)<br>    {<br>        self.uuid = &lt;parse from inElement&gt;<br>    }<br>}<br></p><p>class<br>PartInstance : Element<br>{<br>    init()<br>    {<br>        self.uuid = UUID()<br>    }<br>    <br>    init(xml inElement: XMLElement)<br>    {<br>        //  Use shared implementation in Element extension?<br>    }<br></p><p>    let uuid: UUID<br>    var name: String?<br>    var desc: String?<br>}<br></p><p>class<br>PartDefinition : Element<br>{<br>    etc...<br>}<br></p><p>I may be missing some aspect of this entirely, but I&#39;m having a hard time seeing how to avoid lots of code duplication in this scenario. Appreciate thoughts and advice…<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>More questions about protocol/value programming</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August  2, 2016 at 06:00:00am</p></header><div class="content"><p>A protocol can require that a certain initialiser exists, but it can’t provide a default implementation (you can add initialisers in a protocol extension IIRC, but then they must delegate to an actual, required initialiser).<br></p><p>A protocol is not the same thing as a subclass. Any type could conform to a protocol. In that case, your init method wouldn’t be valid - there may be other stored properties besides “uuid”; in fact, “uuid” may not be a stored property at all by that type. For example, I could write an extension for String or Array&lt;T&gt; which makes them now conform to Element. The fact that “uuid” isn’t declared mutable but you are trying to set it, is a sign that there is not enough knowledge about the type to do this.<br></p><p>If you do have some common properties and want to encapsulate their logic, create a struct. For example, you might create an “XMLHeader” struct, and PartDefinition and PartInstance can contain it by composition. You would need to add forwarding accessors, but they can be added in an extension to avoid cluttering your code.<br></p><p>e.g.:<br></p><p>&gt; // Could this even be a nested type inside XMLElement, perhaps? That would be even cleaner. Maybe there could then be a “var header: Header?&quot; computed property on XMLElement?<br>&gt; <br>&gt; struct XMLElementHeader {<br>&gt; 	let uuid : UUID<br>&gt; 	var name : String?<br>&gt; 	var desc : String?<br>&gt; <br>&gt; 	static func parse(_ xml: XMLElement) -&gt; XMLElementHeader? {<br>&gt; 		// Validate xml<br>&gt; 		return XMLElementHeader(uuid: ..., name: .none, desc: .none)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class PartInstance {<br>&gt; <br>&gt; 	var header : XMLElementHeader<br>&gt; <br>&gt; 	init(xml: XMLElement) {<br>&gt; 		guard let parsedHeader = XMLElementHeader.parse(xml) else { fatalError() }<br>&gt; 		header = parsedHeader<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class PartDefinition {<br>&gt; 	<br>&gt; 	var header : XMLElementHeader<br>&gt; <br>&gt; 	init(xml: XMLElement) {<br>&gt; 		guard let parsedHeader = XMLElementHeader.parse(xml) else { fatalError() }<br>&gt; 		header = parsedHeader<br>&gt; 	}<br>&gt; }<br></p><p>Then, if you want to provide a nicer interface, do it with an extension:<br></p><p>&gt; protocol Element {<br>&gt; 	var uuid : UUID    { get }<br>&gt; 	var name : String? { get, set }<br>&gt; }<br>&gt; <br>&gt; extension PartInstance : Element {<br>&gt; 	var uuid : UUID    { return header.uuid }<br>&gt; 	var name : String? { get { return header.name }<br>&gt; 	 					 set { header.name = newValue } }	<br>&gt; }<br></p><p>That’s how I would do it, anyway.<br></p><p>Karl<br></p><p><br>&gt; On 1 Aug 2016, at 22:32, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; In my schematic capture app, I had a class hierarchy that started with Element. From that I derived PartDefinition and PartInstance. Element has an immutable UUID, name, and description. Element knows how to encode itself as XML by conforming to an XMLCoding protocol.<br>&gt; <br>&gt; Now I&#39;m trying to make Element into a Protocol, and make PartDefinition and PartInstance into structs. But I can&#39;t quite figure out how to inherit the XMLCoding implementation for Element. That is, Element can encode/decode its UUID, name, and desc. It does the decode in a convenience init(xml:) method that takes an XMLNode to parse.<br>&gt; <br>&gt; So how to I add another init(xml:) method to one of my structs (like PartDefinition), and have it call the init(xml:) method on Element? With class inheritance, I was able to do this with a call to super. It&#39;s not clear to me how to do this with Protocols.<br>&gt; <br>&gt; It needs to be in init() because I want some of the instance variables to be let and non-optional. Not actually sure how to do this.<br>&gt; <br>&gt; protocol Element<br>&gt; {<br>&gt;    var uuid    :	UUID { get }<br>&gt;    var name    :	String?  { get }<br>&gt;    var desc    :	String?  { get }<br>&gt; }<br>&gt; <br>&gt; extension Element<br>&gt; {<br>&gt;    init(xml inElement: XMLElement)<br>&gt;    {<br>&gt;        self.uuid = &lt;parse from inElement&gt;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class<br>&gt; PartInstance : Element<br>&gt; {<br>&gt;    init()<br>&gt;    {<br>&gt;        self.uuid = UUID()<br>&gt;    }<br>&gt; <br>&gt;    init(xml inElement: XMLElement)<br>&gt;    {<br>&gt;        //  Use shared implementation in Element extension?<br>&gt;    }<br>&gt; <br>&gt;    let uuid: UUID<br>&gt;    var name: String?<br>&gt;    var desc: String?<br>&gt; }<br>&gt; <br>&gt; class<br>&gt; PartDefinition : Element<br>&gt; {<br>&gt;    etc...<br>&gt; }<br>&gt; <br>&gt; I may be missing some aspect of this entirely, but I&#39;m having a hard time seeing how to avoid lots of code duplication in this scenario. Appreciate thoughts and advice…<br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>More questions about protocol/value programming</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>August  2, 2016 at 01:00:00am</p></header><div class="content"><p>Thanks, Karl, that&#39;s great!<br></p><p>In the end, I think I need to use classes, because I do have reference semantics in my model (e.g. a part definition can be referenced by multiple instances).<br></p><p>But this helps me get my head around the techniques. Thanks!<br></p><p>&gt; On Aug 1, 2016, at 21:39 , Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; A protocol can require that a certain initialiser exists, but it can’t provide a default implementation (you can add initialisers in a protocol extension IIRC, but then they must delegate to an actual, required initialiser).<br>&gt; <br>&gt; A protocol is not the same thing as a subclass. Any type could conform to a protocol. In that case, your init method wouldn’t be valid - there may be other stored properties besides “uuid”; in fact, “uuid” may not be a stored property at all by that type. For example, I could write an extension for String or Array&lt;T&gt; which makes them now conform to Element. The fact that “uuid” isn’t declared mutable but you are trying to set it, is a sign that there is not enough knowledge about the type to do this.<br>&gt; <br>&gt; If you do have some common properties and want to encapsulate their logic, create a struct. For example, you might create an “XMLHeader” struct, and PartDefinition and PartInstance can contain it by composition. You would need to add forwarding accessors, but they can be added in an extension to avoid cluttering your code.<br>&gt; <br>&gt; e.g.:<br>&gt; <br>&gt;&gt; // Could this even be a nested type inside XMLElement, perhaps? That would be even cleaner. Maybe there could then be a “var header: Header?&quot; computed property on XMLElement?<br>&gt;&gt; <br>&gt;&gt; struct XMLElementHeader {<br>&gt;&gt; 	let uuid : UUID<br>&gt;&gt; 	var name : String?<br>&gt;&gt; 	var desc : String?<br>&gt;&gt; <br>&gt;&gt; 	static func parse(_ xml: XMLElement) -&gt; XMLElementHeader? {<br>&gt;&gt; 		// Validate xml<br>&gt;&gt; 		return XMLElementHeader(uuid: ..., name: .none, desc: .none)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class PartInstance {<br>&gt;&gt; <br>&gt;&gt; 	var header : XMLElementHeader<br>&gt;&gt; <br>&gt;&gt; 	init(xml: XMLElement) {<br>&gt;&gt; 		guard let parsedHeader = XMLElementHeader.parse(xml) else { fatalError() }<br>&gt;&gt; 		header = parsedHeader<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class PartDefinition {<br>&gt;&gt; 	<br>&gt;&gt; 	var header : XMLElementHeader<br>&gt;&gt; <br>&gt;&gt; 	init(xml: XMLElement) {<br>&gt;&gt; 		guard let parsedHeader = XMLElementHeader.parse(xml) else { fatalError() }<br>&gt;&gt; 		header = parsedHeader<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt; <br>&gt; Then, if you want to provide a nicer interface, do it with an extension:<br>&gt; <br>&gt;&gt; protocol Element {<br>&gt;&gt; 	var uuid : UUID    { get }<br>&gt;&gt; 	var name : String? { get, set }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension PartInstance : Element {<br>&gt;&gt; 	var uuid : UUID    { return header.uuid }<br>&gt;&gt; 	var name : String? { get { return header.name }<br>&gt;&gt; 	 					 set { header.name = newValue } }	<br>&gt;&gt; }<br>&gt; <br>&gt; That’s how I would do it, anyway.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; <br>&gt;&gt; On 1 Aug 2016, at 22:32, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In my schematic capture app, I had a class hierarchy that started with Element. From that I derived PartDefinition and PartInstance. Element has an immutable UUID, name, and description. Element knows how to encode itself as XML by conforming to an XMLCoding protocol.<br>&gt;&gt; <br>&gt;&gt; Now I&#39;m trying to make Element into a Protocol, and make PartDefinition and PartInstance into structs. But I can&#39;t quite figure out how to inherit the XMLCoding implementation for Element. That is, Element can encode/decode its UUID, name, and desc. It does the decode in a convenience init(xml:) method that takes an XMLNode to parse.<br>&gt;&gt; <br>&gt;&gt; So how to I add another init(xml:) method to one of my structs (like PartDefinition), and have it call the init(xml:) method on Element? With class inheritance, I was able to do this with a call to super. It&#39;s not clear to me how to do this with Protocols.<br>&gt;&gt; <br>&gt;&gt; It needs to be in init() because I want some of the instance variables to be let and non-optional. Not actually sure how to do this.<br>&gt;&gt; <br>&gt;&gt; protocol Element<br>&gt;&gt; {<br>&gt;&gt;   var uuid    :	UUID { get }<br>&gt;&gt;   var name    :	String?  { get }<br>&gt;&gt;   var desc    :	String?  { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Element<br>&gt;&gt; {<br>&gt;&gt;   init(xml inElement: XMLElement)<br>&gt;&gt;   {<br>&gt;&gt;       self.uuid = &lt;parse from inElement&gt;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class<br>&gt;&gt; PartInstance : Element<br>&gt;&gt; {<br>&gt;&gt;   init()<br>&gt;&gt;   {<br>&gt;&gt;       self.uuid = UUID()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   init(xml inElement: XMLElement)<br>&gt;&gt;   {<br>&gt;&gt;       //  Use shared implementation in Element extension?<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   let uuid: UUID<br>&gt;&gt;   var name: String?<br>&gt;&gt;   var desc: String?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class<br>&gt;&gt; PartDefinition : Element<br>&gt;&gt; {<br>&gt;&gt;   etc...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I may be missing some aspect of this entirely, but I&#39;m having a hard time seeing how to avoid lots of code duplication in this scenario. Appreciate thoughts and advice…<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
