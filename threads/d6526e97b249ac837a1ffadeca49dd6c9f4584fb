<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>February 16, 2016 at 03:00:00pm</p></header><div class="content"><p>But wouldn’t you say optional chaining is almost the same thing?  I’m a bit puzzled why people say this new proposal makes the code confusing, while the current implementation of optional chaining isn’t frowned upon.<br></p><p>let a: String? = &quot;123&quot;<br>let b: String = &quot;456&quot;<br>let c = a?.stringByAppendingString(b)<br></p><p>This works as expected.<br></p><p>let a: String = &quot;123&quot;<br>let b: String? = &quot;456&quot;<br>let c = a.stringByAppendingString(b?)<br></p><p>This, however, does not work. I think the only reason the second example seems a bit off is because we’re not used to it, but both seem equally readable to me. The second example is basically equivalent to this:<br></p><p>let a: String = “123”<br>let b: String? = “456”<br>let c = b?.stringByPrependingString(a)<br></p><p>Which would work, if only there is no such function. I guess the point I’m trying to make is that currently, whether we have to use a lot of boilerplate code depends on the choice of receiver and argument of the function, which could be completely arbitrary.<br></p><p>&gt; &gt; To address this, the nil-coalescing operator would allow $$, where $$ is the unwrapped unnamed result of the expression when non nil:<br>&gt; &gt; <br>&gt; &gt; func doSomething(value: Int) -&gt;Int {<br>&gt; &gt; return value<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; let ra = a ?? doSomething($$)<br>&gt; &gt; let rc = c ?? doSomething($$)<br>&gt; &gt; <br>&gt; &gt; ra -&gt;5<br>&gt; &gt; rc -&gt;nil<br>&gt; I think this is completely the wrong way to approach this.<br>&gt; <br>&gt; *If* you want to implement this feature, I think the way to do it is to say that you can put ? after any optional parameter to a normal function call, and Swift will unwrap all the parameters so marked and make the call return `nil` if any of them are nil.<br>&gt; <br>&gt; let ra = doSomething(a?)<br>&gt; let rc = doSomething(c?)<br>&gt; <br>&gt; Naturally, since operators are just function calls with a funny syntax, this would also extend to operators.<br>&gt; <br>&gt; a? + b // a.k.a. +(a?, b)<br>&gt; <br>&gt; Even in this form, however, I don&#39;t think this is a feature worth having. Too indirect and specialized.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 16, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; But wouldn’t you say optional chaining is almost the same thing? I’m a bit puzzled why people say this new proposal makes the code confusing, while the current implementation of optional chaining isn’t frowned upon.<br></p><p>My version is definitely completely analogous to optional chaining; you&#39;re just doing it on the optionality of the parameters instead of the method&#39;s target.<br></p><p>But just because it&#39;s analogous doesn&#39;t mean it&#39;s a good idea.<br></p><p>To see why, let&#39;s dispose of the &quot;a&quot; and &quot;b&quot; examples and do something a little more realistic. This code is based on something one of my controllers does (though I&#39;ve intentionally complicated it). Give it a glance, but don&#39;t linger on it:<br></p><p>	rebuildPageList(in: self.pagesPopupButton?.menu?, from: self.book?.tableOfContents.elements ?? [])<br></p><p>Does rebuildPageList(in:from:) get called every time this line is run? Does it depend on the popup button, the element list, or both? Which parts of the method chain that creates each parameter can be nil, and which cannot? If you carefully parse the line, you can answer all these questions, but it&#39;s not too easy at a glance.<br></p><p>This is less of a problem for the current optional chaining features because they all work in a line, so to speak; you can ignore the parameters and keys and merely focus on the chain of methods, properties, and subscriptors.<br></p><p>It&#39;s not that this isn&#39;t a straightforward extension of an existing idea—it absolutely is. But sometimes a syntax that&#39;s perfect for one area is too lightweight, too easy to overlook, for another. With this proposal in place, the only way to know if any function, or even any *operator*, is actually performed is to check all of its parameters for a question mark. That may be a bridge too far.<br></p><p>And again, I&#39;m not convinced that there are *that* many cases where you want a function to return nil instead of being executed if one of its parameters is nil. It certainly happens sometimes—it&#39;s even happened to me on occasion—but I&#39;m not sure it&#39;s a common enough case, particularly when the proposed solution is &quot;add a feature that means the presence or absence of a single character buried in the middle of complex expression can make it conditional&quot;.<br></p><p>In short, your proposal will require people to read their code *much* more closely than they currently need to. I&#39;m not sure it offers enough benefit to impose that cost.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7411024ff3fb3fdbb0624c41b72a1b92?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Alan Skipp</string> &lt;al_skipp at icloud.com&gt;<p>February 16, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 16 Feb 2016, at 14:10, tvermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; let a: String = &quot;123&quot;<br>&gt; let b: String? = &quot;456&quot;<br>&gt; let c = a.stringByAppendingString(b?)<br>&gt; <br>&gt; This, however, does not work.<br></p><p>If ‘b’ were nil then the result of appending it to a String would be nil. I think this would cause quite a bit of confusion (an appending operation resulting in less than what you started with).<br></p><p>The equivalent code would be:<br></p><p>b.map { a.stringByAppendingString($0) }<br></p><p>It might not be as succinct, but it makes it clearer that the operation depends on the value of ‘b’.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 17, 2016 at 05:00:00pm</p></header><div class="content"><p>Optional chaining is different because of the asymmetry between receiver and arguments (Swift is using single dispatch and not multiple dispatch) and moreover because it is linear and the execution order is clear and simple to understand, i.e. when evaluating<br></p><p>a?.foo()?.bar()?.baz()<br></p><p>I know that when bar() answers nil that foo() has been executed but baz() has not.<br></p><p>When evaluating<br></p><p>a.foo()? + b.bar()? * baz(c?)<br></p><p>I think is is much more difficult to understand what will have been executed when c answers nil, for example.<br></p><p>-Thorsten <br></p><p>&gt; Am 16.02.2016 um 15:10 schrieb tvermeulen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; But wouldn’t you say optional chaining is almost the same thing?  I’m a bit puzzled why people say this new proposal makes the code confusing, while the current implementation of optional chaining isn’t frowned upon.<br>&gt; <br>&gt; let a: String? = &quot;123&quot;<br>&gt; let b: String = &quot;456&quot;<br>&gt; let c = a?.stringByAppendingString(b)<br>&gt; <br>&gt; This works as expected.<br>&gt; <br>&gt; let a: String = &quot;123&quot;<br>&gt; let b: String? = &quot;456&quot;<br>&gt; let c = a.stringByAppendingString(b?)<br>&gt; <br>&gt; This, however, does not work. I think the only reason the second example seems a bit off is because we’re not used to it, but both seem equally readable to me. The second example is basically equivalent to this:<br>&gt; <br>&gt; let a: String = “123”<br>&gt; let b: String? = “456”<br>&gt; let c = b?.stringByPrependingString(a)<br>&gt; <br>&gt; Which would work, if only there is no such function. I guess the point I’m trying to make is that currently, whether we have to use a lot of boilerplate code depends on the choice of receiver and argument of the function, which could be completely arbitrary.<br>&gt; <br>&gt;&gt;&gt; To address this, the nil-coalescing operator would allow $$, where $$ is the unwrapped unnamed result of the expression when non nil:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(value: Int) -&gt;Int {<br>&gt;&gt;&gt; return value<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let ra = a ?? doSomething($$)<br>&gt;&gt;&gt; let rc = c ?? doSomething($$)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ra -&gt;5<br>&gt;&gt;&gt; rc -&gt;nil<br>&gt;&gt; I think this is completely the wrong way to approach this.<br>&gt;&gt; <br>&gt;&gt; *If* you want to implement this feature, I think the way to do it is to say that you can put ? after any optional parameter to a normal function call, and Swift will unwrap all the parameters so marked and make the call return `nil` if any of them are nil.<br>&gt;&gt; <br>&gt;&gt; let ra = doSomething(a?)<br>&gt;&gt; let rc = doSomething(c?)<br>&gt;&gt; <br>&gt;&gt; Naturally, since operators are just function calls with a funny syntax, this would also extend to operators.<br>&gt;&gt; <br>&gt;&gt; a? + b // a.k.a. +(a?, b)<br>&gt;&gt; <br>&gt;&gt; Even in this form, however, I don&#39;t think this is a feature worth having. Too indirect and specialized.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
