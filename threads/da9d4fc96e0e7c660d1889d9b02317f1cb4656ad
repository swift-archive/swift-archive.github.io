<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 21, 2016 at 10:00:00am</p></header><div class="content"><p>on Wed Jul 20 2016, Jonathan Hull &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 20, 2016, at 3:30 PM, Dave Abrahams &lt;dave at boostpro.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jul 20 2016, Dave Abrahams &lt;dabrahams-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; on Wed Jul 20 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Basically, I added back in a super-minimal protocol to fill the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; structural gap left by Sequence.  I call it “IteratorProvider” and it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only has a single function which vends an iterator.  Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; adheres to this, and Iterator adheres to it by returning itself.  All<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the other methods from Sequence remain on Iterator.  Thus anyone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with API that only needs a single pass would take a IteratorProvider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and then work on the iterator it provides.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That leaves us back where we are now: people will see that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IteratorProvider is a simple, universal protocol for both single-and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; multi-pass sequences, write algorithm libraries that depend on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; multi-pass-ness, and test them with the most prevalent examples, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; happen to be multi pass.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let me make a quick counter-argument, because I thought about it a<br>&gt;&gt;&gt;&gt;&gt;&gt; bit, and I don’t think it does have the same problem (especially with<br>&gt;&gt;&gt;&gt;&gt;&gt; careful/better naming).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The difference is that the ONLY method on IteratorProvider is the one<br>&gt;&gt;&gt;&gt;&gt;&gt; to get an iterator.  There is no map, filter, sort, first, count, etc…<br>&gt;&gt;&gt;&gt;&gt;&gt; just a way to get a single-pass iterator.  This changes the mindset<br>&gt;&gt;&gt;&gt;&gt;&gt; when using it.  You are aware that you are getting a single-pass<br>&gt;&gt;&gt;&gt;&gt;&gt; iterator.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe.  What&#39;s to stop people from extending IteratorProvider?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nothing.  But that is true of any protocol.  I am ok with individual&#39;s<br>&gt;&gt;&gt;&gt; extensions.  They would have to use that single method to build up<br>&gt;&gt;&gt;&gt; from anyway, so presumably they would have to consider the single pass<br>&gt;&gt;&gt;&gt; case in their extensions...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; True, people might try to get the iterator a second time, but we can<br>&gt;&gt;&gt;&gt;&gt;&gt; make the iteratorProvider method optional (and trying to get an<br>&gt;&gt;&gt;&gt;&gt;&gt; iterator from an iterator which is spent would return nil) <br>&gt;&gt;&gt;&gt;&gt;&gt; and then they are forced to deal with the case where it was<br>&gt;&gt;&gt;&gt;&gt;&gt; single-pass.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now you can&#39;t loop over the same array multiple times.<br>&gt;&gt;&gt;&gt; I must be missing something.  Isn’t that the point?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No.  Arrays are multipass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I mean, your version is called “IterableOnce”.  Why do you want to<br>&gt;&gt;&gt;&gt; iterate on IterableOnce more than once?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because it happens to be multipass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The point (at least in my mind) is to provide a common interface for<br>&gt;&gt;&gt;&gt; things that we want to iterate over a single time.  If you want to<br>&gt;&gt;&gt;&gt; iterate multiple times, use collection’s interface where you are<br>&gt;&gt;&gt;&gt; guaranteed multi-pass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for ... in uses Iterators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, you actually can loop multiple times for collections by<br>&gt;&gt;&gt;&gt; getting a new iterator from the provider (which could point to the<br>&gt;&gt;&gt;&gt; same array storage).  The optional just forces you to check for the<br>&gt;&gt;&gt;&gt; single-pass case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, I&#39;m sorry; I didn&#39;t realize you were saying that only single-pass<br>&gt;&gt;&gt; IteratorProviders would ever return nil from their methods.<br>&gt;&gt; <br>&gt;&gt; Note: any IteratorProvider that could return nil would have to be a<br>&gt;&gt; class (or wrap a class) in order to bypass mutability restrictions,<br>&gt;&gt; since we can&#39;t allow the method that provides the iterator to be<br>&gt;&gt; mutating.<br>&gt;<br>&gt; That is a good point.  I think I am ok with it, since in my mind this<br>&gt; is already true of non-clonable Iterators anyway.  If you recall, in<br>&gt; my original proposal I wanted to make iterators reference types. That<br>&gt; was rejected for performance reasons, but I still think that<br>&gt; non-clonable Iterators will at least need to wrap a reference type<br>&gt; somewhere (or they will be subject to the issue you are talking about<br>&gt; above).<br>&gt;<br>&gt; Note: In the current system, it is common to create sequences, but<br>&gt; under my proposal it would be rare to create an IteratorProvider that<br>&gt; wasn’t also an Iterator or Collection, since Iterator and Collection<br>&gt; would both have default implementations satisfying IteratorProvider,<br>&gt; and IteratorProvider doesn’t have any useful methods besides the one<br>&gt; providing an Iterator.<br></p><p>Suggestion: Realistically, I see no possibility that this idea can be<br>completely designed, reviewed, approved, and implemented in time for<br>Swift 3, so let&#39;s take this up after Swift 3 ships.  Yes, it&#39;s a<br>breaking change, but there *will* be some of those going forward.<br>Obviously, if you disagree, feel free to pursue it now, but—even though<br>I&#39;m very interested in this topic—I don&#39;t<br>think I have the time budget to participate at the moment.<br></p><p>Regardless, the best proof-of-concept would be to implement it and<br>create a pull request against Swift that demonstrates how it works and<br>passes tests, and that can be worked on by anybody at any time.  That&#39;s<br>also the only thing I can imagine that would make it realistic for me to<br>spend time on it before Swift 3 ships.<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
