<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 13, 2016 at 06:00:00pm</p></header><div class="content"><p>As Thorstan forgot to resend his message to the list, here it is (read below). It should make things about `any&lt;&gt;` more clear.<br></p><p>———<br></p><p>func f(obj: class&lt;SomeClass,SomeProtocl&gt;) {..}<br>if obj is class&lt;SomeClass,SomeProtocl&gt; {..}<br>obj2 = obj as! class&lt;SomeClass,SomeProtocol&gt;<br> <br>and yes, probably struct&lt;SomeStruct,SomeProtocol&gt;<br>Why would you want to add all of these different formats where only one could serve them all. This is redundant in my opinion. <br></p><p>`struct&lt;&gt;` and `enum&lt;&gt;` would have same rules, only the first element would be a different value-type. I might consider this as an alternative.<br></p><p>Correct me if I’m wrong with the redundancy.<br></p><p>———<br></p><p>The &amp; type operator would produce a “flattened&quot; all&lt;&gt; with its operands.  It could be overloaded to accept either a concrete type or a protocol on the lhs and would produce `type` for an lhs that is a type and `all` when lhs is a protocol.   &quot;Type operators” would be evaluated during compile time and would produce a type that is used where the expression was present in the code.  This is a long-term idea, not something that needs to be considered right now.  It would be way out of scope for Swift 3.  <br>Which part of your statement is exactly out of scope for Swift 3, “Type operators“ I guess? <br></p><p>So is it a good idea to add `&amp;` operator for &quot;flattened“ `all&lt;&gt;` whereas “Type operators“ would be a better way to go (for Swift 4 maybe)? As far as I understand the idea behind `&amp;` operator I’m not sure how it could be overloaded, because I thought it would be baked right into the language.<br></p><p>If I mixed something up here please feel free to correct me.<br></p><p>———<br></p><p>Would you mind to give me some feedback for the rules I&#39;ve summarized.<br></p><p>———<br></p><p>The overall feedback seems to be positive so for and my fingers are crossed for this feature to be accepted.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Mai 2016 bei 08:16:51, Thorsten Seitz (tseitz42 at icloud.com) schrieb:<br></p><p><br></p><p>Am 12. Mai 2016 um 22:08 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br></p><p>`all&lt;&gt;` and `any&lt;&gt;` form a pair of complementary type operators, one creating the intersection of the given types (your proposal) and the other creating the union of the given types. As Ceylon has demonstrated that both are really useful I&#39;d like to have both in Swift and therefore would prefer that both should be named such that this duality is visible. Having `type&lt;&gt;` and `any&lt;&gt;` would certainly be possible technically but the naming would not be good.<br></p><p><br>From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br></p><p>You are right, `any&lt;&gt;` is something different and could be proposed in its own thread. I just wanted to extend the context for finding a good name for `type&lt;&gt;`.<br></p><p><br>Here is a little example where `any&lt;&gt;` gets strange:<br></p><p>func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br></p><p>    // how would one use value here?<br>    // what about its properties<br>    // what will foo return and how to use the result<br>}<br></p><p>Ceylon uses flow typing for that (if (is String value) { /* value has type String here */ }).<br>In Swift the equivalent would be `if let string = value as? String { ... }`:<br></p><p>func foo(value: any&lt;Strint, Int&gt;) -&gt; any&lt;String, Int&gt; {<br>   if let string = value as? String {<br>      return string.characters.count<br>   }<br>   else if let int= value as? Int {<br>      return String(int)<br>   }<br>}<br></p><p>A more sensical example using a type union would be the union of two sets:<br></p><p>func union&lt;T, U&gt;(a: Set&lt;T&gt;, b: Set&lt;U&gt;) -&gt; Set&lt;any&lt;T, U&gt;&gt; { ... }<br></p><p>And for type intersection the intersection of two sets:<br></p><p>func intersection&lt;T, U&gt;(a: Set&lt;T&gt;, b: Set&lt;U&gt;) -&gt; Set&lt;all&lt;T, U&gt;&gt; { ... }<br></p><p>(Ceylon&#39;s type operators just read better there...)<br></p><p>Another example for type unions:<br>Ceylon like Swift makes heavy use of optionals but where Swift has a generic wrapper Optional&lt;T&gt; Ceylon just makes use of type unions: in Ceylon T? is syntactic sugar for the type union T | Null where Null is the type having the singleton value null.<br></p><p>FWIW Microsoft&#39;s Typescript gained union and intersection types about (I think) a year ago.<br></p><p><br>One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br></p><p>Exactly.<br></p><p> <br>`all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br></p><p>Right, `all&lt;&gt;` is just an alternative name for `type&lt;&gt;`. There is no change in functionality.<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/b1cb8257/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 08:00:00pm</p></header><div class="content"><p>On 13.05.2016 19:38, Adrian Zubarev via swift-evolution wrote:<br>&gt; Why would you want to add all of these different formats where only one<br>&gt; could serve them all. This is redundant in my opinion.<br>&gt;<br>&gt; `struct&lt;&gt;` and `enum&lt;&gt;` would have same rules, only the first element would<br>&gt; be a different value-type. I might consider this as an alternative.<br>&gt;<br></p><p>Actually, I fully support your idea and strongly +1 for `type&lt;&gt;` keyword. I <br>don&#39;t believe it will confuse anyone as protocol&lt;&gt; does not confuse currently.<br></p><p>But as I can see, the community(or core team) is strongly against of using <br>`type` keyword.<br>So, we have situation : protocol&lt;&gt; and .. all&lt;&gt; ? Will all&lt;&gt; include <br>protocols also? Probably I&#39;d support to remove protocol&lt;&gt; and introduce <br>just all&lt;&gt; for all :-) But if we have protocol&lt;&gt; and can&#39;t have type&lt;&gt; - I <br>asked why we can&#39;t for clarity and consistency have class&lt;&gt; struct&lt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 08:00:00pm</p></header><div class="content"><p>Btw, if we&#39;d have separate class&lt;&gt; and struct&lt;&gt; - we&#39;d be able to have <br>method to separate reference type from value type.<br></p><p>We can write now : print(c is protocol&lt;&gt;)<br></p><p>and we&#39;d can:<br></p><p>print(c is class&lt;&gt;)<br>print(c is struct&lt;&gt;)<br></p><p>Just thoughts..<br></p><p>On 13.05.2016 20:04, Vladimir.S wrote:<br>&gt; On 13.05.2016 19:38, Adrian Zubarev via swift-evolution wrote:<br>&gt;&gt; Why would you want to add all of these different formats where only one<br>&gt;&gt; could serve them all. This is redundant in my opinion.<br>&gt;&gt;<br>&gt;&gt; `struct&lt;&gt;` and `enum&lt;&gt;` would have same rules, only the first element would<br>&gt;&gt; be a different value-type. I might consider this as an alternative.<br>&gt;&gt;<br>&gt;<br>&gt; Actually, I fully support your idea and strongly +1 for `type&lt;&gt;` keyword. I<br>&gt; don&#39;t believe it will confuse anyone as protocol&lt;&gt; does not confuse currently.<br>&gt;<br>&gt; But as I can see, the community(or core team) is strongly against of using<br>&gt; `type` keyword.<br>&gt; So, we have situation : protocol&lt;&gt; and .. all&lt;&gt; ? Will all&lt;&gt; include<br>&gt; protocols also? Probably I&#39;d support to remove protocol&lt;&gt; and introduce<br>&gt; just all&lt;&gt; for all :-) But if we have protocol&lt;&gt; and can&#39;t have type&lt;&gt; - I<br>&gt; asked why we can&#39;t for clarity and consistency have class&lt;&gt; struct&lt;&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>May 13, 2016 at 06:00:00pm</p></header><div class="content"><p>In reply to:<br></p><p>Why would you want to add all of these different formats where only one<br>could serve them all. This is redundant in my opinion.<br></p><p>`struct&lt;&gt;` and `enum&lt;&gt;` would have same rules, only the first element would<br>be a different value-type. I might consider this as an alternative.<br></p><p>Correct me if I’m wrong with the redundancy.<br></p><p><br>&#39;enum&lt;&gt;&#39; might be valid, unless their functions (e.g. for &#39;init(rawValue:<br>Int)&#39; or &#39;allCases&#39;) are declared in explicit protocols which would<br>implicitly cover enums and which other types could declare conformance to.<br></p><p>&#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If you want a<br>struct which conforms to several protocols, protocol&lt;&gt; already covers this.<br>I know there&#39;s a discussion at the moment regarding the equivalent of an<br>&#39;AnyObject&#39; for value types, which might apply to this discussion, but I&#39;m<br>not sure how.<br></p><p>A class in general would also a protocol&lt;AnyObject, ...&gt;. The benefit of<br>&#39;type&lt;&gt;&#39; is in its ability to extend the behaviours of several subclasses<br>at once, e.g. type&lt;UIViewController, UIScrollViewDelegate&gt; covers all view<br>controllers with scroll views, not just UITableViewController,<br>UICollectionViewController, etc..<br></p><p><br></p><p>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/4ace2772/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 13, 2016 at 07:00:00pm</p></header><div class="content"><p>&#39;struct&lt;&gt;&#39; does seem redundant unless it becomes subtypeable. If you want a struct which conforms to several protocols, protocol&lt;&gt; already covers this.<br>I think this is not correct. Lets check this example:<br></p><p>func foo(value: SomeProtocol) {<br></p><p>    if let a = value as? struct&lt;StructA, SomeProtocol&gt; { /* do something with a */ }<br></p><p>    else if let b = value as? struct&lt;StructB, SomeProtocol&gt; { /* do something with b */ }<br></p><p>}<br></p><p>In this scenario you’ll be able to access properties and functions from `StructA` or `StructB` which might not be covered by `SomeProtocol`. Everything is merged nicely into one instance. But you are right it depends on the use-case.<br></p><p><br></p><p>Btw, if we&#39;d have separate class&lt;&gt; and struct&lt;&gt; - we&#39;d be able to have method to separate reference type from value type. <br>We can write now : print(c is protocol&lt;&gt;) <br>and we&#39;d can: <br>print(c is class&lt;&gt;) <br>print(c is struct&lt;&gt;) <br></p><p>True, I didn’t thought about that effect at the first glance, thank you for the hint. I will add this to the draft proposal tomorrow.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/4a9f75e9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
