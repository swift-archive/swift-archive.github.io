<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Further directions for id-as-Any</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>September  6, 2016 at 05:00:00am</p></header><div class="content"><p>In the current Swift 3 betas, value types can now be passed into Objective-C as opaque box objects. A couple of reviews are currently running which tweak this bridging, exposing Optionals and NSValue/NSNumber-compatible types in more natural ways. These are all Good Things. I&#39;d like to look ahead and sketch out a way this feature could evolve further. This will not be detailed, and much or all of it may be out of scope for Phase 1.<br></p><p><br>Firstly, I think we could make boxed value types much more usable from Objective-C:<br></p><p>1. We could bridge selector calls to equivalent Swift methods, where those methods are Objective-C-compatible (other than being on a value type). This could actually be done dynamically if enough metadata is available.<br></p><p>2. We could generate a separate subclass of our box class for each bridged Swift type. This could actually *still* be done dynamically, I believe.<br></p><p>3. We could permit value types to conform to @objc protocols. This would open up several nice features to us; perhaps most importantly, a value type could conform to NSCoding and thereby participate in Foundation&#39;s serialization mechanisms. I suspect that at this point, the box subclasses would have to become &quot;real&quot;, i.e., registered at load time. (Perhaps they&#39;re only greedily registered if they have an explicit @objc?)<br></p><p>4. We could explicitly declare the bridged methods, properties, and conformances in the generated -Swift.h file, thereby making Swift value types directly available to Objective-C, where they can be allocated, accessed, and manipulated in boxed form.<br></p><p><br>Secondly—and separately, but relatedly—I believe a few simple changes could liberalize the @objc-compatibility rules, permitting many more members to be exposed to Objective-C:<br></p><p>1. We could run &quot;omit needless words&quot; in reverse when exposing Swift methods to Objective-C. This would prevent overloads from clashing in Objective-C, and would also have the bonus feature of producing more idiomatic Objective-C interfaces. (Incidentally, is a change considered source-breaking if it breaks Objective-C code, not Swift code?)<br></p><p>2. We could grant access to members using Swift-only type features by allowing the Objective-C versions to have looser types than the Swift versions, and dynamically enforcing the missing constraints instead. For instance, a member with a complicated `where` clause might omit the clause in its Objective-C declaration, but enforce it with a dynamic test.<br></p><p>3. I suspect it might be possible to expose generic types to Objective-C with some custom class methods. For instance, a Swift type with `Key` and `Value` type parameters might have `+classWithKey:(Class)keyClass value:(Class)valueClass` and +`allocWithKey:(Class)keyClass value:(Class)valueClass` methods on it.<br></p><p><br>Are these potential features of interest? If so, to what extent do they affect binary compatibility? On the one hand, they are extensions, adding transparency to things which are currently opaque. But on the other hand, they will presumably involve generating type metadata.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b04cad4cec3d0229248b366373bf4e62?s=50"></div><header><strong>[Idea] Further directions for id-as-Any</strong> from <string>Will Field-Thompson</string> &lt;will.a.ft at gmail.com&gt;<p>September  6, 2016 at 05:00:00pm</p></header><div class="content"><p>This might be useful for some cases, but I have some concerns about tying<br>serialization to this. I would rather see a Swift-centric rethinking of<br>serialization than having the runtime dynamically register Objective-C<br>classes anytime I want to serialize something. Plus, that seems like it&#39;s<br>leaving Linux users out in the cold for serialization — although I&#39;m<br>primarily a macOS/iOS user, so maybe there&#39;s something I don&#39;t know about<br>the corelibs Foundation implementation.<br></p><p>Will Field-Thompson<br></p><p>On Tue, Sep 6, 2016 at 8:20 AM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In the current Swift 3 betas, value types can now be passed into<br>&gt; Objective-C as opaque box objects. A couple of reviews are currently<br>&gt; running which tweak this bridging, exposing Optionals and<br>&gt; NSValue/NSNumber-compatible types in more natural ways. These are all Good<br>&gt; Things. I&#39;d like to look ahead and sketch out a way this feature could<br>&gt; evolve further. This will not be detailed, and much or all of it may be out<br>&gt; of scope for Phase 1.<br>&gt;<br>&gt;<br>&gt; Firstly, I think we could make boxed value types much more usable from<br>&gt; Objective-C:<br>&gt;<br>&gt; 1. We could bridge selector calls to equivalent Swift methods, where those<br>&gt; methods are Objective-C-compatible (other than being on a value type). This<br>&gt; could actually be done dynamically if enough metadata is available.<br>&gt;<br>&gt; 2. We could generate a separate subclass of our box class for each bridged<br>&gt; Swift type. This could actually *still* be done dynamically, I believe.<br>&gt;<br>&gt; 3. We could permit value types to conform to @objc protocols. This would<br>&gt; open up several nice features to us; perhaps most importantly, a value type<br>&gt; could conform to NSCoding and thereby participate in Foundation&#39;s<br>&gt; serialization mechanisms. I suspect that at this point, the box subclasses<br>&gt; would have to become &quot;real&quot;, i.e., registered at load time. (Perhaps<br>&gt; they&#39;re only greedily registered if they have an explicit @objc?)<br>&gt;<br>&gt; 4. We could explicitly declare the bridged methods, properties, and<br>&gt; conformances in the generated -Swift.h file, thereby making Swift value<br>&gt; types directly available to Objective-C, where they can be allocated,<br>&gt; accessed, and manipulated in boxed form.<br>&gt;<br>&gt;<br>&gt; Secondly—and separately, but relatedly—I believe a few simple changes<br>&gt; could liberalize the @objc-compatibility rules, permitting many more<br>&gt; members to be exposed to Objective-C:<br>&gt;<br>&gt; 1. We could run &quot;omit needless words&quot; in reverse when exposing Swift<br>&gt; methods to Objective-C. This would prevent overloads from clashing in<br>&gt; Objective-C, and would also have the bonus feature of producing more<br>&gt; idiomatic Objective-C interfaces. (Incidentally, is a change considered<br>&gt; source-breaking if it breaks Objective-C code, not Swift code?)<br>&gt;<br>&gt; 2. We could grant access to members using Swift-only type features by<br>&gt; allowing the Objective-C versions to have looser types than the Swift<br>&gt; versions, and dynamically enforcing the missing constraints instead. For<br>&gt; instance, a member with a complicated `where` clause might omit the clause<br>&gt; in its Objective-C declaration, but enforce it with a dynamic test.<br>&gt;<br>&gt; 3. I suspect it might be possible to expose generic types to Objective-C<br>&gt; with some custom class methods. For instance, a Swift type with `Key` and<br>&gt; `Value` type parameters might have `+classWithKey:(Class)keyClass<br>&gt; value:(Class)valueClass` and +`allocWithKey:(Class)keyClass<br>&gt; value:(Class)valueClass` methods on it.<br>&gt;<br>&gt;<br>&gt; Are these potential features of interest? If so, to what extent do they<br>&gt; affect binary compatibility? On the one hand, they are extensions, adding<br>&gt; transparency to things which are currently opaque. But on the other hand,<br>&gt; they will presumably involve generating type metadata.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/6e330f52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Idea] Further directions for id-as-Any</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>September  6, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Sep 6, 2016, at 10:02 AM, Will Field-Thompson &lt;will.a.ft at gmail.com&gt; wrote:<br>&gt; <br>&gt; I would rather see a Swift-centric rethinking of serialization than having the runtime dynamically register Objective-C classes anytime I want to serialize something. Plus, that seems like it&#39;s leaving Linux users out in the cold for serialization — although I&#39;m primarily a macOS/iOS user, so maybe there&#39;s something I don&#39;t know about the corelibs Foundation implementation.<br></p><p>I do hope that it will *also* become possible to access a Swift type in pure Swift given a name and a protocol it conforms to, which would allow Corelibs Foundation to also support NSCoding on value types. But that&#39;s a separate issue from improving Objective-C bridging.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Idea] Further directions for id-as-Any</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Sep 6, 2016, at 5:19 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the current Swift 3 betas, value types can now be passed into Objective-C as opaque box objects. A couple of reviews are currently running which tweak this bridging, exposing Optionals and NSValue/NSNumber-compatible types in more natural ways. These are all Good Things. I&#39;d like to look ahead and sketch out a way this feature could evolve further. This will not be detailed, and much or all of it may be out of scope for Phase 1.<br>&gt; <br>&gt; <br>&gt; Firstly, I think we could make boxed value types much more usable from Objective-C:<br>&gt; <br>&gt; 1. We could bridge selector calls to equivalent Swift methods, where those methods are Objective-C-compatible (other than being on a value type). This could actually be done dynamically if enough metadata is available.<br>&gt; <br>&gt; 2. We could generate a separate subclass of our box class for each bridged Swift type. This could actually *still* be done dynamically, I believe.<br>&gt; <br>&gt; 3. We could permit value types to conform to @objc protocols. This would open up several nice features to us; perhaps most importantly, a value type could conform to NSCoding and thereby participate in Foundation&#39;s serialization mechanisms. I suspect that at this point, the box subclasses would have to become &quot;real&quot;, i.e., registered at load time. (Perhaps they&#39;re only greedily registered if they have an explicit @objc?)<br>&gt; <br>&gt; 4. We could explicitly declare the bridged methods, properties, and conformances in the generated -Swift.h file, thereby making Swift value types directly available to Objective-C, where they can be allocated, accessed, and manipulated in boxed form.<br>&gt; <br>&gt; <br>&gt; Secondly—and separately, but relatedly—I believe a few simple changes could liberalize the @objc-compatibility rules, permitting many more members to be exposed to Objective-C:<br>&gt; <br>&gt; 1. We could run &quot;omit needless words&quot; in reverse when exposing Swift methods to Objective-C. This would prevent overloads from clashing in Objective-C, and would also have the bonus feature of producing more idiomatic Objective-C interfaces. (Incidentally, is a change considered source-breaking if it breaks Objective-C code, not Swift code?)<br>&gt; <br>&gt; 2. We could grant access to members using Swift-only type features by allowing the Objective-C versions to have looser types than the Swift versions, and dynamically enforcing the missing constraints instead. For instance, a member with a complicated `where` clause might omit the clause in its Objective-C declaration, but enforce it with a dynamic test.<br>&gt; <br>&gt; 3. I suspect it might be possible to expose generic types to Objective-C with some custom class methods. For instance, a Swift type with `Key` and `Value` type parameters might have `+classWithKey:(Class)keyClass value:(Class)valueClass` and +`allocWithKey:(Class)keyClass value:(Class)valueClass` methods on it.<br>&gt; <br>&gt; <br>&gt; Are these potential features of interest? If so, to what extent do they affect binary compatibility? On the one hand, they are extensions, adding transparency to things which are currently opaque. But on the other hand, they will presumably involve generating type metadata.<br></p><p>Yeah, this is definitely a direction that at least I am interested in. Letting value types conform to @objc protocols and have @objc methods would be especially empowering for Cocoa APIs. There are some subtleties—many ObjC protocols are *intended* to be class-constrained, particularly delegate protocols, and these protocols also tend to be used as weak references and other concepts that only really make sense for classes. Your point (4) also raises a question of whether Swift value types ought to be exposed to ObjC in their boxed or unboxed forms; it seems to me that there are many structs that you&#39;d want to export back to C or ObjC as plain structs and not boxed objects. We&#39;re also still researching the backward compatibility ramifications of changing the bridging model. While at face value, these ought to be additive changes, since we&#39;re turning purportedly opaque ObjC objects into meaningful ones, and relaxing generic constraints, the fact of the matter is people can and do rely on implementation details that are supposed to be private and subject to change. I&#39;m hopeful we can explore this model going forward, though.<br></p><p>-Joe<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
