<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>March  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; What is your evaluation of the proposal?<br></p><p>I am in favor of the proposal. However the “Detailed design” section could use some more clarifications:<br></p><p>1) Eg are abstract let’s allowed?<br></p><p>abstract let: String<br></p><p>2) what about abstract class and static methods?<br></p><p>3) should it be possible to import existing ObjC classes which are effectively abstract classes as true abstract classes? Eg:<br></p><p>- add an attribute on the ObjC side which would make it possible to mark classes like NSObject, NSResponder, NSGestureRecognizer, etc as abstract classes. This attribute would have no semantic significance in ObjC.<br></p><p>- those classes would come across into Swift as “abstract class”<br></p><p>This would make it possible to mark classes in the OS frameworks which are effectively abstract classes as such. This would be another stepping stone towards making the use of the existing Cocoa APIs more Swift-like, safer and less error-prone while preserving binary backward-compatibility to the existing ObjC implementation.<br></p><p>4) how will abstract classes which are marked with the @objc attribute or which derive directly or indirectly from NSObject be treated from the ObjC-side?<br></p><p>@objc abstract class Foo {<br>}<br></p><p>how does the ObjC side look? Would this be exported as just a regular ObjC class? Would it be marked with an attribute as mentioned in the previous bullet point?<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p><br>Yes, in fact Swift is hit harder by the lack of abstract classes compared to other languages which have support for abstract classes. The reason why abstract classes make especially sense for Swift is because of:<br></p><p>1) exhaustive switch-case checks for enum values<br></p><p>2) type-based separation of nullable and non-nullable values<br></p><p>It is often nontrivial and may in fact sometimes be impossible to provide a compilable and type correct null-implementation of a method that should be an abstract method but which can not be marked abstract because of the existing lack of abstract classes in Swift.<br></p><p>In the case of (1) a workaround may be to introduced by adding an extra enum case which only exists to enable us to provide a compile-able null-implementation. But by adding the extra case combined with the exhaustiveness check that Swift does for switch-case blocks, we end up spilling an implementation detail into the API of our class which should actually be kept private. Consider the following example class hierarchy which is used by a media app to describe different types of media:<br></p><p>enum MediaType {<br> case Photo<br> case LivePhoto<br> case Video<br>}<br></p><p><br>class MediaItem {<br></p><p> var title: String = “”<br> var type: MediaType = ???<br>}<br></p><p>class PhotoItem : MediaItem {<br></p><p> …<br>}<br></p><p><br>class VideoItem : MediaItem {<br></p><p> …<br>}<br></p><p>How are we going to implement MediaItem.type without abstract methods? We are either forced to introduce a special enum case just to make the code compilable or we are forced to return one of the existing enum cases which is conceptually wrong - the media item is an abstract, unbiased representation of a media item. It is neither a photo, live photo nor a video. If we introduce an extra enum case then every caller of the MediaItem.type property which does a switch-case over the return value will have to handle this extra case.<br></p><p>Let’s revisit the example from the proposal and lets change the property’s type to NSURL to see the problem with (2):<br></p><p>var url : NSURL {<br></p><p>  assert(false,&quot;Must be overridden”)<br>  return NSURL(fileURLWithPath: “/ignore/this”)<br>}<br></p><p>We are somewhat “lucky” in this case that we can return a nonsensical URL. It’s bad enough that we have to do this (write nonsensical code just to work around a missing language feature). But things would be even worse if there is no simple initializer available for the struct or object that we want to return. We may be forced to change the type of the property to an optional so that we can return nil instead of a concrete value. This however would change the semantics of the API and is not acceptable in every case.<br></p><p><br>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. Swift supports classes. Abstract classes are an established and simple way to describe a partially implemented class and no better solution has been presented on this mailing list that would improve on the concept of abstract classes while not adding additional burden, complexity and potential confusion for the language user.<br></p><p>One recurring suggestion has been to use protocols as a replacement for abstract classes and to extend them with eg support for state so that they can be used as a replacement for abstract classes. None of the presented protocol-based solutions have been convincing.<br></p><p>Abstract classes support a number of important properties:<br></p><p>- they can be derived from concrete classes<br>- they can be derived from other abstract classes<br>- they support inheritance<br>- they support interface<br>- they support implementation<br>- they support state<br></p><p>Protocols, as they stand today in Swift support:<br></p><p>- inheritance<br>- interface<br>- implementation<br></p><p>but they can not be derived from classes nor do they support state. Additionally, Swift protocols have a number of design problems and are already a major source of confusion for language users. Eg the discrepancy in dispatch behavior between methods defined in the protocol proper and a protocol extension has been cited numerous times as a very confusing and surprising aspect of Swift protocols. A number of other examples of problems can be found in the thread &quot;[Completing Generics] Completing protocol	extension diagnostics”.<br></p><p>Finally, adding state to protocols. Once we add state to protocols, we have moved protocols so close to the semantics of classes that we have effectively turned them into a second kind of class. Protocols are already confusing enough as they are today since they already cover a number of different aspects and we should not end up in a situation where protocols will be turned into a kitchen-sink that is forced to suck up everyone’s personal favorite language feature.<br></p><p><br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Compares well to Java and C++.<br></p><p><br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p><br>I’ve read the proposal and the related discussion thread. I’ve been using languages with and without abstract classes.<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>March  4, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 4 mars 2016 à 05:26, Dietmar Planitzer via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; I am in favor of the proposal. However the “Detailed design” section could use some more clarifications:<br>&gt; <br>&gt; 1) Eg are abstract let’s allowed?<br>&gt; <br>&gt; abstract let: String<br>	Yes, as they are for var.<br>&gt; <br>&gt; 2) what about abstract class and static methods?<br>	static are not part of inheritance..then there is not abstract static method.<br>&gt; <br>&gt; 3) should it be possible to import existing ObjC classes which are effectively abstract classes as true abstract classes? Eg:<br>	No, because we should not modify behavior of ObjC language when importing into Swift.<br>&gt; <br>&gt; 4) how will abstract classes which are marked with the @objc attribute or which derive directly or indirectly from NSObject be treated from the ObjC-side?<br>&gt; <br>&gt; @objc abstract class Foo {<br>&gt; }<br>	I suggest that abstract is a Swift-only keyword…then @objc is not allowed to abstract class.<br></p><p>&gt; <br>&gt; how does the ObjC side look? Would this be exported as just a regular ObjC class? Would it be marked with an attribute as mentioned in the previous bullet point?<br>	Abstract classes are not exported to ObjC.<br></p><p>	Regards,<br></p><p>David<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/1e1d8140/attachment.p7s&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  4, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; var url : NSURL {<br>&gt; <br>&gt;  assert(false,&quot;Must be overridden”)<br>&gt;  return NSURL(fileURLWithPath: “/ignore/this”)<br>&gt; }<br></p><p>For what it&#39;s worth, using `fatalError()` or `preconditionFailure()` will allow you to write a version of this with no return statement, because they are annotated with `@noreturn`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  4, 2016 at 10:00:00am</p></header><div class="content"><p>So, having considered this for a while, although I was initially in favour of it, as my background is largely in Java where I used class hierarchies a lot, some work I’ve been doing in Swift that has actually helped me to appreciate protocols and their capabilities a lot more.<br></p><p>I think with this in mind I’m actually now leaning more towards support for mixins plus some kind of implementing type only visibility. Mixins would be a new category of protocol that can include stored properties and overridable/extendable implementation details; my reason for preferring these is that they could be used with structs as well as classes, though I would actually prefer a different name (in fact I’d prefer to think of them as abstract types that are neither a struct or class… yet). Inheriting type only visibility is of course useful for providing partial implementations that a type can/should use, without exposing it as a callable method; I really dislike the idea of using precondition failures or other errors to indicate methods that should not be called directly, as it’s hacky at best, so I think the visibility restriction would provide a much better alternative.<br></p><p><br>Someone asked in this discussion whether classes are second-class citizens in Swift, and thinking about it some more I kind of think that they are; after a period of adjustment I now use structs for almost everything. I only use classes where a common reference is absolutely necessary, and also for nested types. Nesting and polymorphism can actually both be replaced by type-erased wrappers, though for nesting this may be more work than it’s worth if you’re trying to nest a private type, but it does mean that classes are actually a lot less important in Swift than other languages.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  9, 2016 at 03:00:00pm</p></header><div class="content"><p>On Mar 4, 2016, at 5:42 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Someone asked in this discussion whether classes are second-class citizens in Swift, and thinking about it some more I kind of think that they are; after a period of adjustment I now use structs for almost everything. I only use classes where a common reference is absolutely necessary, and also for nested types.<br></p><p>It seems to me that you are using classes and structs in exactly the right way. However, I don&#39;t think your judicious use of classes is necessarily an argument that &quot;classes are second-class citizens in Swift&quot;.<br></p><p>Sometimes classes are the right tool for the job. Sometimes structs or enums are.<br></p><p>What I love about Swift is that it&#39;s often much easier to use the right tool for the right job than other languages. However, if classes are relegated to some sort of demoted status, over time, that would no longer be the case.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 12:35 PM, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mar 4, 2016, at 5:42 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Someone asked in this discussion whether classes are second-class citizens in Swift, and thinking about it some more I kind of think that they are; after a period of adjustment I now use structs for almost everything. I only use classes where a common reference is absolutely necessary, and also for nested types.<br>&gt; <br>&gt; It seems to me that you are using classes and structs in exactly the right way. However, I don&#39;t think your judicious use of classes is necessarily an argument that &quot;classes are second-class citizens in Swift&quot;.<br>&gt; <br>&gt; Sometimes classes are the right tool for the job. Sometimes structs or enums are.<br>&gt; <br>&gt; What I love about Swift is that it&#39;s often much easier to use the right tool for the right job than other languages. However, if classes are relegated to some sort of demoted status, over time, that would no longer be the case.<br></p><p>+1.  Swift loves OOP as well as POP (not to mention FP).  They are both complementary techniques which are great at solving certain kinds of problems.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 8:46 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 9, 2016, at 12:35 PM, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mar 4, 2016, at 5:42 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Someone asked in this discussion whether classes are second-class citizens in Swift, and thinking about it some more I kind of think that they are; after a period of adjustment I now use structs for almost everything. I only use classes where a common reference is absolutely necessary, and also for nested types.<br>&gt;&gt; <br>&gt;&gt; It seems to me that you are using classes and structs in exactly the right way. However, I don&#39;t think your judicious use of classes is necessarily an argument that &quot;classes are second-class citizens in Swift&quot;.<br>&gt;&gt; <br>&gt;&gt; Sometimes classes are the right tool for the job. Sometimes structs or enums are.<br>&gt;&gt; <br>&gt;&gt; What I love about Swift is that it&#39;s often much easier to use the right tool for the right job than other languages. However, if classes are relegated to some sort of demoted status, over time, that would no longer be the case.<br>&gt; <br>&gt; +1.  Swift loves OOP as well as POP (not to mention FP).  They are both complementary techniques which are great at solving certain kinds of problems.<br>&gt; <br>&gt; -Chris<br></p><p>Swift is the Hannah Montana of programming languages.<br>https://www.youtube.com/watch?v=uVjRe8QXFHY &lt;https://www.youtube.com/watch?v=uVjRe8QXFHY&gt;<br></p><p>-- E, a mommy<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/789116a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 10, 2016 at 03:00:00pm</p></header><div class="content"><p>At least it isn&#39;t the Miley Cyrus:<br></p><p>“Miley Cyrus - Wrecking Ball (Explicit Video)”<br></p><p>  -- Howard.<br></p><p>On 10 March 2016 at 14:50, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 9, 2016, at 8:46 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Mar 9, 2016, at 12:35 PM, Evan Maloney via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Mar 4, 2016, at 5:42 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Someone asked in this discussion whether classes are second-class citizens<br>&gt; in Swift, and thinking about it some more I kind of think that they are;<br>&gt; after a period of adjustment I now use structs for almost everything. I<br>&gt; only use classes where a common reference is absolutely necessary, and also<br>&gt; for nested types.<br>&gt;<br>&gt;<br>&gt; It seems to me that you are using classes and structs in exactly the right<br>&gt; way. However, I don&#39;t think your judicious use of classes is necessarily an<br>&gt; argument that &quot;classes are second-class citizens in Swift&quot;.<br>&gt;<br>&gt; Sometimes classes are the right tool for the job. Sometimes structs or<br>&gt; enums are.<br>&gt;<br>&gt; What I love about Swift is that it&#39;s often much easier to use the right<br>&gt; tool for the right job than other languages. However, if classes are<br>&gt; relegated to some sort of demoted status, over time, that would no longer<br>&gt; be the case.<br>&gt;<br>&gt;<br>&gt; +1.  Swift loves OOP as well as POP (not to mention FP).  They are both<br>&gt; complementary techniques which are great at solving certain kinds of<br>&gt; problems.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Swift is the Hannah Montana of programming languages.<br>&gt; https://www.youtube.com/watch?v=uVjRe8QXFHY<br>&gt;<br>&gt; -- E, a mommy<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/b9ee591b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Review] SE-0026 Abstract classes and methods</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 9 Mar 2016, at 20:35, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; <br>&gt; On Mar 4, 2016, at 5:42 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Someone asked in this discussion whether classes are second-class citizens in Swift, and thinking about it some more I kind of think that they are; after a period of adjustment I now use structs for almost everything. I only use classes where a common reference is absolutely necessary, and also for nested types.<br>&gt; <br>&gt; It seems to me that you are using classes and structs in exactly the right way. However, I don&#39;t think your judicious use of classes is necessarily an argument that &quot;classes are second-class citizens in Swift&quot;.<br>&gt; <br>&gt; Sometimes classes are the right tool for the job. Sometimes structs or enums are.<br>&gt; <br>&gt; What I love about Swift is that it&#39;s often much easier to use the right tool for the right job than other languages. However, if classes are relegated to some sort of demoted status, over time, that would no longer be the case.<br></p><p>Well, I may also be on the verge of changing my mind once again; I recently implemented an AnyFoo&lt;T&gt; type, however the boxing is a nightmare without support for abstract classes. Assuming I’m still doing it the right way, boxing a value for type erasure requires a base class FooBoxBase&lt;T&gt;, and a sub-class FooBox&lt;F:Foo&gt; (as FooBox is also of type FooBoxBase&lt;T&gt;, you don’t need to know what type F is within AnyFoo&lt;T&gt;). However, the type I’m boxing has a lot of methods, which means a huge amount of boiler-plate in FooBoxBase that just contains fatal errors, that in turn have to be overridden in FooBox.<br></p><p>With an abstract class this boiler-plate not only wouldn’t be necessary, but would also avoid mistakes such as my forgetting to override a method in FooBox (resulting in the fatal error super method being called instead).<br></p><p>Anyway, while I’m generally a convert to doing everything via protocols first, I think there are still cases where abstract is the best way, as mixins  and similar can&#39;t solve the boxing problem either. Of course we could get some syntactic sugar to make boxing easier (since it’s a very useful thing to do) but there may be similar cases where it just isn’t possible to do cleanly without proper abstract support.<br></p><p>P.S- I reserve the right to change my mind again in future =)<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
