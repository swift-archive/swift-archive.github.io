<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5bef3c5aff006b706278c43654a8ed7?s=50"></div><header><strong>Optimising Set&lt;String&gt; comparisons</strong> from <string>Nial Giacomelli</string> &lt;measuredweighed at gmail.com&gt;<p>November 13, 2016 at 07:00:00pm</p></header><div class="content"><p>Using Swift 3 I have a function that&#39;s called extremely frequently and is<br>appearing regularly in Profiler runs. The function takes two Set&lt;String&gt;<br>instances and simply attempts to determine whether all items from Set A are<br>present in Set B (it&#39;s important to note that Set B may well contain<br>additional items).<br></p><p>I&#39;ve attempted to approach the problem in two ways:<br></p><p>let diff = a.subtracting(b)<br>guard diff.count == 0 else { return false }<br></p><p>And also by simply iterating over the contents of Set A, like so:<br></p><p>for item in a {<br>if !b.contains(item) {<br>return false<br>}<br>}<br></p><p>Both ultimately end up spending the majority of their time in<br>String._compareDeterministicUnicodeCollaton(String) -&gt; Int. Which makes<br>sense, given what I&#39;m doing - but ideally I&#39;d like to come up with a more<br>efficient way of performing the above check. Swift&#39;s String representation<br>is incredibly robust, but for my needs the strings could be adequately<br>represented in ASCII encoding. I&#39;ve also considered storing and comparing<br>the hashValue of the strings, to speed up comparisons...<br></p><p>Hopefully this is an acceptable question for this mailing list. I&#39;m aware<br>that this may not be a Swift-specific question and could well be solved<br>with a more efficient data structure or approach, but I&#39;d really appreciate<br>some input from more experienced Swift developers :-)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161113/6dd19c1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optimising Set&lt;String&gt; comparisons</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Nov 13, 2016, at 1:58 PM, Nial Giacomelli via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Using Swift 3 I have a function that&#39;s called extremely frequently and is appearing regularly in Profiler runs. The function takes two Set&lt;String&gt; instances and simply attempts to determine whether all items from Set A are present in Set B (it&#39;s important to note that Set B may well contain additional items).<br>&gt; <br>&gt; I&#39;ve attempted to approach the problem in two ways:<br>&gt; <br>&gt; let diff = a.subtracting(b)<br>&gt; guard diff.count == 0 else { return false }<br>&gt; <br>&gt; And also by simply iterating over the contents of Set A, like so:<br>&gt; <br>&gt; for item in a {<br>&gt; 	if !b.contains(item) {<br>&gt; 		return false<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Both ultimately end up spending the majority of their time in String._compareDeterministicUnicodeCollaton(String) -&gt; Int. Which makes sense, given what I&#39;m doing - but ideally I&#39;d like to come up with a more efficient way of performing the above check. Swift&#39;s String representation is incredibly robust, but for my needs the strings could be adequately represented in ASCII encoding. I&#39;ve also considered storing and comparing the hashValue of the strings, to speed up comparisons...<br>&gt; <br>&gt; Hopefully this is an acceptable question for this mailing list. I&#39;m aware that this may not be a Swift-specific question and could well be solved with a more efficient data structure or approach, but I&#39;d really appreciate some input from more experienced Swift developers :-)<br></p><p>How often do the sets change? And where do you get them from? I’m wondering, if there’s enough time between when you get the strings and when you need to know if setA is a subset of setB, could you somehow compute the answer asynchronously in a background thread or something? Strictly speaking it wouldn&#39;t be any less work, but if you can move it to where you’re waiting for user input or something you’ll probably get your answer sooner.<br></p><p>Regarding how to get the answer using less work in the first place, I think you’re doing a tiny bit of extra work — just some allocation overhead, really — by calculating the set difference and checking that its count == 0, rather than just checking if a.isSubset(of: b). Beyond that, I’m not really sure… You might be able to do something with the strings’ hash values. I mean, I don’t know if they really “work like that” (I’m quite foggy on how hash values are calculated and exactly what they’re suitable for… this might be a horrible idea), but if they do, comparing hash values (Ints) will definitely be faster than comparing Strings. I did some quick’n’dirty testing on my machine with some code very much like:<br>let setA: Set&lt;String&gt; = [&quot;some&quot;, &quot;set&quot;, &quot;of&quot;, &quot;random&quot;, &quot;strings&quot;]<br>let setB: Set&lt;String&gt; = [&quot;some&quot;, &quot;other&quot;, &quot;set&quot;, &quot;of&quot;, &quot;strings&quot;]<br>let hashedA = Set(setA.map{$0.hashValue})<br>let hashedB = Set(setB.map{$0.hashValue})<br>setA.isSubset(of: setB)<br>hashedA.isSubset(of: hashedB)<br></p><p>The actual execution of hashedA.isSubset(of: hashedB) seems to be very roughly 2x faster than setA.isSubset(of: setB). However, if you include the overhead of calculating them, using hash values drops to about 5x slower. So unless you’d be reusing the hashed values a lot or something, I think you’re already doing about the least amount of work I can think of.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161113/b5df0cfa/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
