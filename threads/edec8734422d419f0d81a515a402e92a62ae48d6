<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>January 18, 2016 at 08:00:00pm</p></header><div class="content"><p>I have just pushed a branch to the SwiftAndroid repo that is at the stage of correctly compiling the swift toolchain and stdlib objects for android-armv7 and macosx-x86_64 (as verified using nm from the different toolchains): https://github.com/SwiftAndroid/swift/tree/osx-crosscompile &lt;https://github.com/SwiftAndroid/swift/tree/osx-crosscompile&gt;. The problem is it fails at the linker stage.<br></p><p>Basically the OSX linker doesn&#39;t understand the “—sysroot” option (See AddSwift.cmake:59). Up until that point though (throughout the compiling stage), we need that option because otherwise the Android components attempt to use OSX /usr/include, which throws all sorts of errors because of wrong architecture etc. Why it fails to compile when I remove the “—sysroot” option, but also fails _with_ it in the link stage will probably be key to fixing this. Again, it seems that what we really need to do is use the Android linker, not the Xcode one.<br></p><p>I&#39;m going to try figure out how to do that tomorrow but not confident I’ll get far given my limited experience with this.. This work may also be of interest to the Raspberry Pi / BeagleBoard folks, would also love to hear some opinions about how to solve the CMAKE_SYSTEM_NAME problem, that will also affect cross-compilation for those uses. In any case, any hints or collaborators would be most welcome.<br></p><p>Geordie<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160118/edec48d6/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 195 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160118/edec48d6/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4226542ea69d5b28efdf689104a49c6c?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Tom Gall</string> &lt;tom.gall at linaro.org&gt;<p>January 18, 2016 at 03:00:00pm</p></header><div class="content"><p>Cool!<br></p><p>I was just starting a similar exercise but using x86-64 linux as the<br>host since I&#39;ve managed to get swift building and running on my<br>arm-linux box.<br></p><p>Cheers!<br></p><p>On Mon, Jan 18, 2016 at 1:03 PM, Geordie Jay via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; I have just pushed a branch to the SwiftAndroid repo that is at the stage of<br>&gt; correctly compiling the swift toolchain and stdlib objects for android-armv7<br>&gt; and macosx-x86_64 (as verified using nm from the different toolchains):<br>&gt; https://github.com/SwiftAndroid/swift/tree/osx-crosscompile. The problem is<br>&gt; it fails at the linker stage.<br>&gt;<br>&gt; Basically the OSX linker doesn&#39;t understand the “—sysroot” option (See<br>&gt; AddSwift.cmake:59). Up until that point though (throughout the compiling<br>&gt; stage), we need that option because otherwise the Android components attempt<br>&gt; to use OSX /usr/include, which throws all sorts of errors because of wrong<br>&gt; architecture etc. Why it fails to compile when I remove the “—sysroot”<br>&gt; option, but also fails _with_ it in the link stage will probably be key to<br>&gt; fixing this. Again, it seems that what we really need to do is use the<br>&gt; Android linker, not the Xcode one.<br>&gt;<br>&gt; I&#39;m going to try figure out how to do that tomorrow but not confident I’ll<br>&gt; get far given my limited experience with this.. This work may also be of<br>&gt; interest to the Raspberry Pi / BeagleBoard folks, would also love to hear<br>&gt; some opinions about how to solve the CMAKE_SYSTEM_NAME problem, that will<br>&gt; also affect cross-compilation for those uses. In any case, any hints or<br>&gt; collaborators would be most welcome.<br>&gt;<br>&gt; Geordie<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p><br></p><p>-- <br>Regards,<br>Tom<br></p><p>&quot;Where&#39;s the kaboom!? There was supposed to be an earth-shattering<br>kaboom!&quot; Marvin Martian<br>Director, Linaro Mobile Group<br>Tech Lead, GPGPU<br>Linaro.org │ Open source software for ARM SoCs<br>irc: tgall_foo | skype : tom_gall<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>January 18, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;m in discussions about this with some others over at<br>https://github.com/SwiftAndroid/swift/issues/13<br></p><p>Basically the Swift build process as is isn&#39;t made for arbitrary<br>cross-compiling. The iOS cross-compiling from OSX relies on some happy<br>accidents, e.g. that they&#39;re all Apple platforms, and isn&#39;t robust. So<br>we&#39;re discussing some alternatives that would eventually also benefit your<br>porting effort.<br></p><p>Out of interest, have you found a version of clang that compiles from your<br>host machine to an arm-Linux target? Or delved into the source in order to<br>make your own? I&#39;d be interested in cross-compiling for Raspberry Pi too<br>but haven&#39;t looked into toolchains yet.<br></p><p>Geordie<br>Tom Gall &lt;tom.gall at linaro.org&gt; schrieb am Mo., 18. Jan. 2016 um 22:07:<br></p><p>&gt; Cool!<br>&gt;<br>&gt; I was just starting a similar exercise but using x86-64 linux as the<br>&gt; host since I&#39;ve managed to get swift building and running on my<br>&gt; arm-linux box.<br>&gt;<br>&gt; Cheers!<br>&gt;<br>&gt; On Mon, Jan 18, 2016 at 1:03 PM, Geordie Jay via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; I have just pushed a branch to the SwiftAndroid repo that is at the<br>&gt; stage of<br>&gt; &gt; correctly compiling the swift toolchain and stdlib objects for<br>&gt; android-armv7<br>&gt; &gt; and macosx-x86_64 (as verified using nm from the different toolchains):<br>&gt; &gt; https://github.com/SwiftAndroid/swift/tree/osx-crosscompile. The<br>&gt; problem is<br>&gt; &gt; it fails at the linker stage.<br>&gt; &gt;<br>&gt; &gt; Basically the OSX linker doesn&#39;t understand the “—sysroot” option (See<br>&gt; &gt; AddSwift.cmake:59). Up until that point though (throughout the compiling<br>&gt; &gt; stage), we need that option because otherwise the Android components<br>&gt; attempt<br>&gt; &gt; to use OSX /usr/include, which throws all sorts of errors because of<br>&gt; wrong<br>&gt; &gt; architecture etc. Why it fails to compile when I remove the “—sysroot”<br>&gt; &gt; option, but also fails _with_ it in the link stage will probably be key<br>&gt; to<br>&gt; &gt; fixing this. Again, it seems that what we really need to do is use the<br>&gt; &gt; Android linker, not the Xcode one.<br>&gt; &gt;<br>&gt; &gt; I&#39;m going to try figure out how to do that tomorrow but not confident<br>&gt; I’ll<br>&gt; &gt; get far given my limited experience with this.. This work may also be of<br>&gt; &gt; interest to the Raspberry Pi / BeagleBoard folks, would also love to hear<br>&gt; &gt; some opinions about how to solve the CMAKE_SYSTEM_NAME problem, that will<br>&gt; &gt; also affect cross-compilation for those uses. In any case, any hints or<br>&gt; &gt; collaborators would be most welcome.<br>&gt; &gt;<br>&gt; &gt; Geordie<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Regards,<br>&gt; Tom<br>&gt;<br>&gt; &quot;Where&#39;s the kaboom!? There was supposed to be an earth-shattering<br>&gt; kaboom!&quot; Marvin Martian<br>&gt; Director, Linaro Mobile Group<br>&gt; Tech Lead, GPGPU<br>&gt; Linaro.org │ Open source software for ARM SoCs<br>&gt; irc: tgall_foo | skype : tom_gall<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160118/c50ab13c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 18, 2016 at 04:00:00pm</p></header><div class="content"><p>On Mon, Jan 18, 2016 at 2:44 PM, Geordie Jay via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; I&#39;m in discussions about this with some others over at<br>&gt; https://github.com/SwiftAndroid/swift/issues/13<br>&gt;<br>&gt; Basically the Swift build process as is isn&#39;t made for arbitrary<br>&gt; cross-compiling. The iOS cross-compiling from OSX relies on some happy<br>&gt; accidents, e.g. that they&#39;re all Apple platforms, and isn&#39;t robust. So we&#39;re<br>&gt; discussing some alternatives that would eventually also benefit your porting<br>&gt; effort.<br></p><p>Unfortunately CMake only supports one C compiler and one linker in one<br>CMake invocation.  The &quot;CMake way&quot; for cross-compilation is to invoke<br>CMake once for every part of the build that requires a different set<br>of tools.  Thus, for Swift, we would need to invoke CMake once for<br>building the tools running on the host (the swiftc running on OS X)<br>with the host toolchain (clang from Xcode), and once for the Android<br>target with the Android toolchain and the just-built Swift to build<br>the standard library.<br></p><p>The disadvantage to this approach is that there are many CMake<br>invocations, and many ninja invocations.  This is bad for the same<br>reasons why recursive make is bad. [1]  So we would like to keep the<br>current scheme for as many targets as possible (OS X native, OS X to<br>iOS cross-compilation, Linux native etc.), and use the multi-CMake<br>scheme only where strictly required.<br></p><p>[1] http://aegis.sourceforge.net/auug97.pdf<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>January 19, 2016 at 01:00:00am</p></header><div class="content"><p>Hi Dimitri, thanks for the enlightening read. I&#39;ll keep those ideas in mind.<br></p><p>By &quot;Linux native&quot; do you mean compiling eg. Linux arm from Linux x86_64<br>with the current scheme, and only running multiple invocations when<br>compiling for mutually ABI-incompatible platforms (eg. osx-&gt;android)?<br></p><p>As it stands that exact scenario seems to build ok with the current method,<br>I &quot;just&quot; got stuck at the linking phase. I did have the impression I was<br>fighting the system the whole time though, and it was pretty hard to keep a<br>mental model of what was going on.<br></p><p>My concern is that maintaining the two different schemes will be even more<br>confusing than maintaining one convoluted single-invocation scheme. Would<br>like to hear some more opinions about this.<br></p><p>Geordie<br>Dmitri Gribenko &lt;gribozavr at gmail.com&gt; schrieb am Di., 19. Jan. 2016 um<br>01:47:<br></p><p>&gt; On Mon, Jan 18, 2016 at 2:44 PM, Geordie Jay via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; I&#39;m in discussions about this with some others over at<br>&gt; &gt; https://github.com/SwiftAndroid/swift/issues/13<br>&gt; &gt;<br>&gt; &gt; Basically the Swift build process as is isn&#39;t made for arbitrary<br>&gt; &gt; cross-compiling. The iOS cross-compiling from OSX relies on some happy<br>&gt; &gt; accidents, e.g. that they&#39;re all Apple platforms, and isn&#39;t robust. So<br>&gt; we&#39;re<br>&gt; &gt; discussing some alternatives that would eventually also benefit your<br>&gt; porting<br>&gt; &gt; effort.<br>&gt;<br>&gt; Unfortunately CMake only supports one C compiler and one linker in one<br>&gt; CMake invocation.  The &quot;CMake way&quot; for cross-compilation is to invoke<br>&gt; CMake once for every part of the build that requires a different set<br>&gt; of tools.  Thus, for Swift, we would need to invoke CMake once for<br>&gt; building the tools running on the host (the swiftc running on OS X)<br>&gt; with the host toolchain (clang from Xcode), and once for the Android<br>&gt; target with the Android toolchain and the just-built Swift to build<br>&gt; the standard library.<br>&gt;<br>&gt; The disadvantage to this approach is that there are many CMake<br>&gt; invocations, and many ninja invocations.  This is bad for the same<br>&gt; reasons why recursive make is bad. [1]  So we would like to keep the<br>&gt; current scheme for as many targets as possible (OS X native, OS X to<br>&gt; iOS cross-compilation, Linux native etc.), and use the multi-CMake<br>&gt; scheme only where strictly required.<br>&gt;<br>&gt; [1] http://aegis.sourceforge.net/auug97.pdf<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160119/f4102b32/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 18, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, Jan 18, 2016 at 5:46 PM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; Hi Dimitri, thanks for the enlightening read. I&#39;ll keep those ideas in mind.<br>&gt;<br>&gt; By &quot;Linux native&quot; do you mean compiling eg. Linux arm from Linux x86_64 with<br>&gt; the current scheme, and only running multiple invocations when compiling for<br>&gt; mutually ABI-incompatible platforms (eg. osx-&gt;android)?<br></p><p>I meant building for the platform itself.  Compiling Linux arm from<br>Linux x86_64 would likely require the two-step approach.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>January 19, 2016 at 10:00:00am</p></header><div class="content"><p>Ok I&#39;m confused as to what you mean now. I can&#39;t imagine how it&#39;d make<br>sense to run CMake multiple times to build from one host for its own<br>platform (save the recursive make approach, which in itself never crossed<br>our mind AFIK, but you mentioned this is a separate issue anyway).<br></p><p>The suggestion was to run CMake once per compilation target, being invoked<br>from build-script(-impl, for now). That would give us the benefit of<br>CMAKE_SYSTEM_NAME providing the target system (as opposed to the host, as<br>is now the case), with CMAKE_HOST_SYSTEM_NAME available when we need it.<br>This would lead to splitting out the CMake directives in a more natural<br>way. I also understand (maybe incorrectly) that this would keep in-code<br>definitions like #if __APPLE__ and objc interop &quot;automatically&quot; valid<br>without the need for hacks or further intervention from further CMake<br>patches.<br></p><p>Based on what you wrote I understood that the above setup may be<br>undesirable for OS X-&gt;iOS compilation. Now that I&#39;ve slept on it I&#39;m<br>actually not sure why. Referring to the article you sent, each target&#39;s DAG<br>should be atomic and independent of one another (this may well be the point<br>where I&#39;m missing something). Also, the build output for each target is<br>kept independent, meaning it wouldn&#39;t need to be rescanned from foreign<br>targets&#39; CMake / ninja runs.<br></p><p>I&#39;m interested to hear your thoughts about this<br></p><p>Geordie<br>Dmitri Gribenko &lt;gribozavr at gmail.com&gt; schrieb am Di., 19. Jan. 2016 um<br>02:51:<br></p><p>&gt; On Mon, Jan 18, 2016 at 5:46 PM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; &gt; Hi Dimitri, thanks for the enlightening read. I&#39;ll keep those ideas in<br>&gt; mind.<br>&gt; &gt;<br>&gt; &gt; By &quot;Linux native&quot; do you mean compiling eg. Linux arm from Linux x86_64<br>&gt; with<br>&gt; &gt; the current scheme, and only running multiple invocations when compiling<br>&gt; for<br>&gt; &gt; mutually ABI-incompatible platforms (eg. osx-&gt;android)?<br>&gt;<br>&gt; I meant building for the platform itself.  Compiling Linux arm from<br>&gt; Linux x86_64 would likely require the two-step approach.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160119/113cdb58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 19, 2016 at 03:00:00am</p></header><div class="content"><p>On Tue, Jan 19, 2016 at 2:50 AM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; Ok I&#39;m confused as to what you mean now. I can&#39;t imagine how it&#39;d make sense<br>&gt; to run CMake multiple times to build from one host for its own platform<br></p><p>To build a Swift distribution, we need to build two pieces: the Swift<br>compiler and the standard library.<br></p><p>When cross-compiling, you can build two different kinds of compilers:<br>a compiler that runs on your host machine, or the compiler that runs<br>on the target.<br></p><p>To build the standard library, you need to use the Swift compiler that<br>runs on the host and a Clang that runs on the host, but both<br>configured to target your target platform.<br></p><p>Thus, if you want to cross-compile to Linux arm from OS X, you would<br>need to use two or three CMake invocations:<br></p><p>(1) to build a Swift compiler that runs on OS X,<br></p><p>(2) use (1) to build a standard library that runs on Linux arm,<br></p><p>(3) build a Swift compiler that runs on Linux arm.<br></p><p>There is a dependency edge between (1) and (2), but they are in<br>different CMake invocations.<br></p><p>When cross-compiling for iOS, tvOS and watchOS, there are many CMake<br>invocations of the second kind -- in fact, multiple for every platform<br>because of many slices.  And, even more, since those platforms use fat<br>libraries, there needs to be a step that creates them from separate<br>slices.<br></p><p>That&#39;s why I&#39;m comparing this to &quot;recursive make&quot;: if we use the CMake<br>approach to cross-compiling with multiple CMake invocations, since we<br>are building the compiler itself, we would be crating dependencies in<br>the graph that CMake does not know about, and we would require some<br>code to orchestrate the build.  Just like recursive make does in its<br>Makefiles.<br></p><p>Using build-script to orchestrate this build would be a natural<br>choice, but it would break many of the current workflows, where<br>developers rely on quickly iterating in one build directory, invoking<br>&#39;ninja check-swift&#39; directly to rebulid the compiler, all the<br>downstream dependencies, and run tests.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m still trying to grasp the fundamental difference in approaches here,<br>especially since you say there are multiple CMake runs already. More<br>importantly, I&#39;d like to fully understand what&#39;s important to keep the<br>same, or at least its desired outcome, which I&#39;m pretty sure is the (1)-(2)<br>cross-boundary dependency staying intact.<br></p><p>Is the difference that the cross-compilation dynamic targets in the current<br>paradigm are set up via CMake (rather than build-script)? Presumably this<br>leaves the the loop that builds the various targets &quot;unrolled&quot; and always<br>in CMake&#39;s output, instead of recreating the CMake files multiple times per<br>build-script run?<br></p><p>As to the workflow, what would stop devs from just having a global bash<br>alias to &quot;check-swift&quot; that invokes the build-script, achieving the same<br>effect?<br>Dmitri Gribenko &lt;gribozavr at gmail.com&gt; schrieb am Di., 19. Jan. 2016 um<br>12:09:<br></p><p>&gt; On Tue, Jan 19, 2016 at 2:50 AM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt; &gt; Ok I&#39;m confused as to what you mean now. I can&#39;t imagine how it&#39;d make<br>&gt; sense<br>&gt; &gt; to run CMake multiple times to build from one host for its own platform<br>&gt;<br>&gt; To build a Swift distribution, we need to build two pieces: the Swift<br>&gt; compiler and the standard library.<br>&gt;<br>&gt; When cross-compiling, you can build two different kinds of compilers:<br>&gt; a compiler that runs on your host machine, or the compiler that runs<br>&gt; on the target.<br>&gt;<br>&gt; To build the standard library, you need to use the Swift compiler that<br>&gt; runs on the host and a Clang that runs on the host, but both<br>&gt; configured to target your target platform.<br>&gt;<br>&gt; Thus, if you want to cross-compile to Linux arm from OS X, you would<br>&gt; need to use two or three CMake invocations:<br>&gt;<br>&gt; (1) to build a Swift compiler that runs on OS X,<br>&gt;<br>&gt; (2) use (1) to build a standard library that runs on Linux arm,<br>&gt;<br>&gt; (3) build a Swift compiler that runs on Linux arm.<br>&gt;<br>&gt; There is a dependency edge between (1) and (2), but they are in<br>&gt; different CMake invocations.<br>&gt;<br>&gt; When cross-compiling for iOS, tvOS and watchOS, there are many CMake<br>&gt; invocations of the second kind -- in fact, multiple for every platform<br>&gt; because of many slices.  And, even more, since those platforms use fat<br>&gt; libraries, there needs to be a step that creates them from separate<br>&gt; slices.<br>&gt;<br>&gt; That&#39;s why I&#39;m comparing this to &quot;recursive make&quot;: if we use the CMake<br>&gt; approach to cross-compiling with multiple CMake invocations, since we<br>&gt; are building the compiler itself, we would be crating dependencies in<br>&gt; the graph that CMake does not know about, and we would require some<br>&gt; code to orchestrate the build.  Just like recursive make does in its<br>&gt; Makefiles.<br>&gt;<br>&gt; Using build-script to orchestrate this build would be a natural<br>&gt; choice, but it would break many of the current workflows, where<br>&gt; developers rely on quickly iterating in one build directory, invoking<br>&gt; &#39;ninja check-swift&#39; directly to rebulid the compiler, all the<br>&gt; downstream dependencies, and run tests.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160119/7e5a6f57/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7f82643a80c536e1ddf188d21826fc08?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Tom Birch</string> &lt;froody at gmail.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>On Tue, Jan 19, 2016 at 3:09 AM Dmitri Gribenko via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; That&#39;s why I&#39;m comparing this to &quot;recursive make&quot;: if we use the CMake<br>&gt; approach to cross-compiling with multiple CMake invocations, since we<br>&gt; are building the compiler itself, we would be crating dependencies in<br>&gt; the graph that CMake does not know about, and we would require some<br>&gt; code to orchestrate the build.  Just like recursive make does in its<br>&gt; Makefiles.<br>&gt;<br>&gt; Using build-script to orchestrate this build would be a natural<br>&gt; choice, but it would break many of the current workflows, where<br>&gt; developers rely on quickly iterating in one build directory, invoking<br>&gt; &#39;ninja check-swift&#39; directly to rebulid the compiler, all the<br>&gt; downstream dependencies, and run tests.<br>&gt;<br></p><p>What do you propose then? As I understand it, there are roughly two options:<br></p><p>1) Split the build of swiftc and stdlib into two CMake invocations,<br>requiring a separate CMake configure step for each build type of the SDK.<br>2) Keep things as they are with a single CMake invocation, and wrap<br>invocations of the toolchain (either with custom CMake commands or shell<br>scripts) to call the right tool with the right flags for each build type of<br>the SDK.<br></p><p>I think (1) is more likely to result in a cleaner, more maintainable<br>buildsystem as more cross-compile targets are added, but as you mentioned,<br>may lead to longer build times and broken workflows. Maybe the dependencies<br>could be fixed by using ExternalProject_Add.<br></p><p>I think (2) will initially be easier, but will pollute the &quot;leaf&quot; CMake<br>functions/targets with target-specific details, as already seems to be<br>happening in AddSwift.cmake.<br></p><p>Is there another approach I&#39;m not considering? What is more likely to be<br>accepted into apple/swift master?<br></p><p>cheers,<br>Tom<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160120/0cd70334/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 20, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Jan 20, 2016 at 1:21 PM, Tom Birch &lt;froody at gmail.com&gt; wrote:<br>&gt; On Tue, Jan 19, 2016 at 3:09 AM Dmitri Gribenko via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; That&#39;s why I&#39;m comparing this to &quot;recursive make&quot;: if we use the CMake<br>&gt;&gt; approach to cross-compiling with multiple CMake invocations, since we<br>&gt;&gt; are building the compiler itself, we would be crating dependencies in<br>&gt;&gt; the graph that CMake does not know about, and we would require some<br>&gt;&gt; code to orchestrate the build.  Just like recursive make does in its<br>&gt;&gt; Makefiles.<br>&gt;&gt;<br>&gt;&gt; Using build-script to orchestrate this build would be a natural<br>&gt;&gt; choice, but it would break many of the current workflows, where<br>&gt;&gt; developers rely on quickly iterating in one build directory, invoking<br>&gt;&gt; &#39;ninja check-swift&#39; directly to rebulid the compiler, all the<br>&gt;&gt; downstream dependencies, and run tests.<br>&gt;<br>&gt;<br>&gt; What do you propose then? As I understand it, there are roughly two options:<br>&gt;<br>&gt; 1) Split the build of swiftc and stdlib into two CMake invocations,<br>&gt; requiring a separate CMake configure step for each build type of the SDK.<br>&gt; 2) Keep things as they are with a single CMake invocation, and wrap<br>&gt; invocations of the toolchain (either with custom CMake commands or shell<br>&gt; scripts) to call the right tool with the right flags for each build type of<br>&gt; the SDK.<br>&gt;<br>&gt; I think (1) is more likely to result in a cleaner, more maintainable<br>&gt; buildsystem as more cross-compile targets are added, but as you mentioned,<br>&gt; may lead to longer build times and broken workflows. Maybe the dependencies<br>&gt; could be fixed by using ExternalProject_Add.<br>&gt;<br>&gt; I think (2) will initially be easier, but will pollute the &quot;leaf&quot; CMake<br>&gt; functions/targets with target-specific details, as already seems to be<br>&gt; happening in AddSwift.cmake.<br>&gt;<br>&gt; Is there another approach I&#39;m not considering? What is more likely to be<br>&gt; accepted into apple/swift master?<br></p><p>I&#39;m proposing we do (1) for new cross-compilation targets (like OS X<br>to Linux, or Linux x86_64 to Linux arm), but keep the current scheme<br>for Darwin.<br></p><p>To keep existing workflows working, I would suggest that native builds<br>keep building the standard library in the same CMake invocation as the<br>compiler.<br></p><p>Optionally, cross-compiling builds can unconditionally invoke the<br>CMake build tool recursively for cross-compilation targets after the<br>compiler is built, to erase the difference between native builds and<br>cross-compiling.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7f82643a80c536e1ddf188d21826fc08?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Tom Birch</string> &lt;froody at gmail.com&gt;<p>January 21, 2016 at 07:00:00pm</p></header><div class="content"><p>Ok, thanks, I&#39;ll run with that. I<br>see SWIFT_NATIVE_(LLVM|CLANG|SWIFT)_TOOLS_PATH, is currently used/supported<br>anywhere? My current plan is to:<br>1) Build everything (llvm/clang, cmark, swift) for macosx-x86_64<br>2) Setup SWIFT_NATIVE_*_TOOLS_PATH to point to the respective dirs created<br>in (1)<br>3) Create a swift-android-armv7 build dir<br>4) Invoke CMake in swift-android-armv7 with vars from (2), plus a<br>Toolchain-android-armv7.cmake to set CMAKE_SYSTEM_NAME, CMAKE_SYSROOT, etc<br>for the android build<br></p><p>Ideally I&#39;d only build the stdlib and tests for android, skipping the tools<br>and and llvm/clang builds. Does this seem feasible? I know the runtime<br>depends on llvm headers, but I can either use the macosx-x86_64 llvm<br>headers, or do a partial headers-only install of llvm-android-armv7. Are<br>there any binaries/tools needed to be built for the target (i.e<br>android-armv7) in order to build stdlib? Anything else I should know/watch<br>out for?<br></p><p>cheers,<br>Tom<br></p><p>On Wed, Jan 20, 2016 at 1:43 PM Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Jan 20, 2016 at 1:21 PM, Tom Birch &lt;froody at gmail.com&gt; wrote:<br>&gt; &gt; On Tue, Jan 19, 2016 at 3:09 AM Dmitri Gribenko via swift-dev<br>&gt; &gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That&#39;s why I&#39;m comparing this to &quot;recursive make&quot;: if we use the CMake<br>&gt; &gt;&gt; approach to cross-compiling with multiple CMake invocations, since we<br>&gt; &gt;&gt; are building the compiler itself, we would be crating dependencies in<br>&gt; &gt;&gt; the graph that CMake does not know about, and we would require some<br>&gt; &gt;&gt; code to orchestrate the build.  Just like recursive make does in its<br>&gt; &gt;&gt; Makefiles.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Using build-script to orchestrate this build would be a natural<br>&gt; &gt;&gt; choice, but it would break many of the current workflows, where<br>&gt; &gt;&gt; developers rely on quickly iterating in one build directory, invoking<br>&gt; &gt;&gt; &#39;ninja check-swift&#39; directly to rebulid the compiler, all the<br>&gt; &gt;&gt; downstream dependencies, and run tests.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; What do you propose then? As I understand it, there are roughly two<br>&gt; options:<br>&gt; &gt;<br>&gt; &gt; 1) Split the build of swiftc and stdlib into two CMake invocations,<br>&gt; &gt; requiring a separate CMake configure step for each build type of the SDK.<br>&gt; &gt; 2) Keep things as they are with a single CMake invocation, and wrap<br>&gt; &gt; invocations of the toolchain (either with custom CMake commands or shell<br>&gt; &gt; scripts) to call the right tool with the right flags for each build type<br>&gt; of<br>&gt; &gt; the SDK.<br>&gt; &gt;<br>&gt; &gt; I think (1) is more likely to result in a cleaner, more maintainable<br>&gt; &gt; buildsystem as more cross-compile targets are added, but as you<br>&gt; mentioned,<br>&gt; &gt; may lead to longer build times and broken workflows. Maybe the<br>&gt; dependencies<br>&gt; &gt; could be fixed by using ExternalProject_Add.<br>&gt; &gt;<br>&gt; &gt; I think (2) will initially be easier, but will pollute the &quot;leaf&quot; CMake<br>&gt; &gt; functions/targets with target-specific details, as already seems to be<br>&gt; &gt; happening in AddSwift.cmake.<br>&gt; &gt;<br>&gt; &gt; Is there another approach I&#39;m not considering? What is more likely to be<br>&gt; &gt; accepted into apple/swift master?<br>&gt;<br>&gt; I&#39;m proposing we do (1) for new cross-compilation targets (like OS X<br>&gt; to Linux, or Linux x86_64 to Linux arm), but keep the current scheme<br>&gt; for Darwin.<br>&gt;<br>&gt; To keep existing workflows working, I would suggest that native builds<br>&gt; keep building the standard library in the same CMake invocation as the<br>&gt; compiler.<br>&gt;<br>&gt; Optionally, cross-compiling builds can unconditionally invoke the<br>&gt; CMake build tool recursively for cross-compilation targets after the<br>&gt; compiler is built, to erase the difference between native builds and<br>&gt; cross-compiling.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160121/5e9e1122/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 21, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Jan 21, 2016 at 11:04 AM, Tom Birch &lt;froody at gmail.com&gt; wrote:<br>&gt; Ok, thanks, I&#39;ll run with that. I see<br>&gt; SWIFT_NATIVE_(LLVM|CLANG|SWIFT)_TOOLS_PATH, is currently used/supported<br>&gt; anywhere?<br></p><p>Yes, it is supported and can be used to compile the libraries with an<br>existing swift compiler, while cross-compiling the compiler.  It can<br>be used for some cross-compilation workflows.<br></p><p>&gt; My current plan is to:<br>&gt; 1) Build everything (llvm/clang, cmark, swift) for macosx-x86_64<br>&gt; 2) Setup SWIFT_NATIVE_*_TOOLS_PATH to point to the respective dirs created<br>&gt; in (1)<br>&gt; 3) Create a swift-android-armv7 build dir<br>&gt; 4) Invoke CMake in swift-android-armv7 with vars from (2), plus a<br>&gt; Toolchain-android-armv7.cmake to set CMAKE_SYSTEM_NAME, CMAKE_SYSROOT, etc<br>&gt; for the android build<br></p><p>Right, except the step (2) actually happens inside of step (4).<br>That&#39;s exactly how it is supposed to work.<br></p><p>&gt; Ideally I&#39;d only build the stdlib and tests for android, skipping the tools<br>&gt; and and llvm/clang builds. Does this seem feasible? I know the runtime<br>&gt; depends on llvm headers, but I can either use the macosx-x86_64 llvm<br>&gt; headers, or do a partial headers-only install of llvm-android-armv7. Are<br>&gt; there any binaries/tools needed to be built for the target (i.e<br>&gt; android-armv7) in order to build stdlib?<br></p><p>Yes, you can do that with appropriate skip-build-* flags, but you<br>would still need to configure llvm/clang.  build-script should take<br>care of that if you give it appropriate flags.<br></p><p>&gt; Anything else I should know/watch<br>&gt; out for?<br></p><p>Nothing that I know of right now.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1a92780aeb1a248560d222575689c59?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>ChrisBieneman</string> &lt;beanz at apple.com&gt;<p>January 22, 2016 at 09:00:00am</p></header><div class="content"><p>Can I provide an alternate suggestion?<br></p><p>Clang can be cross-compiled for alternate platforms with seemingly a single CMake invocation. This is accomplished by having a model where the user configures the cross-build, and LLVM&#39;s CMake detects that you are cross compiling and it handles configuring the host tools and hooking the dependencies up.<br></p><p>This does lead to some pretty gnarly CMake scripting, but I think it provides a very good user experience.<br></p><p>As an example instructions for cross-compiling LLVM are here: http://llvm.org/docs/GettingStarted.html#cross-compiling-llvm<br></p><p>That simple configuration command handles everything, all a user has to do is run ninja once.<br></p><p>-Chris<br></p><p>Sent from my iPad<br></p><p>&gt; On Jan 21, 2016, at 11:38 AM, Dmitri Gribenko via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, Jan 21, 2016 at 11:04 AM, Tom Birch &lt;froody at gmail.com&gt; wrote:<br>&gt;&gt; Ok, thanks, I&#39;ll run with that. I see<br>&gt;&gt; SWIFT_NATIVE_(LLVM|CLANG|SWIFT)_TOOLS_PATH, is currently used/supported<br>&gt;&gt; anywhere?<br>&gt; <br>&gt; Yes, it is supported and can be used to compile the libraries with an<br>&gt; existing swift compiler, while cross-compiling the compiler.  It can<br>&gt; be used for some cross-compilation workflows.<br>&gt; <br>&gt;&gt; My current plan is to:<br>&gt;&gt; 1) Build everything (llvm/clang, cmark, swift) for macosx-x86_64<br>&gt;&gt; 2) Setup SWIFT_NATIVE_*_TOOLS_PATH to point to the respective dirs created<br>&gt;&gt; in (1)<br>&gt;&gt; 3) Create a swift-android-armv7 build dir<br>&gt;&gt; 4) Invoke CMake in swift-android-armv7 with vars from (2), plus a<br>&gt;&gt; Toolchain-android-armv7.cmake to set CMAKE_SYSTEM_NAME, CMAKE_SYSROOT, etc<br>&gt;&gt; for the android build<br>&gt; <br>&gt; Right, except the step (2) actually happens inside of step (4).<br>&gt; That&#39;s exactly how it is supposed to work.<br>&gt; <br>&gt;&gt; Ideally I&#39;d only build the stdlib and tests for android, skipping the tools<br>&gt;&gt; and and llvm/clang builds. Does this seem feasible? I know the runtime<br>&gt;&gt; depends on llvm headers, but I can either use the macosx-x86_64 llvm<br>&gt;&gt; headers, or do a partial headers-only install of llvm-android-armv7. Are<br>&gt;&gt; there any binaries/tools needed to be built for the target (i.e<br>&gt;&gt; android-armv7) in order to build stdlib?<br>&gt; <br>&gt; Yes, you can do that with appropriate skip-build-* flags, but you<br>&gt; would still need to configure llvm/clang.  build-script should take<br>&gt; care of that if you give it appropriate flags.<br>&gt; <br>&gt;&gt; Anything else I should know/watch<br>&gt;&gt; out for?<br>&gt; <br>&gt; Nothing that I know of right now.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 22, 2016 at 09:00:00am</p></header><div class="content"><p>On Fri, Jan 22, 2016 at 9:26 AM, ChrisBieneman &lt;beanz at apple.com&gt; wrote:<br>&gt; Can I provide an alternate suggestion?<br>&gt;<br>&gt; Clang can be cross-compiled for alternate platforms with seemingly a single CMake invocation. This is accomplished by having a model where the user configures the cross-build, and LLVM&#39;s CMake detects that you are cross compiling and it handles configuring the host tools and hooking the dependencies up.<br>&gt;<br>&gt; This does lead to some pretty gnarly CMake scripting, but I think it provides a very good user experience.<br>&gt;<br>&gt; As an example instructions for cross-compiling LLVM are here: http://llvm.org/docs/GettingStarted.html#cross-compiling-llvm<br>&gt;<br>&gt; That simple configuration command handles everything, all a user has to do is run ninja once.<br></p><p>Does that ninja command invoke multiple sub-ninja commands?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1a92780aeb1a248560d222575689c59?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>ChrisBieneman</string> &lt;beanz at apple.com&gt;<p>January 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 9:30 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Jan 22, 2016 at 9:26 AM, ChrisBieneman &lt;beanz at apple.com&gt; wrote:<br>&gt;&gt; Can I provide an alternate suggestion?<br>&gt;&gt; <br>&gt;&gt; Clang can be cross-compiled for alternate platforms with seemingly a single CMake invocation. This is accomplished by having a model where the user configures the cross-build, and LLVM&#39;s CMake detects that you are cross compiling and it handles configuring the host tools and hooking the dependencies up.<br>&gt;&gt; <br>&gt;&gt; This does lead to some pretty gnarly CMake scripting, but I think it provides a very good user experience.<br>&gt;&gt; <br>&gt;&gt; As an example instructions for cross-compiling LLVM are here: http://llvm.org/docs/GettingStarted.html#cross-compiling-llvm<br>&gt;&gt; <br>&gt;&gt; That simple configuration command handles everything, all a user has to do is run ninja once.<br>&gt; <br>&gt; Does that ninja command invoke multiple sub-ninja commands?<br></p><p>Yes. The top-level ninja will put them in the console job pool which results in their output being directly piped to the parent, and only one will execute at a time which allows them to not conflict with each other.<br></p><p>Alternatively if a user were to use make, it just becomes a recursive make call and the standard make IPC gets used to coordinate between the processes.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>On Fri, Jan 22, 2016 at 9:50 AM, Chris Bieneman &lt;beanz at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jan 22, 2016, at 9:30 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 22, 2016 at 9:26 AM, ChrisBieneman &lt;beanz at apple.com&gt; wrote:<br>&gt;&gt;&gt; Can I provide an alternate suggestion?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Clang can be cross-compiled for alternate platforms with seemingly a single CMake invocation. This is accomplished by having a model where the user configures the cross-build, and LLVM&#39;s CMake detects that you are cross compiling and it handles configuring the host tools and hooking the dependencies up.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This does lead to some pretty gnarly CMake scripting, but I think it provides a very good user experience.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As an example instructions for cross-compiling LLVM are here: http://llvm.org/docs/GettingStarted.html#cross-compiling-llvm<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That simple configuration command handles everything, all a user has to do is run ninja once.<br>&gt;&gt;<br>&gt;&gt; Does that ninja command invoke multiple sub-ninja commands?<br>&gt;<br>&gt; Yes. The top-level ninja will put them in the console job pool which results in their output being directly piped to the parent, and only one will execute at a time which allows them to not conflict with each other.<br></p><p>Well, that&#39;s bad, here&#39;s why.<br></p><p>Building the Swift standard library has two phases: a very parallel<br>one, and a strictly serial one.  If you run all ninja invocations<br>serially, you will be increasing the compilation time by about 8x for<br>a full build for Apple operating systems (approx. 1 hour in total,<br>unacceptable).  If you run them all in parallel, you will<br>oversubscribe the machine during the parallel phase, and it will start<br>swapping.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1a92780aeb1a248560d222575689c59?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>ChrisBieneman</string> &lt;beanz at apple.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>What are the very parallel and very serial phases doing?<br></p><p>-Chris<br></p><p>&gt; On Jan 22, 2016, at 10:03 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Jan 22, 2016 at 9:50 AM, Chris Bieneman &lt;beanz at apple.com &lt;mailto:beanz at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 9:30 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jan 22, 2016 at 9:26 AM, ChrisBieneman &lt;beanz at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Can I provide an alternate suggestion?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Clang can be cross-compiled for alternate platforms with seemingly a single CMake invocation. This is accomplished by having a model where the user configures the cross-build, and LLVM&#39;s CMake detects that you are cross compiling and it handles configuring the host tools and hooking the dependencies up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This does lead to some pretty gnarly CMake scripting, but I think it provides a very good user experience.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As an example instructions for cross-compiling LLVM are here: http://llvm.org/docs/GettingStarted.html#cross-compiling-llvm<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That simple configuration command handles everything, all a user has to do is run ninja once.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does that ninja command invoke multiple sub-ninja commands?<br>&gt;&gt; <br>&gt;&gt; Yes. The top-level ninja will put them in the console job pool which results in their output being directly piped to the parent, and only one will execute at a time which allows them to not conflict with each other.<br>&gt; <br>&gt; Well, that&#39;s bad, here&#39;s why.<br>&gt; <br>&gt; Building the Swift standard library has two phases: a very parallel<br>&gt; one, and a strictly serial one.  If you run all ninja invocations<br>&gt; serially, you will be increasing the compilation time by about 8x for<br>&gt; a full build for Apple operating systems (approx. 1 hour in total,<br>&gt; unacceptable).  If you run them all in parallel, you will<br>&gt; oversubscribe the machine during the parallel phase, and it will start<br>&gt; swapping.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160122/a3c63b47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Cross-compile for Android armv7 from OSX</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 22, 2016 at 10:00:00am</p></header><div class="content"><p>All phases are compiling different libraries.  The serial part is the<br>first stage when we compile the core library, that every other library<br>depends on, and another serial stage is StdlibUnittest, that depends<br>on many other libraries, but just takes too long to compile, and its<br>compilation outlives the parallel stage when we still have other work<br>to do.<br></p><p>Dmitri<br></p><p>On Fri, Jan 22, 2016 at 10:10 AM, Chris Bieneman &lt;beanz at apple.com&gt; wrote:<br>&gt; What are the very parallel and very serial phases doing?<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; On Jan 22, 2016, at 10:03 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Fri, Jan 22, 2016 at 9:50 AM, Chris Bieneman &lt;beanz at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 22, 2016, at 9:30 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Fri, Jan 22, 2016 at 9:26 AM, ChrisBieneman &lt;beanz at apple.com&gt; wrote:<br>&gt;<br>&gt; Can I provide an alternate suggestion?<br>&gt;<br>&gt; Clang can be cross-compiled for alternate platforms with seemingly a single<br>&gt; CMake invocation. This is accomplished by having a model where the user<br>&gt; configures the cross-build, and LLVM&#39;s CMake detects that you are cross<br>&gt; compiling and it handles configuring the host tools and hooking the<br>&gt; dependencies up.<br>&gt;<br>&gt; This does lead to some pretty gnarly CMake scripting, but I think it<br>&gt; provides a very good user experience.<br>&gt;<br>&gt; As an example instructions for cross-compiling LLVM are here:<br>&gt; http://llvm.org/docs/GettingStarted.html#cross-compiling-llvm<br>&gt;<br>&gt; That simple configuration command handles everything, all a user has to do<br>&gt; is run ninja once.<br>&gt;<br>&gt;<br>&gt; Does that ninja command invoke multiple sub-ninja commands?<br>&gt;<br>&gt;<br>&gt; Yes. The top-level ninja will put them in the console job pool which results<br>&gt; in their output being directly piped to the parent, and only one will<br>&gt; execute at a time which allows them to not conflict with each other.<br>&gt;<br>&gt;<br>&gt; Well, that&#39;s bad, here&#39;s why.<br>&gt;<br>&gt; Building the Swift standard library has two phases: a very parallel<br>&gt; one, and a strictly serial one.  If you run all ninja invocations<br>&gt; serially, you will be increasing the compilation time by about 8x for<br>&gt; a full build for Apple operating systems (approx. 1 hour in total,<br>&gt; unacceptable).  If you run them all in parallel, you will<br>&gt; oversubscribe the machine during the parallel phase, and it will start<br>&gt; swapping.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
