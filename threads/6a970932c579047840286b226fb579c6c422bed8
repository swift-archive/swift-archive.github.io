<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a6c94632d8c82a2f077bbabbdd412f6?s=50"></div><header><strong>Function overload resolution rules</strong> from <string>Toni Suter</string> &lt;tonisuter at me.com&gt;<p>September 30, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I am trying to get a better understanding of Swift&#39;s function overload resolution rules.<br>As far as I can tell, if there are multiple candidates for a function call, Swift favors<br>functions for which the least amount of parameters have been ignored / defaulted. For example:<br></p><p>// Example 1<br>func f(x: Int) {  print(&quot;f1&quot;) }<br>func f(x: Int, y: Int = 0) { print(&quot;f2&quot;) }<br>f(x: 0) 	// f1<br></p><p>// Example 2<br>func f(x: Int, y: Int = 0) {  print(&quot;f1&quot;) }<br>func f(x: Int, y: Int = 0, z: Int = 0) { print(&quot;f2&quot;) }<br>f(x: 0) 	// f1<br></p><p>It also looks like Swift favors functions with default-value parameters over functions with variadic parameters:<br></p><p>func f(x: Int = 0) {  print(&quot;f1&quot;) }<br>func f(x: Int...) { print(&quot;f2&quot;) }<br></p><p>f() 			// f1<br>f(x: 1) 		// f1<br>f(x: 1, 2) 		// f2 (makes sense because f1 would not work here)<br>f(x: 1, 2, 3) 		// f2 (makes sense because f1 would not work here)<br></p><p>But then I tested functions with default-value parameters and variadic parameters and things start to get weird.<br>For example, this must be a bug, right?<br></p><p>func f(x: Int..., y: Int = 0) { print(x, y) }<br>func f(x: Int...) { print(x) }<br></p><p>f()			// []<br>f(x: 1)			// [1]<br>f(x: 1, 2)		// [1, 2] 0<br>f(x: 1, 2, 3)		// [1, 2, 3]<br></p><p>I think, in this example, it should always call the second overload, because<br>no parameter is ignored / defaulted. What do you think?<br></p><p>Thanks and best regards,<br>Toni<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160930/6a97bed8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Function overload resolution rules</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 30, 2016 at 05:00:00pm</p></header><div class="content"><p>On 30.09.2016 15:02, Toni Suter via swift-users wrote:<br>&gt; Hi,<br>&gt;<br>&gt; I am trying to get a better understanding of Swift&#39;s function overload<br>&gt; resolution rules.<br>&gt; As far as I can tell, if there are multiple candidates for a function call,<br>&gt; Swift favors<br>&gt; functions for which the least amount of parameters have been ignored /<br>&gt; defaulted. For example:<br></p><p>I do believe this *should* be a bug in Swift&#39;s parser. It is not obvious <br>the intention of the user, i.e. which function *user* want to call.<br>IMO there should be no hidden or complex rules on how Swift selects the <br>candidate for function calls if parameters suits for a number of <br>implementations.<br>IMO The only rule should be - if it is not clear from the parameter list <br>which func should be called - compilation error must be thrown. This will <br>be &quot;Swifty&quot; which is &quot;Safe by default&quot;. Current situation is not safe by <br>default.<br></p><p>&gt;<br>&gt; // Example 1<br>&gt; func f(x: Int) {  print(&quot;f1&quot;) }<br>&gt; func f(x: Int, y: Int = 0) { print(&quot;f2&quot;) }<br>&gt; f(x: 0) // f1<br>&gt;<br>&gt; // Example 2<br>&gt; func f(x: Int, y: Int = 0) {  print(&quot;f1&quot;) }<br>&gt; func f(x: Int, y: Int = 0, z: Int = 0) { print(&quot;f2&quot;) }<br>&gt; f(x: 0) // f1<br>&gt;<br>&gt; It also looks like Swift favors functions with default-value parameters<br>&gt; over functions with variadic parameters:<br>&gt;<br>&gt; func f(x: Int = 0) {  print(&quot;f1&quot;) }<br>&gt; func f(x: Int...) { print(&quot;f2&quot;) }<br>&gt;<br>&gt; f() // f1<br>&gt; f(x: 1) // f1<br>&gt; f(x: 1, 2) // f2 (makes sense because f1 would not work here)<br>&gt; f(x: 1, 2, 3) // f2 (makes sense because f1 would not work here)<br>&gt;<br>&gt; But then I tested functions with default-value parameters and variadic<br>&gt; parameters and things start to get weird.<br>&gt; For example, this must be a bug, right?<br>&gt;<br>&gt; func f(x: Int..., y: Int = 0) { print(x, y) }<br>&gt; func f(x: Int...) { print(x) }<br>&gt;<br>&gt; f()// []<br>&gt; f(x: 1)// [1]<br>&gt; f(x: 1, 2)// [1, 2] 0<br>&gt; f(x: 1, 2, 3)// [1, 2, 3]<br>&gt;<br>&gt; I think, in this example, it should always call the second overload, because<br>&gt; no parameter is ignored / defaulted. What do you think?<br>&gt;<br>&gt; Thanks and best regards,<br>&gt; Toni<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e26a5e7b70e927186f7e556d59c50ad5?s=50"></div><header><strong>Function overload resolution rules</strong> from <string>Mark Lacey</string> &lt;mark_lacey at apple.com&gt;<p>September 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 5:02 AM, Toni Suter via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I am trying to get a better understanding of Swift&#39;s function overload resolution rules.<br>&gt; As far as I can tell, if there are multiple candidates for a function call, Swift favors<br>&gt; functions for which the least amount of parameters have been ignored / defaulted. For example:<br>&gt; <br>&gt; // Example 1<br>&gt; func f(x: Int) {  print(&quot;f1&quot;) }<br>&gt; func f(x: Int, y: Int = 0) { print(&quot;f2&quot;) }<br>&gt; f(x: 0) 	// f1<br>&gt; <br>&gt; // Example 2<br>&gt; func f(x: Int, y: Int = 0) {  print(&quot;f1&quot;) }<br>&gt; func f(x: Int, y: Int = 0, z: Int = 0) { print(&quot;f2&quot;) }<br>&gt; f(x: 0) 	// f1<br>&gt; <br>&gt; It also looks like Swift favors functions with default-value parameters over functions with variadic parameters:<br>&gt; <br>&gt; func f(x: Int = 0) {  print(&quot;f1&quot;) }<br>&gt; func f(x: Int...) { print(&quot;f2&quot;) }<br>&gt; <br>&gt; f() 			// f1<br>&gt; f(x: 1) 		// f1<br>&gt; f(x: 1, 2) 		// f2 (makes sense because f1 would not work here)<br>&gt; f(x: 1, 2, 3) 		// f2 (makes sense because f1 would not work here)<br>&gt; <br>&gt; But then I tested functions with default-value parameters and variadic parameters and things start to get weird.<br>&gt; For example, this must be a bug, right?<br>&gt; <br>&gt; func f(x: Int..., y: Int = 0) { print(x, y) }<br>&gt; func f(x: Int...) { print(x) }<br>&gt; <br>&gt; f()			// []<br>&gt; f(x: 1)			// [1]<br>&gt; f(x: 1, 2)		// [1, 2] 0<br>&gt; f(x: 1, 2, 3)		// [1, 2, 3]<br>&gt; <br>&gt; I think, in this example, it should always call the second overload, because<br>&gt; no parameter is ignored / defaulted. What do you think?<br></p><p>Can you open a new bug report for this at bugs.swift.org &lt;http://bugs.swift.org/&gt;?<br></p><p>Mark<br></p><p>&gt; <br>&gt; Thanks and best regards,<br>&gt; Toni<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160930/032d1813/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a6c94632d8c82a2f077bbabbdd412f6?s=50"></div><header><strong>Function overload resolution rules</strong> from <string>Toni Suter</string> &lt;tonisuter at me.com&gt;<p>September 30, 2016 at 08:00:00pm</p></header><div class="content"><p>I created a bug report here: https://bugs.swift.org/browse/SR-2810 &lt;https://bugs.swift.org/browse/SR-2810&gt;<br></p><p>Best regards,<br>Toni<br></p><p>&gt; Am 30.09.2016 um 19:47 schrieb Mark Lacey &lt;mark_lacey at apple.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 30, 2016, at 5:02 AM, Toni Suter via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I am trying to get a better understanding of Swift&#39;s function overload resolution rules.<br>&gt;&gt; As far as I can tell, if there are multiple candidates for a function call, Swift favors<br>&gt;&gt; functions for which the least amount of parameters have been ignored / defaulted. For example:<br>&gt;&gt; <br>&gt;&gt; // Example 1<br>&gt;&gt; func f(x: Int) {  print(&quot;f1&quot;) }<br>&gt;&gt; func f(x: Int, y: Int = 0) { print(&quot;f2&quot;) }<br>&gt;&gt; f(x: 0) 	// f1<br>&gt;&gt; <br>&gt;&gt; // Example 2<br>&gt;&gt; func f(x: Int, y: Int = 0) {  print(&quot;f1&quot;) }<br>&gt;&gt; func f(x: Int, y: Int = 0, z: Int = 0) { print(&quot;f2&quot;) }<br>&gt;&gt; f(x: 0) 	// f1<br>&gt;&gt; <br>&gt;&gt; It also looks like Swift favors functions with default-value parameters over functions with variadic parameters:<br>&gt;&gt; <br>&gt;&gt; func f(x: Int = 0) {  print(&quot;f1&quot;) }<br>&gt;&gt; func f(x: Int...) { print(&quot;f2&quot;) }<br>&gt;&gt; <br>&gt;&gt; f() 			// f1<br>&gt;&gt; f(x: 1) 		// f1<br>&gt;&gt; f(x: 1, 2) 		// f2 (makes sense because f1 would not work here)<br>&gt;&gt; f(x: 1, 2, 3) 		// f2 (makes sense because f1 would not work here)<br>&gt;&gt; <br>&gt;&gt; But then I tested functions with default-value parameters and variadic parameters and things start to get weird.<br>&gt;&gt; For example, this must be a bug, right?<br>&gt;&gt; <br>&gt;&gt; func f(x: Int..., y: Int = 0) { print(x, y) }<br>&gt;&gt; func f(x: Int...) { print(x) }<br>&gt;&gt; <br>&gt;&gt; f()			// []<br>&gt;&gt; f(x: 1)			// [1]<br>&gt;&gt; f(x: 1, 2)		// [1, 2] 0<br>&gt;&gt; f(x: 1, 2, 3)		// [1, 2, 3]<br>&gt;&gt; <br>&gt;&gt; I think, in this example, it should always call the second overload, because<br>&gt;&gt; no parameter is ignored / defaulted. What do you think?<br>&gt; <br>&gt; Can you open a new bug report for this at bugs.swift.org &lt;http://bugs.swift.org/&gt;?<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks and best regards,<br>&gt;&gt; Toni<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160930/3d29aaa9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
