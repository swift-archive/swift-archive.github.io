<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Erica, Dave<br></p><p>Based on what I’ve (not all) read under this topic: <br></p><p>I’d suggest a more complete approach:<br></p><p>Ranges should support:  (as yet not implemented) <br></p><p>- All numerical data types (Double, Float, Int, Money***, Decimal*** ) <br>- An arbitrary increment or decrement value.<br>- Working in the complete  - + numerical range<br>- Allow traversing in both   - + directions.<br></p><p><br></p><p>The basics:<br></p><p>    (v1…v2).by(v3)     // this still is readable. and can be optimized by the compiler (predictable sequence)    <br></p><p>Rules:<br></p><p>    v1, v2, v3  are any numerical type scalar type  <br>    v1, v2, v3  must have the same numerical type.<br>    v1 &gt;  v2:   is allowed and correctly evaluated.  e.g. (8.0…-3.14159).by(-0.0001) <br></p><p><br>    The  ..&lt;  half open operator is no longer allowed.   write e.g.   0...ar.count - 1<br></p><p>    &quot;by(…)”  is obligatory with floating point range.<br></p><p>           the default “by(…)” value of 1 makes sense only with integer ranges.<br></p><p><br>valid examples:<br>    (5…9)                        // 5 6 7 8 9 Integer range without “by” defaults to 1 as increment value.<br>    (1...10).by(2)             // 1 3 5 7 9.<br>    (2...10).by(2)             // 2 4 6 8 10.<br>    (4…-4).by(2)             // 4  2 0 -2 -4 .        // runs backwards<br>    (30..-10).by(-2)        // 30 28 26 24 22 ….. -10.    <br>    (10...0).by(-3)          // 10 7 4 1.                 <br></p><p>    (12…-10)                 // is valid, but returns empty because default increment value = 1<br></p><p>    (12.0…-12.0).by(-1.5)       // 12.0  10.5  9.0….          // of course with float imprecision<br>                                                                       <br>   <br></p><p>   invalid examples:<br></p><p>   (23.0..&lt;60.5).by(0.5)         // half open ranges are no  longer allowed ** <br>  (23.0…60.5)                     // “ by&quot;  is obligatory with floats.<br>  (14...8).by(0.5)                //  v1 v2 and v3 don’t have the same numerical type <br></p><p><br>Half open ranges make no real sense (are not really useful) with floating point values.<br>and no sense at all with e.g (12..&lt;-1)  afaics <br></p><p><br>At least for float iterations the increment value should not each time be accumulated like<br>v1 += v3;  v1 += v3;  v1 += v3;  ….                       // causes float number drift.<br>but be freshly multiplied with each iteration, e.g. by using an internal iteration counter<br>like so:<br></p><p>v1 = v3 * i++;   v1 = v3 * i++;   v1 = v3 * i++;….<br></p><p>for reasons of precision.<br></p><p>If one has worked with floating point data more often<br>awareness of its precision limitations become a second nature conscience. <br>E.g. it is perfectly acceptable and known (also in classical for-loops) that<br>(0.0…1.0).by(0.1) is not guaranteed to reach the humanly expected value of 1.0.<br>This is normal. Due to the nature of what mostly is done in the<br>floating point numbers domain, this does not often cause a problem<br>(e.g like working with a slide ruler) <br>if it is important to reach the “expected end” then one could<br>-add an epsilon value like so (v1…v2 + 0.1) <br>-generate the desired float sequence within an integer loop.<br></p><p><br>The above “range” (imho) improvement makes the <br>stride.. function/keyword completely unnecessary.<br></p><p>Due to its ability to process reversed ranges as is, <br>the .reverse() is optional (no longer necessary in most cases,<br>allowing the compiler to optimize without having to process <br>it like a collection.<br></p><p><br>Now that we have a fully functional range, which can do all things desired, one can<br>then of course, pass this range without any change  to a collection based for …  e.g.<br></p><p>for v in (v1…v2).by(v3)   // optionally add other collection operators/filters/sorts here<br></p><p>(or in any other construct you might see fit)<br>                                       <br></p><p>This seems to be a reasonable alternative for<br></p><p>- the classical for ;; loop<br>-the collection-free for-loop  <br>     for v from v1 to v2 by v3<br></p><p>As you know, the latter is what I have been suggesting, <br>but seemingly does not find much support,<br>(because I received very little reactions) <br>making it doubtful if I will ever make a proposal for this for loop.<br>Anyone out there should I stil do that? <br></p><p>When one does not further extend the range<br>with filters like sort etc. the compiler can still optimize <br>a collection-in-between out of the way.<br>(Thank you Taras, für das Mitdenken. :o)<br></p><p><br>**   note that a half open range would in most cases be unnecessary <br>      if  collection indexes started with 1 instead of 0, e.g. someArray[1…10] <br>     (but it’s too late to change that.) <br>     “the color of the first apple?”    vs<br>     “the color of the zeroth (0) ???  apple?”    ? Silly isn’t? <br></p><p>*** possible future numerical “native” types <br></p><p><br>It could be that (at least) partly something similar has already been suggested.<br>but so much is here of this topic that i can’t see the wood for the trees, so to speak.<br></p><p><br>Your (all) opinions are appreciated. <br></p><p>kind regards, mit freundlichen Grüssen, Met vriendelijke groeten, <br>Sigh, why do we Dutch always have to speak the languages of the bigger countries :o) <br>TedvG<br></p><p>&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt; <br>&gt;&gt;    are even or odd.<br>&gt;&gt; <br>&gt;&gt; (0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>&gt;&gt; (1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br>&gt; <br>&gt; I understand the logic that got you there, but I find it incredibly<br>&gt; counter-intuitive that striding by 2s over a range with odd endpoints<br>&gt; should produce even numbers... I can&#39;t imagine any way I&#39;d be convinced<br>&gt; that was a good idea.<br>&gt; <br>&gt;&gt; (0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>&gt;&gt; (1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br></p><p>&gt; -- <br>&gt;&gt; Dave<br></p><p><br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/83eebf3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 6 Apr 2016, at 21:08, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; v1 &gt;  v2:   is allowed and correctly evaluated.  e.g. (8.0…-3.14159).by(-0.0001) <br></p><p>If the range does not assume `start &gt;= end`, is it still necessary to also indicate the traversal direction with the sign of the step (`-0.0001`)?<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/c66cb266/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello Milos,<br>Good question<br>was thinking about this too.<br>that would imply the ‘by”value should/must always be an absolute value?<br>however (if it is a var) it cannot be guaranteed to be + or - <br>that’s why I thought to leave it as is.<br>?<br>TedvG<br></p><p>&gt; On 06.04.2016, at 22:18, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 6 Apr 2016, at 21:08, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; v1 &gt;  v2:   is allowed and correctly evaluated.  e.g. (8.0…-3.14159).by(-0.0001) <br>&gt; <br>&gt; If the range does not assume `start &gt;= end`, is it still necessary to also indicate the traversal direction with the sign of the step (`-0.0001`)?<br>&gt; <br>&gt; milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/bd0b8c28/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Ted,<br></p><p>&gt; that would imply the ‘by”value should/must always be an absolute value?<br></p><p><br>In a way: Instead of `Strideable.Stride` I would suggest `Strideable.Distance`.<br></p><p>At any rate, leaving the sign to be direction indicator makes it forever necessary for everyone to make this counterintuitive metal gymnastics, since most of the time in life we do not walk backwards, even when we are returning back whence we came from!<br></p><p>What do you think?<br></p><p>milos<br></p><p><br>&gt; On 6 Apr 2016, at 21:34, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello Milos,<br>&gt; Good question<br>&gt; was thinking about this too.<br>&gt; that would imply the ‘by”value should/must always be an absolute value?<br>&gt; however (if it is a var) it cannot be guaranteed to be + or - <br>&gt; that’s why I thought to leave it as is.<br>&gt; ?<br>&gt; TedvG<br>&gt; <br>&gt;&gt; On 06.04.2016, at 22:18, Milos Rankovic &lt;milos at milos-and-slavica.net &lt;mailto:milos at milos-and-slavica.net&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 6 Apr 2016, at 21:08, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; v1 &gt;  v2:   is allowed and correctly evaluated.  e.g. (8.0…-3.14159).by(-0.0001) <br>&gt;&gt; <br>&gt;&gt; If the range does not assume `start &gt;= end`, is it still necessary to also indicate the traversal direction with the sign of the step (`-0.0001`)?<br>&gt;&gt; <br>&gt;&gt; milos<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/f2239f32/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April  6, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Milos<br></p><p>Yes,  (v1…v2).by(v3)  it can determine the going of either in  + or - direction,<br>but only at run time! because the contents of v1, v2, v3 are of course unknown at compile time. <br>Ergo: it cannot expected be an absolute value.<br></p><p>however, I suggested (coded) that here on 4.3.2016…  Works in Playground Xcode 7.3<br>look in the struct its “init”   where the direction is determined<br>by wether “from” or “to” is bigger” <br>implemented like this  (and also with a floating point number tolerance)<br>(The struct should be numerical generic, but I didn’t manage to change it to generic,) <br>Anyway, should be compilerized/hand coded in asm perhaps (I can’t do that)<br></p><p>TedvG<br></p><p>public struct StriderGenerator : GeneratorType<br>{<br>    private let low: Double<br>    private let high: Double<br>    private var step : Double<br>    private var tol  : Double<br></p><p>    private var iterator  = 0<br></p><p>    private let moveForward: Bool<br>    <br>    private var done  = false<br>        <br>    <br>    public init(from: Double, to: Double, by: Double, tolerance: Double)<br>    {<br>        step = by<br>        if from &lt; to<br>        {<br>            low  = from<br>            high = to<br>            moveForward = true<br>        }<br>        else<br>        {<br>            low  = to<br>            high = from<br>            moveForward = false<br>        }<br>        self.tol   = tolerance * 0.5  // center it.<br>    }<br>    <br>    /// return next value or nil, if no next<br>    /// element exists.<br>    <br>    public mutating func next() -&gt; Double?<br>    {<br>        let current:Double<br>        if done<br>        {<br>            return nil<br>        }<br>        <br>        if moveForward<br>        {<br>            current = low + Double(iterator) * step<br>        }<br>        else<br>        {<br>            current = high - Double(iterator) * step<br>        }<br>        iterator += 1<br>        <br>        <br>        // done if exceeding low or high limits + tolerance<br>        <br>        done = current &gt; high   + tol  ||<br>               current &lt; low    - tol<br>        <br>        if done<br>        {<br>            return nil<br>        }<br>        else<br>        {<br>            return current<br>        }<br>    }<br>}<br></p><p>public struct Strider : SequenceType   // Aragorn<br>{<br>    private let start:  Double<br>    private let end:    Double<br>    private let step:   Double<br>    private let tol:    Double<br></p><p>    init(from: Double, to: Double, by: Double, tolerance : Double)<br>    {<br>        _precondition(by &gt; 0.0 ,<br>            &quot;Init of struct Strider: &#39;by:...&#39; value must be &gt; 0.0.&quot;)<br>        _precondition(abs(by) &gt; tolerance,<br>            &quot;Init of struct Strider: &#39;by:...&#39; value must be &gt; tolerance.&quot;)<br>        _precondition(tolerance &gt;= 0.0,<br>            &quot;Init of struct Strider: tolerance:... value must be &gt;= 0.0&quot;)<br>        <br>        start = from<br>        end   = to;<br>        step  = by<br>        tol   = tolerance<br>    }<br>    <br>    /// Return a *generator* over the elements of this *sequence*.<br>    <br>    public func generate() -&gt; StriderGenerator<br>    {<br>        return StriderGenerator(from: start, to: end, by: step, tolerance:  tol)<br>    }<br>}<br></p><p>public extension Double<br>{<br>    <br>    public func strider(to to: Double, by: Double, tolerance: Double ) -&gt; Strider<br>    {<br>        return Strider( from: self, to: to, by: by, tolerance: tolerance)<br>    }<br>}<br></p><p>print(&quot;Testing the new .strider extension&quot;)<br></p><p>let testvalues =<br>[<br>    // fr:     to:     by:   tolerance:<br>    [ 0.0,     5.0,    1.0,    0.0 ],<br>    [-3.0,     4.0,    0.12,   0.1 ],<br>    [ 2.0,    -1.0,    0.34,   0.1  ],<br>    [ 0.001,  -0.002,  0.0001, 0.00001 ]<br>]<br></p><p>for parm in testvalues<br>{<br>    <br>    print(&quot;==============Stride from: \(parm[0]) to: \(parm[1]) by: \(parm[2]) tolerance: \(parm[3])\n&quot;)<br>    <br>    for val in parm[0].strider(to: parm[1], by: parm[2], tolerance: parm[3])<br>    {<br>        print(&quot;\(val) &quot;, terminator:&quot;&quot;)<br>    }<br>    print(&quot;\n\n&quot;)<br>}<br></p><p><br></p><p><br>TedvG<br></p><p><br></p><p>&gt; On 06.04.2016, at 23:15, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt; <br>&gt; Hi Ted,<br>&gt; <br>&gt;&gt; that would imply the ‘by”value should/must always be an absolute value?<br>&gt; <br>&gt; <br>&gt; In a way: Instead of `Strideable.Stride` I would suggest `Strideable.Distance`.<br>&gt; <br>&gt; At any rate, leaving the sign to be direction indicator makes it forever necessary for everyone to make this counterintuitive metal gymnastics, since most of the time in life we do not walk backwards, even when we are returning back whence we came from!<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; milos<br>&gt; <br>&gt; <br>&gt;&gt; On 6 Apr 2016, at 21:34, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com &lt;mailto:tedvgiosdev at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Milos,<br>&gt;&gt; Good question<br>&gt;&gt; was thinking about this too.<br>&gt;&gt; that would imply the ‘by”value should/must always be an absolute value?<br>&gt;&gt; however (if it is a var) it cannot be guaranteed to be + or - <br>&gt;&gt; that’s why I thought to leave it as is.<br>&gt;&gt; ?<br>&gt;&gt; TedvG<br>&gt;&gt; <br>&gt;&gt;&gt; On 06.04.2016, at 22:18, Milos Rankovic &lt;milos at milos-and-slavica.net &lt;mailto:milos at milos-and-slavica.net&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 6 Apr 2016, at 21:08, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; v1 &gt;  v2:   is allowed and correctly evaluated.  e.g. (8.0…-3.14159).by(-0.0001) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the range does not assume `start &gt;= end`, is it still necessary to also indicate the traversal direction with the sign of the step (`-0.0001`)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; milos<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/5a0c965a/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 09:00:00pm</p></header><div class="content"><p>Apologies, I inverted the operator there! This is, of course what I meant:<br></p><p>&gt; On 6 Apr 2016, at 21:08, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; v1 &gt;  v2:   is allowed and correctly evaluated.  e.g. (8.0…-3.14159).by(-0.0001) <br></p><p>If the range does not assume `start &lt;= end`, is it still necessary to also indicate the traversal direction with the sign of the step (`-0.0001`)?<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/e28569ec/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Grrrr Typos… Sorry, here it is again: vital  corrections    look at&lt;&lt;&lt;&lt;&lt;&lt; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br></p><p>Hi Erica, Dave<br></p><p>Based on what I’ve (not all) read under this topic: <br></p><p>I’d suggest a more complete approach:<br></p><p>Ranges should support:  (as yet not implemented) <br></p><p>- All numerical data types (Double, Float, Int, Money***, Decimal*** ) <br>- An arbitrary increment or decrement value.<br>- Working in the complete  - + numerical range<br>- Allow traversing in both   - + directions.<br></p><p><br></p><p>The basics:<br></p><p>    (v1…v2).by(v3)     // this still is readable. and can be optimized by the compiler (predictable sequence)    <br></p><p>Rules:<br></p><p>    v1, v2, v3  are any numerical type scalar type  <br>    v1, v2, v3  must have the same numerical type.<br>    v1 &gt;  v2:   is allowed and correctly evaluated.  e.g. (8.0…-3.14159).by(-0.0001) <br></p><p><br>    The  ..&lt;  half open operator is no longer allowed.   write e.g.   0...ar.count - 1<br></p><p>    &quot;by(…)”  is obligatory with floating point range.<br></p><p>           the default “by(…)” value of 1 makes sense only with integer ranges.<br></p><p><br>valid examples:<br>    (5…9)                        // 5 6 7 8 9 Integer range without “by” defaults to 1 as increment value.<br>    (1...10).by(2)             // 1 3 5 7 9.<br>    (2...10).by(2)             // 2 4 6 8 10.<br>    (4…-4).by(-2)             // 4  2 0 -2 -4 .        // runs backwards          &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>    (30..-10).by(-2)        // 30 28 26 24 22 ….. -10.    <br>    (10...0).by(-3)          // 10 7 4 1.                 <br></p><p>    (12…-10)                 // is valid, but returns empty because default increment value = 1<br></p><p>    (12.0…-12.0).by(-1.5)       // 12.0  10.5  9.0….          // of course with float imprecision<br>                                                                       <br>   <br></p><p>   invalid examples:<br></p><p>   (23.0..&lt;60.5).by(0.5)         // half open ranges are no  longer allowed ** <br>  (23.0…60.5)                     // “ by&quot;  is obligatory with floats.<br>  (14...8).by(0.5)                //  v1 v2 and v3 don’t have the same numerical type <br></p><p><br>Half open ranges make no real sense (are not really useful) with floating point values.<br>and no sense at all with e.g (12..&lt;-1)  afaics <br></p><p><br>At least for float iterations the increment value should not each time be accumulated like<br>v1 += v3;  v1 += v3;  v1 += v3;  ….                       // causes float number drift.<br>but be freshly multiplied with each iteration, e.g. by using an internal iteration counter<br>like so:<br></p><p>v = v1 + v3 * i++;     v = v1 + v3 * i++;      v = v1 + v3 * i++;  v = v1 + v3 * i++;     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br></p><p>for reasons of precision.<br></p><p>If one has worked with floating point data more often<br>awareness of its precision limitations become a second nature conscience. <br>E.g. it is perfectly acceptable and known (also in classical for-loops) that<br>(0.0…1.0).by(0.1) is not guaranteed to reach the humanly expected value of 1.0.<br>This is normal. Due to the nature of what mostly is done in the<br>floating point numbers domain, this does not often cause a problem<br>(e.g like working with a slide ruler) <br>if it is important to reach the “expected end” then one could<br>-add an epsilon value like so (v1…v2 + 0.1) <br>-generate the desired float sequence within an integer loop.<br></p><p><br>The above “range” (imho) improvement makes the <br>stride.. function/keyword completely unnecessary.<br></p><p>Due to its ability to process reversed ranges as is, <br>the .reverse() is optional (no longer necessary in most cases,<br>allowing the compiler to optimize without having to process <br>it like a collection.<br></p><p><br>Now that we have a fully functional range, which can do all things desired, one can<br>then of course, pass this range without any change  to a collection based for …  e.g.<br></p><p>for v in (v1…v2).by(v3)   // optionally add other collection operators/filters/sorts here<br></p><p>(or in any other construct you might see fit)<br>                                       <br></p><p>This seems to be a reasonable alternative for<br></p><p>- the classical for ;; loop<br>-the collection-free for-loop  <br>     for v from v1 to v2 by v3<br></p><p>As you know, the latter is what I have been suggesting, <br>but seemingly does not find much support,<br>(because I received very little reactions) <br>making it doubtful if I will ever make a proposal for this for loop.<br>Anyone out there should I stil do that? <br></p><p>When one does not further extend the range<br>with filters like sort etc. the compiler can still optimize <br>a collection-in-between out of the way.<br>(Thank you Taras, für das Mitdenken. :o)<br></p><p><br>**   note that a half open range would in most cases be unnecessary <br>      if  collection indexes started with 1 instead of 0, e.g. someArray[1…10] <br>     (but it’s too late to change that.) <br>     “the color of the first apple?”    vs<br>     “the color of the zeroth (0) ???  apple?”    ? Silly isn’t? <br></p><p>*** possible future numerical “native” types <br></p><p><br>It could be that (at least) partly something similar has already been suggested.<br>but so much is here of this topic that i can’t see the wood for the trees, so to speak.<br></p><p><br>Your (all) opinions are appreciated. <br></p><p>kind regards, mit freundlichen Grüssen, Met vriendelijke groeten, <br>Sigh, why do we Dutch always have to speak the languages of the bigger countries :o) <br>TedvG<br></p><p>&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt; <br>&gt;&gt;    are even or odd.<br>&gt;&gt; <br>&gt;&gt; (0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>&gt;&gt; (1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br>&gt; <br>&gt; I understand the logic that got you there, but I find it incredibly<br>&gt; counter-intuitive that striding by 2s over a range with odd endpoints<br>&gt; should produce even numbers... I can&#39;t imagine any way I&#39;d be convinced<br>&gt; that was a good idea.<br>&gt; <br>&gt;&gt; (0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>&gt;&gt; (1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br></p><p>&gt; -- <br>&gt;&gt; Dave<br></p><p><br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/45939386/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>April  7, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi All.<br></p><p>nearly no one has yet reacted on my mail, echoed here again,<br></p><p>which leaves by me the following questions pending:<br></p><p>-does what I define and describe completely cover all the required functionality<br> for ranges for all numerical types?<br></p><p>-does it eliminate the need for using “Stride(...)”  at least for numerical scalars?<br></p><p>-combined with for .. in…  , is it an adequate replacement for the  classical for loop?<br></p><p>-can we eliminate  half open operators? Because imho that would simplify things greatly.<br>          -to which text of Dijkstra is this related?  <br></p><p><br>Objections? <br>improvements? <br>Things that I have missed? <br>Feasibility? <br>Implementable?<br></p><p>Thanks<br>TedvG<br></p><p><br></p><p><br></p><p>&gt; On 06.04.2016, at 22:43, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Hi Erica, Dave<br>&gt; <br>&gt; Based on what I’ve (not all) read under this topic: <br>&gt; <br>&gt; I’d suggest a more complete approach:<br>&gt; <br>&gt; Ranges should support:  (as yet not implemented) <br>&gt; <br>&gt; - All numerical data types (Double, Float, Int, Money***, Decimal*** ) <br>&gt; - An arbitrary increment or decrement value.<br>&gt; - Working in the complete  - + numerical range<br>&gt; - Allow traversing in both   - + directions.<br>&gt; <br>&gt; <br>&gt; <br>&gt; The basics:<br>&gt; <br>&gt;     (v1…v2).by(v3)     // this still is readable. and can be optimized by the compiler (predictable sequence)    <br>&gt; <br>&gt; Rules:<br>&gt; <br>&gt;     v1, v2, v3  are any numerical type scalar type  <br>&gt;     v1, v2, v3  must have the same numerical type.<br>&gt;     v1 &gt;  v2:   is allowed and correctly evaluated.  e.g. (8.0…-3.14159).by(-0.0001) <br>&gt; <br>&gt; <br>&gt;     The  ..&lt;  half open operator is no longer allowed.   write e.g.   0...ar.count - 1<br>&gt; <br>&gt;     &quot;by(…)”  is obligatory with floating point range.<br>&gt; <br>&gt;            the default “by(…)” value of 1 makes sense only with integer ranges.<br>&gt; <br>&gt; <br>&gt; valid examples:<br>&gt;     (5…9)                        // 5 6 7 8 9 Integer range without “by” defaults to 1 as increment value.<br>&gt;     (1...10).by(2)             // 1 3 5 7 9.<br>&gt;     (2...10).by(2)             // 2 4 6 8 10.<br>&gt;     (4…-4).by(-2)             // 4  2 0 -2 -4 .        // runs backwards          &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>&gt;     (30..-10).by(-2)        // 30 28 26 24 22 ….. -10.    <br>&gt;     (10...0).by(-3)          // 10 7 4 1.                 <br>&gt; <br>&gt;     (12…-10)                 // is valid, but returns empty because default increment value = 1<br>&gt; <br>&gt;     (12.0…-12.0).by(-1.5)       // 12.0  10.5  9.0….          // of course with float imprecision<br>&gt;                                                                        <br>&gt;    <br>&gt; <br>&gt;    invalid examples:<br>&gt; <br>&gt;    (23.0..&lt;60.5).by(0.5)         // half open ranges are no  longer allowed ** <br>&gt;   (23.0…60.5)                     // “ by&quot;  is obligatory with floats.<br>&gt;   (14...8).by(0.5)                //  v1 v2 and v3 don’t have the same numerical type <br>&gt; <br>&gt; <br>&gt; Half open ranges make no real sense (are not really useful) with floating point values.<br>&gt; and no sense at all with e.g (12..&lt;-1)  afaics <br>&gt; <br>&gt; <br>&gt; At least for float iterations the increment value should not each time be accumulated like<br>&gt; v1 += v3;  v1 += v3;  v1 += v3;  ….                       // causes float number drift.<br>&gt; but be freshly multiplied with each iteration, e.g. by using an internal iteration counter<br>&gt; like so:<br>&gt; <br>&gt; v = v1 + v3 * i++;     v = v1 + v3 * i++;      v = v1 + v3 * i++;  v = v1 + v3 * i++;     &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>&gt; <br>&gt; for reasons of precision.<br>&gt; <br>&gt; If one has worked with floating point data more often<br>&gt; awareness of its precision limitations become a second nature conscience. <br>&gt; E.g. it is perfectly acceptable and known (also in classical for-loops) that<br>&gt; (0.0…1.0).by(0.1) is not guaranteed to reach the humanly expected value of 1.0.<br>&gt; This is normal. Due to the nature of what mostly is done in the<br>&gt; floating point numbers domain, this does not often cause a problem<br>&gt; (e.g like working with a slide ruler) <br>&gt; if it is important to reach the “expected end” then one could<br>&gt; -add an epsilon value like so (v1…v2 + 0.1) <br>&gt; -generate the desired float sequence within an integer loop.<br>&gt; <br>&gt; <br>&gt; The above “range” (imho) improvement makes the <br>&gt; stride.. function/keyword completely unnecessary.<br>&gt; <br>&gt; Due to its ability to process reversed ranges as is, <br>&gt; the .reverse() is optional (no longer necessary in most cases,<br>&gt; allowing the compiler to optimize without having to process <br>&gt; it like a collection.<br>&gt; <br>&gt; <br>&gt; Now that we have a fully functional range, which can do all things desired, one can<br>&gt; then of course, pass this range without any change  to a collection based for …  e.g.<br>&gt; <br>&gt; for v in (v1…v2).by(v3)   // optionally add other collection operators/filters/sorts here<br>&gt; <br>&gt; (or in any other construct you might see fit)<br>&gt;                                        <br>&gt; <br>&gt; This seems to be a reasonable alternative for<br>&gt; <br>&gt; - the classical for ;; loop<br>&gt; -the collection-free for-loop  <br>&gt;      for v from v1 to v2 by v3<br>&gt; <br>&gt; As you know, the latter is what I have been suggesting, <br>&gt; but seemingly does not find much support,<br>&gt; (because I received very little reactions) <br>&gt; making it doubtful if I will ever make a proposal for this for loop.<br>&gt; Anyone out there should I stil do that? <br>&gt; <br>&gt; When one does not further extend the range<br>&gt; with filters like sort etc. the compiler can still optimize <br>&gt; a collection-in-between out of the way.<br>&gt; (Thank you Taras, für das Mitdenken. :o)<br>&gt; <br>&gt; <br>&gt; **   note that a half open range would in most cases be unnecessary <br>&gt;       if  collection indexes started with 1 instead of 0, e.g. someArray[1…10] <br>&gt;      (but it’s too late to change that.) <br>&gt;      “the color of the first apple?”    vs<br>&gt;      “the color of the zeroth (0) ???  apple?”    ? Silly isn’t? <br>&gt; <br>&gt; *** possible future numerical “native” types <br>&gt; <br>&gt; <br>&gt; It could be that (at least) partly something similar has already been suggested.<br>&gt; but so much is here of this topic that i can’t see the wood for the trees, so to speak.<br>&gt; <br>&gt; <br>&gt; Your (all) opinions are appreciated. <br>&gt; <br>&gt; kind regards, mit freundlichen Grüssen, Met vriendelijke groeten, <br>&gt; Sigh, why do we Dutch always have to speak the languages of the bigger countries :o) <br>&gt; TedvG<br>&gt; <br>&gt;&gt; on Wed Apr 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com &lt;http://erica-at-ericasadun.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;    On Apr 6, 2016, at 12:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;    (0..&lt;199).striding(by: -2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    are even or odd.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (0..&lt;199).striding(by: -2): 0..&lt;199 == 0...198 Even<br>&gt;&gt;&gt; (1..&lt;199).striding(by: -2): 1..&lt;199 == 1...198 Even<br>&gt;&gt; <br>&gt;&gt; I understand the logic that got you there, but I find it incredibly<br>&gt;&gt; counter-intuitive that striding by 2s over a range with odd endpoints<br>&gt;&gt; should produce even numbers... I can&#39;t imagine any way I&#39;d be convinced<br>&gt;&gt; that was a good idea.<br>&gt;&gt; <br>&gt;&gt;&gt; (0..&lt;198).striding(by: -2): 1..&lt;198 == 0...197 Odd<br>&gt;&gt;&gt; (1..&lt;198).striding(by: -2): 1..&lt;198 == 1...197 Odd<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt; <br>&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/a6bbdea3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
