<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>Thank you,<br></p><p>-Chris<br>Review Manager<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160106/1e53ad73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 10:13 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br></p><p>The correct link is:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160106/0edccbd4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>January  9, 2016 at 11:00:00am</p></header><div class="content"><p>https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&gt;<br></p><p>* What is your evaluation of the proposal?<br></p><p>+1<br></p><p>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, the current feature is frustrating. Most notably when:<br>- some stored properties have default values<br>- you want to change the access level of the member-wise init<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I think so. It avoids most boilerplate while staying pretty clear to read.<br></p><p>I see one downside with the chosen syntax: I&#39;m concerned the &quot;...&quot; placeholder might be confusing sometimes.<br></p><p>* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No.<br></p><p>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read carefully the latest version of the proposal. I partly read the discussion thread.<br></p><p>-- <br>Pierre<br></p><p>&gt; Le 6 janv. 2016 à 19:13, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Flexible Memberwise Initialization&quot; begins now and runs through January 10th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/393adb13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5deab55eb13a146b24285407e0e2901?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Roger Turnbull</string> &lt;rogeturnbull at outlook.com&gt;<p>January  9, 2016 at 10:00:00am</p></header><div class="content"><p>Hi there,as others have already pointed out, I think the proposal introduces a lot of new complexity that is not compensated by its advantages:- It is brittle. Changing the order of members is no problem today, but it will break compatibility when initializers are generated in the proposed way. The same is true when you refactor and move a member to a superclass.- No default values for constants- Quite big addition to the language (especially when all possible extensions of the proposal are accepted as well)- The &quot;...&quot; can lead to confusion, there&#39;s to much magic involvedImho the last point is a possibility to improve the proposal in a significant way:The three dots are just a placeholder - why not simply be a little bit more detailed?&gt; init(self x: Int, self y: Int = 0, self z: Int = 0) {}is quite verbose, but the following is more concise yet much easier to understand than &quot;...&quot;init(x, y = 0, z = 0) {}Afaik, single words currently aren&#39;t used in method declarations, so the compiler doesn&#39;t need &quot;self&quot;.I myself am not really happy with this syntax, but at least it really solves some problems:- Less boilerplate (but more than in the proposal)- Default value for constants (better than the proposal)- No &quot;memberwise&quot; keyword required (better)- It&#39;s robust: You can rearrange parameters and members without breaking anything (better)You have to type more characters than &quot;...&quot;, but autocompletion could help here as it does in other situations, and right now, I rarely see initializers with more than three parameters (although this could be caused by the annoying repetition in current initializers).Best regards,Roger 		 	   		  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/5f72407a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 10, 2016 at 11:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>I’m generally in favor of the proposal with a small caveat: <br></p><p>Quite recently a discussion started about an idea by Dave Abrahams and Joe Groff on making use of a more generic approach roughly based on an implicit &quot;members&quot; tuple which requires some language support like forwarding tuples as function arguments and possibly more which would probably be very useful for other use cases besides initialization, e.g. updating an instance with the properties of another instance (usable for mementos or copying) and other things.<br>It is not yet clear how exactly this might look like (Paul Cantrell, myself and others tried to to some initial brain storming on this and I don’t know whether Dave and Joe have more details worked out already) so I do not know yet whether that idea might replace this proposal. As I would prefer to have a more general (and ultimately more powerful) solution if possible I would like to suggest to keep this alternative approach in mind when deciding whether this proposal will be accepted, maybe even by putting the decision on hold for a short time during which to explore the alternate solution space a bit more in detail.<br>Matthew Johnson is currently fleshing out some ideas which might possibly combine both approaches (if I understood correctly). These should be considered as well when deciding whether a more general solution might be preferable.<br>—<br></p><p>On further note I’d like to add that I like marking the memberwise initializer with both a keyword (stands out clearly and is in line with „convenience“) and the „…“ placeholder which makes clear that the initializer takes arguments without them being written out in detail. „…“ is well chosen for that purpose (and can be extended with qualifiers as Matthew did point out if that might become necessary).<br></p><p>I’m against rule #6 of the algorithm as written and request the following change (to fit a suggestion by Kevin Ballard): &quot;If the initializer body assigns to a var property that received memberwise initialization synthesis report a warning if there were no prior reads of this property in the initializer body&quot;<br></p><p><br>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Initialization is a very important part to get right and many languages have deficiencies in that area. I like the design decisions of the Swift team here like designated and convenience initializers. Getting boilerplate removed from the initialization process in a clean way is a good idea.<br></p><p><br>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I think it fits well with the concepts of designated and convenience initializers and strikes the right balance between readability and succinctness.<br></p><p><br>* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Scala has a different approach which puts all properties into the primary initializer argument list which is great for simple cases but starts getting unwieldy fast IMO. <br>Ceylon allows putting the properties into the class’s initializer parameter list (with access modifiers similar to Scala) or alternatively to just put the names of the properties into the class’s parameter list (i.e. without access modifiers or type declarations). If more than one initializer is required Ceylon resorts to something similar to standard Swift initializers, requiring the same boilerplate. I prefer this proposal to both of them as it is much cleaner. <br></p><p><br>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I followed the discussion and did take part in it a little bit. I read the proposal and tried to evaluate the alternate idea with the „members“ tuple. Furthermore I looked up the initialization process of Ceylon and Scala because I couldn’t remember their details.<br></p><p><br>-Thorsten <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/188eea12/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0018 Flexible Memberwise Initialization</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 11, 2016 at 09:00:00am</p></header><div class="content"><p>On Wed, Jan 6, 2016 at 10:13 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt;<br></p><p>Reluctant -1. This is a well-written and well-considered proposal. However,<br>in the end my opinion is that the improvement it brings to the language is<br>not worth the significant increase in complexity it entails.<br></p><p>* Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt;<br></p><p>Boilerplate initializers are obnoxious to write but, as other commenters<br>have mentioned, writing them doesn&#39;t actually account for much of how a<br>programmer&#39;s time is spent writing code. The problem this proposal<br>addresses isn&#39;t one of expressiveness or correctness, it&#39;s one of<br>convenience. Features that increase convenience are great, but the<br>benefit-to-complexity they provide is not all that high.<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>To be honest, I don&#39;t think so. The core team has articulated their desire<br>for Swift to be a small language that lends itself to building great<br>libraries. Adding significant special-purpose syntactic and semantic<br>complexity to the language in order to cut down on some boilerplate does<br>not really serve that goal. (Add to this the fact that initializers are<br>already complex enough as-is.) A cut-down version of this proposal could<br>satisfy the most common use cases for synthesized initializers, with<br>complex cases deferred to a point where we have a better tool for handling<br>them (like a macro system).<br></p><p><br>&gt; * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>n/a<br></p><p><br>&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?<br>&gt;<br></p><p>I&#39;ve read through both relevant discussion threads with varying levels of<br>attentiveness, as well as the proposal itself.<br></p><p>Best,<br>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/1daf9b0e/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
