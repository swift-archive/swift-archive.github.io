<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0108: Remove associated type inference</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0108: Remove associated type inference&quot; begins now and runs through July 4. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0108: Remove associated type inference</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 12:33 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0108: Remove associated type inference&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I don’t like the change to using typealias for explicitly binding the type because typealias already has another completely different meaning (introducing a new name) in the identical context. This smacks of the same problem associated types had back when they were spelled typealias. I also understand why using associatedtype is problematic. We do have a keyword that indicates “this thing is not completely new, but actually replaces the received member”<br></p><p>override associatedtype Element = String<br></p><p>Maybe the objection is verbosity? But it certainly is extremely clear that Element is not a new name being introduced, nor is it introducing a new associatedtype. You could also use “let associatedtype Element = String” if override is too tied up with class inheritance.<br></p><p><br>Binding using a nested type seems odd, though I don’t necessarily object to it.<br></p><p><br></p><p>&gt; If associated type inference were to be removed, C.A would be bound as Int (since there would be no explicit typealias declaration overriding the default type value), and the doSomething() implementation returning Int would be considered to fulfill the protocol requirement. Thus, the semantics of the code listing above would change even though the source itself remained unchanged.<br></p><p><br>This is problematic to me. This proposal introduces the disambiguation syntax so I would say that the compiler should emit an error if this situation arises and require you to explicitly specify what associated type you are binding, ignoring the protocol’s default. It could still warn on doSomething() to let you know there is a potential pitfall.<br></p><p><br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I believe Doug when he says it has negative implications for the type checker.<br></p><p><br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Reading and thinking, following the original discussion thread.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/343f6323/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md<br></p><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I don&#39;t think the time is right.<br></p><p>I&#39;ve been reading the code for Sequence, Collection, and the various protocols that they use (I actually went to bed with an almost finished email for the discussion thread), and I think this is going to be a big problem there. From what I can see, there are two places where they lean heavily on inference for basic usability:<br></p><p>1. `Sequence.SubSequence` has no default type, but it is inferred to be `AnySequence&lt;Iterator.Element&gt;` in the absence of an alternative, because the standard library provides an extension full of `AnySequence&lt;Iterator.Element&gt;`-returning implementations. Honestly, I&#39;m not sure why it doesn&#39;t have a default—some very basic testing in the REPL didn&#39;t seem to show any circularity problems—so my guess is that this one could be resolved.<br></p><p>2. `Collection._Element` (actually `IndexableBase._Element`) is a *hidden* associated type which uses inference to break a nasty loop between `Collection` and `IndexingIterator`. (`IndexingIterator` wants to use the `Iterator.Element` of the collection it&#39;s used with, but if that `Iterator` is itself `IndexingIterator`, that would be a circular definition. Instead, it uses the collection&#39;s `_Element`, which is inferred to be the return type of the index subscript.) Without inference, we would have two options here, neither of them great:<br></p><p>	a. Make `Collection.Element` a publicly visible associated type. Because we don&#39;t have `where` clauses for associated types yet, that would make it very easy to create a Collection whose `Element` and `Iterator.Element` did not match. (If we *do* make it a non-hidden associated type, I would suggest we add same-named generic parameters as another way to implicitly fulfill an associated type requirement; that would handle many collections automatically.)<br></p><p>	b. Make the element type a second generic parameter to `IndexingIterator`. This would effectively prevent us from offering a default `Iterator` on `Collection`s.<br></p><p>Additionally, I believe the other un-defaulted associated types we&#39;d like to infer if we can—`Collection.Index`, `Sequence.Iterator`, and `IteratorProtocol.Element`—could all be handled by simple &quot;caveman inference&quot; heuristics, rather than a full type inference pass. All three of these are used in either the types of un-defaulted properties (which cannot ever be overloaded) or the return types of un-defaulted nullary methods (which can be overloaded but rarely are). If we could use only those limited cases to guess the appropriate types, then plug them in and see if they typecheck, that would go a long way towards softening the blow of removing associated type inference.<br></p><p>So, in summary:<br></p><p>• I think that removing associated type inference will seriously impair Collection&#39;s usability and type-safety.<br></p><p>• I think that these issues ought to be mitigated in the future by new compiler features which we may not have the time to implement before we ship Swift 3.<br></p><p>So I think this change should be deferred to Swift 4, when we&#39;ll have time to add mitigating features. (Or, if you want to add mitigating features, merging this change should be conditioned on the mitigating features being finished too.) If we do it now, we will be breaking code which we will later un-break, and exposing chinks in our protocols&#39; armor which we will later fix. Let&#39;s be patient.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, but I don&#39;t think it&#39;s significant enough to warrant a change in Swift *3*.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes and no; see above.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Much more than I probably should have. :^)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Additionally, I believe the other un-defaulted associated types we&#39;d like to infer if we can—`Collection.Index`, `Sequence.Iterator`, and `IteratorProtocol.Element`—could all be handled by simple &quot;caveman inference&quot; heuristics, rather than a full type inference pass. All three of these are used in either the types of un-defaulted properties (which cannot ever be overloaded) or the return types of un-defaulted nullary methods (which can be overloaded but rarely are). If we could use only those limited cases to guess the appropriate types, then plug them in and see if they typecheck, that would go a long way towards softening the blow of removing associated type inference.<br></p><p>I’m curious about this too. It seems too easy...<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/365797e5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 4:38 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I don&#39;t think the time is right.<br>&gt; <br>&gt; I&#39;ve been reading the code for Sequence, Collection, and the various protocols that they use (I actually went to bed with an almost finished email for the discussion thread), and I think this is going to be a big problem there. From what I can see, there are two places where they lean heavily on inference for basic usability:<br>&gt; <br>&gt; 1. `Sequence.SubSequence` has no default type, but it is inferred to be `AnySequence&lt;Iterator.Element&gt;` in the absence of an alternative, because the standard library provides an extension full of `AnySequence&lt;Iterator.Element&gt;`-returning implementations. Honestly, I&#39;m not sure why it doesn&#39;t have a default—some very basic testing in the REPL didn&#39;t seem to show any circularity problems—so my guess is that this one could be resolved.<br>&gt; <br>&gt; 2. `Collection._Element` (actually `IndexableBase._Element`) is a *hidden* associated type which uses inference to break a nasty loop between `Collection` and `IndexingIterator`. (`IndexingIterator` wants to use the `Iterator.Element` of the collection it&#39;s used with, but if that `Iterator` is itself `IndexingIterator`, that would be a circular definition. Instead, it uses the collection&#39;s `_Element`, which is inferred to be the return type of the index subscript.) Without inference, we would have two options here, neither of them great:<br>&gt; <br>&gt; 	a. Make `Collection.Element` a publicly visible associated type. Because we don&#39;t have `where` clauses for associated types yet, that would make it very easy to create a Collection whose `Element` and `Iterator.Element` did not match. (If we *do* make it a non-hidden associated type, I would suggest we add same-named generic parameters as another way to implicitly fulfill an associated type requirement; that would handle many collections automatically.)<br>&gt; <br>&gt; 	b. Make the element type a second generic parameter to `IndexingIterator`. This would effectively prevent us from offering a default `Iterator` on `Collection`s.<br>&gt; <br>&gt; Additionally, I believe the other un-defaulted associated types we&#39;d like to infer if we can—`Collection.Index`, `Sequence.Iterator`, and `IteratorProtocol.Element`—could all be handled by simple &quot;caveman inference&quot; heuristics, rather than a full type inference pass. All three of these are used in either the types of un-defaulted properties (which cannot ever be overloaded) or the return types of un-defaulted nullary methods (which can be overloaded but rarely are). If we could use only those limited cases to guess the appropriate types, then plug them in and see if they typecheck, that would go a long way towards softening the blow of removing associated type inference.<br>&gt; <br>&gt; So, in summary:<br>&gt; <br>&gt; • I think that removing associated type inference will seriously impair Collection&#39;s usability and type-safety.<br></p><p>The usability argument I understand. It’s a big, open question. I hacked up a flag for swiftc (-Xfrontend -disable-associated-type-witness-inference) on this branch:<br></p><p>	https://github.com/apple/swift/tree/disable-associated-type-witness-inference<br></p><p>that simply disables associated type witness inference so we can experiment. If we do nothing to the standard library, the experience is awful for (e.g.) the case of a type that minimally conforms to today’s Collection. But we knew the standard library would need changes, because it heavily depends on this inference today, so we won’t have a good sense of what we can accomplish until someone actually tries to work with the proposed restriction. I, personally, don’t have the time to invest in this right now :(<br></p><p>&gt; • I think that these issues ought to be mitigated in the future by new compiler features which we may not have the time to implement before we ship Swift 3.<br></p><p>You&#39;re talking about recursive protocol constraints (which would help collapse some of the underscored protocols) and where clauses on associated types in particular?<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  1, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 10:55 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; You&#39;re talking about recursive protocol constraints (which would help collapse some of the underscored protocols) and where clauses on associated types in particular?<br></p><p>I&#39;m also talking about &quot;caveman inference&quot; if that&#39;s judged to be a good idea for usability, and anything else we need to make associated types ergonomic despite the loss of inference. (One underdeveloped thought I just had: keep the inference engine around and use it to suggest fix-its for unspecified associated types.)<br></p><p>Ultimately what I&#39;m saying is this: Removing associated type inference is going to impact a lot of code. We can see the impact in the standard library, but we must also remember that it will impact user code, and users will not have Dave Abrahams around to redesign their protocols for them.<br></p><p>Now, the standard library *is* a bit of a special case: In some areas—particularly Collection and its ilk—it is very aggressively designed right to the ragged edge of what Swift supports. But in other areas, it is the canary in the coal mine. If we find that, say, FloatingPoint is significantly more burdensome to conform to without redesigning it, that means many protocols in user code will be too.<br></p><p>Normally, we ship things incrementally, but here I think we need to make an exception: This proposal will make a gigantic mess, and we cannot ship it until we&#39;ve cleaned that mess up. That means we ought to think long and hard, right now, about whether September is a reasonable deadline to not only rip out associated types, not only redesign the standard library to clean up the problems it creates, but also add whatever features are necessary to compensate for the removal. And if we don&#39;t think we can, we should defer until we have the time to finish the job.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 29, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I’m going to stay neutral.  The motivation is implementation focused and I am not qualified to adequately assess it.<br></p><p>It does sound like it might be necessary to do this (at least temporarily) in order to facilitate evolution of other generics features.  However, as I stated in the discussion, I do consider it unfortunate.  The language has this feature for a good reason and that hasn’t changed.  If we do remove this feature we should be very certain that it is necessary.<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>It sounds like the implementation complexities are significant enough to warrant a change.  I trust the core team to asses that.  <br></p><p>If it weren’t for implementation considerations I wouldn’t believe there is a problem.  I think associated type inference is a particularly elegant feature, not a problem.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I suppose it does in the sense that a major them of Swift 3 is to clean up areas of the language that didn’t work out as hoped or intended.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have not actively used them in real projects, but I have spent significant time studying functional languages where inference is a hallmark feature.  Inference can be an extremely elegant feature.  It can also be pushed too far when it can hinder clarity and readability.  <br></p><p>Swift attempts to strike a careful balance here and does a pretty good job of it.  However, there is *no* case where I think Swift takes inference too far (in terms of impact on clarity and readability), including associated type inference.  Reducing Swift’s inference capabilities feels like a step backwards to me.  I believe associated type inference *increases* clarity and readability.  <br></p><p>It’s worth pointing out that manually providing associated type bindings is valid in Swift today, yet it is rare to do so explicitly using a typealias when implementing a conformance.  I believe this is anecdotal evidence that the community generally finds that leaning on inference of associated types *increases* clarity and readability and values this feature. <br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Careful consideration of the implementation issues, the proposed solution, and the impact on users of the language.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md&gt; ]<br></p><p>I’m pretty concerned about completely removing this feature. Yes, it’s a type-checker / decl-checker nightmare, but I think Paolo’s example in the initial discussion showed how it’s being used effectively today. I’d much rather have some kind of inference marker that maps one-to-one between an associated type and a value requirement (method, initializer, property, or subscript), also as brought up in the original discussion. <br></p><p>protocol OptionA {<br>  associatedtype Index<br></p><p>  @infers(Index)<br>  var startIndex: Index { get }<br></p><p>  var endIndex: Index { get }<br>}<br></p><p>protocol OptionB {<br>  @inferredFrom(startIndex) // allows a full name here for overload resolution<br>  associatedtype Index<br></p><p>  var startIndex: Index { get }<br>  var endIndex: Index { get }<br>} <br></p><p>protocol OptionC {<br>  associatedtype Index in startIndex // sugar<br></p><p>  var startIndex: Index { get }<br>  var endIndex: Index { get }<br>}<br></p><p>OptionC is the prettiest, but OptionA is probably the most flexible (consider overloading on associated types).<br></p><p>I know we want to lock down on things now, and I know we can do better in the future, but I think inferring associated types is really quite common, and I’m concerned about taking it out without giving people a good alternative. This is just an impression, though.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/167507b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>+ 1<br>        * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br>Yes. When inference goes wrong it is frustrating and difficult to puzzle<br>out.<br>        * Does this proposal fit well with the feel and direction of Swift?<br>Yes. I agree that a keyword for explicitly invoking inference would also<br>work if it meant that the process would be consistent. The ability to add<br>type aliases to protocol extensions is welcome as well.<br>        * If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br>A couple readings.<br></p><p>On Thu, Jun 30, 2016 at 7:23 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; [Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md<br>&gt;  ]<br>&gt;<br>&gt; I’m pretty concerned about completely removing this feature. Yes, it’s a<br>&gt; type-checker / decl-checker nightmare, but I think Paolo’s example in the<br>&gt; initial discussion showed how it’s being used effectively today. I’d much<br>&gt; rather have some kind of inference marker that maps one-to-one between an<br>&gt; associated type and a value requirement (method, initializer, property, or<br>&gt; subscript), also as brought up in the original discussion.<br>&gt;<br>&gt; protocol OptionA {<br>&gt;   associatedtype Index<br>&gt;<br>&gt;   @infers(Index)<br>&gt;   var startIndex: Index { get }<br>&gt;<br>&gt;   var endIndex: Index { get }<br>&gt; }<br>&gt;<br>&gt; protocol OptionB {<br>&gt;   @inferredFrom(startIndex) // allows a full name here for overload<br>&gt; resolution<br>&gt;   associatedtype Index<br>&gt;<br>&gt;   var startIndex: Index { get }<br>&gt;   var endIndex: Index { get }<br>&gt; }<br>&gt;<br>&gt; protocol OptionC {<br>&gt;   associatedtype Index in startIndex // sugar<br>&gt;<br>&gt;   var startIndex: Index { get }<br>&gt;   var endIndex: Index { get }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; OptionC is the prettiest, but OptionA is probably the most flexible<br>&gt; (consider overloading on associated types).<br>&gt;<br>&gt; I know we want to lock down on things now, and I know we can do better in<br>&gt; the future, but I think inferring associated types is really quite common,<br>&gt; and I’m concerned about taking it out without giving people a good<br>&gt; alternative. This *is* just an impression, though.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/9b7c8997/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>July  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 4:23 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md&gt; ]<br>&gt; <br>&gt; I’m pretty concerned about completely removing this feature. Yes, it’s a type-checker / decl-checker nightmare, but I think Paolo’s example in the initial discussion showed how it’s being used effectively today. I’d much rather have some kind of inference marker that maps one-to-one between an associated type and a value requirement (method, initializer, property, or subscript), also as brought up in the original discussion. <br>&gt; <br>&gt; protocol OptionA {<br>&gt;   associatedtype Index<br>&gt; <br>&gt;   @infers(Index)<br>&gt;   var startIndex: Index { get }<br>&gt; <br>&gt;   var endIndex: Index { get }<br>&gt; }<br>&gt; <br>&gt; protocol OptionB {<br>&gt;   @inferredFrom(startIndex) // allows a full name here for overload resolution<br>&gt;   associatedtype Index<br>&gt; <br>&gt;   var startIndex: Index { get }<br>&gt;   var endIndex: Index { get }<br>&gt; } <br>&gt; <br>&gt; protocol OptionC {<br>&gt;   associatedtype Index in startIndex // sugar<br>&gt; <br>&gt;   var startIndex: Index { get }<br>&gt;   var endIndex: Index { get }<br>&gt; }<br>&gt; <br>&gt; OptionC is the prettiest, but OptionA is probably the most flexible (consider overloading on associated types).<br>&gt; <br>&gt; I know we want to lock down on things now, and I know we can do better in the future, but I think inferring associated types is really quite common, and I’m concerned about taking it out without giving people a good alternative. This is just an impression, though.<br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I’m trying to fill a gap in my own knowledge here. How does explicitly stating that startIndex is the inference point for Index help? <br></p><p>Is it because various extensions and default implementations can provide different concrete types for Index, so the type checker is trying to resolve the ambiguity? If that’s the case, specifying startIndex here restricts the defaults/extensions that need to be considered from all to just ones that implement startIndex? Is that good enough generally or does it just solve the standard library’s problems?<br></p><p>Would it be enough to have rules along these lines for a concrete type adopting a protocol with associated types?<br></p><p>1. If the type’s main declaration (not defaults or extensions) contains a member satisfying a protocol requirement (where the requirement is specified in terms of an associated type) the associated type is locked to the type used in that member, so no global inference is necessary. If more than one such member is present all must use the same exact type.<br>2. Otherwise if there exists only one default/extension satisfying the associated type, the type used in that default implementation is used.<br>3. In all other cases the user must specify the associated types explicitly.<br></p><p>Apologies if this is stuff I should already know.<br></p><p>Russ<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/79a0cbca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 15:53, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 4:23 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md&gt; ]<br>&gt;&gt; <br>&gt;&gt; I’m pretty concerned about completely removing this feature. Yes, it’s a type-checker / decl-checker nightmare, but I think Paolo’s example in the initial discussion showed how it’s being used effectively today. I’d much rather have some kind of inference marker that maps one-to-one between an associated type and a value requirement (method, initializer, property, or subscript), also as brought up in the original discussion. <br>&gt;&gt; <br>&gt;&gt; protocol OptionA {<br>&gt;&gt;   associatedtype Index<br>&gt;&gt; <br>&gt;&gt;   @infers(Index)<br>&gt;&gt;   var startIndex: Index { get }<br>&gt;&gt; <br>&gt;&gt;   var endIndex: Index { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol OptionB {<br>&gt;&gt;   @inferredFrom(startIndex) // allows a full name here for overload resolution<br>&gt;&gt;   associatedtype Index<br>&gt;&gt; <br>&gt;&gt;   var startIndex: Index { get }<br>&gt;&gt;   var endIndex: Index { get }<br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; protocol OptionC {<br>&gt;&gt;   associatedtype Index in startIndex // sugar<br>&gt;&gt; <br>&gt;&gt;   var startIndex: Index { get }<br>&gt;&gt;   var endIndex: Index { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; OptionC is the prettiest, but OptionA is probably the most flexible (consider overloading on associated types).<br>&gt;&gt; <br>&gt;&gt; I know we want to lock down on things now, and I know we can do better in the future, but I think inferring associated types is really quite common, and I’m concerned about taking it out without giving people a good alternative. This is just an impression, though.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I’m trying to fill a gap in my own knowledge here. How does explicitly stating that startIndex is the inference point for Index help? <br>&gt; <br>&gt; Is it because various extensions and default implementations can provide different concrete types for Index, so the type checker is trying to resolve the ambiguity? If that’s the case, specifying startIndex here restricts the defaults/extensions that need to be considered from all to just ones that implement startIndex? Is that good enough generally or does it just solve the standard library’s problems?<br>&gt; <br>&gt; Would it be enough to have rules along these lines for a concrete type adopting a protocol with associated types?<br>&gt; <br>&gt; 1. If the type’s main declaration (not defaults or extensions) contains a member satisfying a protocol requirement (where the requirement is specified in terms of an associated type) the associated type is locked to the type used in that member, so no global inference is necessary. If more than one such member is present all must use the same exact type.<br>&gt; 2. Otherwise if there exists only one default/extension satisfying the associated type, the type used in that default implementation is used.<br>&gt; 3. In all other cases the user must specify the associated types explicitly.<br></p><p>I don&#39;t remember exactly how the current rules work, but I think the compiler looks at all the members that mention an associated type and tries to figure out if they&#39;re all in sync. Reducing that to just looking at one value requirement might be enough to satisfy Doug&#39;s concerns, even if it still has to do overload resolution…or you could follow the spirit of your rule 2 and say that any overloads force you to specify the element type explicitly.<br></p><p>Rule 1, however, is the important one: &quot;if more than one such member is present all must use the same exact type&quot;. I think that&#39;s already moving into the realm of spooky action and circularity issues that Doug&#39;s attempting to squash.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/9cc142c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0108: Remove associated type inference</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 10:43 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 1, 2016, at 15:53, Russ Bishop &lt;xenadu at gmail.com &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 4:23 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md&gt; ]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m pretty concerned about completely removing this feature. Yes, it’s a type-checker / decl-checker nightmare, but I think Paolo’s example in the initial discussion showed how it’s being used effectively today. I’d much rather have some kind of inference marker that maps one-to-one between an associated type and a value requirement (method, initializer, property, or subscript), also as brought up in the original discussion. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol OptionA {<br>&gt;&gt;&gt;   associatedtype Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   @infers(Index)<br>&gt;&gt;&gt;   var startIndex: Index { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var endIndex: Index { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol OptionB {<br>&gt;&gt;&gt;   @inferredFrom(startIndex) // allows a full name here for overload resolution<br>&gt;&gt;&gt;   associatedtype Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var startIndex: Index { get }<br>&gt;&gt;&gt;   var endIndex: Index { get }<br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol OptionC {<br>&gt;&gt;&gt;   associatedtype Index in startIndex // sugar<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var startIndex: Index { get }<br>&gt;&gt;&gt;   var endIndex: Index { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; OptionC is the prettiest, but OptionA is probably the most flexible (consider overloading on associated types).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know we want to lock down on things now, and I know we can do better in the future, but I think inferring associated types is really quite common, and I’m concerned about taking it out without giving people a good alternative. This is just an impression, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; I’m trying to fill a gap in my own knowledge here. How does explicitly stating that startIndex is the inference point for Index help? <br>&gt;&gt; <br>&gt;&gt; Is it because various extensions and default implementations can provide different concrete types for Index, so the type checker is trying to resolve the ambiguity? If that’s the case, specifying startIndex here restricts the defaults/extensions that need to be considered from all to just ones that implement startIndex? Is that good enough generally or does it just solve the standard library’s problems?<br>&gt;&gt; <br>&gt;&gt; Would it be enough to have rules along these lines for a concrete type adopting a protocol with associated types?<br>&gt;&gt; <br>&gt;&gt; 1. If the type’s main declaration (not defaults or extensions) contains a member satisfying a protocol requirement (where the requirement is specified in terms of an associated type) the associated type is locked to the type used in that member, so no global inference is necessary. If more than one such member is present all must use the same exact type.<br>&gt;&gt; 2. Otherwise if there exists only one default/extension satisfying the associated type, the type used in that default implementation is used.<br>&gt;&gt; 3. In all other cases the user must specify the associated types explicitly.<br>&gt; <br>&gt; I don&#39;t remember exactly how the current rules work, but I think the compiler looks at all the members that mention an associated type and tries to figure out if they&#39;re all in sync. Reducing that to just looking at one value requirement might be enough to satisfy Doug&#39;s concerns, even if it still has to do overload resolution…or you could follow the spirit of your rule 2 and say that any overloads force you to specify the element type explicitly.<br></p><p>The compiler currently looks at all of the requirements that mention any of the associated types, then matches each requirement up to all potential declarations that might satisfy the requirement (whether they come from the concrete type, its extensions, or some protocol extension doesn’t matter) to infer potential types for each associated type requirement. A potential solution to the problem assigns a type for each associated type requirement, which then needs to be checked as a whole (e.g., did the type we infer for SubSequence meet the Sequence requirement, and is its Element type the same as our Element type?). When there are multiple possible solutions, they’re ranked based on which declarations were used to satisfy a particular requirement—a declaration from the concrete type is usually better than one from a protocol extension, for example—so one solution can be chosen.<br></p><p>And, really, you should be doing this for all protocol conformances at once, because they often share associated type names. That’s not implemented.<br></p><p>So, back to the restriction: it certainly does help to only be considering one *requirement* for each inferrable associated type, but you’re still considering each possible declaration that can satisfy that requirement. It reduces the state space, but you’re still looking at complete solutions across several associated types and potential declarations that satisfy each requirement we inferred from.<br></p><p><br>&gt; Rule 1, however, is the important one: &quot;if more than one such member is present all must use the same exact type&quot;. I think that&#39;s already moving into the realm of spooky action and circularity issues that Doug&#39;s attempting to squash.<br></p><p>We already implement Rule 1.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/40b541a3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
