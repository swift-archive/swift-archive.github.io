<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 10, 2016 at 03:00:00pm</p></header><div class="content"><p>(This proposal came from thinking about the memberwise initializer proposal as well as older proposals for &quot;cascading&quot; and creating scopes making some members act like local variables.)<br></p><p>I&#39;d like to propose a syntax to set multiple properties at once. It would look like this:<br></p><p>	var object = MyObject()<br>	object .= (<br>		property1: 1,<br>		property2: &quot;a&quot;<br>	)<br></p><p>and be equivalent to this:<br></p><p>	var object = MyObject()<br>	object.property1 = 1<br>	object.property2 = &quot;a&quot;<br>	<br>What the `.=` operator does is take each value in the tuple on the right and assign them to the property of the same name on the variable on the left. Assignments are performed in the same order as they&#39;re defined in the tuple.<br></p><p>The tuple on the left of the `.=` operator can be written on the spot (as above) or be the result of an arbitrary expression, like here:<br></p><p>	var object = MyObject()<br></p><p>	var values = (property1: 1, property2: &quot;b&quot;)<br>	object .= values<br></p><p>	func makeValuesFor(value: Int) -&gt; (property1: Int, property2: String) {<br>		return (value, &quot;\(value)&quot;)<br>	}<br>	object .= makeValuesFor(4)<br></p><p>If the tuple contains property names that do not exist in the assigned variable, or if there is a mismatch in type or visibility and the assignment cannot happen, this is a compile-time error.<br></p><p>This syntax is particularly beneficial when assigning to properties of a deeply nested value:<br></p><p>	object.subpart.detail.numberPad .= (<br>		radix: 9<br>		position: .Top<br>		font: .System<br>	)<br></p><p><br>## Tentative Implementation<br></p><p>It&#39;s almost possible already to implement this with reflection. Here&#39;s an attempt (using a different operator name because `.=` doesn&#39;t work as a custom operator):<br></p><p>	infix operator ~= {  }<br></p><p>	func ~= &lt;T&gt;(inout target: T, values: (a: Int, b: String)) {<br>		let valuesMirror = Mirror(reflecting: values)<br>		let targetMirror = Mirror(reflecting: target)<br>		valueLoop: for valueField in valuesMirror.children {<br>			guard let label = valueField.label else {<br>				fatalError(&quot;Missing label in value tuple.&quot;)<br>			}<br>			for targetField in targetMirror.children {<br>				print(targetField)<br>				if targetField.label == label {<br>					targetField.value = valueField.value<br>					continue valueLoop<br>				}<br>			}<br>		}<br>	}<br></p><p>This fails because you can&#39;t assign to fields using the Mirror API. If this line could be replaced by something that works:<br></p><p>	targetField.value = valueField.value<br></p><p>then we could have a library implementation.<br></p><p><br>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 11, 2016 at 12:00:00am</p></header><div class="content"><p>Methods like &quot;setValuesForKeysWithDictionary&quot; can indeed be very handy — but its name is quite verbose, and imho that isn&#39;t that bad:<br>It&#39;s hard to guess the meaning of &quot;.=&quot; (I&#39;d prefer &quot;&lt;-&quot; instead, but I guess depending on the background of the reader, this may be as hard to understand)<br></p><p>A method with the functionality would be nice, and the possibility of compile time checking would make it better than the variant with dictionaries — but to make the check working, this method would need special treatment by the compiler, and that would appear strange to me.<br></p><p>You&#39;ve written about the older proposal sketches for cascading; have you seen the following idea?<br>object.{<br>	property1 = 1<br>	property2 = &quot;a&quot;<br>}<br>It is a less flexible in some aspect (the tuple in your draft could be created by a function call*), but is even more concise (not much, though) and can be used for more than assigning properties.<br></p><p>Best regards,<br>Tino<br></p><p>* If you continue with your draft, I suggest to explore this possibility further: With a function to turn members of an existing object into a tuple, or the option to selectively remove elements from a tuple, it could be a handy way to create copies.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/74b2be3f33e2efebef65c9a48c32872a?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Angelo Villegas</string> &lt;gelo.web at gmail.com&gt;<p>January 11, 2016 at 03:00:00am</p></header><div class="content"><p>I think the &quot;&lt;-&quot; operator is better than &quot;.=&quot;. This and cascade style assignment would be a good team for me. <br>object &lt;- {    prop1: value1,    prop2: value2}<br></p><p>    _____________________________<br>From: Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt;<br>Sent: Monday, January 11, 2016 7:12 AM<br>Subject: Re: [swift-evolution] Draft proposal: multi-property assignment .= operator<br>To: Michel Fortin &lt;michel.fortin at michelf.ca&gt;<br>Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br></p><p><br>Methods like &quot;setValuesForKeysWithDictionary&quot; can indeed be very handy — but its name is quite verbose, and imho that isn&#39;t that bad:<br>It&#39;s hard to guess the meaning of &quot;.=&quot; (I&#39;d prefer &quot;&lt;-&quot; instead, but I guess depending on the background of the reader, this may be as hard to understand)<br></p><p>A method with the functionality would be nice, and the possibility of compile time checking would make it better than the variant with dictionaries — but to make the check working, this method would need special treatment by the compiler, and that would appear strange to me.<br></p><p>You&#39;ve written about the older proposal sketches for cascading; have you seen the following idea?<br>object.{<br>	property1 = 1<br>	property2 = &quot;a&quot;<br>}<br>It is a less flexible in some aspect (the tuple in your draft could be created by a function call*), but is even more concise (not much, though) and can be used for more than assigning properties.<br></p><p>Best regards,<br>Tino<br></p><p>* If you continue with your draft, I suggest to explore this possibility further: With a function to turn members of an existing object into a tuple, or the option to selectively remove elements from a tuple, it could be a handy way to create copies.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/85a6e39c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January 11, 2016 at 12:00:00am</p></header><div class="content"><p>I don’t know if this is too different from what you are wanting to do. But this can done with Swift now.<br></p><p>https://github.com/joalbright/Inlinit (can be used as a CocoaPod or with SwiftPM)<br></p><p>struct Person: Inlinit {<br></p><p>    var age: Int = 0<br>    var name: String?<br></p><p>}<br></p><p>// initialize &amp; set properties<br>var me = Person {<br></p><p>    $0.name = &quot;Jo&quot;<br>    $0.age = 32<br></p><p>}<br></p><p>// update properties<br>me &lt;- {<br></p><p>    $0.age = 30<br>    $0.name = &quot;John&quot;<br></p><p>}<br></p><p><br>Designer . Developer .  Nerd <br>Jo Albright<br></p><p><br>&gt; On Jan 10, 2016, at 10:05 PM, Angelo Villegas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the &quot;&lt;-&quot; operator is better than &quot;.=&quot;. This and cascade style assignment would be a good team for me. <br>&gt; <br>&gt; object &lt;- {<br>&gt;     prop1: value1,<br>&gt;     prop2: value2<br>&gt; }<br>&gt; _____________________________<br>&gt; From: Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Sent: Monday, January 11, 2016 7:12 AM<br>&gt; Subject: Re: [swift-evolution] Draft proposal: multi-property assignment .= operator<br>&gt; To: Michel Fortin &lt;michel.fortin at michelf.ca &lt;mailto:michel.fortin at michelf.ca&gt;&gt;<br>&gt; Cc: swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; <br>&gt; <br>&gt; Methods like &quot;setValuesForKeysWithDictionary&quot; can indeed be very handy — but its name is quite verbose, and imho that isn&#39;t that bad:<br>&gt; It&#39;s hard to guess the meaning of &quot;.=&quot; (I&#39;d prefer &quot;&lt;-&quot; instead, but I guess depending on the background of the reader, this may be as hard to understand)<br>&gt; <br>&gt; A method with the functionality would be nice, and the possibility of compile time checking would make it better than the variant with dictionaries — but to make the check working, this method would need special treatment by the compiler, and that would appear strange to me.<br>&gt; <br>&gt; You&#39;ve written about the older proposal sketches for cascading; have you seen the following idea?<br>&gt; object.{<br>&gt; property1 = 1<br>&gt; property2 = &quot;a&quot;<br>&gt; }<br>&gt; It is a less flexible in some aspect (the tuple in your draft could be created by a function call*), but is even more concise (not much, though) and can be used for more than assigning properties.<br>&gt; <br>&gt; Best regards,<br>&gt; Tino<br>&gt; <br>&gt; * If you continue with your draft, I suggest to explore this possibility further: With a function to turn members of an existing object into a tuple, or the option to selectively remove elements from a tuple, it could be a handy way to create copies.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/9dcd6353/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 11, 2016 at 08:00:00am</p></header><div class="content"><p>Le 10 janv. 2016 à 18:12, Tino Heth &lt;2th at gmx.de&gt; a écrit :<br></p><p>&gt; Methods like &quot;setValuesForKeysWithDictionary&quot; can indeed be very handy — but its name is quite verbose, and imho that isn&#39;t that bad:<br>&gt; It&#39;s hard to guess the meaning of &quot;.=&quot; (I&#39;d prefer &quot;&lt;-&quot; instead, but I guess depending on the background of the reader, this may be as hard to understand)<br></p><p>I choose `.=` because it&#39;s an assignment (hence `=`) to member properties (hence `.`). What is the meaning of `&lt;-`?<br></p><p>&gt; A method with the functionality would be nice, and the possibility of compile time checking would make it better than the variant with dictionaries — but to make the check working, this method would need special treatment by the compiler, and that would appear strange to me.<br></p><p>What I&#39;m proposing is to use a tuple, not a dictionary. With a tuple, the &quot;keys&quot; are always known at compile time because they&#39;re part of the type.<br></p><p>&gt; You&#39;ve written about the older proposal sketches for cascading; have you seen the following idea?<br>&gt; object.{<br>&gt; 	property1 = 1<br>&gt; 	property2 = &quot;a&quot;<br>&gt; }<br>&gt; <br>&gt; It is a less flexible in some aspect (the tuple in your draft could be created by a function call*), but is even more concise (not much, though) and can be used for more than assigning properties.<br></p><p>Sure I&#39;ve seen it. It&#39;s a completely different concept though: the braces suggest that you have code inside, not a list of values. Because you&#39;re bringing all the members in the local scope in that block, it makes unintended ambiguities and/or shadowing inside this code much more likely (you already have global + self members + local scope variables, now you&#39;re adding member variables from elsewhere that can shadow even your local variables). I&#39;m sure I pointed this out before in an older thread. The tuple-assignement version has no such problem.<br></p><p>&gt; * If you continue with your draft, I suggest to explore this possibility further: With a function to turn members of an existing object into a tuple, or the option to selectively remove elements from a tuple, it could be a handy way to create copies.<br></p><p>I probably won&#39;t pursue it further since the general response was not much positive.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/04a3fc14ec0008acf8d406c93e23c3ae?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Jesse Rusak</string> &lt;me at jesserusak.com&gt;<p>January 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 8:40 AM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; * If you continue with your draft, I suggest to explore this possibility further: With a function to turn members of an existing object into a tuple, or the option to selectively remove elements from a tuple, it could be a handy way to create copies.<br>&gt; <br>&gt; I probably won&#39;t pursue it further since the general response was not much positive.<br></p><p>For what it’s worth, I think this is a good idea. I actually think that this is a nice stepping stone towards general solutions which help to reduce boilerplate, e.g. in initializers. For example, if you could refer to the arguments passed to the current function with some keyword (as in “arguments” in JS) then you could define relatively-concise and flexible initializers with something like:<br></p><p>struct Foo {<br>   let a: Int<br>   let b: String<br></p><p>   init(a: Int, b: String = “&quot;) {<br>      self .= $arguments<br>   }<br>}<br></p><p>In this case I think the “.=” would have to be a language feature in order to allow that assignment to statically satisfy the initialization requirements for a &amp; b. <br></p><p>- Jesse<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; What is the meaning of `&lt;-`?<br>It&#39;s an assignment-operator in some other languages (S/R, maybe more I&#39;m not aware of).<br>Those languages don&#39;t use the &quot;arrow&quot; like C++ does, but to express that data should be stored:<br>calculate(input) -&gt; output<br>output &lt;- calculate(input)<br>have the same effect.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 12:21 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (This proposal came from thinking about the memberwise initializer proposal as well as older proposals for &quot;cascading&quot; and creating scopes making some members act like local variables.)<br>&gt; <br>&gt; I&#39;d like to propose a syntax to set multiple properties at once. It would look like this:<br>&gt; <br>&gt; 	var object = MyObject()<br>&gt; 	object .= (<br>&gt; 		property1: 1,<br>&gt; 		property2: &quot;a&quot;<br>&gt; 	)<br>&gt; <br>&gt; and be equivalent to this:<br>&gt; <br>&gt; 	var object = MyObject()<br>&gt; 	object.property1 = 1<br>&gt; 	object.property2 = &quot;a&quot;<br>&gt; 	<br>&gt; What the `.=` operator does is take each value in the tuple on the right and assign them to the property of the same name on the variable on the left. Assignments are performed in the same order as they&#39;re defined in the tuple.<br></p><p>For me, the scale of the problem isn’t large enough to warrant a language feature, especially given that...<br></p><p>&gt; ## Tentative Implementation<br>&gt; <br>&gt; It&#39;s almost possible already to implement this with reflection. Here&#39;s an attempt (using a different operator name because `.=` doesn&#39;t work as a custom operator):<br>&gt; <br>&gt; 	infix operator ~= {  }<br>&gt; <br>&gt; 	func ~= &lt;T&gt;(inout target: T, values: (a: Int, b: String)) {<br>&gt; 		let valuesMirror = Mirror(reflecting: values)<br>&gt; 		let targetMirror = Mirror(reflecting: target)<br>&gt; 		valueLoop: for valueField in valuesMirror.children {<br>&gt; 			guard let label = valueField.label else {<br>&gt; 				fatalError(&quot;Missing label in value tuple.&quot;)<br>&gt; 			}<br>&gt; 			for targetField in targetMirror.children {<br>&gt; 				print(targetField)<br>&gt; 				if targetField.label == label {<br>&gt; 					targetField.value = valueField.value<br>&gt; 					continue valueLoop<br>&gt; 				}<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; This fails because you can&#39;t assign to fields using the Mirror API. If this line could be replaced by something that works:<br>&gt; <br>&gt; 	targetField.value = valueField.value<br>&gt; <br>&gt; then we could have a library implementation.<br></p><p><br>Assigning to fields using the Mirror API is a completely reasonable feature to add.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 11, 2016 at 08:00:00am</p></header><div class="content"><p>Le 10 janv. 2016 à 22:29, Douglas Gregor &lt;dgregor at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 12:21 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; (This proposal came from thinking about the memberwise initializer proposal as well as older proposals for &quot;cascading&quot; and creating scopes making some members act like local variables.)<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to propose a syntax to set multiple properties at once. It would look like this:<br>&gt;&gt; <br>&gt;&gt; 	var object = MyObject()<br>&gt;&gt; 	object .= (<br>&gt;&gt; 		property1: 1,<br>&gt;&gt; 		property2: &quot;a&quot;<br>&gt;&gt; 	)<br>&gt;&gt; <br>&gt;&gt; and be equivalent to this:<br>&gt;&gt; <br>&gt;&gt; 	var object = MyObject()<br>&gt;&gt; 	object.property1 = 1<br>&gt;&gt; 	object.property2 = &quot;a&quot;<br>&gt;&gt; 	<br>&gt;&gt; What the `.=` operator does is take each value in the tuple on the right and assign them to the property of the same name on the variable on the left. Assignments are performed in the same order as they&#39;re defined in the tuple.<br>&gt; <br>&gt; For me, the scale of the problem isn’t large enough to warrant a language feature, especially given that...<br>&gt; <br>&gt;&gt; ## Tentative Implementation<br>&gt;&gt; <br>&gt;&gt; It&#39;s almost possible already to implement this with reflection. Here&#39;s an attempt (using a different operator name because `.=` doesn&#39;t work as a custom operator):<br>&gt;&gt; <br>&gt;&gt; 	infix operator ~= {  }<br>&gt;&gt; <br>&gt;&gt; 	func ~= &lt;T&gt;(inout target: T, values: (a: Int, b: String)) {<br>&gt;&gt; 		let valuesMirror = Mirror(reflecting: values)<br>&gt;&gt; 		let targetMirror = Mirror(reflecting: target)<br>&gt;&gt; 		valueLoop: for valueField in valuesMirror.children {<br>&gt;&gt; 			guard let label = valueField.label else {<br>&gt;&gt; 				fatalError(&quot;Missing label in value tuple.&quot;)<br>&gt;&gt; 			}<br>&gt;&gt; 			for targetField in targetMirror.children {<br>&gt;&gt; 				print(targetField)<br>&gt;&gt; 				if targetField.label == label {<br>&gt;&gt; 					targetField.value = valueField.value<br>&gt;&gt; 					continue valueLoop<br>&gt;&gt; 				}<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; This fails because you can&#39;t assign to fields using the Mirror API. If this line could be replaced by something that works:<br>&gt;&gt; <br>&gt;&gt; 	targetField.value = valueField.value<br>&gt;&gt; <br>&gt;&gt; then we could have a library implementation.<br>&gt; <br>&gt; Assigning to fields using the Mirror API is a completely reasonable feature to add.<br></p><p>If it can be done using purely library implementation, that&#39;s fine too. I have doubts you can make everything that should be a compile-time error if going that route (notice the runtime fatal error above), or get decent auto-completion. For that, we&#39;d have to write a generic constraint that all the properties on the right exists on the left hand side with a compatible type, which is not expressible currently (as far as I know).<br></p><p>That said, I also realize now that the Mirror API does not do what I need here. I don&#39;t want to access &quot;fields&quot; (aka. stored properties) of the target object, I need to access all the user-exposed properties having the proper visibility in the current context, which includes computed properties that have a setter. Mirror is good for walking the tuple, but not the target.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Draft proposal: multi-property assignment .= operator</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 11, 2016 at 12:00:00am</p></header><div class="content"><p>I would much prefer to see something like a &quot;with&quot; construct, which has<br>been discussed previously in other threads. It would afford<br>property-setting and also method calls, allowing people to build DSLs<br>pretty easily. I don&#39;t feel that a multi-setter is particularly valuable as<br>a special case.<br></p><p>object.{      // or &quot;with object {&quot;<br>    property1 = 1<br>    property2 = &quot;a&quot;<br>    method()<br>    ...<br>}<br></p><p>Jacob Bandes-Storch<br></p><p>On Sun, Jan 10, 2016 at 12:21 PM, Michel Fortin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; (This proposal came from thinking about the memberwise initializer<br>&gt; proposal as well as older proposals for &quot;cascading&quot; and creating scopes<br>&gt; making some members act like local variables.)<br>&gt;<br>&gt; I&#39;d like to propose a syntax to set multiple properties at once. It would<br>&gt; look like this:<br>&gt;<br>&gt;         var object = MyObject()<br>&gt;         object .= (<br>&gt;                 property1: 1,<br>&gt;                 property2: &quot;a&quot;<br>&gt;         )<br>&gt;<br>&gt; and be equivalent to this:<br>&gt;<br>&gt;         var object = MyObject()<br>&gt;         object.property1 = 1<br>&gt;         object.property2 = &quot;a&quot;<br>&gt;<br>&gt; What the `.=` operator does is take each value in the tuple on the right<br>&gt; and assign them to the property of the same name on the variable on the<br>&gt; left. Assignments are performed in the same order as they&#39;re defined in the<br>&gt; tuple.<br>&gt;<br>&gt; The tuple on the left of the `.=` operator can be written on the spot (as<br>&gt; above) or be the result of an arbitrary expression, like here:<br>&gt;<br>&gt;         var object = MyObject()<br>&gt;<br>&gt;         var values = (property1: 1, property2: &quot;b&quot;)<br>&gt;         object .= values<br>&gt;<br>&gt;         func makeValuesFor(value: Int) -&gt; (property1: Int, property2:<br>&gt; String) {<br>&gt;                 return (value, &quot;\(value)&quot;)<br>&gt;         }<br>&gt;         object .= makeValuesFor(4)<br>&gt;<br>&gt; If the tuple contains property names that do not exist in the assigned<br>&gt; variable, or if there is a mismatch in type or visibility and the<br>&gt; assignment cannot happen, this is a compile-time error.<br>&gt;<br>&gt; This syntax is particularly beneficial when assigning to properties of a<br>&gt; deeply nested value:<br>&gt;<br>&gt;         object.subpart.detail.numberPad .= (<br>&gt;                 radix: 9<br>&gt;                 position: .Top<br>&gt;                 font: .System<br>&gt;         )<br>&gt;<br>&gt;<br>&gt; ## Tentative Implementation<br>&gt;<br>&gt; It&#39;s almost possible already to implement this with reflection. Here&#39;s an<br>&gt; attempt (using a different operator name because `.=` doesn&#39;t work as a<br>&gt; custom operator):<br>&gt;<br>&gt;         infix operator ~= {  }<br>&gt;<br>&gt;         func ~= &lt;T&gt;(inout target: T, values: (a: Int, b: String)) {<br>&gt;                 let valuesMirror = Mirror(reflecting: values)<br>&gt;                 let targetMirror = Mirror(reflecting: target)<br>&gt;                 valueLoop: for valueField in valuesMirror.children {<br>&gt;                         guard let label = valueField.label else {<br>&gt;                                 fatalError(&quot;Missing label in value tuple.&quot;)<br>&gt;                         }<br>&gt;                         for targetField in targetMirror.children {<br>&gt;                                 print(targetField)<br>&gt;                                 if targetField.label == label {<br>&gt;                                         targetField.value =<br>&gt; valueField.value<br>&gt;                                         continue valueLoop<br>&gt;                                 }<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; This fails because you can&#39;t assign to fields using the Mirror API. If<br>&gt; this line could be replaced by something that works:<br>&gt;<br>&gt;         targetField.value = valueField.value<br>&gt;<br>&gt; then we could have a library implementation.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Michel Fortin<br>&gt; https://michelf.ca<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/236f66df/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
