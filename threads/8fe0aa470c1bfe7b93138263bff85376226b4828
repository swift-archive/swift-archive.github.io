<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pure Cocoa NSNumbers and AnyHashable</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  2, 2016 at 10:00:00am</p></header><div class="content"><p>There&#39;s a hole in our AnyHashable implementation when it comes to what I&#39;ll call &quot;pure&quot; NSNumbers coming from Cocoa, which were instantiated using -[NSNumber numberWith*:] factories or @(n) syntax in Objective-C. While we maintain type specificity when Swift number types are bridged through NSNumber, NSNumbers constructed in ObjC do not necessarily remember the type they were constructed with or expect to be strictly used as only that type, so we resign to being &quot;fuzzy&quot; and let them bridge back to any Swift type. We however fail to bring this fuzziness to AnyHashable. When we construct an AnyHashable, we&#39;ll bring bridged NSNumbers back to their original Swift types, but we leave a pure NSNumber as an NSNumber, so it doesn&#39;t hash or equate with numeric values in Swift:<br></p><p>// ObjC<br>@import Foundation;<br></p><p>NSDictionary *foo() {<br>  return @{@(1): @&quot;one&quot;};<br>}<br></p><p>// Swift<br>let theFoo /*: [AnyHashable: Any]*/ = foo()<br>theFoo[1] // returns nil, ought to find the value &quot;one&quot;<br></p><p>One way to address this would be to make Swift&#39;s number types use the same hashing as NSNumber does. We could go so far as to switch the &quot;custom AnyHashable&quot; polarity around and coerce the Swift number types into NSNumbers when we put them inside AnyHashable, which would give us consistent hashing and fuzzy equality, but would come at a performance cost when converting a number to AnyHashable. We would also lose type specificity in equality for Swift values, since NSNumber&#39;s -isEqual: only compares numeric value, unless we special-cased NSNumber in AnyHashable&#39;s implementation.<br></p><p>If we didn&#39;t want to adopt NSNumber&#39;s hashing for Swift&#39;s types, but we were willing to say that all of Swift&#39;s number types produce the same hashValue for the same numeric value (so 12.hashValue == 12.0.hashValue == (12 as UInt8).hashValue, etc.), we could also go the other direction, and customize a pure NSNumber&#39;s AnyHashable implementation to use Swift&#39;s number hashing. We would still need special handling for equality of a pure NSNumber with Swift numbers, but maybe that&#39;s inevitable.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161102/8fe04828/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pure Cocoa NSNumbers and AnyHashable</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November 10, 2016 at 09:00:00am</p></header><div class="content"><p>A quick ping. I&#39;d like some feedback about how to address this problem.<br></p><p>-Joe<br></p><p>&gt; On Nov 2, 2016, at 10:26 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; There&#39;s a hole in our AnyHashable implementation when it comes to what I&#39;ll call &quot;pure&quot; NSNumbers coming from Cocoa, which were instantiated using -[NSNumber numberWith*:] factories or @(n) syntax in Objective-C. While we maintain type specificity when Swift number types are bridged through NSNumber, NSNumbers constructed in ObjC do not necessarily remember the type they were constructed with or expect to be strictly used as only that type, so we resign to being &quot;fuzzy&quot; and let them bridge back to any Swift type. We however fail to bring this fuzziness to AnyHashable. When we construct an AnyHashable, we&#39;ll bring bridged NSNumbers back to their original Swift types, but we leave a pure NSNumber as an NSNumber, so it doesn&#39;t hash or equate with numeric values in Swift:<br>&gt; <br>&gt; // ObjC<br>&gt; @import Foundation;<br>&gt; <br>&gt; NSDictionary *foo() {<br>&gt;   return @{@(1): @&quot;one&quot;};<br>&gt; }<br>&gt; <br>&gt; // Swift<br>&gt; let theFoo /*: [AnyHashable: Any]*/ = foo()<br>&gt; theFoo[1] // returns nil, ought to find the value &quot;one&quot;<br>&gt; <br>&gt; One way to address this would be to make Swift&#39;s number types use the same hashing as NSNumber does. We could go so far as to switch the &quot;custom AnyHashable&quot; polarity around and coerce the Swift number types into NSNumbers when we put them inside AnyHashable, which would give us consistent hashing and fuzzy equality, but would come at a performance cost when converting a number to AnyHashable. We would also lose type specificity in equality for Swift values, since NSNumber&#39;s -isEqual: only compares numeric value, unless we special-cased NSNumber in AnyHashable&#39;s implementation.<br>&gt; <br>&gt; If we didn&#39;t want to adopt NSNumber&#39;s hashing for Swift&#39;s types, but we were willing to say that all of Swift&#39;s number types produce the same hashValue for the same numeric value (so 12.hashValue == 12.0.hashValue == (12 as UInt8).hashValue, etc.), we could also go the other direction, and customize a pure NSNumber&#39;s AnyHashable implementation to use Swift&#39;s number hashing. We would still need special handling for equality of a pure NSNumber with Swift numbers, but maybe that&#39;s inevitable.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Pure Cocoa NSNumbers and AnyHashable</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>November 10, 2016 at 10:00:00am</p></header><div class="content"><p>So I think there are a few rough edges here not just the hashing or equality. I think the issue comes down to the subclass of NSNumber that is being used - it is defeating not only hashing but also performance and allocation optimizations in Foundation.<br></p><p>So what would we have to do to get rid of the “type preserving” NSNumber subclass?<br></p><p>Also the other side of things is that NSNumber is a different concept than Int or Float or Double etc. if it was written in Swift would roughly look like this:<br></p><p>enum Numeric : Hashable {<br>    case bool(Bool)<br>    case char(Int8)<br>    case unsignedChar(UInt8)<br>    case short(Int16)<br>    case unsignedShort(UInt16)<br>    case int(Int32)<br>    case unsignedInt(UInt32)<br>    case long(Int)<br>    case unsignedLong(UInt)<br>    case float(Float)<br>    case double(Double)<br>    case longLong(Int64)<br>    case unsignedLongLong(UInt64)<br>    <br>    var longValue: Int {<br>        switch self {<br>        case .bool(let value):<br>            return value ? 1 : 0<br>        case .char(let value):<br>            return Int(value)<br>        case .unsignedChar(let value):<br>            return Int(value)<br>        case .short(let value):<br>            return Int(value)<br>        case .unsignedShort(let value):<br>            return Int(value)<br>        case .int(let value):<br>            return Int(value)<br>        case .unsignedInt(let value):<br>            return Int(value)<br>        case .long(let value):<br>            return value<br>        case .unsignedLong(let value):<br>            return Int(value)<br>        case .float(let value):<br>            return Int(value)<br>        case .double(let value):<br>            return Int(value)<br>        case .longLong(let value):<br>            return Int(value)<br>        case .unsignedLongLong(let value):<br>            return Int(value)<br>        }<br>    }<br>    <br>    var unsignedLongValue: UInt {<br>        switch self {<br>        case .bool(let value):<br>            return value ? 1 : 0<br>        case .char(let value):<br>            return UInt(value)<br>        case .unsignedChar(let value):<br>            return UInt(value)<br>        case .short(let value):<br>            return UInt(value)<br>        case .unsignedShort(let value):<br>            return UInt(value)<br>        case .int(let value):<br>            return UInt(value)<br>        case .unsignedInt(let value):<br>            return UInt(value)<br>        case .long(let value):<br>            return UInt(value)<br>        case .unsignedLong(let value):<br>            return value<br>        case .float(let value):<br>            return UInt(value)<br>        case .double(let value):<br>            return UInt(value)<br>        case .longLong(let value):<br>            return UInt(value)<br>        case .unsignedLongLong(let value):<br>            return UInt(value)<br>        }<br>    }<br>    <br>    var integerValue: Int {<br>        return longValue<br>    }<br>    <br>    var unsignedIntegerValue: UInt {<br>        return unsignedLongValue<br>    }<br>    <br>    var doubleValue: Double {<br>        switch self {<br>        case .bool(let value):<br>            return value ? 1.0 : 0.0<br>        case .char(let value):<br>            return Double(value)<br>        case .unsignedChar(let value):<br>            return Double(value)<br>        case .short(let value):<br>            return Double(value)<br>        case .unsignedShort(let value):<br>            return Double(value)<br>        case .int(let value):<br>            return Double(value)<br>        case .unsignedInt(let value):<br>            return Double(value)<br>        case .long(let value):<br>            return Double(value)<br>        case .unsignedLong(let value):<br>            return Double(value)<br>        case .float(let value):<br>            return Double(value)<br>        case .double(let value):<br>            return value<br>        case .longLong(let value):<br>            return Double(value)<br>        case .unsignedLongLong(let value):<br>            return Double(value)<br>        }<br>    }<br>    <br>    var longLongValue: Int64 {<br>        switch self {<br>        case .bool(let value):<br>            return value ? 1 : 0<br>        case .char(let value):<br>            return Int64(value)<br>        case .unsignedChar(let value):<br>            return Int64(value)<br>        case .short(let value):<br>            return Int64(value)<br>        case .unsignedShort(let value):<br>            return Int64(value)<br>        case .int(let value):<br>            return Int64(value)<br>        case .unsignedInt(let value):<br>            return Int64(value)<br>        case .long(let value):<br>            return Int64(value)<br>        case .unsignedLong(let value):<br>            return Int64(value)<br>        case .float(let value):<br>            return Int64(value)<br>        case .double(let value):<br>            return Int64(value)<br>        case .longLong(let value):<br>            return Int64(value)<br>        case .unsignedLongLong(let value):<br>            return Int64(value)<br>        }<br>    }<br>    <br>    private static let HASHFACTOR = 2654435761<br>    <br>    private static func hashInt(_ i: Int) -&gt; Int {<br>        return (i &gt; 0 ? (i) : (-i)) * HASHFACTOR<br>    }<br>    <br>    private static func hashDouble(_ d_: Double) -&gt; Int {<br>        var d = d_<br>        if d &lt; 0 { d = -d }<br>        let dInt = floor(d + 0.5)<br>        let integralHash = HASHFACTOR * Int(fmod(dInt, Double(UInt.max)))<br>        return (integralHash + Int(((d - dInt) * Double(UInt.max))))<br>    }<br>    <br>    var hashValue: Int {<br>        switch self {<br>        case .long:<br>            fallthrough<br>        case .int:<br>            fallthrough<br>        case .char:<br>            fallthrough<br>        case .bool:<br>            let i = integerValue<br>            return Numeric.hashInt(i)<br>        case .unsignedLong:<br>            fallthrough<br>        case .unsignedInt:<br>            fallthrough<br>        case .unsignedChar:<br>            let i = unsignedIntegerValue<br>            return i &gt; UInt(Int.max) ? Numeric.hashDouble(Double(i)) : Numeric.hashInt(Int(i))<br>        case .longLong(let value):<br>            return Numeric.hashDouble(Double(value))<br>        case .unsignedLongLong(let value):<br>            return Numeric.hashDouble(Double(value))<br>        default:<br>            return Numeric.hashDouble(doubleValue)<br>        }<br>    }<br>    <br>    private static func compareDoubles(_ d1: Double, _ d2: Double) -&gt; ComparisonResult {<br>        if d1.isNaN || d2.isNaN {<br>            if d1.isNaN {<br>                if d2.isNaN {<br>                    return .orderedSame<br>                }<br>                return copysign(1.0, d1) &lt; 0.0 ? .orderedDescending : .orderedAscending<br>            }<br>            return copysign(1.0, d1) &lt; 0 ? .orderedAscending : .orderedDescending<br>        }<br>        if d1 &lt; d2 { return .orderedAscending }<br>        if d2 &lt; d1 { return .orderedDescending }<br>        return .orderedSame<br>    }<br>    <br>    static func ==(_ lhs: Numeric, _ rhs: Numeric) -&gt; Bool {<br>        switch (lhs, rhs) {<br>        case (.double, .double):<br>            fallthrough<br>        case (.double, .float):<br>            fallthrough<br>        case (.float, .double):<br>            fallthrough<br>        case (.float, .float):<br>            return compareDoubles(lhs.doubleValue, rhs.doubleValue) == .orderedSame<br>        case (.unsignedLongLong(let lhsValue), .unsignedLongLong(let rhsValue)):<br>            return lhsValue == rhsValue<br>        case (.unsignedLongLong(let lhsValue), _):<br>            if lhsValue &gt;= UInt64(Int64.max) { return false }<br>            break<br>        case (_, .unsignedLongLong(let rhsValue)):<br>            if rhsValue &gt;= UInt64(Int64.max) { return false }<br>            break<br>        default:<br>            break<br>        }<br>        return lhs.longLongValue == rhs.longLongValue<br>    }<br>}<br></p><p>&gt; On Nov 10, 2016, at 9:48 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; A quick ping. I&#39;d like some feedback about how to address this problem.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Nov 2, 2016, at 10:26 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There&#39;s a hole in our AnyHashable implementation when it comes to what I&#39;ll call &quot;pure&quot; NSNumbers coming from Cocoa, which were instantiated using -[NSNumber numberWith*:] factories or @(n) syntax in Objective-C. While we maintain type specificity when Swift number types are bridged through NSNumber, NSNumbers constructed in ObjC do not necessarily remember the type they were constructed with or expect to be strictly used as only that type, so we resign to being &quot;fuzzy&quot; and let them bridge back to any Swift type. We however fail to bring this fuzziness to AnyHashable. When we construct an AnyHashable, we&#39;ll bring bridged NSNumbers back to their original Swift types, but we leave a pure NSNumber as an NSNumber, so it doesn&#39;t hash or equate with numeric values in Swift:<br>&gt;&gt; <br>&gt;&gt; // ObjC<br>&gt;&gt; @import Foundation;<br>&gt;&gt; <br>&gt;&gt; NSDictionary *foo() {<br>&gt;&gt;  return @{@(1): @&quot;one&quot;};<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Swift<br>&gt;&gt; let theFoo /*: [AnyHashable: Any]*/ = foo()<br>&gt;&gt; theFoo[1] // returns nil, ought to find the value &quot;one&quot;<br>&gt;&gt; <br>&gt;&gt; One way to address this would be to make Swift&#39;s number types use the same hashing as NSNumber does. We could go so far as to switch the &quot;custom AnyHashable&quot; polarity around and coerce the Swift number types into NSNumbers when we put them inside AnyHashable, which would give us consistent hashing and fuzzy equality, but would come at a performance cost when converting a number to AnyHashable. We would also lose type specificity in equality for Swift values, since NSNumber&#39;s -isEqual: only compares numeric value, unless we special-cased NSNumber in AnyHashable&#39;s implementation.<br>&gt;&gt; <br>&gt;&gt; If we didn&#39;t want to adopt NSNumber&#39;s hashing for Swift&#39;s types, but we were willing to say that all of Swift&#39;s number types produce the same hashValue for the same numeric value (so 12.hashValue == 12.0.hashValue == (12 as UInt8).hashValue, etc.), we could also go the other direction, and customize a pure NSNumber&#39;s AnyHashable implementation to use Swift&#39;s number hashing. We would still need special handling for equality of a pure NSNumber with Swift numbers, but maybe that&#39;s inevitable.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161110/c49af9b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Pure Cocoa NSNumbers and AnyHashable</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>November 10, 2016 at 10:00:00am</p></header><div class="content"><p>Just realized some of that code won&#39;t work correctly for certain hashes - it needs to all be UInt bit patterns since Cocoa uses unsigned values for hashing and not signed Int.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Nov 10, 2016, at 10:30 AM, Philippe Hausler via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; So I think there are a few rough edges here not just the hashing or equality. I think the issue comes down to the subclass of NSNumber that is being used - it is defeating not only hashing but also performance and allocation optimizations in Foundation.<br>&gt; <br>&gt; So what would we have to do to get rid of the “type preserving” NSNumber subclass?<br>&gt; <br>&gt; Also the other side of things is that NSNumber is a different concept than Int or Float or Double etc. if it was written in Swift would roughly look like this:<br>&gt; <br>&gt; enum Numeric : Hashable {<br>&gt;     case bool(Bool)<br>&gt;     case char(Int8)<br>&gt;     case unsignedChar(UInt8)<br>&gt;     case short(Int16)<br>&gt;     case unsignedShort(UInt16)<br>&gt;     case int(Int32)<br>&gt;     case unsignedInt(UInt32)<br>&gt;     case long(Int)<br>&gt;     case unsignedLong(UInt)<br>&gt;     case float(Float)<br>&gt;     case double(Double)<br>&gt;     case longLong(Int64)<br>&gt;     case unsignedLongLong(UInt64)<br>&gt;     <br>&gt;     var longValue: Int {<br>&gt;         switch self {<br>&gt;         case .bool(let value):<br>&gt;             return value ? 1 : 0<br>&gt;         case .char(let value):<br>&gt;             return Int(value)<br>&gt;         case .unsignedChar(let value):<br>&gt;             return Int(value)<br>&gt;         case .short(let value):<br>&gt;             return Int(value)<br>&gt;         case .unsignedShort(let value):<br>&gt;             return Int(value)<br>&gt;         case .int(let value):<br>&gt;             return Int(value)<br>&gt;         case .unsignedInt(let value):<br>&gt;             return Int(value)<br>&gt;         case .long(let value):<br>&gt;             return value<br>&gt;         case .unsignedLong(let value):<br>&gt;             return Int(value)<br>&gt;         case .float(let value):<br>&gt;             return Int(value)<br>&gt;         case .double(let value):<br>&gt;             return Int(value)<br>&gt;         case .longLong(let value):<br>&gt;             return Int(value)<br>&gt;         case .unsignedLongLong(let value):<br>&gt;             return Int(value)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var unsignedLongValue: UInt {<br>&gt;         switch self {<br>&gt;         case .bool(let value):<br>&gt;             return value ? 1 : 0<br>&gt;         case .char(let value):<br>&gt;             return UInt(value)<br>&gt;         case .unsignedChar(let value):<br>&gt;             return UInt(value)<br>&gt;         case .short(let value):<br>&gt;             return UInt(value)<br>&gt;         case .unsignedShort(let value):<br>&gt;             return UInt(value)<br>&gt;         case .int(let value):<br>&gt;             return UInt(value)<br>&gt;         case .unsignedInt(let value):<br>&gt;             return UInt(value)<br>&gt;         case .long(let value):<br>&gt;             return UInt(value)<br>&gt;         case .unsignedLong(let value):<br>&gt;             return value<br>&gt;         case .float(let value):<br>&gt;             return UInt(value)<br>&gt;         case .double(let value):<br>&gt;             return UInt(value)<br>&gt;         case .longLong(let value):<br>&gt;             return UInt(value)<br>&gt;         case .unsignedLongLong(let value):<br>&gt;             return UInt(value)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var integerValue: Int {<br>&gt;         return longValue<br>&gt;     }<br>&gt;     <br>&gt;     var unsignedIntegerValue: UInt {<br>&gt;         return unsignedLongValue<br>&gt;     }<br>&gt;     <br>&gt;     var doubleValue: Double {<br>&gt;         switch self {<br>&gt;         case .bool(let value):<br>&gt;             return value ? 1.0 : 0.0<br>&gt;         case .char(let value):<br>&gt;             return Double(value)<br>&gt;         case .unsignedChar(let value):<br>&gt;             return Double(value)<br>&gt;         case .short(let value):<br>&gt;             return Double(value)<br>&gt;         case .unsignedShort(let value):<br>&gt;             return Double(value)<br>&gt;         case .int(let value):<br>&gt;             return Double(value)<br>&gt;         case .unsignedInt(let value):<br>&gt;             return Double(value)<br>&gt;         case .long(let value):<br>&gt;             return Double(value)<br>&gt;         case .unsignedLong(let value):<br>&gt;             return Double(value)<br>&gt;         case .float(let value):<br>&gt;             return Double(value)<br>&gt;         case .double(let value):<br>&gt;             return value<br>&gt;         case .longLong(let value):<br>&gt;             return Double(value)<br>&gt;         case .unsignedLongLong(let value):<br>&gt;             return Double(value)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var longLongValue: Int64 {<br>&gt;         switch self {<br>&gt;         case .bool(let value):<br>&gt;             return value ? 1 : 0<br>&gt;         case .char(let value):<br>&gt;             return Int64(value)<br>&gt;         case .unsignedChar(let value):<br>&gt;             return Int64(value)<br>&gt;         case .short(let value):<br>&gt;             return Int64(value)<br>&gt;         case .unsignedShort(let value):<br>&gt;             return Int64(value)<br>&gt;         case .int(let value):<br>&gt;             return Int64(value)<br>&gt;         case .unsignedInt(let value):<br>&gt;             return Int64(value)<br>&gt;         case .long(let value):<br>&gt;             return Int64(value)<br>&gt;         case .unsignedLong(let value):<br>&gt;             return Int64(value)<br>&gt;         case .float(let value):<br>&gt;             return Int64(value)<br>&gt;         case .double(let value):<br>&gt;             return Int64(value)<br>&gt;         case .longLong(let value):<br>&gt;             return Int64(value)<br>&gt;         case .unsignedLongLong(let value):<br>&gt;             return Int64(value)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     private static let HASHFACTOR = 2654435761<br>&gt;     <br>&gt;     private static func hashInt(_ i: Int) -&gt; Int {<br>&gt;         return (i &gt; 0 ? (i) : (-i)) * HASHFACTOR<br>&gt;     }<br>&gt;     <br>&gt;     private static func hashDouble(_ d_: Double) -&gt; Int {<br>&gt;         var d = d_<br>&gt;         if d &lt; 0 { d = -d }<br>&gt;         let dInt = floor(d + 0.5)<br>&gt;         let integralHash = HASHFACTOR * Int(fmod(dInt, Double(UInt.max)))<br>&gt;         return (integralHash + Int(((d - dInt) * Double(UInt.max))))<br>&gt;     }<br>&gt;     <br>&gt;     var hashValue: Int {<br>&gt;         switch self {<br>&gt;         case .long:<br>&gt;             fallthrough<br>&gt;         case .int:<br>&gt;             fallthrough<br>&gt;         case .char:<br>&gt;             fallthrough<br>&gt;         case .bool:<br>&gt;             let i = integerValue<br>&gt;             return Numeric.hashInt(i)<br>&gt;         case .unsignedLong:<br>&gt;             fallthrough<br>&gt;         case .unsignedInt:<br>&gt;             fallthrough<br>&gt;         case .unsignedChar:<br>&gt;             let i = unsignedIntegerValue<br>&gt;             return i &gt; UInt(Int.max) ? Numeric.hashDouble(Double(i)) : Numeric.hashInt(Int(i))<br>&gt;         case .longLong(let value):<br>&gt;             return Numeric.hashDouble(Double(value))<br>&gt;         case .unsignedLongLong(let value):<br>&gt;             return Numeric.hashDouble(Double(value))<br>&gt;         default:<br>&gt;             return Numeric.hashDouble(doubleValue)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     private static func compareDoubles(_ d1: Double, _ d2: Double) -&gt; ComparisonResult {<br>&gt;         if d1.isNaN || d2.isNaN {<br>&gt;             if d1.isNaN {<br>&gt;                 if d2.isNaN {<br>&gt;                     return .orderedSame<br>&gt;                 }<br>&gt;                 return copysign(1.0, d1) &lt; 0.0 ? .orderedDescending : .orderedAscending<br>&gt;             }<br>&gt;             return copysign(1.0, d1) &lt; 0 ? .orderedAscending : .orderedDescending<br>&gt;         }<br>&gt;         if d1 &lt; d2 { return .orderedAscending }<br>&gt;         if d2 &lt; d1 { return .orderedDescending }<br>&gt;         return .orderedSame<br>&gt;     }<br>&gt;     <br>&gt;     static func ==(_ lhs: Numeric, _ rhs: Numeric) -&gt; Bool {<br>&gt;         switch (lhs, rhs) {<br>&gt;         case (.double, .double):<br>&gt;             fallthrough<br>&gt;         case (.double, .float):<br>&gt;             fallthrough<br>&gt;         case (.float, .double):<br>&gt;             fallthrough<br>&gt;         case (.float, .float):<br>&gt;             return compareDoubles(lhs.doubleValue, rhs.doubleValue) == .orderedSame<br>&gt;         case (.unsignedLongLong(let lhsValue), .unsignedLongLong(let rhsValue)):<br>&gt;             return lhsValue == rhsValue<br>&gt;         case (.unsignedLongLong(let lhsValue), _):<br>&gt;             if lhsValue &gt;= UInt64(Int64.max) { return false }<br>&gt;             break<br>&gt;         case (_, .unsignedLongLong(let rhsValue)):<br>&gt;             if rhsValue &gt;= UInt64(Int64.max) { return false }<br>&gt;             break<br>&gt;         default:<br>&gt;             break<br>&gt;         }<br>&gt;         return lhs.longLongValue == rhs.longLongValue<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt;&gt; On Nov 10, 2016, at 9:48 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A quick ping. I&#39;d like some feedback about how to address this problem.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 2, 2016, at 10:26 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s a hole in our AnyHashable implementation when it comes to what I&#39;ll call &quot;pure&quot; NSNumbers coming from Cocoa, which were instantiated using -[NSNumber numberWith*:] factories or @(n) syntax in Objective-C. While we maintain type specificity when Swift number types are bridged through NSNumber, NSNumbers constructed in ObjC do not necessarily remember the type they were constructed with or expect to be strictly used as only that type, so we resign to being &quot;fuzzy&quot; and let them bridge back to any Swift type. We however fail to bring this fuzziness to AnyHashable. When we construct an AnyHashable, we&#39;ll bring bridged NSNumbers back to their original Swift types, but we leave a pure NSNumber as an NSNumber, so it doesn&#39;t hash or equate with numeric values in Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ObjC<br>&gt;&gt;&gt; @import Foundation;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSDictionary *foo() {<br>&gt;&gt;&gt;  return @{@(1): @&quot;one&quot;};<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Swift<br>&gt;&gt;&gt; let theFoo /*: [AnyHashable: Any]*/ = foo()<br>&gt;&gt;&gt; theFoo[1] // returns nil, ought to find the value &quot;one&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One way to address this would be to make Swift&#39;s number types use the same hashing as NSNumber does. We could go so far as to switch the &quot;custom AnyHashable&quot; polarity around and coerce the Swift number types into NSNumbers when we put them inside AnyHashable, which would give us consistent hashing and fuzzy equality, but would come at a performance cost when converting a number to AnyHashable. We would also lose type specificity in equality for Swift values, since NSNumber&#39;s -isEqual: only compares numeric value, unless we special-cased NSNumber in AnyHashable&#39;s implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we didn&#39;t want to adopt NSNumber&#39;s hashing for Swift&#39;s types, but we were willing to say that all of Swift&#39;s number types produce the same hashValue for the same numeric value (so 12.hashValue == 12.0.hashValue == (12 as UInt8).hashValue, etc.), we could also go the other direction, and customize a pure NSNumber&#39;s AnyHashable implementation to use Swift&#39;s number hashing. We would still need special handling for equality of a pure NSNumber with Swift numbers, but maybe that&#39;s inevitable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161110/555711a4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pure Cocoa NSNumbers and AnyHashable</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Nov 10, 2016, at 10:30 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; So I think there are a few rough edges here not just the hashing or equality. I think the issue comes down to the subclass of NSNumber that is being used - it is defeating not only hashing but also performance and allocation optimizations in Foundation.<br>&gt; <br>&gt; So what would we have to do to get rid of the “type preserving” NSNumber subclass?<br></p><p>The type-preserving subclasses remember the exact Swift type that a value was bridged from, to preserve type specificity of casts so that e.g. `0 as Any as AnyObject as Any as? Float` doesn&#39;t succeed even if the Any &lt;-&gt; AnyObject round-trip involves ObjC, thereby providing somewhat more consistent behavior between Darwin and Corelibs-based Swift. If we were willing to give that up, and say that NSNumbers just flat-out lose type info and can cast back to any Swift number type, then it seems to me we could use the pure Cocoa subclasses. Since those are almost always tagged pointers, or at least pooled and cached on platforms that don&#39;t support tagged pointers, the overhead of then having AnyHashable push numbers into NSNumbers would be less.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
