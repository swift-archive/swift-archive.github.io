<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58e2591737c75b7700b11f23381b9590?s=50"></div><header><strong>[Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Rick Ballard</string> &lt;rballard at apple.com&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of “Swift Testing” for the Package Manager begins now and runs through Thursday, January 7th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md<br></p><p>For this particular review, please note that a significant amount of discussion history is available in the original pull request for the proposal:<br></p><p>	https://github.com/apple/swift-evolution/pull/51<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>	- Rick<br>	  Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  5, 2016 at 01:00:00pm</p></header><div class="content"><p>Overall, I think the feature is important to have, but I don’t understand some of the aspects of the proposal. I also don’t think there is a real focus for clarity on the types of testing that are being supported here. The implication is that unit tests are what this is being targeted, but is this proposal specifically limiting to those particular types of tests? If so, why? If not, some of the aspects really don’t make much sense to be defaulted into.<br></p><p>&gt; Additionally we will support directories called FooTests. This layout style is prevalent in existing open source projects and supporting it will minimize vexation for their authors. However in the interest of consistency and the corresponding reduction of cognitive-load when examining new Swift packages we will not 	recommend this layout. For example:<br>&gt; <br>&gt;     Package<br>&gt;     └── Sources<br>&gt;     │   └── Foo.swift<br>&gt;     └── FooTests<br>&gt;         └── Test.swift<br></p><p>Why support something that that is not going to be recommended? Prevalence of something seems like a poor choice, especially when you are going to specifically not recommend to use it. Also, the proposal already mentioned an override mechanism to allow these to be specified. This seems like something that could easily be cut.<br></p><p>&gt; Additionally, we propose that building a module also builds that module&#39;s corresponding tests. Although this would result in slightly increased build times, we believe that tests are important enough to justify this (one might even consider slow building tests to be a code smell). We would prefer to go even further by executing the tests each time a module is built as well, but we understand that this would impede debug cycles.<br></p><p>Re-building tests all of the time is a huge time waste. Executing those tests even more so (also see original question on the types of tests being supported). Not only that, in production software, it’s very often the case that there are levels of tests that get run because of the shear amount of them that exist and the time involved to run them. In addition to levels, there are classifications of tests (perf, robustness, memory, stress, fuzzing, etc…).<br></p><p>This is something that should be an opt-in. The most basic example of this is refactoring a code base (which is later briefly mentioned at the end o the proposal). The first step is getting the code compiling for the project. It’s not true that the very next step you take is fix up the tests, especially in the cases that the refactoring/changes are exploratory.<br></p><p>&gt; In the future, we may choose to promote the --test option to be a subcommand of the swift command itself:<br>&gt; <br>&gt; $ swift test<br>&gt; <br>&gt; However, any such decision would warrant extensive design consideration, so as to avoid polluting or crowding the command-line interface. Should there be sufficient demand and justification for it, though, it would be straightforward to add this functionality.<br></p><p><br>This doesn’t make sense to me. It’s either straightforward, or it requires extensive design consideration. I personally strongly dislike coupling the notion of building with test execution, so I would much rather see “swift test” used, especially with a look into the future where it’s going to be asked for the ability to run categories of tests and filter to a particular set of tests to be run.<br></p><p>Another real problem with this type of design, is that is makes more advanced build systems very complicated to make. For example, distributed builds that bring together all of the compiled bits to run tests on get blocked because the build command starts to expect certain intermediate output. This is a real problem my previous team still has to this day with xcodebuild and actively prevents us from doing this exact thing with standard tools from Apple, so we have to basically roll our own. I see this design following in the exact same footsteps.<br></p><p>I think a lot of the design would be clarified by changing all of “by convention” items into realized default values in the Package.swift file. That would clearly demonstrate how the work and how we can change them.<br></p><p>-David<br></p><p><br>&gt; On Jan 5, 2016, at 11:06 AM, Rick Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Swift Testing” for the Package Manager begins now and runs through Thursday, January 7th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md<br>&gt; <br>&gt; For this particular review, please note that a significant amount of discussion history is available in the original pull request for the proposal:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/pull/51<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; 	- Rick<br>&gt; 	  Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160105/7cd9ad49/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>January  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Overall, I think the feature is important to have, but I don’t understand some of the aspects of the proposal. I also don’t think there is a real focus for clarity on the types of testing that are being supported here. The implication is that unit tests are what this is being targeted, but is this proposal specifically limiting to those particular types of tests? If so, why? If not, some of the aspects really don’t make much sense to be defaulted into.<br></p><p>The proposal does not advocate any particular testing methodology. Certainly to start with we only support XCTest, but that is just a practical decision. Fundamentally the proposal is only advocating building modules that are *for* testing, and then executing these tests with a runner, which at first will be an XCTest runner.<br></p><p>&gt;&gt; Additionally we will support directories called FooTests. This layout style is prevalent in existing open source projects and supporting it will minimize vexation for their authors. However in the interest of consistency and the corresponding reduction of cognitive-load when examining new Swift packages we will not 	recommend this layout. For example:<br>&gt;&gt; <br>&gt;&gt;     Package<br>&gt;&gt;     └── Sources<br>&gt;&gt;     │   └── Foo.swift<br>&gt;&gt;     └── FooTests<br>&gt;&gt;         └── Test.swift<br>&gt; <br>&gt; Why support something that that is not going to be recommended? Prevalence of something seems like a poor choice, especially when you are going to specifically not recommend to use it. Also, the proposal already mentioned an override mechanism to allow these to be specified. This seems like something that could easily be cut.<br></p><p>If we don’t cater to the thousands of projects already out there we potentially will hinder adoption.<br></p><p>I’d agree with you if supporting this was going to hurt, but it won’t.<br></p><p>&gt;&gt; Additionally, we propose that building a module also builds that module&#39;s corresponding tests. Although this would result in slightly increased build times, we believe that tests are important enough to justify this (one might even consider slow building tests to be a code smell). We would prefer to go even further by executing the tests each time a module is built as well, but we understand that this would impede debug cycles.<br>&gt; <br>&gt; Re-building tests all of the time is a huge time waste. Executing those tests even more so (also see original question on the types of tests being supported). Not only that, in production software, it’s very often the case that there are levels of tests that get run because of the shear amount of them that exist and the time involved to run them. In addition to levels, there are classifications of tests (perf, robustness, memory, stress, fuzzing, etc…).<br></p><p>I would like to wait and see. If you are right and it is a huge time waste then we can turn this off.<br></p><p>&gt; This is something that should be an opt-in. The most basic example of this is refactoring a code base (which is later briefly mentioned at the end o the proposal). The first step is getting the code compiling for the project. It’s not true that the very next step you take is fix up the tests, especially in the cases that the refactoring/changes are exploratory.<br></p><p>Indeed, I agree. But I’d like to wait and see.<br></p><p>&gt;&gt; In the future, we may choose to promote the --test option to be a subcommand of the swift command itself:<br>&gt;&gt; <br>&gt;&gt; $ swift test<br>&gt;&gt; <br>&gt;&gt; However, any such decision would warrant extensive design consideration, so as to avoid polluting or crowding the command-line interface. Should there be sufficient demand and justification for it, though, it would be straightforward to add this functionality.<br>&gt; <br>&gt; <br>&gt; This doesn’t make sense to me. It’s either straightforward, or it requires extensive design consideration. I personally strongly dislike coupling the notion of building with test execution, so I would much rather see “swift test” used, especially with a look into the future where it’s going to be asked for the ability to run categories of tests and filter to a particular set of tests to be run.<br></p><p>I agree, but my issue with `swift test` is that we are beginning to tightly couple `swift build` with swift itself. I’m not sure we should run-and-gun into this decision. SwiftPM is strictly alpha/beta and any decisions we make on these sorts of issues can change.<br></p><p>&gt; Another real problem with this type of design, is that is makes more advanced build systems very complicated to make. For example, distributed builds that bring together all of the compiled bits to run tests on get blocked because the build command starts to expect certain intermediate output. This is a real problem my previous team still has to this day with xcodebuild and actively prevents us from doing this exact thing with standard tools from Apple, so we have to basically roll our own. I see this design following in the exact same footsteps.<br></p><p>I’m not sure I understand.<br></p><p>&gt; I think a lot of the design would be clarified by changing all of “by convention” items into realized default values in the Package.swift file. That would clearly demonstrate how the work and how we can change them.<br></p><p>Can you explain what you mean?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160105/30b8327a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 2:58 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; Overall, I think the feature is important to have, but I don’t understand some of the aspects of the proposal. I also don’t think there is a real focus for clarity on the types of testing that are being supported here. The implication is that unit tests are what this is being targeted, but is this proposal specifically limiting to those particular types of tests? If so, why? If not, some of the aspects really don’t make much sense to be defaulted into.<br>&gt; <br>&gt; The proposal does not advocate any particular testing methodology. Certainly to start with we only support XCTest, but that is just a practical decision. Fundamentally the proposal is only advocating building modules that are *for* testing, and then executing these tests with a runner, which at first will be an XCTest runner.<br></p><p>XCTest is just the runner with an additional style of how to validate the test. I’m talking about the distinction between unit, integration, performance, etc. All of these types of tests can be written with XCTest, though some harder than others. There are choices being made with the implicit assumption that tests in your test modules are unit tests. Running tests by default and only running tests by default on debug builds are examples of those implicit assumptions about the classification of test within your modules.<br></p><p><br>&gt;&gt;&gt; Additionally we will support directories called FooTests. This layout style is prevalent in existing open source projects and supporting it will minimize vexation for their authors. However in the interest of consistency and the corresponding reduction of cognitive-load when examining new Swift packages we will not 	recommend this layout. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Package<br>&gt;&gt;&gt;     └── Sources<br>&gt;&gt;&gt;     │   └── Foo.swift<br>&gt;&gt;&gt;     └── FooTests<br>&gt;&gt;&gt;         └── Test.swift<br>&gt;&gt; <br>&gt;&gt; Why support something that that is not going to be recommended? Prevalence of something seems like a poor choice, especially when you are going to specifically not recommend to use it. Also, the proposal already mentioned an override mechanism to allow these to be specified. This seems like something that could easily be cut.<br>&gt; <br>&gt; If we don’t cater to the thousands of projects already out there we potentially will hinder adoption.<br>&gt; <br>&gt; I’d agree with you if supporting this was going to hurt, but it won’t.<br></p><p>It “hurts” by increasing cost, maintenance, and cognitive overload for understanding all of the “out-of-the-box” ways that test modules get implicitly created. <br></p><p>&gt; <br>&gt;&gt;&gt; Additionally, we propose that building a module also builds that module&#39;s corresponding tests. Although this would result in slightly increased build times, we believe that tests are important enough to justify this (one might even consider slow building tests to be a code smell). We would prefer to go even further by executing the tests each time a module is built as well, but we understand that this would impede debug cycles.<br>&gt;&gt; <br>&gt;&gt; Re-building tests all of the time is a huge time waste. Executing those tests even more so (also see original question on the types of tests being supported). Not only that, in production software, it’s very often the case that there are levels of tests that get run because of the shear amount of them that exist and the time involved to run them. In addition to levels, there are classifications of tests (perf, robustness, memory, stress, fuzzing, etc…).<br>&gt; <br>&gt; I would like to wait and see. If you are right and it is a huge time waste then we can turn this off.<br></p><p>Then please provide and specify how this can be opt-ed out of clearly. Is it the --without-tests flag? Can we specific default options in the Package.swift so that this always occurs?<br></p><p>As a simple query, go around Apple and ask the compiler team if they want this feature for their code. Ask those developing in the corelibs. Ask any of the app teams. Please also do performance testing on this for various sized projects. It will absolutely have an impact, especially with regards to the current state of Swift compile times.<br></p><p>&gt;&gt; This is something that should be an opt-in. The most basic example of this is refactoring a code base (which is later briefly mentioned at the end o the proposal). The first step is getting the code compiling for the project. It’s not true that the very next step you take is fix up the tests, especially in the cases that the refactoring/changes are exploratory.<br>&gt; <br>&gt; Indeed, I agree. But I’d like to wait and see.<br></p><p>I really would like to understand what your metrics of acceptability are here. Is twice the build cost ok? Three times?<br></p><p>&gt;&gt;&gt; In the future, we may choose to promote the --test option to be a subcommand of the swift command itself:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; $ swift test<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, any such decision would warrant extensive design consideration, so as to avoid polluting or crowding the command-line interface. Should there be sufficient demand and justification for it, though, it would be straightforward to add this functionality.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This doesn’t make sense to me. It’s either straightforward, or it requires extensive design consideration. I personally strongly dislike coupling the notion of building with test execution, so I would much rather see “swift test” used, especially with a look into the future where it’s going to be asked for the ability to run categories of tests and filter to a particular set of tests to be run.<br>&gt; <br>&gt; I agree, but my issue with `swift test` is that we are beginning to tightly couple `swift build` with swift itself. I’m not sure we should run-and-gun into this decision. SwiftPM is strictly alpha/beta and any decisions we make on these sorts of issues can change.<br></p><p>The alternatives are:<br></p><p>1. Factor out to a new binary, like spm, or<br>2. Continue down the path of tightly coupling build code with test execution.<br></p><p>I’d actually like to see the Swift Package Manager factor out to it’s own entity sooner rather than later and instead shell out and use the swift compiler. This would also help with other proposals, such as the “Getting C code compiling” one. But that’s a different proposal...<br></p><p>&gt;&gt; Another real problem with this type of design, is that is makes more advanced build systems very complicated to make. For example, distributed builds that bring together all of the compiled bits to run tests on get blocked because the build command starts to expect certain intermediate output. This is a real problem my previous team still has to this day with xcodebuild and actively prevents us from doing this exact thing with standard tools from Apple, so we have to basically roll our own. I see this design following in the exact same footsteps.<br>&gt; <br>&gt; I’m not sure I understand.<br></p><p>Every time you run “swift build” it’s going to trigger a build. This is should never be required to run tests. Even if you say, “we’ll only re-build on incremental builds”, you are assuming that you are building and running tests within the same environment and that the environment is a build-capable environment. This is not a valid assumption. This is what xcodebuild test does today, it tries to smartly only trigger builds when necessary, but since we build on one set of boxes and run tests on other machines, this simply doesn’t work.<br></p><p>We have the opportunity to build a proper toolset that can be correctly used within many different workflows. However, I already see a lot of the coupling starting to happen today that has happened within xcodebuild already, and that really concerns me. Basically, it means that these tools aren’t going to be usable outside of the smaller-scale apps, and teams like mine are going to have to continue investing in more robust and flexible tools to enable our scenarios.<br></p><p><br>&gt;&gt; I think a lot of the design would be clarified by changing all of “by convention” items into realized default values in the Package.swift file. That would clearly demonstrate how the work and how we can change them.<br>&gt; <br>&gt; Can you explain what you mean?<br></p><p>Show what the values for Package.swift are for this structure:<br></p><p>Package<br>├── Sources<br>│   └── Foo<br>│       └──Foo.swift<br>└── Tests<br>    └── Foo<br>        └── Test.swift<br>    └── Bar<br>        └── Test.swift<br></p><p>Instead of it being “by convention”, show what actual layout of a Package.swift file looks like to achieve the same thing. We should be able to define a Package.swift file that does exactly the same thing. <br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160105/8937702e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>January  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; Overall, I think the feature is important to have, but I don’t understand some of the aspects of the proposal. I also don’t think there is a real focus for clarity on the types of testing that are being supported here. The implication is that unit tests are what this is being targeted, but is this proposal specifically limiting to those particular types of tests? If so, why? If not, some of the aspects really don’t make much sense to be defaulted into.<br>&gt;&gt; <br>&gt;&gt; The proposal does not advocate any particular testing methodology. Certainly to start with we only support XCTest, but that is just a practical decision. Fundamentally the proposal is only advocating building modules that are *for* testing, and then executing these tests with a runner, which at first will be an XCTest runner.<br>&gt; <br>&gt; XCTest is just the runner with an additional style of how to validate the test. I’m talking about the distinction between unit, integration, performance, etc. All of these types of tests can be written with XCTest, though some harder than others. There are choices being made with the implicit assumption that tests in your test modules are unit tests. Running tests by default and only running tests by default on debug builds are examples of those implicit assumptions about the classification of test within your modules.<br></p><p>We won’t be running tests by default, just building them by default. We have to pick a build-configuration as a default.<br></p><p>I’m sorry I must be missing something, I don’t see how we are only supporting unit tests. At first XCTest is the only framework, but part of the proposal explains how in the future we will support any framework that can conform to a protocol. That protocol is the topic for another proposal.<br></p><p>&gt;&gt;&gt;&gt; Additionally we will support directories called FooTests. This layout style is prevalent in existing open source projects and supporting it will minimize vexation for their authors. However in the interest of consistency and the corresponding reduction of cognitive-load when examining new Swift packages we will not 	recommend this layout. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Package<br>&gt;&gt;&gt;&gt;     └── Sources<br>&gt;&gt;&gt;&gt;     │   └── Foo.swift<br>&gt;&gt;&gt;&gt;     └── FooTests<br>&gt;&gt;&gt;&gt;         └── Test.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why support something that that is not going to be recommended? Prevalence of something seems like a poor choice, especially when you are going to specifically not recommend to use it. Also, the proposal already mentioned an override mechanism to allow these to be specified. This seems like something that could easily be cut.<br>&gt;&gt; <br>&gt;&gt; If we don’t cater to the thousands of projects already out there we potentially will hinder adoption.<br>&gt;&gt; <br>&gt;&gt; I’d agree with you if supporting this was going to hurt, but it won’t.<br>&gt; <br>&gt; It “hurts” by increasing cost, maintenance, and cognitive overload for understanding all of the “out-of-the-box” ways that test modules get implicitly created. <br></p><p>True, but I don’t feel that the cost here is so great that is not a reasonable compromise relative to the other goals this project has.<br></p><p>&gt;&gt;&gt;&gt; Additionally, we propose that building a module also builds that module&#39;s corresponding tests. Although this would result in slightly increased build times, we believe that tests are important enough to justify this (one might even consider slow building tests to be a code smell). We would prefer to go even further by executing the tests each time a module is built as well, but we understand that this would impede debug cycles.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Re-building tests all of the time is a huge time waste. Executing those tests even more so (also see original question on the types of tests being supported). Not only that, in production software, it’s very often the case that there are levels of tests that get run because of the shear amount of them that exist and the time involved to run them. In addition to levels, there are classifications of tests (perf, robustness, memory, stress, fuzzing, etc…).<br>&gt;&gt; <br>&gt;&gt; I would like to wait and see. If you are right and it is a huge time waste then we can turn this off.<br>&gt; <br>&gt; Then please provide and specify how this can be opt-ed out of clearly. Is it the --without-tests flag? Can we specific default options in the Package.swift so that this always occurs?<br>&gt; <br>&gt; As a simple query, go around Apple and ask the compiler team if they want this feature for their code. Ask those developing in the corelibs. Ask any of the app teams. Please also do performance testing on this for various sized projects. It will absolutely have an impact, especially with regards to the current state of Swift compile times.<br></p><p>The proposal specifies there will be a flag, the flag is TBD. Probably exactly what you specified.<br></p><p>&gt;&gt;&gt; This is something that should be an opt-in. The most basic example of this is refactoring a code base (which is later briefly mentioned at the end o the proposal). The first step is getting the code compiling for the project. It’s not true that the very next step you take is fix up the tests, especially in the cases that the refactoring/changes are exploratory.<br>&gt;&gt; <br>&gt;&gt; Indeed, I agree. But I’d like to wait and see.<br>&gt; <br>&gt; I really would like to understand what your metrics of acceptability are here. Is twice the build cost ok? Three times?<br></p><p>I’d say twice is too much.<br></p><p>&gt;&gt;&gt;&gt; In the future, we may choose to promote the --test option to be a subcommand of the swift command itself:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; $ swift test<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, any such decision would warrant extensive design consideration, so as to avoid polluting or crowding the command-line interface. Should there be sufficient demand and justification for it, though, it would be straightforward to add this functionality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This doesn’t make sense to me. It’s either straightforward, or it requires extensive design consideration. I personally strongly dislike coupling the notion of building with test execution, so I would much rather see “swift test” used, especially with a look into the future where it’s going to be asked for the ability to run categories of tests and filter to a particular set of tests to be run.<br>&gt;&gt; <br>&gt;&gt; I agree, but my issue with `swift test` is that we are beginning to tightly couple `swift build` with swift itself. I’m not sure we should run-and-gun into this decision. SwiftPM is strictly alpha/beta and any decisions we make on these sorts of issues can change.<br>&gt; <br>&gt; The alternatives are:<br>&gt; <br>&gt; 1. Factor out to a new binary, like spm, or<br>&gt; 2. Continue down the path of tightly coupling build code with test execution.<br>&gt; <br>&gt; I’d actually like to see the Swift Package Manager factor out to it’s own entity sooner rather than later and instead shell out and use the swift compiler.<br></p><p>This is already how it is.<br></p><p>&gt; This would also help with other proposals, such as the “Getting C code compiling” one. But that’s a different proposal...<br>&gt; <br>&gt;&gt;&gt; Another real problem with this type of design, is that is makes more advanced build systems very complicated to make. For example, distributed builds that bring together all of the compiled bits to run tests on get blocked because the build command starts to expect certain intermediate output. This is a real problem my previous team still has to this day with xcodebuild and actively prevents us from doing this exact thing with standard tools from Apple, so we have to basically roll our own. I see this design following in the exact same footsteps.<br>&gt;&gt; <br>&gt;&gt; I’m not sure I understand.<br>&gt; <br>&gt; Every time you run “swift build” it’s going to trigger a build. This is should never be required to run tests. Even if you say, “we’ll only re-build on incremental builds”, you are assuming that you are building and running tests within the same environment and that the environment is a build-capable environment. This is not a valid assumption. This is what xcodebuild test does today, it tries to smartly only trigger builds when necessary, but since we build on one set of boxes and run tests on other machines, this simply doesn’t work.<br>&gt; <br>&gt; We have the opportunity to build a proper toolset that can be correctly used within many different workflows. However, I already see a lot of the coupling starting to happen today that has happened within xcodebuild already, and that really concerns me. Basically, it means that these tools aren’t going to be usable outside of the smaller-scale apps, and teams like mine are going to have to continue investing in more robust and flexible tools to enable our scenarios.<br></p><p>Well, it is not too late to uncouple these two pieces. Can you provide justification as to why we should decouple them? The engineering is not terrible to decouple them, but it would make things more complicated. Currently a good deal of the knowledge about where built products are and how they relate to targets does not need to be communicated outside of a single process, and simpler systems have less bugs, so I’d prefer not to complicate things without good rationale.<br></p><p>&gt;&gt;&gt; I think a lot of the design would be clarified by changing all of “by convention” items into realized default values in the Package.swift file. That would clearly demonstrate how the work and how we can change them.<br>&gt;&gt; <br>&gt;&gt; Can you explain what you mean?<br>&gt; <br>&gt; Show what the values for Package.swift are for this structure:<br>&gt; <br>&gt; Package<br>&gt; ├── Sources<br>&gt; │   └── Foo<br>&gt; │       └──Foo.swift<br>&gt; └── Tests<br>&gt;     └── Foo<br>&gt;         └── Test.swift<br>&gt;     └── Bar<br>&gt;         └── Test.swift<br>&gt; <br>&gt; Instead of it being “by convention”, show what actual layout of a Package.swift file looks like to achieve the same thing. We should be able to define a Package.swift file that does exactly the same thing. <br></p><p>We agree. This is not part of this proposal however. But it is planned to make it possible to ignore the conventions if that is desired. The conventions are intended to speed development, but not hinder it, so when it may hinder it we intend to provide alternatives.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160105/f1e65434/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 4:06 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; We won’t be running tests by default, just building them by default. We have to pick a build-configuration as a default.<br>&gt; <br>&gt; I’m sorry I must be missing something, I don’t see how we are only supporting unit tests. At first XCTest is the only framework, but part of the proposal explains how in the future we will support any framework that can conform to a protocol. That protocol is the topic for another proposal.<br></p><p>When there is stuff like this in the proposal:<br></p><p>&gt; &quot;We would prefer to go even further by executing the tests each time a module is built as well, but we understand that this would impede debug cycles.”<br></p><p>That implies that there is a desire to run tests by default. That also suggests the design of the proposal is geared for a very specific type of testing category, specifically unit tests. Maybe that’s not what is meant, but that is how I read it.<br></p><p><br>&gt;&gt; Then please provide and specify how this can be opt-ed out of clearly. Is it the --without-tests flag? Can we specific default options in the Package.swift so that this always occurs?<br>&gt;&gt; <br>&gt;&gt; As a simple query, go around Apple and ask the compiler team if they want this feature for their code. Ask those developing in the corelibs. Ask any of the app teams. Please also do performance testing on this for various sized projects. It will absolutely have an impact, especially with regards to the current state of Swift compile times.<br>&gt; <br>&gt; The proposal specifies there will be a flag, the flag is TBD. Probably exactly what you specified.<br></p><p>What about the defaults so that whenever “swift build” is run, specific flags are used? Is that out of scope - maybe with the build configurations? Or is that intended to be done via a layer of “build scripts” so teams can have consistent workflows?<br></p><p><br>&gt;&gt;&gt;&gt;&gt; In the future, we may choose to promote the --test option to be a subcommand of the swift command itself:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; $ swift test<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, any such decision would warrant extensive design consideration, so as to avoid polluting or crowding the command-line interface. Should there be sufficient demand and justification for it, though, it would be straightforward to add this functionality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This doesn’t make sense to me. It’s either straightforward, or it requires extensive design consideration. I personally strongly dislike coupling the notion of building with test execution, so I would much rather see “swift test” used, especially with a look into the future where it’s going to be asked for the ability to run categories of tests and filter to a particular set of tests to be run.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree, but my issue with `swift test` is that we are beginning to tightly couple `swift build` with swift itself. I’m not sure we should run-and-gun into this decision. SwiftPM is strictly alpha/beta and any decisions we make on these sorts of issues can change.<br>&gt;&gt; <br>&gt;&gt; The alternatives are:<br>&gt;&gt; <br>&gt;&gt; 1. Factor out to a new binary, like spm, or<br>&gt;&gt; 2. Continue down the path of tightly coupling build code with test execution.<br>&gt;&gt; <br>&gt;&gt; I’d actually like to see the Swift Package Manager factor out to it’s own entity sooner rather than later and instead shell out and use the swift compiler.<br>&gt; <br>&gt; This is already how it is.<br></p><p>Huh? Isn’t it tied to the “swift” compiler as a plug-in of sorts? Maybe I don’t understand how it works. I’m talking about removing it completely from the compiler infrastructure. But we can have this discussion a different time.<br></p><p><br>&gt;&gt; This would also help with other proposals, such as the “Getting C code compiling” one. But that’s a different proposal...<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Another real problem with this type of design, is that is makes more advanced build systems very complicated to make. For example, distributed builds that bring together all of the compiled bits to run tests on get blocked because the build command starts to expect certain intermediate output. This is a real problem my previous team still has to this day with xcodebuild and actively prevents us from doing this exact thing with standard tools from Apple, so we have to basically roll our own. I see this design following in the exact same footsteps.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure I understand.<br>&gt;&gt; <br>&gt;&gt; Every time you run “swift build” it’s going to trigger a build. This is should never be required to run tests. Even if you say, “we’ll only re-build on incremental builds”, you are assuming that you are building and running tests within the same environment and that the environment is a build-capable environment. This is not a valid assumption. This is what xcodebuild test does today, it tries to smartly only trigger builds when necessary, but since we build on one set of boxes and run tests on other machines, this simply doesn’t work.<br>&gt;&gt; <br>&gt;&gt; We have the opportunity to build a proper toolset that can be correctly used within many different workflows. However, I already see a lot of the coupling starting to happen today that has happened within xcodebuild already, and that really concerns me. Basically, it means that these tools aren’t going to be usable outside of the smaller-scale apps, and teams like mine are going to have to continue investing in more robust and flexible tools to enable our scenarios.<br>&gt; <br>&gt; Well, it is not too late to uncouple these two pieces. Can you provide justification as to why we should decouple them? The engineering is not terrible to decouple them, but it would make things more complicated. Currently a good deal of the knowledge about where built products are and how they relate to targets does not need to be communicated outside of a single process, and simpler systems have less bugs, so I’d prefer not to complicate things without good rationale.<br></p><p>I don’t know what other examples to really provide here… the ability to build is completely orthogonal to the ability to test. Given a set of binaries, I should be able to run the tests. The tests are not always statically linked to the testing target. Often times they are dynamically injected or used to drive the program externally. <br></p><p>Maybe this provides some better context: some of our apps take multiple hours to perform full builds. These apps are tested across multiple OS installations, hardware configurations, and locales. The apps are not built on all of these target machines. All of these machines should be able to run the same tests available on a developer’s machine, and there is no fundamental reason why they cannot be run in the same way (this is historically been the case with Xcode projects because of arbitrary decisions and unnecessary coupling).<br></p><p>With this proposal, how do I run these tests without triggering a build? Is “swift build --test” only going to run the tests without attempting to build first? That is not how I read the proposal.<br></p><p>I spent a good deal of my time when I was on the Office for Mac team at Microsoft working around all of limitations that made it extremely challenging to actually make use of many of the tools coming out of Apple’s Xcode team. I’d like to see the Swift tools not go down the same path and be tightly coupled in each of the phases so that integration because a huge pain, especially when integration needs to happen with non-Swift tools.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160105/fef90bfe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; We won’t be running tests by default, just building them by default. We have to pick a build-configuration as a default.<br>&gt;&gt; <br>&gt;&gt; I’m sorry I must be missing something, I don’t see how we are only supporting unit tests. At first XCTest is the only framework, but part of the proposal explains how in the future we will support any framework that can conform to a protocol. That protocol is the topic for another proposal.<br>&gt; <br>&gt; When there is stuff like this in the proposal:<br>&gt; <br>&gt;&gt; &quot;We would prefer to go even further by executing the tests each time a module is built as well, but we understand that this would impede debug cycles.”<br>&gt; <br>&gt; That implies that there is a desire to run tests by default. That also suggests the design of the proposal is geared for a very specific type of testing category, specifically unit tests. Maybe that’s not what is meant, but that is how I read it.<br></p><p>I think this is just a misunderstanding. We’d like to run tests all the time, all the tests, all types of tests, this would be great. But practically we cannot.<br></p><p>&gt;&gt;&gt; Then please provide and specify how this can be opt-ed out of clearly. Is it the --without-tests flag? Can we specific default options in the Package.swift so that this always occurs?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a simple query, go around Apple and ask the compiler team if they want this feature for their code. Ask those developing in the corelibs. Ask any of the app teams. Please also do performance testing on this for various sized projects. It will absolutely have an impact, especially with regards to the current state of Swift compile times.<br>&gt;&gt; <br>&gt;&gt; The proposal specifies there will be a flag, the flag is TBD. Probably exactly what you specified.<br>&gt; <br>&gt; What about the defaults so that whenever “swift build” is run, specific flags are used? Is that out of scope - maybe with the build configurations? Or is that intended to be done via a layer of “build scripts” so teams can have consistent workflows?<br></p><p>I would like this feature. We should discuss it in another thread, but both me and Daniel have ideas already in this space, so we’d enjoy the discussion.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt; In the future, we may choose to promote the --test option to be a subcommand of the swift command itself:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; $ swift test<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, any such decision would warrant extensive design consideration, so as to avoid polluting or crowding the command-line interface. Should there be sufficient demand and justification for it, though, it would be straightforward to add this functionality.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This doesn’t make sense to me. It’s either straightforward, or it requires extensive design consideration. I personally strongly dislike coupling the notion of building with test execution, so I would much rather see “swift test” used, especially with a look into the future where it’s going to be asked for the ability to run categories of tests and filter to a particular set of tests to be run.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree, but my issue with `swift test` is that we are beginning to tightly couple `swift build` with swift itself. I’m not sure we should run-and-gun into this decision. SwiftPM is strictly alpha/beta and any decisions we make on these sorts of issues can change.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The alternatives are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Factor out to a new binary, like spm, or<br>&gt;&gt;&gt; 2. Continue down the path of tightly coupling build code with test execution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d actually like to see the Swift Package Manager factor out to it’s own entity sooner rather than later and instead shell out and use the swift compiler.<br>&gt;&gt; <br>&gt;&gt; This is already how it is.<br>&gt; <br>&gt; Huh? Isn’t it tied to the “swift” compiler as a plug-in of sorts? Maybe I don’t understand how it works. I’m talking about removing it completely from the compiler infrastructure. But we can have this discussion a different time.<br></p><p>swift-build is a separate executable and its sources are in a separate repository, the swift-multitool invokes it.<br></p><p>&gt;&gt;&gt; This would also help with other proposals, such as the “Getting C code compiling” one. But that’s a different proposal...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another real problem with this type of design, is that is makes more advanced build systems very complicated to make. For example, distributed builds that bring together all of the compiled bits to run tests on get blocked because the build command starts to expect certain intermediate output. This is a real problem my previous team still has to this day with xcodebuild and actively prevents us from doing this exact thing with standard tools from Apple, so we have to basically roll our own. I see this design following in the exact same footsteps.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure I understand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Every time you run “swift build” it’s going to trigger a build. This is should never be required to run tests. Even if you say, “we’ll only re-build on incremental builds”, you are assuming that you are building and running tests within the same environment and that the environment is a build-capable environment. This is not a valid assumption. This is what xcodebuild test does today, it tries to smartly only trigger builds when necessary, but since we build on one set of boxes and run tests on other machines, this simply doesn’t work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have the opportunity to build a proper toolset that can be correctly used within many different workflows. However, I already see a lot of the coupling starting to happen today that has happened within xcodebuild already, and that really concerns me. Basically, it means that these tools aren’t going to be usable outside of the smaller-scale apps, and teams like mine are going to have to continue investing in more robust and flexible tools to enable our scenarios.<br>&gt;&gt; <br>&gt;&gt; Well, it is not too late to uncouple these two pieces. Can you provide justification as to why we should decouple them? The engineering is not terrible to decouple them, but it would make things more complicated. Currently a good deal of the knowledge about where built products are and how they relate to targets does not need to be communicated outside of a single process, and simpler systems have less bugs, so I’d prefer not to complicate things without good rationale.<br>&gt; <br>&gt; I don’t know what other examples to really provide here… the ability to build is completely orthogonal to the ability to test. Given a set of binaries, I should be able to run the tests. The tests are not always statically linked to the testing target. Often times they are dynamically injected or used to drive the program externally. <br>&gt; <br>&gt; Maybe this provides some better context: some of our apps take multiple hours to perform full builds. These apps are tested across multiple OS installations, hardware configurations, and locales. The apps are not built on all of these target machines. All of these machines should be able to run the same tests available on a developer’s machine, and there is no fundamental reason why they cannot be run in the same way (this is historically been the case with Xcode projects because of arbitrary decisions and unnecessary coupling).<br>&gt; <br>&gt; With this proposal, how do I run these tests without triggering a build? Is “swift build --test” only going to run the tests without attempting to build first? That is not how I read the proposal.<br></p><p>A fast null-build negates this. But if it turns out our null-builds are not fast enough for large projects we will happily accept a patch to allow you to skip the build and just run the tests.<br></p><p>Notably: currently the tests compile to executables, so once they are built you can run them independently. I intend to keep this design, if possible.<br></p><p>&gt; I spent a good deal of my time when I was on the Office for Mac team at Microsoft working around all of limitations that made it extremely challenging to actually make use of many of the tools coming out of Apple’s Xcode team. I’d like to see the Swift tools not go down the same path and be tightly coupled in each of the phases so that integration because a huge pain, especially when integration needs to happen with non-Swift tools.<br></p><p>Thanks for voicing your concerns. I believe we are doing a pretty thorough job already with `swift build` of decoupling it from the rest of the system. As the product evolves and if you feel we are not taking the right approach I’ll gladly receive the criticism and try to respond to it with engineering.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160106/2b54b37a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58e2591737c75b7700b11f23381b9590?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Rick Ballard</string> &lt;rballard at apple.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 11:52 AM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another real problem with this type of design, is that is makes more advanced build systems very complicated to make. For example, distributed builds that bring together all of the compiled bits to run tests on get blocked because the build command starts to expect certain intermediate output. This is a real problem my previous team still has to this day with xcodebuild and actively prevents us from doing this exact thing with standard tools from Apple, so we have to basically roll our own. I see this design following in the exact same footsteps.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure I understand.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Every time you run “swift build” it’s going to trigger a build. This is should never be required to run tests. Even if you say, “we’ll only re-build on incremental builds”, you are assuming that you are building and running tests within the same environment and that the environment is a build-capable environment. This is not a valid assumption. This is what xcodebuild test does today, it tries to smartly only trigger builds when necessary, but since we build on one set of boxes and run tests on other machines, this simply doesn’t work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have the opportunity to build a proper toolset that can be correctly used within many different workflows. However, I already see a lot of the coupling starting to happen today that has happened within xcodebuild already, and that really concerns me. Basically, it means that these tools aren’t going to be usable outside of the smaller-scale apps, and teams like mine are going to have to continue investing in more robust and flexible tools to enable our scenarios.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, it is not too late to uncouple these two pieces. Can you provide justification as to why we should decouple them? The engineering is not terrible to decouple them, but it would make things more complicated. Currently a good deal of the knowledge about where built products are and how they relate to targets does not need to be communicated outside of a single process, and simpler systems have less bugs, so I’d prefer not to complicate things without good rationale.<br>&gt;&gt; <br>&gt;&gt; I don’t know what other examples to really provide here… the ability to build is completely orthogonal to the ability to test. Given a set of binaries, I should be able to run the tests. The tests are not always statically linked to the testing target. Often times they are dynamically injected or used to drive the program externally. <br>&gt;&gt; <br>&gt;&gt; Maybe this provides some better context: some of our apps take multiple hours to perform full builds. These apps are tested across multiple OS installations, hardware configurations, and locales. The apps are not built on all of these target machines. All of these machines should be able to run the same tests available on a developer’s machine, and there is no fundamental reason why they cannot be run in the same way (this is historically been the case with Xcode projects because of arbitrary decisions and unnecessary coupling).<br>&gt;&gt; <br>&gt;&gt; With this proposal, how do I run these tests without triggering a build? Is “swift build --test” only going to run the tests without attempting to build first? That is not how I read the proposal.<br>&gt; <br>&gt; A fast null-build negates this. But if it turns out our null-builds are not fast enough for large projects we will happily accept a patch to allow you to skip the build and just run the tests.<br>&gt; <br>&gt; Notably: currently the tests compile to executables, so once they are built you can run them independently. I intend to keep this design, if possible.<br>&gt; <br>&gt;&gt; I spent a good deal of my time when I was on the Office for Mac team at Microsoft working around all of limitations that made it extremely challenging to actually make use of many of the tools coming out of Apple’s Xcode team. I’d like to see the Swift tools not go down the same path and be tightly coupled in each of the phases so that integration because a huge pain, especially when integration needs to happen with non-Swift tools.<br>&gt; <br>&gt; Thanks for voicing your concerns. I believe we are doing a pretty thorough job already with `swift build` of decoupling it from the rest of the system. As the product evolves and if you feel we are not taking the right approach I’ll gladly receive the criticism and try to respond to it with engineering.<br></p><p>One thing I&#39;ll add here: Unless I misunderstand, I don&#39;t think that this is a design/architectural limitation, but rather just a limitation of what functionality is currently exposed. In your example with xcodebuild, architecturally we do have the ability to test without building, and that functionality is even exposed in the Xcode.app Product menu, we&#39;ve just never implemented a flag to xcodebuild for it. But we haven&#39;t boxed ourselves into an architectural corner there; there&#39;s no improper coupling at a technical level. Likewise, while this initial proposal doesn&#39;t specify the ability to test without building, I think that would be easy to add later on when we want it. Does that address your concern here?<br></p><p>	- Rick<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160107/d3ee6430/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; One thing I&#39;ll add here: Unless I misunderstand, I don&#39;t think that this is a design/architectural limitation, but rather just a limitation of what functionality is currently exposed. In your example with xcodebuild, architecturally we do have the ability to test without building, and that functionality is even exposed in the Xcode.app Product menu, we&#39;ve just never implemented a flag to xcodebuild for it. But we haven&#39;t boxed ourselves into an architectural corner there; there&#39;s no improper coupling at a technical level. Likewise, while this initial proposal doesn&#39;t specify the ability to test without building, I think that would be easy to add later on when we want it. Does that address your concern here?<br>&gt; <br>&gt; 	- Rick<br></p><p>No, it doesn’t. While on the Office for Mac team, we repeatedly asked for many of the items in Xcode and xcodebuild to be made less coupled with each of the steps in the process. We were told no in most cases and given hacky workarounds in others that were prone to break with each incremental update to Xcode. Most of these breaks were found out because we picked up the latest beta build and attempted to run our automation tools only to find that something subtle had changed in our workaround or the basis of the workaround is no longer there.<br></p><p>Sure, SPM is “open source”, however, it’s unrealistic for people/teams to maintain forks of the tools to support features they need. Maybe the changes get accepted into a pull request, maybe not.<br></p><p>Honestly, I’m a bit shocked that the separation of building and executing tests is such a controversial thing. There should be three high-level tasks:<br></p><p>1. build<br>2. run-tests<br>3. build + run-tests<br></p><p>What I’m saying is that by not supporting #2, you’re creating an adoption blocker for any team that cannot or does not want to build every time it runs their tests. There are many reasons for this. I’ve already given several, however, another reason is instrumentation for things like code-coverage or product code markers, often happen as an intermediate step outside of the normal build operation. This is especially true in the cases of bug investigation. Saying that I cannot trigger the running of these tests without a build step baffling to me.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160107/d624402a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58e2591737c75b7700b11f23381b9590?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Rick Ballard</string> &lt;rballard at apple.com&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 11:18 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt;&gt; One thing I&#39;ll add here: Unless I misunderstand, I don&#39;t think that this is a design/architectural limitation, but rather just a limitation of what functionality is currently exposed. In your example with xcodebuild, architecturally we do have the ability to test without building, and that functionality is even exposed in the Xcode.app Product menu, we&#39;ve just never implemented a flag to xcodebuild for it. But we haven&#39;t boxed ourselves into an architectural corner there; there&#39;s no improper coupling at a technical level. Likewise, while this initial proposal doesn&#39;t specify the ability to test without building, I think that would be easy to add later on when we want it. Does that address your concern here?<br>&gt;&gt; <br>&gt;&gt; 	- Rick<br>&gt; <br>&gt; No, it doesn’t. While on the Office for Mac team, we repeatedly asked for many of the items in Xcode and xcodebuild to be made less coupled with each of the steps in the process. We were told no in most cases and given hacky workarounds in others that were prone to break with each incremental update to Xcode. Most of these breaks were found out because we picked up the latest beta build and attempted to run our automation tools only to find that something subtle had changed in our workaround or the basis of the workaround is no longer there.<br>&gt; <br>&gt; Sure, SPM is “open source”, however, it’s unrealistic for people/teams to maintain forks of the tools to support features they need. Maybe the changes get accepted into a pull request, maybe not.<br>&gt; <br>&gt; Honestly, I’m a bit shocked that the separation of building and executing tests is such a controversial thing. There should be three high-level tasks:<br>&gt; <br>&gt; 1. build<br>&gt; 2. run-tests<br>&gt; 3. build + run-tests<br>&gt; <br>&gt; What I’m saying is that by not supporting #2, you’re creating an adoption blocker for any team that cannot or does not want to build every time it runs their tests. There are many reasons for this. I’ve already given several, however, another reason is instrumentation for things like code-coverage or product code markers, often happen as an intermediate step outside of the normal build operation. This is especially true in the cases of bug investigation. Saying that I cannot trigger the running of these tests without a build step baffling to me.<br></p><p>I am not saying that we won&#39;t support this; I expect that we will, for the very good reasons that you&#39;ve raised. I&#39;m just saying that this isn&#39;t some fundamental architectural limitation that needs to be addressed by this proposal; it&#39;s just a matter of what options we expose in the (command-line) UI, and is fairly easy to change. (We should make sure that that&#39;s the case – that this is implemented as separable build and test steps – but I expect we&#39;d be doing that anyway).<br></p><p>I don&#39;t want to derail this thread with discussion of Xcode&#39;s behavior, which is outside the scope of this project, but if you want to send me (off-thread) the radar # for the bug(s) you&#39;ve filed about supporting xcodebuild test-without-build, I&#39;d be happy to take a look at what happened there.<br></p><p>	 -Rick<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160107/13fa55a3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  8, 2016 at 08:00:00am</p></header><div class="content"><p>If I may make an extended comment that may clear up some disconnects that are troubling other reviewers, that I have been grappling with very recently.  I am one of the more aggressive voices in favor of configurability on swift-build-dev–I actually maintain a small fork that has various configurability hacks so the project is usable for me–and I empathize with what David is saying, and what the other folks are saying about &quot;mixed bags&quot; and &quot;first drafts&quot; when a proposal does not entirely fit into my use case.<br></p><p>One thing I have finally learned about SwiftPM proposals is they are subtly different from Language proposals.  <br></p><p>Language proposals operate on a language that already exists, is already implemented, and is basically in a useful state, for various values of &quot;basically&quot;.  Language proposals make small tweaks for small usability wins, and necessarily operate at a minute level of detail with all the problems ironed out to avoid conflicting with current code.  Language proposals tend to be largely adversarial: we have a problem, and there is a solution space; many will enter, few will win.  C-style for loops should either be in or out; there will only ever be one proposal on that topic; everybody has had plenty of time to think about the full implications of C-style for loops three years into the language.  If you think there is some deficiency in SE-0007 your only recourse is to raise objections on this list; the suggestion that you should instead write a different proposal to keep them sounds very much like a brush-off.<br></p><p>SwiftPM, on the other hand, is basically *unusable* (again for various values of &quot;basically&quot;), and there seems to be the prevailing presumption that before anything is done we must have a proposal.  As a consequence, there is no testing support in SwiftPM right now at all, and there is the general sense that before any testing can be added, some proposal must be accepted by this list.  I think this presumption may be so obvious to some people that nobody bothers to actually say it explicitly, whereas it was not at all obvious to me.  This result and the various follow-on consequences of it have only occurred to me recently.<br></p><p>It may be illustrative to think of how Swift might have evolved were it using the swift-evolution process from the beginning.  In that situation there would have first been a proposal to *introduce* C-style for loops (because obviously we need something) and then there would have been a proposal for *for-in loops* and finally there would be another proposal to *repeal the C-style for*.  We would have in fact had 3 proposals on the &quot;for loop topic&quot; (if not more, because I am probably forgetting key developments) and so a proposal for a very greenfield project is hardly a Final Design for All Time and more a permission to start solving the problem at all.<br></p><p>When that first C-style for-loop proposal was presented somebody very well could have said &quot;I think we should have for-in loops&quot;, but it would not have been a brush-off to suggest that should be its own proposal that is separately discussed and implemented *in addition to* the C-style proposal, nor would it have been, in 2013, an objection to C-style-for.  It is easy for us in 2016 to smugly suppose we would have always had one for-loop model, but we had 2 models for years, and as the spirited discussion on SE-0007 has shown, it is not obvious to everyone that they should be combined, and the key arguments involve the details of optimizers and so on which are understood only recently.<br></p><p>Now, with the disclaimer that this is my intuition of the situation, rather than any written policy–and things like this should really be written–the present situation is like introducing the C-style for loops, because we need something.  I think the standard of evidence for this proposal (and in fact all SwiftPM proposals, and in fact all greenfield project proposals) should be much different than other proposals reviewed on this list.  The question we should ask ourselves is: &quot;Is this proposal basically useful?  Should someone start implementing it tomorrow?&quot; and not &quot;Is this proposal exhaustively thorough?&quot;  We are in month 1 of a project here, things are not going to be thorough.  If we are obviously going to box ourselves into a corner, that is one thing, and that class of objection is very important.<br></p><p>But SwiftPM is in a &quot;bad&quot; state (read: it&#39;s unimplemented, I don&#39;t suggest it&#39;s poorly-implemented).  You cannot run tests, you cannot link with libdispatch or Foundation, you cannot build a dynamic library, you cannot call an external build system, you cannot cross-compile, you cannot get an optimized build, you cannot define a DEBUG macro... *we have a lot of work to do*.  And as I understand it, most, if not all, of these problems are going to come across your desk as a proposal review.<br></p><p>Things like running the tests separately from builds are absolutely important.  Things like encouraging a diversity in the type of tests are absolutely important.  But I think it is more important to understand the semantics of this review: it is not, I believe, an absolute statement that we have considered and *rejected* all the things *not* included in the proposal.  It is, I believe, a statement that we have *permission* to implement all the things *in* the proposal.  So the absence of various things should not be worrying, but should instead be redirected into producing proposals that extend this one to support more usecases.  Particularly if these things are critical for motivated users (and trust me, I have testing problems not handled here that are critical for me), it seems like writing follow-on proposals is the productive path to accomplishing them, at least as far as I have understood the process so far.<br></p><p>To some extent these extensions are already happening, for example, I have a proposal still in swift-build-dev &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151228/000125.html&gt; that describes in great detail the protocol given merely one sentence in the present proposal, which may be a first step toward diversity in test types.  I think somebody should draft a proposal for tests-without-builds.  But &quot;we need more features than this&quot; should be an argument for more proposals, not less.  Either that or we need to revisit the apparent presumption in the SwiftPM project about proposals-first, because we are never going to get anywhere by waiting for a Final Specification for Tests Forever before implementing any testing at all.  And I think there should be the feeling that we may even reverse things written here if they turn out to be wrong with more experience, like we did recently with C-style-for.<br></p><p>I really think this whole idea about proposals-first and evidentiary standards of review for greenfield projects needs to be written up and documented somewhere official, because I was quite confused about how SwiftPM is governed until recently (and maybe I&#39;m still confused!  Who knows!) and people looked at me funny when I raised objections very much like David&#39;s on other topics in SwiftPM.  And those kinds of objections and an adversarial presumption are not unreasonable for people more familiar with the Language proposals as a background.  The lack of clarity about the semantics of a review creates misunderstandings that negatively impact both the people writing the proposals and the people trying in good faith to raise objections to them.  We can fix that.<br></p><p>&gt; What is your evaluation of the proposal?<br></p><p>+1<br></p><p>I desperately need test support, I am currently doing something insane to be able to test my codebases on Linux.  The insane thing I am doing needs to die in a fire two weeks ago.<br></p><p>For that matter the insane thing that Foundation and SwiftPM themselves do to run their tests needs to die in a fire.  I think we are not quite there yet with Foundation, but this proposal gets us there (I think?) on SwiftPM.<br></p><p>I agree generally with Paul Cantrell&#39;s assessment that the actual details are a mixed bag.  Specifically:<br></p><p>Paul makes a convincing argument that --without-tests is the right default, and it agrees with my own intuition<br>I wonder if JUnit XML is really the format we want to encourage (as opposed to something JSON-based, etc.)  I certainly don&#39;t object to it as an option, and the current language is certainly vague enough to be agreeable to me, but I would want to discourage it as a default format.  We should have a native format in something easier to parse.<br>That build configuration for testing is lacking (e.g. -D TESTING or similar)<br>That dependencies for test modules are presently unspecified<br>That we need a test-without-build setting for David&#39;s case<br>That we need some overrideable behavior for &quot;swift build -t&quot; other than &quot;run all test modules&quot;<br>It probably goes without saying, but we should standardize on a particular return code for &quot;tests failed&quot; (as opposed to combining with the code for build failure or some other kind of error).<br></p><p>To be clear, I don&#39;t think any of these are important enough to derail this proposal, but they are things I think should be taken up at some point.<br></p><p>I do think there are a lot of strong points about the proposal:<br></p><p>That there is &quot;one weird trick&quot; (swift build -t) that can run tests for any Swift package, and ideally (e.g. through further extensions) we will extend this to support custom testing frameworks and so on so that there is no longer any reason for an ad-hoc way to run the tests<br>That tests are a first-class citizen and available anywhere that builds are available.  One of the early questions everyone has when they dip their toe into a new project are &quot;how does it build&quot; and &quot;how do I run the test suite&quot; and I really think greasing the wheels here is important to the overall future of the ecosystem.  Currently many of the github.com/apple &lt;http://github.com/apple&gt; projects do something &quot;special snowflake&quot; here, and this creates friction.  We have an opportunity to avoid this in the future.<br>I think there is an opportunity here to encourage &quot;bug-reports-as-test-cases&quot;, which are the best kind of bug report.  Often when I submit bug reports I have a little sample project or something but it is not necessarily obvious how to turn that bug report into a test which would simplify upstream reproducing it and so on.  Some standardization here really has the opportunity to make it easy for me to submit bug reports as tests, which simplifies upstream&#39;s life considerably.<br></p><p>I think these strong points are a lot more important than some of the details in the first list that may be absent or wrong, and for those reasons I think we just need to do it and see how it goes.  The only thing that even makes me hesitate is the --without-tests default, but while I believe in that hill I don&#39;t want test support to die on it.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, tests are critical.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Basically.  I think we have a lot more work to do for use cases like David&#39;s (and also mine... and also others...) but we desperately need some basic way to run &quot;some tests somewhere&quot; and &quot;swift build -t&quot; is a fine way.<br></p><p>Organizing the tests into a &quot;Tests&quot; directory is logical for the common case and extends a current SPMism of using directory layout to infer intent.  For legacy interop with Xcode projects there may be other cases we need to take up separately.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I design and implement tools that wrap &quot;xcodebuild test&quot;.  This proposal is light on a lot of details I care about, but the fact that there should be some way to build and run tests is not especially controversial.<br></p><p>I also work with Python3&#39;s unittest module quite often.  I think we can do a lot better than Python, but again this proposal is a first step that doesn&#39;t really touch on any issues I care about there.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve followed this proposal from its first draft.  I&#39;ve also written a follow-on proposal currently collecting feedback in swift-build-dev.<br></p><p><br>&gt; On Jan 7, 2016, at 1:18 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; One thing I&#39;ll add here: Unless I misunderstand, I don&#39;t think that this is a design/architectural limitation, but rather just a limitation of what functionality is currently exposed. In your example with xcodebuild, architecturally we do have the ability to test without building, and that functionality is even exposed in the Xcode.app Product menu, we&#39;ve just never implemented a flag to xcodebuild for it. But we haven&#39;t boxed ourselves into an architectural corner there; there&#39;s no improper coupling at a technical level. Likewise, while this initial proposal doesn&#39;t specify the ability to test without building, I think that would be easy to add later on when we want it. Does that address your concern here?<br>&gt;&gt; <br>&gt;&gt; 	- Rick<br>&gt; <br>&gt; No, it doesn’t. While on the Office for Mac team, we repeatedly asked for many of the items in Xcode and xcodebuild to be made less coupled with each of the steps in the process. We were told no in most cases and given hacky workarounds in others that were prone to break with each incremental update to Xcode. Most of these breaks were found out because we picked up the latest beta build and attempted to run our automation tools only to find that something subtle had changed in our workaround or the basis of the workaround is no longer there.<br>&gt; <br>&gt; Sure, SPM is “open source”, however, it’s unrealistic for people/teams to maintain forks of the tools to support features they need. Maybe the changes get accepted into a pull request, maybe not.<br>&gt; <br>&gt; Honestly, I’m a bit shocked that the separation of building and executing tests is such a controversial thing. There should be three high-level tasks:<br>&gt; <br>&gt; 1. build<br>&gt; 2. run-tests<br>&gt; 3. build + run-tests<br>&gt; <br>&gt; What I’m saying is that by not supporting #2, you’re creating an adoption blocker for any team that cannot or does not want to build every time it runs their tests. There are many reasons for this. I’ve already given several, however, another reason is instrumentation for things like code-coverage or product code markers, often happen as an intermediate step outside of the normal build operation. This is especially true in the cases of bug investigation. Saying that I cannot trigger the running of these tests without a build step baffling to me.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/8598ff11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 6:08 AM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; &lt;all the good stuff&gt;<br></p><p>I agree with pretty much all you’ve said. The caveat is have is this: don’t couple the the atomic steps together when incrementally building it up. When the steps aren’t coupled, it’s significantly easier to iteratively make changes to each of the components. It’s also much easier to review and develop additions because you’ve reduced the surface area for the integration points so there is less to consider, and consequently, it’s easier to validate breaking changes. <br></p><p>For example, before any meaningful work can be done to support different types of test runners, the work is going to need to done to break the build &amp; run tests coupling. In this way, I think the proposal does a disservice because it’s not laying a good foundation to build on, it’s laying a foundation that we already know needs to be broken up.<br></p><p>There’s a difference between “get something done quick” and “get the most minimal viable product” (MVP) out the door. My objection to the proposal is that I don’t see it setting up the MVP.<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>January  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; The caveat is have is this: don’t couple the the atomic steps together<br>when incrementally building it up. When the steps aren’t coupled, it’s<br>significantly easier to iteratively make changes to each of the components.<br>It’s also much easier to review and develop additions because you’ve<br>reduced the surface area for the integration points so there is less to<br>consider, and consequently, it’s easier to validate breaking changes.<br>&gt;<br>&gt; For example, before any meaningful work can be done to support different<br>types of test runners, the work is going to need to done to break the build<br>&amp; run tests coupling. In this way, I think the proposal does a disservice<br>because it’s not laying a good foundation to build on, it’s laying a<br>foundation that we already know needs to be broken up.<br>&gt;<br>&gt; There’s a difference between “get something done quick” and “get the most<br>minimal viable product” (MVP) out the door. My objection to the proposal is<br>that I don’t see it setting up the MVP.<br></p><p><br>Can&#39;t agree with this more. The point of integration between all these<br>tools (and atomic steps) should be as minimal as possible, and so far the<br>proposals that have come through regarding these components of the building<br>and testing project have either felt very heavy-weight or very coupled (for<br>example, to XCTest or similar).  As an example: A simple function that can<br>throw an error (and *maybe* returns a simple status of pass/fail?) is<br>probably enough to facilitate the vast majority of testing frameworks, and<br>it *doesn&#39;t* come with lots of baggage of protocols and implementation<br>details that we can&#39;t assume will be required or even useful for said<br>framework. We should consider what we can leave out instead.<br></p><p>Swift facilitates all sorts of practical wins in code to promote loose<br>coupling in an extremely lightweight way, without having to resort to the<br>relatively heavy OO patterns we see in Java (and, at times, in C#) -- many<br>of which largely exist because the languages didn&#39;t have support for<br>closures until recently. As someone who has authored a third-party testing<br>framework (and made it work with the XCode-provided XCTest API, which was a<br>tremendous headache) I would much prefer to see small, atomic, decoupled<br>integration points. The way to do that is omitting details and working at a<br>nice, high level of abstraction.<br></p><p>So thank you, David, for mentioning this, and I&#39;m 100% in agreement with<br>you.<br></p><p>My biggest concern with this proposal, as it stands, is that it isn&#39;t<br>considering what I think are some very important details that will shape<br>the way the build-tool works longer-term. If there&#39;s a generic testing<br>protocol provided by the build tool, how do I import my testing framework<br>within Package.swift *before* Package.swift has been able to download all<br>my dependencies?<br></p><p>Is there a need for a multi-step, multi-file process here?<br></p><p>I personally would much rather see us focus our discussion on those<br>questions to create a longer-term proposal than continue to debate a<br>proposal that itself admits that it amounts to a temporary solution. Maybe<br>that&#39;s worth opening another topic on swift-build-dev for, but for now, I&#39;m<br>made really uncomfortable by the uncertainty left in this proposal as<br>someone who wants to use and/or create third-party testing tools -- this<br>proposal feels very one-size-fits-all, and that really concerns me.<br></p><p><br>On Fri, Jan 8, 2016 at 11:13 AM, David Owens II via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 8, 2016, at 6:08 AM, Drew Crawford &lt;drew at sealedabstract.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &lt;all the good stuff&gt;<br>&gt;<br>&gt; I agree with pretty much all you’ve said. The caveat is have is this:<br>&gt; don’t couple the the atomic steps together when incrementally building it<br>&gt; up. When the steps aren’t coupled, it’s significantly easier to iteratively<br>&gt; make changes to each of the components. It’s also much easier to review and<br>&gt; develop additions because you’ve reduced the surface area for the<br>&gt; integration points so there is less to consider, and consequently, it’s<br>&gt; easier to validate breaking changes.<br>&gt;<br>&gt; For example, before any meaningful work can be done to support different<br>&gt; types of test runners, the work is going to need to done to break the build<br>&gt; &amp; run tests coupling. In this way, I think the proposal does a disservice<br>&gt; because it’s not laying a good foundation to build on, it’s laying a<br>&gt; foundation that we already know needs to be broken up.<br>&gt;<br>&gt; There’s a difference between “get something done quick” and “get the most<br>&gt; minimal viable product” (MVP) out the door. My objection to the proposal is<br>&gt; that I don’t see it setting up the MVP.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/5fc4261b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 12:51 PM, Brian Pratt &lt;brian at pratt.io&gt; wrote:<br>&gt; <br>&gt;  A simple function that can throw an error (and *maybe* returns a simple status of pass/fail?) is probably enough to facilitate the vast majority of testing frameworks, and it *doesn&#39;t* come with lots of baggage of protocols and implementation details that we can&#39;t assume will be required or even useful for said framework. We should consider what we can leave out instead.<br></p><p>This is not the case, for reasons you can find in the third-party test frameworks proposal; but shortly: it is not innovation to have a protocol which merely allows 10 competing implementations of an XCTest-like framework.<br></p><p>Testing is not a one-size-fits-all concept.  The role of SwiftPM is IMO:<br></p><p>To have a simple way to run XCTest suites, which is the way most people (including SwiftPM &amp; Foundation &amp; many many codebases) write their tests now, and<br>To push innovation into third-party test frameworks that are free to explore the problem space in a more unrestricted way that is not bound by the constraints of XCTest, source compatibility, or the swift-evolution proposal process<br></p><p>This proposal is mostly targeted at the first situation.  I do believe it is the &quot;minimum viable proposal&quot; to address that first situation.  Perhaps the assumption that we are studying (only) the first situation needs to be more clearly stated.<br></p><p>XCTest compatibility is a feature many people require.  I understand folks who find it heavyweight for new code.  But I think the best way forward is to kick the design problem for other models out to third parties, because this mailing list will not scale to designing a novel testing framework one API at a time.  Let&#39;s let the ecosystem go to work on this problem.<br></p><p>We need a proposal to do that, and it is currently being drafted on swift-build-dev.  Please help.<br></p><p>&gt; than continue to debate a proposal that itself admits that it amounts to a temporary solution<br></p><p>I don&#39;t think this is the case at all; the proposal admits to being one solution among many, and one that will need further extensions.  But people have XCTest test suites, they want to test them, we should support it.  There&#39;s nothing temporary about that.<br></p><p>&gt; On Jan 8, 2016, at 11:13 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br></p><p>&gt; For example, before any meaningful work can be done to support different types of test runners, the work is going to need to done to break the build &amp; run tests coupling. In this way, I think the proposal does a disservice because it’s not laying a good foundation to build on, it’s laying a foundation that we already know needs to be broken up.<br></p><p><br>I don&#39;t believe this is the case either.  Under this proposal, building and running is coupled at the CLI, but introducing new CLI arguments is not any great hardship. <br></p><p>It may help to clearly identify the coupling you mean, and how this proposal very specifically establishes it.  Everybody agrees that &quot;coupling is bad, kids&quot; but not everyone understands how this proposal brings it into being.<br></p><p>I wonder if your objection is simply that the XCTest proposal hit review first, rather than the third-party frameworks proposal.  That is only because the XCTest folks are simply better motivated to draft it: there is tons of existing code that can benefit, the test framework actually exists, etc.  The third-party frameworks are not as well-motivated.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/a717a52a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>January  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; This is not the case, for reasons you can find in the third-party test<br>frameworks proposal; but shortly: it is not innovation to have a protocol<br>which merely allows 10 competing implementations of an XCTest-like<br>framework.<br></p><p>I don&#39;t really think innovation is something worth sacrificing *absolute*<br>flexibility for. Not in a tool that&#39;s primarily meant to enable developers<br>to distribute and consume shared libraries of code. There are going to be<br>many ways that developers prefer to write tests and something as generic as<br>a package manager should, in my mind, allow for all of that. While I again<br>agree that XCTest is the most sensible default, I think there&#39;s value in<br>expressing the idea (one not called out by either this proposal or the one<br>for third-party testing frameworks) that the build tool should not have<br>concrete dependencies on XCTest but rather XCTest should integrate as one<br>of many potential generic implementations usable with the build tool in the<br>most minimal interface possible.<br></p><p>That is to say, the build tool shouldn&#39;t take an opinion at all how tests<br>are run, just about the general result. Enforcing any kind of uniformity is<br>counter-intuitive as people may end up with fragmentation in their build<br>tools themselves rather than just in their testing frameworks. There are<br>already more than a handful of Swift testing frameworks that aren&#39;t<br>XCTest-like, even some that are more Quickcheck-inspired, and these<br>prescriptive testing approaches within an opinionated build tool hinder the<br>community&#39;s ability to innovate on their own. The language and its tools<br>should give users flexibility to allow for innovation, not try to prescribe<br>anything about how testing should be done in order to enforce uniformity.<br>That&#39;s a loss.<br></p><p><br>&gt; To have a simple way to run XCTest suites, which is the way most people<br>(including SwiftPM &amp; Foundation &amp; many many codebases) write their tests<br>now, and<br>&gt; To push innovation into third-party test frameworks that are free to<br>explore the problem space in a more unrestricted way that is not bound by<br>the constraints of XCTest, source compatibility, or the swift-evolution<br>proposal process.<br></p><p>Right, so, we agree here -- just wanted to make sure I register a concern<br>that rushing to implement XCTest integration with the build tool feels like<br>a mistake, especially before the community can meaningfully contribute to<br>the relatively new third-party frameworks proposal as it stands. Making the<br>build tool XCTest dependent is probably more difficult than making it<br>generic, and it seems like we&#39;d backtrack quickly.<br></p><p>Why not just let me tell my Package object that I want a specific<br>executable target for testing, one that swift-build will build and then run<br>linking whatever packages I specify from `testDependencies`. Boom, XCTest<br>works, and so do many other frameworks, and all authors have to do is give<br>the proper exit status. This mirrors the UNIX philosophy of small,<br>composable components and I think that&#39;s a good approach to take with Swift<br>and its generic tooling. Further, this makes SwiftPM work for a lot of<br>generic cases until the third-party frameworks proposal is properly ironed<br>out. That protocol may be the ultimate long-term win, but I see no reason<br>to make a short-term sacrifice (XCTest-specific integration) in order to<br>facilitate it when something generic and simple can achieve basically the<br>exact same result from a user experience perspective?<br></p><p>Again, it&#39;s good for the language to be prescriptive, but it&#39;s better to be<br>flexible and let the community evolve their individual tooling as they wish.<br></p><p><br>&gt; It may help to clearly identify the coupling you mean, and how this<br>proposal very specifically establishes it.  Everybody agrees that &quot;coupling<br>is bad, kids&quot; but not everyone understands how this proposal brings it into<br>being.<br></p><p><br>You&#39;re absolutely right -- the nature of the complaints has been very<br>high-level at this point, so, details: I think, in particular, the<br>prescription of testing output creates an unnecessarily large overlap<br>between potential (and existing) third-party frameworks that should be<br>avoided. It means that SwiftPM would have to implement test reporters that<br>might make certain assumptions about how the tests are run (synchronously?)<br>and what output is deemed important. It might make assumptions about how<br>tests fail and how they report those failures to the user. And, having used<br>XCTest as distributed by XCode, it would be frustrating to have very little<br>control over your test output because you have to maintain compliance with<br>a standard that most certainly -is- bound by the constraints of the<br>swift-evolution process. If the stated goal is to iterate, it makes sense<br>to keep the components flexible and light-weight so that iteration can<br>happen more quickly and outside of the bounds of language review / release<br>cycle.<br></p><p>I understand that supporting XCTest is the most pragmatic move, short-term,<br>but I also think the existing proposals convey an overly specific approach<br>to testing that doesn&#39;t feel like it belongs in an otherwise generic build<br>/ packaging tool.<br></p><p><br></p><p>On Fri, Jan 8, 2016 at 7:54 PM, Drew Crawford &lt;drew at sealedabstract.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jan 8, 2016, at 12:51 PM, Brian Pratt &lt;brian at pratt.io&gt; wrote:<br>&gt;<br>&gt;  A simple function that can throw an error (and *maybe* returns a simple<br>&gt; status of pass/fail?) is probably enough to facilitate the vast majority of<br>&gt; testing frameworks, and it *doesn&#39;t* come with lots of baggage of protocols<br>&gt; and implementation details that we can&#39;t assume will be required or even<br>&gt; useful for said framework. We should consider what we can leave out instead.<br>&gt;<br>&gt;<br>&gt; This is not the case, for reasons you can find in the third-party test<br>&gt; frameworks proposal; but shortly: it is not innovation to have a protocol<br>&gt; which merely allows 10 competing implementations of an XCTest-like<br>&gt; framework.<br>&gt;<br>&gt; Testing is not a one-size-fits-all concept.  The role of SwiftPM is IMO:<br>&gt;<br>&gt;<br>&gt;    - To have a simple way to run XCTest suites, which is the way most<br>&gt;    people (including SwiftPM &amp; Foundation &amp; many many codebases) write their<br>&gt;    tests now, and<br>&gt;    - To push innovation into third-party test frameworks that are free to<br>&gt;    explore the problem space in a more unrestricted way that is not bound by<br>&gt;    the constraints of XCTest, source compatibility, or the swift-evolution<br>&gt;    proposal process<br>&gt;<br>&gt;<br>&gt; *This proposal is mostly targeted at the first situation.*  I do believe<br>&gt; it is the &quot;minimum viable proposal&quot; to address that first situation.<br>&gt; Perhaps the assumption that we are studying (only) the first situation<br>&gt; needs to be more clearly stated.<br>&gt;<br>&gt; XCTest compatibility is a feature many people require.  I understand folks<br>&gt; who find it heavyweight for new code.  But I think the best way forward is<br>&gt; to kick the design problem for other models out to third parties, because<br>&gt; this mailing list will not scale to designing a novel testing framework one<br>&gt; API at a time.  Let&#39;s let the ecosystem go to work on this problem.<br>&gt;<br>&gt; We need a proposal to do that, and it is currently being drafted on<br>&gt; swift-build-dev.  Please help.<br>&gt;<br>&gt; than continue to debate a proposal that itself admits that it amounts to a<br>&gt; temporary solution<br>&gt;<br>&gt;<br>&gt; I don&#39;t think this is the case at all; the proposal admits to being one<br>&gt; solution among many, and one that will need further extensions.  But people<br>&gt; have XCTest test suites, they want to test them, we should support it.<br>&gt; There&#39;s nothing temporary about that.<br>&gt;<br>&gt; On Jan 8, 2016, at 11:13 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;<br>&gt; For example, before any meaningful work can be done to support different<br>&gt; types of test runners, the work is going to need to done to break the build<br>&gt; &amp; run tests coupling. In this way, I think the proposal does a disservice<br>&gt; because it’s not laying a good foundation to build on, it’s laying a<br>&gt; foundation that we already know needs to be broken up.<br>&gt;<br>&gt;<br>&gt; I don&#39;t believe this is the case either.  Under this proposal, building<br>&gt; and running is coupled at the CLI, but introducing new CLI arguments is not<br>&gt; any great hardship.<br>&gt;<br>&gt; It may help to clearly identify the coupling you mean, and how this<br>&gt; proposal very specifically establishes it.  Everybody agrees that &quot;coupling<br>&gt; is bad, kids&quot; but not everyone understands how this proposal brings it into<br>&gt; being.<br>&gt;<br>&gt; I wonder if your objection is simply that the XCTest proposal hit review<br>&gt; first, rather than the third-party frameworks proposal.  That is only<br>&gt; because the XCTest folks are simply better motivated to draft it: there is<br>&gt; tons of existing code that can benefit, the test framework actually exists,<br>&gt; etc.  The third-party frameworks are not as well-motivated.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/603f10ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  8, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 9:17 PM, Brian Pratt &lt;brian at pratt.io&gt; wrote:<br>&gt; <br>&gt; I don&#39;t really think innovation is something worth sacrificing *absolute* flexibility for. Not in a tool that&#39;s primarily meant to enable developers to distribute and consume shared libraries of code. There are going to be many ways that developers prefer to write tests and something as generic as a package manager should, in my mind, allow for all of that. While I again agree that XCTest is the most sensible default, I think there&#39;s value in expressing the idea (one not called out by either this proposal or the one for third-party testing frameworks) that the build tool should not have concrete dependencies on XCTest but rather XCTest should integrate as one of many potential generic implementations usable with the build tool in the most minimal interface possible. <br>&gt; <br>&gt; That is to say, the build tool shouldn&#39;t take an opinion at all how tests are run, just about the general result. Enforcing any kind of uniformity is counter-intuitive as people may end up with fragmentation in their build tools themselves rather than just in their testing frameworks. There are already more than a handful of Swift testing frameworks that aren&#39;t XCTest-like, even some that are more Quickcheck-inspired, and these prescriptive testing approaches within an opinionated build tool hinder the community&#39;s ability to innovate on their own. The language and its tools should give users flexibility to allow for innovation, not try to prescribe anything about how testing should be done in order to enforce uniformity. That&#39;s a loss.<br></p><p>This is a nice philosophy, but what does any of it mean?<br></p><p>We already have &quot;*absolute* flexibility&quot;–SwiftPM and Foundation tests are simply an ad-hoc script.  The script can literally do anything, and report its outputs any way.  It can use any testing framework.  It can live anywhere in your repository and be named anything, and can require any number of system-installed dependencies (or not), can be written in any language that you may or may not have installed (Python seems popular, some debate if 2 or 3 &lt;https://github.com/apple/swift-package-manager/pull/108&gt;...), it can take any number of arguments, it can build and test together or separately, it can play music in your iTunes library.  A proposal that provided &quot;absolute&quot; flexibility would simply be:<br></p><p>&gt; # Motivation<br>&gt; <br>&gt; We need absolute flexibility in tests.<br>&gt; <br>&gt; # Proposed solution<br>&gt; <br>&gt; Anyone can write tests however the fuck they want.<br></p><p>Any longer proposal is *necessarily* going to define *some* limits to use of any proposed testing feature.  The question is whether some particular limit is sense or nonsense, not whether there should be anything standardized at all.  And we need to have a specific conversation around the exact technical details of the interface.<br></p><p>That conversation is currently ongoing on swift-build-dev.  If you think a UNIX process model (which does limit flexibility!) is superior to a protocol-based approach, I would love to read an argument for that on the thread.  It has some drawbacks we have been talking about (such as no common reporting format for CI / GUI / Xcode to consume) but maybe you have ideas for how we can solve that problem within a UNIX process model interface.<br></p><p>In any case, SE-0019&#39;s treatment of the interface is so incidental that I do not see why the interface question (which is in my mind still very debatable at this moment) would be a defining issue in this review.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/1e980e59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>January  9, 2016 at 12:00:00am</p></header><div class="content"><p>It&#39;s not the approach (I&#39;ll save my commentary on that for the right<br>thread) it&#39;s the fact that I think the build tool shouldn&#39;t be concerned<br>with things like test output and GUI reporting. That feels like a behavior<br>that belongs in the testing tools themselves, doesn&#39;t it?<br></p><p>On Friday, January 8, 2016, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 8, 2016, at 9:17 PM, Brian Pratt &lt;brian at pratt.io<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;brian at pratt.io&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; I don&#39;t really think innovation is something worth sacrificing *absolute*<br>&gt; flexibility for. Not in a tool that&#39;s primarily meant to enable developers<br>&gt; to distribute and consume shared libraries of code. There are going to be<br>&gt; many ways that developers prefer to write tests and something as generic as<br>&gt; a package manager should, in my mind, allow for all of that. While I again<br>&gt; agree that XCTest is the most sensible default, I think there&#39;s value in<br>&gt; expressing the idea (one not called out by either this proposal or the one<br>&gt; for third-party testing frameworks) that the build tool should not have<br>&gt; concrete dependencies on XCTest but rather XCTest should integrate as one<br>&gt; of many potential generic implementations usable with the build tool in the<br>&gt; most minimal interface possible.<br>&gt;<br>&gt; That is to say, the build tool shouldn&#39;t take an opinion at all how tests<br>&gt; are run, just about the general result. Enforcing any kind of uniformity is<br>&gt; counter-intuitive as people may end up with fragmentation in their build<br>&gt; tools themselves rather than just in their testing frameworks. There are<br>&gt; already more than a handful of Swift testing frameworks that aren&#39;t<br>&gt; XCTest-like, even some that are more Quickcheck-inspired, and these<br>&gt; prescriptive testing approaches within an opinionated build tool hinder the<br>&gt; community&#39;s ability to innovate on their own. The language and its tools<br>&gt; should give users flexibility to allow for innovation, not try to prescribe<br>&gt; anything about how testing should be done in order to enforce uniformity.<br>&gt; That&#39;s a loss.<br>&gt;<br>&gt;<br>&gt; This is a nice philosophy, but what does any of it mean?<br>&gt;<br>&gt; We already have &quot;*absolute* flexibility&quot;–SwiftPM and Foundation tests are<br>&gt; simply an ad-hoc script.  The script can literally do anything, and report<br>&gt; its outputs any way.  It can use any testing framework.  It can live<br>&gt; anywhere in your repository and be named anything, and can require any<br>&gt; number of system-installed dependencies (or not), can be written in any<br>&gt; language that you may or may not have installed (Python seems popular, some<br>&gt; debate if 2 or 3 &lt;https://github.com/apple/swift-package-manager/pull/108&gt;...),<br>&gt; it can take any number of arguments, it can build and test together or<br>&gt; separately, it can play music in your iTunes library.  A proposal that<br>&gt; provided &quot;absolute&quot; flexibility would simply be:<br>&gt;<br>&gt; # Motivation<br>&gt;<br>&gt;<br>&gt; We need absolute flexibility in tests.<br>&gt;<br>&gt;<br>&gt; # Proposed solution<br>&gt;<br>&gt; Anyone can write tests however the fuck they want.<br>&gt;<br>&gt;<br>&gt; Any longer proposal is *necessarily* going to define *some* limits to use<br>&gt; of any proposed testing feature.  The question is whether some particular<br>&gt; limit is sense or nonsense, not whether there should be anything<br>&gt; standardized at all.  And we need to have a specific conversation around<br>&gt; the *exact* technical details of the interface.<br>&gt;<br>&gt; That conversation is currently ongoing on swift-build-dev.  If you think a<br>&gt; UNIX process model (which does limit flexibility!) is superior to a<br>&gt; protocol-based approach, I would love to read an argument for that on the<br>&gt; thread.  It has some drawbacks we have been talking about (such as no<br>&gt; common reporting format for CI / GUI / Xcode to consume) but maybe you have<br>&gt; ideas for how we can solve that problem within a UNIX process model<br>&gt; interface.<br>&gt;<br>&gt; In any case, SE-0019&#39;s treatment of the interface is so incidental that I<br>&gt; do not see why the interface question (which is in my mind still very<br>&gt; debatable at this moment) would be a defining issue in this review.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160109/91a3702e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  9, 2016 at 12:00:00am</p></header><div class="content"><p>You know... you have a really good point there.  I never even stopped to think about that assumption.<br></p><p>I think clearly swift-multitool should frontend, but is there a reason we don&#39;t have an independent testing tool from the package manager?<br></p><p>That very much does seem like the kind of architectural thing we should iron out before a proposal is accepted.  Maybe I missed an obvious rationale in the earlier discussion.<br></p><p>&gt; On Jan 9, 2016, at 12:01 AM, Brian Pratt &lt;brian at pratt.io&gt; wrote:<br>&gt; <br>&gt; It&#39;s not the approach (I&#39;ll save my commentary on that for the right thread) it&#39;s the fact that I think the build tool shouldn&#39;t be concerned with things like test output and GUI reporting. That feels like a behavior that belongs in the testing tools themselves, doesn&#39;t it?<br>&gt; <br>&gt; On Friday, January 8, 2016, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 9:17 PM, Brian Pratt &lt;brian at pratt.io &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;brian at pratt.io&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t really think innovation is something worth sacrificing *absolute* flexibility for. Not in a tool that&#39;s primarily meant to enable developers to distribute and consume shared libraries of code. There are going to be many ways that developers prefer to write tests and something as generic as a package manager should, in my mind, allow for all of that. While I again agree that XCTest is the most sensible default, I think there&#39;s value in expressing the idea (one not called out by either this proposal or the one for third-party testing frameworks) that the build tool should not have concrete dependencies on XCTest but rather XCTest should integrate as one of many potential generic implementations usable with the build tool in the most minimal interface possible. <br>&gt;&gt; <br>&gt;&gt; That is to say, the build tool shouldn&#39;t take an opinion at all how tests are run, just about the general result. Enforcing any kind of uniformity is counter-intuitive as people may end up with fragmentation in their build tools themselves rather than just in their testing frameworks. There are already more than a handful of Swift testing frameworks that aren&#39;t XCTest-like, even some that are more Quickcheck-inspired, and these prescriptive testing approaches within an opinionated build tool hinder the community&#39;s ability to innovate on their own. The language and its tools should give users flexibility to allow for innovation, not try to prescribe anything about how testing should be done in order to enforce uniformity. That&#39;s a loss.<br>&gt; <br>&gt; This is a nice philosophy, but what does any of it mean?<br>&gt; <br>&gt; We already have &quot;*absolute* flexibility&quot;–SwiftPM and Foundation tests are simply an ad-hoc script.  The script can literally do anything, and report its outputs any way.  It can use any testing framework.  It can live anywhere in your repository and be named anything, and can require any number of system-installed dependencies (or not), can be written in any language that you may or may not have installed (Python seems popular, some debate if 2 or 3 &lt;https://github.com/apple/swift-package-manager/pull/108&gt;...), it can take any number of arguments, it can build and test together or separately, it can play music in your iTunes library.  A proposal that provided &quot;absolute&quot; flexibility would simply be:<br>&gt; <br>&gt;&gt; # Motivation<br>&gt;&gt; <br>&gt;&gt; We need absolute flexibility in tests.<br>&gt;&gt; <br>&gt;&gt; # Proposed solution<br>&gt;&gt; <br>&gt;&gt; Anyone can write tests however the fuck they want.<br>&gt; <br>&gt; Any longer proposal is *necessarily* going to define *some* limits to use of any proposed testing feature.  The question is whether some particular limit is sense or nonsense, not whether there should be anything standardized at all.  And we need to have a specific conversation around the exact technical details of the interface.<br>&gt; <br>&gt; That conversation is currently ongoing on swift-build-dev.  If you think a UNIX process model (which does limit flexibility!) is superior to a protocol-based approach, I would love to read an argument for that on the thread.  It has some drawbacks we have been talking about (such as no common reporting format for CI / GUI / Xcode to consume) but maybe you have ideas for how we can solve that problem within a UNIX process model interface.<br>&gt; <br>&gt; In any case, SE-0019&#39;s treatment of the interface is so incidental that I do not see why the interface question (which is in my mind still very debatable at this moment) would be a defining issue in this review.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160109/9698d243/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January 11, 2016 at 12:00:00am</p></header><div class="content"><p>As I&#39;ve taken some more time to evaluate the criticisms people have raised (several off-list), my view of the proposal has changed.  There is enough substantive dissent here that we should send this back for more cooking.<br></p><p>A summary of the criticisms that convinced me are:<br></p><p>1.  Whether testing and SwiftPM should be coupled at all.  This isn&#39;t obviously clear to everybody that SwiftPM is the right place to solve the problem and a reasoned justification in the document is necessary.  The only treatment of this coupling at all is that it &quot;will help ensure a stable and reliable packaging ecosystem&quot;, but there is no discussion of why this is so.  IMO this is a critical omission.<br></p><p>2.  Whether privileging XCTest is in the best interest of the ecosystem.  My informal poll reveals much more debate than I had expected about whether people even want to use XCTest for their programs, and so I think an approach that starts with defining the interface first and wiring XCTest into it second is better for the long-term health of the ecosystem than an approach that starts with XCTest first and invents a separate system for third-party later which we may or may not retrofit XCTest back into.  I think a proposal that takes the latter position should include a reasoned technical justification for that decision.<br></p><p>3.  The proposal&#39;s treatment of various topics &quot;in passing&quot; is frustrating.  For example, the proposal says<br></p><p>&gt; We expect that such an implementation would take the form of a Swift protocol<br></p><p>If we are right now deciding to use a protocol (over say a UNIX process model) then this is not the kind of detailed discussion we need to justify that decision–and I say that as a person in favor of doing it.<br></p><p>Or if we are not right now deciding that, why is it in the proposal? So I think the proposal needs to be a lot clearer about what is an essential part of what is being proposed and what is nonessential, and right now it tries to cut both ways on several points.  The protocol system, JUnit XML, Testability for debug builds, opting out of additional compilation, all exist in this grey area where I am not sure if they are passing ideas or binding precedent that we aren&#39;t defending well (or at all in some cases).<br></p><p>4.  I think all reviewers supporting the proposal have found &quot;irregularities&quot; in the document.  Paul Cantrell said it best that this was a &quot;vision and first draft&quot; but &quot;not a releasable product&quot;.  I have argued that we should use a different standard of evidence for greenfield proposals.<br></p><p>The fact is, though, there is no &quot;official&quot; explanation for why we should +1 a document that we all agree has deficiencies.  I have tried to argue that it is a stopgap solution that is necessary but I find my own argument poor.<br></p><p> In another context of SwiftPM, Daniel Dunbar said:<br></p><p>&gt; the approach we want to take for developing and adding features is to be in a good place *at the time of release*...  With that mindset, it doesn&#39;t usually make sense to add features that we consider actively/potentially harmful, even if that solves some current short term pain.<br></p><p>(emphasis in original)<br></p><p>It seems like the same principle should apply here.  If we have consensus that this proposal is potentially harmful (and there are some details that I would characterize that way) then let&#39;s send it back and get a better document.<br></p><p>5.  The &quot;Alternatives considered&quot; section admits that it considers no alternatives, but I think there are clear alternatives to each of the 4 numbered criticisms above.  Specifically each of these are potential alternatives to the proposal:<br></p><p>    1.  Do testing from a completely separate tool that isn&#39;t SwiftPM (probably frontended through swift-multitool)<br>    1a.  Or building the test frontend inside the XCTest project instead<br>    2.  Start with defining interface for the testing framework first, instead of potentially having one codepath for XCTest and another codepath for third party<br>    3.  UNIX process model instead of protocol, JSON format instead of JUnit XML, compiling without testability for debug builds by default, etc.<br>    4.  Doing nothing, until we have a &quot;final draft&quot; proposal that reviewers can endorse with fewer reservations.<br></p><p>To be clear, I&#39;m not particularly advocating in favor of doing any of these, but I do think we can do a lot better than not imagining any alternatives, which is the present text.<br></p><p>While I don&#39;t advance these as arguments to reject, I think we should take the opportunity to fix them:<br></p><p>1.  Being more careful about not assuming compilation times are free, see Paul Cantrell and David Owens&#39;s excellent arguments<br>2.  There is some kind of documentation snafu in the swift-evolution process as it relates to this proposal.  The process document &lt;https://github.com/apple/swift-evolution/blob/master/process.md#review-process&gt; says the Review Manager is a member of the core team, but our RM  is not listed there &lt;https://swift.org/community/#community-structure&gt;.  I&#39;m sure there is a reasonable explanation, but we should fix the docs.<br></p><p>I want testing as bad as all of you, but I see enough substance in the criticism that I now believe we should reject the proposal as it presently appears before us.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160111/5910a895/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; 2.  Whether privileging XCTest is in the best interest of the ecosystem.  My informal poll reveals much more debate than I had expected about whether people even want to use XCTest for their programs, and so I think an approach that starts with defining the interface first and wiring XCTest into it second is better for the long-term health of the ecosystem than an approach that starts with XCTest first and invents a separate system for third-party later which we may or may not retrofit XCTest back into.  I think a proposal that takes the latter position should include a reasoned technical justification for that decision.<br></p><p>I have no opinion about this proposal (to be honest, I haven&#39;t even used the package manager yet), but let&#39;s be careful not to make the perfect the enemy of the good here. If we want testing to be part of the package manager, it&#39;s perfectly acceptable for the initial version to rely on XCTest. The interface between SwiftPM and XCTest can then be gradually abstracted and refined until it becomes a generic test harness; then a separate proposal could formalize that interface and add support for alternative test frameworks.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 5:54 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t believe this is the case either.  Under this proposal, building and running is coupled at the CLI, but introducing new CLI arguments is not any great hardship. <br>&gt; <br>&gt; It may help to clearly identify the coupling you mean, and how this proposal very specifically establishes it.  Everybody agrees that &quot;coupling is bad, kids&quot; but not everyone understands how this proposal brings it into being.<br>&gt; <br>&gt; I wonder if your objection is simply that the XCTest proposal hit review first, rather than the third-party frameworks proposal.  That is only because the XCTest folks are simply better motivated to draft it: there is tons of existing code that can benefit, the test framework actually exists, etc.  The third-party frameworks are not as well-motivated.<br></p><p>I don’t care that the default and only supported test runner is XCTest for the moment. I can simply write a little wrapper and shell out to some other test runner. I can even get through the fact that tests will be built everytime (they won’t though, because people will simply comment them out in the Package.swift file until they are ready to use them).<br></p><p>What I care about is the coupling of the test phase with the build phase. I cannot work around that. <br></p><p>When I run “swift build -t” or “swift tests” or whatever the CLI will be, I need to be able to do that without re-triggering builds. A no-op build is not sufficient. If you don’t agree with, then I really have no other examples to provide that can convince anyone of that fact.<br></p><p>At some later date, maybe we’ll get “swift build --run-tests” or “swift tests --no-build” that simply runs the tests without attempting to do a build. Ok, maybe we will. If it’s a week later, ok. If it’s a month later, ok. If it’s going to be a year away, that becomes a real issue. However, there is no compelling reason to couple this from the start, especially if there is no architectural considerations to worry about.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/5c146556/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  8, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 9:20 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; At some later date, maybe we’ll get “swift build --run-tests” or “swift tests --no-build” that simply runs the tests without attempting to do a build. Ok, maybe we will. If it’s a week later, ok. If it’s a month later, ok. If it’s going to be a year away, that becomes a real issue. However, there is no compelling reason to couple this from the start, especially if there is no architectural considerations to worry about.<br></p><p><br>I think the common case (perhaps it is uncommon for you) is a test-driven implementation loop, where somebody has a failing test, they are working in a text editor or IDE, and they want to know if it the thing they changed caused the tests to pass.  This is my workflow when I PR something to Foundation or SwiftPM, and my workflow on other projects.<br></p><p>Certainly that could be accomplished via chaining commands instead (e.g. &quot;swift build &amp;&amp; swift test&quot;) which better supports your workflow although that is slightly more awkward for the common situation.<br></p><p>But in any case this whole argument feels to me like a bikeshed–we have infinite freedom to support any number of CLI commands, with builds &amp; tests together, separated, in a box, with a fox.   This one was elected to support a common workflow, not to the exclusion of all the other things we could do additionally.<br></p><p>But there is language being used on this point (from several people) like:<br></p><p>&gt; there is no compelling reason to couple this from the start<br></p><p>&gt; My biggest concern with this proposal, as it stands, is that it isn&#39;t considering what I think are some very important details that will shape the way the build-tool works longer-term.<br></p><p>&gt; For example, before any meaningful work can be done to support different types of test runners, the work is going to need to done to break the build &amp; run tests coupling. In this way, I think the proposal does a disservice because it’s not laying a good foundation to build on, it’s laying a foundation that we already know needs to be broken up.<br></p><p>I fail to understand how the election of one (first) command line argument has any of these follow-on consequences at all.  We are discussing a CLI frontend, not an architecture diagram.<br></p><p>If someone believes we are in danger of laying a bad foundation then that is an important objection, but to understand it we need an argument of the form<br></p><p>1.  &quot;swift build -t&quot;<br>2. ???<br>3.  Therefore, [specific irreversible harm]<br></p><p>Until that is laid out in a way I can follow, I can&#39;t make sense of the objection.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/ff32478a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 8:28 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 9:20 PM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; At some later date, maybe we’ll get “swift build --run-tests” or “swift tests --no-build” that simply runs the tests without attempting to do a build. Ok, maybe we will. If it’s a week later, ok. If it’s a month later, ok. If it’s going to be a year away, that becomes a real issue. However, there is no compelling reason to couple this from the start, especially if there is no architectural considerations to worry about.<br>&gt; <br>&gt; <br>&gt; I think the common case (perhaps it is uncommon for you) is a test-driven implementation loop, where somebody has a failing test, they are working in a text editor or IDE, and they want to know if it the thing they changed caused the tests to pass.  This is my workflow when I PR something to Foundation or SwiftPM, and my workflow on other projects.<br></p><p>I don’t run all of my tests when I do this. I re-run the subset that actually apply to what I’m working on. Then before performing a check-in, I re-run all of the tests.<br></p><p>&gt; Certainly that could be accomplished via chaining commands instead (e.g. &quot;swift build &amp;&amp; swift test&quot;) which better supports your workflow although that is slightly more awkward for the common situation.<br></p><p>This is only the “common situation” if what I was talking about in earlier posts is true: the testing that is being support here is primary for unit tests only or integration tests that can run as quickly as unit tests. But yes, I’m saying that the proposal should enable that exact scenario as the building block. <br></p><p>&gt; But in any case this whole argument feels to me like a bikeshed–we have infinite freedom to support any number of CLI commands, with builds &amp; tests together, separated, in a box, with a fox.   This one was elected to support a common workflow, not to the exclusion of all the other things we could do additionally.<br></p><p>Again, if it so easy, then why not simply come out of the gate with “build”, “test”, and “run-tests”. Surely we’ve already discussed this with more time then it would be to implement if SPM’s architecture is actually going to allow this and that shortcuts are not taken to get the “test” portion working more quickly. Call me jaded by experience with other tools, but whenever I’ve seen shortcuts like these taken, it’s always more work than a simple add of a new command to break what is being treated by the current implementation as an atomic command into two.<br></p><p><br>&gt; But there is language being used on this point (from several people) like:<br>&gt; <br>&gt;&gt; there is no compelling reason to couple this from the start<br>&gt; <br>&gt;&gt; My biggest concern with this proposal, as it stands, is that it isn&#39;t considering what I think are some very important details that will shape the way the build-tool works longer-term.<br>&gt; <br>&gt;&gt; For example, before any meaningful work can be done to support different types of test runners, the work is going to need to done to break the build &amp; run tests coupling. In this way, I think the proposal does a disservice because it’s not laying a good foundation to build on, it’s laying a foundation that we already know needs to be broken up.<br>&gt; <br>&gt; I fail to understand how the election of one (first) command line argument has any of these follow-on consequences at all.  We are discussing a CLI frontend, not an architecture diagram.<br>&gt; <br>&gt; If someone believes we are in danger of laying a bad foundation then that is an important objection, but to understand it we need an argument of the form<br>&gt; <br>&gt; 1.  &quot;swift build -t&quot;<br>&gt; 2. ???<br>&gt; 3.  Therefore, [specific irreversible harm]<br>&gt; <br>&gt; Until that is laid out in a way I can follow, I can&#39;t make sense of the objection.<br></p><p>I don’t know how else to explain my objection; I’ve done so in at least three different ways, including examples of how a similar design affects my previous team with still unsupported behavior in other Apple tools that have the same design as being illustrated here (Rick, I’m reaching out to my old counterparts to see if they have any radars they want followed up with). It’s not irreversible harm, it’s starting the process with unnecessary technical debt. <br></p><p>Fortunately, this time around we can at least fork the tools to get the support we need, if it doesn’t come (and potentially send the fix back or submit proposals), instead of do what Facebook had to do with xctool.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/16e18839/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[swift-build-dev] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January  8, 2016 at 07:00:00am</p></header><div class="content"><p>One more thing:<br></p><p>&gt; On Jan 6, 2016, at 1:52 PM, Max Howell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Notably: currently the tests compile to executables, so once they are built you can run them independently. I intend to keep this design, if possible.<br>&gt; <br></p><p>…if I am interpreting this correctly, I’m not sure I like it and I realized another issue isn’t being explicitly-addressed in the proposal:<br></p><p>- If there is test-only utility code, where does it live? How much visibility do the various test modules have into each other?<br></p><p>…and seeing that the tests are currently intended to get compiled to individual executables makes me at least a little concerned that the answer might be “they have no such mutual visibility”.<br></p><p>Can the document at least clarify the intended/philosophical outlook here? <br></p><p>I ask b/c I’ve found that it isn’t that uncommon in certain cases to wind up with data-driven tests; e.g. the actual input-output pairs might live in some JSON/XML/whatever, and the test code just imports-and-parses them, checks your code against them, and complains about mis-matches.<br></p><p>At present it’s easy to create-and-use such test-specific helper code; it’s not clear if that’s the case under the proposal. <br></p><p>Relatedly, I’m aware that resource-packing is currently a “future feature” for the PM itself, so I don’t begrudge it’s not being handled in this proposal; nevertheless it seems important enough to also go into a section touching on “future directions/future goals”.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/7bd06b78/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  5, 2016 at 01:00:00pm</p></header><div class="content"><p>A few requests for clarification from the proposal authors:<br></p><p>1. The proposal talks in several places about “test modules” (for example, “test-module is created per subdirectory of Tests”). How do these test modules interact with Package.swift? Does each of them have a separate target? If so, how is the test module name specified in the Target(…) entry?<br></p><p>2. Perhaps answered by #1, how does Package.swift specify test-only dependencies (e.g. Quick) that are necessary to build tests, but should not be exported to downstream projects?<br></p><p>3. You propose that “building a module also builds that module&#39;s corresponding tests.” Does this apply only to the top-level package, or to all of its dependencies? For example, if my FooApp depends on BarLib, and BarLib’s tests depend on HugeFancyTestFramework, do I have to download and compile HugeFancyTestFramework in order to build FooApp? (Hopefully not!)<br></p><p>I apologize if these questions are already answered in the proposal. I’m not sure I caught every subtlety of the writeup.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Jan 5, 2016, at 1:06 PM, Rick Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Swift Testing” for the Package Manager begins now and runs through Thursday, January 7th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md<br>&gt; <br>&gt; For this particular review, please note that a significant amount of discussion history is available in the original pull request for the proposal:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/pull/51<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; 	- Rick<br>&gt; 	  Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8993e184f091e98f018c07d96ac4731f?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>John Joyce</string> &lt;uchuugaka at icloud.com&gt;<p>January  6, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 4:06 AM, Rick Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>Overall this is great direction, but needs more deliberation and sifting about the details. This kind of infrastructure will live a while, or if it ends up stinky, will go unused.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>Not really a language change as far as I can tell.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>Definitely.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>This is an excellent addition that keeps the whole life cycle view in.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br></p><p><br></p><p>On Build Configuration/Testability<br>This seems to be a fairly narrow view, but maybe it&#39;s enough.<br>I think release and debug are not the only configurations, though likely the most common set.<br>Perhaps some sensible defaults should be implicit (written automatically in a PM file) but customizable? <br>(apologies if this exists and I missed it.)<br></p><p>Additionally, this takes a narrow view on the nature of testing. <br>Unit tests are not the only game in town and I would like to see this left open to other kinds of automated testing.<br>You might have UI testing among others. XCUITest is not the only idea here.<br>You may need to test interactions and flows between systems.<br></p><p>For the Command Line Interface section<br>I would suggest the subcommand test makes a lot of sense.<br></p><p>Is there a proper place here somewhere for ensuring a home for test resources? <br>(a standardized test/ subdirectory for static/standard test data )<br></p><p>Lovely open ended callouts on the test reporting section.<br>Important for that to be malleable and replaceable. Might be JSON would be an obvious addition there...?<br></p><p>Lastly, should there be any built-in facility for bug/issue tracking relationships?<br>Perhaps too much minutia for this proposal, but seems a good thing to include.<br>In particular for reporting, any ticket/tracking numbers referring to regression tests are always good callouts in manager friendly reporting.<br></p><p><br>Lastly as an addition, would it make sense to include some kind of test/code-coverage element here?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160106/e3be749f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  7, 2016 at 11:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br></p><p>I recommend accepting it as a vision and first draft, though not as a releasable product (yet).<br></p><p>This is a difficult proposal to review because of the way it mixes the general and the specific. On the one hand, it feels like this document’s primary intent is to lay out a large-scale vision, a philosophy of how the Package Manager should treat tests — and more importantly, a vision of the habits package authors should have around writing tests. On the other hand, the proposal is full of very specific details (such as directory structure) — too many such details to evaluate it as a large-scale vision only, yet not enough to evaluate it as a completely specified solution. I’ll therefore take the vision and the details separately.<br></p><p>I like the proposal’s broad vision very much. It advocates three important cultural norms about testing in Swift, all somewhat contrary to other package management systems, but all ones I approve of:<br></p><p>The package manager not only allows but proactively encourages package authors to write and maintain tests.<br>Tests are a uniform feature of Swift packages, with a standard invocation mechanism and standard result reporting (as opposed to being an ad hoc build task that differs from project to project).<br>Tests should run reproducibly, for everyone, on checkout with no manual setup. It’s just “run tests;” there is no step 2.<br></p><p>While the proposal doesn’t state all of this quite so specifically, it’s there in the thinking — and I approve. Thinking about this proposal in terms of Chris Lattner’s notion of the “programmer model,” I see this proposal tending toward a world where a package’s tests are run regularly not only but its contributors, but also its clients. That has cultural implications: users will hold package owners accountable if tests are missing, don’t work, or fail to catch problems. “Tests pass for everyone everywhere” is a significantly higher bar than “tests passed for one person somewhere,” and I like a Swift culture built around that higher standard of reproducibility.<br></p><p>The specific details of the proposal are a mixed bag. These seem good to me:<br></p><p>the proposed directory structure,<br>the notion of multiple test modules,<br>automatic dependency determination between test modules and library targets,<br>the long-term goal of “swift test” being the command line invocation mechanism,<br>the ability to target individual tests from the command line,<br>starting with XCTest as the initial mechanism with the goal of shifting to a more abstract protocol-based approach in the future, and<br>providing machine-readable test results.<br></p><p>These details I have questions or reservations about:<br></p><p>lack of clarity about how to run individual test modules from the command line,<br>lack of clarity about which test modules are run by default with “swift test” (“all of them” is probably the wrong answer),<br>lack of clarity about how test modules interact with Package.swift, and related to that, how a project should specify build configuration and dependencies specific to a particular test module,<br>the “swift build --test” syntax (although I realize that this initial approach is due to larger constraints), and<br>a seeming assumption that extra compilation is essentially free.<br></p><p>This last one deserves special comment. The notion that the build command will also build tests but will not run them seems peculiar, and poorly justified in the document. Why build if you’re not going to use the build output? Developers spend hours shaving fractions of seconds off of their build cycles, and for good reason: development is highly iterative. And not all those iterations involve running tests!<br></p><p>The proposal’s authors’ answer to this seems to run something along the lines of “incremental builds are fast, and slow test builds are a code smell anyway.” That’s a weak justification. Incremental builds are not fast when iterating on changes to a core type that forces recompilation of large swaths of the tests, and even in ideal cases, Swift’s incremental builds are not always as fast in practice as they ought to be in theory. If users’ tests are building slowly, then either (1) that smell is there for a good reason, and you’re punishing users already in pain, or (2) the additional disincentive of slow builds is unlikely to alter behavior for which there are already the much larger disincentives of high maintenance cost and difficulty bringing in new contributors.<br></p><p>The “--without-tests” option does little to allay this concern. Because it is the right default, it will become another hoop to jump through — and Swift developers will forever be swapping shell aliases that make it the default. (Check the number of upvotes on this question: http://stackoverflow.com/questions/1381725/how-to-make-no-ri-no-rdoc-the-default-for-gem-install &lt;http://stackoverflow.com/questions/1381725/how-to-make-no-ri-no-rdoc-the-default-for-gem-install&gt;)<br></p><p>Carthage made similar mistakes about unnecessary builds being approximately free, and has paid for it in a larger stream of user complaints (some written by this author, as you can probably tell).<br></p><p>These concerns aside, this proposal is the right direction. My recommendation is thus to accept it as a vision, direction for development, and first draft, with the expectation that subsequent proposals will address the concerns above.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift … er, the Swift PM?<br></p><p>Yes. As noted above, making testing a first-class citizen of the Swift ecosystem has large cultural benefits. The potential to be able to build dependency tests against a particular set of resolved version is highly appealing. Setting testing standards at the package manager’s outset will help prevent test approach fragmentation, and thus help realize these benefits.<br></p><p>Does this proposal fit well with the feel and direction of the Swift PM?<br></p><p>It does fit with the Swift PM’s general direction of being prescriptive about top-level project structure and standardized build process, while leaving intra-module structure fairly open.<br></p><p>If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I’ve used bundler extensively, which does not address testing at all. Though Ruby has a strong testing culture, individual gem tests are of highly varying quality, and are sometimes difficult to run. Environment-related gem bugs — new Ruby version, incompatible dependency version, etc. — are sometimes a problem, and would presumably be easier to catch if it were easy to run gem tests en masse.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal carefully and asked some questions, but have not followed the whole discussion thread.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Jan 5, 2016, at 1:06 PM, Rick Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Swift Testing” for the Package Manager begins now and runs through Thursday, January 7th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md<br>&gt; <br>&gt; For this particular review, please note that a significant amount of discussion history is available in the original pull request for the proposal:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/pull/51<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; 	- Rick<br>&gt; 	  Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160107/8d813fad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58e2591737c75b7700b11f23381b9590?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Rick Ballard</string> &lt;rballard at apple.com&gt;<p>January  7, 2016 at 11:00:00pm</p></header><div class="content"><p>Thank you, Paul. Your detailed feedback is both appreciated and just the sort of feedback we need to make this process useful.<br></p><p>The concerns that you raise here are the sorts of things that I think we&#39;ll be able to address outside this proposal process. The purpose of this process is to validate our high-level direction, not to vet every last technical detail, so I think we can do things like change the default behavior of `swift build` with respect to test code without going through this process. As such, I&#39;d encourage you to follow up on the swift-build-dev mailing list about your specific reservations and help us get the right specifics in place here as we implement this.<br></p><p>Cheers,<br></p><p>	- Rick<br></p><p>&gt; On Jan 7, 2016, at 9:26 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; I recommend accepting it as a vision and first draft, though not as a releasable product (yet).<br>&gt; <br>&gt; This is a difficult proposal to review because of the way it mixes the general and the specific. On the one hand, it feels like this document’s primary intent is to lay out a large-scale vision, a philosophy of how the Package Manager should treat tests — and more importantly, a vision of the habits package authors should have around writing tests. On the other hand, the proposal is full of very specific details (such as directory structure) — too many such details to evaluate it as a large-scale vision only, yet not enough to evaluate it as a completely specified solution. I’ll therefore take the vision and the details separately.<br>&gt; <br>&gt; I like the proposal’s broad vision very much. It advocates three important cultural norms about testing in Swift, all somewhat contrary to other package management systems, but all ones I approve of:<br>&gt; <br>&gt; The package manager not only allows but proactively encourages package authors to write and maintain tests.<br>&gt; Tests are a uniform feature of Swift packages, with a standard invocation mechanism and standard result reporting (as opposed to being an ad hoc build task that differs from project to project).<br>&gt; Tests should run reproducibly, for everyone, on checkout with no manual setup. It’s just “run tests;” there is no step 2.<br>&gt; <br>&gt; While the proposal doesn’t state all of this quite so specifically, it’s there in the thinking — and I approve. Thinking about this proposal in terms of Chris Lattner’s notion of the “programmer model,” I see this proposal tending toward a world where a package’s tests are run regularly not only but its contributors, but also its clients. That has cultural implications: users will hold package owners accountable if tests are missing, don’t work, or fail to catch problems. “Tests pass for everyone everywhere” is a significantly higher bar than “tests passed for one person somewhere,” and I like a Swift culture built around that higher standard of reproducibility.<br>&gt; <br>&gt; The specific details of the proposal are a mixed bag. These seem good to me:<br>&gt; <br>&gt; the proposed directory structure,<br>&gt; the notion of multiple test modules,<br>&gt; automatic dependency determination between test modules and library targets,<br>&gt; the long-term goal of “swift test” being the command line invocation mechanism,<br>&gt; the ability to target individual tests from the command line,<br>&gt; starting with XCTest as the initial mechanism with the goal of shifting to a more abstract protocol-based approach in the future, and<br>&gt; providing machine-readable test results.<br>&gt; <br>&gt; These details I have questions or reservations about:<br>&gt; <br>&gt; lack of clarity about how to run individual test modules from the command line,<br>&gt; lack of clarity about which test modules are run by default with “swift test” (“all of them” is probably the wrong answer),<br>&gt; lack of clarity about how test modules interact with Package.swift, and related to that, how a project should specify build configuration and dependencies specific to a particular test module,<br>&gt; the “swift build --test” syntax (although I realize that this initial approach is due to larger constraints), and<br>&gt; a seeming assumption that extra compilation is essentially free.<br>&gt; <br>&gt; This last one deserves special comment. The notion that the build command will also build tests but will not run them seems peculiar, and poorly justified in the document. Why build if you’re not going to use the build output? Developers spend hours shaving fractions of seconds off of their build cycles, and for good reason: development is highly iterative. And not all those iterations involve running tests!<br>&gt; <br>&gt; The proposal’s authors’ answer to this seems to run something along the lines of “incremental builds are fast, and slow test builds are a code smell anyway.” That’s a weak justification. Incremental builds are not fast when iterating on changes to a core type that forces recompilation of large swaths of the tests, and even in ideal cases, Swift’s incremental builds are not always as fast in practice as they ought to be in theory. If users’ tests are building slowly, then either (1) that smell is there for a good reason, and you’re punishing users already in pain, or (2) the additional disincentive of slow builds is unlikely to alter behavior for which there are already the much larger disincentives of high maintenance cost and difficulty bringing in new contributors.<br>&gt; <br>&gt; The “--without-tests” option does little to allay this concern. Because it is the right default, it will become another hoop to jump through — and Swift developers will forever be swapping shell aliases that make it the default. (Check the number of upvotes on this question: http://stackoverflow.com/questions/1381725/how-to-make-no-ri-no-rdoc-the-default-for-gem-install &lt;http://stackoverflow.com/questions/1381725/how-to-make-no-ri-no-rdoc-the-default-for-gem-install&gt;)<br>&gt; <br>&gt; Carthage made similar mistakes about unnecessary builds being approximately free, and has paid for it in a larger stream of user complaints (some written by this author, as you can probably tell).<br>&gt; <br>&gt; These concerns aside, this proposal is the right direction. My recommendation is thus to accept it as a vision, direction for development, and first draft, with the expectation that subsequent proposals will address the concerns above.<br>&gt; <br>&gt; Is the problem being addressed significant enough to warrant a change to Swift … er, the Swift PM?<br>&gt; <br>&gt; Yes. As noted above, making testing a first-class citizen of the Swift ecosystem has large cultural benefits. The potential to be able to build dependency tests against a particular set of resolved version is highly appealing. Setting testing standards at the package manager’s outset will help prevent test approach fragmentation, and thus help realize these benefits.<br>&gt; <br>&gt; Does this proposal fit well with the feel and direction of the Swift PM?<br>&gt; <br>&gt; It does fit with the Swift PM’s general direction of being prescriptive about top-level project structure and standardized build process, while leaving intra-module structure fairly open.<br>&gt; <br>&gt; If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I’ve used bundler extensively, which does not address testing at all. Though Ruby has a strong testing culture, individual gem tests are of highly varying quality, and are sometimes difficult to run. Environment-related gem bugs — new Ruby version, incompatible dependency version, etc. — are sometimes a problem, and would presumably be easier to catch if it were easy to run gem tests en masse.<br>&gt; <br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I read the proposal carefully and asked some questions, but have not followed the whole discussion thread.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 1:06 PM, Rick Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of “Swift Testing” for the Package Manager begins now and runs through Thursday, January 7th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md&gt;<br>&gt;&gt; <br>&gt;&gt; For this particular review, please note that a significant amount of discussion history is available in the original pull request for the proposal:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/pull/51<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; 	- Rick<br>&gt;&gt; 	  Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160107/f7b94269/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>January  8, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>only as an additional data-point and without me having read the proposal very deeply<br></p><p>&gt; On 8 Jan 2016, at 06:26, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>[snip]<br></p><p>&gt; These details I have questions or reservations about:<br>&gt; <br>&gt; 	• lack of clarity about how to run individual test modules from the command line,<br>&gt; 	• lack of clarity about which test modules are run by default with “swift test” (“all of them” is probably the wrong answer),<br>&gt; 	• lack of clarity about how test modules interact with Package.swift, and related to that, how a project should specify build configuration and dependencies specific to a particular test module,<br>&gt; 	• the “swift build --test” syntax (although I realize that this initial approach is due to larger constraints), and<br>&gt; 	• a seeming assumption that extra compilation is essentially free.<br></p><p>I have next to no experience with Swift, but for a (heavily template-based… :/) C++ code, the compilation time of the unit tests is an order of magnitude longer than the compilation time of the actual code / library itself.<br>I would advise only compiling the tests when they are actually used (run).<br></p><p>For said C++ code we use waf (https://waf.io) as build-tool and our default build (triggered by `./waf`) only builds the library itself, while `./waf test` performs the normal build and in addition compiles and runs the tests (including correct dependency checking so that only those tests that need to be recompiled or rerun due to changes in the library itself do so). This later command then has options for forcing running of all or no tests.<br>This seems to work quite well for us in that context.<br></p><p>	Daniel.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>There is certainly a difference between Swift (the language) evolution proposals and SwiftPM evolution proposals.<br></p><p>Language features should be considered unchangeable (you might have to change them one day, but to do so is painful to the ecosystem)<br></p><p>SwiftPM is a tool, we can change it, especially since it is pre-1.0, we should be careful still, but our proposals are submitted here with the understanding that they are foundations, and not complete solutions. We will iterate<br></p><p>We can reverse decisions. For example, building tests by default is controversial, and perhaps it is unwise. We’ll find out in due course, I for one have no problem with reversing a decision provided it is proved incorrect.<br></p><p>Honestly I am leaning towards thinking it is idealist and not practical already, but I’d still like to try it out and see.<br></p><p>&gt; lack of clarity about how to run individual test modules from the command line,<br></p><p>I imagine it would be `swift test foo` where foo is the test module name.<br></p><p>&gt; lack of clarity about which test modules are run by default with “swift test” (“all of them” is probably the wrong answer),<br></p><p>Why is all of them the wrong answer? It seems to be the only sensible default to me. Clearly there should be a way to configure that in Package.swift, but that is for another proposal.<br></p><p>&gt; lack of clarity about how test modules interact with Package.swift, and related to that, how a project should specify build configuration and dependencies specific to a particular test module,<br></p><p>We already have a testDependencies option in Package.swift, hence the lack of clarity here. However Package.swift needs a rethink IMO. I plan to propose changes in a few weeks after seeing it in the wild for longer.<br></p><p>Thanks for your input Paul,<br></p><p>Max<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/4e63b96f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 1:57 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; We will iterate.<br>&gt; …<br>&gt; We can reverse decisions. For example, building tests by default is controversial, and perhaps it is unwise. We’ll find out in due course, I for one have no problem with reversing a decision provided it is proved incorrect.<br></p><p>That’s good to know.<br></p><p>Really, my reaction to this whole proposal is that I won’t really know until I try it, so let’s try it!<br></p><p>&gt;&gt; lack of clarity about how to run individual test modules from the command line,<br>&gt; <br>&gt; I imagine it would be `swift test foo` where foo is the test module name.<br></p><p>Disambiguating between test module names and test names would need some thought then, but probably that’s easily solved.<br></p><p>&gt;&gt; lack of clarity about which test modules are run by default with “swift test” (“all of them” is probably the wrong answer),<br>&gt; <br>&gt; Why is all of them the wrong answer? It seems to be the only sensible default to me. Clearly there should be a way to configure that in Package.swift, but that is for another proposal.<br></p><p>It depends on what all those different test modules are.<br></p><p>One possibility is that they’re arbitrary functional groupings: Tests/Validation, Tests/Computation, Tests/Formatting. In that case, “all of them” is right. But I don’t know anybody who organizes test modules at the top level like that.<br></p><p>Another possibility is that they correspond to targets/submodules under Sources: Tests/Core, Tests/FancyAddOn, Tests/UIKitExtensions, Tests/WatchKitExtensions. In that case, the default would be to build &amp; run the tests for whatever source module(s) you’re building.<br></p><p>A third possibility is that they correspond to different _kinds_ of testing: Tests/Regression, Tests/Integration, Tests/Performance. In this example, the integration tests might require some kind of environment setup, the performance tests might take 60 seconds to run, and so you’d only want the regression tests to run by default.<br></p><p>OK, so maybe “all of them” is the default and it’s overridable … but I tend to think that there should be a default of Sources/Foo running only Tests/Foo by default. Something along those lines.<br></p><p>Cheers, P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160108/66ad6959/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58e2591737c75b7700b11f23381b9590?s=50"></div><header><strong>[swift-evolution] [Review] SE-0019 Swift Testing (Package Manager)</strong> from <string>Rick Ballard</string> &lt;rballard at apple.com&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>This review has completed and the proposal is now &quot;Under Revision&quot;. A second review will be scheduled once revisions are complete. Thank you all for your feedback.<br></p><p>	- Rick<br>	  Review Manager<br></p><p>&gt; On Jan 5, 2016, at 11:06 AM, Rick Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of “Swift Testing” for the Package Manager begins now and runs through Thursday, January 7th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0019-package-manager-testing.md<br>&gt; <br>&gt; For this particular review, please note that a significant amount of discussion history is available in the original pull request for the proposal:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/pull/51<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; 	- Rick<br>&gt; 	  Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
