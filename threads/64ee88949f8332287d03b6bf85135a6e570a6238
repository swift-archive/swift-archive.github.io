<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Harmonize access modifiers for extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 16, 2016 at 01:00:00pm</p></header><div class="content"><p>With the impending withdrawal of SE-0119 and the closing window for (most)<br>source-breaking changes, I thought I&#39;d draft up a proposal to address some<br>of the key points raised in that discussion.<br></p><p>The proposed changes are deliberately limited in scope to rationalizing<br>access modifier rules without adding any new facilities (such as<br>conformances of lower visibility than the type), which might be more<br>appropriate for the Swift 4 timeline.<br></p><p>I hope this will prove satisfactory to the community :)<br></p><p><br>Harmonize access modifiers for extensions<br></p><p>   - Proposal: SE-XXXX<br>   &lt;https://github.com/xwu/swift-evolution/blob/harmonize-access-modifiers/proposals/XXXX-harmonize-access-modifiers.md&gt;<br>   - Author: Xiaodi Wu &lt;https://github.com/xwu&gt;<br>   - Status: Awaiting review<br>   - Review manager: TBD<br></p><p>&lt;https://github.com/xwu/swift-evolution/tree/harmonize-access-modifiers#introduction&gt;<br>Introduction<br></p><p>During discussion of SE-0119<br>&lt;https://github.com/xwu/swift-evolution/blob/harmonize-access-modifiers/proposals/0119-extensions-access-modifiers&gt;,<br>the community articulated the view that access modifiers for extensions<br>were and should continue to be subject to the same rules as access<br>modifiers for types. Unfortunately, it is not factually true today; this<br>proposal aims to make it so.<br></p><p>Swift-evolution threads:<br></p><p>   - [Proposal] Revising access modifiers on extensions<br>   &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160620/022144.html&gt;<br>   - [More to be added here]<br></p><p>&lt;https://github.com/xwu/swift-evolution/tree/harmonize-access-modifiers#motivation&gt;<br>Motivation<br></p><p>Consider the following:<br></p><p>public struct foo {<br>  func frobnicate() { } // implicitly internal<br>}<br>public extension foo { }<br></p><p>public struct bar { }<br>public extension bar {<br>  func frobnicate() { } // implicitly public, according to SE-0025<br>}<br></p><p>According to SE-0025, a method moved from the body of a public struct into<br>a public extension becomes public without modification. This is surprising<br>behavior contrary to Swift&#39;s general rule of not exposing public API by<br>default.<br></p><p>Furthermore, SE-0025 now permits the owner of a type to design access for<br>members as though the type will have a higher access level than it<br>currently does. For example, users will be able to design public methods<br>inside an internaltype before &quot;flipping the switch&quot; and making that type<br>public. The same approach is prohibited by SE-0025 for extensions, although<br>conceptually it need not be.<br>&lt;https://github.com/xwu/swift-evolution/tree/harmonize-access-modifiers#proposed-solution&gt;Proposed<br>solution<br></p><p>The proposed solution is to change access modifier rules for extensions<br>with the following effect: if any method (or computed property) declared<br>within the body of a type at file scope is moved without modification into<br>the body of an extension in the same file, the move will not change its<br>accessibility.<br></p><p>In code:<br></p><p>struct foo {<br>  // Any method declared here...<br>}<br>extension foo {<br>  // ...should have the same visibility when moved here.<br>}<br></p><p>This implies that public API commitments will need to be annotated as public at<br>declaration sites inside an extension just as it must be at declaration<br>sites inside types.<br>&lt;https://github.com/xwu/swift-evolution/tree/harmonize-access-modifiers#detailed-design&gt;Detailed<br>design<br></p><p>   1. Declarations inside the extension will, like declarations inside<br>   types, have a default access level of internal.<br>   2. The compiler should not warn when a broader level of access control<br>   is used for a method (or computed property, etc.) declared within an<br>   extension with more restrictive access. This allows the owner of the<br>   extension to design the access level they would use for a method if the<br>   type or extension were to be made more widely accessible.<br>   3. An extension declared without an explicit access modifier will have<br>   the same access level as the type being extended.<br>   4. An extension declared without protocol conformance may optionally use<br>   an explicit access modifier to provide an upper bound for the visibility of<br>   its members.<br></p><p>&lt;https://github.com/xwu/swift-evolution/tree/harmonize-access-modifiers#alternatives-considered&gt;Alternatives<br>considered<br></p><p>   - One alternative, still open for consideration, is to eliminate #4 and<br>   disallow explicit access modifiers on extensions. As an advantage, this<br>   would clarify the mental model that extensions are not their own entities,<br>   as they cannot be referred to by name and have no runtime representation.<br>   As a disadvantage, extensions cease to be an access modifier grouping<br>   construct, which some users really like.<br></p><p>&lt;https://github.com/xwu/swift-evolution/tree/harmonize-access-modifiers#acknowledgments&gt;<br>Acknowledgments<br></p><p>Thanks to all discussants on the list, especially Adrian Zubarev and Jose<br>Cheyo Jimenez.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/64ee6238/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Draft] Harmonize access modifiers for extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 16, 2016 at 08:00:00pm</p></header><div class="content"><p>Have you by any chance meant this?<br></p><p>You can extend a class, structure, or enumeration in any access context in which the class, structure, or enumeration is available. Any type members added in an extension have the same default access level as type members declared in the original type being extended. If you extend a public or internal type, any new type members you add will have a default access level of internal. If you extend a private type, any new type members you add will have a default access level of private.<br></p><p>[HERE]: Alternatively, you can mark an extension with an explicit access level modifier (for example, private extension) to set a new default access level for all members defined within the extension.<br></p><p>This new default can still be overridden within the extension for individual type members.<br></p><p>Source<br>This is not according SE–0025 to me. It’s how access control on extensions worked all the time (which I misunderstood when posting my first draft).<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 16. Juli 2016 um 20:04:38, Xiaodi Wu via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>According to SE-0025, a method moved from the body of a public struct into a public extension becomes public without modification. This is surprising behavior contrary to Swift&#39;s general rule of not exposing public API by default.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/38aa7491/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Harmonize access modifiers for extensions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 16, 2016 at 01:00:00pm</p></header><div class="content"><p>On Sat, Jul 16, 2016 at 1:13 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Have you by any chance meant this?<br>&gt;<br>&gt; You can extend a class, structure, or enumeration in any access context in<br>&gt; which the class, structure, or enumeration is available. Any type members<br>&gt; added in an extension have the same default access level as type members<br>&gt; declared in the original type being extended. If you extend a public or<br>&gt; internal type, any new type members you add will have a default access<br>&gt; level of internal. If you extend a private type, any new type members you<br>&gt; add will have a default access level of private.<br>&gt;<br>&gt; [HERE]: *Alternatively, you can mark an extension with an explicit access<br>&gt; level modifier (for example, private extension) to set a new default access<br>&gt; level for all members defined within the extension.*<br>&gt;<br>&gt; This new default can still be overridden within the extension for<br>&gt; individual type members.<br>&gt;<br>&gt; Source<br>&gt; &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html&gt;<br>&gt;<br>&gt; This is not according SE–0025 to me. It’s how access control on extensions<br>&gt; worked all the time (which I misunderstood when posting my first draft).<br>&gt;<br></p><p>Ah right; it is how it&#39;s always worked. I will amend the Motivation section<br>to say that.<br></p><p>Am 16. Juli 2016 um 20:04:38, Xiaodi Wu via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; According to SE-0025, a method moved from the body of a public struct into<br>&gt; a public extension becomes public without modification. This is surprising<br>&gt; behavior contrary to Swift&#39;s general rule of not exposing public API by<br>&gt; default.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/9155393f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
