<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Pitch] Remove transparent bridging between Swift strings and char *</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>June 22, 2016 at 09:00:00am</p></header><div class="content"><p>Hi All.<br></p><p>In the spirit of Chris’ focus on Swift 3 message…<br></p><p>I’ve been working on calling C code that takes “const char * const *” arguments, and it ain’t easy, but that can be left for a future proposal…<br></p><p>What does surprise me is that Swift String bridges directly into “char *” arguments in C as nul-terminated C strings, apparently preserving unicode and all. I can find nothing on bridging to “char *” in “Using Swift with Cocoa and Objective-C&quot;<br></p><p>In the spirit of preventing you from hurting yourself, I think this functionality should be removed, forcing you to use cString(using:) first.<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Remove transparent bridging between Swift strings and char *</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;ve actually enjoyed this hidden feature on several occasions. It nicely allows you to interact with C APIs such as:<br></p><p>system(&quot;rm -rf ~/*&quot;)<br></p><p>Could you please elaborate a bit on the &quot;hurting yourself&quot; part? Do you mean e.g. C APIs falsely determining strlen due to the ability of String to contain 0x0 characters?<br></p><p>&gt; On Jun 22, 2016, at 6:37 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi All.<br>&gt; <br>&gt; In the spirit of Chris’ focus on Swift 3 message…<br>&gt; <br>&gt; I’ve been working on calling C code that takes “const char * const *” arguments, and it ain’t easy, but that can be left for a future proposal…<br>&gt; <br>&gt; What does surprise me is that Swift String bridges directly into “char *” arguments in C as nul-terminated C strings, apparently preserving unicode and all. I can find nothing on bridging to “char *” in “Using Swift with Cocoa and Objective-C&quot;<br>&gt; <br>&gt; In the spirit of preventing you from hurting yourself, I think this functionality should be removed, forcing you to use cString(using:) first.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Pitch] Remove transparent bridging between Swift strings and char *</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 22, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 9:37 AM, Kenny Leung via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi All.<br>&gt;<br>&gt; In the spirit of Chris’ focus on Swift 3 message…<br>&gt;<br>&gt; I’ve been working on calling C code that takes “const char * const *” arguments, and it ain’t easy, but that can be left for a future proposal…<br>&gt;<br>&gt; What does surprise me is that Swift String bridges directly into “char *” arguments in C as nul-terminated C strings, apparently preserving unicode and all. I can find nothing on bridging to “char *” in “Using Swift with Cocoa and Objective-C&quot;<br></p><p>I think it is too useful for the C interop that it would not be<br>feasible for it to be removed completely.  One tweak that I think we<br>should consider making is removing this implicit conversion when<br>calling Swift code, and only leave it for calling imported functions.<br>The reasoning is that Swift code should not be using<br>UnsafePointer&lt;UInt8&gt; to pass strings around.<br></p><p>We might need to leave an escape hatch (an underscored attribute) to<br>opt into this behavior for the overlays though.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Pitch] Remove transparent bridging between Swift strings and char *</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>June 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 22 Jun 2016, at 17:37, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What does surprise me is that Swift String bridges directly into “char *” arguments in C as nul-terminated C strings, apparently preserving unicode and all. I can find nothing on bridging to “char *” in “Using Swift with Cocoa and Objective-C&quot;<br></p><p>* Using Swift with Cocoa and Objective-C &gt; Interoperability &gt; Interacting with C APIs &gt; Pointers &gt; Constant Pointers:<br></p><p>&quot;When a function is declared as taking a UnsafePointer&lt;Type&gt; argument, it can accept [...] A String value, if Type is Int8 or UInt8. The string will automatically be converted to UTF8 in a buffer, and a pointer to that buffer is passed to the function.&quot;<br></p><p>&gt; In the spirit of preventing you from hurting yourself, I think this functionality should be removed, forcing you to use cString(using:) first.<br></p><p>Do you mean the encoding should always be given, instead of using UTF-8 by default? I think the no-argument -[NSString cString] method was deprecated for this reason?<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Pitch] Remove transparent bridging between Swift strings and char *</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>June 22, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks! Missed that.<br></p><p>I think it would be OK if the transparent bridging called cString(using:) itself, and the whole thing would fail if the conversion fails.<br></p><p>-Kenny<br></p><p><br>&gt; On Jun 22, 2016, at 11:52 AM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 Jun 2016, at 17:37, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What does surprise me is that Swift String bridges directly into “char *” arguments in C as nul-terminated C strings, apparently preserving unicode and all. I can find nothing on bridging to “char *” in “Using Swift with Cocoa and Objective-C&quot;<br>&gt; <br>&gt; * Using Swift with Cocoa and Objective-C &gt; Interoperability &gt; Interacting with C APIs &gt; Pointers &gt; Constant Pointers:<br>&gt; <br>&gt; &quot;When a function is declared as taking a UnsafePointer&lt;Type&gt; argument, it can accept [...] A String value, if Type is Int8 or UInt8. The string will automatically be converted to UTF8 in a buffer, and a pointer to that buffer is passed to the function.&quot;<br>&gt; <br>&gt;&gt; In the spirit of preventing you from hurting yourself, I think this functionality should be removed, forcing you to use cString(using:) first.<br>&gt; <br>&gt; Do you mean the encoding should always be given, instead of using UTF-8 by default? I think the no-argument -[NSString cString] method was deprecated for this reason?<br>&gt; <br>&gt; -- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Pitch] Remove transparent bridging between Swift strings and char *</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 22 Jun 2016, at 20:02, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think it would be OK if the transparent bridging called cString(using:) itself, and the whole thing would fail if the conversion fails.<br></p><p>But the cString(using:) method is from Foundation, and using UTF-8 should always succeed in any case.<br></p><p>UTF-8 by default is probably correct for POSIX APIs, but maybe not for Windows APIs (if code pages are expected).<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Pitch] Remove transparent bridging between Swift strings and char *</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>June 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 12:37 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; But the cString(using:) method is from Foundation, and using UTF-8 should always succeed in any case.<br></p><p>I suppose you’re right about that, but now it brings up more confusion in my mind about what’s in Foundation and what’s in the standard library. So would there be extensions on String in (Swift) Foundation that implements cString(encoding:)? What decides what functions are in the standard library and what are in Foundation?<br></p><p>&gt; UTF-8 by default is probably correct for POSIX APIs, but maybe not for Windows APIs (if code pages are expected).<br></p><p>I guess it all depends on what you think should be valid for C strings. Based on the documentation, I guess the core team thinks UTF-8 is valid.<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00464d59365595ecaebd19b44de312fa?s=50"></div><header><strong>[Pitch] Remove transparent bridging between Swift strings and char *</strong> from <string>Gwynne Raskind</string> &lt;gwynne at darkrainfall.org&gt;<p>June 22, 2016 at 04:00:00pm</p></header><div class="content"><p>As I understand it, UTF-8 for POSIX APIs is always (usually?) valid on macOS, valid on Linux _IF_ your LANG etc. are set to C or en_US.UTF-8, and of questionable validity on Windows. Is the stdlib possibly converting to the &quot;system encoding&quot; underneath and possibly silently dropping characters it can’t translate when the encoding is not UTF-8? Whichever thing is actually happening, I definitely agree this needs to be documented. I also somewhat agree that forcing an explicit call to a cString accessor is not entirely unreasonable (though it does present a danger of allowing such pointers to escape calls to C APIs, normally you would never see the raw value and there’s no reason to think it remains valid outside the scope of the conversion). Interop with C should be easy, but it shouldn’t be so easy that you can ignore the way the APIs work - dealing in UnsafePointers means thinking hard about memory management, even more so in some ways when doing interop from Swift than in plain C.<br></p><p>That having been said, the encoding issue is the part that concerns me more than the rest, I have no strong opinion either way about changing how the automatic bridging happens. If the encoding semantics were documented (maybe even with examples showing how to do it manually if you need more control for special cases), I’d be satisfied with the status quo.<br></p><p>-- Gwynne Raskind<br></p><p><br></p><p>&gt; On Jun 22, 2016, at 15:01, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 12:37 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt;&gt; But the cString(using:) method is from Foundation, and using UTF-8 should always succeed in any case.<br>&gt; <br>&gt; I suppose you’re right about that, but now it brings up more confusion in my mind about what’s in Foundation and what’s in the standard library. So would there be extensions on String in (Swift) Foundation that implements cString(encoding:)? What decides what functions are in the standard library and what are in Foundation?<br>&gt; <br>&gt;&gt; UTF-8 by default is probably correct for POSIX APIs, but maybe not for Windows APIs (if code pages are expected).<br>&gt; <br>&gt; I guess it all depends on what you think should be valid for C strings. Based on the documentation, I guess the core team thinks UTF-8 is valid.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
