<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Formatted version: https://github.com/DevAndArtist/swift-evolution/blob/refactor_metatypes/proposals/0126-refactor-metatypes.md<br></p><p>Refactor Metatypes<br></p><p>Proposal: SE–0126<br>Authors: Adrian Zubarev, Anton Zhilin, Brent Royal-Gordon<br>Status: Revision<br>Review manager: Chris Lattner<br>Revision: 2<br>Previous Revisions: 1<br>Introduction<br></p><p>This proposal removes .Type and .Protocol in favor of two generic-style syntaxes and aligns global type(of:) function (SE–0096) to match the changes.<br></p><p>Swift-evolution thread (post Swift 3):<br></p><p>[Pitch] Refactor Metatypes<br>Older swift-evolution threads: [1], [2], [3]<br></p><p>Motivation<br></p><p>Every type T has an instance, accessible through T.self, which represents the type itself. Like all instances in Swift, this “type instance” itself has a type, which is referred to as its “metatype”. The metatype of T is written T.Type. The instance members of the metatype are the same as the static or class members of the type.<br></p><p>Metatypes have subtype relationships which reflect the types they represent. For instance, given these types:<br></p><p>protocol Proto {}<br>class Base {}<br>class Derived: Base, Proto {}<br>Derived.Type is a subtype of both Base.Type and Proto.Type (and Any.Type). That means that Derived.self can be used anywhere a Derived.Type, Base.Type, Proto.Type, or Any.Type is called for.<br></p><p>Unfortunately, this simple picture is complicated by protocols. Proto.self is actually of type Proto.Protocol, not type Proto.Type. This is necessary because the protocol does not, and cannot, conform to itself; it requires conforming types to provide static members, but it doesn’t actually provide those members itself. Proto.Type still exists, but it is the supertype of all types conforming to the protocol.<br></p><p>Making this worse, a generic type always uses T.Type to refer to the type of T.self. So when Proto is bound to a generic parameter P, P.Type is the same as Proto.Protocol.<br></p><p>This shifting of types is complicated and confusing; we seek to clean up this area.<br></p><p>We also believe that, in the long term, the dot syntax will prevent us from implementing certain future enhancements that might be valuable:<br></p><p>Moving the implementation of metatypes at least partly into the standard library.<br>Adding members available on all type instances for features like read-write reflection or memory layout information.<br>Conforming metatypes to protocols like Hashable or CustomStringConvertible.<br>Offering straightforward syntaxes for dynamic features like looking up types by name.<br>Proposed solution<br></p><p>We abolish .Type and .Protocol in favor of two generic-style syntaxes:<br></p><p>Type&lt;T&gt; is the concrete type of T.self. A Type&lt;T&gt; only ever has one instance, T.self; even if T has a subtype U, Type&lt;U&gt; is not a subtype of Type&lt;T&gt;.<br></p><p>Subtype&lt;T&gt; is the supertype of all Types whose instances are subtypes of T, including T itself:<br></p><p>If T is a struct or enum, then Type&lt;T&gt; is the only subtype of Subtype&lt;T&gt;.<br></p><p>If T is a class, then Type&lt;T&gt; and the Types of all subclasses of T are subtypes of Subtype&lt;T&gt;.<br></p><p>If T is a protocol, then the Types of all concrete types conforming to T are subtypes of Subtype&lt;T&gt;. Type&lt;T&gt; is not itself a subtype of Subtype&lt;T&gt;, or of any Subtype other than Subtype&lt;Any&gt;.<br></p><p>Structural types follow the subtype/supertype relationships of their constituent types. For instance:<br></p><p>Type&lt;(NSString, NSString)&gt; is a subtype of Subtype&lt;(NSObject, NSObject)&gt;<br></p><p>Metatypes of functions are a little bit more special (the subtyping relation on functions flips around for parameter types):<br></p><p>Type&lt;(Any) -&gt; Void&gt; is a subtype of Subtype&lt;(Int) -&gt; Void&gt; etc.<br>Type&lt;(Void) -&gt; Int&gt; is a subtype of Subtype&lt;(Void) -&gt; Any&gt;<br>In this new notation, some of our existing standard library functions would have signatures like:<br></p><p>func unsafeBitCast&lt;T, U&gt;(_: T, to type: Type&lt;U&gt;) -&gt; U<br>func ==(t0: Subtype&lt;Any&gt;?, t1: Subtype&lt;Any&gt;?) -&gt; Bool<br>func type&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt; // SE-0096<br>That last example, type(of:), is rather interesting, because it is actually a magic syntax rather than a function. We propose to align this syntax with Type and Subtype by renaming it to Subtype(of:). We believe this is clearer about both the type and meaning of the operation.<br></p><p>let anInstance: NSObject = NSString()<br>let aClass: Subtype&lt;NSObject&gt; = Subtype(of: anInstance)<br></p><p>print(aClass) // =&gt; NSString<br>More details:<br></p><p>Every static or class member of T which can be called on all subtypes is an instance member of Subtype&lt;T&gt;. That includes:<br></p><p>Static/class properties and methods<br></p><p>Required initializers (as methods named init)<br></p><p>Unbound instance methods<br></p><p>The Type&lt;T&gt; of a concrete type T has all of the members required by Subtype&lt;T&gt;, plus non-required initializers.<br></p><p>The Type&lt;T&gt; of a protocol T includes only unbound instance methods of T.<br></p><p>If T conforms to P, then Subtype&lt;T&gt; is a subtype of Subtype&lt;P&gt;, even if T is a protocol.<br></p><p>The type of Subtype&lt;T&gt;.self is Type&lt;Subtype&lt;T&gt;&gt;.<br></p><p>The type of Type&lt;T&gt;.self is Type&lt;Type&lt;T&gt;&gt;, which is not a subtype of any type except Subtype&lt;Type&lt;T&gt;&gt;. There is an infinite regress of Type&lt;...&lt;Type&lt;T&gt;&gt;&gt;s.<br></p><p>Subtypes are abstract types similar to class-bound protocols; they, too, support identity operations.<br></p><p>Types are concrete reference types which have identities just like objects do.<br></p><p>swift Int.self === Int.self // true Int.self === Any.self // false<br></p><p>Visual metatype relationship example (not a valid Swift code)<br>Some examples<br>Future Directions<br></p><p>We could allow extensions on Type and perhaps on Subtype to add members or conform them to protocols. This could allow us to remove some standard library hacks, like the non-Equatable-related == operators for types.<br></p><p>It may be possible to implement parts of Type as a fairly ordinary final class, moving code from the runtime into the standard library.<br></p><p>We could offer a Subtype(ofType: Type&lt;T&gt;, named: String) pseudo-initializer which would allow type-safe access to classes by name.<br></p><p>We could offer other reflection and dynamic features on Type and Subtype.<br></p><p>We could move the MemoryLayout members into Type (presumably prefixed), removing the rather artificial MemoryLayout enum.<br></p><p>Along with other generics enhancements, there may be a use for a Subprotocol&lt;T&gt; syntax for any protocol requiring conformance to protocol T.<br></p><p>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator.<br></p><p>We suggest the following migration process; this can differ from the final migration process implemented by the core team if this proposal will be accepted:<br></p><p>Any.Type is migrated to Subtype&lt;Any&gt;.<br>If T.Type is in function parameter, where T is a generic type parameter, then it’s migrated to Type&lt;T&gt;.<br>Every T.Protocol will be replaced with Type&lt;T&gt;.<br>Every T.Type in a dynamic cast will be replaced with Subtype&lt;T&gt;.<br>If static members are called on a metatype instance, then this instance is migrated to Subtype&lt;T&gt;.<br>Return types of functions are migrated to Subtype&lt;T&gt;.<br>Variable declarations is migrated to Subtype&lt;T&gt;.<br>Alternatives considered<br></p><p>Other names for Type and Subtype were considered:<br></p><p>Type: SpecificType, Metatype or ExactType.<br>Subtype: Supertype, Base, BaseType, ExistentialType or TypeProtocol.<br>Alternatively the pseudo initializer Subtype(of:) could remain as a global function:<br></p><p>public func subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/b799723b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>September 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Let me first say that this new draft does a great job of explaining the<br>current situation and the goals of the proposal. The revised “Motivation”<br>section in particular is very clearly written and introduces the concepts<br>effectively.<br></p><p>I found the previous versions to be highly confusing, and I did not<br>understand from them what was being proposed and why. After reading this<br>one, I feel that I finally comprehend the situation, both in terms of how<br>metatypes behave today and how the authors would like them to work.<br></p><p>This is still an area where I do not have much expertise, so I look forward<br>to hearing what better-versed people think of the overall approach as well<br>as the specific details.<br></p><p>Nevin<br></p><p><br></p><p>On Wed, Sep 28, 2016 at 6:18 AM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Formatted version: https://github.com/DevAndArtist/swift-evolution/<br>&gt; blob/refactor_metatypes/proposals/0126-refactor-metatypes.md<br>&gt; ------------------------------<br>&gt; Refactor Metatypes<br>&gt;<br>&gt;    - Proposal: SE–0126<br>&gt;    &lt;http://0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;    - Authors: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;, Anton<br>&gt;    Zhilin &lt;https://github.com/Anton3&gt;, Brent Royal-Gordon<br>&gt;    &lt;https://github.com/brentdax&gt;<br>&gt;    - Status: *Revision*<br>&gt;    - Review manager: Chris Lattner &lt;http://github.com/lattner&gt;<br>&gt;    - Revision: 2<br>&gt;    - Previous Revisions: 1<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/83707b0879c83dcde778f8163f5768212736fdc2/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal removes .Type and .Protocol in favor of two generic-style<br>&gt; syntaxes and aligns global type(of:) function (SE–0096) to match the<br>&gt; changes.<br>&gt;<br>&gt; Swift-evolution thread (post Swift 3):<br>&gt;<br>&gt;    - [Pitch] Refactor Metatypes<br>&gt;<br>&gt; Older swift-evolution threads: [1]<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/025115.html&gt;,<br>&gt; [2]<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/024772.html&gt;,<br>&gt; [3]<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/023818.html&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Every type T has an instance, accessible through T.self, which represents<br>&gt; the type itself. Like all instances in Swift, this “type instance” itself<br>&gt; has a type, which is referred to as its “metatype”. The metatype of T is<br>&gt; written T.Type. The instance members of the metatype are the same as the<br>&gt; static or class members of the type.<br>&gt;<br>&gt; Metatypes have subtype relationships which reflect the types they<br>&gt; represent. For instance, given these types:<br>&gt;<br>&gt; protocol Proto {}<br>&gt; class Base {}<br>&gt; class Derived: Base, Proto {}<br>&gt;<br>&gt; Derived.Type is a subtype of both Base.Type and Proto.Type (and Any.Type).<br>&gt; That means that Derived.self can be used anywhere a Derived.Type,<br>&gt; Base.Type, Proto.Type, or Any.Type is called for.<br>&gt;<br>&gt; Unfortunately, this simple picture is complicated by protocols. Proto.self<br>&gt; is actually of type Proto.Protocol, not type Proto.Type. This is<br>&gt; necessary because the protocol does not, and cannot, conform to itself; it<br>&gt; requires conforming types to provide static members, but it doesn’t<br>&gt; actually provide those members itself. Proto.Type still exists, but it is<br>&gt; the supertype of all types conforming to the protocol.<br>&gt;<br>&gt; Making this worse, a generic type always uses T.Type to refer to the type<br>&gt; of T.self. So when Proto is bound to a generic parameter P, P.Type is the<br>&gt; same as Proto.Protocol.<br>&gt;<br>&gt; This shifting of types is complicated and confusing; we seek to clean up<br>&gt; this area.<br>&gt;<br>&gt; We also believe that, in the long term, the dot syntax will prevent us<br>&gt; from implementing certain future enhancements that might be valuable:<br>&gt;<br>&gt;    - Moving the implementation of metatypes at least partly into the<br>&gt;    standard library.<br>&gt;    - Adding members available on all type instances for features like<br>&gt;    read-write reflection or memory layout information.<br>&gt;    - Conforming metatypes to protocols like Hashable or<br>&gt;    CustomStringConvertible.<br>&gt;    - Offering straightforward syntaxes for dynamic features like looking<br>&gt;    up types by name.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; We abolish .Type and .Protocol in favor of two generic-style syntaxes:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Type&lt;T&gt; is the concrete type of T.self. A Type&lt;T&gt; only ever has one<br>&gt;    instance, T.self; even if T has a subtype U, Type&lt;U&gt; is not a subtype<br>&gt;    of Type&lt;T&gt;.<br>&gt;    -<br>&gt;<br>&gt;    Subtype&lt;T&gt; is the supertype of all Types whose instances are subtypes<br>&gt;    of T, including T itself:<br>&gt;    -<br>&gt;<br>&gt;    If T is a struct or enum, then Type&lt;T&gt; is the only subtype of<br>&gt;    Subtype&lt;T&gt;.<br>&gt;    -<br>&gt;<br>&gt;    If T is a class, then Type&lt;T&gt; and the Types of all subclasses of T are<br>&gt;    subtypes of Subtype&lt;T&gt;.<br>&gt;    -<br>&gt;<br>&gt;    If T is a protocol, then the Types of all concrete types conforming to<br>&gt;    T are subtypes of Subtype&lt;T&gt;. Type&lt;T&gt; is not itself a subtype of<br>&gt;    Subtype&lt;T&gt;, or of any Subtype other than Subtype&lt;Any&gt;.<br>&gt;    -<br>&gt;<br>&gt;    Structural types follow the subtype/supertype relationships of their<br>&gt;    constituent types. For instance:<br>&gt;    -<br>&gt;<br>&gt;    Type&lt;(NSString, NSString)&gt; is a subtype of Subtype&lt;(NSObject,<br>&gt;    NSObject)&gt;<br>&gt;    -<br>&gt;<br>&gt;    Metatypes of functions are a little bit more special (the subtyping<br>&gt;    relation on functions flips around for parameter types<br>&gt;    &lt;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&gt;<br>&gt;    ):<br>&gt;    - Type&lt;(Any) -&gt; Void&gt; is a subtype of Subtype&lt;(Int) -&gt; Void&gt; etc.<br>&gt;       - Type&lt;(Void) -&gt; Int&gt; is a subtype of Subtype&lt;(Void) -&gt; Any&gt;<br>&gt;<br>&gt; In this new notation, some of our existing standard library functions<br>&gt; would have signatures like:<br>&gt;<br>&gt; func unsafeBitCast&lt;T, U&gt;(_: T, to type: Type&lt;U&gt;) -&gt; U<br>&gt; func ==(t0: Subtype&lt;Any&gt;?, t1: Subtype&lt;Any&gt;?) -&gt; Bool<br>&gt; func type&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt; // SE-0096<br>&gt;<br>&gt; That last example, type(of:), is rather interesting, because it is<br>&gt; actually a magic syntax rather than a function. We propose to align this<br>&gt; syntax with Type and Subtype by renaming it to Subtype(of:). We believe<br>&gt; this is clearer about both the type and meaning of the operation.<br>&gt;<br>&gt; let anInstance: NSObject = NSString()<br>&gt; let aClass: Subtype&lt;NSObject&gt; = Subtype(of: anInstance)<br>&gt;<br>&gt; print(aClass) // =&gt; NSString<br>&gt;<br>&gt; More details:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Every static or class member of T which can be called on all subtypes<br>&gt;    is an instance member of Subtype&lt;T&gt;. That includes:<br>&gt;    -<br>&gt;<br>&gt;    Static/class properties and methods<br>&gt;    -<br>&gt;<br>&gt;    Required initializers (as methods named init)<br>&gt;    -<br>&gt;<br>&gt;    Unbound instance methods<br>&gt;    -<br>&gt;<br>&gt;    The Type&lt;T&gt; of a concrete type T has all of the members required by<br>&gt;    Subtype&lt;T&gt;, plus non-required initializers.<br>&gt;    -<br>&gt;<br>&gt;    The Type&lt;T&gt; of a protocol T includes only unbound instance methods of T<br>&gt;    .<br>&gt;    -<br>&gt;<br>&gt;    If T conforms to P, then Subtype&lt;T&gt; is a subtype of Subtype&lt;P&gt;, even<br>&gt;    if T is a protocol.<br>&gt;    -<br>&gt;<br>&gt;    The type of Subtype&lt;T&gt;.self is Type&lt;Subtype&lt;T&gt;&gt;.<br>&gt;    -<br>&gt;<br>&gt;    The type of Type&lt;T&gt;.self is Type&lt;Type&lt;T&gt;&gt;, which is not a subtype of<br>&gt;    any type except Subtype&lt;Type&lt;T&gt;&gt;. There is an infinite regress of<br>&gt;    Type&lt;...&lt;Type&lt;T&gt;&gt;&gt;s.<br>&gt;    -<br>&gt;<br>&gt;    Subtypes are abstract types similar to class-bound protocols; they,<br>&gt;    too, support identity operations.<br>&gt;    -<br>&gt;<br>&gt;    Types are concrete reference types which have identities just like<br>&gt;    objects do.<br>&gt;<br>&gt; swift Int.self === Int.self // true Int.self === Any.self // false<br>&gt;<br>&gt; *Visual metatype relationship example (not a valid Swift code)*<br>&gt;<br>&gt; protocol Foo {<br>&gt;   static func foo()<br>&gt;   func instanceMethodFoo()<br>&gt; }<br>&gt;<br>&gt; protocol Boo : Foo {<br>&gt;   static func foo()<br>&gt;   static func boo()<br>&gt;   func instanceMethodFoo()<br>&gt;   func instanceMethodBoo()<br>&gt; }<br>&gt;<br>&gt; class A : Foo {<br>&gt;   static func foo() { ... }<br>&gt;   func instanceMethodFoo() { ... }<br>&gt; }<br>&gt;<br>&gt; class B : A, Boo {<br>&gt;   static func boo() { ... }<br>&gt;   func instanceMethodBoo() { ... }<br>&gt; }<br>&gt;<br>&gt; /// Swift generates metatypes along the lines of:<br>&gt; ///<br>&gt; /// Syntax: `meta protocol Subtype&lt;T&gt;` - only metatypes can conform to these meta protocols<br>&gt; /// Syntax: `final meta class Type&lt;T&gt;` - metatype<br>&gt; /// Note: `CapturedType` represents `Self` of `T` in `Subtype&lt;T&gt;`<br>&gt;<br>&gt; // For Any:<br>&gt; meta protocol Subtype&lt;Any&gt; : meta class {<br>&gt;   var `self`: Self { get }<br>&gt; }<br>&gt;<br>&gt; final meta class Type&lt;Any&gt; : Subtype&lt;Any&gt; {<br>&gt;   var `self`: Type&lt;Any&gt; { ... }<br>&gt; }<br>&gt;<br>&gt; // For Foo:<br>&gt; meta protocol Subtype&lt;Foo&gt; : Subtype&lt;Any&gt; {<br>&gt;   var `self`: Self { get }<br>&gt;   func foo()<br>&gt;   func instanceMethodFoo(_ `self`: CapturedType) -&gt; (Void) -&gt; Void<br>&gt; }<br>&gt;<br>&gt; final meta class Type&lt;Foo&gt; : Subtype&lt;Any&gt; {<br>&gt;   var `self`: Type&lt;Foo&gt; { ... }<br>&gt;   func instanceMethodFoo(_ `self`: Foo) -&gt; (Void) -&gt; Void { ... }<br>&gt; }<br>&gt;<br>&gt; // For Boo:<br>&gt; meta protocol Subtype&lt;Boo&gt; : Subtype&lt;Foo&gt; {<br>&gt;   var `self`: Self { get }<br>&gt;   func boo()<br>&gt;   func instanceMethodBoo(_ `self`: CapturedType) -&gt; (Void) -&gt; Void<br>&gt; }<br>&gt;<br>&gt; final meta class Type&lt;Boo&gt; : Subtype&lt;Any&gt; {<br>&gt;   var `self`: Type&lt;Boo&gt; { ... }<br>&gt;   func instanceMethodFoo(_ `self`: Boo) -&gt; (Void) -&gt; Void { ... }<br>&gt;   func instanceMethodBoo(_ `self`: Boo) -&gt; (Void) -&gt; Void { ... }<br>&gt; }<br>&gt;<br>&gt; // For A:<br>&gt; meta protocol Subtype&lt;A&gt; : Subtype&lt;Foo&gt; {<br>&gt;   var `self`: Self { get }<br>&gt;   func foo()<br>&gt;   func instanceMethodFoo(_ `self`: CapturedType) -&gt; (Void) -&gt; Void<br>&gt; }<br>&gt;<br>&gt; final meta class Type&lt;A&gt; : Subtype&lt;A&gt; {<br>&gt;   var `self`: Type&lt;A&gt; { ... }<br>&gt;   func foo() { ... }<br>&gt;   func instanceMethodFoo(_ `self`: A) -&gt; (Void) -&gt; Void { ... }<br>&gt; }<br>&gt;<br>&gt; // For B:<br>&gt; meta protocol Subtype&lt;B&gt; : Subtype&lt;A&gt;, Subtype&lt;Boo&gt; {<br>&gt;   var `self`: Self<br>&gt;   func foo()<br>&gt;   func boo()<br>&gt;   func instanceMethodFoo(_ `self`: CapturedType) -&gt; (Void) -&gt; Void<br>&gt;   func instanceMethodBoo(_ `self`: CapturedType) -&gt; (Void) -&gt; Void<br>&gt; }<br>&gt;<br>&gt; final meta class Type&lt;B&gt; : Subtype&lt;B&gt; {<br>&gt;   var `self`: Type&lt;B&gt; { ... }<br>&gt;   func foo() { ... }<br>&gt;   func boo() { ... }<br>&gt;   func instanceMethodFoo(_ `self`: B) -&gt; (Void) -&gt; Void { ... }<br>&gt;   func instanceMethodBoo(_ `self`: B) -&gt; (Void) -&gt; Void { ... }<br>&gt; }<br>&gt;<br>&gt; *Some examples*<br>&gt;<br>&gt; // Types:<br>&gt; protocol Foo {}<br>&gt; protocol Boo : Foo {}<br>&gt; class A : Foo {}<br>&gt; class B : A, Boo {}<br>&gt; struct S: Foo {}<br>&gt;<br>&gt; // Metatypes:<br>&gt; let a1: Type&lt;A&gt; = A.self           //=&gt; Okay<br>&gt; let p1: Type&lt;Foo&gt; = Foo.self       //=&gt; Okay<br>&gt; let p2: Type&lt;Boo&gt; = C.self         //=&gt; Error -- `C` is not the same as `Foo`<br>&gt;<br>&gt; let any_1: Subtype&lt;Any&gt; = A.self   //=&gt; Okay<br>&gt; let any_2: Subtype&lt;Any&gt; = Foo.self //=&gt; Okay<br>&gt;<br>&gt; let a_1: Subtype&lt;A&gt; = A.self       //=&gt; Okay<br>&gt; let p_1: Subtype&lt;Foo&gt; = A.self     //=&gt; Okay<br>&gt; let p_2: Subtype&lt;Foo&gt; = Foo.self   //=&gt; Error -- `Type&lt;Foo&gt;` is not a subtype of `Subtype&lt;Foo&gt;`<br>&gt;<br>&gt; // Generic functions:<br>&gt; func dynamic&lt;T&gt;(subtype: Subtype&lt;Any&gt;, `is` _: Type&lt;T&gt;) -&gt; Bool {<br>&gt;   return type is Subtype&lt;T&gt;<br>&gt; }<br>&gt;<br>&gt; func dynamic&lt;T&gt;(subtype: Subtype&lt;Any&gt;, `as` _: Type&lt;T&gt;) -&gt; Subtype&lt;T&gt;? {<br>&gt;   return type as? Subtype&lt;T&gt;<br>&gt; }<br>&gt;<br>&gt; let s1: Type&lt;S&gt; = S.self<br>&gt;<br>&gt; dynamic(subtype: s1, is: Foo.self)    //=&gt; true<br>&gt; dynamic(subtype: s1, as: Foo.self)    //=&gt; an `Optional&lt;Subtype&lt;Foo&gt;&gt;`<br>&gt;<br>&gt; Future Directions<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    We could allow extensions on Type and perhaps on Subtype to add<br>&gt;    members or conform them to protocols. This could allow us to remove some<br>&gt;    standard library hacks, like the non-Equatable-related == operators<br>&gt;    for types.<br>&gt;    -<br>&gt;<br>&gt;    It may be possible to implement parts of Type as a fairly ordinary<br>&gt;    final class, moving code from the runtime into the standard library.<br>&gt;    -<br>&gt;<br>&gt;    We could offer a Subtype(ofType: Type&lt;T&gt;, named: String)<br>&gt;    pseudo-initializer which would allow type-safe access to classes by name.<br>&gt;    -<br>&gt;<br>&gt;    We could offer other reflection and dynamic features on Type and<br>&gt;    Subtype.<br>&gt;    -<br>&gt;<br>&gt;    We could move the MemoryLayout members into Type (presumably<br>&gt;    prefixed), removing the rather artificial MemoryLayout enum.<br>&gt;    -<br>&gt;<br>&gt;    Along with other generics enhancements, there may be a use for a<br>&gt;    Subprotocol&lt;T&gt; syntax for any protocol requiring conformance to<br>&gt;    protocol T.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; This is a source-breaking change that can be automated by a migrator.<br>&gt;<br>&gt; We suggest the following migration process; this can differ from the final<br>&gt; migration process implemented by the core team if this proposal will be<br>&gt; accepted:<br>&gt;<br>&gt;    - Any.Type is migrated to Subtype&lt;Any&gt;.<br>&gt;    - If T.Type is in function parameter, where T is a generic type<br>&gt;    parameter, then it’s migrated to Type&lt;T&gt;.<br>&gt;    - Every T.Protocol will be replaced with Type&lt;T&gt;.<br>&gt;    - Every T.Type in a dynamic cast will be replaced with Subtype&lt;T&gt;.<br>&gt;    - If static members are called on a metatype instance, then this<br>&gt;    instance is migrated to Subtype&lt;T&gt;.<br>&gt;    - Return types of functions are migrated to Subtype&lt;T&gt;.<br>&gt;    - Variable declarations is migrated to Subtype&lt;T&gt;.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; Other names for Type and Subtype were considered:<br>&gt;<br>&gt;    - Type: SpecificType, Metatype or ExactType.<br>&gt;    - Subtype: Supertype, Base, BaseType, ExistentialType or TypeProtocol.<br>&gt;<br>&gt; Alternatively the pseudo initializer Subtype(of:) could remain as a<br>&gt; global function:<br>&gt;<br>&gt; public func subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/839f8c37/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>September 28, 2016 at 08:00:00pm</p></header><div class="content"><p>First off, I agree with Nevin (up-thread) that this is a much clearer version of the previous proposal, well done.<br></p><p>&gt; On Sep 28, 2016, at 6:18 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Formatted version: https://github.com/DevAndArtist/swift-evolution/blob/refactor_metatypes/proposals/0126-refactor-metatypes.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/refactor_metatypes/proposals/0126-refactor-metatypes.md&gt;<br>&gt; Refactor Metatypes<br>&gt; <br>&gt; Proposal: SE–0126 &lt;x-msg://5/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt; Authors: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;, Anton Zhilin &lt;https://github.com/Anton3&gt;, Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: Revision<br>&gt; Review manager: Chris Lattner &lt;http://github.com/lattner&gt;<br>&gt; Revision: 2<br>&gt; Previous Revisions: 1 &lt;https://github.com/apple/swift-evolution/blob/83707b0879c83dcde778f8163f5768212736fdc2/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt; Introduction<br>&gt; <br>&gt; This proposal removes .Type and .Protocol in favor of two generic-style syntaxes and aligns global type(of:) function (SE–0096) to match the changes.<br>&gt; <br>&gt; Swift-evolution thread (post Swift 3): <br>&gt; <br>&gt; [Pitch] Refactor Metatypes &lt;applewebdata://A0AAC176-7F99-483F-BC96-BDA55910F1A4&gt;<br>&gt; Older swift-evolution threads: [1] &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/025115.html&gt;, [2] &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/024772.html&gt;, [3] &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/023818.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; Every type T has an instance, accessible through T.self, which represents the type itself. Like all instances in Swift, this “type instance” itself has a type, which is referred to as its “metatype”. The metatype of T is written T.Type. The instance members of the metatype are the same as the static or class members of the type.<br>&gt; <br>&gt; Metatypes have subtype relationships which reflect the types they represent. For instance, given these types:<br>&gt; <br>&gt; protocol Proto {}<br>&gt; class Base {}<br>&gt; class Derived: Base, Proto {}<br>&gt; Derived.Type is a subtype of both Base.Type and Proto.Type (and Any.Type). That means that Derived.self can be used anywhere a Derived.Type, Base.Type, Proto.Type, or Any.Type is called for.<br>&gt; <br>&gt; Unfortunately, this simple picture is complicated by protocols. Proto.self is actually of type Proto.Protocol, not type Proto.Type. This is necessary because the protocol does not, and cannot, conform to itself; it requires conforming types to provide static members, but it doesn’t actually provide those members itself. Proto.Type still exists, but it is the supertype of all types conforming to the protocol.<br>&gt; <br>&gt; Making this worse, a generic type always uses T.Type to refer to the type of T.self. So when Proto is bound to a generic parameter P, P.Type is the same as Proto.Protocol.<br>&gt; <br>&gt; This shifting of types is complicated and confusing; we seek to clean up this area.<br>&gt; <br>&gt; We also believe that, in the long term, the dot syntax will prevent us from implementing certain future enhancements that might be valuable:<br>&gt; <br>&gt; Moving the implementation of metatypes at least partly into the standard library.<br>&gt; Adding members available on all type instances for features like read-write reflection or memory layout information.<br>&gt; Conforming metatypes to protocols like Hashable or CustomStringConvertible.<br>&gt; Offering straightforward syntaxes for dynamic features like looking up types by name.<br>&gt; Proposed solution<br>&gt; <br>&gt; We abolish .Type and .Protocol in favor of two generic-style syntaxes:<br>&gt; <br>&gt; Type&lt;T&gt; is the concrete type of T.self. A Type&lt;T&gt; only ever has one instance, T.self; even if T has a subtype U, Type&lt;U&gt; is not a subtype of Type&lt;T&gt;.<br>&gt; <br>&gt; Subtype&lt;T&gt; is the supertype of all Types whose instances are subtypes of T, including T itself:<br>&gt; <br>&gt; If T is a struct or enum, then Type&lt;T&gt; is the only subtype of Subtype&lt;T&gt;.<br>&gt; <br>&gt; If T is a class, then Type&lt;T&gt; and the Types of all subclasses of T are subtypes of Subtype&lt;T&gt;.<br>&gt; <br>&gt; If T is a protocol, then the Types of all concrete types conforming to T are subtypes of Subtype&lt;T&gt;. Type&lt;T&gt; is not itself a subtype of Subtype&lt;T&gt;, or of any Subtype other than Subtype&lt;Any&gt;.<br>&gt; <br>I’m having trouble reconciling this with rule #2 above, which states that “Subtype is the supertype of all Types whose instances are subtypes of T, including T itself.” Which one is wrong, or am I confused?<br></p><p>One thing I haven’t understood the motivation for exactly is what someone would be able to do with a Proto.self. Dynamic conformance checking? For a concrete T, having its .self seems useful for doing dynamic casts and such, but I don’t understand why for a Proto you need to have both. You did a good job of explaining why T.Protocol and T.Type are different, but not why both of them need to exist. So you could definitely do more to spell out the use-cases here.<br>&gt; Structural types follow the subtype/supertype relationships of their constituent types. For instance:<br>&gt; <br>&gt; Type&lt;(NSString, NSString)&gt; is a subtype of Subtype&lt;(NSObject, NSObject)&gt;<br>&gt; <br>&gt; Metatypes of functions are a little bit more special (the subtyping relation on functions flips around for parameter types &lt;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&gt;):<br>&gt; <br>&gt; Type&lt;(Any) -&gt; Void&gt; is a subtype of Subtype&lt;(Int) -&gt; Void&gt; etc.<br>&gt; Type&lt;(Void) -&gt; Int&gt; is a subtype of Subtype&lt;(Void) -&gt; Any&gt;<br></p><p>Does this potentially expose contravariant type parameters, and is that an issue? (I’m trying to imagine a scenario where you could have an A on the left hand side of an arrow and have that leak out to other clients, but I haven’t had a chance to write much Swift 3 yet, unfortunately.)<br>&gt; In this new notation, some of our existing standard library functions would have signatures like:<br>&gt; <br>&gt; func unsafeBitCast&lt;T, U&gt;(_: T, to type: Type&lt;U&gt;) -&gt; U<br>&gt; func ==(t0: Subtype&lt;Any&gt;?, t1: Subtype&lt;Any&gt;?) -&gt; Bool<br>&gt; func type&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt; // SE-0096<br>&gt; That last example, type(of:), is rather interesting, because it is actually a magic syntax rather than a function. We propose to align this syntax with Type and Subtype by renaming it to Subtype(of:). We believe this is clearer about both the type and meaning of the operation.<br>&gt; <br>&gt; let anInstance: NSObject = NSString()<br>&gt; let aClass: Subtype&lt;NSObject&gt; = Subtype(of: anInstance)<br>&gt; <br>&gt; print(aClass) // =&gt; NSString<br>&gt; More details:<br>&gt; <br>&gt; Every static or class member of T which can be called on all subtypes is an instance member of Subtype&lt;T&gt;. That includes:<br>&gt; <br>&gt; Static/class properties and methods<br>&gt; <br>&gt; Required initializers (as methods named init)<br>&gt; <br>&gt; Unbound instance methods<br>&gt; <br>&gt; The Type&lt;T&gt; of a concrete type T has all of the members required by Subtype&lt;T&gt;, plus non-required initializers.<br>&gt; <br>&gt; The Type&lt;T&gt; of a protocol T includes only unbound instance methods of T.<br>&gt; <br>&gt; If T conforms to P, then Subtype&lt;T&gt; is a subtype of Subtype&lt;P&gt;, even if T is a protocol.<br>&gt; <br>&gt; The type of Subtype&lt;T&gt;.self is Type&lt;Subtype&lt;T&gt;&gt;.<br>&gt; <br>&gt; The type of Type&lt;T&gt;.self is Type&lt;Type&lt;T&gt;&gt;, which is not a subtype of any type except Subtype&lt;Type&lt;T&gt;&gt;. There is an infinite regress of Type&lt;...&lt;Type&lt;T&gt;&gt;&gt;s.<br>&gt; <br>&gt; Subtypes are abstract types similar to class-bound protocols; they, too, support identity operations. <br>&gt; <br>&gt; Types are concrete reference types which have identities just like objects do.<br>&gt; <br>&gt; swift Int.self === Int.self // true Int.self === Any.self // false<br>&gt; <br>&gt; <br>&gt; Visual metatype relationship example (not a valid Swift code)<br>&gt; <br>&gt; <br>&gt; Some examples<br>&gt; <br>&gt; // Types:<br>&gt; protocol Foo {}<br>&gt; protocol Boo : Foo {}<br>&gt; class A : Foo {}<br>&gt; class B : A, Boo {}<br>&gt; struct S: Foo {}<br>&gt; <br>&gt; // Metatypes:<br>&gt; let a1: Type&lt;A&gt; = A.self           //=&gt; Okay<br>&gt; let p1: Type&lt;Foo&gt; = Foo.self       //=&gt; Okay<br>&gt; let p2: Type&lt;Boo&gt; = C.self         //=&gt; Error -- `C` is not the same as `Foo`<br>&gt; <br>&gt; let any_1: Subtype&lt;Any&gt; = A.self   //=&gt; Okay<br>&gt; let any_2: Subtype&lt;Any&gt; = Foo.self //=&gt; Okay<br>&gt; <br>&gt; let a_1: Subtype&lt;A&gt; = A.self       //=&gt; Okay<br>&gt; let p_1: Subtype&lt;Foo&gt; = A.self     //=&gt; Okay<br>&gt; let p_2: Subtype&lt;Foo&gt; = Foo.self   //=&gt; Error -- `Type&lt;Foo&gt;` is not a subtype of `Subtype&lt;Foo&gt;`<br>&gt; <br>&gt; // Generic functions:<br>&gt; func dynamic&lt;T&gt;(subtype: Subtype&lt;Any&gt;, `is` _: Type&lt;T&gt;) -&gt; Bool {<br>&gt;   return type is Subtype&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; func dynamic&lt;T&gt;(subtype: Subtype&lt;Any&gt;, `as` _: Type&lt;T&gt;) -&gt; Subtype&lt;T&gt;? {<br>&gt;   return type as? Subtype&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; let s1: Type&lt;S&gt; = S.self<br>&gt; <br>&gt; dynamic(subtype: s1, is: Foo.self)    //=&gt; true<br>&gt; dynamic(subtype: s1, as: Foo.self)    //=&gt; an `Optional&lt;Subtype&lt;Foo&gt;&gt;`<br>&gt; <br>&gt; <br>&gt; Future Directions<br>&gt; <br>&gt; We could allow extensions on Type and perhaps on Subtype to add members or conform them to protocols. This could allow us to remove some standard library hacks, like the non-Equatable-related == operators for types.<br>&gt; <br>&gt; It may be possible to implement parts of Type as a fairly ordinary final class, moving code from the runtime into the standard library.<br>&gt; <br>&gt; We could offer a Subtype(ofType: Type&lt;T&gt;, named: String) pseudo-initializer which would allow type-safe access to classes by name.<br>&gt; <br>&gt; We could offer other reflection and dynamic features on Type and Subtype.<br>&gt; <br>&gt; We could move the MemoryLayout members into Type (presumably prefixed), removing the rather artificial MemoryLayout enum.<br>&gt; <br>&gt; Along with other generics enhancements, there may be a use for a Subprotocol&lt;T&gt; syntax for any protocol requiring conformance to protocol T.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a source-breaking change that can be automated by a migrator. <br>&gt; <br>&gt; We suggest the following migration process; this can differ from the final migration process implemented by the core team if this proposal will be accepted:<br>&gt; <br>&gt; Any.Type is migrated to Subtype&lt;Any&gt;.<br>&gt; If T.Type is in function parameter, where T is a generic type parameter, then it’s migrated to Type&lt;T&gt;.<br>&gt; Every T.Protocol will be replaced with Type&lt;T&gt;.<br>&gt; Every T.Type in a dynamic cast will be replaced with Subtype&lt;T&gt;.<br>&gt; If static members are called on a metatype instance, then this instance is migrated to Subtype&lt;T&gt;.<br>&gt; Return types of functions are migrated to Subtype&lt;T&gt;.<br>&gt; Variable declarations is migrated to Subtype&lt;T&gt;.<br>&gt; Alternatives considered<br>&gt; <br>&gt; Other names for Type and Subtype were considered:<br>&gt; <br>&gt; Type: SpecificType, Metatype or ExactType.<br>&gt; Subtype: Supertype, Base, BaseType, ExistentialType or TypeProtocol.<br>&gt; Alternatively the pseudo initializer Subtype(of:) could remain as a global function:<br>&gt; <br>&gt; public func subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br></p><p>Thank you for the hard work you’ve put into this proposal, it’s come a long way!<br></p><p>-Colin<br></p><p>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/1fb629b0/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>September 29, 2016 at 12:00:00pm</p></header><div class="content"><p>2016-09-29 3:31 GMT+03:00 Colin Barrett via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p><br>&gt;    -<br>&gt;<br>&gt;    Type&lt;T&gt; is the concrete type of T.self. A Type&lt;T&gt; only ever has one<br>&gt;    instance, T.self; even if T has a subtype U, Type&lt;U&gt; is not a subtype<br>&gt;    of Type&lt;T&gt;.<br>&gt;    -<br>&gt;<br>&gt;    Subtype&lt;T&gt; is the supertype of all Types whose instances are subtypes<br>&gt;    of T, including T itself:<br>&gt;    -<br>&gt;<br>&gt;    If T is a struct or enum, then Type&lt;T&gt; is the only subtype of<br>&gt;    Subtype&lt;T&gt;.<br>&gt;    -<br>&gt;<br>&gt;    If T is a class, then Type&lt;T&gt; and the Types of all subclasses of T are<br>&gt;    subtypes of Subtype&lt;T&gt;.<br>&gt;    -<br>&gt;<br>&gt;    If T is a protocol, then the Types of all concrete types conforming to<br>&gt;    T are subtypes of Subtype&lt;T&gt;. Type&lt;T&gt; is not itself a subtype of<br>&gt;    Subtype&lt;T&gt;, or of any Subtype other than Subtype&lt;Any&gt;.<br>&gt;<br>&gt; I’m having trouble reconciling this with rule #2 above, which states that<br>&gt; “Subtype is the supertype of all Types whose instances are subtypes of T,<br>&gt; including T itself.” Which one is wrong, or am I confused?<br>&gt;<br>#2 applies to types, and #5 applies to protocols. If T is a type, then<br>Type&lt;T&gt; is always a subtype of Subtype&lt;T&gt;. If T is a protocol, then Type&lt;T&gt;<br>is never a subtype of Subtype&lt;T&gt;.<br></p><p>One thing I haven’t understood the motivation for exactly is what someone<br>&gt; would be able to do with a Proto.self. Dynamic conformance checking? For a<br>&gt; concrete T, having its .self seems useful for doing dynamic casts and such,<br>&gt; but I don’t understand why for a Proto you need to have both. You did a<br>&gt; good job of explaining why T.Protocol and T.Type are different, but not why<br>&gt; both of them need to exist. So you could definitely do more to spell out<br>&gt; the use-cases here.<br>&gt;<br>I honestly can’t imagine a use case for .Protocol currently. Maybe<br>enumerating protocols that exist in the program, just for the sake of it.<br></p><p><br>&gt;    -<br>&gt;<br>&gt;    Metatypes of functions are a little bit more special (the subtyping<br>&gt;    relation on functions flips around for parameter types<br>&gt;    &lt;https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)&gt;<br>&gt;    ):<br>&gt;    -<br>&gt;       - Type&lt;(Any) -&gt; Void&gt; is a subtype of Subtype&lt;(Int) -&gt; Void&gt; etc.<br>&gt;       - Type&lt;(Void) -&gt; Int&gt; is a subtype of Subtype&lt;(Void) -&gt; Any&gt;<br>&gt;<br>&gt;<br>&gt; Does this potentially expose contravariant type parameters, and is that an<br>&gt; issue? (I’m trying to imagine a scenario where you could have an A on the<br>&gt; left hand side of an arrow and have that leak out to other clients, but I<br>&gt; haven’t had a chance to write much Swift 3 yet, unfortunately.)<br>&gt;<br>Could you give a code example, where that would be an issue?<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/62d6d9ca/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>September 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 3:18 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; func unsafeBitCast&lt;T, U&gt;(_: T, to type: Type&lt;U&gt;) -&gt; U<br>&gt; func ==(t0: Subtype&lt;Any&gt;?, t1: Subtype&lt;Any&gt;?) -&gt; Bool<br>&gt; func type&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt; // SE-0096<br>&gt; That last example, type(of:), is rather interesting, because it is actually a magic syntax rather than a function. We propose to align this syntax with Type and Subtype by renaming it to Subtype(of:). We believe this is clearer about both the type and meaning of the operation.<br>&gt; <br>Why would we not have type(of:) and subtype(of:)? Why would I want the Subtype&lt;T&gt; instead of the specific Type&lt;T&gt;?<br></p><p>What is the rationale for losing the meta type relationships by having Type&lt;U&gt; not be a subtype of Type&lt;T&gt;?<br></p><p><br>&gt; let anInstance: NSObject = NSString()<br>&gt; let aClass: Subtype&lt;NSObject&gt; = Subtype(of: anInstance)<br>&gt; <br>&gt; print(aClass) // =&gt; NSString<br>&gt; More details:<br>&gt; <br>&gt; Every static or class member of T which can be called on all subtypes is an instance member of Subtype&lt;T&gt;. That includes:<br>&gt; <br>&gt; Static/class properties and methods<br>&gt; <br>&gt; Required initializers (as methods named init)<br>&gt; <br>&gt; Unbound instance methods<br>&gt; <br>&gt; The Type&lt;T&gt; of a concrete type T has all of the members required by Subtype&lt;T&gt;, plus non-required initializers.<br>&gt; <br>&gt; The Type&lt;T&gt; of a protocol T includes only unbound instance methods of T.<br>&gt; <br>&gt; If T conforms to P, then Subtype&lt;T&gt; is a subtype of Subtype&lt;P&gt;, even if T is a protocol.<br>&gt; <br>&gt; The type of Subtype&lt;T&gt;.self is Type&lt;Subtype&lt;T&gt;&gt;.<br>&gt; <br>&gt; The type of Type&lt;T&gt;.self is Type&lt;Type&lt;T&gt;&gt;, which is not a subtype of any type except Subtype&lt;Type&lt;T&gt;&gt;. There is an infinite regress of Type&lt;...&lt;Type&lt;T&gt;&gt;&gt;s.<br>&gt; <br>&gt; Subtypes are abstract types similar to class-bound protocols; they, too, support identity operations. <br>&gt; <br>&gt; Types are concrete reference types which have identities just like objects do.<br>&gt; <br>&gt; swift Int.self === Int.self // true Int.self === Any.self // false<br>&gt; <br>&gt; <br>&gt; Some examples<br>&gt; <br>I don’t see C defined in the example.<br></p><p><br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a source-breaking change that can be automated by a migrator. <br>&gt; <br>&gt; We suggest the following migration process; this can differ from the final migration process implemented by the core team if this proposal will be accepted:<br>&gt; <br>To the extent possible I suggest that Swift 4+ stick to deprecations unless it presents a significant effort. I think a lot of people are a bit exhausted with huge syntax changes and the impression was that most source-breaking changes were being done in Swift 3 so we could do them once.<br></p><p><br>&gt; Alternatives considered<br>&gt; <br>&gt; Other names for Type and Subtype were considered:<br>&gt; <br>&gt; Type: SpecificType, Metatype or ExactType.<br>&gt; Subtype: Supertype, Base, BaseType, ExistentialType or TypeProtocol.<br>&gt; Alternatively the pseudo initializer Subtype(of:) could remain as a global function:<br>&gt; <br>&gt; public func subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br></p><p>I think there is some potential for confusion with Subtype&lt;T&gt;, but I don’t want to bike shed it too much :)<br></p><p><br>Overall looks really nice!<br></p><p>Russ<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/27d41bbc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>September 29, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 3:24 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why would we not have type(of:) and subtype(of:)? Why would I want the Subtype&lt;T&gt; instead of the specific Type&lt;T&gt;?<br></p><p>Let&#39;s turn this around. Suppose you write:<br></p><p>	let obj: NSObject = …<br>	let ty = type(of: obj)<br></p><p>What is `ty`? Well, it&#39;s a `Type&lt;NSObject&gt;`, and there&#39;s only one of those: `NSObject.self`. So there&#39;s only one possible instance that could be assigned to that variable.<br></p><p>This is true in general: If `type(of:)` returns `Type&lt;T&gt;`, then it can only have one possible return value. In other words, the return value of `type(of:)` would always be the *static* type of the variable, not its dynamic type. There may be some narrow cases where that&#39;d be useful, but 99% of the time, you want `subtype(of:)` because you&#39;re trying to discover which of many dynamic subtypes of the static type you&#39;re actually dealing with. So most uses of `type(of:)` would probably be mistaken attempts to perform `subtype(of:)` instead.<br></p><p>&gt; What is the rationale for losing the meta type relationships by having Type&lt;U&gt; not be a subtype of Type&lt;T&gt;?<br></p><p>The relationships aren&#39;t lost; they&#39;re just expressed through `Subtype`, not `Type`.<br></p><p>Again, turn this around. `Subtype` is the normal thing that you&#39;ll want to use most of the time. `Type` is the weird thing whose existence is hard to explain. (One version of this proposal used `Type` for `Subtype` and `ExactType` for `Type` in order to imply that subtype is usually what you want, but some of the contributors weren&#39;t happy with that.)<br></p><p>So, `Type` is the weird thing. Why does it exist? Two reasons:<br></p><p>1. `Subtype&lt;T&gt;` only includes *inheritable* type members of `T`. `Type&lt;T&gt;` also includes *non-inheritable* members, particularly non-required initializers.<br></p><p>2. It allows precise type matches: `subty is Subtype&lt;NSObject&gt;` would match for any subtype of `NSObject`, whereas `subty is Type&lt;NSObject&gt;` would only match for `NSObject` itself.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>September 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;From Brent’s explanation, it sounds to me like “Type” and “StaticType”<br>respectively would be more descriptive than “Subtype” and “Type” as<br>proposed.<br></p><p>Nevin<br></p><p><br>On Thu, Sep 29, 2016 at 10:29 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Sep 29, 2016, at 3:24 PM, Russ Bishop via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Why would we not have type(of:) and subtype(of:)? Why would I want the<br>&gt; Subtype&lt;T&gt; instead of the specific Type&lt;T&gt;?<br>&gt;<br>&gt; Let&#39;s turn this around. Suppose you write:<br>&gt;<br>&gt;         let obj: NSObject = …<br>&gt;         let ty = type(of: obj)<br>&gt;<br>&gt; What is `ty`? Well, it&#39;s a `Type&lt;NSObject&gt;`, and there&#39;s only one of<br>&gt; those: `NSObject.self`. So there&#39;s only one possible instance that could be<br>&gt; assigned to that variable.<br>&gt;<br>&gt; This is true in general: If `type(of:)` returns `Type&lt;T&gt;`, then it can<br>&gt; only have one possible return value. In other words, the return value of<br>&gt; `type(of:)` would always be the *static* type of the variable, not its<br>&gt; dynamic type. There may be some narrow cases where that&#39;d be useful, but<br>&gt; 99% of the time, you want `subtype(of:)` because you&#39;re trying to discover<br>&gt; which of many dynamic subtypes of the static type you&#39;re actually dealing<br>&gt; with. So most uses of `type(of:)` would probably be mistaken attempts to<br>&gt; perform `subtype(of:)` instead.<br>&gt;<br>&gt; &gt; What is the rationale for losing the meta type relationships by having<br>&gt; Type&lt;U&gt; not be a subtype of Type&lt;T&gt;?<br>&gt;<br>&gt; The relationships aren&#39;t lost; they&#39;re just expressed through `Subtype`,<br>&gt; not `Type`.<br>&gt;<br>&gt; Again, turn this around. `Subtype` is the normal thing that you&#39;ll want to<br>&gt; use most of the time. `Type` is the weird thing whose existence is hard to<br>&gt; explain. (One version of this proposal used `Type` for `Subtype` and<br>&gt; `ExactType` for `Type` in order to imply that subtype is usually what you<br>&gt; want, but some of the contributors weren&#39;t happy with that.)<br>&gt;<br>&gt; So, `Type` is the weird thing. Why does it exist? Two reasons:<br>&gt;<br>&gt; 1. `Subtype&lt;T&gt;` only includes *inheritable* type members of `T`. `Type&lt;T&gt;`<br>&gt; also includes *non-inheritable* members, particularly non-required<br>&gt; initializers.<br>&gt;<br>&gt; 2. It allows precise type matches: `subty is Subtype&lt;NSObject&gt;` would<br>&gt; match for any subtype of `NSObject`, whereas `subty is Type&lt;NSObject&gt;`<br>&gt; would only match for `NSObject` itself.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/3208f287/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 30, 2016 at 03:00:00am</p></header><div class="content"><p>I&#39;m confused by this explanation.Today, `type(of:)` is the new<br>`.dynamicType`. Is this proposal suggesting a silent change so that it now<br>returns the static type? If so, why (particularly when you explain that<br>this is often *not* what you would want)?<br></p><p>I&#39;m also somewhat puzzled about the proposed design. This proposal explains<br>that Subtype&lt;T&gt; should be a supertype of Type&lt;T&gt; and its subtypes. Why is a<br>supertype named Subtype?<br>On Thu, Sep 29, 2016 at 9:44 PM Nevin Brackett-Rozinsky via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; From Brent’s explanation, it sounds to me like “Type” and “StaticType”<br>&gt; respectively would be more descriptive than “Subtype” and “Type” as<br>&gt; proposed.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Thu, Sep 29, 2016 at 10:29 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; On Sep 29, 2016, at 3:24 PM, Russ Bishop via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Why would we not have type(of:) and subtype(of:)? Why would I want the<br>&gt;&gt; Subtype&lt;T&gt; instead of the specific Type&lt;T&gt;?<br>&gt;&gt;<br>&gt;&gt; Let&#39;s turn this around. Suppose you write:<br>&gt;&gt;<br>&gt;&gt;         let obj: NSObject = …<br>&gt;&gt;         let ty = type(of: obj)<br>&gt;&gt;<br>&gt;&gt; What is `ty`? Well, it&#39;s a `Type&lt;NSObject&gt;`, and there&#39;s only one of<br>&gt;&gt; those: `NSObject.self`. So there&#39;s only one possible instance that could be<br>&gt;&gt; assigned to that variable.<br>&gt;&gt;<br>&gt;&gt; This is true in general: If `type(of:)` returns `Type&lt;T&gt;`, then it can<br>&gt;&gt; only have one possible return value. In other words, the return value of<br>&gt;&gt; `type(of:)` would always be the *static* type of the variable, not its<br>&gt;&gt; dynamic type. There may be some narrow cases where that&#39;d be useful, but<br>&gt;&gt; 99% of the time, you want `subtype(of:)` because you&#39;re trying to discover<br>&gt;&gt; which of many dynamic subtypes of the static type you&#39;re actually dealing<br>&gt;&gt; with. So most uses of `type(of:)` would probably be mistaken attempts to<br>&gt;&gt; perform `subtype(of:)` instead.<br>&gt;&gt;<br>&gt;&gt; &gt; What is the rationale for losing the meta type relationships by having<br>&gt;&gt; Type&lt;U&gt; not be a subtype of Type&lt;T&gt;?<br>&gt;&gt;<br>&gt;&gt; The relationships aren&#39;t lost; they&#39;re just expressed through `Subtype`,<br>&gt;&gt; not `Type`.<br>&gt;&gt;<br>&gt;&gt; Again, turn this around. `Subtype` is the normal thing that you&#39;ll want<br>&gt;&gt; to use most of the time. `Type` is the weird thing whose existence is hard<br>&gt;&gt; to explain. (One version of this proposal used `Type` for `Subtype` and<br>&gt;&gt; `ExactType` for `Type` in order to imply that subtype is usually what you<br>&gt;&gt; want, but some of the contributors weren&#39;t happy with that.)<br>&gt;&gt;<br>&gt;&gt; So, `Type` is the weird thing. Why does it exist? Two reasons:<br>&gt;&gt;<br>&gt;&gt; 1. `Subtype&lt;T&gt;` only includes *inheritable* type members of `T`.<br>&gt;&gt; `Type&lt;T&gt;` also includes *non-inheritable* members, particularly<br>&gt;&gt; non-required initializers.<br>&gt;&gt;<br>&gt;&gt; 2. It allows precise type matches: `subty is Subtype&lt;NSObject&gt;` would<br>&gt;&gt; match for any subtype of `NSObject`, whereas `subty is Type&lt;NSObject&gt;`<br>&gt;&gt; would only match for `NSObject` itself.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/58fe918d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>September 29, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 8:14 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m confused by this explanation.Today, `type(of:)` is the new `.dynamicType`. Is this proposal suggesting a silent change so that it now returns the static type? If so, why (particularly when you explain that this is often *not* what you would want)?<br></p><p>I&#39;m short-handing the names to talk about the return values. In other words, I assume that, if we have both `type(of:)` and `subtype(of:)`, their signatures would be:<br></p><p>	func type&lt;T&gt;(of: T) -&gt; Type&lt;T&gt;<br>	func subtype&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt;<br></p><p>And I&#39;m saying that, given these names, `type(of:)` is confusing and near-useless, whereas `subtype(of:)` is what you almost always want.<br></p><p>We *could*, of course, have a function called `type(of:)` which returned `Subtype&lt;T&gt;` and had the semantics I&#39;m referring to as `subtype(of:)`. A name is just a name.<br></p><p>&gt; I&#39;m also somewhat puzzled about the proposed design. This proposal explains that Subtype&lt;T&gt; should be a supertype of Type&lt;T&gt; and its subtypes. Why is a supertype named Subtype?<br></p><p>Because a type&#39;s name should describe the *instances*; that&#39;s why you don&#39;t put &quot;Class&quot; at the end of all of your class names. (It&#39;s also why we&#39;re proposing `Type&lt;T&gt;` instead of `Metatype&lt;T&gt;`.)<br></p><p>Every instance of `Subtype&lt;T&gt;` is the type instance for a subtype of `T`. For instance, in this hierarchy:<br></p><p>	NSObject<br>	NSResponder: NSObject<br>	NSView: NSResponder<br></p><p>`Type&lt;NSResponder&gt;` is a `Subtype&lt;NSObject&gt;`, but not a `Subtype&lt;NSView&gt;`.<br></p><p>Thus, this reads correctly:<br></p><p>	let aType: Subtype&lt;NSResponder&gt; = NSView.self<br></p><p>Whereas this does not:<br></p><p>	let aType: Supertype&lt;NSResponder&gt; = NSView.self<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 30, 2016 at 04:00:00am</p></header><div class="content"><p>Great explanation.<br></p><p>Can you elaborate on your two reasons for the proposed Type&lt;T&gt;?<br></p><p>In particular, what do you mean by inheritable and non-inheritable members<br>of T? Where do these come into play? How is the current T.Type deficient in<br>this respect?<br></p><p>Regarding (2), it is already possible to do precise type matches using `==`<br>instead of `is` (see corelibs-foundation for extensive uses). What does the<br>proposal offer that goes beyond what we currently have?<br></p><p><br>On Thu, Sep 29, 2016 at 22:57 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Sep 29, 2016, at 8:14 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;m confused by this explanation.Today, `type(of:)` is the new<br>&gt; `.dynamicType`. Is this proposal suggesting a silent change so that it now<br>&gt; returns the static type? If so, why (particularly when you explain that<br>&gt; this is often *not* what you would want)?<br>&gt;<br>&gt; I&#39;m short-handing the names to talk about the return values. In other<br>&gt; words, I assume that, if we have both `type(of:)` and `subtype(of:)`, their<br>&gt; signatures would be:<br>&gt;<br>&gt;         func type&lt;T&gt;(of: T) -&gt; Type&lt;T&gt;<br>&gt;         func subtype&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt;<br>&gt;<br>&gt; And I&#39;m saying that, given these names, `type(of:)` is confusing and<br>&gt; near-useless, whereas `subtype(of:)` is what you almost always want.<br>&gt;<br>&gt; We *could*, of course, have a function called `type(of:)` which returned<br>&gt; `Subtype&lt;T&gt;` and had the semantics I&#39;m referring to as `subtype(of:)`. A<br>&gt; name is just a name.<br>&gt;<br>&gt; &gt; I&#39;m also somewhat puzzled about the proposed design. This proposal<br>&gt; explains that Subtype&lt;T&gt; should be a supertype of Type&lt;T&gt; and its subtypes.<br>&gt; Why is a supertype named Subtype?<br>&gt;<br>&gt; Because a type&#39;s name should describe the *instances*; that&#39;s why you<br>&gt; don&#39;t put &quot;Class&quot; at the end of all of your class names. (It&#39;s also why<br>&gt; we&#39;re proposing `Type&lt;T&gt;` instead of `Metatype&lt;T&gt;`.)<br>&gt;<br>&gt; Every instance of `Subtype&lt;T&gt;` is the type instance for a subtype of `T`.<br>&gt; For instance, in this hierarchy:<br>&gt;<br>&gt;         NSObject<br>&gt;         NSResponder: NSObject<br>&gt;         NSView: NSResponder<br>&gt;<br>&gt; `Type&lt;NSResponder&gt;` is a `Subtype&lt;NSObject&gt;`, but not a `Subtype&lt;NSView&gt;`.<br>&gt;<br>&gt; Thus, this reads correctly:<br>&gt;<br>&gt;         let aType: Subtype&lt;NSResponder&gt; = NSView.self<br>&gt;<br>&gt; Whereas this does not:<br>&gt;<br>&gt;         let aType: Supertype&lt;NSResponder&gt; = NSView.self<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/edbf4d88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 30, 2016 at 12:00:00pm</p></header><div class="content"><p>I’ll join the conversation tomorrow. Thanks to Brent for his huge contribution. :)<br></p><p>Just a quick side note:<br></p><p>Moving from T.Type and T.Protocol to Type&lt;T&gt; and Subtype&lt;T&gt; would also allow us to finally reuse and correctly nest our custom Type and Protocol types.<br>struct A {<br>   struct Type {}<br>}<br></p><p>A.Type() // &lt;— Yeay<br>This proposal also aims to fix the problem with generics where any protocol metatype was converted to P.Protocol.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 30. September 2016 um 06:22:34, Xiaodi Wu via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>What does the proposal offer that goes beyond what we currently have?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/97767875/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>September 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 9:21 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Can you elaborate on your two reasons for the proposed Type&lt;T&gt;?<br>&gt; <br>&gt; In particular, what do you mean by inheritable and non-inheritable members of T? Where do these come into play? How is the current T.Type deficient in this respect?<br></p><p>Consider a snippet of code like this:<br></p><p>	class A { init(a: Int) { } }<br>	class B: A { init(b: Int) { super.init(a: b) } }<br></p><p>You can call `A.init(a:)` directly:<br></p><p>	A(a: 0)<br>	A.self.init(a: 0)<br></p><p>However, if you try to assign `A`&#39;s type instance to a variable and do it through there, you can&#39;t:<br></p><p>	let aType: A.Type = A.self<br>	aType.init(a: 0)		// Error: constructing an object of class type &#39;A&#39; with a metatype value must use a &#39;required&#39; initializer<br></p><p>This is a reflection of the fact that an `A.Type` could be `A.self` or `B.self` (or any other subclass of `A`), and `B.self` may not have an `init(a:)`.<br></p><p>`Type&lt;A&gt;` does not have this problem because it *is* guaranteed to be an `A`. It can express initializers and potentially anything else we might add that doesn&#39;t get inherited.<br></p><p>Of course, that isn&#39;t hugely useful right now because `Type&lt;T&gt;` only has one instance, and you can just refer to that instance directly. But I don&#39;t like that this distinction is unutterable; `Type&lt;T&gt;` corrects that.<br></p><p>And I think we may have features in the future where this is useful. For instance, if reflection ever gains the ability to access non-stored-property members, the distinction between `Subtype&lt;T&gt;` and `Type&lt;T&gt;` may become important. And if we ever get the ability to conform metatypes to protocols, I think non-inheritable conformances may be a good thing.<br></p><p>&gt; Regarding (2), it is already possible to do precise type matches using `==` instead of `is` (see corelibs-foundation for extensive uses). What does the proposal offer that goes beyond what we currently have?<br></p><p>`as?` compatibility, I suppose? Honestly, that&#39;s just something I noticed when I was writing it up. It might not be important.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 30, 2016 at 09:00:00pm</p></header><div class="content"><p>On Fri, Sep 30, 2016 at 5:56 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Sep 29, 2016, at 9:21 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Can you elaborate on your two reasons for the proposed Type&lt;T&gt;?<br>&gt; &gt;<br>&gt; &gt; In particular, what do you mean by inheritable and non-inheritable<br>&gt; members of T? Where do these come into play? How is the current T.Type<br>&gt; deficient in this respect?<br>&gt;<br>&gt; Consider a snippet of code like this:<br>&gt;<br>&gt;         class A { init(a: Int) { } }<br>&gt;         class B: A { init(b: Int) { super.init(a: b) } }<br>&gt;<br>&gt; You can call `A.init(a:)` directly:<br>&gt;<br>&gt;         A(a: 0)<br>&gt;         A.self.init(a: 0)<br>&gt;<br>&gt; However, if you try to assign `A`&#39;s type instance to a variable and do it<br>&gt; through there, you can&#39;t:<br>&gt;<br>&gt;         let aType: A.Type = A.self<br>&gt;         aType.init(a: 0)                // Error: constructing an object<br>&gt; of class type &#39;A&#39; with a metatype value must use a &#39;required&#39; initializer<br>&gt;<br>&gt; This is a reflection of the fact that an `A.Type` could be `A.self` or<br>&gt; `B.self` (or any other subclass of `A`), and `B.self` may not have an<br>&gt; `init(a:)`.<br>&gt;<br>&gt; `Type&lt;A&gt;` does not have this problem because it *is* guaranteed to be an<br>&gt; `A`. It can express initializers and potentially anything else we might add<br>&gt; that doesn&#39;t get inherited.<br>&gt;<br>&gt; Of course, that isn&#39;t hugely useful right now because `Type&lt;T&gt;` only has<br>&gt; one instance, and you can just refer to that instance directly. But I don&#39;t<br>&gt; like that this distinction is unutterable; `Type&lt;T&gt;` corrects that.<br>&gt;<br>&gt; And I think we may have features in the future where this is useful. For<br>&gt; instance, if reflection ever gains the ability to access<br>&gt; non-stored-property members, the distinction between `Subtype&lt;T&gt;` and<br>&gt; `Type&lt;T&gt;` may become important. And if we ever get the ability to conform<br>&gt; metatypes to protocols, I think non-inheritable conformances may be a good<br>&gt; thing.<br>&gt;<br>&gt; &gt; Regarding (2), it is already possible to do precise type matches using<br>&gt; `==` instead of `is` (see corelibs-foundation for extensive uses). What<br>&gt; does the proposal offer that goes beyond what we currently have?<br>&gt;<br>&gt; `as?` compatibility, I suppose? Honestly, that&#39;s just something I noticed<br>&gt; when I was writing it up. It might not be important.<br>&gt;<br></p><p>This is a very clear answer. So for my understanding, what you&#39;re saying<br>is: without other language features not yet proposed, `Type&lt;T&gt;` does not in<br>itself enable a particularly notable use case that&#39;s not currently possible<br>today. It is being included in this proposal because the original design of<br>Swift lumped two things together for simplicity, but you disagree with that<br>design decision and want the distinction to be utterable. Is that more or<br>less the gist of it?<br></p><p>--<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/96d554d4/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 30, 2016 at 08:00:00am</p></header><div class="content"><p>Hey Brent,<br></p><p>Sorry for being a bit dense about this, but...<br></p><p>&gt; <br>&gt;    NSObject<br>&gt;    NSResponder: NSObject<br>&gt;    NSView: NSResponder<br>&gt; <br>&gt; `Type&lt;NSResponder&gt;` is a `Subtype&lt;NSObject&gt;`, but not a `Subtype&lt;NSView&gt;`.<br>&gt; <br>&gt; Thus, this reads correctly:<br>&gt; <br>&gt;    let aType: Subtype&lt;NSResponder&gt; = NSView.self<br>&gt; <br>&gt; Whereas this does not:<br>&gt; <br>&gt;    let aType: Supertype&lt;NSResponder&gt; = NSView.self<br></p><p><br>Calling it SuperTypeOf&lt;T&gt; and SubTypeOf&lt;T&gt; would make it less confusing as that is how I read it in my mind in your last example.<br></p><p>Sent from my iPhone<br></p><p>On 30 Sep 2016, at 04:57, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Sep 29, 2016, at 8:14 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m confused by this explanation.Today, `type(of:)` is the new `.dynamicType`. Is this proposal suggesting a silent change so that it now returns the static type? If so, why (particularly when you explain that this is often *not* what you would want)?<br>&gt; <br>&gt; I&#39;m short-handing the names to talk about the return values. In other words, I assume that, if we have both `type(of:)` and `subtype(of:)`, their signatures would be:<br>&gt; <br>&gt;    func type&lt;T&gt;(of: T) -&gt; Type&lt;T&gt;<br>&gt;    func subtype&lt;T&gt;(of: T) -&gt; Subtype&lt;T&gt;<br>&gt; <br>&gt; And I&#39;m saying that, given these names, `type(of:)` is confusing and near-useless, whereas `subtype(of:)` is what you almost always want.<br>&gt; <br>&gt; We *could*, of course, have a function called `type(of:)` which returned `Subtype&lt;T&gt;` and had the semantics I&#39;m referring to as `subtype(of:)`. A name is just a name.<br>&gt; <br>&gt;&gt; I&#39;m also somewhat puzzled about the proposed design. This proposal explains that Subtype&lt;T&gt; should be a supertype of Type&lt;T&gt; and its subtypes. Why is a supertype named Subtype?<br>&gt; <br>&gt; Because a type&#39;s name should describe the *instances*; that&#39;s why you don&#39;t put &quot;Class&quot; at the end of all of your class names. (It&#39;s also why we&#39;re proposing `Type&lt;T&gt;` instead of `Metatype&lt;T&gt;`.)<br>&gt; <br>&gt; Every instance of `Subtype&lt;T&gt;` is the type instance for a subtype of `T`. For instance, in this hierarchy:<br>&gt; <br>&gt;    NSObject<br>&gt;    NSResponder: NSObject<br>&gt;    NSView: NSResponder<br>&gt; <br>&gt; `Type&lt;NSResponder&gt;` is a `Subtype&lt;NSObject&gt;`, but not a `Subtype&lt;NSView&gt;`.<br>&gt; <br>&gt; Thus, this reads correctly:<br>&gt; <br>&gt;    let aType: Subtype&lt;NSResponder&gt; = NSView.self<br>&gt; <br>&gt; Whereas this does not:<br>&gt; <br>&gt;    let aType: Supertype&lt;NSResponder&gt; = NSView.self<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/d672ff45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 30, 2016 at 09:00:00pm</p></header><div class="content"><p>About the proposed names:<br></p><p>To be crystal clear we could use more descriptive names for our two types. Today T.Type is referred as *metatype* and serving two different purposes at once.<br></p><p>It’s a concrete type; we call it Type&lt;T&gt; or other suggested names looked like ExactType&lt;T&gt;, StaticType&lt;T&gt; etc.<br></p><p>T.Type is also the base type for all subtypes of T.<br></p><p>Protocols has one exception here.<br></p><p>1.1. The concrete type for protocols is not T.Type but T.Protocol.<br></p><p>2.1. T.Protocol has only one supertype, which is the existential (#2) Any.Type type.<br></p><p>Our proposal slices this behaviour into two different types, where you only can create a *concrete type* Type&lt;T&gt; with T.self or shadow a concrete type behind Subtype&lt;U&gt; with subtype(of:) function.<br></p><p>To be precise the correct names should be:<br></p><p>Metatype&lt;T&gt; for the concrete type (#1).<br>ExistentialMetatype&lt;T&gt; for the existential type (#2).<br>But we felt that we should adopt the existing name from T.Type and use the short form for the *concrete type* Type&lt;T&gt;.<br></p><p>Brent already showed in multiple examples but the question seems to come up over and over about the correct name of the current type(of:) function.<br></p><p>Imagine this scenario:<br></p><p>protocol P {}<br>struct A : P {}<br></p><p>let proto: P = A()<br>let any: Any = proto<br></p><p>// the old behaviour looked like this<br></p><p>// *concrete* `A.Type` is hidden behind the existential `Any.Type`<br>let anyMetatype: Any.Type = any.dynamicType  <br></p><p>anyMetatype is P.Type //=&gt; true `P.Type` is the existential type here<br>anyMetatype is A.Type //=&gt; true<br>let aMetatype = anyMetatype as! A.Type // Okay<br></p><p>// today `type(of:)` does the same trick<br></p><p>// After this proposal:<br>// subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br></p><p>// The function will extract `Type&lt;A&gt;` for `any` but shadow it behind `Subtype&lt;Any&gt;`<br>let anyMetatype: `Subtype&lt;Any&gt;` = subtype(of: any)<br></p><p>// The correct relationship look like this:<br>// Subtype&lt;P&gt; : Subtype&lt;Any&gt;<br>// Subtype&lt;A&gt; : Subtype&lt;P&gt;<br>// Type&lt;A&gt; : Subtype&lt;A&gt;<br></p><p>anyMetatype is Subtype&lt;P&gt; //=&gt; true<br>anyMetatype is Subtype&lt;A&gt; //=&gt; true<br>anyMetatype is Type&lt;A&gt;    //=&gt; true<br>anyMetatype is Type&lt;P&gt;    //=&gt; false<br>anyMetatype is Type&lt;Any&gt;  //=&gt; false<br>let aMetatype_1 = anyMetatype as! Subtype&lt;A&gt; // Okay<br>let aMetatype_2 = anyMetatype as! Type&lt;A&gt;    // Okay<br>subtype(of:) function extracts the *concrete type* from the given instance but shadows it behind the *existential type* equal to the type of the given instance.<br></p><p>subtype(of: T) returns a existential metatype instance Subtype&lt;T&gt; where in reality it’s a concrete metatype Type&lt;U&gt; with the relationship like U : T.<br></p><p>This is exact the same behaviour as the old .dynamicType had.<br></p><p>I hope that cleared some raising questions.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 30. September 2016 um 09:00:53, Goffredo Marocchi via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Calling it SuperTypeOf&lt;T&gt; and SubTypeOf&lt;T&gt; would make it less confusing as that is how I read it in my mind in your last example.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/5b6c10cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 30, 2016 at 02:00:00pm</p></header><div class="content"><p>Sorry, my question at least has nothing to do with bikeshedding. I&#39;m<br>confused about why the proposal feels it&#39;s necessary to have both Type and<br>Subtype. I don&#39;t understand Brent&#39;s two reasons and was hoping for some<br>elaboration. I&#39;ve tried to clarify my question in a gist:<br></p><p>https://gist.github.com/xwu/0cc2c8d358f1fdf066ba739bcd151167<br></p><p><br>On Fri, Sep 30, 2016 at 2:09 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; About the proposed names:<br>&gt;<br>&gt; To be crystal clear we could use more descriptive names for our two types.<br>&gt; Today T.Type is referred as *metatype* and serving two different purposes<br>&gt; at once.<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    It’s a concrete type; we call it Type&lt;T&gt; or other suggested names<br>&gt;    looked like ExactType&lt;T&gt;, StaticType&lt;T&gt; etc.<br>&gt;    2.<br>&gt;<br>&gt;    T.Type is also the *base type* for all subtypes of T.<br>&gt;<br>&gt; Protocols has one exception here.<br>&gt;<br>&gt; 1.1. The concrete type for protocols is not T.Type but T.Protocol.<br>&gt;<br>&gt; 2.1. T.Protocol has only one supertype, which is the existential (#2)<br>&gt; Any.Type type.<br>&gt;<br>&gt; Our proposal slices this behaviour into two different types, where you<br>&gt; only can create a *concrete type* Type&lt;T&gt; with T.self or shadow a<br>&gt; concrete type behind Subtype&lt;U&gt; with subtype(of:) function.<br>&gt;<br>&gt; To be precise the correct names should be:<br>&gt;<br>&gt;    - Metatype&lt;T&gt; for the concrete type (#1).<br>&gt;    - ExistentialMetatype&lt;T&gt; for the existential type (#2).<br>&gt;<br>&gt; But we felt that we should adopt the existing name from T.Type and use<br>&gt; the short form for the *concrete type* Type&lt;T&gt;.<br>&gt; ------------------------------<br>&gt;<br>&gt; Brent already showed in multiple examples but the question seems to come<br>&gt; up over and over about the correct name of the current type(of:) function.<br>&gt;<br>&gt; Imagine this scenario:<br>&gt;<br>&gt; protocol P {}<br>&gt; struct A : P {}<br>&gt;<br>&gt; let proto: P = A()<br>&gt; let any: Any = proto<br>&gt;<br>&gt; // the old behaviour looked like this<br>&gt;<br>&gt; // *concrete* `A.Type` is hidden behind the existential `Any.Type`<br>&gt; let anyMetatype: Any.Type = any.dynamicType<br>&gt;<br>&gt; anyMetatype is P.Type //=&gt; true `P.Type` is the existential type here<br>&gt; anyMetatype is A.Type //=&gt; true<br>&gt; let aMetatype = anyMetatype as! A.Type // Okay<br>&gt;<br>&gt; // today `type(of:)` does the same trick<br>&gt;<br>&gt; // After this proposal:<br>&gt; // subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br>&gt;<br>&gt; // The function will extract `Type&lt;A&gt;` for `any` but shadow it behind `Subtype&lt;Any&gt;`<br>&gt; let anyMetatype: `Subtype&lt;Any&gt;` = subtype(of: any)<br>&gt;<br>&gt; // The correct relationship look like this:<br>&gt; // Subtype&lt;P&gt; : Subtype&lt;Any&gt;<br>&gt; // Subtype&lt;A&gt; : Subtype&lt;P&gt;<br>&gt; // Type&lt;A&gt; : Subtype&lt;A&gt;<br>&gt;<br>&gt; anyMetatype is Subtype&lt;P&gt; //=&gt; true<br>&gt; anyMetatype is Subtype&lt;A&gt; //=&gt; true<br>&gt; anyMetatype is Type&lt;A&gt;    //=&gt; true<br>&gt; anyMetatype is Type&lt;P&gt;    //=&gt; false<br>&gt; anyMetatype is Type&lt;Any&gt;  //=&gt; false<br>&gt; let aMetatype_1 = anyMetatype as! Subtype&lt;A&gt; // Okay<br>&gt; let aMetatype_2 = anyMetatype as! Type&lt;A&gt;    // Okay<br>&gt;<br>&gt; subtype(of:) function extracts the *concrete type* from the given<br>&gt; instance but shadows it behind the *existential type* equal to the type of<br>&gt; the given instance.<br>&gt;<br>&gt; subtype(of: T) returns a existential metatype instance Subtype&lt;T&gt; where<br>&gt; in reality it’s a concrete metatype Type&lt;U&gt; with the relationship like U<br>&gt; : T.<br>&gt;<br>&gt; This is exact the same behaviour as the old .dynamicType had.<br>&gt;<br>&gt; I hope that cleared some raising questions.<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 30. September 2016 um 09:00:53, Goffredo Marocchi via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; Calling it SuperTypeOf&lt;T&gt; and SubTypeOf&lt;T&gt; would make it less confusing as<br>&gt; that is how I read it in my mind in your last example.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/19426f2d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>October  1, 2016 at 12:00:00am</p></header><div class="content"><p>2016-09-30 22:48 GMT+03:00 Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>Sorry, my question at least has nothing to do with bikeshedding. I&#39;m<br>&gt; confused about why the proposal feels it&#39;s necessary to have both Type and<br>&gt; Subtype. I don&#39;t understand Brent&#39;s two reasons and was hoping for some<br>&gt; elaboration. I&#39;ve tried to clarify my question in a gist:<br>&gt;<br>&gt; https://gist.github.com/xwu/0cc2c8d358f1fdf066ba739bcd151167<br>&gt;<br>Regardless of syntax, there are Metatype&lt;T&gt; and ExistentialMetatype&lt;T&gt;<br>“under the hood”. I’ll take the liberty to use these names for this post.<br></p><p>Purpose and difference between the two kinds of metatypes is easy to<br>understand. If it helps, size of Metatype&lt;T&gt; is typically 0 while size of<br>ExistentialMetatype&lt;T&gt; is typically 8.<br></p><p>NOTE: Metatype&lt;P&gt; can’t be a subtype of ExistentialMetatype&lt;P&gt; for<br>protocols P, because protocols do not implement their own static<br>requirements.<br></p><p>Apparently, creators of Swift also thought that two kinds of metatypes are<br>too difficult for an average developer. So an attempt was made to unify<br>both under a single name, T.Type. For “final” types like structs, T.Type<br>maps onto Metatype&lt;T&gt;. For classes and protocols, T.Type maps onto<br>ExistentialMetatype&lt;T&gt;.<br></p><p>This abstraction turned out to be leaky. I’ll give 3 leaks.<br></p><p>   1. Because of Note, we could not have ID of a protocol itself inside of<br>   any kind of metatype. This feature was needed in real code. The solution<br>   was to add T.Protocol syntax that could only be used for protocols to<br>   create a Metatype&lt;T&gt;. But this solution created a plethora of other<br>   inconsistencies and abstraction leaks (which were explored by Adrian).<br>   Arguably the most important is (2).<br>   2. In generic functions accepting T.Type, passing T.self creates an<br>   instance of T.Protocol, which is still described in code as T.Type.<br>   *boom!*<br>   3. Accepting static metatypes in functions is often what people want.<br>   Consider the following basic example:<br></p><p>func create&lt;T: Creatable&gt;(type: T.Type)<br></p><p>Most probably, create does not read contents of type to deal with<br>appropriate subtype. It does not support existentiality, type is here for<br>function specialization. But in case T is subtypable, we still pass around<br>those 8 bytes that are not used by the create, confusing both compiler and<br>some developers. In 90% cases, when we see such a function, it throws off<br>value of metatype instance.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161001/388fabdb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 30, 2016 at 11:00:00pm</p></header><div class="content"><p>I replied on your gist directly, but you can also read my reply below.<br></p><p>I though I made it crystal clear in my last post what the main problem is.<br></p><p>Again:<br></p><p>T.Type serves two jobs at once.<br></p><p>It’s a concrete metatype of T.<br>It’s an existential metatype of T where other metatypes where U is a subtype of T (U : T) are subtypes of this existential metatype.<br>Forget about protocols for a moment:<br></p><p>struct S { }  <br></p><p>let metatype_1: Any.Type = S.self // &lt;~~ (concrete) metatype<br>// ~~~~~~~~~~~~ ^ existential metatype<br></p><p>let metatype_s: S.Type = S.self // &lt;~~ (concrete) metatype<br>// ~~~~~~~~~~~~ ^ existential metatype<br></p><p>/*<br>   The relationship looks here like this<br>    <br>   (concrete metatype) `T.Type : T.Type` (existential metatype)  <br>    <br>   OR for the given example: `S.Type : S.Type : Any.Type` (last one is again an existential metatype)<br>   This looks confusing right?<br>*/<br></p><p>class B { }<br>class D : B { }<br></p><p>let metatype_b: B.Type = B.self // &lt;~~ (concrete) metatype<br>// ~~~~~~~~~~~~ ^ existential metatype<br></p><p>metatype_b is D.Type // false<br></p><p>let metatype_d: D.Type = D.self // &lt;~~ (concrete) metatype<br>// ~~~~~~~~~~~~ ^ existential metatype<br></p><p>let metatype_2: B.Type = metatype_d   // Totally fine<br>let metatype_3: Any.Type = metatype_2 // Okay<br></p><p>metatype_3 is D.Type // true<br></p><p>/*<br>   Relationship:<br>    <br>   (existential metatype) `B.Type : Any.Type` (existential metatype)<br>   (concrete metatype) `B.Type : B.Type` (existential metatype)<br>    <br>   (existential metatype) `D.Type : B.Type` (existential metatype)<br>   (concrete metatype) `D.Type : D.Type` (existential metatype)<br>*/<br>It should be clear by now that there is this odd T.Type : T.Type relationship. We want to correct this behaviour + solve the problem that raises with protocols with one simple and single design.<br></p><p>Let’s see what happens with protocols:<br></p><p>protocol P { }  <br></p><p>let metatype_p: P.Type = P.self // Error, because the concrete metatype is not a subtype of the existential metatype of P<br></p><p>// Furthermore `P.self` is `P.Protocol`<br></p><p>let metatype_3: Any.Type = P.self // fine &lt;~~ (concrete) metatype<br>// ~~~~~~~~~~~~ ^ existential metatype<br></p><p>/*<br>   Relationship:<br>   (concrete metatype) `P.Protocol : Any.Type` (existential metatype)<br>   (existential metatype) `P.Type : Any.Type` (existential metatype)<br>    <br>   At this time `P.Type : Any.Type` is an existential metatype that exists but it does not have any subtypes!<br>*/<br></p><p>struct I : P { }<br></p><p>let metatype_i: I.Type = I.self // &lt;~~ (concrete) metatype<br>// ~~~~~~~~~~~~ ^ existential metatype<br></p><p>let metatype_4: P.Type = metatype_i // fine<br>// ~~~~~~~~~~~~ ^ existential metatype<br></p><p>metatype_4 is I.Type // true<br></p><p>/*<br>   Relationship:<br>   (existential metatype) `P.Type : Any.Type` (existential metatype)<br>   (existential metatype) `I.Type : P.Type` (existential metatype)<br>   (concrete metatype) `I.Type : I.Type` (existential metatype)<br>*/<br>There is a huge overlap in the current design. I hope this cleared your question here.<br></p><p>Side note: The following function isn’t possible to implement with the current T.Type design because in generic context a protocol will end up T.Protocol.<br></p><p>func dynamic&lt;T&gt;(subtype: Subtype&lt;Any&gt;, `is` _: Type&lt;T&gt;) -&gt; Bool {<br>  return type is Subtype&lt;T&gt;<br>}<br>The proposed design however solves these problems and the relationship becomes clearer:<br></p><p>(existential metatype) `Subtype&lt;B&gt; : Subtype&lt;Any&gt;` (existential metatype)<br>(concrete metatype) `Type&lt;B&gt; : Subtype&lt;B&gt;` (existential metatype)<br>    <br>(existential metatype) `Subtype&lt;D&gt; : Subtype&lt;B&gt;` (existential metatype)<br>(concrete metatype) `Type&lt;D&gt; : Subtype&lt;D&gt;` (existential metatype)<br></p><p>(existential metatype) `Subtype&lt;P&gt; : Subtype&lt;Any&gt;` (existential metatype)<br>(concrete metatype) `Type&lt;P&gt; : Subtype&lt;Any&gt;` (existential metatype)<br></p><p>(existential metatype) `Subtype&lt;P&gt; : Subtype&lt;Any&gt;` (existential metatype)<br>(existential metatype) `Subtype&lt;I&gt; : Subtype&lt;P&gt;` (existential metatype)<br>(concrete metatype) `Type&lt;I&gt; : Subtype&lt;I&gt;` (existential metatype)<br>The only way to work with Subtype&lt;T&gt; is by using subtype(of:) function of by manually shadowing a concrete metatype Type&lt;T&gt;.<br></p><p>The only way to instantiate a concrete metatype is done with T.self.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 30. September 2016 um 21:48:39, Xiaodi Wu (xiaodi.wu at gmail.com) schrieb:<br></p><p>Sorry, my question at least has nothing to do with bikeshedding. I&#39;m confused about why the proposal feels it&#39;s necessary to have both Type and Subtype. I don&#39;t understand Brent&#39;s two reasons and was hoping for some elaboration. I&#39;ve tried to clarify my question in a gist:<br></p><p>https://gist.github.com/xwu/0cc2c8d358f1fdf066ba739bcd151167<br></p><p><br>On Fri, Sep 30, 2016 at 2:09 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>About the proposed names:<br></p><p>To be crystal clear we could use more descriptive names for our two types. Today T.Type is referred as *metatype* and serving two different purposes at once.<br></p><p>It’s a concrete type; we call it Type&lt;T&gt; or other suggested names looked like ExactType&lt;T&gt;, StaticType&lt;T&gt; etc.<br></p><p>T.Type is also the base type for all subtypes of T.<br></p><p>Protocols has one exception here.<br></p><p>1.1. The concrete type for protocols is not T.Type but T.Protocol.<br></p><p>2.1. T.Protocol has only one supertype, which is the existential (#2) Any.Type type.<br></p><p>Our proposal slices this behaviour into two different types, where you only can create a *concrete type* Type&lt;T&gt; with T.self or shadow a concrete type behind Subtype&lt;U&gt; with subtype(of:) function.<br></p><p>To be precise the correct names should be:<br></p><p>Metatype&lt;T&gt; for the concrete type (#1).<br>ExistentialMetatype&lt;T&gt; for the existential type (#2).<br>But we felt that we should adopt the existing name from T.Type and use the short form for the *concrete type* Type&lt;T&gt;.<br></p><p>Brent already showed in multiple examples but the question seems to come up over and over about the correct name of the current type(of:) function.<br></p><p>Imagine this scenario:<br></p><p>protocol P {}<br>struct A : P {}<br></p><p>let proto: P = A()<br>let any: Any = proto<br></p><p>// the old behaviour looked like this<br></p><p>// *concrete* `A.Type` is hidden behind the existential `Any.Type`<br>let anyMetatype: Any.Type = any.dynamicType   <br></p><p>anyMetatype is P.Type //=&gt; true `P.Type` is the existential type here<br>anyMetatype is A.Type //=&gt; true<br>let aMetatype = anyMetatype as! A.Type // Okay<br></p><p>// today `type(of:)` does the same trick<br></p><p>// After this proposal:<br>// subtype&lt;T&gt;(of instance: T) -&gt; Subtype&lt;T&gt;<br></p><p>// The function will extract `Type&lt;A&gt;` for `any` but shadow it behind `Subtype&lt;Any&gt;`<br>let anyMetatype: `Subtype&lt;Any&gt;` = subtype(of: any)<br></p><p>// The correct relationship look like this:<br>// Subtype&lt;P&gt; : Subtype&lt;Any&gt;<br>// Subtype&lt;A&gt; : Subtype&lt;P&gt;<br>// Type&lt;A&gt; : Subtype&lt;A&gt;<br></p><p>anyMetatype is Subtype&lt;P&gt; //=&gt; true<br>anyMetatype is Subtype&lt;A&gt; //=&gt; true<br>anyMetatype is Type&lt;A&gt;    //=&gt; true<br>anyMetatype is Type&lt;P&gt;    //=&gt; false<br>anyMetatype is Type&lt;Any&gt;  //=&gt; false<br>let aMetatype_1 = anyMetatype as! Subtype&lt;A&gt; // Okay<br>let aMetatype_2 = anyMetatype as! Type&lt;A&gt;    // Okay<br>subtype(of:) function extracts the *concrete type* from the given instance but shadows it behind the *existential type* equal to the type of the given instance.<br></p><p>subtype(of: T) returns a existential metatype instance Subtype&lt;T&gt; where in reality it’s a concrete metatype Type&lt;U&gt; with the relationship like U : T.<br></p><p>This is exact the same behaviour as the old .dynamicType had.<br></p><p>I hope that cleared some raising questions.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 30. September 2016 um 09:00:53, Goffredo Marocchi via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Calling it SuperTypeOf&lt;T&gt; and SubTypeOf&lt;T&gt; would make it less confusing as that is how I read it in my mind in your last example.<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/3a629861/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>September 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Sep 29, 2016, at 7:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 29, 2016, at 3:24 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why would we not have type(of:) and subtype(of:)? Why would I want the Subtype&lt;T&gt; instead of the specific Type&lt;T&gt;?<br>&gt; <br>&gt; Let&#39;s turn this around. Suppose you write:<br>&gt; <br>&gt; 	let obj: NSObject = …<br>&gt; 	let ty = type(of: obj)<br>&gt; <br>&gt; What is `ty`? Well, it&#39;s a `Type&lt;NSObject&gt;`, and there&#39;s only one of those: `NSObject.self`. So there&#39;s only one possible instance that could be assigned to that variable.<br>&gt; <br>&gt; This is true in general: If `type(of:)` returns `Type&lt;T&gt;`, then it can only have one possible return value. In other words, the return value of `type(of:)` would always be the *static* type of the variable, not its dynamic type. There may be some narrow cases where that&#39;d be useful, but 99% of the time, you want `subtype(of:)` because you&#39;re trying to discover which of many dynamic subtypes of the static type you&#39;re actually dealing with. So most uses of `type(of:)` would probably be mistaken attempts to perform `subtype(of:)` instead.<br>&gt; <br>&gt;&gt; What is the rationale for losing the meta type relationships by having Type&lt;U&gt; not be a subtype of Type&lt;T&gt;?<br>&gt; <br>&gt; The relationships aren&#39;t lost; they&#39;re just expressed through `Subtype`, not `Type`.<br>&gt; <br>&gt; Again, turn this around. `Subtype` is the normal thing that you&#39;ll want to use most of the time. `Type` is the weird thing whose existence is hard to explain. (One version of this proposal used `Type` for `Subtype` and `ExactType` for `Type` in order to imply that subtype is usually what you want, but some of the contributors weren&#39;t happy with that.)<br>&gt; <br>&gt; So, `Type` is the weird thing. Why does it exist? Two reasons:<br>&gt; <br>&gt; 1. `Subtype&lt;T&gt;` only includes *inheritable* type members of `T`. `Type&lt;T&gt;` also includes *non-inheritable* members, particularly non-required initializers.<br>&gt; <br>&gt; 2. It allows precise type matches: `subty is Subtype&lt;NSObject&gt;` would match for any subtype of `NSObject`, whereas `subty is Type&lt;NSObject&gt;` would only match for `NSObject` itself.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>I understand what you’re getting at. <br></p><p>This topic is confusing enough that I think it warrants being extremely clear about the naming. Type and Subtype feel like a class hierarchy and that’s not exactly what we are doing here. If Type&lt;T&gt; represents the static type of T then let’s just call it StaticType&lt;T&gt;. If the thing most people want to work with is the dynamic type Subtype&lt;T&gt; then let’s just call it that: DynamicType&lt;T&gt;.<br></p><p>Now this becomes really clear:<br></p><p>class A { }<br>class B: A { }<br></p><p>//clearly only ever represents A as a type<br>let metatype_1 = statictype(of: A())<br></p><p>//clearly might dynamically be A, B, or any subclass<br>let metatype_2 = dynamictype(of: A())<br></p><p><br>It also becomes trivially easy to explain because the name follows the explanation. Why can I only use required initializers on DynamicType&lt;A&gt;? Because we don’t know if the initializer is available; the dynamic type may differ at runtime. StaticType&lt;A&gt; knows exactly what is available on A because it is statically known at compile time.<br></p><p><br>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 10:25 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; This topic is confusing enough that I think it warrants being extremely clear about the naming. Type and Subtype feel like a class hierarchy and that’s not exactly what we are doing here. If Type&lt;T&gt; represents the static type of T then let’s just call it StaticType&lt;T&gt;. If the thing most people want to work with is the dynamic type Subtype&lt;T&gt; then let’s just call it that: DynamicType&lt;T&gt;.<br>&gt; <br>&gt; Now this becomes really clear:<br>&gt; <br>&gt; class A { }<br>&gt; class B: A { }<br>&gt; <br>&gt; //clearly only ever represents A as a type<br>&gt; let metatype_1 = statictype(of: A())<br>&gt; <br>&gt; //clearly might dynamically be A, B, or any subclass<br>&gt; let metatype_2 = dynamictype(of: A())<br>&gt; <br>&gt; <br>&gt; It also becomes trivially easy to explain because the name follows the explanation. Why can I only use required initializers on DynamicType&lt;A&gt;? Because we don’t know if the initializer is available; the dynamic type may differ at runtime. StaticType&lt;A&gt; knows exactly what is available on A because it is statically known at compile time.<br></p><p>But that *isn&#39;t* clear about the relationship between DynamicType and StaticType—specifically, that there are no concrete DynamicTypes, and all DynamicType variables will contain StaticType instances.<br></p><p>In some drafts, I suggested pairs like `Type` and `SpecificType`:<br></p><p>	func type&lt;T&gt;(of: T) -&gt; Type&lt;T&gt;<br>	func size&lt;T&gt;(of: SpecificType&lt;T&gt;) -&gt; Int<br></p><p>(Incidentally, a third benefit of the redesign is that parameters can now be clear about whether they&#39;re actually sensitive to the specific dynamic type you pass or they&#39;re just being used to pin a generic parameter to a static type. For instance, when you call `UnsafeMutableRawPointer.initializeMemory(as:at:count:to:)`, it doesn&#39;t care what dynamic type you pass, but when you call `URLProtocol.registerClass(_:)`, it does. This would be represented—using the proposal&#39;s names—by `initializeMemory` taking a `Type&lt;T&gt;` and `URLProtocol` taking a `Subtype&lt;URLProtocol&gt;` or `Subtype&lt;AnyObject&gt;`.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October  2, 2016 at 07:00:00am</p></header><div class="content"><p>I think the names should be bikeshedded more still. From your examples they seem to make sense when I mentally add Of like TypeOf&lt;&gt; and SubTypeOf&lt;&gt;, but since you are not commenting on why that is wrong or right or misleading, or at least I have missed your reply on that, I am still a bit at loss. Maybe we need other words altogether?<br></p><p>Sent from my iPhone<br></p><p>On 2 Oct 2016, at 05:04, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Sep 30, 2016, at 10:25 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; This topic is confusing enough that I think it warrants being extremely clear about the naming. Type and Subtype feel like a class hierarchy and that’s not exactly what we are doing here. If Type&lt;T&gt; represents the static type of T then let’s just call it StaticType&lt;T&gt;. If the thing most people want to work with is the dynamic type Subtype&lt;T&gt; then let’s just call it that: DynamicType&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt; Now this becomes really clear:<br>&gt;&gt; <br>&gt;&gt; class A { }<br>&gt;&gt; class B: A { }<br>&gt;&gt; <br>&gt;&gt; //clearly only ever represents A as a type<br>&gt;&gt; let metatype_1 = statictype(of: A())<br>&gt;&gt; <br>&gt;&gt; //clearly might dynamically be A, B, or any subclass<br>&gt;&gt; let metatype_2 = dynamictype(of: A())<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It also becomes trivially easy to explain because the name follows the explanation. Why can I only use required initializers on DynamicType&lt;A&gt;? Because we don’t know if the initializer is available; the dynamic type may differ at runtime. StaticType&lt;A&gt; knows exactly what is available on A because it is statically known at compile time.<br>&gt; <br>&gt; But that *isn&#39;t* clear about the relationship between DynamicType and StaticType—specifically, that there are no concrete DynamicTypes, and all DynamicType variables will contain StaticType instances.<br>&gt; <br>&gt; In some drafts, I suggested pairs like `Type` and `SpecificType`:<br>&gt; <br>&gt;    func type&lt;T&gt;(of: T) -&gt; Type&lt;T&gt;<br>&gt;    func size&lt;T&gt;(of: SpecificType&lt;T&gt;) -&gt; Int<br>&gt; <br>&gt; (Incidentally, a third benefit of the redesign is that parameters can now be clear about whether they&#39;re actually sensitive to the specific dynamic type you pass or they&#39;re just being used to pin a generic parameter to a static type. For instance, when you call `UnsafeMutableRawPointer.initializeMemory(as:at:count:to:)`, it doesn&#39;t care what dynamic type you pass, but when you call `URLProtocol.registerClass(_:)`, it does. This would be represented—using the proposal&#39;s names—by `initializeMemory` taking a `Type&lt;T&gt;` and `URLProtocol` taking a `Subtype&lt;URLProtocol&gt;` or `Subtype&lt;AnyObject&gt;`.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>October  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Goffredo Marocchi wrote:<br>&gt; <br>&gt; I think the names should be bikeshedded more still. From your examples they seem to make sense when I mentally add Of like TypeOf&lt;&gt; and SubTypeOf&lt;&gt;, but since you are not commenting on why that is wrong or right or misleading, or at least I have missed your reply on that, I am still a bit at loss. Maybe we need other words altogether?<br></p><p>OTOH, we don&#39;t have ArrayOf&lt;Element&gt; or DictionaryOfKeyAndValue&lt;Key, Value&gt;, while we still pronounce them that way. I don&#39;t think prepositions belong in the name of types but in exceptional cases, and this doesn&#39;t sound exceptional enough to me.<br></p><p>— Pyry<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  2, 2016 at 09:00:00am</p></header><div class="content"><p>That’s right. I was about to say something similar about the Of.<br></p><p>Actually Type&lt;T&gt; would be the correct name for the static/concrete metatype.<br></p><p>We already have this notation but not in a generic way T.Type<br>If we add of only in our mind to Type&lt;T&gt;, we’ll get “Type of a type T” which is shortly referred as a “metatype of T”. (Array&lt;Element&gt; - Array of Element type)<br>Since Subtype&lt;T&gt; in reality is some *existential metatype* and the whole talk about existential types now tend to have the Any prefix, lets follow that trend here too.<br></p><p>Type&lt;T&gt; - (static/concrete/exact) metatype.<br>AnyType&lt;T&gt; - existential metatype.<br>It might be even easier to memorise this name than Subtype.<br></p><p>The example from the proposal rewritten:<br></p><p>// Types:<br>protocol Foo {}<br>protocol Boo : Foo {}<br>class A : Foo {}<br>class B : A, Boo {}<br>struct S : Foo {}<br></p><p>// Metatypes:<br>let a1: Type&lt;A&gt; = A.self           //=&gt; Okay<br>let p1: Type&lt;Foo&gt; = Foo.self       //=&gt; Okay<br>let p2: Type&lt;Boo&gt; = C.self         //=&gt; Error -- `C` is not the same as `Foo`<br></p><p>let any_1: AnyType&lt;Any&gt; = A.self   //=&gt; Okay<br>let any_2: AnyType&lt;Any&gt; = Foo.self //=&gt; Okay<br></p><p>let a_1: AnyType&lt;A&gt; = A.self       //=&gt; Okay<br>let p_1: AnyType&lt;Foo&gt; = A.self     //=&gt; Okay<br>let p_2: AnyType&lt;Foo&gt; = Foo.self   //=&gt; Error -- `Type&lt;Foo&gt;` is not a subtype of `AnyType&lt;Foo&gt;`<br></p><p>// Generic functions:<br>func dynamic&lt;T&gt;(type: AnyType&lt;Any&gt;, `is` _: Type&lt;T&gt;) -&gt; Bool {<br>  return type is AnyType&lt;T&gt;<br>}<br></p><p>func dynamic&lt;T&gt;(type: AnyType&lt;Any&gt;, `as` _: Type&lt;T&gt;) -&gt; AnyType&lt;T&gt;? {<br>  return type as? AnyType&lt;T&gt;<br>}<br></p><p>let s1: Type&lt;S&gt; = S.self<br></p><p>dynamic(type: s1, is: Foo.self)    //=&gt; true<br>dynamic(type: s1, as: Foo.self)    //=&gt; an `Optional&lt;AnyType&lt;Foo&gt;&gt;`<br>The type(of:) function could now stay, because now we’d only need to change the return type.<br></p><p>func type&lt;T&gt;(of instance: T) -&gt; AnyType&lt;T&gt;<br>Isn’t this a good compromise?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 2. Oktober 2016 um 09:01:45, Pyry Jahkola via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>OTOH, we don&#39;t have ArrayOf&lt;Element&gt; or DictionaryOfKeyAndValue&lt;Key, Value&gt;, while we still pronounce them that way. I don&#39;t think prepositions belong in the name of types but in exceptional cases, and this doesn&#39;t sound exceptional enough to me.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161002/b9c614de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>October  2, 2016 at 11:00:00am</p></header><div class="content"><p>That sounds very good to me, and AnyType&lt;T&gt; aligns well with the proposed Any&lt;...&gt; syntax.<br></p><p>— Pyry<br></p><p>&gt; Adrian Zubarev wrote:<br>&gt; <br>&gt; That’s right. I was about to say something similar about the Of.<br>&gt; <br>&gt; Actually Type&lt;T&gt; would be the correct name for the static/concrete metatype.<br>&gt; <br>&gt; We already have this notation but not in a generic way T.Type<br>&gt; If we add of only in our mind to Type&lt;T&gt;, we’ll get “Type of a type T” which is shortly referred as a “metatype of T”. (Array&lt;Element&gt; - Array of Element type)<br>&gt; Since Subtype&lt;T&gt; in reality is some *existential metatype* and the whole talk about existential types now tend to have the Any prefix, lets follow that trend here too.<br>&gt; <br>&gt; Type&lt;T&gt; - (static/concrete/exact) metatype.<br>&gt; AnyType&lt;T&gt; - existential metatype.<br>&gt; It might be even easier to memorise this name than Subtype.<br>&gt; <br>&gt; The example from the proposal rewritten:<br>&gt; <br>&gt; // Types:<br>&gt; protocol Foo {}<br>&gt; protocol Boo : Foo {}<br>&gt; class A : Foo {}<br>&gt; class B : A, Boo {}<br>&gt; struct S : Foo {}<br>&gt; <br>&gt; // Metatypes:<br>&gt; let a1: Type&lt;A&gt; = A.self           //=&gt; Okay<br>&gt; let p1: Type&lt;Foo&gt; = Foo.self       //=&gt; Okay<br>&gt; let p2: Type&lt;Boo&gt; = C.self         //=&gt; Error -- `C` is not the same as `Foo`<br>&gt; <br>&gt; let any_1: AnyType&lt;Any&gt; = A.self   //=&gt; Okay<br>&gt; let any_2: AnyType&lt;Any&gt; = Foo.self //=&gt; Okay<br>&gt; <br>&gt; let a_1: AnyType&lt;A&gt; = A.self       //=&gt; Okay<br>&gt; let p_1: AnyType&lt;Foo&gt; = A.self     //=&gt; Okay<br>&gt; let p_2: AnyType&lt;Foo&gt; = Foo.self   //=&gt; Error -- `Type&lt;Foo&gt;` is not a subtype of `AnyType&lt;Foo&gt;`<br>&gt; <br>&gt; // Generic functions:<br>&gt; func dynamic&lt;T&gt;(type: AnyType&lt;Any&gt;, `is` _: Type&lt;T&gt;) -&gt; Bool {<br>&gt;   return type is AnyType&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; func dynamic&lt;T&gt;(type: AnyType&lt;Any&gt;, `as` _: Type&lt;T&gt;) -&gt; AnyType&lt;T&gt;? {<br>&gt;   return type as? AnyType&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; let s1: Type&lt;S&gt; = S.self<br>&gt; <br>&gt; dynamic(type: s1, is: Foo.self)    //=&gt; true<br>&gt; dynamic(type: s1, as: Foo.self)    //=&gt; an `Optional&lt;AnyType&lt;Foo&gt;&gt;`<br>&gt; The type(of:) function could now stay, because now we’d only need to change the return type.<br>&gt; <br>&gt; func type&lt;T&gt;(of instance: T) -&gt; AnyType&lt;T&gt;<br>&gt; Isn’t this a good compromise?<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 2. Oktober 2016 um 09:01:45, Pyry Jahkola via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt; <br>&gt;&gt; OTOH, we don&#39;t have ArrayOf&lt;Element&gt; or DictionaryOfKeyAndValue&lt;Key, Value&gt;, while we still pronounce them that way. I don&#39;t think prepositions belong in the name of types but in exceptional cases, and this doesn&#39;t sound exceptional enough to me.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161002/0a90d0d7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October  2, 2016 at 11:00:00am</p></header><div class="content"><p>Love it :)!<br></p><p>Sent from my iPhone<br></p><p>&gt; On 2 Oct 2016, at 09:37, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That’s right. I was about to say something similar about the Of.<br>&gt; <br>&gt; Actually Type&lt;T&gt; would be the correct name for the static/concrete metatype.<br>&gt; <br>&gt; We already have this notation but not in a generic way T.Type<br>&gt; If we add of only in our mind to Type&lt;T&gt;, we’ll get “Type of a type T” which is shortly referred as a “metatype of T”. (Array&lt;Element&gt; - Array of Element type)<br>&gt; Since Subtype&lt;T&gt; in reality is some *existential metatype* and the whole talk about existential types now tend to have the Any prefix, lets follow that trend here too.<br>&gt; <br>&gt; Type&lt;T&gt; - (static/concrete/exact) metatype.<br>&gt; AnyType&lt;T&gt; - existential metatype.<br>&gt; It might be even easier to memorise this name than Subtype.<br>&gt; <br>&gt; The example from the proposal rewritten:<br>&gt; <br>&gt; // Types:<br>&gt; protocol Foo {}<br>&gt; protocol Boo : Foo {}<br>&gt; class A : Foo {}<br>&gt; class B : A, Boo {}<br>&gt; struct S : Foo {}<br>&gt; <br>&gt; // Metatypes:<br>&gt; let a1: Type&lt;A&gt; = A.self           //=&gt; Okay<br>&gt; let p1: Type&lt;Foo&gt; = Foo.self       //=&gt; Okay<br>&gt; let p2: Type&lt;Boo&gt; = C.self         //=&gt; Error -- `C` is not the same as `Foo`<br>&gt; <br>&gt; let any_1: AnyType&lt;Any&gt; = A.self   //=&gt; Okay<br>&gt; let any_2: AnyType&lt;Any&gt; = Foo.self //=&gt; Okay<br>&gt; <br>&gt; let a_1: AnyType&lt;A&gt; = A.self       //=&gt; Okay<br>&gt; let p_1: AnyType&lt;Foo&gt; = A.self     //=&gt; Okay<br>&gt; let p_2: AnyType&lt;Foo&gt; = Foo.self   //=&gt; Error -- `Type&lt;Foo&gt;` is not a subtype of `AnyType&lt;Foo&gt;`<br>&gt; <br>&gt; // Generic functions:<br>&gt; func dynamic&lt;T&gt;(type: AnyType&lt;Any&gt;, `is` _: Type&lt;T&gt;) -&gt; Bool {<br>&gt;   return type is AnyType&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; func dynamic&lt;T&gt;(type: AnyType&lt;Any&gt;, `as` _: Type&lt;T&gt;) -&gt; AnyType&lt;T&gt;? {<br>&gt;   return type as? AnyType&lt;T&gt;<br>&gt; }<br>&gt; <br>&gt; let s1: Type&lt;S&gt; = S.self<br>&gt; <br>&gt; dynamic(type: s1, is: Foo.self)    //=&gt; true<br>&gt; dynamic(type: s1, as: Foo.self)    //=&gt; an `Optional&lt;AnyType&lt;Foo&gt;&gt;`<br>&gt; The type(of:) function could now stay, because now we’d only need to change the return type.<br>&gt; <br>&gt; func type&lt;T&gt;(of instance: T) -&gt; AnyType&lt;T&gt;<br>&gt; Isn’t this a good compromise?<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 2. Oktober 2016 um 09:01:45, Pyry Jahkola via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt; <br>&gt;&gt; OTOH, we don&#39;t have ArrayOf&lt;Element&gt; or DictionaryOfKeyAndValue&lt;Key, Value&gt;, while we still pronounce them that way. I don&#39;t think prepositions belong in the name of types but in exceptional cases, and this doesn&#39;t sound exceptional enough to me.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161002/00bb4c7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Refactor Metatypes</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October  2, 2016 at 01:00:00pm</p></header><div class="content"><p>You can read the updated version of the proposal on a sub-branch: https://github.com/DevAndArtist/swift-evolution/blob/refactor_existential_metatypes/proposals/0126-refactor-metatypes.md<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 2. Oktober 2016 um 11:47:50, Goffredo Marocchi (panajev at gmail.com) schrieb:<br></p><p>Love it :)!<br></p><p>Sent from my iPhone<br></p><p>On 2 Oct 2016, at 09:37, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>That’s right. I was about to say something similar about the Of.<br></p><p>Actually Type&lt;T&gt; would be the correct name for the static/concrete metatype.<br></p><p>We already have this notation but not in a generic way T.Type<br>If we add of only in our mind to Type&lt;T&gt;, we’ll get “Type of a type T” which is shortly referred as a “metatype of T”. (Array&lt;Element&gt; - Array of Element type)<br>Since Subtype&lt;T&gt; in reality is some *existential metatype* and the whole talk about existential types now tend to have the Any prefix, lets follow that trend here too.<br></p><p>Type&lt;T&gt; - (static/concrete/exact) metatype.<br>AnyType&lt;T&gt; - existential metatype.<br>It might be even easier to memorise this name than Subtype.<br></p><p>The example from the proposal rewritten:<br></p><p>// Types:<br>protocol Foo {}<br>protocol Boo : Foo {}<br>class A : Foo {}<br>class B : A, Boo {}<br>struct S : Foo {}<br></p><p>// Metatypes:<br>let a1: Type&lt;A&gt; = A.self           //=&gt; Okay<br>let p1: Type&lt;Foo&gt; = Foo.self       //=&gt; Okay<br>let p2: Type&lt;Boo&gt; = C.self         //=&gt; Error -- `C` is not the same as `Foo`<br></p><p>let any_1: AnyType&lt;Any&gt; = A.self   //=&gt; Okay<br>let any_2: AnyType&lt;Any&gt; = Foo.self //=&gt; Okay<br></p><p>let a_1: AnyType&lt;A&gt; = A.self       //=&gt; Okay<br>let p_1: AnyType&lt;Foo&gt; = A.self     //=&gt; Okay<br>let p_2: AnyType&lt;Foo&gt; = Foo.self   //=&gt; Error -- `Type&lt;Foo&gt;` is not a subtype of `AnyType&lt;Foo&gt;`<br></p><p>// Generic functions:<br>func dynamic&lt;T&gt;(type: AnyType&lt;Any&gt;, `is` _: Type&lt;T&gt;) -&gt; Bool {<br>  return type is AnyType&lt;T&gt;<br>}<br></p><p>func dynamic&lt;T&gt;(type: AnyType&lt;Any&gt;, `as` _: Type&lt;T&gt;) -&gt; AnyType&lt;T&gt;? {<br>  return type as? AnyType&lt;T&gt;<br>}<br></p><p>let s1: Type&lt;S&gt; = S.self<br></p><p>dynamic(type: s1, is: Foo.self)    //=&gt; true<br>dynamic(type: s1, as: Foo.self)    //=&gt; an `Optional&lt;AnyType&lt;Foo&gt;&gt;`<br>The type(of:) function could now stay, because now we’d only need to change the return type.<br></p><p>func type&lt;T&gt;(of instance: T) -&gt; AnyType&lt;T&gt;<br>Isn’t this a good compromise?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 2. Oktober 2016 um 09:01:45, Pyry Jahkola via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>OTOH, we don&#39;t have ArrayOf&lt;Element&gt; or DictionaryOfKeyAndValue&lt;Key, Value&gt;, while we still pronounce them that way. I don&#39;t think prepositions belong in the name of types but in exceptional cases, and this doesn&#39;t sound exceptional enough to me.<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161002/f681988e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
