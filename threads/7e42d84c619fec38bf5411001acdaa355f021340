<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Making functions generic on optionals</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February  5, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi All.<br></p><p>In the code below, I have the method<br></p><p>public class func sortDescriptorsFromString(sortString :String) throws -&gt; [NSSortDescriptor]<br></p><p>In order to make life easier, I would like to make sortString optional, but then I would have to make the return type optional to to be able to return nil if the argument is nil. To get around this, I’ve added a stub method<br></p><p>public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]?<br></p><p>that declares the argument to be optional and the return type to be optional.<br></p><p>I get the feeling that there is a way to not have to write a stub method every time I want to do this. I also get the feeling that I should be able to accomplish it through generics. But I do not know how to write the declaration for such a method. Can anyone help?<br></p><p>Thanks!<br></p><p>-Kenny<br></p><p><br>extension NSSortDescriptor {<br></p><p>    public class func sortDescriptorsFromString(sortString :String) throws -&gt; [NSSortDescriptor] {<br>        var descriptors = [NSSortDescriptor]()<br>        let components = sortString.split(&quot;[, ]+&quot;)<br></p><p>        for i in 0.stride(to: components.count, by: 2) {<br>            let key = components[i]<br>            let direction = components[i + 1]<br>            var descriptor :NSSortDescriptor?<br></p><p>            if SORT_STRINGS_ASCENDING.contains(direction) {<br>                descriptor = NSSortDescriptor(key: key, ascending: true)<br>            } else if SORT_STRINGS_DESCENDING.contains(direction) {<br>                descriptor = NSSortDescriptor(key: key, ascending: false)<br>            } else if SORT_STRINGS_CASEINSENSITIVE_ASCENDING.contains(direction) {<br>                descriptor = NSSortDescriptor(key: key, ascending: true, selector: &quot;caseInsensitiveCompare:&quot;);<br>            } else if SORT_STRINGS_CASEINSENSITIVE_DESCENDING.contains(direction) {<br>                descriptor = NSSortDescriptor(key: key, ascending: false, selector: &quot;caseInsensitiveCompare:&quot;);<br>            } else if SORT_DATE_ASCENDING.contains(direction) {<br>                descriptor = NSSortDescriptor(key: key, ascending: true, selector: &quot;compare:&quot;);<br>            } else if SORT_DATE_DESCENDING.contains(direction) {<br>                descriptor = NSSortDescriptor(key: key, ascending: false, selector: &quot;compare:&quot;);<br>            }<br></p><p>            if let nnDescriptor = descriptor {<br>                descriptors.append(nnDescriptor)<br>            } else {<br>                throw NSSortDescriptorError.UnsupportedSortDirection<br>            }<br>        }<br></p><p>        return descriptors<br>    }<br></p><p>    public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]? {<br>        guard let sortString = sortString else {return nil}<br>        return try self.sortDescriptorsFromString(sortString)<br>    }<br></p><p>}<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160205/7e421340/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Making functions generic on optionals</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  5, 2016 at 02:00:00pm</p></header><div class="content"><p>The smallest way to write this is at the call site:<br></p><p>sortStringOpt.map { NSSortDescriptor.sortDescriptorsFromString($0) }<br></p><p>But really I&#39;m a little curious about why you&#39;re thinking about &quot;every time [you] want to do this&quot;. Does this really come up that often? In this particular case, why would you ever not have a sort string?<br></p><p>Jordan<br></p><p><br>&gt; On Feb 5, 2016, at 13:53, Kenny Leung via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi All.<br>&gt; <br>&gt; In the code below, I have the method<br>&gt; <br>&gt; public class func sortDescriptorsFromString(sortString :String) throws -&gt; [NSSortDescriptor]<br>&gt; <br>&gt; In order to make life easier, I would like to make sortString optional, but then I would have to make the return type optional to to be able to return nil if the argument is nil. To get around this, I’ve added a stub method<br>&gt; <br>&gt; public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]?<br>&gt; <br>&gt; that declares the argument to be optional and the return type to be optional.<br>&gt; <br>&gt; I get the feeling that there is a way to not have to write a stub method every time I want to do this. I also get the feeling that I should be able to accomplish it through generics. But I do not know how to write the declaration for such a method. Can anyone help?<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; extension NSSortDescriptor {<br>&gt; <br>&gt;     public class func sortDescriptorsFromString(sortString :String) throws -&gt; [NSSortDescriptor] {<br>&gt;         var descriptors = [NSSortDescriptor]()<br>&gt;         let components = sortString.split(&quot;[, ]+&quot;)<br>&gt; <br>&gt;         for i in 0.stride(to: components.count, by: 2) {<br>&gt;             let key = components[i]<br>&gt;             let direction = components[i + 1]<br>&gt;             var descriptor :NSSortDescriptor?<br>&gt; <br>&gt;             if SORT_STRINGS_ASCENDING.contains(direction) {<br>&gt;                 descriptor = NSSortDescriptor(key: key, ascending: true)<br>&gt;             } else if SORT_STRINGS_DESCENDING.contains(direction) {<br>&gt;                 descriptor = NSSortDescriptor(key: key, ascending: false)<br>&gt;             } else if SORT_STRINGS_CASEINSENSITIVE_ASCENDING.contains(direction) {<br>&gt;                 descriptor = NSSortDescriptor(key: key, ascending: true, selector: &quot;caseInsensitiveCompare:&quot;);<br>&gt;             } else if SORT_STRINGS_CASEINSENSITIVE_DESCENDING.contains(direction) {<br>&gt;                 descriptor = NSSortDescriptor(key: key, ascending: false, selector: &quot;caseInsensitiveCompare:&quot;);<br>&gt;             } else if SORT_DATE_ASCENDING.contains(direction) {<br>&gt;                 descriptor = NSSortDescriptor(key: key, ascending: true, selector: &quot;compare:&quot;);<br>&gt;             } else if SORT_DATE_DESCENDING.contains(direction) {<br>&gt;                 descriptor = NSSortDescriptor(key: key, ascending: false, selector: &quot;compare:&quot;);<br>&gt;             }<br>&gt; <br>&gt;             if let nnDescriptor = descriptor {<br>&gt;                 descriptors.append(nnDescriptor)<br>&gt;             } else {<br>&gt;                 throw NSSortDescriptorError.UnsupportedSortDirection<br>&gt;             }<br>&gt;         }<br>&gt; <br>&gt;         return descriptors<br>&gt;     }<br>&gt; <br>&gt;     public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]? {<br>&gt;         guard let sortString = sortString else {return nil}<br>&gt;         return try self.sortDescriptorsFromString(sortString)<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160205/a5b177d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Making functions generic on optionals</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February  5, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Jordan.<br></p><p>Thanks for the response.<br></p><p>&gt; On Feb 5, 2016, at 2:34 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; The smallest way to write this is at the call site:<br>&gt; <br>&gt; sortStringOpt.map { NSSortDescriptor.sortDescriptorsFromString($0) }<br></p><p>Sorry, but I don’t understand this solution. What type is sortStringOpt?<br></p><p>&gt; But really I&#39;m a little curious about why you&#39;re thinking about &quot;every time [you] want to do this&quot;. Does this really come up that often? In this particular case, why would you ever not have a sort string?<br></p><p>In particular, sortString might come from user input, so it may be nil.<br></p><p>In general,  “every time I want to do this” was referring to providing a piece of API that could take optional or non-optional inputs without either burdening the provider with writing a stub method or the client with having to always deal with an optional return from the method.<br></p><p>-Kenny<br></p><p><br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 5, 2016, at 13:53, Kenny Leung via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi All.<br>&gt;&gt; <br>&gt;&gt; In the code below, I have the method<br>&gt;&gt; <br>&gt;&gt; public class func sortDescriptorsFromString(sortString :String) throws -&gt; [NSSortDescriptor]<br>&gt;&gt; <br>&gt;&gt; In order to make life easier, I would like to make sortString optional, but then I would have to make the return type optional to to be able to return nil if the argument is nil. To get around this, I’ve added a stub method<br>&gt;&gt; <br>&gt;&gt; public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]?<br>&gt;&gt; <br>&gt;&gt; that declares the argument to be optional and the return type to be optional.<br>&gt;&gt; <br>&gt;&gt; I get the feeling that there is a way to not have to write a stub method every time I want to do this. I also get the feeling that I should be able to accomplish it through generics. But I do not know how to write the declaration for such a method. Can anyone help?<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension NSSortDescriptor {<br>&gt;&gt; <br>&gt;&gt;     public class func sortDescriptorsFromString(sortString :String) throws -&gt; [NSSortDescriptor] {<br>&gt;&gt;         var descriptors = [NSSortDescriptor]()<br>&gt;&gt;         let components = sortString.split(&quot;[, ]+&quot;)<br>&gt;&gt; <br>&gt;&gt;         for i in 0.stride(to: components.count, by: 2) {<br>&gt;&gt;             let key = components[i]<br>&gt;&gt;             let direction = components[i + 1]<br>&gt;&gt;             var descriptor :NSSortDescriptor?<br>&gt;&gt; <br>&gt;&gt;             if SORT_STRINGS_ASCENDING.contains(direction) {<br>&gt;&gt;                 descriptor = NSSortDescriptor(key: key, ascending: true)<br>&gt;&gt;             } else if SORT_STRINGS_DESCENDING.contains(direction) {<br>&gt;&gt;                 descriptor = NSSortDescriptor(key: key, ascending: false)<br>&gt;&gt;             } else if SORT_STRINGS_CASEINSENSITIVE_ASCENDING.contains(direction) {<br>&gt;&gt;                 descriptor = NSSortDescriptor(key: key, ascending: true, selector: &quot;caseInsensitiveCompare:&quot;);<br>&gt;&gt;             } else if SORT_STRINGS_CASEINSENSITIVE_DESCENDING.contains(direction) {<br>&gt;&gt;                 descriptor = NSSortDescriptor(key: key, ascending: false, selector: &quot;caseInsensitiveCompare:&quot;);<br>&gt;&gt;             } else if SORT_DATE_ASCENDING.contains(direction) {<br>&gt;&gt;                 descriptor = NSSortDescriptor(key: key, ascending: true, selector: &quot;compare:&quot;);<br>&gt;&gt;             } else if SORT_DATE_DESCENDING.contains(direction) {<br>&gt;&gt;                 descriptor = NSSortDescriptor(key: key, ascending: false, selector: &quot;compare:&quot;);<br>&gt;&gt;             }<br>&gt;&gt; <br>&gt;&gt;             if let nnDescriptor = descriptor {<br>&gt;&gt;                 descriptors.append(nnDescriptor)<br>&gt;&gt;             } else {<br>&gt;&gt;                 throw NSSortDescriptorError.UnsupportedSortDirection<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         return descriptors<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]? {<br>&gt;&gt;         guard let sortString = sortString else {return nil}<br>&gt;&gt;         return try self.sortDescriptorsFromString(sortString)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Making functions generic on optionals</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February  5, 2016 at 03:00:00pm</p></header><div class="content"><p>Thanks for your answers.<br></p><p>After some googling and experimenting, I get it now:<br></p><p>    func testOptionalMap() {<br>        do {<br>            var sortString :String?<br>            var sortDescriptors :[NSSortDescriptor]?<br></p><p>            sortString = &quot;name,up&quot;<br>            try sortDescriptors = sortString.map {try NSSortDescriptor.sortDescriptorsFromString($0)}<br>            XCTAssertNotNil(sortDescriptors);<br>            if let sortDescriptor = sortDescriptors?[0] {<br>                assert(sortDescriptor, &quot;name&quot;,   true)<br>            }<br></p><p>            sortString = nil<br>            try sortDescriptors = sortString.map {try NSSortDescriptor.sortDescriptorsFromString($0)}<br>            XCTAssertNil(sortDescriptors);<br>        } catch {<br>            XCTFail()<br>        }<br>    }<br></p><p>I commented out the stub method, yet I can still send an optional into sortDescriptorsFromString.<br></p><p>I have to say, though, this is a very unfriendly way to solve this problem.<br></p><p>- since optionals are so hidden syntax wise, you could naturally assume that map belongs to String, and not Optional<br>- reading the code, it’s not obvious what the map function is actually doing here. You really have to squint your eyes to realize that <br></p><p>“Optional.map will only execute the code in the block if the thing it’s wrapping is not nil, and $0 is the thing it’s wrapping, unwrapped&quot;<br></p><p>So I’ll try rephrasing my question:<br></p><p>Is there way to declare a method such that, if the argument is optional, the return value is optional, but if the argument is not optional, the return value is also not optional? The argument and the return values are not the same type.<br></p><p>Thanks!<br></p><p>-Kenny<br></p><p><br>&gt; On Feb 5, 2016, at 14:45, Kenny Leung via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Jordan.<br>&gt; <br>&gt; Thanks for the response.<br>&gt; <br>&gt;&gt; On Feb 5, 2016, at 2:34 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The smallest way to write this is at the call site:<br>&gt;&gt; <br>&gt;&gt; sortStringOpt.map { NSSortDescriptor.sortDescriptorsFromString($0) }<br>&gt; <br>&gt; Sorry, but I don’t understand this solution. What type is sortStringOpt?<br>&gt; <br>&gt;&gt; But really I&#39;m a little curious about why you&#39;re thinking about &quot;every time [you] want to do this&quot;. Does this really come up that often? In this particular case, why would you ever not have a sort string?<br>&gt; <br>&gt; In particular, sortString might come from user input, so it may be nil.<br>&gt; <br>&gt; In general,  “every time I want to do this” was referring to providing a piece of API that could take optional or non-optional inputs without either burdening the provider with writing a stub method or the client with having to always deal with an optional return from the method.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 5, 2016, at 13:53, Kenny Leung via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi All.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the code below, I have the method<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class func sortDescriptorsFromString(sortString :String) throws -&gt; [NSSortDescriptor]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to make life easier, I would like to make sortString optional, but then I would have to make the return type optional to to be able to return nil if the argument is nil. To get around this, I’ve added a stub method<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; that declares the argument to be optional and the return type to be optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I get the feeling that there is a way to not have to write a stub method every time I want to do this. I also get the feeling that I should be able to accomplish it through generics. But I do not know how to write the declaration for such a method. Can anyone help?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSSortDescriptor {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public class func sortDescriptorsFromString(sortString :String) throws -&gt; [NSSortDescriptor] {<br>&gt;&gt;&gt;        var descriptors = [NSSortDescriptor]()<br>&gt;&gt;&gt;        let components = sortString.split(&quot;[, ]+&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        for i in 0.stride(to: components.count, by: 2) {<br>&gt;&gt;&gt;            let key = components[i]<br>&gt;&gt;&gt;            let direction = components[i + 1]<br>&gt;&gt;&gt;            var descriptor :NSSortDescriptor?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            if SORT_STRINGS_ASCENDING.contains(direction) {<br>&gt;&gt;&gt;                descriptor = NSSortDescriptor(key: key, ascending: true)<br>&gt;&gt;&gt;            } else if SORT_STRINGS_DESCENDING.contains(direction) {<br>&gt;&gt;&gt;                descriptor = NSSortDescriptor(key: key, ascending: false)<br>&gt;&gt;&gt;            } else if SORT_STRINGS_CASEINSENSITIVE_ASCENDING.contains(direction) {<br>&gt;&gt;&gt;                descriptor = NSSortDescriptor(key: key, ascending: true, selector: &quot;caseInsensitiveCompare:&quot;);<br>&gt;&gt;&gt;            } else if SORT_STRINGS_CASEINSENSITIVE_DESCENDING.contains(direction) {<br>&gt;&gt;&gt;                descriptor = NSSortDescriptor(key: key, ascending: false, selector: &quot;caseInsensitiveCompare:&quot;);<br>&gt;&gt;&gt;            } else if SORT_DATE_ASCENDING.contains(direction) {<br>&gt;&gt;&gt;                descriptor = NSSortDescriptor(key: key, ascending: true, selector: &quot;compare:&quot;);<br>&gt;&gt;&gt;            } else if SORT_DATE_DESCENDING.contains(direction) {<br>&gt;&gt;&gt;                descriptor = NSSortDescriptor(key: key, ascending: false, selector: &quot;compare:&quot;);<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;            if let nnDescriptor = descriptor {<br>&gt;&gt;&gt;                descriptors.append(nnDescriptor)<br>&gt;&gt;&gt;            } else {<br>&gt;&gt;&gt;                throw NSSortDescriptorError.UnsupportedSortDirection<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        return descriptors<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]? {<br>&gt;&gt;&gt;        guard let sortString = sortString else {return nil}<br>&gt;&gt;&gt;        return try self.sortDescriptorsFromString(sortString)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160205/d40319c0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Making functions generic on optionals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;     public class func sortDescriptorsFromString(sortString :String?) throws -&gt; [NSSortDescriptor]? {<br>&gt;         guard let sortString = sortString else {return nil}<br>&gt;         return try self.sortDescriptorsFromString(sortString)<br>&gt;     }<br>&gt; <br>&gt; }<br></p><p>This is equivalent to (something like):<br></p><p>	return try sortString.map(self.sortDescriptorsFromString)<br></p><p>You can always use that directly at the call sites where you have an optional String.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
