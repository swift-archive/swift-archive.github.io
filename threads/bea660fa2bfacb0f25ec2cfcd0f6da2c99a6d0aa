<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>March 14, 2016 at 02:00:00am</p></header><div class="content"><p>I&#39;m curious to see if anyone else has desire for this change.<br></p><p>Currently, scopes created by functions, closures, &quot;do {}&quot;, etc.<br>implicitly capture values from their outer scopes. The only way to opt out<br>this behavior is via functions defined &quot;elsewhere&quot;:<br></p><p>func a() { ... }<br>func foo(b: () -&gt; ()) {<br>    func c() { ... }<br>    let d = { ... }<br></p><p>    a() // nothing from foo&#39;s scope will implicitly get into a<br>    b() // nothing from foo&#39;s scope will implicitly get into b<br></p><p>    c() // implicitly captures values in foo<br>    d() // implicitly captures values in foo<br>    do {<br>        // implicitly captures values in foo<br>    }<br>}<br></p><p>One problem that comes with this bebavior is unintended capturing. E.g. a user<br>may think they successfuly factored out some code, but a missing variable was<br>satified by something with the same name from an outer scope.<br></p><p>C++ addresses this issue by making its user explicitly indicate lambda&#39;s<br>capturing behavior:<br></p><p>[] {...}  // capture nothing<br>[=] {...}  // capture everything by value<br>[&amp;] {...}  // capture everything by reference<br></p><p>It&#39;d be nice if Swift can allow user to opt out the automatic capturing at<br>some level. We already have the capture list syntax, reusing it for explictly<br>capture in this case:<br></p><p>func foo() {<br>    let a = 5<br>    let b = &quot;Ziggy&quot;<br>    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br></p><p>    let d: @explicit_capture () -&gt; () = { [a, b] in<br>        let years = a // ok<br>        let artist = b // ok<br>        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>    }<br>}<br></p><p><br>An alternative would be making implicit capture an opt-in feature (similar to<br>C++):<br></p><p>func foo() {<br>    let a = 5<br>    let b = &quot;Ziggy&quot;<br>    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br></p><p>    let d = { [a] in<br>        let years = a // ok<br>        let artist = b // error: implicit capture in not allowed for &#39;d&#39;<br>        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>    }<br></p><p>    let e: @capture_all () -&gt; () = { [a] in<br>        let years = a // ok<br>        let artist = b // ok<br>        let others = c // error: implicit capture in not allowed for &#39;e&#39;<br>    }<br>}<br></p><p>Obviously, this version would be a breaking change.<br></p><p>I have no attchment to the syntax. Chris has brought up moving @noescape<br>before variable types declaration, so putting @explicit_capture there seems<br>natural.<br></p><p>Thoughts?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 14, 2016 at 10:00:00am</p></header><div class="content"><p>I think I’m in favour of something along these lines, though personally I think the better solution is to simply eliminate implicit capture for closures and local functions, and instead provide a @capture attribute to re-enable current behaviour (and to avoid breaking code). This way developers are encouraged to either opt-in to the implicit capture behaviour, or declare a capture list, with the latter being preferred as it can more clearly declare what you need and in what capacity.<br></p><p>That said I think that do { … } blocks should retain implicit capture, as they’re really just a sub-section of your code, even if in some ways they can be thought of as a closure that automatically executes.<br></p><p>&gt; On 14 Mar 2016, at 02:12, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m curious to see if anyone else has desire for this change.<br>&gt; <br>&gt; Currently, scopes created by functions, closures, &quot;do {}&quot;, etc.<br>&gt; implicitly capture values from their outer scopes. The only way to opt out<br>&gt; this behavior is via functions defined &quot;elsewhere&quot;:<br>&gt; <br>&gt; func a() { ... }<br>&gt; func foo(b: () -&gt; ()) {<br>&gt;    func c() { ... }<br>&gt;    let d = { ... }<br>&gt; <br>&gt;    a() // nothing from foo&#39;s scope will implicitly get into a<br>&gt;    b() // nothing from foo&#39;s scope will implicitly get into b<br>&gt; <br>&gt;    c() // implicitly captures values in foo<br>&gt;    d() // implicitly captures values in foo<br>&gt;    do {<br>&gt;        // implicitly captures values in foo<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; One problem that comes with this bebavior is unintended capturing. E.g. a user<br>&gt; may think they successfuly factored out some code, but a missing variable was<br>&gt; satified by something with the same name from an outer scope.<br>&gt; <br>&gt; C++ addresses this issue by making its user explicitly indicate lambda&#39;s<br>&gt; capturing behavior:<br>&gt; <br>&gt; [] {...}  // capture nothing<br>&gt; [=] {...}  // capture everything by value<br>&gt; [&amp;] {...}  // capture everything by reference<br>&gt; <br>&gt; It&#39;d be nice if Swift can allow user to opt out the automatic capturing at<br>&gt; some level. We already have the capture list syntax, reusing it for explictly<br>&gt; capture in this case:<br>&gt; <br>&gt; func foo() {<br>&gt;    let a = 5<br>&gt;    let b = &quot;Ziggy&quot;<br>&gt;    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br>&gt; <br>&gt;    let d: @explicit_capture () -&gt; () = { [a, b] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // ok<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; An alternative would be making implicit capture an opt-in feature (similar to<br>&gt; C++):<br>&gt; <br>&gt; func foo() {<br>&gt;    let a = 5<br>&gt;    let b = &quot;Ziggy&quot;<br>&gt;    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br>&gt; <br>&gt;    let d = { [a] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;    }<br>&gt; <br>&gt;    let e: @capture_all () -&gt; () = { [a] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // ok<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;e&#39;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Obviously, this version would be a breaking change.<br>&gt; <br>&gt; I have no attchment to the syntax. Chris has brought up moving @noescape<br>&gt; before variable types declaration, so putting @explicit_capture there seems<br>&gt; natural.<br>&gt; <br>&gt; Thoughts?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>It&#39;s worth noting that—for better or for worse—explicit capture has different semantics from implicit capture today. If a local variable (&#39;var&#39;, not &#39;let&#39;) is captured, it is captured by value when mentioned explicitly and by reference when not. This is discussed in The Swift Programming Language &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544&gt;.<br></p><p>If you were to then propose a syntax of `inout x` or `&amp;x`, I would argue that there is no inout-ish behavior: updates to the variable both inside and outside the closure (a) are always reflected immediately (i.e. there is no writeback), and (b) are not subject to the aliasing restrictions that &#39;inout&#39; has. <br></p><p>(Not that I have an alternative spelling handy.)<br></p><p>Jordan<br></p><p><br>&gt; On Mar 13, 2016, at 19:12, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m curious to see if anyone else has desire for this change.<br>&gt; <br>&gt; Currently, scopes created by functions, closures, &quot;do {}&quot;, etc.<br>&gt; implicitly capture values from their outer scopes. The only way to opt out<br>&gt; this behavior is via functions defined &quot;elsewhere&quot;:<br>&gt; <br>&gt; func a() { ... }<br>&gt; func foo(b: () -&gt; ()) {<br>&gt;    func c() { ... }<br>&gt;    let d = { ... }<br>&gt; <br>&gt;    a() // nothing from foo&#39;s scope will implicitly get into a<br>&gt;    b() // nothing from foo&#39;s scope will implicitly get into b<br>&gt; <br>&gt;    c() // implicitly captures values in foo<br>&gt;    d() // implicitly captures values in foo<br>&gt;    do {<br>&gt;        // implicitly captures values in foo<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; One problem that comes with this bebavior is unintended capturing. E.g. a user<br>&gt; may think they successfuly factored out some code, but a missing variable was<br>&gt; satified by something with the same name from an outer scope.<br>&gt; <br>&gt; C++ addresses this issue by making its user explicitly indicate lambda&#39;s<br>&gt; capturing behavior:<br>&gt; <br>&gt; [] {...}  // capture nothing<br>&gt; [=] {...}  // capture everything by value<br>&gt; [&amp;] {...}  // capture everything by reference<br>&gt; <br>&gt; It&#39;d be nice if Swift can allow user to opt out the automatic capturing at<br>&gt; some level. We already have the capture list syntax, reusing it for explictly<br>&gt; capture in this case:<br>&gt; <br>&gt; func foo() {<br>&gt;    let a = 5<br>&gt;    let b = &quot;Ziggy&quot;<br>&gt;    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br>&gt; <br>&gt;    let d: @explicit_capture () -&gt; () = { [a, b] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // ok<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; An alternative would be making implicit capture an opt-in feature (similar to<br>&gt; C++):<br>&gt; <br>&gt; func foo() {<br>&gt;    let a = 5<br>&gt;    let b = &quot;Ziggy&quot;<br>&gt;    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br>&gt; <br>&gt;    let d = { [a] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;    }<br>&gt; <br>&gt;    let e: @capture_all () -&gt; () = { [a] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // ok<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;e&#39;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Obviously, this version would be a breaking change.<br>&gt; <br>&gt; I have no attchment to the syntax. Chris has brought up moving @noescape<br>&gt; before variable types declaration, so putting @explicit_capture there seems<br>&gt; natural.<br>&gt; <br>&gt; Thoughts?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/d0aa61c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 11:09 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s worth noting that—for better or for worse—explicit capture has different semantics from implicit capture today. If a local variable (&#39;var&#39;, not &#39;let&#39;) is captured, it is captured by value when mentioned explicitly and by reference when not. This is discussed in The Swift Programming Language &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544&gt;.<br>&gt; <br>&gt; If you were to then propose a syntax of `inout x` or `&amp;x`, I would argue that there is no inout-ish behavior: updates to the variable both inside and outside the closure (a) are always reflected immediately (i.e. there is no writeback), and (b) are not subject to the aliasing restrictions that &#39;inout&#39; has. <br>&gt; <br>&gt; (Not that I have an alternative spelling handy.)<br></p><p>`[var x]` seems to me like a reasonable spelling for explicit `var` capture.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 13, 2016, at 19:12, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m curious to see if anyone else has desire for this change.<br>&gt;&gt; <br>&gt;&gt; Currently, scopes created by functions, closures, &quot;do {}&quot;, etc.<br>&gt;&gt; implicitly capture values from their outer scopes. The only way to opt out<br>&gt;&gt; this behavior is via functions defined &quot;elsewhere&quot;:<br>&gt;&gt; <br>&gt;&gt; func a() { ... }<br>&gt;&gt; func foo(b: () -&gt; ()) {<br>&gt;&gt;    func c() { ... }<br>&gt;&gt;    let d = { ... }<br>&gt;&gt; <br>&gt;&gt;    a() // nothing from foo&#39;s scope will implicitly get into a<br>&gt;&gt;    b() // nothing from foo&#39;s scope will implicitly get into b<br>&gt;&gt; <br>&gt;&gt;    c() // implicitly captures values in foo<br>&gt;&gt;    d() // implicitly captures values in foo<br>&gt;&gt;    do {<br>&gt;&gt;        // implicitly captures values in foo<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One problem that comes with this bebavior is unintended capturing. E.g. a user<br>&gt;&gt; may think they successfuly factored out some code, but a missing variable was<br>&gt;&gt; satified by something with the same name from an outer scope.<br>&gt;&gt; <br>&gt;&gt; C++ addresses this issue by making its user explicitly indicate lambda&#39;s<br>&gt;&gt; capturing behavior:<br>&gt;&gt; <br>&gt;&gt; [] {...}  // capture nothing<br>&gt;&gt; [=] {...}  // capture everything by value<br>&gt;&gt; [&amp;] {...}  // capture everything by reference<br>&gt;&gt; <br>&gt;&gt; It&#39;d be nice if Swift can allow user to opt out the automatic capturing at<br>&gt;&gt; some level. We already have the capture list syntax, reusing it for explictly<br>&gt;&gt; capture in this case:<br>&gt;&gt; <br>&gt;&gt; func foo() {<br>&gt;&gt;    let a = 5<br>&gt;&gt;    let b = &quot;Ziggy&quot;<br>&gt;&gt;    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br>&gt;&gt; <br>&gt;&gt;    let d: @explicit_capture () -&gt; () = { [a, b] in<br>&gt;&gt;        let years = a // ok<br>&gt;&gt;        let artist = b // ok<br>&gt;&gt;        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; An alternative would be making implicit capture an opt-in feature (similar to<br>&gt;&gt; C++):<br>&gt;&gt; <br>&gt;&gt; func foo() {<br>&gt;&gt;    let a = 5<br>&gt;&gt;    let b = &quot;Ziggy&quot;<br>&gt;&gt;    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br>&gt;&gt; <br>&gt;&gt;    let d = { [a] in<br>&gt;&gt;        let years = a // ok<br>&gt;&gt;        let artist = b // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;&gt;        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    let e: @capture_all () -&gt; () = { [a] in<br>&gt;&gt;        let years = a // ok<br>&gt;&gt;        let artist = b // ok<br>&gt;&gt;        let others = c // error: implicit capture in not allowed for &#39;e&#39;<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Obviously, this version would be a breaking change.<br>&gt;&gt; <br>&gt;&gt; I have no attchment to the syntax. Chris has brought up moving @noescape<br>&gt;&gt; before variable types declaration, so putting @explicit_capture there seems<br>&gt;&gt; natural.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/2088623d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 11:11, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 16, 2016, at 11:09 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s worth noting that—for better or for worse—explicit capture has different semantics from implicit capture today. If a local variable (&#39;var&#39;, not &#39;let&#39;) is captured, it is captured by value when mentioned explicitly and by reference when not. This is discussed in The Swift Programming Language &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544&gt;.<br>&gt;&gt; <br>&gt;&gt; If you were to then propose a syntax of `inout x` or `&amp;x`, I would argue that there is no inout-ish behavior: updates to the variable both inside and outside the closure (a) are always reflected immediately (i.e. there is no writeback), and (b) are not subject to the aliasing restrictions that &#39;inout&#39; has. <br>&gt;&gt; <br>&gt;&gt; (Not that I have an alternative spelling handy.)<br>&gt; <br>&gt; `[var x]` seems to me like a reasonable spelling for explicit `var` capture.<br></p><p>I forgot to preempt that one too. :-) That would be somewhat at odds with the &quot;var x&quot; we left in switches, which is definitely an independent variable. (Especially if someone extends it to &quot;var x = y&quot;.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/a9b678ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 11:24 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 16, 2016, at 11:11, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 16, 2016, at 11:09 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s worth noting that—for better or for worse—explicit capture has different semantics from implicit capture today. If a local variable (&#39;var&#39;, not &#39;let&#39;) is captured, it is captured by value when mentioned explicitly and by reference when not. This is discussed in The Swift Programming Language &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you were to then propose a syntax of `inout x` or `&amp;x`, I would argue that there is no inout-ish behavior: updates to the variable both inside and outside the closure (a) are always reflected immediately (i.e. there is no writeback), and (b) are not subject to the aliasing restrictions that &#39;inout&#39; has. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Not that I have an alternative spelling handy.)<br>&gt;&gt; <br>&gt;&gt; `[var x]` seems to me like a reasonable spelling for explicit `var` capture.<br>&gt; <br>&gt; I forgot to preempt that one too. :-) That would be somewhat at odds with the &quot;var x&quot; we left in switches, which is definitely an independent variable. (Especially if someone extends it to &quot;var x = y&quot;.)<br></p><p>OTOH it does more or less exactly what it says, capturing the `var` x rather than only the current value of x. It also makes some sense with the new restriction on capturing `inout` parameters—you can&#39;t capture an `inout x` using `var x` since you don&#39;t get to see the `var` through the inout abstraction. As far as `[var x = y]` is concerned, we could just say that&#39;s not allowed.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/49e537e0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 16, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 16 Mar 2016, at 18:24, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 16, 2016, at 11:11, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 16, 2016, at 11:09 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s worth noting that—for better or for worse—explicit capture has different semantics from implicit capture today. If a local variable (&#39;var&#39;, not &#39;let&#39;) is captured, it is captured by value when mentioned explicitly and by reference when not. This is discussed in The Swift Programming Language &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you were to then propose a syntax of `inout x` or `&amp;x`, I would argue that there is no inout-ish behavior: updates to the variable both inside and outside the closure (a) are always reflected immediately (i.e. there is no writeback), and (b) are not subject to the aliasing restrictions that &#39;inout&#39; has. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Not that I have an alternative spelling handy.)<br>&gt;&gt; <br>&gt;&gt; `[var x]` seems to me like a reasonable spelling for explicit `var` capture.<br>&gt; <br>&gt; I forgot to preempt that one too. :-) That would be somewhat at odds with the &quot;var x&quot; we left in switches, which is definitely an independent variable. (Especially if someone extends it to &quot;var x = y&quot;.)<br></p><p>What about “capture” as the keyword? This will require a new name for capture lists, but it seems like it isn’t well named at the moment anyway if it’s effectively copying values right now.<br></p><p>I’m also curious about thoughts regarding making implicit capture opt-in by default, vs the original proposals opt-out solution. Obviously this will require a good solution to the capture lists to replace the functionality and/or an attribute to opt-in to the current implicit behaviour, but I think it’s safer for it to be opt-in rather than the default.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/06edcc18/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 12:30 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 16 Mar 2016, at 18:24, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 16, 2016, at 11:11, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 16, 2016, at 11:09 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s worth noting that—for better or for worse—explicit capture has different semantics from implicit capture today. If a local variable (&#39;var&#39;, not &#39;let&#39;) is captured, it is captured by value when mentioned explicitly and by reference when not. This is discussed in The Swift Programming Language &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you were to then propose a syntax of `inout x` or `&amp;x`, I would argue that there is no inout-ish behavior: updates to the variable both inside and outside the closure (a) are always reflected immediately (i.e. there is no writeback), and (b) are not subject to the aliasing restrictions that &#39;inout&#39; has. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Not that I have an alternative spelling handy.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `[var x]` seems to me like a reasonable spelling for explicit `var` capture.<br>&gt;&gt; <br>&gt;&gt; I forgot to preempt that one too. :-) That would be somewhat at odds with the &quot;var x&quot; we left in switches, which is definitely an independent variable. (Especially if someone extends it to &quot;var x = y&quot;.)<br>&gt; <br>&gt; What about “capture” as the keyword? This will require a new name for capture lists, but it seems like it isn’t well named at the moment anyway if it’s effectively copying values right now.<br>&gt; <br>&gt; I’m also curious about thoughts regarding making implicit capture opt-in by default, vs the original proposals opt-out solution. Obviously this will require a good solution to the capture lists to replace the functionality and/or an attribute to opt-in to the current implicit behaviour, but I think it’s safer for it to be opt-in rather than the default.<br></p><p>I suspect that by far the most common use for capture lists is to declare [(weak|unowned) self]. I don&#39;t think we want to punish that use case.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/9e17a220/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 16, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 16 Mar 2016, at 19:37, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; What about “capture” as the keyword? This will require a new name for capture lists, but it seems like it isn’t well named at the moment anyway if it’s effectively copying values right now.<br>&gt;&gt; <br>&gt;&gt; I’m also curious about thoughts regarding making implicit capture opt-in by default, vs the original proposals opt-out solution. Obviously this will require a good solution to the capture lists to replace the functionality and/or an attribute to opt-in to the current implicit behaviour, but I think it’s safer for it to be opt-in rather than the default.<br>&gt; <br>&gt; I suspect that by far the most common use for capture lists is to declare [(weak|unowned) self]. I don&#39;t think we want to punish that use case.<br></p><p><br>capture could remain implicit for weak/unowned. Actually anything else for weak/owned may actually be meaningless (if you create a weak reference to a new copy of a value type then it’s just going to be nil I think, I could be mistaken).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/476704dd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Limit Implicit Capture</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 13, 2016, at 7:12 PM, Daniel Duan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m curious to see if anyone else has desire for this change.<br>&gt; <br>&gt; Currently, scopes created by functions, closures, &quot;do {}&quot;, etc.<br>&gt; implicitly capture values from their outer scopes. The only way to opt out<br>&gt; this behavior is via functions defined &quot;elsewhere&quot;:<br>&gt; <br>&gt; func a() { ... }<br>&gt; func foo(b: () -&gt; ()) {<br>&gt;    func c() { ... }<br>&gt;    let d = { ... }<br>&gt; <br>&gt;    a() // nothing from foo&#39;s scope will implicitly get into a<br>&gt;    b() // nothing from foo&#39;s scope will implicitly get into b<br>&gt; <br>&gt;    c() // implicitly captures values in foo<br>&gt;    d() // implicitly captures values in foo<br>&gt;    do {<br>&gt;        // implicitly captures values in foo<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; One problem that comes with this bebavior is unintended capturing. E.g. a user<br>&gt; may think they successfuly factored out some code, but a missing variable was<br>&gt; satified by something with the same name from an outer scope.<br>&gt; <br>&gt; C++ addresses this issue by making its user explicitly indicate lambda&#39;s<br>&gt; capturing behavior:<br>&gt; <br>&gt; [] {...}  // capture nothing<br>&gt; [=] {...}  // capture everything by value<br>&gt; [&amp;] {...}  // capture everything by reference<br>&gt; <br>&gt; It&#39;d be nice if Swift can allow user to opt out the automatic capturing at<br>&gt; some level. We already have the capture list syntax, reusing it for explictly<br>&gt; capture in this case:<br>&gt; <br>&gt; func foo() {<br>&gt;    let a = 5<br>&gt;    let b = &quot;Ziggy&quot;<br>&gt;    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br>&gt; <br>&gt;    let d: @explicit_capture () -&gt; () = { [a, b] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // ok<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; An alternative would be making implicit capture an opt-in feature (similar to<br>&gt; C++):<br>&gt; <br>&gt; func foo() {<br>&gt;    let a = 5<br>&gt;    let b = &quot;Ziggy&quot;<br>&gt;    let c = [&quot;Weild&quot;, &quot;Gilly&quot;]<br>&gt; <br>&gt;    let d = { [a] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;d&#39;<br>&gt;    }<br>&gt; <br>&gt;    let e: @capture_all () -&gt; () = { [a] in<br>&gt;        let years = a // ok<br>&gt;        let artist = b // ok<br>&gt;        let others = c // error: implicit capture in not allowed for &#39;e&#39;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Obviously, this version would be a breaking change.<br>&gt; <br>&gt; I have no attchment to the syntax. Chris has brought up moving @noescape<br>&gt; before variable types declaration, so putting @explicit_capture there seems<br>&gt; natural.<br>&gt; <br>&gt; Thoughts?<br></p><p>I like the idea, but this seems to me like more a property of the closure literal than the function type, so the annotation belongs in the capture list. {[only a, b] in a + b } maybe (filling in your own preferred syntax for &#39;only&#39;).<br></p><p>-Joe<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
