<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>João Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>July 26, 2016 at 09:00:00pm</p></header><div class="content"><p>This proposal [gist &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800&gt;] is the result of the discussions from the thread &quot;Prohibit invisible characters in identifier names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;&quot;. I hope it&#39;s still on time for inclusion in Swift 3.<br></p><p>Sincerely,<br>João Pinheiro<br></p><p><br>Normalize Unicode Identifiers<br></p><p>Proposal: SE-NNNN &lt;https://gist.github.com/JoaoPinheiro/NNNN-normalize-identifiers.md&gt;<br>Author: João Pinheiro &lt;https://github.com/joaopinheiro&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#introduction&gt;Introduction<br></p><p>This proposal aims to introduce identifier normalization in order to prevent the unsafe and potentially abusive use of invisible or equivalent representations of Unicode characters in identifiers.<br></p><p>Swift-evolution thread: Discussion thread &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;<br> &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#motivation&gt;Motivation<br></p><p>Even though Swift supports the use of Unicode for identifiers, these aren&#39;t yet normalized. This allows for different Unicode representations of the same characters to be considered distinct identifiers.<br></p><p>For example:<br></p><p>let Å = &quot;Angstrom&quot;<br>let Å = &quot;Latin Capital Letter A With Ring Above&quot;<br>let Å = &quot;Latin Capital Letter A + Combining Ring Above&quot;<br>In addition to that, default-ignorable characters like the Zero Width Space and Zero Width Non-Joiner (exemplified below) are also currently accepted as valid parts of identifiers without any restrictions.<br></p><p>let ab = &quot;ab&quot;<br>let a​b = &quot;a + Zero Width Space + b&quot;<br></p><p>func xy() { print(&quot;xy&quot;) }<br>func x‌y() { print(&quot;x + &lt;Zero Width Non-Joiner&gt; + y&quot;) }<br>The use of default-ignorable characters in identifiers is problematical, first because the effects they represent are stylistic or otherwise out of scope for identifiers, and second because the characters themselves often have no visible display. It is also possible to misapply these characters such that users can create strings that look the same but actually contain different characters, which can create security problems.<br></p><p> &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#proposed-solution&gt;Proposed solution<br></p><p>Normalize Swift identifiers according to the normalization form NFC recommended for case-sensitive languages in the Unicode Standard Annexes 15 &lt;https://gist.github.com/JoaoPinheiro/UAX15&gt; and 31 &lt;https://gist.github.com/JoaoPinheiro/UAX31&gt; and follow the Normalization Charts &lt;https://gist.github.com/JoaoPinheiro/NormalizationCharts&gt;.<br></p><p>In addition to that, prohibit the use of default-ignorable characters in identifiers except in the special cases described in UAX31 &lt;https://gist.github.com/JoaoPinheiro/UAX31&gt;, listed below:<br></p><p>Allow Zero Width Non-Joiner (U+200C) when breaking a cursive connection<br>Allow Zero Width Non-Joiner (U+200C) in a conjunct context<br>Allow Zero Width Joiner (U+200D) in a conjunct context<br> &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#impact-on-existing-code&gt;Impact on existing code<br></p><p>This has potential to be a code-breaking change in cases where people may have used distinct, but identical looking, identifiers with different Unicode representations. The likelihood of that happening in actual code is very small and the problem can be solved by renaming identifiers that don&#39;t conform to the new normalized form into new non-colliding identifiers.<br></p><p> &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#alternatives-considered&gt;Alternatives considered<br></p><p>The option of ignoring default-ignorable characters in identifiers was also discussed, but it was considered to be more confusing and less secure than explicitly treating them as errors.<br></p><p> &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#unaddressed-issues&gt;Unaddressed Issues<br></p><p>There was some discussion around the issue of Unicode confusable characters, but it was considered to be out of scope for this proposal. Unicode confusable characters are a complicated issue and any possible solutions also come with significant drawbacks that would require more time and consideration.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/e4564531/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 26, 2016 at 02:00:00pm</p></header><div class="content"><p>+1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s highly<br>unlikely to be code-breaking in practice. Any existing code that would get<br>tripped up by this normalization is arguably broken already.<br></p><p><br>On Tue, Jul 26, 2016 at 2:22 PM, João Pinheiro &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; This proposal [gist<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800&gt;]<br>&gt; is the result of the discussions from the thread &quot;Prohibit invisible<br>&gt; characters in identifier names<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;&quot;. I hope<br>&gt; it&#39;s still on time for inclusion in Swift 3.<br>&gt;<br>&gt; Sincerely,<br>&gt; João Pinheiro<br>&gt;<br>&gt;<br>&gt; Normalize Unicode Identifiers<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://gist.github.com/JoaoPinheiro/NNNN-normalize-identifiers.md&gt;<br>&gt;    - Author: João Pinheiro &lt;https://github.com/joaopinheiro&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal aims to introduce identifier normalization in order to<br>&gt; prevent the unsafe and potentially abusive use of invisible or equivalent<br>&gt; representations of Unicode characters in identifiers.<br>&gt;<br>&gt; Swift-evolution thread: Discussion thread<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Even though Swift supports the use of Unicode for identifiers, these<br>&gt; aren&#39;t yet normalized. This allows for different Unicode representations of<br>&gt; the same characters to be considered distinct identifiers.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; let Å = &quot;Angstrom&quot;<br>&gt; let Å = &quot;Latin Capital Letter A With Ring Above&quot;<br>&gt; let Å = &quot;Latin Capital Letter A + Combining Ring Above&quot;<br>&gt;<br>&gt; In addition to that, *default-ignorable* characters like the *Zero Width<br>&gt; Space* and *Zero Width Non-Joiner* (exemplified below) are also currently<br>&gt; accepted as valid parts of identifiers without any restrictions.<br>&gt;<br>&gt; let ab = &quot;ab&quot;<br>&gt; let a​b = &quot;a + Zero Width Space + b&quot;<br>&gt;<br>&gt; func xy() { print(&quot;xy&quot;) }<br>&gt; func x‌y() { print(&quot;x + &lt;Zero Width Non-Joiner&gt; + y&quot;) }<br>&gt;<br>&gt; The use of default-ignorable characters in identifiers is problematical,<br>&gt; first because the effects they represent are stylistic or otherwise out of<br>&gt; scope for identifiers, and second because the characters themselves often<br>&gt; have no visible display. It is also possible to misapply these characters<br>&gt; such that users can create strings that look the same but actually contain<br>&gt; different characters, which can create security problems.<br>&gt;<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; Normalize Swift identifiers according to the normalization form NFC<br>&gt; recommended for case-sensitive languages in the Unicode Standard Annexes<br>&gt; 15 &lt;https://gist.github.com/JoaoPinheiro/UAX15&gt; and 31<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/UAX31&gt; and follow the Normalization<br>&gt; Charts &lt;https://gist.github.com/JoaoPinheiro/NormalizationCharts&gt;.<br>&gt;<br>&gt; In addition to that, prohibit the use of *default-ignorable* characters<br>&gt; in identifiers except in the special cases described in UAX31<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/UAX31&gt;, listed below:<br>&gt;<br>&gt;    - Allow Zero Width Non-Joiner (U+200C) when breaking a cursive<br>&gt;    connection<br>&gt;    - Allow Zero Width Non-Joiner (U+200C) in a conjunct context<br>&gt;    - Allow Zero Width Joiner (U+200D) in a conjunct context<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; This has potential to be a code-breaking change in cases where people may<br>&gt; have used distinct, but identical looking, identifiers with different<br>&gt; Unicode representations. The likelihood of that happening in actual code is<br>&gt; very small and the problem can be solved by renaming identifiers that don&#39;t<br>&gt; conform to the new normalized form into new non-colliding identifiers.<br>&gt;<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The option of ignoring *default-ignorable* characters in identifiers was<br>&gt; also discussed, but it was considered to be more confusing and less secure<br>&gt; than explicitly treating them as errors.<br>&gt;<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800#unaddressed-issues&gt;Unaddressed<br>&gt; Issues<br>&gt; There was some discussion around the issue of Unicode confusable<br>&gt; characters, but it was considered to be out of scope for this proposal.<br>&gt; Unicode confusable characters are a complicated issue and any possible<br>&gt; solutions also come with significant drawbacks that would require more time<br>&gt; and consideration.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/3241c23c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s highly unlikely to be code-breaking in practice. Any existing code that would get tripped up by this normalization is arguably broken already.<br></p><p>I&#39;m inclined to agree. To be paranoid about perfect compatibility, we could conceivably allow existing code with differently-normalized identifiers with a warning based on Swift version, but it&#39;s probably not worth it. It&#39;d be interesting to data-mine Github or the iOS Swift Playgrounds app and see if this breaks any Swift 3 code in practice.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>September 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s highly unlikely to be code-breaking in practice. Any existing code that would get tripped up by this normalization is arguably broken already.<br>&gt; <br>&gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we could conceivably allow existing code with differently-normalized identifiers with a warning based on Swift version, but it&#39;s probably not worth it. It&#39;d be interesting to data-mine Github or the iOS Swift Playgrounds app and see if this breaks any Swift 3 code in practice.<br></p><p>As an additional interesting point here, we could in general normalize unicode strings. This could potentially reduce the size of unicode characters or allow us to constant propagate certain unicode algorithms in the optimizer.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 22, 2016 at 06:00:00pm</p></header><div class="content"><p>You mean values of type String? I would want those to be exactly what I say<br>they are; NFC normalization is available, if I recall, as part of<br>Foundation, but by no means should my String values be silently changed!<br></p><p><br>On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s<br>&gt; highly unlikely to be code-breaking in practice. Any existing code that<br>&gt; would get tripped up by this normalization is arguably broken already.<br>&gt; &gt;<br>&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we<br>&gt; could conceivably allow existing code with differently-normalized<br>&gt; identifiers with a warning based on Swift version, but it&#39;s probably not<br>&gt; worth it. It&#39;d be interesting to data-mine Github or the iOS Swift<br>&gt; Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt;<br>&gt; As an additional interesting point here, we could in general normalize<br>&gt; unicode strings. This could potentially reduce the size of unicode<br>&gt; characters or allow us to constant propagate certain unicode algorithms in<br>&gt; the optimizer.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/80e16544/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>September 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Sep 22, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; You mean values of type String?<br></p><p>I was speaking solely of constant strings.<br></p><p>&gt; I would want those to be exactly what I say they are; NFC normalization is available, if I recall, as part of Foundation, but by no means should my String values be silently changed!<br></p><p>Why.<br></p><p>&gt; <br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s highly unlikely to be code-breaking in practice. Any existing code that would get tripped up by this normalization is arguably broken already.<br>&gt; &gt;<br>&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we could conceivably allow existing code with differently-normalized identifiers with a warning based on Swift version, but it&#39;s probably not worth it. It&#39;d be interesting to data-mine Github or the iOS Swift Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt; <br>&gt; As an additional interesting point here, we could in general normalize unicode strings. This could potentially reduce the size of unicode characters or allow us to constant propagate certain unicode algorithms in the optimizer.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/9ea301f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September 22, 2016 at 11:00:00pm</p></header><div class="content"><p>This point seems moot to me because String&#39;s == checks for *canonical<br>equivalence* anyway.<br>On Thu, Sep 22, 2016 at 4:54 PM Michael Gottesman via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Sep 22, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; You mean values of type String?<br>&gt;<br>&gt;<br>&gt; I was speaking solely of constant strings.<br>&gt;<br>&gt; I would want those to be exactly what I say they are; NFC normalization is<br>&gt; available, if I recall, as part of Foundation, but by no means should my<br>&gt; String values be silently changed!<br>&gt;<br>&gt;<br>&gt; Why.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s<br>&gt;&gt; highly unlikely to be code-breaking in practice. Any existing code that<br>&gt;&gt; would get tripped up by this normalization is arguably broken already.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we<br>&gt;&gt; could conceivably allow existing code with differently-normalized<br>&gt;&gt; identifiers with a warning based on Swift version, but it&#39;s probably not<br>&gt;&gt; worth it. It&#39;d be interesting to data-mine Github or the iOS Swift<br>&gt;&gt; Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt;&gt;<br>&gt;&gt; As an additional interesting point here, we could in general normalize<br>&gt;&gt; unicode strings. This could potentially reduce the size of unicode<br>&gt;&gt; characters or allow us to constant propagate certain unicode algorithms in<br>&gt;&gt; the optimizer.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/f93ca4a9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 22, 2016 at 07:00:00pm</p></header><div class="content"><p>On Thu, Sep 22, 2016 at 6:54 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Sep 22, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; You mean values of type String?<br>&gt;<br>&gt;<br>&gt; I was speaking solely of constant strings.<br>&gt;<br>&gt; I would want those to be exactly what I say they are; NFC normalization is<br>&gt; available, if I recall, as part of Foundation, but by no means should my<br>&gt; String values be silently changed!<br>&gt;<br>&gt;<br>&gt; Why.<br>&gt;<br></p><p>For one, I don&#39;t want to pay the computational cost of normalization at<br>runtime unless necessary. For another, I expect to be able to round-trip<br>user input. Normalization is not lossless and cannot be reversed. Finally,<br>if I want to use normalization form D (NFD), your proposal would make it<br>impossible, because (IIUC) serial NFC + NFD normalization can produce<br>different output than NFD normalization alone.<br></p><p>On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s<br>&gt;&gt; highly unlikely to be code-breaking in practice. Any existing code that<br>&gt;&gt; would get tripped up by this normalization is arguably broken already.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we<br>&gt;&gt; could conceivably allow existing code with differently-normalized<br>&gt;&gt; identifiers with a warning based on Swift version, but it&#39;s probably not<br>&gt;&gt; worth it. It&#39;d be interesting to data-mine Github or the iOS Swift<br>&gt;&gt; Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt;&gt;<br>&gt;&gt; As an additional interesting point here, we could in general normalize<br>&gt;&gt; unicode strings. This could potentially reduce the size of unicode<br>&gt;&gt; characters or allow us to constant propagate certain unicode algorithms in<br>&gt;&gt; the optimizer.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/89a71bf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>September 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Sep 22, 2016, at 5:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 6:54 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 22, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; You mean values of type String?<br>&gt; <br>&gt; I was speaking solely of constant strings.<br>&gt; <br>&gt;&gt; I would want those to be exactly what I say they are; NFC normalization is available, if I recall, as part of Foundation, but by no means should my String values be silently changed!<br>&gt; <br>&gt; Why.<br>&gt; <br>&gt; For one, I don&#39;t want to pay the computational cost of normalization at runtime unless necessary.<br></p><p>This would only happen with strings that are known to be constant at compile time (and as such the transformation would occur at compile time). There would be no runtime cost.<br></p><p>&gt; For another, I expect to be able to round-trip user input.<br></p><p>String checks for canonical equivalence, IIRC.<br></p><p>&gt; Normalization is not lossless and cannot be reversed. Finally, if I want to use normalization form D (NFD), your proposal<br>&gt; would make it impossible, because (IIUC) serial NFC + NFD normalization can produce different output than NFD normalization alone.<br></p><p>Why would you want to do this/care about this? I.e. what is the use case?<br></p><p>As an aside, I am not formally proposing this. I am just discussing potential opportunities for optimization given that we would need (as apart of this proposal) to add knowledge of unicode to the compiler which would allow for compile time transformations.<br></p><p>&gt; <br>&gt;&gt; On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s highly unlikely to be code-breaking in practice. Any existing code that would get tripped up by this normalization is arguably broken already.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we could conceivably allow existing code with differently-normalized identifiers with a warning based on Swift version, but it&#39;s probably not worth it. It&#39;d be interesting to data-mine Github or the iOS Swift Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt;&gt; <br>&gt;&gt; As an additional interesting point here, we could in general normalize unicode strings. This could potentially reduce the size of unicode characters or allow us to constant propagate certain unicode algorithms in the optimizer.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/53a77dba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Thu, Sep 22, 2016 at 7:44 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Sep 22, 2016, at 5:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Thu, Sep 22, 2016 at 6:54 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 22, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; You mean values of type String?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I was speaking solely of constant strings.<br>&gt;&gt;<br>&gt;&gt; I would want those to be exactly what I say they are; NFC normalization<br>&gt;&gt; is available, if I recall, as part of Foundation, but by no means should my<br>&gt;&gt; String values be silently changed!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why.<br>&gt;&gt;<br>&gt;<br>&gt; For one, I don&#39;t want to pay the computational cost of normalization at<br>&gt; runtime unless necessary.<br>&gt;<br>&gt;<br>&gt; This would only happen with strings that are known to be constant at<br>&gt; compile time (and as such the transformation would occur at compile time).<br>&gt; There would be no runtime cost.<br>&gt;<br></p><p>Yes, for constant strings only there would be no runtime cost.<br></p><p><br>&gt;<br>&gt; For another, I expect to be able to round-trip user input.<br>&gt;<br>&gt;<br>&gt; String checks for canonical equivalence, IIRC.<br>&gt;<br></p><p>Sure, but I&#39;m not talking about using comparison operators here. I mean<br>that if we have `let str = &quot;[some non-NFC string]&quot;`, I should be able to<br>write that out to a file with all the non-canonical glyphs intact.<br></p><p>There are known issues with NFC that are acceptable for normalizing Swift<br>identifiers but make it unsuitable for general use. For example, the<br>normalized form of Greek ano teleia is middle dot, but these two glyphs are<br>rendered differently in many fonts, and substituting a middle dot in place<br>of the Greek punctuation mark is actually quite inadequate for Greek text<br>(ano teleia is supposed to be around x-height; middle dot is not). Even for<br>constant strings, it is essential that one can output ano teleia when it is<br>specified rather than middle dot. However, Unicode normalization algorithms<br>guarantee stability and will forever require swapping the former for the<br>latter. I understand that other such problematic characters exist.<br></p><p>Normalization is not lossless and cannot be reversed. Finally, if I want to<br>&gt; use normalization form D (NFD), your proposal<br>&gt;<br>&gt; would make it impossible, because (IIUC) serial NFC + NFD normalization<br>&gt; can produce different output than NFD normalization alone.<br>&gt;<br>&gt;<br>&gt; Why would you want to do this/care about this? I.e. what is the use case?<br>&gt;<br></p><p>Use cases for NFD include searching, where you&#39;d find substrings considered<br>&quot;compatible.&quot; For instance, the ﬁ ligature is considered compatible with<br>the letters f and i, but they are not equal. If you&#39;ve ever successfully<br>searched for a word like &quot;finance&quot; in a PDF document that&#39;s been typeset<br>with ligatures, you&#39;ve benefited from NFD. Roughly speaking (IIUC), the<br>difference between searching NFC-normalized strings and NFD-normalized<br>strings is analogous to the difference between a case-sensitive and a<br>case-insensitive search. Therefore, given a string x, it&#39;s sometimes<br>important to be able to obtain NFD(x). If every string x is now<br>automatically NFC(x), then the best one can do is NFD(NFC(x)), which is not<br>guaranteed equal to NFD(x) even with canonical comparison (i.e.<br>NFC(NFD(NFC(x))) != NFC(NFD(x)) for all x).<br></p><p><br>&gt; As an aside, I am not formally proposing this. I am just discussing<br>&gt; potential opportunities for optimization given that we would need (as apart<br>&gt; of this proposal) to add knowledge of unicode to the compiler which would<br>&gt; allow for compile time transformations.<br>&gt;<br></p><p>I&#39;d be interested to know what performance gains you&#39;re envisioning with<br>such an optimization of constant strings at compile time.<br></p><p>On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s<br>&gt;&gt;&gt; highly unlikely to be code-breaking in practice. Any existing code that<br>&gt;&gt;&gt; would get tripped up by this normalization is arguably broken already.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we<br>&gt;&gt;&gt; could conceivably allow existing code with differently-normalized<br>&gt;&gt;&gt; identifiers with a warning based on Swift version, but it&#39;s probably not<br>&gt;&gt;&gt; worth it. It&#39;d be interesting to data-mine Github or the iOS Swift<br>&gt;&gt;&gt; Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As an additional interesting point here, we could in general normalize<br>&gt;&gt;&gt; unicode strings. This could potentially reduce the size of unicode<br>&gt;&gt;&gt; characters or allow us to constant propagate certain unicode algorithms in<br>&gt;&gt;&gt; the optimizer.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/7d2e91d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>September 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Sep 22, 2016, at 6:11 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 7:44 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 22, 2016, at 5:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Sep 22, 2016 at 6:54 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 22, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You mean values of type String?<br>&gt;&gt; <br>&gt;&gt; I was speaking solely of constant strings.<br>&gt;&gt; <br>&gt;&gt;&gt; I would want those to be exactly what I say they are; NFC normalization is available, if I recall, as part of Foundation, but by no means should my String values be silently changed!<br>&gt;&gt; <br>&gt;&gt; Why.<br>&gt;&gt; <br>&gt;&gt; For one, I don&#39;t want to pay the computational cost of normalization at runtime unless necessary.<br>&gt; <br>&gt; This would only happen with strings that are known to be constant at compile time (and as such the transformation would occur at compile time). There would be no runtime cost.<br>&gt; <br>&gt; Yes, for constant strings only there would be no runtime cost.<br>&gt;  <br>&gt; <br>&gt;&gt; For another, I expect to be able to round-trip user input. <br>&gt; <br>&gt; String checks for canonical equivalence, IIRC.<br>&gt; <br>&gt; Sure, but I&#39;m not talking about using comparison operators here. I mean that if we have `let str = &quot;[some non-NFC string]&quot;`, I should be able to write that out to a file with all the non-canonical glyphs intact.<br></p><p>I would argue that most people that is not an interesting distinction. Naturally there would be a way to escape such canonicalization to get the non-canonicalized String.<br></p><p>&gt; <br>&gt; There are known issues with NFC that are acceptable for normalizing Swift identifiers but make it unsuitable for general use. For example, the normalized form of Greek ano teleia is middle dot, but these two glyphs are rendered differently in many fonts, and substituting a middle dot in place of the Greek punctuation mark is actually quite inadequate for Greek text (ano teleia is supposed to be around x-height; middle dot is not). Even for constant strings, it is essential that one can output ano teleia when it is specified rather than middle dot. However, Unicode normalization algorithms guarantee stability and will forever require swapping the former for the latter. I understand that other such problematic characters exist.<br></p><p>I would argue that that is a problem with the unicode standard and with the fonts. This is not a problem for Swift to solve.<br></p><p>&gt; <br>&gt;&gt; Normalization is not lossless and cannot be reversed. Finally, if I want to use normalization form D (NFD), your proposal<br>&gt;&gt; would make it impossible, because (IIUC) serial NFC + NFD normalization can produce different output than NFD normalization alone.<br>&gt; <br>&gt; Why would you want to do this/care about this? I.e. what is the use case?<br>&gt; <br>&gt; Use cases for NFD include searching, where you&#39;d find substrings considered &quot;compatible.&quot; For instance, the ﬁ ligature is considered compatible with the letters f and i, but they are not equal. If you&#39;ve ever successfully searched for a word like &quot;finance&quot; in a PDF document that&#39;s been typeset with ligatures, you&#39;ve benefited from NFD. Roughly speaking (IIUC), the difference between searching NFC-normalized strings and NFD-normalized strings is analogous to the difference between a case-sensitive and a case-insensitive search. Therefore, given a string x, it&#39;s sometimes important to be able to obtain NFD(x). If every string x is now automatically NFC(x), then the best one can do is NFD(NFC(x)), which is not guaranteed equal to NFD(x) even with canonical comparison (i.e. NFC(NFD(NFC(x))) != NFC(NFD(x)) for all x).<br></p><p>There are issues here related to String design. For instance, one could make an argument that such searching is really only interesting for a &quot;Text&quot; use case which is different from a String use case. That being said, I don&#39;t want to argue about this here since we are hijacking this thread ; ).<br></p><p>&gt;  <br>&gt; As an aside, I am not formally proposing this. I am just discussing potential opportunities for optimization given that we would need (as apart of this proposal) to add knowledge of unicode to the compiler which would allow for compile time transformations.<br>&gt; <br>&gt; I&#39;d be interested to know what performance gains you&#39;re envisioning with such an optimization of constant strings at compile time.<br></p><p>I would have to measure such wins to say anything concrete. Algorithmically one would be able to avoid normalization during common unicode operations when you know you are using constant strings. Even though this may provide a runtime win, the major win from teaching the compiler about unicode would be in terms of applying unicode operations such as encoding/decoding to constant strings.<br></p><p>That being said, this is not the proposal that is being discussed here or even being proposed here. [i.e. lets stop hijacking this thread ; )]<br></p><p>&gt; <br>&gt;&gt;&gt; On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s highly unlikely to be code-breaking in practice. Any existing code that would get tripped up by this normalization is arguably broken already.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we could conceivably allow existing code with differently-normalized identifiers with a warning based on Swift version, but it&#39;s probably not worth it. It&#39;d be interesting to data-mine Github or the iOS Swift Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As an additional interesting point here, we could in general normalize unicode strings. This could potentially reduce the size of unicode characters or allow us to constant propagate certain unicode algorithms in the optimizer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/eafb3f5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 22, 2016 at 09:00:00pm</p></header><div class="content"><p>Agreed. Taking this offlist :)<br></p><p><br>On Thu, Sep 22, 2016 at 9:01 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Sep 22, 2016, at 6:11 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Thu, Sep 22, 2016 at 7:44 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 22, 2016, at 5:09 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Sep 22, 2016 at 6:54 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>&gt;&gt;  wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sep 22, 2016, at 4:19 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You mean values of type String?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was speaking solely of constant strings.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would want those to be exactly what I say they are; NFC normalization<br>&gt;&gt;&gt; is available, if I recall, as part of Foundation, but by no means should my<br>&gt;&gt;&gt; String values be silently changed!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For one, I don&#39;t want to pay the computational cost of normalization at<br>&gt;&gt; runtime unless necessary.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This would only happen with strings that are known to be constant at<br>&gt;&gt; compile time (and as such the transformation would occur at compile time).<br>&gt;&gt; There would be no runtime cost.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, for constant strings only there would be no runtime cost.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; For another, I expect to be able to round-trip user input.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; String checks for canonical equivalence, IIRC.<br>&gt;&gt;<br>&gt;<br>&gt; Sure, but I&#39;m not talking about using comparison operators here. I mean<br>&gt; that if we have `let str = &quot;[some non-NFC string]&quot;`, I should be able to<br>&gt; write that out to a file with all the non-canonical glyphs intact.<br>&gt;<br>&gt;<br>&gt; I would argue that most people that is not an interesting distinction.<br>&gt; Naturally there would be a way to escape such canonicalization to get the<br>&gt; non-canonicalized String.<br>&gt;<br>&gt;<br>&gt; There are known issues with NFC that are acceptable for normalizing Swift<br>&gt; identifiers but make it unsuitable for general use. For example, the<br>&gt; normalized form of Greek ano teleia is middle dot, but these two glyphs are<br>&gt; rendered differently in many fonts, and substituting a middle dot in place<br>&gt; of the Greek punctuation mark is actually quite inadequate for Greek text<br>&gt; (ano teleia is supposed to be around x-height; middle dot is not). Even for<br>&gt; constant strings, it is essential that one can output ano teleia when it is<br>&gt; specified rather than middle dot. However, Unicode normalization algorithms<br>&gt; guarantee stability and will forever require swapping the former for the<br>&gt; latter. I understand that other such problematic characters exist.<br>&gt;<br>&gt;<br>&gt; I would argue that that is a problem with the unicode standard and with<br>&gt; the fonts. This is not a problem for Swift to solve.<br>&gt;<br>&gt;<br>&gt; Normalization is not lossless and cannot be reversed. Finally, if I want<br>&gt;&gt; to use normalization form D (NFD), your proposal<br>&gt;&gt;<br>&gt;&gt; would make it impossible, because (IIUC) serial NFC + NFD normalization<br>&gt;&gt; can produce different output than NFD normalization alone.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why would you want to do this/care about this? I.e. what is the use case?<br>&gt;&gt;<br>&gt;<br>&gt; Use cases for NFD include searching, where you&#39;d find substrings<br>&gt; considered &quot;compatible.&quot; For instance, the ﬁ ligature is considered<br>&gt; compatible with the letters f and i, but they are not equal. If you&#39;ve ever<br>&gt; successfully searched for a word like &quot;finance&quot; in a PDF document that&#39;s<br>&gt; been typeset with ligatures, you&#39;ve benefited from NFD. Roughly speaking<br>&gt; (IIUC), the difference between searching NFC-normalized strings and<br>&gt; NFD-normalized strings is analogous to the difference between a<br>&gt; case-sensitive and a case-insensitive search. Therefore, given a string x,<br>&gt; it&#39;s sometimes important to be able to obtain NFD(x). If every string x is<br>&gt; now automatically NFC(x), then the best one can do is NFD(NFC(x)), which is<br>&gt; not guaranteed equal to NFD(x) even with canonical comparison (i.e.<br>&gt; NFC(NFD(NFC(x))) != NFC(NFD(x)) for all x).<br>&gt;<br>&gt;<br>&gt; There are issues here related to String design. For instance, one could<br>&gt; make an argument that such searching is really only interesting for a<br>&gt; &quot;Text&quot; use case which is different from a String use case. That being said,<br>&gt; I don&#39;t want to argue about this here since we are hijacking this thread ;<br>&gt; ).<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; As an aside, I am not formally proposing this. I am just discussing<br>&gt;&gt; potential opportunities for optimization given that we would need (as apart<br>&gt;&gt; of this proposal) to add knowledge of unicode to the compiler which would<br>&gt;&gt; allow for compile time transformations.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;d be interested to know what performance gains you&#39;re envisioning with<br>&gt; such an optimization of constant strings at compile time.<br>&gt;<br>&gt;<br>&gt; I would have to measure such wins to say anything concrete.<br>&gt; Algorithmically one would be able to avoid normalization during common<br>&gt; unicode operations when you know you are using constant strings. Even<br>&gt; though this may provide a runtime win, the major win from teaching the<br>&gt; compiler about unicode would be in terms of applying unicode operations<br>&gt; such as encoding/decoding to constant strings.<br>&gt;<br>&gt; That being said, this is not the proposal that is being discussed here or<br>&gt; even being proposed here. [i.e. lets stop hijacking this thread ; )]<br>&gt;<br>&gt;<br>&gt; On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s<br>&gt;&gt;&gt;&gt; highly unlikely to be code-breaking in practice. Any existing code that<br>&gt;&gt;&gt;&gt; would get tripped up by this normalization is arguably broken already.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we<br>&gt;&gt;&gt;&gt; could conceivably allow existing code with differently-normalized<br>&gt;&gt;&gt;&gt; identifiers with a warning based on Swift version, but it&#39;s probably not<br>&gt;&gt;&gt;&gt; worth it. It&#39;d be interesting to data-mine Github or the iOS Swift<br>&gt;&gt;&gt;&gt; Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As an additional interesting point here, we could in general normalize<br>&gt;&gt;&gt;&gt; unicode strings. This could potentially reduce the size of unicode<br>&gt;&gt;&gt;&gt; characters or allow us to constant propagate certain unicode algorithms in<br>&gt;&gt;&gt;&gt; the optimizer.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/981066b3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 23, 2016 at 07:00:00am</p></header><div class="content"><p>No the proposal seems to be about unicode characters in Swift source code:<br></p><p>To ease lexing/parsing and avoid user confusion, the names of custom identifiers (type names, variable names, etc.) and operators in Swift can be composed of (mostly) separate sets of characters.<br></p><p>In that sense, it sounds more like a source-breaking bugfix to me.<br></p><p>&gt; On 23 Sep 2016, at 01:19, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You mean values of type String? I would want those to be exactly what I say they are; NFC normalization is available, if I recall, as part of Foundation, but by no means should my String values be silently changed!<br>&gt; <br>&gt; <br>&gt; On Thu, Sep 22, 2016 at 6:10 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Sep 22, 2016, at 10:50 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 26, 2016, at 12:26 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; +1. Even if it&#39;s too late for Swift 3, though, I&#39;d argue that it&#39;s highly unlikely to be code-breaking in practice. Any existing code that would get tripped up by this normalization is arguably broken already.<br>&gt; &gt;<br>&gt; &gt; I&#39;m inclined to agree. To be paranoid about perfect compatibility, we could conceivably allow existing code with differently-normalized identifiers with a warning based on Swift version, but it&#39;s probably not worth it. It&#39;d be interesting to data-mine Github or the iOS Swift Playgrounds app and see if this breaks any Swift 3 code in practice.<br>&gt; <br>&gt; As an additional interesting point here, we could in general normalize unicode strings. This could potentially reduce the size of unicode characters or allow us to constant propagate certain unicode algorithms in the optimizer.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160923/69e035b2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 26, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 26, 2016, at 12:22 PM, João Pinheiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This proposal [gist &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800&gt;] is the result of the discussions from the thread &quot;Prohibit invisible characters in identifier names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;&quot;. I hope it&#39;s still on time for inclusion in Swift 3.<br></p><p>Hi João,<br></p><p>Unfortunately, we’re out of time to accept new proposals.  Tomorrow is the last day for *implementation* work on source breaking changes to be done.  We can talk about this next week for Swift 3.x or Swift 4.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/0e81a0bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>João Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>July 27, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;ll wait until next week to ping about this again when the stress from Swift 3 has passed. I&#39;ll also revise the proposal to clarify about the small code-breaking possibility. As Xiaodi Wu mentioned, this change is highly unlikely to be code-breaking and existing code that would be broken up by this normalisation could arguably be considered broken already.<br></p><p>Sincerely,<br>João Pinheiro<br></p><p><br>&gt; On 26 Jul 2016, at 22:32, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 26, 2016, at 12:22 PM, João Pinheiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This proposal [gist &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800&gt;] is the result of the discussions from the thread &quot;Prohibit invisible characters in identifier names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;&quot;. I hope it&#39;s still on time for inclusion in Swift 3.<br>&gt; <br>&gt; Hi João,<br>&gt; <br>&gt; Unfortunately, we’re out of time to accept new proposals.  Tomorrow is the last day for *implementation* work on source breaking changes to be done.  We can talk about this next week for Swift 3.x or Swift 4.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/81cb8762/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>João Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>August  9, 2016 at 04:00:00pm</p></header><div class="content"><p>The crunch from Swift 3 has now passed and I&#39;m bringing up this proposal again. Should I go ahead and issue a pull request for this?<br></p><p>Sincerely,<br>João Pinheiro<br></p><p><br>&gt; On 26 Jul 2016, at 22:32, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 26, 2016, at 12:22 PM, João Pinheiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This proposal [gist &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800&gt;] is the result of the discussions from the thread &quot;Prohibit invisible characters in identifier names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;&quot;. I hope it&#39;s still on time for inclusion in Swift 3.<br>&gt; <br>&gt; Hi João,<br>&gt; <br>&gt; Unfortunately, we’re out of time to accept new proposals.  Tomorrow is the last day for *implementation* work on source breaking changes to be done.  We can talk about this next week for Swift 3.x or Swift 4.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/151afa68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September 21, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi João,<br>I think you should definitely put up a PR for this. I&#39;m restarting the<br>discussion about allowed operator/identifier characters (<br>https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59), and I<br>think your proposal is an obvious requirement for any solution to be<br>complete. :-)<br></p><p>Jacob<br></p><p>On Tue, Aug 9, 2016 at 7:20 AM, João Pinheiro &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; The crunch from Swift 3 has now passed and I&#39;m bringing up this proposal<br>&gt; again. Should I go ahead and issue a pull request for this?<br>&gt;<br>&gt; Sincerely,<br>&gt; João Pinheiro<br>&gt;<br>&gt;<br>&gt; On 26 Jul 2016, at 22:32, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 26, 2016, at 12:22 PM, João Pinheiro via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This proposal [gist<br>&gt; &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800&gt;]<br>&gt; is the result of the discussions from the thread &quot;Prohibit invisible<br>&gt; characters in identifier names<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;&quot;. I hope<br>&gt; it&#39;s still on time for inclusion in Swift 3.<br>&gt;<br>&gt;<br>&gt; Hi João,<br>&gt;<br>&gt; Unfortunately, we’re out of time to accept new proposals.  Tomorrow is the<br>&gt; last day for *implementation* work on source breaking changes to be done.<br>&gt; We can talk about this next week for Swift 3.x or Swift 4.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/82915334/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>João Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>September 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Jacob,<br></p><p>I&#39;ll go ahead and submit a pull request for this later today then!<br></p><p>João<br></p><p>&gt; On 22 Sep 2016, at 08:00, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi João,<br>&gt; I think you should definitely put up a PR for this. I&#39;m restarting the discussion about allowed operator/identifier characters (https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59), and I think your proposal is an obvious requirement for any solution to be complete. :-)<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt;&gt; On Tue, Aug 9, 2016 at 7:20 AM, João Pinheiro &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The crunch from Swift 3 has now passed and I&#39;m bringing up this proposal again. Should I go ahead and issue a pull request for this?<br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt; João Pinheiro<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26 Jul 2016, at 22:32, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 26, 2016, at 12:22 PM, João Pinheiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal [gist] is the result of the discussions from the thread &quot;Prohibit invisible characters in identifier names&quot;. I hope it&#39;s still on time for inclusion in Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi João,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, we’re out of time to accept new proposals.  Tomorrow is the last day for *implementation* work on source breaking changes to be done.  We can talk about this next week for Swift 3.x or Swift 4.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/8fec7791/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92adc26e3003cac88ca299a08d35b2b3?s=50"></div><header><strong>[Proposal] Normalize Unicode Identifiers</strong> from <string>João Pinheiro</string> &lt;joao at joaopinheiro.org&gt;<p>September 23, 2016 at 01:00:00am</p></header><div class="content"><p>I&#39;ve submitted the pull request for this proposal. :)<br></p><p><br>&gt; On 22 Sep 2016, at 14:58, João Pinheiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Jacob,<br>&gt; <br>&gt; I&#39;ll go ahead and submit a pull request for this later today then!<br>&gt; <br>&gt; João<br>&gt; <br>&gt; On 22 Sep 2016, at 08:00, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi João,<br>&gt;&gt; I think you should definitely put up a PR for this. I&#39;m restarting the discussion about allowed operator/identifier characters (https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59 &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt;), and I think your proposal is an obvious requirement for any solution to be complete. :-)<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Tue, Aug 9, 2016 at 7:20 AM, João Pinheiro &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; The crunch from Swift 3 has now passed and I&#39;m bringing up this proposal again. Should I go ahead and issue a pull request for this?<br>&gt;&gt; <br>&gt;&gt; Sincerely,<br>&gt;&gt; João Pinheiro<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 26 Jul 2016, at 22:32, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 26, 2016, at 12:22 PM, João Pinheiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal [gist &lt;https://gist.github.com/JoaoPinheiro/5f226f46c67d235a7039c775a4300800&gt;] is the result of the discussions from the thread &quot;Prohibit invisible characters in identifier names &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/21022&gt;&quot;. I hope it&#39;s still on time for inclusion in Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi João,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, we’re out of time to accept new proposals.  Tomorrow is the last day for *implementation* work on source breaking changes to be done.  We can talk about this next week for Swift 3.x or Swift 4.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160923/5e20b18c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
