<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dc0a379038518c23790a02ec4d17ec1e?s=50"></div><header><strong>Another way of designing server side</strong> from <string>Michael Chiu</string> &lt;hatsuneyuji at icloud.com&gt;<p>November  6, 2016 at 11:00:00pm</p></header><div class="content"><p>I would like to share some of my opinion as well.<br></p><p>I agree with you that we should have some design guidelines.<br></p><p>For me personally I would prefer protocol-orientated than functional approach for the following reasons, these are just thoughts:<br></p><p>- Life cycle of objects and call back hell.<br>     - in a networking environment it is hard to guarantee if the object still exist over and over different handlers, and since we can only store closures that are escaping, we really can’t guarantee what will happen, which can lead to callbacks hell.<br>     - Retains a lot of “middle men”<br>     - callbacks hells. (For example, Node.js)<br>     - more likely to cause memory leak (If some closure is retaining its owner).<br></p><p>- Fast<br>- No need to worry about class inheritance<br>- Much easily to schedule events.<br>      - for example, if we defines the way to read from the socket as socket.read(), it guarantees we only drain the socket when we need to, instead of letting the socket to make the decision since socket itself has no knowledge of our runtime at all.<br>- Much more readable<br>- Clear separation between roles of objects<br></p><p>I think the reactive and functional approach is still necessary, but for higher level api, which I think it’s stakeholder’s job to do with their own web frameworks. Since developer will expect a callback orientated API since it is more expressive to code with. <br></p><p>But sometimes, you might not necessarily want to drain data from the socket immediately (It never happen on me), a reactive model is easy and expressive but not necessarily powerful when we simply don’t want things to happen immediately. I think making functional programming can be danger as a guideline for building building blocks.<br></p><p>I think stick with a model with less callbacks will be much easier and safer. Nevertheless, protocol is much more powerful since we can access the methods and also the properties of an object without worry about an object retaining itself in closures.<br></p><p>I believe I’m might be a little bit off topic here and lot of thing I write can be false as well, but these are just some thoughts I have in my mind. <br></p><p>Thanks,<br>Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abab8a25de5c943e3481fd3f95f3d89a?s=50"></div><header><strong>Another way of designing server side</strong> from <string>Антон Миронов</string> &lt;antonvmironov at gmail.com&gt;<p>November  7, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Micheal,<br></p><p>Thank you for expressing your opinion. It means that we do need some kind of design guidelines.<br></p><p>As for your thoughts about guidelines.<br>- Protocol-oriented approach lets you build safe and flexible types. It has to be put into guidelines too. But it does not compete with a functional approach much.<br>- I do not like callbacks too.  But functional does not mean callbacks. Callbacks oppose to purity principle.<br>- there is a problem of memory leaks in asynchronously called lambdas. Using `weak` all over the place helps to solve this, but this approach is a very fragile. I&#39;ve tried to solve this problem in a library of asynchronous primitives I make.<br>- functional does not mean slow. You can actually make things faster incorporating lazy evaluation and etc.<br></p><p>A point about streams. I think that streams must usable both ways. Neither of those ways denies another.<br></p><p>&gt; On Nov 7, 2016, at 9:50 AM, Michael Chiu &lt;hatsuneyuji at icloud.com&gt; wrote:<br>&gt; <br>&gt; I would like to share some of my opinion as well.<br>&gt; <br>&gt; I agree with you that we should have some design guidelines.<br>&gt; <br>&gt; For me personally I would prefer protocol-orientated than functional approach for the following reasons, these are just thoughts:<br>&gt; <br>&gt; - Life cycle of objects and call back hell.<br>&gt;     - in a networking environment it is hard to guarantee if the object still exist over and over different handlers, and since we can only store closures that are escaping, we really can’t guarantee what will happen, which can lead to callbacks hell.<br>&gt;     - Retains a lot of “middle men”<br>&gt;     - callbacks hells. (For example, Node.js)<br>&gt;     - more likely to cause memory leak (If some closure is retaining its owner).<br>&gt; <br>&gt; - Fast<br>&gt; - No need to worry about class inheritance<br>&gt; - Much easily to schedule events.<br>&gt;      - for example, if we defines the way to read from the socket as socket.read(), it guarantees we only drain the socket when we need to, instead of letting the socket to make the decision since socket itself has no knowledge of our runtime at all.<br>&gt; - Much more readable<br>&gt; - Clear separation between roles of objects<br>&gt; <br>&gt; I think the reactive and functional approach is still necessary, but for higher level api, which I think it’s stakeholder’s job to do with their own web frameworks. Since developer will expect a callback orientated API since it is more expressive to code with. <br>&gt; <br>&gt; But sometimes, you might not necessarily want to drain data from the socket immediately (It never happen on me), a reactive model is easy and expressive but not necessarily powerful when we simply don’t want things to happen immediately. I think making functional programming can be danger as a guideline for building building blocks.<br>&gt; <br>&gt; I think stick with a model with less callbacks will be much easier and safer. Nevertheless, protocol is much more powerful since we can access the methods and also the properties of an object without worry about an object retaining itself in closures.<br>&gt; <br>&gt; I believe I’m might be a little bit off topic here and lot of thing I write can be false as well, but these are just some thoughts I have in my mind. <br>&gt; <br>&gt; Thanks,<br>&gt; Michael<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5f87c6d6b2f41c3ac647171eb30e34?s=50"></div><header><strong>Another way of designing server side</strong> from <string>Jean-Daniel</string> &lt;dev at xenonium.com&gt;<p>November  9, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Le 7 nov. 2016 à 10:33, Anton Mironov via swift-server-dev &lt;swift-server-dev at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi Micheal,<br>&gt; <br>&gt; Thank you for expressing your opinion. It means that we do need some kind of design guidelines.<br>&gt; <br>&gt; As for your thoughts about guidelines.<br>&gt; - Protocol-oriented approach lets you build safe and flexible types. It has to be put into guidelines too. But it does not compete with a functional approach much.<br>&gt; - I do not like callbacks too.  But functional does not mean callbacks. Callbacks oppose to purity principle.<br>&gt; - there is a problem of memory leaks in asynchronously called lambdas. Using `weak` all over the place helps to solve this, but this approach is a very fragile. I&#39;ve tried to solve this problem in a library of asynchronous primitives I make.<br></p><p>Using strong reference to self in lambda does not imply memory leak. It depends the life cycle of your lambda.<br></p><p>&gt; - functional does not mean slow. You can actually make things faster incorporating lazy evaluation and etc.<br>&gt; <br>&gt; A point about streams. I think that streams must usable both ways. Neither of those ways denies another.<br>&gt; <br>&gt;&gt; On Nov 7, 2016, at 9:50 AM, Michael Chiu &lt;hatsuneyuji at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would like to share some of my opinion as well.<br>&gt;&gt; <br>&gt;&gt; I agree with you that we should have some design guidelines.<br>&gt;&gt; <br>&gt;&gt; For me personally I would prefer protocol-orientated than functional approach for the following reasons, these are just thoughts:<br>&gt;&gt; <br>&gt;&gt; - Life cycle of objects and call back hell.<br>&gt;&gt;    - in a networking environment it is hard to guarantee if the object still exist over and over different handlers, and since we can only store closures that are escaping, we really can’t guarantee what will happen, which can lead to callbacks hell.<br>&gt;&gt;    - Retains a lot of “middle men”<br>&gt;&gt;    - callbacks hells. (For example, Node.js)<br>&gt;&gt;    - more likely to cause memory leak (If some closure is retaining its owner).<br>&gt;&gt; <br>&gt;&gt; - Fast<br>&gt;&gt; - No need to worry about class inheritance<br>&gt;&gt; - Much easily to schedule events.<br>&gt;&gt;     - for example, if we defines the way to read from the socket as socket.read(), it guarantees we only drain the socket when we need to, instead of letting the socket to make the decision since socket itself has no knowledge of our runtime at all.<br>&gt;&gt; - Much more readable<br>&gt;&gt; - Clear separation between roles of objects<br>&gt;&gt; <br>&gt;&gt; I think the reactive and functional approach is still necessary, but for higher level api, which I think it’s stakeholder’s job to do with their own web frameworks. Since developer will expect a callback orientated API since it is more expressive to code with. <br>&gt;&gt; <br>&gt;&gt; But sometimes, you might not necessarily want to drain data from the socket immediately (It never happen on me), a reactive model is easy and expressive but not necessarily powerful when we simply don’t want things to happen immediately. I think making functional programming can be danger as a guideline for building building blocks.<br>&gt;&gt; <br>&gt;&gt; I think stick with a model with less callbacks will be much easier and safer. Nevertheless, protocol is much more powerful since we can access the methods and also the properties of an object without worry about an object retaining itself in closures.<br>&gt;&gt; <br>&gt;&gt; I believe I’m might be a little bit off topic here and lot of thing I write can be false as well, but these are just some thoughts I have in my mind. <br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-server-dev mailing list<br>&gt; swift-server-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-server-dev<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
