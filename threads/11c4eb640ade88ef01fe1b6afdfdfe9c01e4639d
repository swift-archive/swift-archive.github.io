<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September  2, 2016 at 11:00:00am</p></header><div class="content"><p>on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;<br>&gt; The proposal is available here:<br>&gt;<br>&gt;  &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;<br>&gt;  * What is your evaluation of the proposal?<br></p><p>I strongly support inclusion of the feature, but I have issues with the<br>name.  It seems to me that in order to fit into the standard library, it<br>should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>conveys something important, and for the same reasons we&#39;re using<br>Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>stick to the scheme:<br></p><p>- “Unsafe,” because you can break memory safety with this tool<br></p><p>- “Raw,” because the fundamental model is that of “raw,” rather than<br>  “typed,” memory.<br></p><p>- “Buffer,” because it works on a series of contiguous elements of known<br>  length.<br></p><p>- “Pointer,” because it has reference semantics!  When you pass one of<br>  these things around by value, you&#39;re not passing the bytes; you&#39;re<br>  passing a shared reference to the bytes.<br></p><p>&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br></p><p>Yes, and it fills an important funcationality gap now that we have the<br>unsafe pointer model nailed down.<br></p><p>&gt;  <br>&gt;  * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, except for the name.<br></p><p>&gt;  <br>&gt;  * If you have used other languages or libraries with a similar<br>&gt;  feature, how do you feel that this proposal compares to those?  <br></p><p>I don&#39;t think any other language distinguishes raw from typed memory in<br>this way.<br></p><p>&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;  reading, or an in-depth study?<br></p><p>Enough ;-)<br></p><p>-- <br>-Dave, posting as a reviewer, not a review manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  2, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt; <br>&gt;&gt; The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; I strongly support inclusion of the feature, but I have issues with the<br></p><p>Clearly, otherwise you wouldn&#39;t have announced it 4 times ;)<br></p><p>&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br></p><p>Well, that&#39;s natural from a stdlib designer&#39;s viewpoint. It is almost<br>identical functionality, but it also exposes the UnsafeRawPointer API<br>for loading and storing arbitrary types. This naming issue was<br>discussed for a couple weeks on swift-evolution. Let&#39;s see if I can<br>recap inline with your comments.<br></p><p>&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt; stick to the scheme:<br>&gt; <br>&gt; - “Unsafe,” because you can break memory safety with this tool<br></p><p>OK. Let&#39;s not drop that one!<br></p><p>&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;  “typed,” memory.<br></p><p>To me, bytes only exist in memory. Accessing a byte, as opposed to some<br>in-memory type, is always a raw access.<br></p><p>&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;  length.<br></p><p>To me, bytes always represent a contiguous chunk of raw memory. The<br>term implies that we&#39;re dealing with memory layout, as opposed to just<br>some opaque chunk of data, which is I think what Foundation Data is for.<br></p><p>&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;  these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;  passing a shared reference to the bytes.<br></p><p>Unsafe means that this value doesn&#39;t own the memory. I agree with you<br>that reference semantics are important, and we need to clearly<br>distinguished this from something like Data. I just think Unsafe is<br>enough for the name.<br></p><p>UnsafeMutableRawBufferPointer does not actually convey that it can be<br>viewed as a collection of 8-bit values, which is fairly important.<br></p><p>Now that I&#39;ve satisfied my pedantic side, let&#39;s look at it from the developer&#39;s side.<br>To me it&#39;s a question of whether a longer or shorter name is more meaningful in<br>the natural setting of users&#39; source code:<br></p><p>func foo(bytes: UnsafeMutableRawBufferPointer)<br></p><p>withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>  foo(bytes: $0)<br>}<br>---<br>func foo(bytes: UnsafeMutableBytes)<br></p><p>withUnsafeBytes(of: &amp;header) {<br>  write(bytes: $0)<br>}<br></p><p>I don&#39;t think the longer name is more descriptive. I do think the<br>shorter name is more intuitive and meaningful.<br></p><p>UnsafeMutableRawPointer is already too long to be recognizable to<br>users. A benefit of UnsafeBytes is that the most developers won&#39;t need<br>to know how to work directly with raw pointers. So the name doesn’t<br>need to evoke them.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeBytes</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Sep 2, 2016, at 5:14 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I strongly support inclusion of the feature, but I have issues with the<br>&gt; <br>&gt; Clearly, otherwise you wouldn&#39;t have announced it 4 times ;)<br>&gt; <br>&gt;&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt;&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>&gt; <br>&gt; Well, that&#39;s natural from a stdlib designer&#39;s viewpoint. It is almost<br>&gt; identical functionality, but it also exposes the UnsafeRawPointer API<br>&gt; for loading and storing arbitrary types. This naming issue was<br>&gt; discussed for a couple weeks on swift-evolution. Let&#39;s see if I can<br>&gt; recap inline with your comments.<br>&gt; <br>&gt;&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt;&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt;&gt; stick to the scheme:<br>&gt;&gt; <br>&gt;&gt; - “Unsafe,” because you can break memory safety with this tool<br>&gt; <br>&gt; OK. Let&#39;s not drop that one!<br>&gt; <br>&gt;&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;&gt; “typed,” memory.<br>&gt; <br>&gt; To me, bytes only exist in memory. Accessing a byte, as opposed to some<br>&gt; in-memory type, is always a raw access.<br>&gt; <br>&gt;&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;&gt; length.<br>&gt; <br>&gt; To me, bytes always represent a contiguous chunk of raw memory. The<br>&gt; term implies that we&#39;re dealing with memory layout, as opposed to just<br>&gt; some opaque chunk of data, which is I think what Foundation Data is for.<br>&gt; <br>&gt;&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;&gt; these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;&gt; passing a shared reference to the bytes.<br>&gt; <br>&gt; Unsafe means that this value doesn&#39;t own the memory. I agree with you<br>&gt; that reference semantics are important, and we need to clearly<br>&gt; distinguished this from something like Data. I just think Unsafe is<br>&gt; enough for the name.<br>&gt; <br>&gt; UnsafeMutableRawBufferPointer does not actually convey that it can be<br>&gt; viewed as a collection of 8-bit values, which is fairly important.<br>&gt; <br>&gt; Now that I&#39;ve satisfied my pedantic side, let&#39;s look at it from the developer&#39;s side.<br>&gt; To me it&#39;s a question of whether a longer or shorter name is more meaningful in<br>&gt; the natural setting of users&#39; source code:<br>&gt; <br>&gt; func foo(bytes: UnsafeMutableRawBufferPointer)<br>&gt; <br>&gt; withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>&gt;  foo(bytes: $0)<br>&gt; }<br>&gt; ---<br>&gt; func foo(bytes: UnsafeMutableBytes)<br>&gt; <br>&gt; withUnsafeBytes(of: &amp;header) {<br>&gt;  write(bytes: $0)<br>&gt; }<br>&gt; <br>&gt; I don&#39;t think the longer name is more descriptive. I do think the<br>&gt; shorter name is more intuitive and meaningful.<br>&gt; <br>&gt; UnsafeMutableRawPointer is already too long to be recognizable to<br>&gt; users. A benefit of UnsafeBytes is that the most developers won&#39;t need<br>&gt; to know how to work directly with raw pointers. So the name doesn’t<br>&gt; need to evoke them.<br>&gt; <br>&gt; -Andy<br></p><p>Update on the naming debate...<br></p><p>I&#39;ve tentatively updated this proposal renaming UnsafeBytes to UnsafeRawBufferPointer. It&#39;s not bad as long as the `withUnsafeBytes` name remains:<br></p><p>https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/0138-unsaferawbufferpointer.md<br></p><p>I&#39;ve heard a few compelling arguments to use a long type name. I&#39;m the only person who&#39;s argued in favor of the short name. Here are the key points that have convinced me to give in:<br></p><p>- Although I would like &quot;bytes&quot; to only refer to raw, untyped memory,<br>  in reality it means different things to different people.<br></p><p>- We do not want to promote using this type in public API, except as<br>  an alternative to other UnsafePointer related types. APIs should<br>  really migrate to safe, managed types.<br></p><p>- In practice, we may end up with overloads that the more descriptive<br>  type can help clarify. For example, Data.withUnsafeBytes already<br>  passes an UnsafePointer to its closure. That API already shipped, but<br>  we may want a &quot;raw&quot; variant of it. Having the closure take<br>  `UnsafeRawBufferPointer` clarifies the distinction.<br></p><p>- What was more important to me was that the closure-taking functions<br>  are reasonably named and imply a collection of bytes over some<br>  value, which is not necessarilly a buffer to begin with. We can<br>  still do that. The function name can indicate a collection of bytes<br>  over some value&#39;s representation, while the argument type (which<br>  doesn&#39;t need to be spelled out) specifies that the collection is<br>  represented as a raw pointer with length:<br>  `withUnsafeBytes(of: &amp;value) { p: UnsafeRawBufferPointer in ...}<br></p><p>Does anyone have a good argument to keep the short UnsafeBytes type name?<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160906/fe589a0b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September 10, 2016 at 05:00:00pm</p></header><div class="content"><p>https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br></p><p>The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br></p><p>withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem...<br></p><p>In this code, it&#39;s obvious that a sequence of bytes is being appended to an array.<br></p><p>var buffer = [UInt8]()<br>withUnsafeBytes(of: &amp;header) {<br>  buffer += $0<br>}<br></p><p>In the following version, the closure argument type is obvious, which is nice, but otherwise it&#39;s borderline unreadable, and doesn&#39;t describe what&#39;s actually happenning. How can we tell that a sequence of bytes will be appended?<br></p><p>var buffer = [UInt8]()<br>withUnsafeRawBufferPointer(to: &amp;header) {<br>  buffer += $0<br>}<br></p><p>The mutable version really stretches the limits of descriptively naming things, and still doesn&#39;t say anything about a byte sequence:<br></p><p>withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>  readHeader(into: $0)<br>}<br></p><p>-Andy<br></p><p>&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt; <br>&gt;&gt; The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; I strongly support inclusion of the feature, but I have issues with the<br>&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt; stick to the scheme:<br>&gt; <br>&gt; - “Unsafe,” because you can break memory safety with this tool<br>&gt; <br>&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;  “typed,” memory.<br>&gt; <br>&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;  length.<br>&gt; <br>&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;  these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;  passing a shared reference to the bytes.<br>&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;   change to Swift?<br>&gt; <br>&gt; Yes, and it fills an important funcationality gap now that we have the<br>&gt; unsafe pointer model nailed down.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes, except for the name.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?  <br>&gt; <br>&gt; I don&#39;t think any other language distinguishes raw from typed memory in<br>&gt; this way.<br>&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt; <br>&gt; Enough ;-)<br>&gt; <br>&gt; -- <br>&gt; -Dave, posting as a reviewer, not a review manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>September 10, 2016 at 06:00:00pm</p></header><div class="content"><p>Coincidentally, I just wrote my first Swift code to use UnsafePointer&lt;&gt;. I was wrapping the LZMA API to decompress LZMA data. It&#39;s a C API that works by pointing to an input buffer and and output buffer, and then calling a function that decompresses what it can given those two buffers (and their lengths).<br></p><p>I treated them as UnsafePointer&lt;UInt8&gt;, but really they&#39;re raw, in the sense that they are not a collection of a single element, just a collection of bytes.<br></p><p>My wrapper&#39;s interface to LZMA uses Data instances. I don&#39;t see a way of getting from Data to UnsafeRawBufferPointer in Xcode 8 GM seed (which makes sense, given that this is still in progress). But I also didn&#39;t see a way to get to UnsafeRawPointer; should there be?<br></p><p>Will something be added to Data when SE-0138 is finalized? I guess that&#39;s not for Swift 3 but 3.x? <br></p><p>Thanks, and sorry if I&#39;m hijacking the thread a bit with this.<br></p><p>&gt; On Sep 10, 2016, at 17:53 , Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt; <br>&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt; <br>&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem...<br>&gt; <br>&gt; In this code, it&#39;s obvious that a sequence of bytes is being appended to an array.<br>&gt; <br>&gt; var buffer = [UInt8]()<br>&gt; withUnsafeBytes(of: &amp;header) {<br>&gt;  buffer += $0<br>&gt; }<br>&gt; <br>&gt; In the following version, the closure argument type is obvious, which is nice, but otherwise it&#39;s borderline unreadable, and doesn&#39;t describe what&#39;s actually happenning. How can we tell that a sequence of bytes will be appended?<br>&gt; <br>&gt; var buffer = [UInt8]()<br>&gt; withUnsafeRawBufferPointer(to: &amp;header) {<br>&gt;  buffer += $0<br>&gt; }<br>&gt; <br>&gt; The mutable version really stretches the limits of descriptively naming things, and still doesn&#39;t say anything about a byte sequence:<br>&gt; <br>&gt; withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>&gt;  readHeader(into: $0)<br>&gt; }<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I strongly support inclusion of the feature, but I have issues with the<br>&gt;&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt;&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>&gt;&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt;&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt;&gt; stick to the scheme:<br>&gt;&gt; <br>&gt;&gt; - “Unsafe,” because you can break memory safety with this tool<br>&gt;&gt; <br>&gt;&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;&gt; “typed,” memory.<br>&gt;&gt; <br>&gt;&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;&gt; length.<br>&gt;&gt; <br>&gt;&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;&gt; these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;&gt; passing a shared reference to the bytes.<br>&gt;&gt; <br>&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;  change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, and it fills an important funcationality gap now that we have the<br>&gt;&gt; unsafe pointer model nailed down.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, except for the name.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?  <br>&gt;&gt; <br>&gt;&gt; I don&#39;t think any other language distinguishes raw from typed memory in<br>&gt;&gt; this way.<br>&gt;&gt; <br>&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Enough ;-)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave, posting as a reviewer, not a review manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Sep 10, 2016, at 6:23 PM, Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Coincidentally, I just wrote my first Swift code to use UnsafePointer&lt;&gt;. I was wrapping the LZMA API to decompress LZMA data. It&#39;s a C API that works by pointing to an input buffer and and output buffer, and then calling a function that decompresses what it can given those two buffers (and their lengths).<br>&gt; <br>&gt; I treated them as UnsafePointer&lt;UInt8&gt;, but really they&#39;re raw, in the sense that they are not a collection of a single element, just a collection of bytes.<br>&gt; <br>&gt; My wrapper&#39;s interface to LZMA uses Data instances. I don&#39;t see a way of getting from Data to UnsafeRawBufferPointer in Xcode 8 GM seed (which makes sense, given that this is still in progress). But I also didn&#39;t see a way to get to UnsafeRawPointer; should there be?<br></p><p>There should be and there isn&#39;t. It used to be Data.bytes, but it was just deprecated. In the current state of limbo, you just do this:<br></p><p>  return data.withUnsafeBytes { bytes: UnsafeBufferPointer&lt;UInt8&gt; in … }<br></p><p>and that binds Data’s memory to UInt8. It fine in practice as long as Data owns its memory (not using bytesNoCopy). Otherwise whoever else uses the memory should also view it as either raw or UInt8, or they should bind memory each time they access it.<br></p><p>&gt; Will something be added to Data when SE-0138 is finalized? I guess that&#39;s not for Swift 3 but 3.x? <br></p><p>Yes. It just takes a little more time to evolve the Data API.<br></p><p>-Andy<br></p><p>&gt; Thanks, and sorry if I&#39;m hijacking the thread a bit with this.<br>&gt; <br>&gt;&gt; On Sep 10, 2016, at 17:53 , Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt;&gt; <br>&gt;&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt;&gt; <br>&gt;&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem...<br>&gt;&gt; <br>&gt;&gt; In this code, it&#39;s obvious that a sequence of bytes is being appended to an array.<br>&gt;&gt; <br>&gt;&gt; var buffer = [UInt8]()<br>&gt;&gt; withUnsafeBytes(of: &amp;header) {<br>&gt;&gt; buffer += $0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In the following version, the closure argument type is obvious, which is nice, but otherwise it&#39;s borderline unreadable, and doesn&#39;t describe what&#39;s actually happenning. How can we tell that a sequence of bytes will be appended?<br>&gt;&gt; <br>&gt;&gt; var buffer = [UInt8]()<br>&gt;&gt; withUnsafeRawBufferPointer(to: &amp;header) {<br>&gt;&gt; buffer += $0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The mutable version really stretches the limits of descriptively naming things, and still doesn&#39;t say anything about a byte sequence:<br>&gt;&gt; <br>&gt;&gt; withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>&gt;&gt; readHeader(into: $0)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strongly support inclusion of the feature, but I have issues with the<br>&gt;&gt;&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt;&gt;&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>&gt;&gt;&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt;&gt;&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt;&gt;&gt; stick to the scheme:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “Unsafe,” because you can break memory safety with this tool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;&gt;&gt; “typed,” memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;&gt;&gt; length.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;&gt;&gt; these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;&gt;&gt; passing a shared reference to the bytes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, and it fills an important funcationality gap now that we have the<br>&gt;&gt;&gt; unsafe pointer model nailed down.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, except for the name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think any other language distinguishes raw from typed memory in<br>&gt;&gt;&gt; this way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Enough ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave, posting as a reviewer, not a review manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>September 11, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks, Andrew. In my case, the Data reads from a file, and since the raw access is wrapped around the LZMA decompression, I think it should be safe (no one else is accessing the data at that time).<br></p><p>I&#39;ll just wait for Foundation.Data to be updated and update my code then.<br></p><p>&gt; On Sep 10, 2016, at 19:33 , Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 10, 2016, at 6:23 PM, Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Coincidentally, I just wrote my first Swift code to use UnsafePointer&lt;&gt;. I was wrapping the LZMA API to decompress LZMA data. It&#39;s a C API that works by pointing to an input buffer and and output buffer, and then calling a function that decompresses what it can given those two buffers (and their lengths).<br>&gt;&gt; <br>&gt;&gt; I treated them as UnsafePointer&lt;UInt8&gt;, but really they&#39;re raw, in the sense that they are not a collection of a single element, just a collection of bytes.<br>&gt;&gt; <br>&gt;&gt; My wrapper&#39;s interface to LZMA uses Data instances. I don&#39;t see a way of getting from Data to UnsafeRawBufferPointer in Xcode 8 GM seed (which makes sense, given that this is still in progress). But I also didn&#39;t see a way to get to UnsafeRawPointer; should there be?<br>&gt; <br>&gt; There should be and there isn&#39;t. It used to be Data.bytes, but it was just deprecated. In the current state of limbo, you just do this:<br>&gt; <br>&gt;  return data.withUnsafeBytes { bytes: UnsafeBufferPointer&lt;UInt8&gt; in … }<br>&gt; <br>&gt; and that binds Data’s memory to UInt8. It fine in practice as long as Data owns its memory (not using bytesNoCopy). Otherwise whoever else uses the memory should also view it as either raw or UInt8, or they should bind memory each time they access it.<br>&gt; <br>&gt;&gt; Will something be added to Data when SE-0138 is finalized? I guess that&#39;s not for Swift 3 but 3.x? <br>&gt; <br>&gt; Yes. It just takes a little more time to evolve the Data API.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; Thanks, and sorry if I&#39;m hijacking the thread a bit with this.<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 10, 2016, at 17:53 , Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this code, it&#39;s obvious that a sequence of bytes is being appended to an array.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var buffer = [UInt8]()<br>&gt;&gt;&gt; withUnsafeBytes(of: &amp;header) {<br>&gt;&gt;&gt; buffer += $0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the following version, the closure argument type is obvious, which is nice, but otherwise it&#39;s borderline unreadable, and doesn&#39;t describe what&#39;s actually happenning. How can we tell that a sequence of bytes will be appended?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var buffer = [UInt8]()<br>&gt;&gt;&gt; withUnsafeRawBufferPointer(to: &amp;header) {<br>&gt;&gt;&gt; buffer += $0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The mutable version really stretches the limits of descriptively naming things, and still doesn&#39;t say anything about a byte sequence:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>&gt;&gt;&gt; readHeader(into: $0)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I strongly support inclusion of the feature, but I have issues with the<br>&gt;&gt;&gt;&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt;&gt;&gt;&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>&gt;&gt;&gt;&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt;&gt;&gt;&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt;&gt;&gt;&gt; stick to the scheme:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - “Unsafe,” because you can break memory safety with this tool<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;&gt;&gt;&gt; “typed,” memory.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;&gt;&gt;&gt; length.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;&gt;&gt;&gt; these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;&gt;&gt;&gt; passing a shared reference to the bytes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, and it fills an important funcationality gap now that we have the<br>&gt;&gt;&gt;&gt; unsafe pointer model nailed down.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, except for the name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think any other language distinguishes raw from typed memory in<br>&gt;&gt;&gt;&gt; this way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Enough ;-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave, posting as a reviewer, not a review manager<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Sep 11, 2016, at 2:29 PM, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt; Thanks, Andrew. In my case, the Data reads from a file, and since the raw access is wrapped around the LZMA decompression, I think it should be safe (no one else is accessing the data at that time).<br>&gt; <br>&gt; I&#39;ll just wait for Foundation.Data to be updated and update my code then.<br></p><p>Sure, enumerateBytes is fine for you. To be clear, it would only be a problem if Data did not own the memory (bytesNoCopy:), allowing the same memory to be accessed as a non-UInt8 type.<br>-Andy<br></p><p>&gt; <br>&gt;&gt; On Sep 10, 2016, at 19:33 , Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 10, 2016, at 6:23 PM, Rick Mann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Coincidentally, I just wrote my first Swift code to use UnsafePointer&lt;&gt;. I was wrapping the LZMA API to decompress LZMA data. It&#39;s a C API that works by pointing to an input buffer and and output buffer, and then calling a function that decompresses what it can given those two buffers (and their lengths).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I treated them as UnsafePointer&lt;UInt8&gt;, but really they&#39;re raw, in the sense that they are not a collection of a single element, just a collection of bytes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My wrapper&#39;s interface to LZMA uses Data instances. I don&#39;t see a way of getting from Data to UnsafeRawBufferPointer in Xcode 8 GM seed (which makes sense, given that this is still in progress). But I also didn&#39;t see a way to get to UnsafeRawPointer; should there be?<br>&gt;&gt; <br>&gt;&gt; There should be and there isn&#39;t. It used to be Data.bytes, but it was just deprecated. In the current state of limbo, you just do this:<br>&gt;&gt; <br>&gt;&gt; return data.withUnsafeBytes { bytes: UnsafeBufferPointer&lt;UInt8&gt; in … }<br>&gt;&gt; <br>&gt;&gt; and that binds Data’s memory to UInt8. It fine in practice as long as Data owns its memory (not using bytesNoCopy). Otherwise whoever else uses the memory should also view it as either raw or UInt8, or they should bind memory each time they access it.<br>&gt;&gt; <br>&gt;&gt;&gt; Will something be added to Data when SE-0138 is finalized? I guess that&#39;s not for Swift 3 but 3.x? <br>&gt;&gt; <br>&gt;&gt; Yes. It just takes a little more time to evolve the Data API.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt; Thanks, and sorry if I&#39;m hijacking the thread a bit with this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 10, 2016, at 17:53 , Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this code, it&#39;s obvious that a sequence of bytes is being appended to an array.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var buffer = [UInt8]()<br>&gt;&gt;&gt;&gt; withUnsafeBytes(of: &amp;header) {<br>&gt;&gt;&gt;&gt; buffer += $0<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the following version, the closure argument type is obvious, which is nice, but otherwise it&#39;s borderline unreadable, and doesn&#39;t describe what&#39;s actually happenning. How can we tell that a sequence of bytes will be appended?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var buffer = [UInt8]()<br>&gt;&gt;&gt;&gt; withUnsafeRawBufferPointer(to: &amp;header) {<br>&gt;&gt;&gt;&gt; buffer += $0<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The mutable version really stretches the limits of descriptively naming things, and still doesn&#39;t say anything about a byte sequence:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>&gt;&gt;&gt;&gt; readHeader(into: $0)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt;&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt;&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt;&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt;&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt;&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I strongly support inclusion of the feature, but I have issues with the<br>&gt;&gt;&gt;&gt;&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt;&gt;&gt;&gt;&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>&gt;&gt;&gt;&gt;&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt;&gt;&gt;&gt;&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt;&gt;&gt;&gt;&gt; stick to the scheme:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - “Unsafe,” because you can break memory safety with this tool<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;&gt;&gt;&gt;&gt; “typed,” memory.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;&gt;&gt;&gt;&gt; length.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;&gt;&gt;&gt;&gt; these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;&gt;&gt;&gt;&gt; passing a shared reference to the bytes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, and it fills an important funcationality gap now that we have the<br>&gt;&gt;&gt;&gt;&gt; unsafe pointer model nailed down.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, except for the name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t think any other language distinguishes raw from typed memory in<br>&gt;&gt;&gt;&gt;&gt; this way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Enough ;-)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave, posting as a reviewer, not a review manager<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Rick Mann<br>&gt;&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September 11, 2016 at 08:00:00am</p></header><div class="content"><p>Now that “Raw” is introduced, also using “Unsafe” seems redundant to me. So ditch the unsafe and just go for “withRawBytes” and “withMutableRawBytes”.<br>I expect that most code that uses this type wil already have a name indicating that it concerns a byte buffer pointer, so “withRawBytes” should give sufficient clue as to what is going on.<br></p><p>Rien.<br></p><p>&gt; On 11 Sep 2016, at 02:53, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt; <br>&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt; <br>&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem...<br>&gt; <br>&gt; In this code, it&#39;s obvious that a sequence of bytes is being appended to an array.<br>&gt; <br>&gt; var buffer = [UInt8]()<br>&gt; withUnsafeBytes(of: &amp;header) {<br>&gt;  buffer += $0<br>&gt; }<br>&gt; <br>&gt; In the following version, the closure argument type is obvious, which is nice, but otherwise it&#39;s borderline unreadable, and doesn&#39;t describe what&#39;s actually happenning. How can we tell that a sequence of bytes will be appended?<br>&gt; <br>&gt; var buffer = [UInt8]()<br>&gt; withUnsafeRawBufferPointer(to: &amp;header) {<br>&gt;  buffer += $0<br>&gt; }<br>&gt; <br>&gt; The mutable version really stretches the limits of descriptively naming things, and still doesn&#39;t say anything about a byte sequence:<br>&gt; <br>&gt; withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>&gt;  readHeader(into: $0)<br>&gt; }<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I strongly support inclusion of the feature, but I have issues with the<br>&gt;&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt;&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>&gt;&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt;&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt;&gt; stick to the scheme:<br>&gt;&gt; <br>&gt;&gt; - “Unsafe,” because you can break memory safety with this tool<br>&gt;&gt; <br>&gt;&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;&gt; “typed,” memory.<br>&gt;&gt; <br>&gt;&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;&gt; length.<br>&gt;&gt; <br>&gt;&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;&gt; these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;&gt; passing a shared reference to the bytes.<br>&gt;&gt; <br>&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;  change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, and it fills an important funcationality gap now that we have the<br>&gt;&gt; unsafe pointer model nailed down.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, except for the name.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?  <br>&gt;&gt; <br>&gt;&gt; I don&#39;t think any other language distinguishes raw from typed memory in<br>&gt;&gt; this way.<br>&gt;&gt; <br>&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Enough ;-)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave, posting as a reviewer, not a review manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>September 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 11 Sep 2016, at 01:53, Andrew Trick wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt; <br>&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt; <br>&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem...<br></p><p>Does the `enumerateBytes` method (of Foundation.Data and DispatchData) also need an UnsafeRawBufferPointer version?<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Sep 11, 2016, at 3:07 AM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 11 Sep 2016, at 01:53, Andrew Trick wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt;&gt; <br>&gt;&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt;&gt; <br>&gt;&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem...<br>&gt; <br>&gt; Does the `enumerateBytes` method (of Foundation.Data and DispatchData) also need an UnsafeRawBufferPointer version?<br></p><p><br>I think it should only have an UnsafeRawBufferPointer version. If the user wants to bind memory, they should do that explicitly. I’ve made the likely changes to Data on a branch:<br>https://github.com/atrick/swift/commit/19968405608fa326eb7ad5ffed5fcd9a78b0f0a5 &lt;https://github.com/atrick/swift/commit/19968405608fa326eb7ad5ffed5fcd9a78b0f0a5&gt;<br></p><p>There are enough changes to Data that I think it deserves a separate proposal and discussion thread. It’s useful to look ahead at how the Data API should look but I’m trying to get language-level changes accepted first (in some sense, Unsafe constructs are part of the language even if they don’t require compiler changes).<br></p><p>Also keep in mind, adding UnsafeRawBufferPointer does not make Data any less usable today. We just need to get core support in place so we can have a discussion about Foundation.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160911/779e8739/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 10, 2016, at 5:53 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt; <br>&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt; <br>&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem…<br></p><p>I was totally wrong about this policy. In closure-taking “withXyz&quot; functions, “Xyz&quot; should reveal the role of the closure argument, not its type. We do not need to repeat type information.<br></p><p>We have strong agreement to leave the proposed `withUnsafeBytes {…}` name as it stands.<br></p><p>Note that `withRawBytes` was a strong contender, but at this time it&#39;s more important to consistently follow the convention for using `Unsafe` in the closure name whenever the closure argument is unsafe (e.g. you can&#39;t return it from the closure). We may want to revisit this logic later (in some sense Unsafe is redundant), but when we do that, we also need to reevaluate all of our withUnsafe APIs. Furthermore, we would want to change Foundation Data&#39;s API to be consistent. These are bigger debates that can be deferred.<br></p><p>-Andy<br></p><p>&gt; <br>&gt; In this code, it&#39;s obvious that a sequence of bytes is being appended to an array.<br>&gt; <br>&gt; var buffer = [UInt8]()<br>&gt; withUnsafeBytes(of: &amp;header) {<br>&gt;  buffer += $0<br>&gt; }<br>&gt; <br>&gt; In the following version, the closure argument type is obvious, which is nice, but otherwise it&#39;s borderline unreadable, and doesn&#39;t describe what&#39;s actually happenning. How can we tell that a sequence of bytes will be appended?<br>&gt; <br>&gt; var buffer = [UInt8]()<br>&gt; withUnsafeRawBufferPointer(to: &amp;header) {<br>&gt;  buffer += $0<br>&gt; }<br>&gt; <br>&gt; The mutable version really stretches the limits of descriptively naming things, and still doesn&#39;t say anything about a byte sequence:<br>&gt; <br>&gt; withUnsafeMutableRawBufferPointer(to: &amp;header) {<br>&gt;  readHeader(into: $0)<br>&gt; }<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; On Sep 2, 2016, at 11:14 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Sep 01 2016, Andrew Trick &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’m resending this for Review Manager Dave A. because the announce list is dropping his messages...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;UnsafeBytes&quot; begins now and runs through September<br>&gt;&gt;&gt; 7th. This late addition to Swift 3 is a follow-up to SE-0107:<br>&gt;&gt;&gt; UnsafeRawPointer. It addresses common use cases for UnsafeRawPointer,<br>&gt;&gt;&gt; allowing developers to continue working with collections of UInt8 values,<br>&gt;&gt;&gt; but now doing so via a type safe API. The UnsafeBytes API will not require <br>&gt;&gt;&gt; direct manipulation of raw pointers or reasoning about binding memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsafebytes.md&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I strongly support inclusion of the feature, but I have issues with the<br>&gt;&gt; name.  It seems to me that in order to fit into the standard library, it<br>&gt;&gt; should be called Unsafe[Mutable]RawBufferPointer.  Each part of the name<br>&gt;&gt; conveys something important, and for the same reasons we&#39;re using<br>&gt;&gt; Unsafe[Mutable]BufferPointer instead of UnsafeMutableElements, we should<br>&gt;&gt; stick to the scheme:<br>&gt;&gt; <br>&gt;&gt; - “Unsafe,” because you can break memory safety with this tool<br>&gt;&gt; <br>&gt;&gt; - “Raw,” because the fundamental model is that of “raw,” rather than<br>&gt;&gt; “typed,” memory.<br>&gt;&gt; <br>&gt;&gt; - “Buffer,” because it works on a series of contiguous elements of known<br>&gt;&gt; length.<br>&gt;&gt; <br>&gt;&gt; - “Pointer,” because it has reference semantics!  When you pass one of<br>&gt;&gt; these things around by value, you&#39;re not passing the bytes; you&#39;re<br>&gt;&gt; passing a shared reference to the bytes.<br>&gt;&gt; <br>&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;  change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, and it fills an important funcationality gap now that we have the<br>&gt;&gt; unsafe pointer model nailed down.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, except for the name.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?  <br>&gt;&gt; <br>&gt;&gt; I don&#39;t think any other language distinguishes raw from typed memory in<br>&gt;&gt; this way.<br>&gt;&gt; <br>&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Enough ;-)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave, posting as a reviewer, not a review manager<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>September 26, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 14 Sep 2016, at 17:08, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 10, 2016, at 5:53 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt;&gt; <br>&gt;&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt;&gt; <br>&gt;&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem…<br>&gt; <br>&gt; I was totally wrong about this policy. In closure-taking “withXyz&quot; functions, “Xyz&quot; should reveal the role of the closure argument, not its type. We do not need to repeat type information.<br>&gt; <br>&gt; We have strong agreement to leave the proposed `withUnsafeBytes {…}` name as it stands.<br>&gt; <br>&gt; Note that `withRawBytes` was a strong contender, but at this time it&#39;s more important to consistently follow the convention for using `Unsafe` in the closure name whenever the closure argument is unsafe (e.g. you can&#39;t return it from the closure). We may want to revisit this logic later (in some sense Unsafe is redundant), but when we do that, we also need to reevaluate all of our withUnsafe APIs. Furthermore, we would want to change Foundation Data&#39;s API to be consistent. These are bigger debates that can be deferred.<br></p><p>An example without `Unsafe` in the function name:<br></p><p>&lt;https://developer.apple.com/reference/swift/string/1538904-withcstring&gt;<br></p><p>-- Ben<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 26, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 14 Sep 2016, at 18:08, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 10, 2016, at 5:53 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md<br>&gt;&gt; <br>&gt;&gt; The review period has been extended until September 14. The UnsafeRawBufferPointer type name is settled, but we still need to come up with an answer for the name of the new closure taking functions:<br>&gt;&gt; <br>&gt;&gt; withXyz() should normally reveal the closure argument type as Xyz. That&#39;s why I originally proposed UnsafeBytes as the type name. Now that we&#39;ve decided to use the descriptive type instead we have a problem…<br>&gt; <br>&gt; I was totally wrong about this policy. In closure-taking “withXyz&quot; functions, “Xyz&quot; should reveal the role of the closure argument, not its type. We do not need to repeat type information.<br>&gt; <br>&gt; We have strong agreement to leave the proposed `withUnsafeBytes {…}` name as it stands.<br>&gt; <br>&gt; Note that `withRawBytes` was a strong contender, but at this time it&#39;s more important to consistently follow the convention for using `Unsafe` in the closure name whenever the closure argument is unsafe (e.g. you can&#39;t return it from the closure). We may want to revisit this logic later (in some sense Unsafe is redundant), but when we do that, we also need to reevaluate all of our withUnsafe APIs. Furthermore, we would want to change Foundation Data&#39;s API to be consistent. These are bigger debates that can be deferred.<br></p><p>Annotating that a parameter of a closure should not escape the closure is probably a worthwhile thing to have, anyway. Currently we only allow that for function-type parameters, but there are other parameters you might give (such as the pointer in `String.withCString()`’s closure) which should not escape their context.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>SE-0138 UnsafeRawBufferPointer</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>September 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; <br>&gt; Annotating that a parameter of a closure should not escape the closure is probably a worthwhile thing to have, anyway. Currently we only allow that for function-type parameters, but there are other parameters you might give (such as the pointer in `String.withCString()`’s closure) which should not escape their context.<br></p><p><br>It certainly needs to be at least explicitly documented somewhere. I’ve seen people use it in published code to obtain a pointer to (fro example) the bytes in an array without realising that the storage could easily go away.<br></p><p><br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
