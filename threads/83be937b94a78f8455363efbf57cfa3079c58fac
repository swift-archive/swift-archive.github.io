<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4f7ef407e29c78270ee50b2173370fe?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Bram Beernink</string> &lt;bram.beernink89 at gmail.com&gt;<p>July 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Would it be possible to improve value and move semantics (performance) in Swift? Consider this possible Swift code in a future release of Swift:<br></p><p>let array1 : [String] = [&quot;Val1&quot;, &quot;Val2&quot;]<br>let array2 = array1.appended(“Val3”) // Copy of array1 with “Val3” appended. array1 is left untouched. Nothing special yet.<br>var array3 : [String] = [“Var1”]<br>array3 = array3.appended(“Var2”) // array3 can just be mutated to add “Var2”, while maintaining value semantics. Swift can recognize that array3’s old state is not referenced anywhere in the future.<br>let array4 = array2.appended(&quot;Val4&quot;).appended(&quot;Val5&quot;) // Copy of array2 with both &quot;Val4&quot; and &quot;Val5&quot; appended. In this case, “Val5” can also be appended by mutation.<br></p><p>This example illustrates improved value semantics with a string array. But it would be good if this can work with any struct. Maybe via something similar to isUniquelyReferenced? Or maybe you can even have a “smart” self in a non-mutating func in a struct:<br>struct Array&lt;T&gt; {<br>    func appended(e : T) -&gt; Array&lt;T&gt; { // No mutating keyword!<br>        self.append(e) // self would either be mutated here if the current ref count of self is 1, and self is either a “rvalue” or self’s old state cannot possibly referenced anymore after this call. Otherwise, &quot;self” would actually be a copy of self.<br>        return self<br>    }<br>}<br></p><p>I think that with such support it is encouraged to make more use of (immutable) value types while not sacrificing performance. Less mutations lead to more understandable code, which leads to less bugs.<br></p><p>In any case, keep up the fast improvements to Swift.<br></p><p>Best regards,<br>Bram.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160729/83be8fac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 30, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On 29 Jul 2016, at 18:42, Bram Beernink via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Would it be possible to improve value and move semantics (performance) in Swift? Consider this possible Swift code in a future release of Swift:<br>&gt; <br>&gt; let array1 : [String] = [&quot;Val1&quot;, &quot;Val2&quot;]<br>&gt; let array2 = array1.appended(“Val3”) // Copy of array1 with “Val3” appended. array1 is left untouched. Nothing special yet.<br>&gt; var array3 : [String] = [“Var1”]<br>&gt; array3 = array3.appended(“Var2”) // array3 can just be mutated to add “Var2”, while maintaining value semantics. Swift can recognize that array3’s old state is not referenced anywhere in the future.<br>&gt; let array4 = array2.appended(&quot;Val4&quot;).appended(&quot;Val5&quot;) // Copy of array2 with both &quot;Val4&quot; and &quot;Val5&quot; appended. In this case, “Val5” can also be appended by mutation.<br>&gt; <br>&gt; This example illustrates improved value semantics with a string array. But it would be good if this can work with any struct. Maybe via something similar to isUniquelyReferenced? Or maybe you can even have a “smart” self in a non-mutating func in a struct:<br>&gt; struct Array&lt;T&gt; {<br>&gt;     func appended(e : T) -&gt; Array&lt;T&gt; { // No mutating keyword!<br>&gt;         self.append(e) // self would either be mutated here if the current ref count of self is 1, and self is either a “rvalue” or self’s old state cannot possibly referenced anymore after this call. Otherwise, &quot;self” would actually be a copy of self.<br>&gt;         return self<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; I think that with such support it is encouraged to make more use of (immutable) value types while not sacrificing performance. Less mutations lead to more understandable code, which leads to less bugs.<br>&gt; <br>&gt; In any case, keep up the fast improvements to Swift.<br>&gt; <br>&gt; Best regards,<br>&gt; Bram.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>It’s a known issue. See: https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment &lt;https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment&gt;<br></p><p>I’m not a compiler expert, but in theory I’d expect a smart-enough, fast-enough optimiser to be able to replace those with mutating calls. <br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/8257165d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 29 Jul 2016, at 17:42, Bram Beernink via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Would it be possible to improve value and move semantics (performance) in Swift? Consider this possible Swift code in a future release of Swift:<br>&gt; <br>&gt; let array1 : [String] = [&quot;Val1&quot;, &quot;Val2&quot;]<br>&gt; let array2 = array1.appended(“Val3”) // Copy of array1 with “Val3” appended. array1 is left untouched. Nothing special yet.<br>&gt; var array3 : [String] = [“Var1”]<br>&gt; array3 = array3.appended(“Var2”) // array3 can just be mutated to add “Var2”, while maintaining value semantics. Swift can recognize that array3’s old state is not referenced anywhere in the future.<br>&gt; let array4 = array2.appended(&quot;Val4&quot;).appended(&quot;Val5&quot;) // Copy of array2 with both &quot;Val4&quot; and &quot;Val5&quot; appended. In this case, “Val5” can also be appended by mutation.<br></p><p>Well, for the array3 = array3.appended(&quot;Var2&quot;) example this could possibly be addressed by an attribute to indicate to the compiler that .appended() has a mutating variant, as this will allow it to issue a warning when the assignment is to the same variable, which would address that simple case (and provide more awareness of the mutating options and encourage developers to use them).<br></p><p>&gt; This example illustrates improved value semantics with a string array. But it would be good if this can work with any struct. Maybe via something similar to isUniquelyReferenced? Or maybe you can even have a “smart” self in a non-mutating func in a struct:<br>&gt; struct Array&lt;T&gt; {<br>&gt;     func appended(e : T) -&gt; Array&lt;T&gt; { // No mutating keyword!<br>&gt;         self.append(e) // self would either be mutated here if the current ref count of self is 1, and self is either a “rvalue” or self’s old state cannot possibly referenced anymore after this call. Otherwise, &quot;self” would actually be a copy of self.<br>&gt;         return self<br>&gt;     }<br>&gt; }<br></p><p>I don&#39;t know about allowing mutation of self in non-mutating methods, that seems confusing; however, I&#39;d be surprised if the compiler doesn&#39;t already detect variables that only exist to create a copy that is discarded.<br></p><p>The compiler should already be trying to inline very simple methods like the common copy -&gt; mutate -&gt; return style of non-mutating implementations, in which case it should be able to identify that a copy is being created only to overwrite the original anyway, so can be eliminated. Do you believe that this isn&#39;t currently being done?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/47bbfc1c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4f7ef407e29c78270ee50b2173370fe?s=50"></div><header><strong>Improved value and move semantics</strong> from <string>Bram Beernink</string> &lt;bram.beernink89 at gmail.com&gt;<p>July 31, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Karl and Haravikk,<br></p><p>Thank you for your replies. <br></p><p>I was assuming that the cases I represented are not always optimized for several reasons:<br>Swift’s book only talks about optimization in the context of arrays, strings and dictionaries. Not in the context of structs in general:<br>“The description above refers to the “copying” of strings, arrays, and dictionaries. The behavior you see in your code will always be as if a copy took place. However, Swift only performs an actual copy behind the scenes when it is absolutely necessary to do so. Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization.”<br>Excerpt From: Apple Inc. “The Swift Programming Language (Swift 2.2).” iBooks. https://itun.es/nl/jEUH0.l &lt;https://itun.es/nl/jEUH0.l&gt;<br>In https://github.com/apple/swift/tree/eb27bb65a7c17bd9b4255baee5c4e4f9c214bde6/stdlib/public/core &lt;https://github.com/apple/swift/tree/eb27bb65a7c17bd9b4255baee5c4e4f9c214bde6/stdlib/public/core&gt; I see <br>public mutating func append(_ newElement: Element) , line 1268,<br>using _makeUniqueAndReserveCapacityIfNotUnique() at line 1269, leading me to suspect that to have COW, you have to do additional work.<br>Doing some manual tests some time ago, isUniquelyReferenced seemed to return false in a case like append_one as https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment &lt;https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment&gt; mentioned by Karl, meaning that it indeed leads to unnecessary copying.<br></p><p>In any case, https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment &lt;https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment&gt; does mention that: “Sometimes COW can introduce additional unexpected copies if the user is not careful.” I would argue that what we need is not only COW, but Copy On Write When Necessary, COWWN. In COWWN copies are only made when writing to the shared reference if it is not unique and the shared reference’s old state is still referred to in next statements. So not only is the current reference count taken into account, but also whether the old state is needed afterwards. This is both runtime as well as compile-time data.<br></p><p>So my questions would be:<br>Why does Swift sometimes do additional unnecessary copying, as implied by https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment &lt;https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#advice-use-inplace-mutation-instead-of-object-reassignment&gt; in the case of append_one? Is this a problem that cannot be solved? (In C++ you would solve this example using a=a.append_one(std::move(a)). But I would think that since Swift does not have to deal with pointers and manual memory management, it can automatically detect such cases unlike C++?)<br>If/once structs are COWWN, can Swift introduce immutable functions for the standard library, such as func appended(_ newElement: Element) -&gt; Array&lt;Element&gt;?<br></p><p>Best regards,<br>Bram.<br></p><p>&gt; On 30 jul. 2016, at 12:46, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt;&gt; On 29 Jul 2016, at 17:42, Bram Beernink via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Would it be possible to improve value and move semantics (performance) in Swift? Consider this possible Swift code in a future release of Swift:<br>&gt;&gt; <br>&gt;&gt; let array1 : [String] = [&quot;Val1&quot;, &quot;Val2&quot;]<br>&gt;&gt; let array2 = array1.appended(“Val3”) // Copy of array1 with “Val3” appended. array1 is left untouched. Nothing special yet.<br>&gt;&gt; var array3 : [String] = [“Var1”]<br>&gt;&gt; array3 = array3.appended(“Var2”) // array3 can just be mutated to add “Var2”, while maintaining value semantics. Swift can recognize that array3’s old state is not referenced anywhere in the future.<br>&gt;&gt; let array4 = array2.appended(&quot;Val4&quot;).appended(&quot;Val5&quot;) // Copy of array2 with both &quot;Val4&quot; and &quot;Val5&quot; appended. In this case, “Val5” can also be appended by mutation.<br>&gt; <br>&gt; Well, for the array3 = array3.appended(&quot;Var2&quot;) example this could possibly be addressed by an attribute to indicate to the compiler that .appended() has a mutating variant, as this will allow it to issue a warning when the assignment is to the same variable, which would address that simple case (and provide more awareness of the mutating options and encourage developers to use them).<br>&gt; <br>&gt;&gt; This example illustrates improved value semantics with a string array. But it would be good if this can work with any struct. Maybe via something similar to isUniquelyReferenced? Or maybe you can even have a “smart” self in a non-mutating func in a struct:<br>&gt;&gt; struct Array&lt;T&gt; {<br>&gt;&gt;     func appended(e : T) -&gt; Array&lt;T&gt; { // No mutating keyword!<br>&gt;&gt;         self.append(e) // self would either be mutated here if the current ref count of self is 1, and self is either a “rvalue” or self’s old state cannot possibly referenced anymore after this call. Otherwise, &quot;self” would actually be a copy of self.<br>&gt;&gt;         return self<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; I don&#39;t know about allowing mutation of self in non-mutating methods, that seems confusing; however, I&#39;d be surprised if the compiler doesn&#39;t already detect variables that only exist to create a copy that is discarded.<br>&gt; <br>&gt; The compiler should already be trying to inline very simple methods like the common copy -&gt; mutate -&gt; return style of non-mutating implementations, in which case it should be able to identify that a copy is being created only to overwrite the original anyway, so can be eliminated. Do you believe that this isn&#39;t currently being done?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160731/1b5f3dab/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
