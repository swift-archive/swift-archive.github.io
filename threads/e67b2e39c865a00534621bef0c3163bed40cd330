<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23bb59b802aac41afdf8ffffae1040d5?s=50"></div><header><strong>Notes from Swift core team 2016-04-20 design discussion</strong> from <string>Alex Martini</string> &lt;amartini at apple.com&gt;<p>April 21, 2016 at 08:00:00am</p></header><div class="content"><p>To help keep proposals moving forward, the Swift core team has set aside some time specifically for design discussions of upcoming proposals.  Below are some rough notes from the yesterday&#39;s discussion.<br></p><p>These are informal comments, intended to guide the proposals in directions that draw constructive feedback. You are welcome to ignore the feedback, agree with it, or disagree with it.  As always, the formal decision doesn&#39;t happen until after the review period ends.<br></p><p>SE-0068: Expanding Swift Self to class members and value types &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-04-20.html#se-0068-expanding-swift-self-to-class-members-and-value-types&gt;<br>https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br>We have one keyword left in the language, dynamicType, which is camel cased. This proposal renames it to Self instead.<br></p><p>In a static function today, self.dynamicType will give you a metatype but the non-member Self will not. The most useful reason to reference it is to call an initializer. It makes accessing the metatype weirder. It’s not Self.Type; that’s a type — you have to spell it Self.type.<br></p><p>Quiz time! What do each of the permutations mean?<br></p><p>Self.self<br>self.Self<br>Self.Self<br>self.self<br>The number of capital letters gives you the level of meta-ness. This is very subtle, which is probably not a good thing.<br></p><p>Another approach would be to introduce a new dynamictype keyword that doesn’t need to be accessed as a member of self, and keep Self the way it is.  Self should work in structs as a type alias.<br></p><p>Why don’t we turn this into a standard library function? It’s not something you need so often that the member access is very valuable. Putting it in the standard library as dynamicType(_:) does still allow for that function to be implemented using compiler magic.<br></p><p>func dynamicType&lt;T&gt;(_: T) -&gt; T.Type { }<br>We have a proposal to remove .self on types. One reason .self exists is to avoid the mistake of writing let x = Int — the compiler will give you a weird type error later on in code if the value of x is what we today call Int.self but you meant to call the Int() initializer. Creating a metatype is not a common operation, so doing it explicitly is a good thing.<br></p><p>It’s weird that you can use the metatype directly to construct something or to do member access, but you can’t access it as a bare value.<br></p><p>Coming back to this proposal, if we removed .self why would we want to add .Self?<br></p><p>If you have a variable whose value is a metatype, you also keep its name in lower case. So Self makes a little less sense from that aspect too.<br></p><p>Another perspective is that .dynamicType is just an implicitly synthesized property on all type.<br></p><p>We do have other keywords that follow the dot on types, Int.Type and Fooable.Protocol, so this isn’t the only thing. Those things are magic nested types.<br></p><p>Subjectively, having dynamicType as a member feels weird.<br></p><p>If .self goes away, the four-self example above is simplified, and .Self doesn’t make sense anymore. There’s also the difference that .Self would be a runtime thing.<br></p><p>What to do about optional requirements &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-04-20.html#what-to-do-about-optional-requirements&gt;<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/14046 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14046&gt;<br>People commonly ask why optional only works on Objective-C protocols, and the responses they get are usually that in Swift code you should reshape your protocols. As a starting assumption, we’re not making optionl work in Swift. So what do we do about this as part of the interoperability code?<br></p><p>People do write these, but it’s often because they’re writing a delegate protocol and they’re following the example of Cocoa frameworks.<br></p><p>Roughly three things we can do:<br></p><p>Rename it to make it clearly an Objective-C interop feature. We could also forbid you actually spelling it in Swift code. That doesn’t work well because it breaks your ability to write code in Swift that has Objective-C clients — those clients won’t get the default implementation from the extensions like you would use with Swift clients instead of creating optional requirements.<br>Modeling optional requirements as a function of optional type such as ((A, B) -&gt; C)? doesn’t work well. For example, properties can have optional type and they can be optional requirements, so you would end up having to deal with a lot of extra complexity due to double-optionals and likely want better code completion so you could type it all out.<br>You force the default implementation to be visible from all callers, and you do the dispatch at the call site. The only advantage of this is that it takes optional requirements out of the language entirely. If you wanted to implement the (somewhat common) pattern of checking whether a type implements an optional requirement, you would have to use a respondsToSelector check.<br>The best pattern we’ve seen for checking conformance and using different code paths based on that is to use finer-grained protocols. (But there are still issues with organizing your code that way.)<br></p><p>The caller default (#3) is really the only way to get optional requirements out of the type system. The weird code path in the compiler here is the same as the weird code path as we have in AnyObject. But it doesn’t look like we’re going to be able to do that.<br></p><p>We can rename this as objcoptional or possibly demote it to an attribute.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/e67bd330/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Notes from Swift core team 2016-04-20 design discussion</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 21, 2016 at 08:00:00pm</p></header><div class="content"><p>&quot;Another approach would be to introduce a new dynamictype keyword that <br>doesn’t need to be accessed as a member of self, and keep Self the way it <br>is.  Self should work in structs as a type alias.&quot;<br></p><p>So, could you clarify, do you suggest to introduce dynamictype keyword <br>instead of &quot;self.dynamicType&quot; ? (In addition to remove .self on type and <br>.Self for instance)<br></p><p>And to leave Self just as placeholder for current type i.e. &quot;the class <br>there this is declared&quot;  ?<br></p><p>Just want to clarify. Let&#39;s review this code:<br></p><p>protocol Proto {<br>     func z() -&gt; Self<br>     func z(s: Self)<br>}<br></p><p>class X: Proto {<br>     required init () {}<br>     func x() -&gt; Self { return self.dynamicType.init() }<br>     func z() -&gt; Self { return self }<br>     func z(s: X) {}<br>}<br></p><p><br>How should it looks like in Swift 3.0 ? :<br></p><p>protocol AP {<br>     func z() -&gt; dynamictype<br>     func z(s: Self)<br>}<br></p><p>class X: AP {<br>     required init () {}<br>     func x() -&gt; dynamictype { return dynamicType.init() }<br>     func z() -&gt; dynamictype { return self }<br>     func z(s: X) {} // ? Don&#39;t we want to have Self here ?<br>}<br></p><p><br>Do you support to extend Self to be used in class methods declarations to <br>behave just like in protocol i.e. as &quot;placeholder for defined class&quot; ?<br></p><p>So we can have in class:<br>     func z(s: Self) {}<br></p><p>Do you support to rename Self -&gt; #Self ?<br></p><p>Thank you for answers.<br></p><p><br>On 21.04.2016 18:58, Alex Martini via swift-evolution wrote:<br>&gt; To help keep proposals moving forward, the Swift core team has set aside<br>&gt; some time specifically for design discussions of upcoming proposals.  Below<br>&gt; are some rough notes from the yesterday&#39;s discussion.<br>&gt;<br>&gt; These are informal comments, intended to guide the proposals in directions<br>&gt; that draw constructive feedback. You are welcome to ignore the<br>&gt; feedback, agree with it, or disagree with it.  As always, the formal<br>&gt; decision doesn&#39;t happen until after the review period ends.<br>&gt;<br>&gt;<br>&gt;       SE-0068: Expanding Swift Self to class members and value types<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt;<br>&gt; We have one keyword left in the language, dynamicType, which is camel<br>&gt; cased. This proposal renames it to Self instead.<br>&gt;<br>&gt; In a static function today, self.dynamicType will give you a metatype but<br>&gt; the non-member Self will not. The most useful reason to reference it is to<br>&gt; call an initializer. It makes accessing the metatype weirder. It’s<br>&gt; not Self.Type; that’s a type — you have to spell it Self.type.<br>&gt;<br>&gt; Quiz time! What do each of the permutations mean?<br>&gt;<br>&gt; Self.self<br>&gt; self.Self<br>&gt; Self.Self<br>&gt; self.self<br>&gt;<br>&gt; The number of capital letters gives you the level of meta-ness. This is<br>&gt; very subtle, which is probably not a good thing.<br>&gt;<br>&gt; Another approach would be to introduce a new dynamictype keyword that<br>&gt; doesn’t need to be accessed as a member of self, and keep Self the way it<br>&gt; is.  Self should work in structs as a type alias.<br>&gt;<br>&gt; Why don’t we turn this into a standard library function? It’s not something<br>&gt; you need so often that the member access is very valuable. Putting it in<br>&gt; the standard library as dynamicType(_:) does still allow for that function<br>&gt; to be implemented using compiler magic.<br>&gt;<br>&gt; func dynamicType&lt;T&gt;(_: T) -&gt; T.Type { }<br>&gt;<br>&gt; We have a proposal to remove .self on types. One reason .self exists is to<br>&gt; avoid the mistake of writing let x = Int — the compiler will give you a<br>&gt; weird type error later on in code if the value of x is what we today<br>&gt; call Int.self but you meant to call the Int() initializer. Creating a<br>&gt; metatype is not a common operation, so doing it explicitly is a good thing.<br>&gt;<br>&gt; It’s weird that you can use the metatype directly to construct something or<br>&gt; to do member access, but you can’t access it as a bare value.<br>&gt;<br>&gt; Coming back to this proposal, if we removed .self why would we want to<br>&gt; add .Self?<br>&gt;<br>&gt; If you have a variable whose value is a metatype, you also keep its name in<br>&gt; lower case. So Self makes a little less sense from that aspect too.<br>&gt;<br>&gt; Another perspective is that .dynamicType is just an implicitly synthesized<br>&gt; property on all type.<br>&gt;<br>&gt; We do have other keywords that follow the dot on<br>&gt; types, Int.Type and Fooable.Protocol, so this isn’t the only thing. Those<br>&gt; things are magic nested types.<br>&gt;<br>&gt; Subjectively, having dynamicType as a member feels weird.<br>&gt;<br>&gt; If .self goes away, the four-self example above is simplified,<br>&gt; and .Self doesn’t make sense anymore. There’s also the difference<br>&gt; that .Self would be a runtime thing.<br>&gt;<br>&gt;<br>&gt;       What to do about optional requirements<br>&gt;<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/14046<br>&gt;<br>&gt; People commonly ask why optional only works on Objective-C protocols, and<br>&gt; the responses they get are usually that in Swift code you should reshape<br>&gt; your protocols. As a starting assumption, we’re not making optionl work in<br>&gt; Swift. So what do we do about this as part of the interoperability code?<br>&gt;<br>&gt; People do write these, but it’s often because they’re writing a delegate<br>&gt; protocol and they’re following the example of Cocoa frameworks.<br>&gt;<br>&gt; Roughly three things we can do:<br>&gt;<br>&gt;  1. Rename it to make it clearly an Objective-C interop feature. We could<br>&gt;     also forbid you actually spelling it in Swift code. That doesn’t work<br>&gt;     well because it breaks your ability to write code in Swift that has<br>&gt;     Objective-C clients — those clients won’t get the default<br>&gt;     implementation from the extensions like you would use with Swift<br>&gt;     clients instead of creating optional requirements.<br>&gt;  2. Modeling optional requirements as a function of optional type such<br>&gt;     as ((A, B) -&gt; C)? doesn’t work well. For example, properties can have<br>&gt;     optional type and they can be optional requirements, so you would end<br>&gt;     up having to deal with a lot of extra complexity due to<br>&gt;     double-optionals and likely want better code completion so you could<br>&gt;     type it all out.<br>&gt;  3. You force the default implementation to be visible from all callers,<br>&gt;     and you do the dispatch at the call site. The only advantage of this is<br>&gt;     that it takes optional requirements out of the language entirely. If<br>&gt;     you wanted to implement the (somewhat common) pattern of checking<br>&gt;     whether a type implements an optional requirement, you would have to<br>&gt;     use a respondsToSelector check.<br>&gt;<br>&gt; The best pattern we’ve seen for checking conformance and using different<br>&gt; code paths based on that is to use finer-grained protocols. (But there are<br>&gt; still issues with organizing your code that way.)<br>&gt;<br>&gt; The caller default (#3) is really the only way to get optional requirements<br>&gt; out of the type system. The weird code path in the compiler here is the<br>&gt; same as the weird code path as we have in AnyObject. But it doesn’t look<br>&gt; like we’re going to be able to do that.<br>&gt;<br>&gt; We can rename this as objcoptional or possibly demote it to an attribute.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Notes from Swift core team 2016-04-20 design discussion</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 21, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 21, 2016, at 9:58 AM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What to do about optional requirements<br></p><p>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/14046 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14046&gt;<br>&gt; Rename it to make it clearly an Objective-C interop feature. We could also forbid you actually spelling it in Swift code. That doesn’t work well because it breaks your ability to write code in Swift that has Objective-C clients — those clients won’t get the default implementation from the extensions like you would use with Swift clients instead of creating optional requirements.<br>&gt; Modeling optional requirements as a function of optional type such as ((A, B) -&gt; C)? doesn’t work well. For example, properties can have optional type and they can be optional requirements, so you would end up having to deal with a lot of extra complexity due to double-optionals and likely want better code completion so you could type it all out.<br>&gt; You force the default implementation to be visible from all callers, and you do the dispatch at the call site. The only advantage of this is that it takes optional requirements out of the language entirely. If you wanted to implement the (somewhat common) pattern of checking whether a type implements an optional requirement, you would have to use a respondsToSelector check.<br>Calling an optional method on a delegate protocol and using the result to judge whether you should have some default behavior to me does seem a bit flimsy in retrospect (I originally proposed things like importing optional methods with throws and having an unimplemented method error raised by default, etc). You aren’t really trying to judge that the behavior ‘currently’ is the default, but that there is no behavior defined thus you can reliably *always* use the default.<br></p><p>To that end, you need some way to detect static features of a type at runtime. Today we have respondsToSelector for objc types, and checking for conformance to different protocols.<br></p><p>I don’t think supporting optional protocols in swift could work unless there was also a respondsToSelector equivalent for native swift types.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/74aaff26/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/74aaff26/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Notes from Swift core team 2016-04-20 design discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 22, 2016 at 06:00:00pm</p></header><div class="content"><p>We could require optional methods which would return T to instead return OptionalResult&lt;T&gt; which is essentially an enum with values &#39;unimplemented&#39; and &#39;implemented(T)&#39;, i.e. essentially the same as Optional but as a separate type to avoid confusion when the real result would be &#39;T?&#39;.<br></p><p>Default implementations would answer &#39;unimplemented&#39;.<br></p><p>This would require the caller to handle the unimplemented default case explicitly.<br></p><p>-Thorsten <br></p><p><br>&gt; Am 22.04.2016 um 02:58 schrieb David Waite via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Apr 21, 2016, at 9:58 AM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What to do about optional requirements<br>&gt; <br>&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/14046<br>&gt;&gt; Rename it to make it clearly an Objective-C interop feature. We could also forbid you actually spelling it in Swift code. That doesn’t work well because it breaks your ability to write code in Swift that has Objective-C clients — those clients won’t get the default implementation from the extensions like you would use with Swift clients instead of creating optional requirements.<br>&gt;&gt; Modeling optional requirements as a function of optional type such as ((A, B) -&gt; C)? doesn’t work well. For example, properties can have optional type and they can be optional requirements, so you would end up having to deal with a lot of extra complexity due to double-optionals and likely want better code completion so you could type it all out.<br>&gt;&gt; You force the default implementation to be visible from all callers, and you do the dispatch at the call site. The only advantage of this is that it takes optional requirements out of the language entirely. If you wanted to implement the (somewhat common) pattern of checking whether a type implements an optional requirement, you would have to use a respondsToSelector check.<br>&gt; Calling an optional method on a delegate protocol and using the result to judge whether you should have some default behavior to me does seem a bit flimsy in retrospect (I originally proposed things like importing optional methods with throws and having an unimplemented method error raised by default, etc). You aren’t really trying to judge that the behavior ‘currently’ is the default, but that there is no behavior defined thus you can reliably *always* use the default.<br>&gt; <br>&gt; To that end, you need some way to detect static features of a type at runtime. Today we have respondsToSelector for objc types, and checking for conformance to different protocols.<br>&gt; <br>&gt; I don’t think supporting optional protocols in swift could work unless there was also a respondsToSelector equivalent for native swift types.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/80a13e24/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Notes from Swift core team 2016-04-20 design discussion</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 22, 2016 at 11:00:00am</p></header><div class="content"><p>Sure, but I personally want to configure delegates early, when the delegate is set.<br></p><p>It may be inappropriate to send a synthetic message through (e.g. give me the table row height for arbitrary index -1 so I can detect if you have overridden behavior)<br></p><p>A default implementation may help the caller, but some API do consider a non-default implementation to be a flag in itself.<br></p><p>I don’t think you can meet current objective-c usage and meaning of optional protocols by collapsing the flag into default method behavior. This would cause problems when porting the objective-c caller of the delegate interface to swift.<br></p><p>-DW<br></p><p>&gt; On Apr 22, 2016, at 10:01 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; We could require optional methods which would return T to instead return OptionalResult&lt;T&gt; which is essentially an enum with values &#39;unimplemented&#39; and &#39;implemented(T)&#39;, i.e. essentially the same as Optional but as a separate type to avoid confusion when the real result would be &#39;T?&#39;.<br>&gt; <br>&gt; Default implementations would answer &#39;unimplemented&#39;.<br>&gt; <br>&gt; This would require the caller to handle the unimplemented default case explicitly.<br>&gt; <br>&gt; -Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/ad56ed23/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/ad56ed23/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Notes from Swift core team 2016-04-20 design discussion</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April 22, 2016 at 08:00:00pm</p></header><div class="content"><p>I have the same thoughts and also have code that configures itself on<br>delegate setting.<br></p><p>On Fri, Apr 22, 2016 at 10:04 AM David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sure, but I personally want to configure delegates early, when the<br>&gt; delegate is set.<br>&gt;<br>&gt; It may be inappropriate to send a synthetic message through (e.g. give me<br>&gt; the table row height for arbitrary index -1 so I can detect if you have<br>&gt; overridden behavior)<br>&gt;<br>&gt; A default implementation may help the caller, but some API do consider a<br>&gt; non-default implementation to be a flag in itself.<br>&gt;<br>&gt; I don’t think you can meet current objective-c usage and meaning of<br>&gt; optional protocols by collapsing the flag into default method behavior.<br>&gt; This would cause problems when porting the objective-c caller of the<br>&gt; delegate interface to swift.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Apr 22, 2016, at 10:01 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt; We could require optional methods which would return T to instead return<br>&gt; OptionalResult&lt;T&gt; which is essentially an enum with values &#39;unimplemented&#39;<br>&gt; and &#39;implemented(T)&#39;, i.e. essentially the same as Optional but as a<br>&gt; separate type to avoid confusion when the real result would be &#39;T?&#39;.<br>&gt;<br>&gt; Default implementations would answer &#39;unimplemented&#39;.<br>&gt;<br>&gt; This would require the caller to handle the unimplemented default case<br>&gt; explicitly.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/3249ba27/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Notes from Swift core team 2016-04-20 design discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 23, 2016 at 10:00:00pm</p></header><div class="content"><p>Ah, yes, you are right, I didn’t think of configuring delegates when the delegate ist set.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 22.04.2016 um 19:04 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt; Sure, but I personally want to configure delegates early, when the delegate is set.<br>&gt; <br>&gt; It may be inappropriate to send a synthetic message through (e.g. give me the table row height for arbitrary index -1 so I can detect if you have overridden behavior)<br>&gt; <br>&gt; A default implementation may help the caller, but some API do consider a non-default implementation to be a flag in itself.<br>&gt; <br>&gt; I don’t think you can meet current objective-c usage and meaning of optional protocols by collapsing the flag into default method behavior. This would cause problems when porting the objective-c caller of the delegate interface to swift.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 10:01 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We could require optional methods which would return T to instead return OptionalResult&lt;T&gt; which is essentially an enum with values &#39;unimplemented&#39; and &#39;implemented(T)&#39;, i.e. essentially the same as Optional but as a separate type to avoid confusion when the real result would be &#39;T?&#39;.<br>&gt;&gt; <br>&gt;&gt; Default implementations would answer &#39;unimplemented&#39;.<br>&gt;&gt; <br>&gt;&gt; This would require the caller to handle the unimplemented default case explicitly.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160423/ba2d106d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 25, 2016 at 02:00:00pm</p></header><div class="content"><p>On 25.04.2016 4:57, Brent Royal-Gordon via swift-evolution wrote:<br> &gt;&gt; <br>https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br> &gt;<br> &gt; I&#39;m not totally clear what&#39;s being proposed here.<br> &gt;<br> &gt; Is this valid?<br> &gt; ...<br></p><p>Yes, I&#39;m also confused if it is a final proposal or some additions/changes <br>are expected here? As we were also discussing #Self (in meaning <br>&quot;placeholder for name of current defining type&quot;, resolving at compilation time)<br></p><p>Also, there were notes regarding this proposal by @Alex <br>Martini&lt;amartini at apple.com&gt; 21.04.2016 18:58 (quoted below), with <br>suggestion for &quot;dynamictype&quot; keyword / &quot;dynamicType&quot; standard library <br>function.<br></p><p>@Brent, your questions could be(in general) answered by replacing &quot;Self&quot; to <br>&quot;dynamicType&quot;, but actually there are more questions on this proposal, <br>which I suggest to discuss.<br></p><p>We have some mess *right now* with all these dynamicType/self/Self :<br></p><p>* &quot;self&quot; in meaning of current instance reference (OK), dynamicType is <br>dynamic type of the instance :<br>class A { func f() { self.something() } }<br>self.dynamicType is A<br></p><p>* &quot;self&quot; in meaning of current type object in static/class methods, <br>dynamicType is meta type<br>class A { static func f() { self.something() } }<br>self.dynamicType is A.Type<br></p><p>* &quot;Self&quot; in meaning &quot;placeholder to concrete defining class name&quot; :<br>protocol AProtocol {  func assignFrom(a: Self)  }<br>class A : AProtocol {  func assignFrom(a: A) {..}  } // &quot;A&quot; here,not &quot;Self&quot;<br></p><p>* &quot;Self&quot; in meaning of dynamic type in runtime:<br>class A {  func f() -&gt; Self { return self }  }<br></p><p><br>I&#39;d like to discuss how the following current code should looks in Swift 3.0 :<br></p><p>----------------------------<br>protocol Proto {<br>     func z() -&gt; Self<br>     func z(s: Self) // I propose the #Self here<br>}<br></p><p>class X: Proto {<br>     required init () {}<br>     func x() -&gt; Self { return self.dynamicType.init() }<br>     func z() -&gt; Self { return self }<br>     func z(s: X) {} // propose z(s: #Self) here<br></p><p>     static func staticF() -&gt; Self {..} // shouldn&#39;t be #Self here?<br>     class func classF() -&gt; Self {..}<br>}<br>----------------------------<br></p><p><br></p><p>&quot;Notes from Swift core team 2016-04-20 design discussion&quot; :<br></p><p>On 21.04.2016 18:58, Alex Martini via swift-evolution wrote:<br>&gt;<br>&gt;       SE-0068: Expanding Swift Self to class members and value types<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt;<br>&gt; We have one keyword left in the language, dynamicType, which is camel<br>&gt; cased. This proposal renames it to Self instead.<br>&gt;<br>&gt; In a static function today, self.dynamicType will give you a metatype but<br>&gt; the non-member Self will not. The most useful reason to reference it is to<br>&gt; call an initializer. It makes accessing the metatype weirder. It’s<br>&gt; not Self.Type; that’s a type — you have to spell it Self.type.<br>&gt;<br>&gt; Quiz time! What do each of the permutations mean?<br>&gt;<br>&gt; Self.self<br>&gt; self.Self<br>&gt; Self.Self<br>&gt; self.self<br>&gt;<br>&gt; The number of capital letters gives you the level of meta-ness. This is<br>&gt; very subtle, which is probably not a good thing.<br>&gt;<br>&gt; Another approach would be to introduce a new dynamictype keyword that<br>&gt; doesn’t need to be accessed as a member of self, and keep Self the way it<br>&gt; is.  Self should work in structs as a type alias.<br>&gt;<br>&gt; Why don’t we turn this into a standard library function? It’s not something<br>&gt; you need so often that the member access is very valuable. Putting it in<br>&gt; the standard library as dynamicType(_:) does still allow for that function<br>&gt; to be implemented using compiler magic.<br>&gt;<br>&gt; func dynamicType&lt;T&gt;(_: T) -&gt; T.Type { }<br>&gt;<br>&gt; We have a proposal to remove .self on types. One reason .self exists is to<br>&gt; avoid the mistake of writing let x = Int — the compiler will give you a<br>&gt; weird type error later on in code if the value of x is what we today<br>&gt; call Int.self but you meant to call the Int() initializer. Creating a<br>&gt; metatype is not a common operation, so doing it explicitly is a good thing.<br>&gt;<br>&gt; It’s weird that you can use the metatype directly to construct something or<br>&gt; to do member access, but you can’t access it as a bare value.<br>&gt;<br>&gt; Coming back to this proposal, if we removed .self why would we want to<br>&gt; add .Self?<br>&gt;<br>&gt; If you have a variable whose value is a metatype, you also keep its name in<br>&gt; lower case. So Self makes a little less sense from that aspect too.<br>&gt;<br>&gt; Another perspective is that .dynamicType is just an implicitly synthesized<br>&gt; property on all type.<br>&gt;<br>&gt; We do have other keywords that follow the dot on<br>&gt; types, Int.Type and Fooable.Protocol, so this isn’t the only thing. Those<br>&gt; things are magic nested types.<br>&gt;<br>&gt; Subjectively, having dynamicType as a member feels weird.<br>&gt;<br>&gt; If .self goes away, the four-self example above is simplified,<br>&gt; and .Self doesn’t make sense anymore. There’s also the difference<br>&gt; that .Self would be a runtime thing.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Is &quot;Self&quot; dynamically dispatched? What would the following program print?<br></p><p>class A: NSObject {<br>    static func myClassName() -&gt; String {<br>        return &quot;A&quot;<br>    }<br>    func hello() -&gt; String {<br>        return &quot;I am a \(Self.myClassName())&quot;<br>    }<br>}<br></p><p>class B: A {<br>    static func myClassName() -&gt; String {<br>        return &quot;B&quot;<br>    }<br>}<br></p><p>print(B.init().hello())<br></p><p>Because I think &quot;Self&quot; would only cause confusion if it is statically dispatched. assert(B.init().hello() == &quot;I am a B&quot;)<br></p><p>-Michael<br></p><p>&gt; Am 25.04.2016 um 13:33 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On 25.04.2016 4:57, Brent Royal-Gordon via swift-evolution wrote:<br>&gt; &gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt; &gt;<br>&gt; &gt; I&#39;m not totally clear what&#39;s being proposed here.<br>&gt; &gt;<br>&gt; &gt; Is this valid?<br>&gt; &gt; ...<br>&gt; <br>&gt; Yes, I&#39;m also confused if it is a final proposal or some additions/changes are expected here? As we were also discussing #Self (in meaning &quot;placeholder for name of current defining type&quot;, resolving at compilation time)<br>&gt; <br>&gt; Also, there were notes regarding this proposal by @Alex Martini&lt;amartini at apple.com&gt; 21.04.2016 18:58 (quoted below), with suggestion for &quot;dynamictype&quot; keyword / &quot;dynamicType&quot; standard library function.<br>&gt; <br>&gt; @Brent, your questions could be(in general) answered by replacing &quot;Self&quot; to &quot;dynamicType&quot;, but actually there are more questions on this proposal, which I suggest to discuss.<br>&gt; <br>&gt; We have some mess *right now* with all these dynamicType/self/Self :<br>&gt; <br>&gt; * &quot;self&quot; in meaning of current instance reference (OK), dynamicType is dynamic type of the instance :<br>&gt; class A { func f() { self.something() } }<br>&gt; self.dynamicType is A<br>&gt; <br>&gt; * &quot;self&quot; in meaning of current type object in static/class methods, dynamicType is meta type<br>&gt; class A { static func f() { self.something() } }<br>&gt; self.dynamicType is A.Type<br>&gt; <br>&gt; * &quot;Self&quot; in meaning &quot;placeholder to concrete defining class name&quot; :<br>&gt; protocol AProtocol {  func assignFrom(a: Self)  }<br>&gt; class A : AProtocol {  func assignFrom(a: A) {..}  } // &quot;A&quot; here,not &quot;Self&quot;<br>&gt; <br>&gt; * &quot;Self&quot; in meaning of dynamic type in runtime:<br>&gt; class A {  func f() -&gt; Self { return self }  }<br>&gt; <br>&gt; <br>&gt; I&#39;d like to discuss how the following current code should looks in Swift 3.0 :<br>&gt; <br>&gt; ----------------------------<br>&gt; protocol Proto {<br>&gt;    func z() -&gt; Self<br>&gt;    func z(s: Self) // I propose the #Self here<br>&gt; }<br>&gt; <br>&gt; class X: Proto {<br>&gt;    required init () {}<br>&gt;    func x() -&gt; Self { return self.dynamicType.init() }<br>&gt;    func z() -&gt; Self { return self }<br>&gt;    func z(s: X) {} // propose z(s: #Self) here<br>&gt; <br>&gt;    static func staticF() -&gt; Self {..} // shouldn&#39;t be #Self here?<br>&gt;    class func classF() -&gt; Self {..}<br>&gt; }<br>&gt; ----------------------------<br>&gt; <br>&gt; <br>&gt; <br>&gt; &quot;Notes from Swift core team 2016-04-20 design discussion&quot; :<br>&gt; <br>&gt; On 21.04.2016 18:58, Alex Martini via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;      SE-0068: Expanding Swift Self to class members and value types<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt;&gt; <br>&gt;&gt; We have one keyword left in the language, dynamicType, which is camel<br>&gt;&gt; cased. This proposal renames it to Self instead.<br>&gt;&gt; <br>&gt;&gt; In a static function today, self.dynamicType will give you a metatype but<br>&gt;&gt; the non-member Self will not. The most useful reason to reference it is to<br>&gt;&gt; call an initializer. It makes accessing the metatype weirder. It’s<br>&gt;&gt; not Self.Type; that’s a type — you have to spell it Self.type.<br>&gt;&gt; <br>&gt;&gt; Quiz time! What do each of the permutations mean?<br>&gt;&gt; <br>&gt;&gt; Self.self<br>&gt;&gt; self.Self<br>&gt;&gt; Self.Self<br>&gt;&gt; self.self<br>&gt;&gt; <br>&gt;&gt; The number of capital letters gives you the level of meta-ness. This is<br>&gt;&gt; very subtle, which is probably not a good thing.<br>&gt;&gt; <br>&gt;&gt; Another approach would be to introduce a new dynamictype keyword that<br>&gt;&gt; doesn’t need to be accessed as a member of self, and keep Self the way it<br>&gt;&gt; is.  Self should work in structs as a type alias.<br>&gt;&gt; <br>&gt;&gt; Why don’t we turn this into a standard library function? It’s not something<br>&gt;&gt; you need so often that the member access is very valuable. Putting it in<br>&gt;&gt; the standard library as dynamicType(_:) does still allow for that function<br>&gt;&gt; to be implemented using compiler magic.<br>&gt;&gt; <br>&gt;&gt; func dynamicType&lt;T&gt;(_: T) -&gt; T.Type { }<br>&gt;&gt; <br>&gt;&gt; We have a proposal to remove .self on types. One reason .self exists is to<br>&gt;&gt; avoid the mistake of writing let x = Int — the compiler will give you a<br>&gt;&gt; weird type error later on in code if the value of x is what we today<br>&gt;&gt; call Int.self but you meant to call the Int() initializer. Creating a<br>&gt;&gt; metatype is not a common operation, so doing it explicitly is a good thing.<br>&gt;&gt; <br>&gt;&gt; It’s weird that you can use the metatype directly to construct something or<br>&gt;&gt; to do member access, but you can’t access it as a bare value.<br>&gt;&gt; <br>&gt;&gt; Coming back to this proposal, if we removed .self why would we want to<br>&gt;&gt; add .Self?<br>&gt;&gt; <br>&gt;&gt; If you have a variable whose value is a metatype, you also keep its name in<br>&gt;&gt; lower case. So Self makes a little less sense from that aspect too.<br>&gt;&gt; <br>&gt;&gt; Another perspective is that .dynamicType is just an implicitly synthesized<br>&gt;&gt; property on all type.<br>&gt;&gt; <br>&gt;&gt; We do have other keywords that follow the dot on<br>&gt;&gt; types, Int.Type and Fooable.Protocol, so this isn’t the only thing. Those<br>&gt;&gt; things are magic nested types.<br>&gt;&gt; <br>&gt;&gt; Subjectively, having dynamicType as a member feels weird.<br>&gt;&gt; <br>&gt;&gt; If .self goes away, the four-self example above is simplified,<br>&gt;&gt; and .Self doesn’t make sense anymore. There’s also the difference<br>&gt;&gt; that .Self would be a runtime thing.<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 25, 2016 at 02:00:00pm</p></header><div class="content"><p>On Apr 25, 2016, at 11:18 AM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is &quot;Self&quot; dynamically dispatched? What would the following program print?<br>&gt; <br>&gt; class A: NSObject {<br>&gt;    static func myClassName() -&gt; String {<br>&gt;        return &quot;A&quot;<br>&gt;    }<br>&gt;    func hello() -&gt; String {<br>&gt;        return &quot;I am a \(Self.myClassName())&quot;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class B: A {<br>&gt;    static func myClassName() -&gt; String {<br>&gt;        return &quot;B&quot;<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; print(B.init().hello())<br>&gt; <br>&gt; Because I think &quot;Self&quot; would only cause confusion if it is statically dispatched. assert(B.init().hello() == &quot;I am a B&quot;)<br>&gt; <br>&gt; -Michael<br></p><p><br>The current Swift will not allow your second example to compile.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/66707e8c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0068: Expanding Swift Self to class members and value types</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 26, 2016 at 04:00:00pm</p></header><div class="content"><p>On 25.04.2016 20:18, Michael Peternell via swift-evolution wrote:<br>&gt; Is &quot;Self&quot; dynamically dispatched? What would the following program print?<br></p><p>In your example you can just replace &quot;Self&quot; to &quot;self.dynamicType&quot;, the more <br>questions appear if &quot;Self&quot; is used in protocol as result type and as <br>parameter type<br></p><p>&gt;<br>&gt; class A: NSObject {<br>&gt;     static func myClassName() -&gt; String {<br>&gt;         return &quot;A&quot;<br>&gt;     }<br>&gt;     func hello() -&gt; String {<br>&gt;         return &quot;I am a \(Self.myClassName())&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class B: A {<br>&gt;     static func myClassName() -&gt; String {<br>&gt;         return &quot;B&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; print(B.init().hello())<br>&gt;<br>&gt; Because I think &quot;Self&quot; would only cause confusion if it is statically dispatched. assert(B.init().hello() == &quot;I am a B&quot;)<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt;&gt; Am 25.04.2016 um 13:33 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; On 25.04.2016 4:57, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not totally clear what&#39;s being proposed here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is this valid?<br>&gt;&gt;&gt; ...<br>&gt;&gt;<br>&gt;&gt; Yes, I&#39;m also confused if it is a final proposal or some additions/changes are expected here? As we were also discussing #Self (in meaning &quot;placeholder for name of current defining type&quot;, resolving at compilation time)<br>&gt;&gt;<br>&gt;&gt; Also, there were notes regarding this proposal by @Alex Martini&lt;amartini at apple.com&gt; 21.04.2016 18:58 (quoted below), with suggestion for &quot;dynamictype&quot; keyword / &quot;dynamicType&quot; standard library function.<br>&gt;&gt;<br>&gt;&gt; @Brent, your questions could be(in general) answered by replacing &quot;Self&quot; to &quot;dynamicType&quot;, but actually there are more questions on this proposal, which I suggest to discuss.<br>&gt;&gt;<br>&gt;&gt; We have some mess *right now* with all these dynamicType/self/Self :<br>&gt;&gt;<br>&gt;&gt; * &quot;self&quot; in meaning of current instance reference (OK), dynamicType is dynamic type of the instance :<br>&gt;&gt; class A { func f() { self.something() } }<br>&gt;&gt; self.dynamicType is A<br>&gt;&gt;<br>&gt;&gt; * &quot;self&quot; in meaning of current type object in static/class methods, dynamicType is meta type<br>&gt;&gt; class A { static func f() { self.something() } }<br>&gt;&gt; self.dynamicType is A.Type<br>&gt;&gt;<br>&gt;&gt; * &quot;Self&quot; in meaning &quot;placeholder to concrete defining class name&quot; :<br>&gt;&gt; protocol AProtocol {  func assignFrom(a: Self)  }<br>&gt;&gt; class A : AProtocol {  func assignFrom(a: A) {..}  } // &quot;A&quot; here,not &quot;Self&quot;<br>&gt;&gt;<br>&gt;&gt; * &quot;Self&quot; in meaning of dynamic type in runtime:<br>&gt;&gt; class A {  func f() -&gt; Self { return self }  }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to discuss how the following current code should looks in Swift 3.0 :<br>&gt;&gt;<br>&gt;&gt; ----------------------------<br>&gt;&gt; protocol Proto {<br>&gt;&gt;    func z() -&gt; Self<br>&gt;&gt;    func z(s: Self) // I propose the #Self here<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class X: Proto {<br>&gt;&gt;    required init () {}<br>&gt;&gt;    func x() -&gt; Self { return self.dynamicType.init() }<br>&gt;&gt;    func z() -&gt; Self { return self }<br>&gt;&gt;    func z(s: X) {} // propose z(s: #Self) here<br>&gt;&gt;<br>&gt;&gt;    static func staticF() -&gt; Self {..} // shouldn&#39;t be #Self here?<br>&gt;&gt;    class func classF() -&gt; Self {..}<br>&gt;&gt; }<br>&gt;&gt; ----------------------------<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &quot;Notes from Swift core team 2016-04-20 design discussion&quot; :<br>&gt;&gt;<br>&gt;&gt; On 21.04.2016 18:58, Alex Martini via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;      SE-0068: Expanding Swift Self to class members and value types<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We have one keyword left in the language, dynamicType, which is camel<br>&gt;&gt;&gt; cased. This proposal renames it to Self instead.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In a static function today, self.dynamicType will give you a metatype but<br>&gt;&gt;&gt; the non-member Self will not. The most useful reason to reference it is to<br>&gt;&gt;&gt; call an initializer. It makes accessing the metatype weirder. It’s<br>&gt;&gt;&gt; not Self.Type; that’s a type — you have to spell it Self.type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Quiz time! What do each of the permutations mean?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Self.self<br>&gt;&gt;&gt; self.Self<br>&gt;&gt;&gt; Self.Self<br>&gt;&gt;&gt; self.self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The number of capital letters gives you the level of meta-ness. This is<br>&gt;&gt;&gt; very subtle, which is probably not a good thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another approach would be to introduce a new dynamictype keyword that<br>&gt;&gt;&gt; doesn’t need to be accessed as a member of self, and keep Self the way it<br>&gt;&gt;&gt; is.  Self should work in structs as a type alias.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Why don’t we turn this into a standard library function? It’s not something<br>&gt;&gt;&gt; you need so often that the member access is very valuable. Putting it in<br>&gt;&gt;&gt; the standard library as dynamicType(_:) does still allow for that function<br>&gt;&gt;&gt; to be implemented using compiler magic.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func dynamicType&lt;T&gt;(_: T) -&gt; T.Type { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We have a proposal to remove .self on types. One reason .self exists is to<br>&gt;&gt;&gt; avoid the mistake of writing let x = Int — the compiler will give you a<br>&gt;&gt;&gt; weird type error later on in code if the value of x is what we today<br>&gt;&gt;&gt; call Int.self but you meant to call the Int() initializer. Creating a<br>&gt;&gt;&gt; metatype is not a common operation, so doing it explicitly is a good thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s weird that you can use the metatype directly to construct something or<br>&gt;&gt;&gt; to do member access, but you can’t access it as a bare value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Coming back to this proposal, if we removed .self why would we want to<br>&gt;&gt;&gt; add .Self?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you have a variable whose value is a metatype, you also keep its name in<br>&gt;&gt;&gt; lower case. So Self makes a little less sense from that aspect too.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another perspective is that .dynamicType is just an implicitly synthesized<br>&gt;&gt;&gt; property on all type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We do have other keywords that follow the dot on<br>&gt;&gt;&gt; types, Int.Type and Fooable.Protocol, so this isn’t the only thing. Those<br>&gt;&gt;&gt; things are magic nested types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Subjectively, having dynamicType as a member feels weird.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If .self goes away, the four-self example above is simplified,<br>&gt;&gt;&gt; and .Self doesn’t make sense anymore. There’s also the difference<br>&gt;&gt;&gt; that .Self would be a runtime thing.<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
