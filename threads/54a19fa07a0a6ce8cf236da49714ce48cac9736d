<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ce7514c08622b5f30debe6d87dea32ac?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Patrick Lind</string> &lt;pklind0728 at gmail.com&gt;<p>August  2, 2016 at 10:00:00am</p></header><div class="content"><p>Sorry about dredging up an older topic! I was trying to search through the<br>mailing list to figure out the right place to reference and this seemed as<br>good as any... Also this is the first mailing list I&#39;ve ever joined and<br>first e-mail on said list so please forgive me if I&#39;m doing this wrong!<br></p><p>I wanted to ask a question on the future of doing Protocol-oriented<br>programming in conjunction with generics. Disclosure, I&#39;ve worked a lot<br>with C# so this would be the same idea as Interface oriented programming in<br>combination with Generics there.<br></p><p>Is there currently a way to do dependency injection using protocols with<br>generics? I&#39;ve linked to a StackOverflow question below that I&#39;ve asked<br>regarding this topic (again if that is a faux pas I apologize).<br></p><p>http://stackoverflow.com/questions/38619660/is-it-possible-to-pass-generic-protocols-into-a-constructor-for-proper-dependenc<br></p><p>The main aspect that I&#39;m interested in getting to is being able to properly<br>mock and unit test my code using dependency injection and Protocols. This<br>is a very, very useful way to architect your code in such a way as to<br>easily facilitate this kind of unit testing in conjunction with Mocking.<br></p><p>Please let me know if I&#39;m completely missing the boat here!<br></p><p>Thanks,<br></p><p>Patrick<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The “Complete Generics” goal for Swift 3 has been fairly ill-defined thus<br>fair, with just this short blurb in the list of goals:<br>&gt;<br>&gt; Complete generics: Generics are used pervasively in a number of Swift<br>libraries, especially the standard library. However, there are a number of<br>generics features the standard library requires to fully realize its<br>vision, including recursive protocol constraints, the ability to make a<br>constrained extension conform to a new protocol (i.e., an array of<br>Equatable elements is Equatable), and so on. Swift 3.0 should provide those<br>generics features needed by the standard library, because they affect the<br>standard library&#39;s ABI.<br>&gt; This message expands upon the notion of “completing generics”. It is not<br>a plan for Swift 3, nor an official core team communication, but it<br>collects the results of numerous discussions among the core team and Swift<br>developers, both of the compiler and the standard library. I hope to<br>achieve several things:<br>&gt;<br>&gt; Communicate a vision for Swift generics, building on the original<br>generics design document&lt;<br>https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, so we have<br>something concrete and comprehensive to discuss.<br>&gt; Establish some terminology that the Swift developers have been using for<br>these features, so our discussions can be more productive (“oh, you’re<br>proposing what we refer to as ‘conditional conformances’; go look over at<br>this thread”).<br>&gt; Engage more of the community in discussions of specific generics<br>features, so we can coalesce around designs for public review. And maybe<br>even get some of them implemented.<br>&gt;<br>&gt; A message like this can easily turn into a centithread&lt;<br>http://www.urbandictionary.com/define.php?term=centithread&gt;. To separate<br>concerns in our discussion, I ask that replies to this specific thread be<br>limited to discussions of the vision as a whole: how the pieces fit<br>together, what pieces are missing, whether this is the right long-term<br>vision for Swift, and so on. For discussions of specific language features,<br>e.g., to work out the syntax and semantics of conditional conformances or<br>discuss the implementation in compiler or use in the standard library,<br>please start a new thread based on the feature names I’m using.<br>&gt;<br>&gt; This message covers a lot of ground; I’ve attempted a rough<br>categorization of the various features, and kept the descriptions brief to<br>limit the overall length. Most of these aren’t my ideas, and any syntax I’m<br>providing is simply a way to express these ideas in code and is subject to<br>change. Not all of these features will happen, either soon or ever, but<br>they are intended to be a fairly complete whole that should mesh together.<br>I’ve put a * next to features that I think are important in the nearer term<br>vs. being interesting “some day”. Mostly, the *’s reflect features that<br>will have a significant impact on the Swift standard library’s design and<br>implementation.<br>&gt;<br>&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;<br>&gt; Removing unnecessary restrictions<br>&gt;<br>&gt; There are a number of restrictions to the use of generics that fall out<br>of the implementation in the Swift compiler. Removal of these restrictions<br>is a matter of implementation only; one need not introduce new syntax or<br>semantics to realize them. I’m listing them for two reasons: first, it’s an<br>acknowledgment that these features are intended to exist in the model we<br>have today, and, second, we’d love help with the implementation of these<br>features.<br>&gt;<br>&gt;<br>&gt; *Recursive protocol constraints<br>&gt;<br>&gt; Currently, an associated type cannot be required to conform to its<br>enclosing protocol (or any protocol that inherits that protocol). For<br>example, in the standard library SubSequence type of a Sequence should<br>itself be a Sequence:<br>&gt;<br>&gt; protocol Sequence {<br>&gt; associatedtype Iterator : IteratorProtocol<br>&gt; …<br>&gt; associatedtype SubSequence : Sequence // currently ill-formed, but should<br>be possible<br>&gt; }<br>&gt;<br>&gt; The compiler currently rejects this protocol, which is unfortunate: it<br>effectively pushes the SubSequence-must-be-a-Sequence requirement into<br>every consumer of SubSequence, and does not communicate the intent of this<br>abstraction well.<br>&gt;<br>&gt; Nested generics<br>&gt;<br>&gt; Currently, a generic type cannot be nested within another generic type,<br>e.g.<br>&gt;<br>&gt; struct X&lt;T&gt;{<br>&gt; struct Y&lt;U&gt;{ } // currently ill-formed, but should be possible<br>&gt; }<br>&gt;<br>&gt; There isn’t much to say about this: the compiler simply needs to be<br>improved to handle nested generics throughout.<br>&gt;<br>&gt;<br>&gt; Concrete same-type requirements<br>&gt;<br>&gt; Currently, a constrained extension cannot use a same-type constraint to<br>make a type parameter equivalent to a concrete type. For example:<br>&gt;<br>&gt; extension Array where Element == String {<br>&gt; func makeSentence() -&gt;String {<br>&gt; // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; This is a highly-requested feature that fits into the existing syntax and<br>semantics. Note that one could imagine introducing new syntax, e.g.,<br>extending “Array&lt;String&gt;”, which gets into new-feature territory: see the<br>section on “Parameterized extensions”.<br>&gt;<br>&gt; Parameterizing other declarations<br>&gt;<br>&gt; There are a number of Swift declarations that currently cannot have<br>generic parameters; some of those have fairly natural extensions to generic<br>forms that maintain their current syntax and semantics, but become more<br>powerful when made generic.<br>&gt;<br>&gt; Generic typealiases<br>&gt;<br>&gt; Typealiases could be allowed to carry generic parameters. They would<br>still be aliases (i.e., they would not introduce new types). For example:<br>&gt;<br>&gt; typealias StringDictionary&lt;Value&gt;= Dictionary&lt;String, Value&gt;<br>&gt;<br>&gt; var d1 = StringDictionary&lt;Int&gt;()<br>&gt; var d2: Dictionary&lt;String, Int&gt;= d1 // okay: d1 and d2 have the same<br>type, Dictionary&lt;String, Int&gt;<br>&gt;<br>&gt;<br>&gt; Generic subscripts<br>&gt;<br>&gt; Subscripts could be allowed to have generic parameters. For example, we<br>could introduce a generic subscript on a Collection that allows us to pull<br>out the values at an arbitrary set of indices:<br>&gt;<br>&gt; extension Collection {<br>&gt; subscript&lt;Indices: Sequence where Indices.Iterator.Element ==<br>Index&gt;(indices: Indices) -&gt;[Iterator.Element] {<br>&gt; get {<br>&gt; var result = [Iterator.Element]()<br>&gt; for index in indices {<br>&gt; result.append(self[index])<br>&gt; }<br>&gt;<br>&gt; return result<br>&gt; }<br>&gt;<br>&gt; set {<br>&gt; for (index, value) in zip(indices, newValue) {<br>&gt; self[index] = value<br>&gt; }<br>&gt; }<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Generic constants<br>&gt;<br>&gt; let constants could be allowed to have generic parameters, such that they<br>produce differently-typed values depending on how they are used. For<br>example, this is particularly useful for named literal values, e.g.,<br>&gt;<br>&gt; let π&lt;T : FloatLiteralConvertible&gt;: T =<br>3.141592653589793238462643383279502884197169399<br>&gt;<br>&gt; The Clang importer could make particularly good use of this when<br>importing macros.<br>&gt;<br>&gt;<br>&gt; Parameterized extensions<br>&gt;<br>&gt; Extensions themselves could be parameterized, which would allow some<br>structural pattern matching on types. For example, this would permit one to<br>extend an array of optional values, e.g.,<br>&gt;<br>&gt; extension&lt;T&gt;Array where Element == T? {<br>&gt; var someValues: [T] {<br>&gt; var result = [T]()<br>&gt; for opt in self {<br>&gt; if let value = opt { result.append(value) }<br>&gt; }<br>&gt; return result<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; We can generalize this to a protocol extensions:<br>&gt;<br>&gt; extension&lt;T&gt;Sequence where Element == T? {<br>&gt; var someValues: [T] {<br>&gt; var result = [T]()<br>&gt; for opt in self {<br>&gt; if let value = opt { result.append(value) }<br>&gt; }<br>&gt; return result<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Note that when one is extending nominal types, we could simplify the<br>syntax somewhat to make the same-type constraint implicit in the syntax:<br>&gt;<br>&gt; extension&lt;T&gt;Array&lt;T?&gt;{<br>&gt; var someValues: [T] {<br>&gt; var result = [T]()<br>&gt; for opt in self {<br>&gt; if let value = opt { result.append(value) }<br>&gt; }<br>&gt; return result<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; When we’re working with concrete types, we can use that syntax to improve<br>the extension of concrete versions of generic types (per “Concrete<br>same-type requirements”, above), e.g.,<br>&gt;<br>&gt; extension Array&lt;String&gt;{<br>&gt; func makeSentence() -&gt;String {<br>&gt; // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Minor extensions<br>&gt;<br>&gt; There are a number of minor extensions we can make to the generics system<br>that don’t fundamentally change what one can express in Swift, but which<br>can improve its expressivity.<br>&gt;<br>&gt; *Arbitrary requirements in protocols<br>&gt;<br>&gt; Currently, a new protocol can inherit from other protocols, introduce new<br>associated types, and add new conformance constraints to associated types<br>(by redeclaring an associated type from an inherited protocol). However,<br>one cannot express more general constraints. Building on the example from<br>“Recursive protocol constraints”, we really want the element type of a<br>Sequence’s SubSequence to be the same as the element type of the Sequence,<br>e.g.,<br>&gt;<br>&gt; protocol Sequence {<br>&gt; associatedtype Iterator : IteratorProtocol<br>&gt; …<br>&gt; associatedtype SubSequence : Sequence where SubSequence.Iterator.Element<br>== Iterator.Element<br>&gt; }<br>&gt;<br>&gt; Hanging the where clause off the associated type is protocol not ideal,<br>but that’s a discussion for another thread.<br>&gt;<br>&gt;<br>&gt; *Typealiases in protocols and protocol extensions<br>&gt;<br>&gt; Now that associated types have their own keyword (thanks!), it’s<br>reasonable to bring back “typealias”. Again with the Sequence protocol:<br>&gt;<br>&gt; protocol Sequence {<br>&gt; associatedtype Iterator : IteratorProtocol<br>&gt; typealias Element = Iterator.Element // rejoice! now we can refer to<br>SomeSequence.Element rather than SomeSequence.Iterator.Element<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Default generic arguments<br>&gt;<br>&gt; Generic parameters could be given the ability to provide default<br>arguments, which would be used in cases where the type argument is not<br>specified and type inference could not determine the type argument. For<br>example:<br>&gt;<br>&gt; public final class Promise&lt;Value, Reason=Error&gt;{ … }<br>&gt;<br>&gt; func getRandomPromise() -&gt;Promise&lt;Int, ErrorProtocol&gt;{ … }<br>&gt;<br>&gt; var p1: Promise&lt;Int&gt;= …<br>&gt; var p2: Promise&lt;Int, Error&gt;= p1 // okay: p1 and p2 have the same type<br>Promise&lt;Int, Error&gt;<br>&gt; var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int,<br>ErrorProtocol&gt;due to type inference<br>&gt;<br>&gt;<br>&gt; Generalized “class” constraints<br>&gt;<br>&gt; The “class” constraint can currently only be used for defining protocols.<br>We could generalize it to associated type and type parameter declarations,<br>e.g.,<br>&gt;<br>&gt; protocol P {<br>&gt; associatedtype A : class<br>&gt; }<br>&gt;<br>&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;<br>&gt; As part of this, the magical AnyObject protocol could be replaced with an<br>existential with a class bound, so that it becomes a typealias:<br>&gt;<br>&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;<br>&gt; See the “Existentials” section, particularly “Generalized existentials”,<br>for more information.<br>&gt;<br>&gt;<br>&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt;<br>&gt; When a superclass conforms to a protocol and has one of the protocol’s<br>requirements satisfied by a member of a protocol extension, that member<br>currently cannot be overridden by a subclass. For example:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func foo() { print(“P”) }<br>&gt; }<br>&gt;<br>&gt; class C : P {<br>&gt; // gets the protocol extension’s<br>&gt; }<br>&gt;<br>&gt; class D : C {<br>&gt; /*override not allowed!*/ func foo() { print(“D”) }<br>&gt; }<br>&gt;<br>&gt; let p: P = D()<br>&gt; p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;<br>&gt; D.foo should be required to specify “override” and should be called<br>dynamically.<br>&gt;<br>&gt;<br>&gt; Major extensions to the generics model<br>&gt;<br>&gt; Unlike the minor extensions, major extensions to the generics model<br>provide more expressivity in the Swift generics system and, generally, have<br>a much more significant design and implementation cost.<br>&gt;<br>&gt;<br>&gt; *Conditional conformances<br>&gt;<br>&gt; Conditional conformances express the notion that a generic type will<br>conform to a particular protocol only under certain circumstances. For<br>example, Array is Equatable only when its elements are Equatable:<br>&gt;<br>&gt; extension Array : Equatable where Element : Equatable { }<br>&gt;<br>&gt; func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt;Bool { … }<br>&gt;<br>&gt; Conditional conformances are a potentially very powerful feature. One<br>important aspect of this feature is how deal with or avoid overlapping<br>conformances. For example, imagine an adaptor over a Sequence that has<br>conditional conformances to Collection and MutableCollection:<br>&gt;<br>&gt; struct SequenceAdaptor&lt;S: Sequence&gt;: Sequence { }<br>&gt; extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt; extension SequenceAdaptor : MutableCollection where S: MutableCollection<br>{ }<br>&gt;<br>&gt; This should almost certainly be permitted, but we need to cope with or<br>reject “overlapping” conformances:<br>&gt;<br>&gt; extension SequenceAdaptor : Collection where S:<br>SomeOtherProtocolSimilarToCollection { } // trouble: two ways for<br>SequenceAdaptor to conform to Collection<br>&gt;<br>&gt; See the section on “Private conformances” for more about the issues with<br>having the same type conform to the same protocol multiple times.<br>&gt;<br>&gt;<br>&gt; Variadic generics<br>&gt;<br>&gt; Currently, a generic parameter list contains a fixed number of generic<br>parameters. If one has a type that could generalize to any number of<br>generic parameters, the only real way to deal with it today involves<br>creating a set of types. For example, consider the standard library’s “zip”<br>function. It returns one of these when provided with two arguments to zip<br>together:<br>&gt;<br>&gt; public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt; Sequence2 : Sequence&gt;: Sequence { … }<br>&gt;<br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt; sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt; -&gt;Zip2Sequence&lt;Sequence1, Sequence2&gt;{ … }<br>&gt;<br>&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;<br>&gt; public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt; Sequence2 : Sequence,<br>&gt; Sequence3 : Sequence&gt;: Sequence { … }<br>&gt;<br>&gt; public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 :<br>Sequence&gt;(<br>&gt; sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt; -&gt;Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt;{ … }<br>&gt;<br>&gt; Variadic generics would allow us to abstract over a set of generic<br>parameters. The syntax below is hopelessly influenced by C++11 variadic<br>templates&lt;http://www.jot.fm/issues/issue_2008_02/article2/&gt;(sorry), where<br>putting an ellipsis (“…”) to the left of a declaration makes it a<br>“parameter pack” containing zero or more parameters and putting an ellipsis<br>to the right of a type/expression/etc. expands the parameter packs within<br>that type/expression into separate arguments. The important part is that we<br>be able to meaningfully abstract over zero or more generic parameters, e.g.:<br>&gt;<br>&gt; public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt;: Iterator {<br>// zero or more type parameters, each of which conforms to IteratorProtocol<br>&gt; public typealias Element = (Iterators.Element...) // a tuple containing<br>the element types of each iterator in Iterators<br>&gt;<br>&gt; var (...iterators): (Iterators...) // zero or more stored properties, one<br>for each type in Iterators<br>&gt; var reachedEnd: Bool = false<br>&gt;<br>&gt; public mutating func next() -&gt;Element? {<br>&gt; if reachedEnd { return nil }<br>&gt;<br>&gt; guard let values = (iterators.next()...) { // call “next” on each of the<br>iterators, put the results into a tuple named “values&quot;<br>&gt; reachedEnd = true<br>&gt; return nil<br>&gt; }<br>&gt;<br>&gt; return values<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; public struct ZipSequence&lt;...Sequences : Sequence&gt;: Sequence {<br>&gt; public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;// get the<br>zip iterator with the iterator types of our Sequences<br>&gt;<br>&gt; var (...sequences): (Sequences...) // zero or more stored properties, one<br>for each type in Sequences<br>&gt;<br>&gt; // details ...<br>&gt; }<br>&gt;<br>&gt; Such a design could also work for function parameters, so we can pack<br>together multiple function arguments with different types, e.g.,<br>&gt;<br>&gt; public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...)<br>&gt; -&gt;ZipSequence&lt;Sequences...&gt;{<br>&gt; return ZipSequence(sequences...)<br>&gt; }<br>&gt;<br>&gt; Finally, this could tie into the discussions about a tuple “splat”<br>operator. For example:<br>&gt;<br>&gt; func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt;Result, // function taking<br>some number of arguments and producing Result<br>&gt; args: (Args...)) -&gt;Result { // tuple of arguments<br>&gt; return fn(args...) // expand the arguments in the tuple “args” into<br>separate arguments<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Extensions of structural types<br>&gt;<br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can be<br>extended. One could imagine extending structural types—particularly tuple<br>types—to allow them to, e.g., conform to protocols. For example, pulling<br>together variadic generics, parameterized extensions, and conditional<br>conformances, one could express “a tuple type is Equatable if all of its<br>element types are Equatable”:<br>&gt;<br>&gt; extension&lt;...Elements : Equatable&gt;(Elements...) : Equatable { //<br>extending the tuple type “(Elements…)” to be Equatable<br>&gt; }<br>&gt;<br>&gt; There are some natural bounds here: one would need to have actual<br>structural types. One would not be able to extend every type:<br>&gt;<br>&gt; extension&lt;T&gt;T { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt;<br>&gt; And before you think you’re cleverly making it possible to have a<br>conditional conformance that makes every type T that conforms to protocol P<br>also conform to protocol Q, see the section &quot;Conditional conformances via<br>protocol extensions”, below:<br>&gt;<br>&gt; extension&lt;T : P&gt;T : Q { // error: neither a structural nor a nominal type<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Syntactic improvements<br>&gt;<br>&gt; There are a number of potential improvements we could make to the<br>generics syntax. Such a list could go on for a very long time, so I’ll only<br>highlight some obvious ones that have been discussed by the Swift<br>developers.<br>&gt;<br>&gt; *Default implementations in protocols<br>&gt;<br>&gt; Currently, protocol members can never have implementations. We could<br>allow one to provide such implementations to be used as the default if a<br>conforming type does not supply an implementation, e.g.,<br>&gt;<br>&gt; protocol Bag {<br>&gt; associatedtype Element : Equatable<br>&gt; func contains(element: Element) -&gt;Bool<br>&gt;<br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>Element&gt;(elements: S) -&gt;Bool {<br>&gt; for x in elements {<br>&gt; if contains(x) { return true }<br>&gt; }<br>&gt; return false<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; struct IntBag : Bag {<br>&gt; typealias Element = Int<br>&gt; func contains(element: Int) -&gt;Bool { ... }<br>&gt;<br>&gt; // okay: containsAll requirement is satisfied by Bag’s default<br>implementation<br>&gt; }<br>&gt;<br>&gt; One can get this effect with protocol extensions today, hence the<br>classification of this feature as a (mostly) syntactic improvement:<br>&gt;<br>&gt; protocol Bag {<br>&gt; associatedtype Element : Equatable<br>&gt; func contains(element: Element) -&gt;Bool<br>&gt;<br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>Element&gt;(elements: S) -&gt;Bool<br>&gt; }<br>&gt;<br>&gt; extension Bag {<br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>Element&gt;(elements: S) -&gt;Bool {<br>&gt; for x in elements {<br>&gt; if contains(x) { return true }<br>&gt; }<br>&gt; return false<br>&gt; }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; *Moving the where clause outside of the angle brackets<br>&gt;<br>&gt; The “where” clause of generic functions comes very early in the<br>declaration, although it is generally of much less concern to the client<br>than the function parameters and result type that follow it. This is one of<br>the things that contributes to “angle bracket blindness”. For example,<br>consider the containsAll signature above:<br>&gt;<br>&gt; func containsAll&lt;S: Sequence where Sequence.Iterator.Element ==<br>Element&gt;(elements: S) -&gt;Bool<br>&gt;<br>&gt; One could move the “where” clause to the end of the signature, so that<br>the most important parts—name, generic parameter, parameters, result<br>type—precede it:<br>&gt;<br>&gt; func containsAll&lt;S: Sequence&gt;(elements: S) -&gt;Bool<br>&gt; where Sequence.Iterator.Element == Element<br>&gt;<br>&gt;<br>&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt;<br>&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to<br>compose protocols together, mostly to create values of existential type,<br>e.g.,<br>&gt;<br>&gt; var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;<br>&gt; It’s weird that it’s a type name that starts with a lowercase letter, and<br>most Swift developers probably never deal with this feature unless they<br>happen to look at the definition of Any:<br>&gt;<br>&gt; typealias Any = protocol&lt;&gt;<br>&gt;<br>&gt; “Any” might be a better name for this functionality. “Any” without<br>brackets could be a keyword for “any type”, and “Any” followed by brackets<br>could take the role of “protocol&lt;&gt;” today:<br>&gt;<br>&gt; var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;<br>&gt; That reads much better: “Any type that conforms to NSCoding and<br>NSCopying”. See the section &quot;Generalized existentials” for additional<br>features in this space.<br>&gt;<br>&gt; Maybe<br>&gt;<br>&gt; There are a number of features that get discussed from time-to-time,<br>while they could fit into Swift’s generics system, it’s not clear that they<br>belong in Swift at all. The important question for any feature in this<br>category is not “can it be done” or “are there cool things we can express”,<br>but “how can everyday Swift developers benefit from the addition of such a<br>feature?”. Without strong motivating examples, none of these “maybes” will<br>move further along.<br>&gt;<br>&gt; Dynamic dispatch for members of protocol extensions<br>&gt;<br>&gt; Only the requirements of protocols currently use dynamic dispatch, which<br>can lead to surprises:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; extension P {<br>&gt; func foo() { print(“P.foo()”)<br>&gt; func bar() { print(“P.bar()”)<br>&gt; }<br>&gt;<br>&gt; struct X : P {<br>&gt; func foo() { print(“X.foo()”)<br>&gt; func bar() { print(“X.bar()”)<br>&gt; }<br>&gt;<br>&gt; let x = X()<br>&gt; x.foo() // X.foo()<br>&gt; x.bar() // X.bar()<br>&gt;<br>&gt; let p: P = X()<br>&gt; p.foo() // X.foo()<br>&gt; p.bar() // P.bar()<br>&gt;<br>&gt; Swift could adopt a model where members of protocol extensions are<br>dynamically dispatched.<br>&gt;<br>&gt; Named generic parameters<br>&gt;<br>&gt; When specifying generic arguments for a generic type, the arguments are<br>always positional: Dictionary&lt;String, Int&gt;is a Dictionary whose Key type is<br>String and whose Value type is Int, by convention. One could permit the<br>arguments to be labeled, e.g.,<br>&gt;<br>&gt; var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt;<br>&gt; Such a feature makes more sense if Swift gains default generic arguments,<br>because generic argument labels would allow one to skip defaulted arguments.<br>&gt;<br>&gt; Generic value parameters<br>&gt;<br>&gt; Currently, Swift’s generic parameters are always types. One could imagine<br>allowing generic parameters that are values, e.g.,<br>&gt;<br>&gt; struct MultiArray&lt;T, let Dimensions: Int&gt;{ // specify the number of<br>dimensions to the array<br>&gt; subscript (indices: Int...) -&gt;T {<br>&gt; get {<br>&gt; require(indices.count == Dimensions)<br>&gt; // ...<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; A suitably general feature might allow us to express fixed-length array<br>or vector types as a standard library component, and perhaps also allow one<br>to implement a useful dimensional analysis library. Tackling this feature<br>potentially means determining what it is for an expression to be a<br>“constant expression” and diving into dependent-typing, hence the “maybe”.<br>&gt;<br>&gt; Higher-kinded types<br>&gt;<br>&gt; Higher-kinded types allow one to express the relationship between two<br>different specializations of the same nominal type within a protocol. For<br>example, if we think of the Self type in a protocol as really being<br>“Self&lt;T&gt;”, it allows us to talk about the relationship between “Self&lt;T&gt;”<br>and “Self&lt;U&gt;” for some other type U. For example, it could allow the “map”<br>operation on a collection to return a collection of the same kind but with<br>a different operation, e.g.,<br>&gt;<br>&gt; let intArray: Array&lt;Int&gt;= …<br>&gt; intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt; let intSet: Set&lt;Int&gt;= …<br>&gt; intSet.map { String($0) } // produces Set&lt;String&gt;<br>&gt;<br>&gt;<br>&gt; Potential syntax borrowed from one thread on higher-kinded types&lt;<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002736.html&gt;uses<br>~=<br>as a “similarity” constraint to describe a Functor protocol:<br>&gt;<br>&gt; protocol Functor {<br>&gt; associatedtype A<br>&gt; func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt;FB.A) -&gt;FB<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Specifying type arguments for uses of generic functions<br>&gt;<br>&gt; The type arguments of a generic function are always determined via type<br>inference. For example, given:<br>&gt;<br>&gt; func f&lt;T&gt;(t: T)<br>&gt;<br>&gt; one cannot directly specify T: either one calls “f” (and T is determined<br>via the argument’s type) or one uses “f” in a context where it is given a<br>particular function type (e.g., “let x: (Int) -&gt;Void = f” would infer T =<br>Int). We could permit explicit specialization here, e.g.,<br>&gt;<br>&gt; let x = f&lt;Int&gt;// x has type (Int) -&gt;Void<br>&gt;<br>&gt;<br>&gt; Unlikely<br>&gt;<br>&gt; Features in this category have been requested at various times, but they<br>don’t fit well with Swift’s generics system because they cause some part of<br>the model to become overly complicated, have unacceptable implementation<br>limitations, or overlap significantly with existing features.<br>&gt;<br>&gt; Generic protocols<br>&gt;<br>&gt; One of the most commonly requested features is the ability to<br>parameterize protocols themselves. For example, a protocol that indicates<br>that the Self type can be constructed from some specified type T:<br>&gt;<br>&gt; protocol ConstructibleFromValue&lt;T&gt;{<br>&gt; init(_ value: T)<br>&gt; }<br>&gt;<br>&gt; Implicit in this feature is the ability for a given type to conform to<br>the protocol in two different ways. A “Real” type might be constructible<br>from both Float and Double, e.g.,<br>&gt;<br>&gt; struct Real { … }<br>&gt; extension Real : ConstructibleFrom&lt;Float&gt;{<br>&gt; init(_ value: Float) { … }<br>&gt; }<br>&gt; extension Real : ConstructibleFrom&lt;Double&gt;{<br>&gt; init(_ value: Double) { … }<br>&gt; }<br>&gt;<br>&gt; Most of the requests for this feature actually want a different feature.<br>They tend to use a parameterized Sequence as an example, e.g.,<br>&gt;<br>&gt; protocol Sequence&lt;Element&gt;{ … }<br>&gt;<br>&gt; func foo(strings: Sequence&lt;String&gt;) { /// works on any sequence<br>containing Strings<br>&gt; // ...<br>&gt; }<br>&gt;<br>&gt; The actual requested feature here is the ability to say “Any type that<br>conforms to Sequence whose Element type is String”, which is covered by the<br>section on “Generalized existentials”, below.<br>&gt;<br>&gt; More importantly, modeling Sequence with generic parameters rather than<br>associated types is tantalizing but wrong: you don’t want a type conforming<br>to Sequence in multiple ways, or (among other things) your for..in loops<br>stop working, and you lose the ability to dynamically cast down to an<br>existential “Sequence” without binding the Element type (again, see<br>“Generalized existentials”). Use cases similar to the<br>ConstructibleFromValue protocol above seem too few to justify the potential<br>for confusion between associated types and generic parameters of protocols;<br>we’re better off not having the latter.<br>&gt;<br>&gt;<br>&gt; Private conformances<br>&gt;<br>&gt; Right now, a protocol conformance can be no less visible than the minimum<br>of the conforming type’s access and the protocol’s access. Therefore, a<br>public type conforming to a public protocol must provide the conformance<br>publicly. One could imagine removing that restriction, so that one could<br>introduce a private conformance:<br>&gt;<br>&gt; public protocol P { }<br>&gt; public struct X { }<br>&gt; extension X : internal P { … } // X conforms to P, but only within this<br>module<br>&gt;<br>&gt; The main problem with private conformances is the interaction with<br>dynamic casting. If I have this code:<br>&gt;<br>&gt; func foo(value: Any) {<br>&gt; if let x = value as? P { print(“P”) }<br>&gt; }<br>&gt;<br>&gt; foo(X())<br>&gt;<br>&gt; Under what circumstances should it print “P”? If foo() is defined within<br>the same module as the conformance of X to P? If the call is defined within<br>the same module as the conformance of X to P? Never? Either of the first<br>two answers requires significant complications in the dynamic casting<br>infrastructure to take into account the module in which a particular<br>dynamic cast occurred (the first option) or where an existential was formed<br>(the second option), while the third answer breaks the link between the<br>static and dynamic type systems—none of which is an acceptable result.<br>&gt;<br>&gt; Conditional conformances via protocol extensions<br>&gt;<br>&gt; We often get requests to make a protocol conform to another protocol.<br>This is, effectively, the expansion of the notion of “Conditional<br>conformances” to protocol extensions. For example:<br>&gt;<br>&gt; protocol P {<br>&gt; func foo()<br>&gt; }<br>&gt;<br>&gt; protocol Q {<br>&gt; func bar()<br>&gt; }<br>&gt;<br>&gt; extension Q : P { // every type that conforms to Q also conforms to P<br>&gt; func foo() { // implement “foo” requirement in terms of “bar&quot;<br>&gt; bar()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; func f&lt;T: P&gt;(t: T) { … }<br>&gt;<br>&gt; struct X : Q {<br>&gt; func bar() { … }<br>&gt; }<br>&gt;<br>&gt; f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;<br>&gt; This is an extremely powerful feature: is allows one to map the<br>abstractions of one domain into another domain (e.g., every Matrix is a<br>Graph). However, similar to private conformances, it puts a major burden on<br>the dynamic-casting runtime to chase down arbitrarily long and potentially<br>cyclic chains of conformances, which makes efficient implementation nearly<br>impossible.<br>&gt;<br>&gt; Potential removals<br>&gt;<br>&gt; The generics system doesn’t seem like a good candidate for a reduction in<br>scope; most of its features do get used fairly pervasively in the standard<br>library, and few feel overly anachronistic. However...<br>&gt;<br>&gt; Associated type inference<br>&gt;<br>&gt; Associated type inference is the process by which we infer the type<br>bindings for associated types from other requirements. For example:<br>&gt;<br>&gt; protocol IteratorProtocol {<br>&gt; associatedtype Element<br>&gt; mutating func next() -&gt;Element?<br>&gt; }<br>&gt;<br>&gt; struct IntIterator : IteratorProtocol {<br>&gt; mutating func next() -&gt;Int? { … } // use this to infer Element = Int<br>&gt; }<br>&gt;<br>&gt; Associated type inference is a useful feature. It’s used throughout the<br>standard library, and it helps keep associated types less visible to types<br>that simply want to conform to a protocol. On the other hand, associated<br>type inference is the only place in Swift where we have a global type<br>inference problem: it has historically been a major source of bugs, and<br>implementing it fully and correctly requires a drastically different<br>architecture to the type checker. Is the value of this feature worth<br>keeping global type inference in the Swift language, when we have<br>deliberatively avoided global type inference elsewhere in the language?<br>&gt;<br>&gt;<br>&gt; Existentials<br>&gt;<br>&gt; Existentials aren’t really generics per se, but the two systems are<br>closely intertwined due to their mutable dependence on protocols.<br>&gt;<br>&gt; *Generalized existentials<br>&gt;<br>&gt; The restrictions on existential types came from an implementation<br>limitation, but it is reasonable to allow a value of protocol type even<br>when the protocol has Self constraints or associated types. For example,<br>consider IteratorProtocol again and how it could be used as an existential:<br>&gt;<br>&gt; protocol IteratorProtocol {<br>&gt; associatedtype Element<br>&gt; mutating func next() -&gt;Element?<br>&gt; }<br>&gt;<br>&gt; let it: IteratorProtocol = …<br>&gt; it.next() // if this is permitted, it could return an “Any?”, i.e., the<br>existential that wraps the actual element<br>&gt;<br>&gt; Additionally, it is reasonable to want to constrain the associated types<br>of an existential, e.g., “a Sequence whose element type is String” could be<br>expressed by putting a where clause into “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per<br>“Renaming protocol&lt;…&gt;to Any&lt;…&gt;”):<br>&gt;<br>&gt; let strings: Any&lt;Sequence where .Iterator.Element == String&gt;= [“a”, “b”,<br>“c”]<br>&gt;<br>&gt; The leading “.” indicates that we’re talking about the dynamic type,<br>i.e., the “Self” type that’s conforming to the Sequence protocol. There’s<br>no reason why we cannot support arbitrary “where” clauses within the<br>“Any&lt;…&gt;”. This very-general syntax is a bit unwieldy, but common cases can<br>easily be wrapped up in a generic typealias (see the section “Generic<br>typealiases” above):<br>&gt;<br>&gt; typealias AnySequence&lt;Element&gt;= Any&lt;Sequence where .Iterator.Element ==<br>Element&gt;<br>&gt; let strings: AnySequence&lt;String&gt;= [“a”, “b”, “c”]<br>&gt;<br>&gt;<br>&gt; Opening existentials<br>&gt;<br>&gt; Generalized existentials as described above will still have trouble with<br>protocol requirements that involve Self or associated types in function<br>parameters. For example, let’s try to use Equatable as an existential:<br>&gt;<br>&gt; protocol Equatable {<br>&gt; func ==(lhs: Self, rhs: Self) -&gt;Bool<br>&gt; func !=(lhs: Self, rhs: Self) -&gt;Bool<br>&gt; }<br>&gt;<br>&gt; let e1: Equatable = …<br>&gt; let e2: Equatable = …<br>&gt; if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same<br>dynamic type<br>&gt;<br>&gt; One explicit way to allow such operations in a type-safe manner is to<br>introduce an “open existential” operation of some sort, which extracts and<br>gives a name to the dynamic type stored inside an existential. For example:<br>&gt;<br>&gt;<br>&gt; if let storedInE1 = e1 openas T { // T is a the type of storedInE1, a<br>copy of the value stored in e1<br>&gt; if let storedInE2 = e2 as? T { // is e2 also a T?<br>&gt; if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are<br>both of type T, which we know is Equatable<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/54a1736d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  3, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 7:58 AM, Patrick Lind via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; http://stackoverflow.com/questions/38619660/is-it-possible-to-pass-generic-protocols-into-a-constructor-for-proper-dependenc<br></p><p>I *think* that the specific feature you&#39;re looking for here is usually called &quot;enhanced existentials&quot;. This would have a different syntax—something like `RepositoryProtocol where Object == Zombie`—but would do basically the same thing.<br></p><p>The way to work around this in Swift 2 or 3 is to manually write a type-erasing wrapper:<br></p><p>	// Effectively a constructor of AnyRepository.<br>	public func anyRepository&lt;Repository: RepositoryProtocol&gt;(_ repository: Repository) -&gt; AnyRepository&lt;Repository.Object&gt; {<br>		// Don&#39;t double-wrap<br>		if let repo = repository as? AnyRepository&lt;Repository.Object&gt; {<br>			return repo<br>		}<br>		return ConcreteAnyRepository(repository: repository)<br>	}<br>	<br>	// This is the public face of the wrapper. It&#39;s actually abstract. Since it doesn&#39;t have the <br>	// RepositoryProtocol as a parameter, it &quot;erases&quot; the repository&#39;s type.<br>	public class AnyRepository&lt;Object&gt;: RepositoryProtocol {<br>		private init() {}<br>		<br>		public var items: Array&lt;Object&gt; {<br>			get { fatalError(&quot;abstract&quot;) }<br>			set { fatalError(&quot;abstract&quot;) }<br>		}<br>		<br>		public func insert(_ object: Object) {<br>			fatalError(&quot;abstract&quot;)<br>		}<br>		<br>		public func deleteAll() {<br>			fatalError(&quot;abstract&quot;)<br>		}<br>	}<br>	<br>	// All instances of AnyRepository will actually belong to this concrete subclass, which <br>	// *does* have the specific RepositoryProtocol as a parameter.<br>	private class ConcreteAnyRepository&lt;Repository: RepositoryProtocol&gt;: AnyRepository&lt;Repository.Object&gt; {<br>		private let repository: Repository<br>		<br>		override var items: Array&lt;Object&gt; {<br>			get { return repository.items }<br>			set { repository.items = newValue }<br>		}<br>		<br>		override func insert(_ object: Object) {<br>			repository.insert(object)<br>		}<br>		<br>		override func deleteAll() {<br>			repository.deleteAll()<br>		}<br>	}<br></p><p>And then your ZombieServiceProtocol can look like:<br></p><p>	protocol ZombieServiceProtocol {<br>	    func fetchZombies()<br>	<br>	    var zombieRepository: AnyRepository&lt;Zombie&gt; { get set }<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
