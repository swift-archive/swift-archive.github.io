<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April  5, 2016 at 01:00:00pm</p></header><div class="content"><p>on Mon Apr 04 2016, Joe Groff &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of “Allow Swift types to provide custom Objective-C representations”<br>&gt; begins now and runs through April 11, 2016. The proposal is available here:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should<br>&gt; be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt; manager. When replying, please try to keep the proposal link at the top of the<br>&gt; message:<br>&gt;<br>&gt; Proposal link:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt;<br>&gt; Reply text<br>&gt;<br>&gt; Other replies<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review through<br>&gt; constructive criticism and, eventually, determine the direction of Swift. When<br>&gt; writing your review, here are some questions you might want to answer in your<br>&gt; review:<br>&gt;<br>&gt; • What is your evaluation of the proposal?<br>&gt; • Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br>&gt; • If you have used other languages or libraries with a similar feature, how do<br>&gt; you feel that this proposal compares to those?<br>&gt; • How much effort did you put into your review? A glance, a quick reading, or an<br>&gt; in-depth study?<br></p><p>A few thoughts: <br></p><p>1. It would have made it easier to evaluate if the proposal had not<br>   talked about removing _ObjectiveCBridgeable and replacing it with a<br>   new ObjectiveCBridgeable protocol, but what could more accurately be<br>   described as de-underscoring the existing protocol and slightly<br>   modernizing its API.  The existing protocol was always intended to be<br>   suitable for general use this way, and the design remains<br>   substantially unchanged, so I support the proposal in principle.<br></p><p>2. These two APIs should look different IMO:<br></p><p>      init?(bridgedFromObjectiveC: ObjectiveCType)<br>      init(unconditionallyBridgedFromObjectiveC: ObjectiveCType?)<br></p><p>    they should definitely use “bridging” instead of “bridged,” since the<br>    phrase describes *how* the conversion is going to be done.<br></p><p>      init?(bridgingFromObjectiveC: ObjectiveCType)<br>      init(unconditionallyBridgingFromObjectiveC: ObjectiveCType?)<br></p><p>    Then, the “ObjectiveC” in the names looks like redundant type<br>    information, suggesting this would be better:<br></p><p>      init?(bridgingFrom: ObjectiveCType)<br>      init(unconditionallyBridgingFrom: ObjectiveCType?)<br></p><p>    But then, these *are* intended to be full-width type conversions,<br>    are they not?  Why not these:<br></p><p>      init?(_ source: ObjectiveCType)<br>      init(_ source: ObjectiveCType?)<br></p><p>    ?  If any of these transformations are wrong, it would good to have<br>    a rationale as to why.<br></p><p><br>3. Is this proposal introducing a backdoor people can exploit to create<br>   user-defined implicit conversions?  If so, shouldn&#39;t that worry us?<br></p><p>4. This proposal should probably support creating a type that only<br>   bridges *from* Objective-C, to handle bridging mutable Objective-C<br>   classes without an immutable base class to value types (anything else<br>   breaks one of the languages&#39; expectations of value or reference<br>   semantics).  This suggests a hierarchy of two protocols might be<br>   warranted.<br></p><p>5. For the version of the protocol that does bridge back to Objective-C,<br>   maybe something should be done to make it more clear that the<br>   ObjectiveCType must be immutable.  Perhaps that means doing this<br>   without a protocol hierarchy and using a different associated type<br>   name in the two protocols; I don&#39;t know.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br></p><p>&gt;    But then, these *are* intended to be full-width type conversions,<br>&gt;    are they not?  Why not these:<br>&gt; <br>&gt;      init?(_ source: ObjectiveCType)<br>&gt;      init(_ source: ObjectiveCType?)<br>&gt; <br>&gt;    ?  If any of these transformations are wrong, it would good to have<br>&gt;    a rationale as to why.<br></p><p>I really don&#39;t like these two differing only by the optionality of their argument and return type, especially if they&#39;re going to have *no* argument label, which will make them look very attractive. And the unconditional one has many strange semantics—the extra layer of optionality on the argument, the fact that it may *lazily* crash if you access a sub-object which isn&#39;t permitted, etc. So I would at least label that one:<br></p><p>	init?(_ source: ObjectiveCType)<br>	init(forced source: ObjectiveCType?)<br></p><p>I&#39;m also a little worried about having an `init?(_:)` when a particular conversion might reasonably always succeed. The lack of a label will imply to users that this is something they can use directly; <br></p><p>&gt; 3. Is this proposal introducing a backdoor people can exploit to create<br>&gt;   user-defined implicit conversions?  If so, shouldn&#39;t that worry us?<br></p><p>This proposal reads to me like it permits conversions by casting, but not by simply using one type where another belongs.<br></p><p>&gt; 4. This proposal should probably support creating a type that only<br>&gt;   bridges *from* Objective-C, to handle bridging mutable Objective-C<br>&gt;   classes without an immutable base class to value types (anything else<br>&gt;   breaks one of the languages&#39; expectations of value or reference<br>&gt;   semantics).  This suggests a hierarchy of two protocols might be<br>&gt;   warranted.<br></p><p>I agree.<br></p><p>Here&#39;s an alternative design. It does a few things:<br></p><p>* Splits bridging from and bridging to Objective-C so they can be applied independently.<br>* Splits conditional and unconditional bridging from Objective-C. <br>* Explicitly marks Objective-C types with their Swift equivalents, even in Swift, to make it clear that each Objective-C type bridges to exactly one Swift type, and which type that is. (This allows you to have multiple conversions between various Swift types and a single Objective-C type, while explicitly specifying which one, if any, should be used when translating Objective-C APIs to Swift.)<br></p><p>I&#39;m using the proposed SE-0041 protocol naming conventions (https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md) to name the protocols. I&#39;m also assuming the presence of conditional conformances and where clauses on associated types; these protocols would have to be temporarily hobbled to work within the type system&#39;s current capabilities.<br></p><p>	/// Conforming types can be cast from Self to ObjectiveCType using `as` (or a subtype using `as?` <br>	/// or `as!`), and Swift APIs taking or returning Self are exposed to Objective-C as ObjectiveCType.<br>	protocol ObjectiveCRepresentable {<br>		associatedtype ObjectiveCType: AnyObject<br>		func bridged() -&gt; ObjectiveCType<br>	}<br>	<br>	/// Conforming types can be cast from ObjectiveCType or a subtype to Self using `as?` or `as!`.<br>	/// <br>	/// -SeeAlso: ObjectiveCUnconditionallyCreatable, ObjectiveCBridgeable<br>	protocol ObjectiveCCreatable {<br>		associatedtype ObjectiveCType: AnyObject<br>		init?(_ source: ObjectiveCType)<br>		init(forced source: ObjectiveCType?)<br>	}<br>	<br>	/// Conforming types can be cast from UnconditionalObjectiveCType to Self using `as`.<br>	/// <br>	/// -Note:	A type can conform to both this protocol and ObjectiveCCreatable to <br>	///		allow both an unconditional exact cast and a conditional inexact one. <br>	///		For instance, Array can have ObjectiveCType = NSArray&lt;AnyObject&gt; <br>	///      	and UnconditionalObjectiveCType = NSArray&lt;T&gt;.<br>	protocol ObjectiveCUnconditionallyCreatable {<br>		associatedtype UnconditionalObjectiveCType: AnyObject<br>		init(_ source: UnconditionalObjectiveCType?)<br>	}<br>	<br>	/// Conforming types are translated from Self to SwiftType in APIs imported from Objective-C.<br>	/// <br>	/// -Note:	Objective-C headers can apply this protocol to their classes using the<br>	///		SWIFT_BRIDGED(&quot;SwiftType&quot;) attribute.<br>	/// -Remark: This could instead be indicated with a Swift-side attribute.<br>	protocol ObjectiveCBridgeable: class {<br>		associatedtype SwiftType: ObjectiveCUnconditionallyCreatable where SwiftType.UnconditionalObjectiveCType == Self<br>	}<br></p><p>Interestingly, another alternative would be to remove the bridging semantic from ObjectiveCRepresentable and put it in a subprotocol:<br></p><p>	/// Conforming types can be cast from Self to ObjectiveCType using `as` (or a subtype using `as?` <br>	/// or `as!`).<br>	protocol ObjectiveCRepresentable { … }<br>	<br>	/// Conforming types will be translated from Self to ObjectiveCType in APIs exported to Objective-C<br>	protocol SwiftToObjectiveCBridgeable: ObjectiveCRepresentable {}<br>	<br>	/// Conforming types are translated from Self to SwiftType in APIs imported from Objective-C.<br>	/// <br>	/// -Note:	Objective-C headers can apply this protocol to their classes using the<br>	///		SWIFT_BRIDGED(&quot;SwiftType&quot;) attribute.<br>	protocol ObjectiveCToSwiftBridgeable: class {<br>		associatedtype SwiftType: ObjectiveCUnconditionallyCreatable where SwiftType.UnconditionalObjectiveCType == Self<br>	}<br></p><p>Then the Representable protocol and the two Creatable protocols are no longer Objective-C-specific—they simply indicate that a type can be cast to an equivalent object type. We can then make them into ObjectRepresentable, ObjectCreatable, and ObjectUnconditionalCreatable. (This is good because we will presumably want to continue, for instance, casting NSNumber to Int in Corelibs Foundation code.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April  5, 2016 at 06:00:00pm</p></header><div class="content"><p>(Sorry, sent without finishing a sentence.)<br></p><p>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt; <br>&gt;&gt;   But then, these *are* intended to be full-width type conversions,<br>&gt;&gt;   are they not?  Why not these:<br>&gt;&gt; <br>&gt;&gt;     init?(_ source: ObjectiveCType)<br>&gt;&gt;     init(_ source: ObjectiveCType?)<br>&gt;&gt; <br>&gt;&gt;   ?  If any of these transformations are wrong, it would good to have<br>&gt;&gt;   a rationale as to why.<br>&gt; <br>&gt; I really don&#39;t like these two differing only by the optionality of their argument and return type, especially if they&#39;re going to have *no* argument label, which will make them look very attractive. And the unconditional one has many strange semantics—the extra layer of optionality on the argument, the fact that it may *lazily* crash if you access a sub-object which isn&#39;t permitted, etc. So I would at least label that one:<br>&gt; <br>&gt; 	init?(_ source: ObjectiveCType)<br>&gt; 	init(forced source: ObjectiveCType?)<br>&gt; <br>&gt; I&#39;m also a little worried about having an `init?(_:)` when a particular conversion might reasonably always succeed. The lack of a label will imply to users that this is something they can use directly; <br></p><p>if the conversion always succeeds, though, it will unnecessarily be returning an optional value. (And from what I can tell, you can&#39;t satisfy an optional return value in a protocol with a member having a non-optional return value. Not sure why that is.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; • What is your evaluation of the proposal?<br></p><p>+1, been a supporter of this idea from the very beginning.<br></p><p>&gt; • Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>It is when doing hybrid (Objective-C plus Swift) development.<br></p><p>&gt; • Does this proposal fit well with the feel and direction of Swift?<br></p><p>Not with the direction of Swift itself but it certainly helps with the transition from Objective-C.<br></p><p>&gt; • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Been following the topic since the beginning.<br></p><p>–––<br></p><p>One thing,<br></p><p>I noticed the proposal includes @warn_unused_result attribute in one of code examples. As this will be removed per SE-0047, I suggest removing the attribute from the proposal code examples.<br></p><p><br>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 06.04.2016, o godz. 03:08:<br>&gt; <br>&gt; (Sorry, sent without finishing a sentence.)<br>&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md<br>&gt;&gt; <br>&gt;&gt;&gt;  But then, these *are* intended to be full-width type conversions,<br>&gt;&gt;&gt;  are they not?  Why not these:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    init?(_ source: ObjectiveCType)<br>&gt;&gt;&gt;    init(_ source: ObjectiveCType?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  ?  If any of these transformations are wrong, it would good to have<br>&gt;&gt;&gt;  a rationale as to why.<br>&gt;&gt; <br>&gt;&gt; I really don&#39;t like these two differing only by the optionality of their argument and return type, especially if they&#39;re going to have *no* argument label, which will make them look very attractive. And the unconditional one has many strange semantics—the extra layer of optionality on the argument, the fact that it may *lazily* crash if you access a sub-object which isn&#39;t permitted, etc. So I would at least label that one:<br>&gt;&gt; <br>&gt;&gt; 	init?(_ source: ObjectiveCType)<br>&gt;&gt; 	init(forced source: ObjectiveCType?)<br>&gt;&gt; <br>&gt;&gt; I&#39;m also a little worried about having an `init?(_:)` when a particular conversion might reasonably always succeed. The lack of a label will imply to users that this is something they can use directly; <br>&gt; <br>&gt; if the conversion always succeeds, though, it will unnecessarily be returning an optional value. (And from what I can tell, you can&#39;t satisfy an optional return value in a protocol with a member having a non-optional return value. Not sure why that is.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/33946caa/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0058: Allow Swift types to provide custom Objective-C representations</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 5, 2016, at 1:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A few thoughts: <br>&gt; <br>&gt; 1. It would have made it easier to evaluate if the proposal had not<br>&gt;   talked about removing _ObjectiveCBridgeable and replacing it with a<br>&gt;   new ObjectiveCBridgeable protocol, but what could more accurately be<br>&gt;   described as de-underscoring the existing protocol and slightly<br>&gt;   modernizing its API.  The existing protocol was always intended to be<br>&gt;   suitable for general use this way, and the design remains<br>&gt;   substantially unchanged, so I support the proposal in principle.<br></p><p>You can blame that on me; After changes from feedback I felt it different enough to call it a replacement.<br></p><p><br></p><p>&gt; <br>&gt; 2. These two APIs should look different IMO:<br>&gt; <br>&gt;      init?(bridgedFromObjectiveC: ObjectiveCType)<br>&gt;      init(unconditionallyBridgedFromObjectiveC: ObjectiveCType?)<br>&gt; <br>&gt;    they should definitely use “bridging” instead of “bridged,” since the<br>&gt;    phrase describes *how* the conversion is going to be done.<br></p><p>Fair enough, IIRC some of the naming guidelines were still being decided when I wrote it up. <br>I’m not sure if the proposal needs to go back for revision and review again or if we can make minor changes during review but either way cleaning up the names (and removing the deprecated @warn_unused_result attribute) should be no problem.<br></p><p><br></p><p>&gt; <br>&gt; 3. Is this proposal introducing a backdoor people can exploit to create<br>&gt;   user-defined implicit conversions?  If so, shouldn&#39;t that worry us?<br></p><p>No. I explicitly call out in the doc that no implicit conversions are allowed except for the automatically generated thunks when importing Objective-C APIs into Swift. You must do an explicit cast in situations where the API can’t import automatically (eg: UnsafePointer&lt;ObjCType&gt;).<br></p><p><br></p><p>&gt; <br>&gt; 4. This proposal should probably support creating a type that only<br>&gt;   bridges *from* Objective-C, to handle bridging mutable Objective-C<br>&gt;   classes without an immutable base class to value types (anything else<br>&gt;   breaks one of the languages&#39; expectations of value or reference<br>&gt;   semantics).  This suggests a hierarchy of two protocols might be<br>&gt;   warranted.<br>&gt; <br></p><p>I’m not quite following why it breaks the expectations of value or reference semantics. Are you talking about allowing a Swift type to bridge to either a mutable or immutable variant in ObjC? In the proposal as written you’d presumably specify the bridging type as the mutable variant but importing the immutable variant does present a problem (it would violate the ambiguity rules if the types were defined in Swift) - is that what you were driving at?<br></p><p><br></p><p>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/0f5af826/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
