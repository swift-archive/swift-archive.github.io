<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>Proposal link: https://github.com/apple/swift-evolution/blob/master/proposals/0097-negative-attributes.md<br></p><p>Hello Swift Community,<br></p><p>The review of SE-0097: &quot;Normalizing naming for &quot;negative&quot; attributes&quot; ran from May 24…30, 2016. The proposal is *rejected* for Swift 3.  <br></p><p>The core team agrees with the principle guiding the proposal (that negative attributes should start with “non” instead of “no”) and highly values standardized naming for attributes.  The community was lukewarm about “nonescaping” but pretty significantly opposed to “nonreturning”.<br></p><p>The core team discussed this at length and agreed that the problem identified by the proposal needs to be solved, but prefers to explore directions that would define away these attributes completely:<br></p><p><br>1) For noreturn, the core team prefers to explore a solution where a function can be declared as returning an non-constructable “bottom” type (e.g. an enum with zero cases).  This would lead to something like:<br></p><p>	func abort() -&gt; NoReturn { … }<br></p><p>This will require some new support in the compiler, but should flow better through the type system than @noreturn in function composition and other applications.  Joe Groff offered to write a proposal for this.<br></p><p><br>2) For noescape, the core team feels that the right solution is for closure arguments to *default* to noescape, which means that the attribute we should really need is @escaping.<br></p><p><br>Many thanks to Erica Sadun for driving this discussion and writing the proposal.  This was an important topic for the community and core team to re-evalute, and it was very effective at forcing progress.<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jun 1, 2016, at 9:02 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; 2) For noescape, the core team feels that the right solution is for closure arguments to *default* to noescape, which means that the attribute we should really need is @escaping.<br></p><p>To provide some more details, this approach has the following advantages:<br></p><p>- Most functional algorithms written in pure Swift will benefit because they are naturally noescape.  The core team feels that this will reduce the boilerplate involved with writing these algorithms.<br></p><p>- The compiler has enough logic in it to provide a great QoI experience when a developer doesn’t think about escaping, and tries to escape a closure - it can provide a fixit that suggests adding @escaping.<br></p><p>- Recent changes (to disallow escaping closures to close over an inout parameter) are pushing the language to prefer noescape closures.  noescape closures have also always been the preferred default, since they eliminate a class of retain cycle issues.<br></p><p>- &quot;@autoclosure(escaping)&quot; can be simplified and standardized to &quot;@autoclosure @escaping”<br></p><p><br>The two primary concerns with taking this direction were that it is would adversely impact resilience, and that imported Objective-C APIs would be too annoying to work with, because the compiler would have to be conservative and assume they are escaping:<br></p><p><br></p><p>On resilience, the concern with this approach is that an API may not thinking about whether a closure parameter should be escaping or not, and this behavior makes it possible that someone could write “V1” of an API and not accidentally promise noescape semantics, but then need it in “V2” of the same API.  <br></p><p>John McCall pointed out that resilience in the type system is different than resilience in practice: An API changing to capture a closure and use it long after it was originally passed is likely to break the clients regardless of whether the type system captures this as an issue.  He argues (and the argument is strong IMO) that it is *better* for resilient APIs to default to @noescape, since that forces the author of V2 to think about whether they are breaking their clients.  If they are doing something that is “logically” noescape in their V2, then they can unsafe bitcast away the escaping aspect of the closure.  This is better than changing the client’s view of the API in any case.<br></p><p><br>On imported Objective-C API, the core team did a quick study of the Cocoa APIs and found that most closure/block parameters are escaping in practice.  As such, the core team feels that it isn’t overly burdensome to ask that imported Objective-C APIs annotate their semantically noescape block parameters with the clang __attribute__((noescape)) attribute.<br></p><p><br>I’m happy to write up this proposal, but won’t have cycles to do so for several weeks.  If someone else wants to take it up, that would be great :-)<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>June  2, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;d like to write this proposal.<br></p><p>On Thu, Jun 2, 2016 at 12:11 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jun 1, 2016, at 9:02 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt; 2) For noescape, the core team feels that the right solution is for<br>&gt; closure arguments to *default* to noescape, which means that the attribute<br>&gt; we should really need is @escaping.<br>&gt;<br>&gt; To provide some more details, this approach has the following advantages:<br>&gt;<br>&gt; - Most functional algorithms written in pure Swift will benefit because<br>&gt; they are naturally noescape.  The core team feels that this will reduce the<br>&gt; boilerplate involved with writing these algorithms.<br>&gt;<br>&gt; - The compiler has enough logic in it to provide a great QoI experience<br>&gt; when a developer doesn’t think about escaping, and tries to escape a<br>&gt; closure - it can provide a fixit that suggests adding @escaping.<br>&gt;<br>&gt; - Recent changes (to disallow escaping closures to close over an inout<br>&gt; parameter) are pushing the language to prefer noescape closures.  noescape<br>&gt; closures have also always been the preferred default, since they eliminate<br>&gt; a class of retain cycle issues.<br>&gt;<br>&gt; - &quot;@autoclosure(escaping)&quot; can be simplified and standardized to<br>&gt; &quot;@autoclosure @escaping”<br>&gt;<br>&gt;<br>&gt; The two primary concerns with taking this direction were that it is would<br>&gt; adversely impact resilience, and that imported Objective-C APIs would be<br>&gt; too annoying to work with, because the compiler would have to be<br>&gt; conservative and assume they are escaping:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On resilience, the concern with this approach is that an API may not<br>&gt; thinking about whether a closure parameter should be escaping or not, and<br>&gt; this behavior makes it possible that someone could write “V1” of an API and<br>&gt; not accidentally promise noescape semantics, but then need it in “V2” of<br>&gt; the same API.<br>&gt;<br>&gt; John McCall pointed out that resilience in the type system is different<br>&gt; than resilience in practice: An API changing to capture a closure and use<br>&gt; it long after it was originally passed is likely to break the clients<br>&gt; regardless of whether the type system captures this as an issue.  He argues<br>&gt; (and the argument is strong IMO) that it is *better* for resilient APIs to<br>&gt; default to @noescape, since that forces the author of V2 to think about<br>&gt; whether they are breaking their clients.  If they are doing something that<br>&gt; is “logically” noescape in their V2, then they can unsafe bitcast away the<br>&gt; escaping aspect of the closure.  This is better than changing the client’s<br>&gt; view of the API in any case.<br>&gt;<br>&gt;<br>&gt; On imported Objective-C API, the core team did a quick study of the Cocoa<br>&gt; APIs and found that most closure/block parameters are escaping in<br>&gt; practice.  As such, the core team feels that it isn’t overly burdensome to<br>&gt; ask that imported Objective-C APIs annotate their semantically noescape<br>&gt; block parameters with the clang __attribute__((noescape)) attribute.<br>&gt;<br>&gt;<br>&gt; I’m happy to write up this proposal, but won’t have cycles to do so for<br>&gt; several weeks.  If someone else wants to take it up, that would be great :-)<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/6c1063d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>+1. It would be great to get this reviewed and in for Swift 3.<br></p><p>Austin<br></p><p>&gt; On Jun 1, 2016, at 9:22 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to write this proposal.<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 12:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Jun 1, 2016, at 9:02 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; &gt; 2) For noescape, the core team feels that the right solution is for closure arguments to *default* to noescape, which means that the attribute we should really need is @escaping.<br>&gt; <br>&gt; To provide some more details, this approach has the following advantages:<br>&gt; <br>&gt; - Most functional algorithms written in pure Swift will benefit because they are naturally noescape.  The core team feels that this will reduce the boilerplate involved with writing these algorithms.<br>&gt; <br>&gt; - The compiler has enough logic in it to provide a great QoI experience when a developer doesn’t think about escaping, and tries to escape a closure - it can provide a fixit that suggests adding @escaping.<br>&gt; <br>&gt; - Recent changes (to disallow escaping closures to close over an inout parameter) are pushing the language to prefer noescape closures.  noescape closures have also always been the preferred default, since they eliminate a class of retain cycle issues.<br>&gt; <br>&gt; - &quot;@autoclosure(escaping)&quot; can be simplified and standardized to &quot;@autoclosure @escaping”<br>&gt; <br>&gt; <br>&gt; The two primary concerns with taking this direction were that it is would adversely impact resilience, and that imported Objective-C APIs would be too annoying to work with, because the compiler would have to be conservative and assume they are escaping:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On resilience, the concern with this approach is that an API may not thinking about whether a closure parameter should be escaping or not, and this behavior makes it possible that someone could write “V1” of an API and not accidentally promise noescape semantics, but then need it in “V2” of the same API.<br>&gt; <br>&gt; John McCall pointed out that resilience in the type system is different than resilience in practice: An API changing to capture a closure and use it long after it was originally passed is likely to break the clients regardless of whether the type system captures this as an issue.  He argues (and the argument is strong IMO) that it is *better* for resilient APIs to default to @noescape, since that forces the author of V2 to think about whether they are breaking their clients.  If they are doing something that is “logically” noescape in their V2, then they can unsafe bitcast away the escaping aspect of the closure.  This is better than changing the client’s view of the API in any case.<br>&gt; <br>&gt; <br>&gt; On imported Objective-C API, the core team did a quick study of the Cocoa APIs and found that most closure/block parameters are escaping in practice.  As such, the core team feels that it isn’t overly burdensome to ask that imported Objective-C APIs annotate their semantically noescape block parameters with the clang __attribute__((noescape)) attribute.<br>&gt; <br>&gt; <br>&gt; I’m happy to write up this proposal, but won’t have cycles to do so for several weeks.  If someone else wants to take it up, that would be great :-)<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/017ce5c0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  1, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 9:22 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to write this proposal.<br></p><p>Go for it!  Thanks,<br></p><p>-Chris<br></p><p>&gt; <br>&gt; On Thu, Jun 2, 2016 at 12:11 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Jun 1, 2016, at 9:02 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; &gt; 2) For noescape, the core team feels that the right solution is for closure arguments to *default* to noescape, which means that the attribute we should really need is @escaping.<br>&gt; <br>&gt; To provide some more details, this approach has the following advantages:<br>&gt; <br>&gt; - Most functional algorithms written in pure Swift will benefit because they are naturally noescape.  The core team feels that this will reduce the boilerplate involved with writing these algorithms.<br>&gt; <br>&gt; - The compiler has enough logic in it to provide a great QoI experience when a developer doesn’t think about escaping, and tries to escape a closure - it can provide a fixit that suggests adding @escaping.<br>&gt; <br>&gt; - Recent changes (to disallow escaping closures to close over an inout parameter) are pushing the language to prefer noescape closures.  noescape closures have also always been the preferred default, since they eliminate a class of retain cycle issues.<br>&gt; <br>&gt; - &quot;@autoclosure(escaping)&quot; can be simplified and standardized to &quot;@autoclosure @escaping”<br>&gt; <br>&gt; <br>&gt; The two primary concerns with taking this direction were that it is would adversely impact resilience, and that imported Objective-C APIs would be too annoying to work with, because the compiler would have to be conservative and assume they are escaping:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On resilience, the concern with this approach is that an API may not thinking about whether a closure parameter should be escaping or not, and this behavior makes it possible that someone could write “V1” of an API and not accidentally promise noescape semantics, but then need it in “V2” of the same API.<br>&gt; <br>&gt; John McCall pointed out that resilience in the type system is different than resilience in practice: An API changing to capture a closure and use it long after it was originally passed is likely to break the clients regardless of whether the type system captures this as an issue.  He argues (and the argument is strong IMO) that it is *better* for resilient APIs to default to @noescape, since that forces the author of V2 to think about whether they are breaking their clients.  If they are doing something that is “logically” noescape in their V2, then they can unsafe bitcast away the escaping aspect of the closure.  This is better than changing the client’s view of the API in any case.<br>&gt; <br>&gt; <br>&gt; On imported Objective-C API, the core team did a quick study of the Cocoa APIs and found that most closure/block parameters are escaping in practice.  As such, the core team feels that it isn’t overly burdensome to ask that imported Objective-C APIs annotate their semantically noescape block parameters with the clang __attribute__((noescape)) attribute.<br>&gt; <br>&gt; <br>&gt; I’m happy to write up this proposal, but won’t have cycles to do so for several weeks.  If someone else wants to take it up, that would be great :-)<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/554db130/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>June  6, 2016 at 02:00:00pm</p></header><div class="content"><p>I created a draft proposal to make `@noescape` the default and created a<br>new email thread with subject &quot;[Proposal] Make non-escaping closures the<br>default&quot;.<br></p><p>On Thu, Jun 2, 2016 at 1:22 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 1, 2016, at 9:22 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;<br>&gt; I&#39;d like to write this proposal.<br>&gt;<br>&gt;<br>&gt; Go for it!  Thanks,<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 12:11 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Jun 1, 2016, at 9:02 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; &gt; 2) For noescape, the core team feels that the right solution is for<br>&gt;&gt; closure arguments to *default* to noescape, which means that the attribute<br>&gt;&gt; we should really need is @escaping.<br>&gt;&gt;<br>&gt;&gt; To provide some more details, this approach has the following advantages:<br>&gt;&gt;<br>&gt;&gt; - Most functional algorithms written in pure Swift will benefit because<br>&gt;&gt; they are naturally noescape.  The core team feels that this will reduce the<br>&gt;&gt; boilerplate involved with writing these algorithms.<br>&gt;&gt;<br>&gt;&gt; - The compiler has enough logic in it to provide a great QoI experience<br>&gt;&gt; when a developer doesn’t think about escaping, and tries to escape a<br>&gt;&gt; closure - it can provide a fixit that suggests adding @escaping.<br>&gt;&gt;<br>&gt;&gt; - Recent changes (to disallow escaping closures to close over an inout<br>&gt;&gt; parameter) are pushing the language to prefer noescape closures.  noescape<br>&gt;&gt; closures have also always been the preferred default, since they eliminate<br>&gt;&gt; a class of retain cycle issues.<br>&gt;&gt;<br>&gt;&gt; - &quot;@autoclosure(escaping)&quot; can be simplified and standardized to<br>&gt;&gt; &quot;@autoclosure @escaping”<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The two primary concerns with taking this direction were that it is would<br>&gt;&gt; adversely impact resilience, and that imported Objective-C APIs would be<br>&gt;&gt; too annoying to work with, because the compiler would have to be<br>&gt;&gt; conservative and assume they are escaping:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On resilience, the concern with this approach is that an API may not<br>&gt;&gt; thinking about whether a closure parameter should be escaping or not, and<br>&gt;&gt; this behavior makes it possible that someone could write “V1” of an API and<br>&gt;&gt; not accidentally promise noescape semantics, but then need it in “V2” of<br>&gt;&gt; the same API.<br>&gt;&gt;<br>&gt;&gt; John McCall pointed out that resilience in the type system is different<br>&gt;&gt; than resilience in practice: An API changing to capture a closure and use<br>&gt;&gt; it long after it was originally passed is likely to break the clients<br>&gt;&gt; regardless of whether the type system captures this as an issue.  He argues<br>&gt;&gt; (and the argument is strong IMO) that it is *better* for resilient APIs to<br>&gt;&gt; default to @noescape, since that forces the author of V2 to think about<br>&gt;&gt; whether they are breaking their clients.  If they are doing something that<br>&gt;&gt; is “logically” noescape in their V2, then they can unsafe bitcast away the<br>&gt;&gt; escaping aspect of the closure.  This is better than changing the client’s<br>&gt;&gt; view of the API in any case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On imported Objective-C API, the core team did a quick study of the Cocoa<br>&gt;&gt; APIs and found that most closure/block parameters are escaping in<br>&gt;&gt; practice.  As such, the core team feels that it isn’t overly burdensome to<br>&gt;&gt; ask that imported Objective-C APIs annotate their semantically noescape<br>&gt;&gt; block parameters with the clang __attribute__((noescape)) attribute.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I’m happy to write up this proposal, but won’t have cycles to do so for<br>&gt;&gt; several weeks.  If someone else wants to take it up, that would be great :-)<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/32ad7cc5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Jun 1, 2016 at 9:11 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jun 1, 2016, at 9:02 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt; 2) For noescape, the core team feels that the right solution is for<br>&gt; closure arguments to *default* to noescape, which means that the attribute<br>&gt; we should really need is @escaping.<br>&gt;<br>&gt; To provide some more details, this approach has the following advantages:<br>&gt;<br>&gt; - Most functional algorithms written in pure Swift will benefit because<br>&gt; they are naturally noescape.  The core team feels that this will reduce the<br>&gt; boilerplate involved with writing these algorithms.<br>&gt;<br>&gt; - The compiler has enough logic in it to provide a great QoI experience<br>&gt; when a developer doesn’t think about escaping, and tries to escape a<br>&gt; closure - it can provide a fixit that suggests adding @escaping.<br>&gt;<br>&gt; - Recent changes (to disallow escaping closures to close over an inout<br>&gt; parameter) are pushing the language to prefer noescape closures.  noescape<br>&gt; closures have also always been the preferred default, since they eliminate<br>&gt; a class of retain cycle issues.<br>&gt;<br>&gt; - &quot;@autoclosure(escaping)&quot; can be simplified and standardized to<br>&gt; &quot;@autoclosure @escaping”<br>&gt;<br>&gt;<br>&gt; The two primary concerns with taking this direction were that it is would<br>&gt; adversely impact resilience, and that imported Objective-C APIs would be<br>&gt; too annoying to work with, because the compiler would have to be<br>&gt; conservative and assume they are escaping:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On resilience, the concern with this approach is that an API may not<br>&gt; thinking about whether a closure parameter should be escaping or not, and<br>&gt; this behavior makes it possible that someone could write “V1” of an API and<br>&gt; not accidentally promise noescape semantics, but then need it in “V2” of<br>&gt; the same API.<br>&gt;<br>&gt; John McCall pointed out that resilience in the type system is different<br>&gt; than resilience in practice: An API changing to capture a closure and use<br>&gt; it long after it was originally passed is likely to break the clients<br>&gt; regardless of whether the type system captures this as an issue.  He argues<br>&gt; (and the argument is strong IMO) that it is *better* for resilient APIs to<br>&gt; default to @noescape, since that forces the author of V2 to think about<br>&gt; whether they are breaking their clients.  If they are doing something that<br>&gt; is “logically” noescape in their V2, then they can unsafe bitcast away the<br>&gt; escaping aspect of the closure.  This is better than changing the client’s<br>&gt; view of the API in any case.<br>&gt;<br>&gt;<br>&gt; On imported Objective-C API, the core team did a quick study of the Cocoa<br>&gt; APIs and found that most closure/block parameters are escaping in<br>&gt; practice.  As such, the core team feels that it isn’t overly burdensome to<br>&gt; ask that imported Objective-C APIs annotate their semantically noescape<br>&gt; block parameters with the clang __attribute__((noescape)) attribute.<br>&gt;<br></p><p>This part is what I proposed last year; still waiting on an update:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md<br></p><p><br>&gt;<br>&gt;<br>&gt; I’m happy to write up this proposal, but won’t have cycles to do so for<br>&gt; several weeks.  If someone else wants to take it up, that would be great :-)<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/71e1a296/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  1, 2016 at 10:00:00pm</p></header><div class="content"><p>On Jun 1, 2016, at 9:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On imported Objective-C API, the core team did a quick study of the Cocoa APIs and found that most closure/block parameters are escaping in practice.  As such, the core team feels that it isn’t overly burdensome to ask that imported Objective-C APIs annotate their semantically noescape block parameters with the clang __attribute__((noescape)) attribute.<br>&gt; <br>&gt; This part is what I proposed last year; still waiting on an update:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md&gt;<br>&gt;  <br></p><p>The problem with that proposal, and the reason it is sitting around in limbo is:<br></p><p>1) it is prescriptive of a process “Audit system C/Objective-C libraries...&quot;, not a proposal for a set of specific changes.<br></p><p>2) swift-evolution isn’t the right place to propose changes for Foundation or other APIs outside of the standard library.  <br></p><p>It has been stuck in a crack for a long time, and has no hope of getting unstuck.  I think that at this point the right thing is to close it.  Is that ok with you?<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/369d1e02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>June  1, 2016 at 11:00:00pm</p></header><div class="content"><p>On Wed, Jun 1, 2016 at 10:25 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Jun 1, 2016, at 9:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On imported Objective-C API, the core team did a quick study of the Cocoa<br>&gt;&gt; APIs and found that most closure/block parameters are escaping in<br>&gt;&gt; practice.  As such, the core team feels that it isn’t overly burdensome to<br>&gt;&gt; ask that imported Objective-C APIs annotate their semantically noescape<br>&gt;&gt; block parameters with the clang __attribute__((noescape)) attribute.<br>&gt;&gt;<br>&gt;<br>&gt; This part is what I proposed last year; still waiting on an update:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md<br>&gt;<br>&gt;<br>&gt;<br>&gt; The problem with that proposal, and the reason it is sitting around in<br>&gt; limbo is:<br>&gt;<br>&gt; 1) it is prescriptive of a process “Audit system C/Objective-C<br>&gt; libraries...&quot;, not a proposal for a set of specific changes.<br>&gt;<br>&gt; 2) swift-evolution isn’t the right place to propose changes for Foundation<br>&gt; or other APIs outside of the standard library.<br>&gt;<br>&gt; It has been stuck in a crack for a long time, and has no hope of getting<br>&gt; unstuck.  I think that at this point the right thing is to close it.  Is<br>&gt; that ok with you?<br>&gt;<br>&gt; -Chris<br>&gt;<br></p><p>Okay, but is there any other way the community can have input on the set of<br>functions/methods that should be updated, and some visibility into<br>whether/when this will happen? It was my impression that Philippe was<br>making progress on this, but I hadn&#39;t heard any more for a while. (My<br>concern would be APIs getting missed due to lack of community input.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/bc7b7ad4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 11:29 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 1, 2016 at 10:25 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; On Jun 1, 2016, at 9:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On imported Objective-C API, the core team did a quick study of the Cocoa APIs and found that most closure/block parameters are escaping in practice.  As such, the core team feels that it isn’t overly burdensome to ask that imported Objective-C APIs annotate their semantically noescape block parameters with the clang __attribute__((noescape)) attribute.<br>&gt;&gt; <br>&gt;&gt; This part is what I proposed last year; still waiting on an update:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md&gt;<br>&gt;&gt;  <br>&gt; <br>&gt; The problem with that proposal, and the reason it is sitting around in limbo is:<br>&gt; <br>&gt; 1) it is prescriptive of a process “Audit system C/Objective-C libraries...&quot;, not a proposal for a set of specific changes.<br>&gt; <br>&gt; 2) swift-evolution isn’t the right place to propose changes for Foundation or other APIs outside of the standard library.  <br>&gt; <br>&gt; It has been stuck in a crack for a long time, and has no hope of getting unstuck.  I think that at this point the right thing is to close it.  Is that ok with you?<br>&gt; <br>&gt; Okay, but is there any other way the community can have input on the set of functions/methods that should be updated, and some visibility into whether/when this will happen? It was my impression that Philippe was making progress on this, but I hadn&#39;t heard any more for a while. (My concern would be APIs getting missed due to lack of community input.)<br></p><p>At this point it is hard to say.  All I know is that the only process for this is to discuss it on the list (in which case many Apple folk will probably notice and make take it up on their own volition) or by filing a bug with bugreporter.apple.com &lt;http://bugreporter.apple.com/&gt; requesting it.  Neither of these approaches give you the transparency you seek into when or if it will happen.<br></p><p>I understand that this isn’t what you want to hear, but it’s just the reality that Apple’s general framework design and evolution is not governed by the swift-evolution process.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/95639f55/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  2, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; 1) For noreturn, the core team prefers to explore a solution where a function can be declared as returning an non-constructable “bottom” type (e.g. an enum with zero cases).  This would lead to something like:<br>&gt; <br>&gt; 	func abort() -&gt; NoReturn { … }<br>&gt; <br>&gt; This will require some new support in the compiler, but should flow better through the type system than @noreturn in function composition and other applications.  Joe Groff offered to write a proposal for this.<br></p><p>Are you thinking in terms of a *real* bottom type—that is, a type which is the subtype of all types—or a fake bottom type which is simply an empty enum?<br></p><p>If you&#39;re thinking about a real bottom type, I wouldn&#39;t want to call it `NoReturn`, because the bottom type may end up playing a larger role in the language. Given our use of `Any`, the natural names for a bottom type are probably `All` (as the subtype of all types) or `None` (as a type with no instances). I do worry that those names are a little too short and attractive, though. `None` might be mistaken for `Void`; `All` might be mistaken for `Any`, and wouldn&#39;t make much sense when read as the return value of a function.<br></p><p>My best suggestion is `Never`. A function with a `Never` return type would read as &quot;never returns&quot;:<br></p><p>	func abort() -&gt; Never { … }<br></p><p>If it appeared in, say, a generic type, it would mean &quot;never occurs&quot;:<br></p><p>	let result: Result&lt;String, Never&gt;<br></p><p>Flowing from that, we can end up with functions taking a `Never` parameter, which are never called:<br></p><p>	result.flatMapError { (_: Never) in fatalError(&quot;can&#39;t happen&quot;) }<br></p><p>Or `Never?` values, which are never `some`:<br></p><p>	let _: Never? = Result&lt;String, Never&gt;.error<br></p><p>(By the way, the return type of the force unwrap operator on a `Never?` is `Never`, which is just right: if you force unwrap a `Never?`, it will always trap, never return.)<br></p><p>The main issue I see with `Never` is that it&#39;s an adverb, not a noun. But the nouns all seem to have problems. And besides, the bottom type isn&#39;t so much a thing as a lack of a thing, isn&#39;t it? That&#39;s bound to have a slightly funky name.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[swift-evolution-announce] [Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June  2, 2016 at 09:00:00am</p></header><div class="content"><p>In terms of naming, I almost feel like “None” would be a better name for it as then it reads somewhat as the opposite of “Any” and that has a nice symmetry to me.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 2, 2016, at 4:04 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 1) For noreturn, the core team prefers to explore a solution where a function can be declared as returning an non-constructable “bottom” type (e.g. an enum with zero cases).  This would lead to something like:<br>&gt;&gt; <br>&gt;&gt; 	func abort() -&gt; NoReturn { … }<br>&gt;&gt; <br>&gt;&gt; This will require some new support in the compiler, but should flow better through the type system than @noreturn in function composition and other applications.  Joe Groff offered to write a proposal for this.<br>&gt; <br>&gt; Are you thinking in terms of a *real* bottom type—that is, a type which is the subtype of all types—or a fake bottom type which is simply an empty enum?<br>&gt; <br>&gt; If you&#39;re thinking about a real bottom type, I wouldn&#39;t want to call it `NoReturn`, because the bottom type may end up playing a larger role in the language. Given our use of `Any`, the natural names for a bottom type are probably `All` (as the subtype of all types) or `None` (as a type with no instances). I do worry that those names are a little too short and attractive, though. `None` might be mistaken for `Void`; `All` might be mistaken for `Any`, and wouldn&#39;t make much sense when read as the return value of a function.<br>&gt; <br>&gt; My best suggestion is `Never`. A function with a `Never` return type would read as &quot;never returns&quot;:<br>&gt; <br>&gt; 	func abort() -&gt; Never { … }<br>&gt; <br>&gt; If it appeared in, say, a generic type, it would mean &quot;never occurs&quot;:<br>&gt; <br>&gt; 	let result: Result&lt;String, Never&gt;<br>&gt; <br>&gt; Flowing from that, we can end up with functions taking a `Never` parameter, which are never called:<br>&gt; <br>&gt; 	result.flatMapError { (_: Never) in fatalError(&quot;can&#39;t happen&quot;) }<br>&gt; <br>&gt; Or `Never?` values, which are never `some`:<br>&gt; <br>&gt; 	let _: Never? = Result&lt;String, Never&gt;.error<br>&gt; <br>&gt; (By the way, the return type of the force unwrap operator on a `Never?` is `Never`, which is just right: if you force unwrap a `Never?`, it will always trap, never return.)<br>&gt; <br>&gt; The main issue I see with `Never` is that it&#39;s an adverb, not a noun. But the nouns all seem to have problems. And besides, the bottom type isn&#39;t so much a thing as a lack of a thing, isn&#39;t it? That&#39;s bound to have a slightly funky name.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Rejected] SE-0097: Normalizing naming for &quot;negative&quot; attributes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 9:52 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In terms of naming, I almost feel like “None” would be a better name for it as then it reads somewhat as the opposite of “Any” and that has a nice symmetry to me.<br></p><p>+ 1.  Although the inverse of “None” is really “All” (as in “all or none”).  I’m not necessarily suggesting we use “All”, just pointing out the linguistic relationship.  <br></p><p>That said, I do believe we should *consider* alternatives names for “Any” as part of the discussion of the name for a bottom type.  It would be nice symmetry if we found names for the top and bottom types that are inverses of each other.<br></p><p>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 4:04 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 1) For noreturn, the core team prefers to explore a solution where a function can be declared as returning an non-constructable “bottom” type (e.g. an enum with zero cases).  This would lead to something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func abort() -&gt; NoReturn { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will require some new support in the compiler, but should flow better through the type system than @noreturn in function composition and other applications.  Joe Groff offered to write a proposal for this.<br>&gt;&gt; <br>&gt;&gt; Are you thinking in terms of a *real* bottom type—that is, a type which is the subtype of all types—or a fake bottom type which is simply an empty enum?<br>&gt;&gt; <br>&gt;&gt; If you&#39;re thinking about a real bottom type, I wouldn&#39;t want to call it `NoReturn`, because the bottom type may end up playing a larger role in the language. Given our use of `Any`, the natural names for a bottom type are probably `All` (as the subtype of all types) or `None` (as a type with no instances). I do worry that those names are a little too short and attractive, though. `None` might be mistaken for `Void`; `All` might be mistaken for `Any`, and wouldn&#39;t make much sense when read as the return value of a function.<br>&gt;&gt; <br>&gt;&gt; My best suggestion is `Never`. A function with a `Never` return type would read as &quot;never returns&quot;:<br>&gt;&gt; <br>&gt;&gt; 	func abort() -&gt; Never { … }<br>&gt;&gt; <br>&gt;&gt; If it appeared in, say, a generic type, it would mean &quot;never occurs&quot;:<br>&gt;&gt; <br>&gt;&gt; 	let result: Result&lt;String, Never&gt;<br>&gt;&gt; <br>&gt;&gt; Flowing from that, we can end up with functions taking a `Never` parameter, which are never called:<br>&gt;&gt; <br>&gt;&gt; 	result.flatMapError { (_: Never) in fatalError(&quot;can&#39;t happen&quot;) }<br>&gt;&gt; <br>&gt;&gt; Or `Never?` values, which are never `some`:<br>&gt;&gt; <br>&gt;&gt; 	let _: Never? = Result&lt;String, Never&gt;.error<br>&gt;&gt; <br>&gt;&gt; (By the way, the return type of the force unwrap operator on a `Never?` is `Never`, which is just right: if you force unwrap a `Never?`, it will always trap, never return.)<br>&gt;&gt; <br>&gt;&gt; The main issue I see with `Never` is that it&#39;s an adverb, not a noun. But the nouns all seem to have problems. And besides, the bottom type isn&#39;t so much a thing as a lack of a thing, isn&#39;t it? That&#39;s bound to have a slightly funky name.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
