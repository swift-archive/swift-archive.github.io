<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 10:00:00am</p></header><div class="content"><p>PermutationGenerator confuses me that it&#39;s confirm to both of SequenceType<br>and GeneratorType. Should it replace by PermutationSequence and<br>PermutationGenerator?<br></p><p><br>Also, we should have a PermutationCollection because we can:<br></p><p><br>public struct PermutationCollection&lt;C : CollectionType, I : CollectionType<br>where C.Index == I.Generator.Element&gt; : CollectionType {<br></p><p><br></p><p>    public typealias Generator = PermutationGenerator&lt;C, I&gt;<br></p><p><br></p><p>    public typealias Index = I.Index<br></p><p>    public typealias Element = C.Generator.Element<br></p><p><br></p><p>    private let _base: C<br></p><p>    private let _indices: I<br></p><p><br></p><p>    public subscript(idx: Index) -&gt; Element {<br></p><p>        return _base[_indices[idx]]<br></p><p>    }<br></p><p><br></p><p>    public var startIndex : Index {<br></p><p>        return _indices.startIndex<br></p><p>    }<br></p><p>    public var endIndex : Index {<br></p><p>        return _indices.endIndex<br></p><p>    }<br></p><p><br></p><p>    public var count : Index.Distance {<br></p><p>        return _indices.count<br></p><p>    }<br></p><p><br></p><p>    public func generate() -&gt; Generator {<br></p><p>        return PermutationGenerator(elements: _base, indices: _indices)<br></p><p>    }<br></p><p>}<br></p><p><br>and some methods provide:<br></p><p><br>public extension CollectionType {<br></p><p><br></p><p>    @warn_unused_result<br></p><p>    func collect&lt;I : SequenceType where Index == I.Generator.Element&gt;(indices:<br>I) -&gt; PermutationGenerator&lt;Self, I&gt; {<br></p><p>        return PermutationGenerator(elements: self, indices: indices)<br></p><p>    }<br></p><p><br></p><p>    @warn_unused_result<br></p><p>    func collect&lt;I : CollectionType where Index ==<br>I.Generator.Element&gt;(indices:<br>I) -&gt; PermutationCollection&lt;Self, I&gt; {<br></p><p>        return PermutationCollection(_base: self, _indices: indices)<br></p><p>    }<br></p><p>}<br></p><p><br>public extension LazyCollectionType {<br></p><p><br></p><p>    @warn_unused_result<br></p><p>    func collect&lt;I : SequenceType where Elements.Index == I.Generator.<br>Element&gt;(indices: I) -&gt; LazySequence&lt;PermutationGenerator&lt;Elements, I&gt;&gt; {<br></p><p>        return self.elements.collect(indices).lazy<br></p><p>    }<br></p><p><br></p><p>    @warn_unused_result<br></p><p>    func collect&lt;I : CollectionType where Elements.Index == I.Generator.<br>Element&gt;(indices: I) -&gt; LazyCollection&lt;PermutationCollection&lt;Elements, I&gt;&gt; {<br></p><p>        return self.elements.collect(indices).lazy<br></p><p>    }<br></p><p>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/058c4015/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 08:00:00pm</p></header><div class="content"><p>We have plenty of examples of GeneratorTypes that also conform to<br>SequenceType. There&#39;s no harm in it, and it saves having to declare a<br>separate type that consists solely of a generate() method that returns<br>the generator. In fact, the stdlib automatically derives the generate()<br>method for any GeneratorType that conforms to SequenceType already,<br>specifically to make this pattern as easy as possible. The only thing at<br>all odd about this is the name PermutationGenerator doesn&#39;t tell you<br>it&#39;s a sequence, but that&#39;s no different than AnyGenerator,<br>EmptyGenerator, EnumerateGenerator, FlattenGenerator, IndexingGenerator,<br>JoinGenerator, LazyFilterGenerator, LazyMapGenerator, RangeGenerator,<br>and UnsafeBufferPointerGenerator (though to be fair all of those have a<br>matching distinct Sequence type).<br></p><p>As for PermutationCollection, that&#39;s not a bad idea. I guess the biggest<br>objection is that I&#39;m not sure if PermutationGenerator is even pulling<br>its own weight, and adding more permutation types won&#39;t help. I don&#39;t<br>see any uses of PermutationGenerator in the stdlib, and I&#39;ve never found<br>a use for it in my own code, though I imagine that someone somewhere is<br>actually using it. In any case, the argument &quot;because we can&quot; isn&#39;t<br>sufficient to add something to the stdlib; it has to actually be of<br>enough use to be worth both the added maintenance burden and the added<br>code size.<br></p><p>That said, even if we do add a PermutationGenerator, I definitely don&#39;t<br>think extending CollectionType with a collect() method set like that is<br>worth doing. If we did have a method it should probably be called<br>&quot;permute&quot;, but I doubt enough people would use it to be worth the added<br>semantic overhead of yet another collection method.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 06:22 PM, Susan Cheng via swift-evolution wrote:<br>&gt; PermutationGenerator confuses me that it&#39;s confirm to both of<br>&gt; SequenceType and GeneratorType. Should it replace by<br>&gt; PermutationSequence and PermutationGenerator?<br></p><p><br>&gt;<br></p><p><br>&gt; Also, we should have a PermutationCollection because we can:<br></p><p><br>&gt;<br></p><p><br>&gt; public struct PermutationCollection&lt;C : CollectionType, I :<br>&gt; CollectionType where C.Index == I.Generator.Element&gt; :<br>&gt; CollectionType {<br></p><p><br>&gt;<br></p><p><br>&gt; public typealias Generator = PermutationGenerator&lt;C, I&gt;<br></p><p><br>&gt;<br></p><p><br>&gt; public typealias Index = I.Index<br></p><p><br>&gt; public typealias Element = C.Generator.Element<br></p><p><br>&gt;<br></p><p><br>&gt; private let _base: C<br></p><p><br>&gt; private let _indices: I<br></p><p><br>&gt;<br></p><p><br>&gt; public subscript(idx: Index) -&gt; Element {<br></p><p><br>&gt; return _base[_indices[idx]]<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; public var startIndex : Index {<br></p><p><br>&gt; return _indices.startIndex<br></p><p><br>&gt; }<br></p><p><br>&gt; public var endIndex : Index {<br></p><p><br>&gt; return _indices.endIndex<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; public var count : Index.Distance {<br></p><p><br>&gt; return _indices.count<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; public func generate() -&gt; Generator {<br></p><p><br>&gt; return PermutationGenerator(elements: _base, indices: _indices)<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; and some methods provide:<br></p><p><br>&gt;<br></p><p><br>&gt; publicextensionCollectionType {<br></p><p><br>&gt;<br></p><p><br>&gt; @warn_unused_result<br></p><p><br>&gt; func collect&lt;I : SequenceTypewhereIndex ==<br>&gt; I.Generator.Element&gt;(indices: I) -&gt; PermutationGenerator&lt;Self, I&gt; {<br></p><p><br>&gt; return PermutationGenerator(elements: self, indices: indices)<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; @warn_unused_result<br></p><p><br>&gt; func collect&lt;I : CollectionType where Index ==<br>&gt; I.Generator.Element&gt;(indices: I) -&gt; PermutationCollection&lt;Self, I&gt; {<br></p><p><br>&gt; return PermutationCollection(_base: self, _indices: indices)<br></p><p><br>&gt; }<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; publicextensionLazyCollectionType {<br></p><p><br>&gt;<br></p><p><br>&gt; @warn_unused_result<br></p><p><br>&gt; func collect&lt;I : SequenceTypewhereElements.Index ==<br>&gt; I.Generator.Element&gt;(indices: I) -&gt;<br>&gt; LazySequence&lt;PermutationGenerator&lt;Elements, I&gt;&gt; {<br></p><p><br>&gt; return self.elements.collect(indices).lazy<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; @warn_unused_result<br></p><p><br>&gt; func collect&lt;I : CollectionTypewhereElements.Index ==<br>&gt; I.Generator.Element&gt;(indices: I) -&gt;<br>&gt; LazyCollection&lt;PermutationCollection&lt;Elements, I&gt;&gt; {<br></p><p><br>&gt; return self.elements.collect(indices).lazy<br></p><p><br>&gt; }<br></p><p><br>&gt;<br></p><p><br>&gt; }<br></p><p><br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/784d0cf0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 08:00:00pm</p></header><div class="content"><p>As I know SequenceType should have behaved as immutable structure and it<br>provides method to get a mutable GeneratorType which generates value from<br>start of sequence.<br>But the PermutationGenerator break this rule, every time it changes it&#39;s<br>state, it cannot get the generator with the start of sequence.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/c659c397/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015 at 2:01 PM, Susan Cheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As I know SequenceType should have behaved as immutable structure and it<br>&gt; provides method to get a mutable GeneratorType which generates value from<br>&gt; start of sequence.<br></p><p><br>Sequences are not immutable.  A sequence is allowed to be consumed by<br>iterating over its generator.  If the type you have is a sequence, you can<br>only assume that you can access the elements only once.  For example, a<br>socket can be modeled as a sequence of bytes.  Once the bytes are consumed<br>from the corresponding generator, they are gone from the sequence.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/d2d5962e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 09:00:00pm</p></header><div class="content"><p>yes for sequences are not immutable. I get confused.<br></p><p>no for sequences should be definition of lists of values. Just<br>like Fibonacci sequence, we can calculate the values form the start of<br>the Fibonacci sequence one by one. But we are not accessing the values<br>of Fibonacci sequence.<br></p><p>A socket can be modeled as a sequence of bytes but socket(itself) is not<br>the sequence. It&#39;s just provide method to access the bytes sequences.<br></p><p>Dmitri Gribenko &lt;gribozavr at gmail.com&gt; 於 2015年12月31日星期四 寫道：<br></p><p>&gt; On Thu, Dec 31, 2015 at 2:01 PM, Susan Cheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; As I know SequenceType should have behaved as immutable structure and it<br>&gt;&gt; provides method to get a mutable GeneratorType which generates value from<br>&gt;&gt; start of sequence.<br>&gt;<br>&gt;<br>&gt; Sequences are not immutable.  A sequence is allowed to be consumed by<br>&gt; iterating over its generator.  If the type you have is a sequence, you can<br>&gt; only assume that you can access the elements only once.  For example, a<br>&gt; socket can be modeled as a sequence of bytes.  Once the bytes are consumed<br>&gt; from the corresponding generator, they are gone from the sequence.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;gribozavr at gmail.com&#39;);&gt;&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/ed64cb37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 31, 2015 at 03:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015 at 3:04 PM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt; yes for sequences are not immutable. I get confused.<br>&gt;<br>&gt; no for sequences should be definition of lists of values. Just like<br>&gt; Fibonacci sequence, we can calculate the values form the start of the<br>&gt; Fibonacci sequence one by one. But we are not accessing the values of<br>&gt; Fibonacci sequence.<br></p><p>Those are collections.  Collections can be iterated over multiple times.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 09:00:00pm</p></header><div class="content"><p>I don&#39;t think so.<br></p><p>As we don&#39;t say &quot;Fibonacci collection&quot;, we know Fibonacci numbers are in<br>order. But we can&#39;t tell the number immediately if I asked a specific index<br>of Fibonacci sequence. The only way is calculate the sequence one by one<br>from start.<br></p><p>So we need the collection, and collection do the jobs. But it true that<br>collections are sequences.<br>Swift is also have this definition, in concrete implementation way.<br></p><p>Dmitri Gribenko &lt;gribozavr at gmail.com&gt; 於 2015年12月31日星期四 寫道：<br></p><p>&gt; On Thu, Dec 31, 2015 at 3:04 PM, Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; yes for sequences are not immutable. I get confused.<br>&gt; &gt;<br>&gt; &gt; no for sequences should be definition of lists of values. Just like<br>&gt; &gt; Fibonacci sequence, we can calculate the values form the start of the<br>&gt; &gt; Fibonacci sequence one by one. But we are not accessing the values of<br>&gt; &gt; Fibonacci sequence.<br>&gt;<br>&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com<br>&gt; &lt;javascript:;&gt;&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/0b055a11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 31, 2015 at 03:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015 at 3:36 PM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt; I don&#39;t think so.<br>&gt;<br>&gt; As we don&#39;t say &quot;Fibonacci collection&quot;, we know Fibonacci numbers are in<br>&gt; order. But we can&#39;t tell the number immediately if I asked a specific index<br>&gt; of Fibonacci sequence. The only way is calculate the sequence one by one<br>&gt; from start.<br></p><p>That&#39;s OK, collections can have Forward indices which have exactly<br>these properties.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>December 31, 2015 at 10:00:00pm</p></header><div class="content"><p>sequence can have more methods with it, we can find first five values of<br>a sequence.<br></p><p>but we don&#39;t do this with a generator<br></p><p>struct Fibonacci: SequenceType {<br></p><p><br></p><p>    var first, second: Int<br></p><p><br></p><p>    func generate() -&gt; AnyGenerator&lt;Int&gt; {<br></p><p><br></p><p>        var a = first<br></p><p>        var b = second<br></p><p><br></p><p>        return anyGenerator {<br></p><p>            let temp = a<br></p><p>            (a, b) = (b, a + b)<br></p><p>            return temp<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p><br>Array(Fibonacci(first: 1, second: 1).prefix(10))<br></p><p>Happy new year to all<br></p><p><br>2015-12-31 21:57 GMT+08:00 Dmitri Gribenko &lt;gribozavr at gmail.com&gt;:<br></p><p>&gt; On Thu, Dec 31, 2015 at 3:36 PM, Susan Cheng &lt;susan.doggie at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt; I don&#39;t think so.<br>&gt; &gt;<br>&gt; &gt; As we don&#39;t say &quot;Fibonacci collection&quot;, we know Fibonacci numbers are in<br>&gt; &gt; order. But we can&#39;t tell the number immediately if I asked a specific<br>&gt; index<br>&gt; &gt; of Fibonacci sequence. The only way is calculate the sequence one by one<br>&gt; &gt; from start.<br>&gt;<br>&gt; That&#39;s OK, collections can have Forward indices which have exactly<br>&gt; these properties.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/a3fb8676/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; Those are collections.  Collections can be iterated over multiple times.<br>Speaking of the Fibonacci-numbers:<br>Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>(only nitpicking — I just couldn&#39;t resist)<br></p><p>Happy new year!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 31, 2015 at 03:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015 at 3:51 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt; Speaking of the Fibonacci-numbers:<br>&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt; (only nitpicking — I just couldn&#39;t resist)<br></p><p>Well, I didn&#39;t say you need to iterate to the very end, or that you<br>need to iterate them serially.  You can take two generators from the<br>same collection, and advance them independently, in interleaved<br>fashion, for example.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 31, 2015 at 10:00:00am</p></header><div class="content"><p>It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br></p><p>-- E<br></p><p><br>&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt; Speaking of the Fibonacci-numbers:<br>&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt; <br>&gt; Happy new year!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br></p><p>This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt; <br>&gt;&gt; Happy new year!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 31, 2015 at 10:00:00am</p></header><div class="content"><p>I&#39;m trying to work them out, so it&#39;s still muddled.<br></p><p>Right now, I think SequenceType is better described as CollectionWalkType but that&#39;s kind of (1) a mouthful and (2) not entirely accurate. <br></p><p>Moving back a step: SequenceType is defined as: &quot;A type that can be iterated with a `for`...`in` loop.&quot; But it says nothing about whether that loop ever terminates and many stdlib sequence functions currently don&#39;t make sense (at least if they&#39;re not lazy) with respect to infinite sequences, which should probably be &quot;StreamType&quot; not sequences. A couple of examples:<br>Here&#39;s my fib: http://swiftstub.com/189513594/<br>And here&#39;s Oisin&#39;s user-input sequence:  https://gist.github.com/oisdk/2c7ac33bf2188528842a<br>Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br></p><p>Hopefully that&#39;s enough of a starting point to indicate where my thinking is at and what I&#39;m trying to think through when it comes to this. -- E<br></p><p><br>&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt; <br>&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -Dave<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/a424b4a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 31, 2015 at 06:00:00pm</p></header><div class="content"><p>Just to add to that, it’s always seemed strange to me that to signify your sequence is multi-pass (i.e., to make it conform to CollectionType) you have to have it conform to Indexable. <br></p><p>&gt; On 31 Dec 2015, at 17:52, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m trying to work them out, so it&#39;s still muddled.<br>&gt; <br>&gt; Right now, I think SequenceType is better described as CollectionWalkType but that&#39;s kind of (1) a mouthful and (2) not entirely accurate. <br>&gt; <br>&gt; Moving back a step: SequenceType is defined as: &quot;A type that can be iterated with a `for`...`in` loop.&quot; But it says nothing about whether that loop ever terminates and many stdlib sequence functions currently don&#39;t make sense (at least if they&#39;re not lazy) with respect to infinite sequences, which should probably be &quot;StreamType&quot; not sequences. A couple of examples:<br>&gt; Here&#39;s my fib: http://swiftstub.com/189513594/ &lt;http://swiftstub.com/189513594/&gt;<br>&gt; And here&#39;s Oisin&#39;s user-input sequence:  https://gist.github.com/oisdk/2c7ac33bf2188528842a &lt;https://gist.github.com/oisdk/2c7ac33bf2188528842a&gt;<br>&gt; Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br>&gt; <br>&gt; Hopefully that&#39;s enough of a starting point to indicate where my thinking is at and what I&#39;m trying to think through when it comes to this. -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt;&gt; <br>&gt;&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/00266a23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 10:52 AM, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just to add to that, it’s always seemed strange to me that to signify your sequence is multi-pass (i.e., to make it conform to CollectionType) you have to have it conform to Indexable. <br></p><p>FWIW, Indexable is an implementation artifact that will go away when Swift’s generics system is improved.<br></p><p>But if your real objection is that you have to come up with an Index and a subscripting operator, I can understand that.  Part of the reason for this is our reluctance to create any distinct protocols with identical syntactic requirements &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;.  To justify having a separate multi-pass sequence protocol, there would have to be a significant/important class of multi-pass sequences for which CollectionType was unimplementable without serious costs.<br></p><p>In principle there’s a way to ease the pain of creating CollectionType conformances for multipass SequenceTypes…if only it didn’t crash the compiler &lt;https://bugs.swift.org/browse/SR-427&gt; ;-).  Here’s a variation that uses a generic adapter instead of a protocol conformance declaration:<br></p><p>/// A `CollectionType` containing the same elements as `Base`, without storing them.<br>///<br>/// - Requires: `Base` supports multiple passes (traversing it does not<br>///   consume the sequence), and `Base.Generator` has value semantics<br>public struct Multipass&lt;Base: SequenceType where Base.Generator: Equatable&gt; : CollectionType {<br>  public var startIndex: MultipassIndex&lt;Base&gt; {<br>    var g = _base.generate()<br>    return MultipassIndex(buffer: g.next(), generator: g)<br>  }<br>  <br>  public var endIndex: MultipassIndex&lt;Base&gt; {<br>    return MultipassIndex(buffer: nil, generator: _base.generate())<br>  }<br></p><p>  public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>    return position.buffer!<br>  }<br></p><p>  public init(_ base: Base) {<br>    _base = base<br>  }<br>  <br>  var _base: Base<br>}<br></p><p>// Note: Requires T.Generator has value semantics<br>public struct MultipassIndex&lt;T: SequenceType where T.Generator: Equatable&gt; : ForwardIndexType {<br>  public func successor() -&gt; MultipassIndex {<br>    var r = self<br>    r.buffer = r.generator.next()<br>    return r<br>  }<br>  var buffer: T.Generator.Element?<br>  var generator: T.Generator<br>}<br></p><p>public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>  return x.buffer == nil &amp;&amp; y.buffer == nil || x.generator == y.generator<br>}<br></p><p>//===--- An example fibonacci sequence ------------------------------------===//<br>struct FibGenerator : GeneratorType {<br>  mutating func next() -&gt; Int? {<br>    let c = a + b<br>    a = b<br>    b = c<br>    return a &lt; limit ? a : nil<br>  }<br>  var a, b, limit: Int<br>}<br></p><p><br>struct Fib : SequenceType {<br>  var limit = 1000<br>  <br>  func generate() -&gt; FibGenerator {<br>    return Generator(a: 0, b: 1, limit: limit)<br>  }<br>}<br></p><p>//===--- Adapt Fib for use with Multipass ---------------------------------===//<br>extension FibGenerator : Equatable {}<br>func == (x: Fib.Generator, y: Fib.Generator) -&gt; Bool {<br>  return x.a == y.a<br>}<br></p><p>//===--- Demonstration ----------------------------------------------------===//<br>let c = Multipass(Fib())<br>print(c.first)<br>print(c.count)<br>print(c.lazy.map { $0 + 1 })<br></p><p><br>&gt; <br>&gt;&gt; On 31 Dec 2015, at 17:52, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m trying to work them out, so it&#39;s still muddled.<br>&gt;&gt; <br>&gt;&gt; Right now, I think SequenceType is better described as CollectionWalkType but that&#39;s kind of (1) a mouthful and (2) not entirely accurate. <br>&gt;&gt; <br>&gt;&gt; Moving back a step: SequenceType is defined as: &quot;A type that can be iterated with a `for`...`in` loop.&quot; But it says nothing about whether that loop ever terminates and many stdlib sequence functions currently don&#39;t make sense (at least if they&#39;re not lazy) with respect to infinite sequences, which should probably be &quot;StreamType&quot; not sequences. A couple of examples:<br>&gt;&gt; Here&#39;s my fib: http://swiftstub.com/189513594/ &lt;http://swiftstub.com/189513594/&gt;<br>&gt;&gt; And here&#39;s Oisin&#39;s user-input sequence:  https://gist.github.com/oisdk/2c7ac33bf2188528842a &lt;https://gist.github.com/oisdk/2c7ac33bf2188528842a&gt;<br>&gt;&gt; Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br>&gt;&gt; <br>&gt;&gt; Hopefully that&#39;s enough of a starting point to indicate where my thinking is at and what I&#39;m trying to think through when it comes to this. -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/e6b9ca5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>January  1, 2016 at 11:00:00am</p></header><div class="content"><p>How GeneratorType confirm to Equatable??<br></p><p>struct Fib : SequenceType {<br></p><p>    var a: Int<br>    var b: Int<br></p><p>    var limit: Int<br></p><p>    func generate() -&gt; FibGenerator {<br>        return Generator(a: a, b: b, limit: limit)<br>    }<br>}<br></p><p>let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br></p><p>-Susan<br></p><p><br>2016-01-01 11:17 GMT+08:00 Dave Abrahams &lt;dabrahams at apple.com&gt;:<br></p><p>&gt; FWIW, Indexable is an implementation artifact that will go away when<br>&gt; Swift’s generics system is improved.<br>&gt;<br>&gt; But if your real objection is that you have to come up with an Index and a<br>&gt; subscripting operator, I can understand that.  Part of the reason for this<br>&gt; is our reluctance to create any distinct protocols with identical syntactic<br>&gt; requirements &lt;<br>&gt; http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;.<br>&gt; To justify having a separate multi-pass sequence protocol, there would have<br>&gt; to be a significant/important class of multi-pass sequences for which<br>&gt; CollectionType was unimplementable without serious costs.<br>&gt;<br>&gt; In principle there’s a way to ease the pain of creating CollectionType<br>&gt; conformances for multipass SequenceTypes…if only it didn’t crash the<br>&gt; compiler &lt;https://bugs.swift.org/browse/SR-427&gt; ;-).  Here’s a variation<br>&gt; that uses a generic adapter instead of a protocol conformance declaration:<br>&gt;<br>&gt; /// A `CollectionType` containing the same elements as `Base`, without<br>&gt; storing them.<br>&gt; ///<br>&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt; public struct Multipass&lt;Base: SequenceType where Base.Generator:<br>&gt; Equatable&gt; : CollectionType {<br>&gt;   public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;     var g = _base.generate()<br>&gt;     return MultipassIndex(buffer: g.next(), generator: g)<br>&gt;   }<br>&gt;<br>&gt;   public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;     return MultipassIndex(buffer: nil, generator: _base.generate())<br>&gt;   }<br>&gt;<br>&gt;   public subscript(position: MultipassIndex&lt;Base&gt;) -&gt;<br>&gt; Base.Generator.Element {<br>&gt;     return position.buffer!<br>&gt;   }<br>&gt;<br>&gt;   public init(_ base: Base) {<br>&gt;     _base = base<br>&gt;   }<br>&gt;<br>&gt;   var _base: Base<br>&gt; }<br>&gt;<br>&gt; // Note: Requires T.Generator has value semantics<br>&gt; public struct MultipassIndex&lt;T: SequenceType where T.Generator: Equatable&gt;<br>&gt; : ForwardIndexType {<br>&gt;   public func successor() -&gt; MultipassIndex {<br>&gt;     var r = self<br>&gt;     r.buffer = r.generator.next()<br>&gt;     return r<br>&gt;   }<br>&gt;   var buffer: T.Generator.Element?<br>&gt;   var generator: T.Generator<br>&gt; }<br>&gt;<br>&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;   return x.buffer == nil &amp;&amp; y.buffer == nil || x.generator == y.generator<br>&gt; }<br>&gt;<br>&gt; //===--- An example fibonacci sequence<br>&gt; ------------------------------------===//<br>&gt; struct FibGenerator : GeneratorType {<br>&gt;   mutating func next() -&gt; Int? {<br>&gt;     let c = a + b<br>&gt;     a = b<br>&gt;     b = c<br>&gt;     return a &lt; limit ? a : nil<br>&gt;   }<br>&gt;   var a, b, limit: Int<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct Fib : SequenceType {<br>&gt;   var limit = 1000<br>&gt;<br>&gt;   func generate() -&gt; FibGenerator {<br>&gt;     return Generator(a: 0, b: 1, limit: limit)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; //===--- Adapt Fib for use with Multipass<br>&gt; ---------------------------------===//<br>&gt; extension FibGenerator : Equatable {}<br>&gt; func == (x: Fib.Generator, y: Fib.Generator) -&gt; Bool {<br>&gt;   return x.a == y.a<br>&gt; }<br>&gt;<br>&gt; //===--- Demonstration<br>&gt; ----------------------------------------------------===//<br>&gt; let c = Multipass(Fib())<br>&gt; print(c.first)<br>&gt; print(c.count)<br>&gt; print(c.lazy.map { $0 + 1 })<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/492180d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 7:46 PM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; How GeneratorType confirm to Equatable??<br></p><p>I don’t understand the question.  In the code I posted there’s a working example of how a GeneratorType model can conform to Equatable..<br></p><p>&gt; <br>&gt; struct Fib : SequenceType {<br>&gt;     <br>&gt;     var a: Int<br>&gt;     var b: Int<br>&gt;     <br>&gt;     var limit: Int<br>&gt;     <br>&gt;     func generate() -&gt; FibGenerator {<br>&gt;         return Generator(a: a, b: b, limit: limit)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt; <br>&gt; -Susan<br>&gt; <br>&gt; <br>&gt; 2016-01-01 11:17 GMT+08:00 Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;:<br>&gt; FWIW, Indexable is an implementation artifact that will go away when Swift’s generics system is improved.<br>&gt; <br>&gt; But if your real objection is that you have to come up with an Index and a subscripting operator, I can understand that.  Part of the reason for this is our reluctance to create any distinct protocols with identical syntactic requirements &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;&gt;.  To justify having a separate multi-pass sequence protocol, there would have to be a significant/important class of multi-pass sequences for which CollectionType was unimplementable without serious costs.<br>&gt; <br>&gt; In principle there’s a way to ease the pain of creating CollectionType conformances for multipass SequenceTypes…if only it didn’t crash the compiler &lt;https://bugs.swift.org/browse/SR-427 &lt;https://bugs.swift.org/browse/SR-427&gt;&gt; ;-).  Here’s a variation that uses a generic adapter instead of a protocol conformance declaration:<br>&gt; <br>&gt; /// A `CollectionType` containing the same elements as `Base`, without storing them.<br>&gt; ///<br>&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt; public struct Multipass&lt;Base: SequenceType where Base.Generator: Equatable&gt; : CollectionType {<br>&gt;   public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;     var g = _base.generate()<br>&gt;     return MultipassIndex(buffer: g.next(), generator: g)<br>&gt;   }<br>&gt; <br>&gt;   public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;     return MultipassIndex(buffer: nil, generator: _base.generate())<br>&gt;   }<br>&gt; <br>&gt;   public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>&gt;     return position.buffer!<br>&gt;   }<br>&gt; <br>&gt;   public init(_ base: Base) {<br>&gt;     _base = base<br>&gt;   }<br>&gt; <br>&gt;   var _base: Base<br>&gt; }<br>&gt; <br>&gt; // Note: Requires T.Generator has value semantics<br>&gt; public struct MultipassIndex&lt;T: SequenceType where T.Generator: Equatable&gt; : ForwardIndexType {<br>&gt;   public func successor() -&gt; MultipassIndex {<br>&gt;     var r = self<br>&gt;     r.buffer = r.generator.next()<br>&gt;     return r<br>&gt;   }<br>&gt;   var buffer: T.Generator.Element?<br>&gt;   var generator: T.Generator<br>&gt; }<br>&gt; <br>&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;   return x.buffer == nil &amp;&amp; y.buffer == nil || x.generator == y.generator<br>&gt; }<br>&gt; <br>&gt; //===--- An example fibonacci sequence ------------------------------------===//<br>&gt; struct FibGenerator : GeneratorType {<br>&gt;   mutating func next() -&gt; Int? {<br>&gt;     let c = a + b<br>&gt;     a = b<br>&gt;     b = c<br>&gt;     return a &lt; limit ? a : nil<br>&gt;   }<br>&gt;   var a, b, limit: Int<br>&gt; }<br>&gt; <br>&gt; <br>&gt; struct Fib : SequenceType {<br>&gt;   var limit = 1000<br>&gt; <br>&gt;   func generate() -&gt; FibGenerator {<br>&gt;     return Generator(a: 0, b: 1, limit: limit)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; //===--- Adapt Fib for use with Multipass ---------------------------------===//<br>&gt; extension FibGenerator : Equatable {}<br>&gt; func == (x: Fib.Generator, y: Fib.Generator) -&gt; Bool {<br>&gt;   return x.a == y.a<br>&gt; }<br>&gt; <br>&gt; //===--- Demonstration ----------------------------------------------------===//<br>&gt; let c = Multipass(Fib())<br>&gt; print(c.first)<br>&gt; print(c.count)<br>&gt; print(c.lazy.map { $0 + 1 })<br>&gt; <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/f389ccfb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>January  1, 2016 at 12:00:00pm</p></header><div class="content"><p>if you try my modification, it will crash.<br></p><p>struct Fib : SequenceType {<br>    <br>    var a: Int<br>    var b: Int<br>    <br>    var limit: Int<br>    <br>    func generate() -&gt; FibGenerator {<br>        return Generator(a: a, b: b, limit: limit)<br>    }<br>}<br></p><p>let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br></p><p>A SequenceType becomes a CollectionType only work by adding a Index. that the most significantly different of sequence and collection.<br></p><p>/// A `CollectionType` containing the same elements as `Base`, without storing them.<br>///<br>/// - Requires: `Base` supports multiple passes (traversing it does not<br>///   consume the sequence), and `Base.Generator` has value semantics<br>public struct Multipass&lt;Base: SequenceType&gt; : CollectionType {<br>    public var startIndex: MultipassIndex&lt;Base&gt; {<br>        var g = _base.enumerate().generate()<br>        if let (idx, val) = g.next() {<br>            return MultipassIndex(index: idx, buffer: val, generator: g)<br>        }<br>        return MultipassIndex(index: nil, buffer: nil, generator: g)<br>    }<br>    <br>    public var endIndex: MultipassIndex&lt;Base&gt; {<br>        return MultipassIndex(index: nil, buffer: nil, generator: _base.enumerate().generate())<br>    }<br>    <br>    public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>        return position.buffer!<br>    }<br>    <br>    public init(_ base: Base) {<br>        _base = base<br>    }<br>    <br>    var _base: Base<br>}<br></p><p>// Note: Requires T.Generator has value semantics<br>public struct MultipassIndex&lt;T: SequenceType&gt; : ForwardIndexType {<br>    public func successor() -&gt; MultipassIndex {<br>        var r = self<br>        if let (idx, val) = r.generator.next() {<br>            r.index = idx<br>            r.buffer = val<br>        } else {<br>            r.index = nil<br>            r.buffer = nil<br>        }<br>        return r<br>    }<br>    var index: Int?<br>    var buffer: T.Generator.Element?<br>    var generator: EnumerateSequence&lt;T&gt;.Generator<br>}<br></p><p>public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>    return x.index == y.index<br>}<br></p><p>//===--- An example fibonacci sequence ------------------------------------===//<br>struct FibGenerator : GeneratorType {<br>    mutating func next() -&gt; Int? {<br>        let c = a + b<br>        a = b<br>        b = c<br>        return a &lt; limit ? a : nil<br>    }<br>    var a, b, limit: Int<br>}<br></p><p><br>struct Fib : SequenceType {<br>    var limit = 100<br>    <br>    func generate() -&gt; FibGenerator {<br>        return Generator(a: 0, b: 1, limit: limit)<br>    }<br>}<br></p><p>It&#39;s true that ForwardIndexType is also run-through the base one by one but it also correct that getting specific value with specific index.<br></p><p>c[c.startIndex.successor().successor().successor()] // it&#39;s a defined behave<br></p><p><br>&gt; Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2016年1月1日 下午12:00 寫道：<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 7:46 PM, Susan Cheng &lt;susan.doggie at gmail.com &lt;mailto:susan.doggie at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; How GeneratorType confirm to Equatable??<br>&gt; <br>&gt; I don’t understand the question.  In the code I posted there’s a working example of how a GeneratorType model can conform to Equatable..<br>&gt; <br>&gt;&gt; <br>&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;     <br>&gt;&gt;     var a: Int<br>&gt;&gt;     var b: Int<br>&gt;&gt;     <br>&gt;&gt;     var limit: Int<br>&gt;&gt;     <br>&gt;&gt;     func generate() -&gt; FibGenerator {<br>&gt;&gt;         return Generator(a: a, b: b, limit: limit)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt;&gt; <br>&gt;&gt; -Susan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2016-01-01 11:17 GMT+08:00 Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;:<br>&gt;&gt; FWIW, Indexable is an implementation artifact that will go away when Swift’s generics system is improved.<br>&gt;&gt; <br>&gt;&gt; But if your real objection is that you have to come up with an Index and a subscripting operator, I can understand that.  Part of the reason for this is our reluctance to create any distinct protocols with identical syntactic requirements &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;&gt;.  To justify having a separate multi-pass sequence protocol, there would have to be a significant/important class of multi-pass sequences for which CollectionType was unimplementable without serious costs.<br>&gt;&gt; <br>&gt;&gt; In principle there’s a way to ease the pain of creating CollectionType conformances for multipass SequenceTypes…if only it didn’t crash the compiler &lt;https://bugs.swift.org/browse/SR-427 &lt;https://bugs.swift.org/browse/SR-427&gt;&gt; ;-).  Here’s a variation that uses a generic adapter instead of a protocol conformance declaration:<br>&gt;&gt; <br>&gt;&gt; /// A `CollectionType` containing the same elements as `Base`, without storing them.<br>&gt;&gt; ///<br>&gt;&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt;&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt;&gt; public struct Multipass&lt;Base: SequenceType where Base.Generator: Equatable&gt; : CollectionType {<br>&gt;&gt;   public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;     var g = _base.generate()<br>&gt;&gt;     return MultipassIndex(buffer: g.next(), generator: g)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;     return MultipassIndex(buffer: nil, generator: _base.generate())<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>&gt;&gt;     return position.buffer!<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   public init(_ base: Base) {<br>&gt;&gt;     _base = base<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   var _base: Base<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Note: Requires T.Generator has value semantics<br>&gt;&gt; public struct MultipassIndex&lt;T: SequenceType where T.Generator: Equatable&gt; : ForwardIndexType {<br>&gt;&gt;   public func successor() -&gt; MultipassIndex {<br>&gt;&gt;     var r = self<br>&gt;&gt;     r.buffer = r.generator.next()<br>&gt;&gt;     return r<br>&gt;&gt;   }<br>&gt;&gt;   var buffer: T.Generator.Element?<br>&gt;&gt;   var generator: T.Generator<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;   return x.buffer == nil &amp;&amp; y.buffer == nil || x.generator == y.generator<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //===--- An example fibonacci sequence ------------------------------------===//<br>&gt;&gt; struct FibGenerator : GeneratorType {<br>&gt;&gt;   mutating func next() -&gt; Int? {<br>&gt;&gt;     let c = a + b<br>&gt;&gt;     a = b<br>&gt;&gt;     b = c<br>&gt;&gt;     return a &lt; limit ? a : nil<br>&gt;&gt;   }<br>&gt;&gt;   var a, b, limit: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;   var limit = 1000<br>&gt;&gt; <br>&gt;&gt;   func generate() -&gt; FibGenerator {<br>&gt;&gt;     return Generator(a: 0, b: 1, limit: limit)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //===--- Adapt Fib for use with Multipass ---------------------------------===//<br>&gt;&gt; extension FibGenerator : Equatable {}<br>&gt;&gt; func == (x: Fib.Generator, y: Fib.Generator) -&gt; Bool {<br>&gt;&gt;   return x.a == y.a<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //===--- Demonstration ----------------------------------------------------===//<br>&gt;&gt; let c = Multipass(Fib())<br>&gt;&gt; print(c.first)<br>&gt;&gt; print(c.count)<br>&gt;&gt; print(c.lazy.map { $0 + 1 })<br>&gt;&gt; <br>&gt; <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/ae2240a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 8:22 PM, 鄭齊峯 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; if you try my modification, it will crash.<br></p><p>Only because your Sequence genereates an arithmetic underflow.  I don’t understand what point you’re trying to make<br>&gt; <br>&gt; struct Fib : SequenceType {<br>&gt;     <br>&gt;     var a: Int<br>&gt;     var b: Int<br>&gt;     <br>&gt;     var limit: Int<br>&gt;     <br>&gt;     func generate() -&gt; FibGenerator {<br>&gt;         return Generator(a: a, b: b, limit: limit)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt; <br>&gt; A SequenceType becomes a CollectionType only work by adding a Index. that the most significantly different of sequence and collection.<br></p><p>I think I understand that pretty well, having designed both of those abstractions, but still don’t get your point.  Sorry, I’m trying here, but I can’t figure out what you’re trying to tell me.<br></p><p>&gt; <br>&gt; /// A `CollectionType` containing the same elements as `Base`, without storing them.<br>&gt; ///<br>&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt; public struct Multipass&lt;Base: SequenceType&gt; : CollectionType {<br>&gt;     public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;         var g = _base.enumerate().generate()<br>&gt;         if let (idx, val) = g.next() {<br>&gt;             return MultipassIndex(index: idx, buffer: val, generator: g)<br>&gt;         }<br>&gt;         return MultipassIndex(index: nil, buffer: nil, generator: g)<br>&gt;     }<br>&gt;     <br>&gt;     public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;         return MultipassIndex(index: nil, buffer: nil, generator: _base.enumerate().generate())<br>&gt;     }<br>&gt;     <br>&gt;     public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>&gt;         return position.buffer!<br>&gt;     }<br>&gt;     <br>&gt;     public init(_ base: Base) {<br>&gt;         _base = base<br>&gt;     }<br>&gt;     <br>&gt;     var _base: Base<br>&gt; }<br>&gt; <br>&gt; // Note: Requires T.Generator has value semantics<br>&gt; public struct MultipassIndex&lt;T: SequenceType&gt; : ForwardIndexType {<br>&gt;     public func successor() -&gt; MultipassIndex {<br>&gt;         var r = self<br>&gt;         if let (idx, val) = r.generator.next() {<br>&gt;             r.index = idx<br>&gt;             r.buffer = val<br>&gt;         } else {<br>&gt;             r.index = nil<br>&gt;             r.buffer = nil<br>&gt;         }<br>&gt;         return r<br>&gt;     }<br>&gt;     var index: Int?<br>&gt;     var buffer: T.Generator.Element?<br>&gt;     var generator: EnumerateSequence&lt;T&gt;.Generator<br>&gt; }<br>&gt; <br>&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;     return x.index == y.index<br>&gt; }<br>&gt; <br>&gt; //===--- An example fibonacci sequence ------------------------------------===//<br>&gt; struct FibGenerator : GeneratorType {<br>&gt;     mutating func next() -&gt; Int? {<br>&gt;         let c = a + b<br>&gt;         a = b<br>&gt;         b = c<br>&gt;         return a &lt; limit ? a : nil<br>&gt;     }<br>&gt;     var a, b, limit: Int<br>&gt; }<br>&gt; <br>&gt; <br>&gt; struct Fib : SequenceType {<br>&gt;     var limit = 100<br>&gt;     <br>&gt;     func generate() -&gt; FibGenerator {<br>&gt;         return Generator(a: 0, b: 1, limit: limit)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; It&#39;s true that ForwardIndexType is also run-through the base one by one but it also correct that getting specific value with specific index.<br>&gt; <br>&gt; c[c.startIndex.successor().successor().successor()] // it&#39;s a defined behave<br></p><p>Again, not sure what you’re trying to say here.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; 於 2016年1月1日 下午12:00 寫道：<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 7:46 PM, Susan Cheng &lt;susan.doggie at gmail.com &lt;mailto:susan.doggie at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How GeneratorType confirm to Equatable??<br>&gt;&gt; <br>&gt;&gt; I don’t understand the question.  In the code I posted there’s a working example of how a GeneratorType model can conform to Equatable..<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var a: Int<br>&gt;&gt;&gt;     var b: Int<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var limit: Int<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func generate() -&gt; FibGenerator {<br>&gt;&gt;&gt;         return Generator(a: a, b: b, limit: limit)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Susan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-01-01 11:17 GMT+08:00 Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;:<br>&gt;&gt;&gt; FWIW, Indexable is an implementation artifact that will go away when Swift’s generics system is improved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But if your real objection is that you have to come up with an Index and a subscripting operator, I can understand that.  Part of the reason for this is our reluctance to create any distinct protocols with identical syntactic requirements &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;&gt;.  To justify having a separate multi-pass sequence protocol, there would have to be a significant/important class of multi-pass sequences for which CollectionType was unimplementable without serious costs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In principle there’s a way to ease the pain of creating CollectionType conformances for multipass SequenceTypes…if only it didn’t crash the compiler &lt;https://bugs.swift.org/browse/SR-427 &lt;https://bugs.swift.org/browse/SR-427&gt;&gt; ;-).  Here’s a variation that uses a generic adapter instead of a protocol conformance declaration:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// A `CollectionType` containing the same elements as `Base`, without storing them.<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt;&gt;&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt;&gt;&gt; public struct Multipass&lt;Base: SequenceType where Base.Generator: Equatable&gt; : CollectionType {<br>&gt;&gt;&gt;   public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;&gt;     var g = _base.generate()<br>&gt;&gt;&gt;     return MultipassIndex(buffer: g.next(), generator: g)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;&gt;     return MultipassIndex(buffer: nil, generator: _base.generate())<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>&gt;&gt;&gt;     return position.buffer!<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   public init(_ base: Base) {<br>&gt;&gt;&gt;     _base = base<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var _base: Base<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Note: Requires T.Generator has value semantics<br>&gt;&gt;&gt; public struct MultipassIndex&lt;T: SequenceType where T.Generator: Equatable&gt; : ForwardIndexType {<br>&gt;&gt;&gt;   public func successor() -&gt; MultipassIndex {<br>&gt;&gt;&gt;     var r = self<br>&gt;&gt;&gt;     r.buffer = r.generator.next()<br>&gt;&gt;&gt;     return r<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   var buffer: T.Generator.Element?<br>&gt;&gt;&gt;   var generator: T.Generator<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;&gt;   return x.buffer == nil &amp;&amp; y.buffer == nil || x.generator == y.generator<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //===--- An example fibonacci sequence ------------------------------------===//<br>&gt;&gt;&gt; struct FibGenerator : GeneratorType {<br>&gt;&gt;&gt;   mutating func next() -&gt; Int? {<br>&gt;&gt;&gt;     let c = a + b<br>&gt;&gt;&gt;     a = b<br>&gt;&gt;&gt;     b = c<br>&gt;&gt;&gt;     return a &lt; limit ? a : nil<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   var a, b, limit: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;&gt;   var limit = 1000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func generate() -&gt; FibGenerator {<br>&gt;&gt;&gt;     return Generator(a: 0, b: 1, limit: limit)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //===--- Adapt Fib for use with Multipass ---------------------------------===//<br>&gt;&gt;&gt; extension FibGenerator : Equatable {}<br>&gt;&gt;&gt; func == (x: Fib.Generator, y: Fib.Generator) -&gt; Bool {<br>&gt;&gt;&gt;   return x.a == y.a<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //===--- Demonstration ----------------------------------------------------===//<br>&gt;&gt;&gt; let c = Multipass(Fib())<br>&gt;&gt;&gt; print(c.first)<br>&gt;&gt;&gt; print(c.count)<br>&gt;&gt;&gt; print(c.lazy.map { $0 + 1 })<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/8c157adf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf2e4441943974c6550424bb9fa45d6b?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Susan Cheng</string> &lt;susan.doggie at gmail.com&gt;<p>January  1, 2016 at 01:00:00pm</p></header><div class="content"><p>I didn&#39;t explain correctly.<br></p><p>let&#39;s take this:<br></p><p>let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br></p><p>this sequences should have results with [1, -1, 0, -1, -1, ...]<br>So is c.startIndex.successor() equal to<br>c.startIndex.successor().successor().successor()??<br></p><p>Dave Abrahams &lt;dabrahams at apple.com&gt; 於 2016年1月1日星期五 寫道：<br></p><p>&gt;<br>&gt; On Dec 31, 2015, at 8:22 PM, 鄭齊峯 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; if you try my modification, it will crash.<br>&gt;<br>&gt;<br>&gt; Only because your Sequence genereates an arithmetic underflow.  I don’t<br>&gt; understand what point you’re trying to make<br>&gt;<br>&gt;<br>&gt; struct Fib : SequenceType {<br>&gt;<br>&gt;     var a: Int<br>&gt;     var b: Int<br>&gt;<br>&gt;     var limit: Int<br>&gt;<br>&gt;     func generate() -&gt; FibGenerator {<br>&gt;         return Generator(a: a, b: b, limit: limit)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt;<br>&gt; A SequenceType becomes a CollectionType only work by adding a Index. that<br>&gt; the most significantly different of sequence and collection.<br>&gt;<br>&gt;<br>&gt; I think I understand that pretty well, having designed both of those<br>&gt; abstractions, but still don’t get your point.  Sorry, I’m trying here, but<br>&gt; I can’t figure out what you’re trying to tell me.<br>&gt;<br>&gt;<br>&gt; /// A `CollectionType` containing the same elements as `Base`, without<br>&gt; storing them.<br>&gt; ///<br>&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt; public struct Multipass&lt;Base: SequenceType&gt; : CollectionType {<br>&gt;     public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;         var g = _base.enumerate().generate()<br>&gt;         if let (idx, val) = g.next() {<br>&gt;             return MultipassIndex(index: idx, buffer: val, generator: g)<br>&gt;         }<br>&gt;         return MultipassIndex(index: nil, buffer: nil, generator: g)<br>&gt;     }<br>&gt;<br>&gt;     public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;         return MultipassIndex(index: nil, buffer: nil, generator: _base.<br>&gt; enumerate().generate())<br>&gt;     }<br>&gt;<br>&gt;     public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.<br>&gt; Element {<br>&gt;         return position.buffer!<br>&gt;     }<br>&gt;<br>&gt;     public init(_ base: Base) {<br>&gt;         _base = base<br>&gt;     }<br>&gt;<br>&gt;     var _base: Base<br>&gt; }<br>&gt;<br>&gt; // Note: Requires T.Generator has value semantics<br>&gt; public struct MultipassIndex&lt;T: SequenceType&gt; : ForwardIndexType {<br>&gt;     public func successor() -&gt; MultipassIndex {<br>&gt;         var r = self<br>&gt;         if let (idx, val) = r.generator.next() {<br>&gt;             r.index = idx<br>&gt;             r.buffer = val<br>&gt;         } else {<br>&gt;             r.index = nil<br>&gt;             r.buffer = nil<br>&gt;         }<br>&gt;         return r<br>&gt;     }<br>&gt;     var index: Int?<br>&gt;     var buffer: T.Generator.Element?<br>&gt;     var generator: EnumerateSequence&lt;T&gt;.Generator<br>&gt; }<br>&gt;<br>&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;     return x.index == y.index<br>&gt; }<br>&gt;<br>&gt; //===--- An example fibonacci sequence<br>&gt; ------------------------------------===//<br>&gt; struct FibGenerator : GeneratorType {<br>&gt;     mutating func next() -&gt; Int? {<br>&gt;         let c = a + b<br>&gt;         a = b<br>&gt;         b = c<br>&gt;         return a &lt; limit ? a : nil<br>&gt;     }<br>&gt;     var a, b, limit: Int<br>&gt; }<br>&gt;<br>&gt;<br>&gt; struct Fib : SequenceType {<br>&gt;     var limit = 100<br>&gt;<br>&gt;     func generate() -&gt; FibGenerator {<br>&gt;         return Generator(a: 0, b: 1, limit: limit)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; It&#39;s true that ForwardIndexType is also run-through the base one by one<br>&gt; but it also correct that getting specific value with specific index.<br>&gt;<br>&gt; c[c.startIndex.successor().successor().successor()] // it&#39;s a defined<br>&gt; behave<br>&gt;<br>&gt;<br>&gt; Again, not sure what you’re trying to say here.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Dave Abrahams &lt;dabrahams at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dabrahams at apple.com&#39;);&gt;&gt; 於 2016年1月1日<br>&gt; 下午12:00 寫道：<br>&gt;<br>&gt;<br>&gt; On Dec 31, 2015, at 7:46 PM, Susan Cheng &lt;susan.doggie at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;susan.doggie at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; How GeneratorType confirm to Equatable??<br>&gt;<br>&gt;<br>&gt; I don’t understand the question.  In the code I posted there’s a working<br>&gt; example of how a GeneratorType model can conform to Equatable..<br>&gt;<br>&gt;<br>&gt; struct Fib : SequenceType {<br>&gt;<br>&gt;     var a: Int<br>&gt;     var b: Int<br>&gt;<br>&gt;     var limit: Int<br>&gt;<br>&gt;     func generate() -&gt; FibGenerator {<br>&gt;         return Generator(a: a, b: b, limit: limit)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt;<br>&gt; -Susan<br>&gt;<br>&gt;<br>&gt; 2016-01-01 11:17 GMT+08:00 Dave Abrahams &lt;dabrahams at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dabrahams at apple.com&#39;);&gt;&gt;:<br>&gt;<br>&gt;&gt; FWIW, Indexable is an implementation artifact that will go away when<br>&gt;&gt; Swift’s generics system is improved.<br>&gt;&gt;<br>&gt;&gt; But if your real objection is that you have to come up with an Index and<br>&gt;&gt; a subscripting operator, I can understand that.  Part of the reason for<br>&gt;&gt; this is our reluctance to create any distinct protocols with identical<br>&gt;&gt; syntactic requirements &lt;<br>&gt;&gt; http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;.<br>&gt;&gt; To justify having a separate multi-pass sequence protocol, there would have<br>&gt;&gt; to be a significant/important class of multi-pass sequences for which<br>&gt;&gt; CollectionType was unimplementable without serious costs.<br>&gt;&gt;<br>&gt;&gt; In principle there’s a way to ease the pain of creating CollectionType<br>&gt;&gt; conformances for multipass SequenceTypes…if only it didn’t crash the<br>&gt;&gt; compiler &lt;https://bugs.swift.org/browse/SR-427&gt; ;-).  Here’s a variation<br>&gt;&gt; that uses a generic adapter instead of a protocol conformance declaration:<br>&gt;&gt;<br>&gt;&gt; /// A `CollectionType` containing the same elements as `Base`, without<br>&gt;&gt; storing them.<br>&gt;&gt; ///<br>&gt;&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt;&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt;&gt; public struct Multipass&lt;Base: SequenceType where Base.Generator:<br>&gt;&gt; Equatable&gt; : CollectionType {<br>&gt;&gt;   public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;     var g = _base.generate()<br>&gt;&gt;     return MultipassIndex(buffer: g.next(), generator: g)<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;     return MultipassIndex(buffer: nil, generator: _base.generate())<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   public subscript(position: MultipassIndex&lt;Base&gt;) -&gt;<br>&gt;&gt; Base.Generator.Element {<br>&gt;&gt;     return position.buffer!<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   public init(_ base: Base) {<br>&gt;&gt;     _base = base<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   var _base: Base<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Note: Requires T.Generator has value semantics<br>&gt;&gt; public struct MultipassIndex&lt;T: SequenceType where T.Generator:<br>&gt;&gt; Equatable&gt; : ForwardIndexType {<br>&gt;&gt;   public func successor() -&gt; MultipassIndex {<br>&gt;&gt;     var r = self<br>&gt;&gt;     r.buffer = r.generator.next()<br>&gt;&gt;     return r<br>&gt;&gt;   }<br>&gt;&gt;   var buffer: T.Generator.Element?<br>&gt;&gt;   var generator: T.Generator<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;   return x.buffer == nil &amp;&amp; y.buffer == nil || x.generator == y.generator<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; //===--- An example fibonacci sequence<br>&gt;&gt; ------------------------------------===//<br>&gt;&gt; struct FibGenerator : GeneratorType {<br>&gt;&gt;   mutating func next() -&gt; Int? {<br>&gt;&gt;     let c = a + b<br>&gt;&gt;     a = b<br>&gt;&gt;     b = c<br>&gt;&gt;     return a &lt; limit ? a : nil<br>&gt;&gt;   }<br>&gt;&gt;   var a, b, limit: Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;   var limit = 1000<br>&gt;&gt;<br>&gt;&gt;   func generate() -&gt; FibGenerator {<br>&gt;&gt;     return Generator(a: 0, b: 1, limit: limit)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; //===--- Adapt Fib for use with Multipass<br>&gt;&gt; ---------------------------------===//<br>&gt;&gt; extension FibGenerator : Equatable {}<br>&gt;&gt; func == (x: Fib.Generator, y: Fib.Generator) -&gt; Bool {<br>&gt;&gt;   return x.a == y.a<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; //===--- Demonstration<br>&gt;&gt; ----------------------------------------------------===//<br>&gt;&gt; let c = Multipass(Fib())<br>&gt;&gt; print(c.first)<br>&gt;&gt; print(c.count)<br>&gt;&gt; print(c.lazy.map { $0 + 1 })<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/c12e1eef/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  1, 2016 at 06:00:00pm</p></header><div class="content"><p>I see what you’ve done, now, after diffing your code with mine.  That’s a very nice improvement; it generalizes to cover more Sequences and doesn’t require an Equatable generator.  Great job!<br></p><p>&gt; On Dec 31, 2015, at 9:30 PM, Susan Cheng &lt;susan.doggie at gmail.com&gt; wrote:<br>&gt; <br>&gt; I didn&#39;t explain correctly.<br>&gt; <br>&gt; let&#39;s take this:<br>&gt; <br>&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt; <br>&gt; this sequences should have results with [1, -1, 0, -1, -1, ...]<br></p><p>&gt; So is c.startIndex.successor() equal to c.startIndex.successor().successor().successor()??<br>&gt; <br>&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; 於 2016年1月1日星期五 寫道：<br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 8:22 PM, 鄭齊峯 via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; if you try my modification, it will crash.<br>&gt; <br>&gt; Only because your Sequence genereates an arithmetic underflow.  I don’t understand what point you’re trying to make<br>&gt;&gt; <br>&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;     <br>&gt;&gt;     var a: Int<br>&gt;&gt;     var b: Int<br>&gt;&gt;     <br>&gt;&gt;     var limit: Int<br>&gt;&gt;     <br>&gt;&gt;     func generate() -&gt; FibGenerator {<br>&gt;&gt;         return Generator(a: a, b: b, limit: limit)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt;&gt; <br>&gt;&gt; A SequenceType becomes a CollectionType only work by adding a Index. that the most significantly different of sequence and collection.<br>&gt; <br>&gt; I think I understand that pretty well, having designed both of those abstractions, but still don’t get your point.  Sorry, I’m trying here, but I can’t figure out what you’re trying to tell me.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; /// A `CollectionType` containing the same elements as `Base`, without storing them.<br>&gt;&gt; ///<br>&gt;&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt;&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt;&gt; public struct Multipass&lt;Base: SequenceType&gt; : CollectionType {<br>&gt;&gt;     public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;         var g = _base.enumerate().generate()<br>&gt;&gt;         if let (idx, val) = g.next() {<br>&gt;&gt;             return MultipassIndex(index: idx, buffer: val, generator: g)<br>&gt;&gt;         }<br>&gt;&gt;         return MultipassIndex(index: nil, buffer: nil, generator: g)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;         return MultipassIndex(index: nil, buffer: nil, generator: _base.enumerate().generate())<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>&gt;&gt;         return position.buffer!<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     public init(_ base: Base) {<br>&gt;&gt;         _base = base<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var _base: Base<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Note: Requires T.Generator has value semantics<br>&gt;&gt; public struct MultipassIndex&lt;T: SequenceType&gt; : ForwardIndexType {<br>&gt;&gt;     public func successor() -&gt; MultipassIndex {<br>&gt;&gt;         var r = self<br>&gt;&gt;         if let (idx, val) = r.generator.next() {<br>&gt;&gt;             r.index = idx<br>&gt;&gt;             r.buffer = val<br>&gt;&gt;         } else {<br>&gt;&gt;             r.index = nil<br>&gt;&gt;             r.buffer = nil<br>&gt;&gt;         }<br>&gt;&gt;         return r<br>&gt;&gt;     }<br>&gt;&gt;     var index: Int?<br>&gt;&gt;     var buffer: T.Generator.Element?<br>&gt;&gt;     var generator: EnumerateSequence&lt;T&gt;.Generator<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;     return x.index == y.index<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //===--- An example fibonacci sequence ------------------------------------===//<br>&gt;&gt; struct FibGenerator : GeneratorType {<br>&gt;&gt;     mutating func next() -&gt; Int? {<br>&gt;&gt;         let c = a + b<br>&gt;&gt;         a = b<br>&gt;&gt;         b = c<br>&gt;&gt;         return a &lt; limit ? a : nil<br>&gt;&gt;     }<br>&gt;&gt;     var a, b, limit: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;     var limit = 100<br>&gt;&gt;     <br>&gt;&gt;     func generate() -&gt; FibGenerator {<br>&gt;&gt;         return Generator(a: 0, b: 1, limit: limit)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It&#39;s true that ForwardIndexType is also run-through the base one by one but it also correct that getting specific value with specific index.<br>&gt;&gt; <br>&gt;&gt; c[c.startIndex.successor().successor().successor()] // it&#39;s a defined behave<br>&gt; <br>&gt; Again, not sure what you’re trying to say here.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Dave Abrahams &lt;dabrahams at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dabrahams at apple.com&#39;);&gt;&gt; 於 2016年1月1日 下午12:00 寫道：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 7:46 PM, Susan Cheng &lt;susan.doggie at gmail.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;susan.doggie at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How GeneratorType confirm to Equatable??<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t understand the question.  In the code I posted there’s a working example of how a GeneratorType model can conform to Equatable..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var a: Int<br>&gt;&gt;&gt;&gt;     var b: Int<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var limit: Int<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     func generate() -&gt; FibGenerator {<br>&gt;&gt;&gt;&gt;         return Generator(a: a, b: b, limit: limit)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let c = Multipass(Fib(a: 1, b: -1, limit: 10))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Susan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016-01-01 11:17 GMT+08:00 Dave Abrahams &lt;dabrahams at apple.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;dabrahams at apple.com&#39;);&gt;&gt;:<br>&gt;&gt;&gt;&gt; FWIW, Indexable is an implementation artifact that will go away when Swift’s generics system is improved.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But if your real objection is that you have to come up with an Index and a subscripting operator, I can understand that.  Part of the reason for this is our reluctance to create any distinct protocols with identical syntactic requirements &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;&gt;.  To justify having a separate multi-pass sequence protocol, there would have to be a significant/important class of multi-pass sequences for which CollectionType was unimplementable without serious costs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In principle there’s a way to ease the pain of creating CollectionType conformances for multipass SequenceTypes…if only it didn’t crash the compiler &lt;https://bugs.swift.org/browse/SR-427 &lt;https://bugs.swift.org/browse/SR-427&gt;&gt; ;-).  Here’s a variation that uses a generic adapter instead of a protocol conformance declaration:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// A `CollectionType` containing the same elements as `Base`, without storing them.<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt;&gt;&gt;&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt;&gt;&gt;&gt; public struct Multipass&lt;Base: SequenceType where Base.Generator: Equatable&gt; : CollectionType {<br>&gt;&gt;&gt;&gt;   public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;&gt;&gt;     var g = _base.generate()<br>&gt;&gt;&gt;&gt;     return MultipassIndex(buffer: g.next(), generator: g)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;&gt;&gt;&gt;     return MultipassIndex(buffer: nil, generator: _base.generate())<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>&gt;&gt;&gt;&gt;     return position.buffer!<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public init(_ base: Base) {<br>&gt;&gt;&gt;&gt;     _base = base<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var _base: Base<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Note: Requires T.Generator has value semantics<br>&gt;&gt;&gt;&gt; public struct MultipassIndex&lt;T: SequenceType where T.Generator: Equatable&gt; : ForwardIndexType {<br>&gt;&gt;&gt;&gt;   public func successor() -&gt; MultipassIndex {<br>&gt;&gt;&gt;&gt;     var r = self<br>&gt;&gt;&gt;&gt;     r.buffer = r.generator.next()<br>&gt;&gt;&gt;&gt;     return r<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   var buffer: T.Generator.Element?<br>&gt;&gt;&gt;&gt;   var generator: T.Generator<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;&gt;&gt;   return x.buffer == nil &amp;&amp; y.buffer == nil || x.generator == y.generator<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //===--- An example fibonacci sequence ------------------------------------===//<br>&gt;&gt;&gt;&gt; struct FibGenerator : GeneratorType {<br>&gt;&gt;&gt;&gt;   mutating func next() -&gt; Int? {<br>&gt;&gt;&gt;&gt;     let c = a + b<br>&gt;&gt;&gt;&gt;     a = b<br>&gt;&gt;&gt;&gt;     b = c<br>&gt;&gt;&gt;&gt;     return a &lt; limit ? a : nil<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   var a, b, limit: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Fib : SequenceType {<br>&gt;&gt;&gt;&gt;   var limit = 1000<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func generate() -&gt; FibGenerator {<br>&gt;&gt;&gt;&gt;     return Generator(a: 0, b: 1, limit: limit)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //===--- Adapt Fib for use with Multipass ---------------------------------===//<br>&gt;&gt;&gt;&gt; extension FibGenerator : Equatable {}<br>&gt;&gt;&gt;&gt; func == (x: Fib.Generator, y: Fib.Generator) -&gt; Bool {<br>&gt;&gt;&gt;&gt;   return x.a == y.a<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //===--- Demonstration ----------------------------------------------------===//<br>&gt;&gt;&gt;&gt; let c = Multipass(Fib())<br>&gt;&gt;&gt;&gt; print(c.first)<br>&gt;&gt;&gt;&gt; print(c.count)<br>&gt;&gt;&gt;&gt; print(c.lazy.map { $0 + 1 })<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -Dave<br>&gt; <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/ce19c3ca/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 1:02 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 31, 2015, at 10:52 AM, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com &lt;mailto:oisin.kidney at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just to add to that, it’s always seemed strange to me that to signify your sequence is multi-pass (i.e., to make it conform to CollectionType) you have to have it conform to Indexable. <br>&gt; <br>&gt; FWIW, Indexable is an implementation artifact that will go away when Swift’s generics system is improved.<br>&gt; <br>&gt; But if your real objection is that you have to come up with an Index and a subscripting operator, I can understand that.  Part of the reason for this is our reluctance to create any distinct protocols with identical syntactic requirements &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;.  To justify having a separate multi-pass sequence protocol, there would have to be a significant/important class of multi-pass sequences for which CollectionType was unimplementable without serious costs.<br>&gt; <br>&gt; In principle there’s a way to ease the pain of creating CollectionType conformances for multipass SequenceTypes…if only it didn’t crash the compiler &lt;https://bugs.swift.org/browse/SR-427&gt; ;-).  Here’s a variation that uses a generic adapter instead of a protocol conformance declaration:<br></p><p>I probably failed to make clear that the code below works today, and doesn’t crash the compiler:<br></p><p>&gt; <br>&gt; /// A `CollectionType` containing the same elements as `Base`, without storing them.<br>&gt; ///<br>&gt; /// - Requires: `Base` supports multiple passes (traversing it does not<br>&gt; ///   consume the sequence), and `Base.Generator` has value semantics<br>&gt; public struct Multipass&lt;Base: SequenceType where Base.Generator: Equatable&gt; : CollectionType {<br>&gt;   public var startIndex: MultipassIndex&lt;Base&gt; {<br>&gt;     var g = _base.generate()<br>&gt;     return MultipassIndex(buffer: g.next(), generator: g)<br>&gt;   }<br>&gt;   <br>&gt;   public var endIndex: MultipassIndex&lt;Base&gt; {<br>&gt;     return MultipassIndex(buffer: nil, generator: _base.generate())<br>&gt;   }<br>&gt; <br>&gt;   public subscript(position: MultipassIndex&lt;Base&gt;) -&gt; Base.Generator.Element {<br>&gt;     return position.buffer!<br>&gt;   }<br>&gt; <br>&gt;   public init(_ base: Base) {<br>&gt;     _base = base<br>&gt;   }<br>&gt;   <br>&gt;   var _base: Base<br>&gt; }<br>&gt; <br>&gt; // Note: Requires T.Generator has value semantics<br>&gt; public struct MultipassIndex&lt;T: SequenceType where T.Generator: Equatable&gt; : ForwardIndexType {<br>&gt;   public func successor() -&gt; MultipassIndex {<br>&gt;     var r = self<br>&gt;     r.buffer = r.generator.next()<br>&gt;     return r<br>&gt;   }<br>&gt;   var buffer: T.Generator.Element?<br>&gt;   var generator: T.Generator<br>&gt; }<br>&gt; <br>&gt; public func == &lt;T&gt;(x: MultipassIndex&lt;T&gt;, y: MultipassIndex&lt;T&gt;) -&gt; Bool {<br>&gt;   return x.buffer == nil &amp;&amp; y.buffer == nil || x.generator == y.generator<br>&gt; }<br>&gt; <br>&gt; //===--- An example fibonacci sequence ------------------------------------===//<br>&gt; struct FibGenerator : GeneratorType {<br>&gt;   mutating func next() -&gt; Int? {<br>&gt;     let c = a + b<br>&gt;     a = b<br>&gt;     b = c<br>&gt;     return a &lt; limit ? a : nil<br>&gt;   }<br>&gt;   var a, b, limit: Int<br>&gt; }<br>&gt; <br>&gt; <br>&gt; struct Fib : SequenceType {<br>&gt;   var limit = 1000<br>&gt;   <br>&gt;   func generate() -&gt; FibGenerator {<br>&gt;     return Generator(a: 0, b: 1, limit: limit)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; //===--- Adapt Fib for use with Multipass ---------------------------------===//<br>&gt; extension FibGenerator : Equatable {}<br>&gt; func == (x: Fib.Generator, y: Fib.Generator) -&gt; Bool {<br>&gt;   return x.a == y.a<br>&gt; }<br>&gt; <br>&gt; //===--- Demonstration ----------------------------------------------------===//<br>&gt; let c = Multipass(Fib())<br>&gt; print(c.first)<br>&gt; print(c.count)<br>&gt; print(c.lazy.map { $0 + 1 })<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 31 Dec 2015, at 17:52, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m trying to work them out, so it&#39;s still muddled.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, I think SequenceType is better described as CollectionWalkType but that&#39;s kind of (1) a mouthful and (2) not entirely accurate. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moving back a step: SequenceType is defined as: &quot;A type that can be iterated with a `for`...`in` loop.&quot; But it says nothing about whether that loop ever terminates and many stdlib sequence functions currently don&#39;t make sense (at least if they&#39;re not lazy) with respect to infinite sequences, which should probably be &quot;StreamType&quot; not sequences. A couple of examples:<br>&gt;&gt;&gt; Here&#39;s my fib: http://swiftstub.com/189513594/ &lt;http://swiftstub.com/189513594/&gt;<br>&gt;&gt;&gt; And here&#39;s Oisin&#39;s user-input sequence:  https://gist.github.com/oisdk/2c7ac33bf2188528842a &lt;https://gist.github.com/oisdk/2c7ac33bf2188528842a&gt;<br>&gt;&gt;&gt; Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hopefully that&#39;s enough of a starting point to indicate where my thinking is at and what I&#39;m trying to think through when it comes to this. -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt;&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt;&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt;&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/f9ce8a2a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 9:52 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m trying to work them out, so it&#39;s still muddled.<br>&gt; <br>&gt; Right now, I think SequenceType is better described as CollectionWalkType<br></p><p>Why do you say so?<br></p><p>&gt; but that&#39;s kind of (1) a mouthful and (2) not entirely accurate. <br>&gt; <br>&gt; Moving back a step: SequenceType is defined as: &quot;A type that can be iterated with a `for`...`in` loop.&quot; But it says nothing about whether that loop ever terminates and many stdlib sequence functions currently don&#39;t make sense (at least if they&#39;re not lazy) with respect to infinite sequences, which should probably be &quot;StreamType&quot; not sequences. A couple of examples:<br>&gt; Here&#39;s my fib: http://swiftstub.com/189513594/ &lt;http://swiftstub.com/189513594/&gt;<br>&gt; And here&#39;s Oisin&#39;s user-input sequence:  https://gist.github.com/oisdk/2c7ac33bf2188528842a &lt;https://gist.github.com/oisdk/2c7ac33bf2188528842a&gt;<br>&gt; Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br>&gt; <br>&gt; Hopefully that&#39;s enough of a starting point to indicate where my thinking is at and what I&#39;m trying to think through when it comes to this. — E<br></p><p>All you’ve descrived here is the lack of a distinct protocol for finite sequences, which doesn&#39;t indicate “muddled concepts” at all.  It&#39;s a conscious choice of protocol granularity per this posting &lt;http://news.gmane.org/find-root.php?message_id=2A3E0C76-1C88-4752-8A70-AA64BB14223A at apple.com&gt;   In the development of the standard library we’ve tried to keep the API surface area small and given all the factors described in that posting, the conservative choice was to not separate them.<br></p><p>That’s not to say I’m opposed to carving out a place for finite sequences (and as we approach ABI stability now would be the time to do it) but I’d like to clearly understand why we’re doing it, and ideally I’d like to address all of the concerns noted in the post.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt;&gt; <br>&gt;&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/bd234265/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  6, 2016 at 09:00:00am</p></header><div class="content"><p>I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br></p><p>In Magic DWIM Swift, there would only be two types that you&#39;d ever conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some operations can meaningfully use either one (like forEach or maxElement); these operations go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br></p><p>In this world, both GeneratorType and CollectionType are refinements of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the necessary default implementations. Maybe we rename some of the protocols in the process. Again, no concrete type would ever conform to SequenceType; it&#39;s just something you can use as a generic constraint.<br></p><p>We can&#39;t actually do this today because it creates a circularity between SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s protocol checking logic to allow this, though.<br></p><p>Anyway, that&#39;s that idea. At the very least it helped me clear up my thoughts about Sequence, Collection, and Generator back when I was first learning them.<br></p><p>Jordan<br></p><p>P.S. This idea falls apart if someone comes up with a model (concrete type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able to think of one back when I was originally thinking about this, but of course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the sequence/generator distinction that&#39;s really meaningful there.)<br></p><p><br>&gt; On Dec 31, 2015, at 9:52, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m trying to work them out, so it&#39;s still muddled.<br>&gt; <br>&gt; Right now, I think SequenceType is better described as CollectionWalkType but that&#39;s kind of (1) a mouthful and (2) not entirely accurate. <br>&gt; <br>&gt; Moving back a step: SequenceType is defined as: &quot;A type that can be iterated with a `for`...`in` loop.&quot; But it says nothing about whether that loop ever terminates and many stdlib sequence functions currently don&#39;t make sense (at least if they&#39;re not lazy) with respect to infinite sequences, which should probably be &quot;StreamType&quot; not sequences. A couple of examples:<br>&gt; Here&#39;s my fib: http://swiftstub.com/189513594/ &lt;http://swiftstub.com/189513594/&gt;<br>&gt; And here&#39;s Oisin&#39;s user-input sequence:  https://gist.github.com/oisdk/2c7ac33bf2188528842a &lt;https://gist.github.com/oisdk/2c7ac33bf2188528842a&gt;<br>&gt; Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br>&gt; <br>&gt; Hopefully that&#39;s enough of a starting point to indicate where my thinking is at and what I&#39;m trying to think through when it comes to this. -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt;&gt; <br>&gt;&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/d4e51ece/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: open<br>Type: image/gif<br>Size: 43 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/d4e51ece/attachment.gif&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 11:37 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br>&gt; <br>&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some operations can meaningfully use either one (like forEach or maxElement); these operations go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt; <br>&gt; In this world, both GeneratorType and CollectionType are refinements of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the necessary default implementations. Maybe we rename some of the protocols in the process. Again, no concrete type would ever conform to SequenceType; it&#39;s just something you can use as a generic constraint.<br>&gt; <br>&gt; We can&#39;t actually do this today because it creates a circularity between SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s protocol checking logic to allow this, though.<br>&gt; <br>&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my thoughts about Sequence, Collection, and Generator back when I was first learning them.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. This idea falls apart if someone comes up with a model (concrete type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able to think of one back when I was originally thinking about this, but of course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the sequence/generator distinction that&#39;s really meaningful there.)<br></p><p>It’s not clear what you mean by a `SequenceType` that isn’t either a `Collection` or a `Generator`, but if you mean a *concrete* sequence that:<br></p><p>- can be re-iterated (thus not a `Generator`)<br>- has no meaningful index (!) (thus not a `Collection`)<br></p><p>…then I can provide you with examples of such. The (!) is b/c you can of course always use `Int` as an index, in the sense that “the value at index `n` is obtained by iterating `n` steps from the start of the sequence”; I’ll assume this doesn’t “count” as an index for purposes of this discussion.<br></p><p>Given the above, I will provide two examples.<br></p><p>Here is one that is stable, re-iterable, infinite, and has no “non-trivial&quot; index:<br></p><p>    // Modest generalization of a seedable PRNG.<br>    // We assume that identically-seeded sources generate<br>    // identical elements (via `randomElement`), in identical order.<br>    protocol RandomElementSourceType {<br></p><p>      typealias Element<br>      typealias Seed: Equatable<br>      // ^ `:Equatable` isn&#39;t actually necessary, but it&#39;s nice<br>  <br>      init(seed: Seed)<br>  <br>      mutating func randomElement() -&gt; Element<br></p><p>    }<br></p><p>    struct RandomElementGenerator&lt;R:RandomElementSourceType&gt; : GeneratorType {<br></p><p>      typealias Element = R.Element<br>  <br>      private var source: R<br>  <br>      mutating func next() -&gt; Element? {<br>        return source.randomElement() // &lt;- never stops!<br>      }<br>  <br>    }<br></p><p>    struct RandomElementSequence&lt;R:RandomElementSourceType&gt; : SequenceType {<br></p><p>      typealias Generator = RandomElementGenerator&lt;R&gt;<br>  <br>      private let seed: R.Seed<br>  <br>      func generate() -&gt; Generator {<br>        return Generator(source: R(seed: seed))<br>        // ^ as per assumptions, each iteration will be identical b/c<br>        //   because each iteration uses the same seed <br>      }<br></p><p>    }<br></p><p>…and here is one that is not-necessarily-stable, reiteration-capable, finite (one hopes!), and with no “non-trivial” index:<br></p><p>    struct SuperviewGenerator : GeneratorType {<br>    <br>      typealias Element = UIView<br>    <br>      private var currentView: UIView? // or NSView on OS X, etc.<br>      <br>      private init(initialView: UIView?) {<br>        currentView = initialView<br>      }<br>      <br>      mutating func next() -&gt; Element? {<br>        guard let here = currentView else {<br>          return nil<br>        }<br>        currentView = here.superview<br>        return here<br>      }<br>    <br>    }<br></p><p>    // also e.g. analogous constructs for `CALayer`,<br>    // `UIViewController`, `UIResponder`, “folders/directories”, and so on...<br>    struct SuperviewSequence : SequenceType {<br></p><p>      typealias Generator = SuperviewGenerator<br>      <br>      private let initialView: UIView?<br>      <br>      init(initialView: UIView?) {<br>        self.initialView = initialView<br>      }<br>      <br>      func generate() -&gt; Generator {<br>        return Generator(initialView: initialView)<br>      }<br>      <br>      func underestimateCount() -&gt; Int {<br>        return initialView != nil ? 1 : 0<br>      }<br>      <br>    }<br>    <br>    // Useful extensions:<br>    extension UIView {<br>    <br>      // Enumerates the view hierarchy upward from `self`, including `self`.<br>      func inclusiveSuperviewSequence() -&gt; SuperviewSequence {<br>        return SuperviewSequence(initialView: self)<br>      }<br>      <br>      // Enumerates the view hierarchy upward from `self`, omitting `self`.<br>      func exclusiveSuperviewSequence() -&gt; SuperviewSequence { <br>        return SuperviewSequence(initialView: self.superview)<br>      }<br>    <br>    }<br></p><p><br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 9:52, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m trying to work them out, so it&#39;s still muddled.<br>&gt;&gt; <br>&gt;&gt; Right now, I think SequenceType is better described as CollectionWalkType but that&#39;s kind of (1) a mouthful and (2) not entirely accurate. <br>&gt;&gt; <br>&gt;&gt; Moving back a step: SequenceType is defined as: &quot;A type that can be iterated with a `for`...`in` loop.&quot; But it says nothing about whether that loop ever terminates and many stdlib sequence functions currently don&#39;t make sense (at least if they&#39;re not lazy) with respect to infinite sequences, which should probably be &quot;StreamType&quot; not sequences. A couple of examples:<br>&gt;&gt; Here&#39;s my fib: http://swiftstub.com/189513594/ &lt;http://swiftstub.com/189513594/&gt;<br>&gt;&gt; And here&#39;s Oisin&#39;s user-input sequence:  https://gist.github.com/oisdk/2c7ac33bf2188528842a &lt;https://gist.github.com/oisdk/2c7ac33bf2188528842a&gt;<br>&gt;&gt; Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br>&gt;&gt; <br>&gt;&gt; Hopefully that&#39;s enough of a starting point to indicate where my thinking is at and what I&#39;m trying to think through when it comes to this. -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &lt;open.gif&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/1744eea1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 10:42, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 6, 2016, at 11:37 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br>&gt;&gt; <br>&gt;&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some operations can meaningfully use either one (like forEach or maxElement); these operations go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt;&gt; <br>&gt;&gt; In this world, both GeneratorType and CollectionType are refinements of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the necessary default implementations. Maybe we rename some of the protocols in the process. Again, no concrete type would ever conform to SequenceType; it&#39;s just something you can use as a generic constraint.<br>&gt;&gt; <br>&gt;&gt; We can&#39;t actually do this today because it creates a circularity between SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s protocol checking logic to allow this, though.<br>&gt;&gt; <br>&gt;&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my thoughts about Sequence, Collection, and Generator back when I was first learning them.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. This idea falls apart if someone comes up with a model (concrete type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able to think of one back when I was originally thinking about this, but of course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the sequence/generator distinction that&#39;s really meaningful there.)<br>&gt; <br>&gt; It’s not clear what you mean by a `SequenceType` that isn’t either a `Collection` or a `Generator`, but if you mean a *concrete* sequence that:<br>&gt; <br>&gt; - can be re-iterated (thus not a `Generator`)<br>&gt; - has no meaningful index (!) (thus not a `Collection`)<br>&gt; <br>&gt; …then I can provide you with examples of such. The (!) is b/c you can of course always use `Int` as an index, in the sense that “the value at index `n` is obtained by iterating `n` steps from the start of the sequence”; I’ll assume this doesn’t “count” as an index for purposes of this discussion.<br>&gt; <br>&gt; Given the above, I will provide two examples.<br>&gt; <br>&gt; Here is one that is stable, re-iterable, infinite, and has no “non-trivial&quot; index:<br>&gt; <br>&gt;     // Modest generalization of a seedable PRNG.<br>&gt;     // We assume that identically-seeded sources generate<br>&gt;     // identical elements (via `randomElement`), in identical order.<br>&gt;     protocol RandomElementSourceType {<br>&gt; <br>&gt;       typealias Element<br>&gt;       typealias Seed: Equatable<br>&gt;       // ^ `:Equatable` isn&#39;t actually necessary, but it&#39;s nice<br>&gt;   <br>&gt;       init(seed: Seed)<br>&gt;   <br>&gt;       mutating func randomElement() -&gt; Element<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     struct RandomElementGenerator&lt;R:RandomElementSourceType&gt; : GeneratorType {<br>&gt; <br>&gt;       typealias Element = R.Element<br>&gt;   <br>&gt;       private var source: R<br>&gt;   <br>&gt;       mutating func next() -&gt; Element? {<br>&gt;         return source.randomElement() // &lt;- never stops!<br>&gt;       }<br>&gt;   <br>&gt;     }<br>&gt; <br>&gt;     struct RandomElementSequence&lt;R:RandomElementSourceType&gt; : SequenceType {<br>&gt; <br>&gt;       typealias Generator = RandomElementGenerator&lt;R&gt;<br>&gt;   <br>&gt;       private let seed: R.Seed<br>&gt;   <br>&gt;       func generate() -&gt; Generator {<br>&gt;         return Generator(source: R(seed: seed))<br>&gt;         // ^ as per assumptions, each iteration will be identical b/c<br>&gt;         //   because each iteration uses the same seed <br>&gt;       }<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; …and here is one that is not-necessarily-stable, reiteration-capable, finite (one hopes!), and with no “non-trivial” index:<br>&gt; <br>&gt;     struct SuperviewGenerator : GeneratorType {<br>&gt;     <br>&gt;       typealias Element = UIView<br>&gt;     <br>&gt;       private var currentView: UIView? // or NSView on OS X, etc.<br>&gt;       <br>&gt;       private init(initialView: UIView?) {<br>&gt;         currentView = initialView<br>&gt;       }<br>&gt;       <br>&gt;       mutating func next() -&gt; Element? {<br>&gt;         guard let here = currentView else {<br>&gt;           return nil<br>&gt;         }<br>&gt;         currentView = here.superview<br>&gt;         return here<br>&gt;       }<br>&gt;     <br>&gt;     }<br>&gt; <br>&gt;     // also e.g. analogous constructs for `CALayer`,<br>&gt;     // `UIViewController`, `UIResponder`, “folders/directories”, and so on...<br>&gt;     struct SuperviewSequence : SequenceType {<br>&gt; <br>&gt;       typealias Generator = SuperviewGenerator<br>&gt;       <br>&gt;       private let initialView: UIView?<br>&gt;       <br>&gt;       init(initialView: UIView?) {<br>&gt;         self.initialView = initialView<br>&gt;       }<br>&gt;       <br>&gt;       func generate() -&gt; Generator {<br>&gt;         return Generator(initialView: initialView)<br>&gt;       }<br>&gt;       <br>&gt;       func underestimateCount() -&gt; Int {<br>&gt;         return initialView != nil ? 1 : 0<br>&gt;       }<br>&gt;       <br>&gt;     }<br>&gt;     <br>&gt;     // Useful extensions:<br>&gt;     extension UIView {<br>&gt;     <br>&gt;       // Enumerates the view hierarchy upward from `self`, including `self`.<br>&gt;       func inclusiveSuperviewSequence() -&gt; SuperviewSequence {<br>&gt;         return SuperviewSequence(initialView: self)<br>&gt;       }<br>&gt;       <br>&gt;       // Enumerates the view hierarchy upward from `self`, omitting `self`.<br>&gt;       func exclusiveSuperviewSequence() -&gt; SuperviewSequence { <br>&gt;         return SuperviewSequence(initialView: self.superview)<br>&gt;       }<br>&gt;     <br>&gt;     }<br></p><p>I&#39;ve been musing over these for a few days, and I think the answers are that RandomElementSequence would be a Generator and SuperviewSequence would be a Collection.<br></p><p>RandomElementSequence: As you say, this type is copyable, but its iteration is destructive: you can&#39;t get back to a previous state via any sort of Index. But that&#39;s not a distinction between Sequence and Generator today; there are some Generators that are perfectly copyable and others that are not. (Ideally, the ones that aren&#39;t would be made into classes.) If all you have is a generic Generator, you can only iterate it once…but the same is true of Sequence. Knowing the concrete type <br></p><p>Sure, you could come up with a new protocol, MultipassSequence, but you could just as easily have a MultipassGenerator that just means &quot;this generator is safe to copy&quot;. (That&#39;s basically InputIterator vs. ForwardIterator &lt;http://en.cppreference.com/w/cpp/iterator&gt; in C++.)<br></p><p>(Another direction to take this: a degenerate case of an index would be &quot;the entire state of the underlying RNG&quot;, but that&#39;s not always possible with, say, access control.)<br></p><p>SuperviewSequence: Right, so, I claim this is a Collection. Here&#39;s my index:<br></p><p>public struct SuperviewIndex: ForwardIndexType {<br>  var currentNode: AnyClass?<br></p><p>  func successor() -&gt; SuperviewIndex {<br>    guard let currentNode = self.currentNode else {<br>      fatalError(&quot;advanced past the end SuperviewIndex&quot;)<br>    }<br>    return SuperviewIndex(currentNode.superclass)<br>  }<br>}<br></p><p>and the CollectionType implementation:<br></p><p>public var startIndex: SuperviewIndex { return .init(startNode) }<br>public var endIndex: SuperviewIndex { return .init(nil) }<br></p><p>public subscript(index: SuperviewIndex) {<br>    guard let currentNode = index.currentNode else {<br>      fatalError(&quot;accessed endIndex&quot;)<br>    }<br>    // Debug-only assertion<br>    assert(self.indices.contains(index), &quot;not part of this superclass hierarchy&quot;)<br>    return currentNode<br>}<br></p><p>It is a little weird that the subscript doesn&#39;t depend on &#39;self&#39; at all, but that&#39;s just the nature of the collection: if you want an O(1) access, you&#39;re not going through the collection at all. (Try to implement a linked list that conforms to CollectionType using a class and you&#39;ll see the same thing. Implement one using an enum and it&#39;s even weirder.)<br></p><p><br>I&#39;m still trying to come up with a good response to Erica&#39;s idea that GeneratorType and CollectionType don&#39;t inherently have anything in common, but the gist of it is that there are useful operations common to both kinds of values, which suggests the existence of a more general abstraction. That is, there are things that are obviously Collections and things that are obviously not Collections but could still be Generators, and there are operations (currently on SequenceType) that apply to both.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/ada85d52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 5:21 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 6, 2016, at 10:42, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 11:37 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some operations can meaningfully use either one (like forEach or maxElement); these operations go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this world, both GeneratorType and CollectionType are refinements of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the necessary default implementations. Maybe we rename some of the protocols in the process. Again, no concrete type would ever conform to SequenceType; it&#39;s just something you can use as a generic constraint.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can&#39;t actually do this today because it creates a circularity between SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s protocol checking logic to allow this, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my thoughts about Sequence, Collection, and Generator back when I was first learning them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S. This idea falls apart if someone comes up with a model (concrete type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able to think of one back when I was originally thinking about this, but of course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the sequence/generator distinction that&#39;s really meaningful there.)<br>&gt;&gt; <br>&gt;&gt; It’s not clear what you mean by a `SequenceType` that isn’t either a `Collection` or a `Generator`, but if you mean a *concrete* sequence that:<br>&gt;&gt; <br>&gt;&gt; - can be re-iterated (thus not a `Generator`)<br>&gt;&gt; - has no meaningful index (!) (thus not a `Collection`)<br>&gt;&gt; <br>&gt;&gt; …then I can provide you with examples of such. The (!) is b/c you can of course always use `Int` as an index, in the sense that “the value at index `n` is obtained by iterating `n` steps from the start of the sequence”; I’ll assume this doesn’t “count” as an index for purposes of this discussion.<br>&gt;&gt; <br>&gt;&gt; Given the above, I will provide two examples.<br>&gt;&gt; <br>&gt;&gt; Here is one that is stable, re-iterable, infinite, and has no “non-trivial&quot; index:<br>&gt;&gt; <br>&gt;&gt;     // Modest generalization of a seedable PRNG.<br>&gt;&gt;     // We assume that identically-seeded sources generate<br>&gt;&gt;     // identical elements (via `randomElement`), in identical order.<br>&gt;&gt;     protocol RandomElementSourceType {<br>&gt;&gt; <br>&gt;&gt;       typealias Element<br>&gt;&gt;       typealias Seed: Equatable<br>&gt;&gt;       // ^ `:Equatable` isn&#39;t actually necessary, but it&#39;s nice<br>&gt;&gt;   <br>&gt;&gt;       init(seed: Seed)<br>&gt;&gt;   <br>&gt;&gt;       mutating func randomElement() -&gt; Element<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     struct RandomElementGenerator&lt;R:RandomElementSourceType&gt; : GeneratorType {<br>&gt;&gt; <br>&gt;&gt;       typealias Element = R.Element<br>&gt;&gt;   <br>&gt;&gt;       private var source: R<br>&gt;&gt;   <br>&gt;&gt;       mutating func next() -&gt; Element? {<br>&gt;&gt;         return source.randomElement() // &lt;- never stops!<br>&gt;&gt;       }<br>&gt;&gt;   <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     struct RandomElementSequence&lt;R:RandomElementSourceType&gt; : SequenceType {<br>&gt;&gt; <br>&gt;&gt;       typealias Generator = RandomElementGenerator&lt;R&gt;<br>&gt;&gt;   <br>&gt;&gt;       private let seed: R.Seed<br>&gt;&gt;   <br>&gt;&gt;       func generate() -&gt; Generator {<br>&gt;&gt;         return Generator(source: R(seed: seed))<br>&gt;&gt;         // ^ as per assumptions, each iteration will be identical b/c<br>&gt;&gt;         //   because each iteration uses the same seed <br>&gt;&gt;       }<br>&gt;&gt; <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; …and here is one that is not-necessarily-stable, reiteration-capable, finite (one hopes!), and with no “non-trivial” index:<br>&gt;&gt; <br>&gt;&gt;     struct SuperviewGenerator : GeneratorType {<br>&gt;&gt;     <br>&gt;&gt;       typealias Element = UIView<br>&gt;&gt;     <br>&gt;&gt;       private var currentView: UIView? // or NSView on OS X, etc.<br>&gt;&gt;       <br>&gt;&gt;       private init(initialView: UIView?) {<br>&gt;&gt;         currentView = initialView<br>&gt;&gt;       }<br>&gt;&gt;       <br>&gt;&gt;       mutating func next() -&gt; Element? {<br>&gt;&gt;         guard let here = currentView else {<br>&gt;&gt;           return nil<br>&gt;&gt;         }<br>&gt;&gt;         currentView = here.superview<br>&gt;&gt;         return here<br>&gt;&gt;       }<br>&gt;&gt;     <br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // also e.g. analogous constructs for `CALayer`,<br>&gt;&gt;     // `UIViewController`, `UIResponder`, “folders/directories”, and so on...<br>&gt;&gt;     struct SuperviewSequence : SequenceType {<br>&gt;&gt; <br>&gt;&gt;       typealias Generator = SuperviewGenerator<br>&gt;&gt;       <br>&gt;&gt;       private let initialView: UIView?<br>&gt;&gt;       <br>&gt;&gt;       init(initialView: UIView?) {<br>&gt;&gt;         self.initialView = initialView<br>&gt;&gt;       }<br>&gt;&gt;       <br>&gt;&gt;       func generate() -&gt; Generator {<br>&gt;&gt;         return Generator(initialView: initialView)<br>&gt;&gt;       }<br>&gt;&gt;       <br>&gt;&gt;       func underestimateCount() -&gt; Int {<br>&gt;&gt;         return initialView != nil ? 1 : 0<br>&gt;&gt;       }<br>&gt;&gt;       <br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // Useful extensions:<br>&gt;&gt;     extension UIView {<br>&gt;&gt;     <br>&gt;&gt;       // Enumerates the view hierarchy upward from `self`, including `self`.<br>&gt;&gt;       func inclusiveSuperviewSequence() -&gt; SuperviewSequence {<br>&gt;&gt;         return SuperviewSequence(initialView: self)<br>&gt;&gt;       }<br>&gt;&gt;       <br>&gt;&gt;       // Enumerates the view hierarchy upward from `self`, omitting `self`.<br>&gt;&gt;       func exclusiveSuperviewSequence() -&gt; SuperviewSequence { <br>&gt;&gt;         return SuperviewSequence(initialView: self.superview)<br>&gt;&gt;       }<br>&gt;&gt;     <br>&gt;&gt;     }<br>&gt; <br>&gt; I&#39;ve been musing over these for a few days, and I think the answers are that RandomElementSequence would be a Generator and SuperviewSequence would be a Collection.<br>&gt; <br>&gt; RandomElementSequence: As you say, this type is copyable, but its iteration is destructive: you can&#39;t get back to a previous state via any sort of Index. But that&#39;s not a distinction between Sequence and Generator today; there are some Generators that are perfectly copyable and others that are not. (Ideally, the ones that aren&#39;t would be made into classes.) If all you have is a generic Generator, you can only iterate it once…but the same is true of Sequence. Knowing the concrete type <br></p><p>^ did something get edited out here?<br></p><p>&gt; <br>&gt; Sure, you could come up with a new protocol, MultipassSequence, but you could just as easily have a MultipassGenerator that just means &quot;this generator is safe to copy&quot;. (That&#39;s basically InputIterator vs. ForwardIterator &lt;http://en.cppreference.com/w/cpp/iterator&gt; in C++.)<br></p><p>I’m almost ready to make a proposal for something along those lines, actually, although these responses mean I’ll be revising it a bit first.<br></p><p>&gt; <br>&gt; (Another direction to take this: a degenerate case of an index would be &quot;the entire state of the underlying RNG&quot;, but that&#39;s not always possible with, say, access control.)<br></p><p>Dmitri suggested this also; I don’t see what the natural `endIndex` would be here (that isn’t just, say, created by artificially truncating the underlying sequence).<br></p><p>&gt; SuperviewSequence: Right, so, I claim this is a Collection. Here&#39;s my index:<br>&gt; <br>&gt; public struct SuperviewIndex: ForwardIndexType {<br>&gt;   var currentNode: AnyClass?<br>&gt; <br>&gt;   func successor() -&gt; SuperviewIndex {<br>&gt;     guard let currentNode = self.currentNode else {<br>&gt;       fatalError(&quot;advanced past the end SuperviewIndex&quot;)<br>&gt;     }<br>&gt;     return SuperviewIndex(currentNode.superclass)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; and the CollectionType implementation:<br>&gt; <br>&gt; public var startIndex: SuperviewIndex { return .init(startNode) }<br>&gt; public var endIndex: SuperviewIndex { return .init(nil) }<br>&gt; <br>&gt; public subscript(index: SuperviewIndex) {<br>&gt;     guard let currentNode = index.currentNode else {<br>&gt;       fatalError(&quot;accessed endIndex&quot;)<br>&gt;     }<br>&gt;     // Debug-only assertion<br>&gt;     assert(self.indices.contains(index), &quot;not part of this superclass hierarchy&quot;)<br>&gt;     return currentNode<br>&gt; }<br></p><p>I have to hand it to you here, it really does meet the requirements; this is a good trick to be aware of. <br></p><p>Interestingly-enough, I hadn’t actually actually considered writing a superclass sequence, but it’d certainly have its own uses.<br></p><p>It also highlights that `ForwardIndexType` and `GeneratorType` are suspiciously similar, and would be even more so in a “collections move indices” world (e.g. SR-122, which I hope is adopted in some form).<br></p><p>&gt; <br>&gt; It is a little weird that the subscript doesn&#39;t depend on &#39;self&#39; at all, but that&#39;s just the nature of the collection: if you want an O(1) access, you&#39;re not going through the collection at all. (Try to implement a linked list that conforms to CollectionType using a class and you&#39;ll see the same thing. Implement one using an enum and it&#39;s even weirder.)<br>&gt; <br>&gt; <br>&gt; I&#39;m still trying to come up with a good response to Erica&#39;s idea that GeneratorType and CollectionType don&#39;t inherently have anything in common, but the gist of it is that there are useful operations common to both kinds of values, which suggests the existence of a more general abstraction. That is, there are things that are obviously Collections and things that are obviously not Collections but could still be Generators, and there are operations (currently on SequenceType) that apply to both.<br></p><p>FWIW, I’d say that it’s less that theres an actual common abstraction here as that you have a bunch of operations that *could* be defined on `GeneratorType` (though currently are-defined on `SequenceType`), but because you can always get a “canonical” generator from a `CollectionType` it becomes easy to start eliding this distinction…and after awhile you might start referring to these generator-operations as applying to both.<br></p><p>That’s just one interpretation, though.<br></p><p>Thanks for the considered response; I’ve picked up a couple tricks and now have some food for thought.<br></p><p>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/ea52d0de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 18:35 , plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; RandomElementSequence: As you say, this type is copyable, but its iteration is destructive: you can&#39;t get back to a previous state via any sort of Index. But that&#39;s not a distinction between Sequence and Generator today; there are some Generators that are perfectly copyable and others that are not. (Ideally, the ones that aren&#39;t would be made into classes.) If all you have is a generic Generator, you can only iterate it once…but the same is true of Sequence. Knowing the concrete type <br>&gt; <br>&gt; ^ did something get edited out here?<br></p><p>Oops, yes. &quot;Knowing the concrete type is the only way to guarantee that multiple iteration is safe.&quot; And then:<br></p><p>&gt;&gt; Sure, you could come up with a new protocol, MultipassSequence, but you could just as easily have a MultipassGenerator that just means &quot;this generator is safe to copy&quot;. (That&#39;s basically InputIterator vs. ForwardIterator &lt;http://en.cppreference.com/w/cpp/iterator&gt; in C++.)<br></p><p><br></p><p>Also:<br></p><p>&gt; It also highlights that `ForwardIndexType` and `GeneratorType` are suspiciously similar, and would be even more so in a “collections move indices” world (e.g. SR-122, which I hope is adopted in some form).<br></p><p>I guess this is true, in that both produce a single successor, but (a) ForwardIndexType is non-destructive whereas GeneratorType may be, and (b) in that new model, ForwardIndexType does not know its successor whereas GeneratorType does.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/429ca196/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 11:55 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 18:35 , plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; RandomElementSequence: As you say, this type is copyable, but its iteration is destructive: you can&#39;t get back to a previous state via any sort of Index. But that&#39;s not a distinction between Sequence and Generator today; there are some Generators that are perfectly copyable and others that are not. (Ideally, the ones that aren&#39;t would be made into classes.) If all you have is a generic Generator, you can only iterate it once…but the same is true of Sequence. Knowing the concrete type <br>&gt;&gt; <br>&gt;&gt; ^ did something get edited out here?<br>&gt; <br>&gt; Oops, yes. &quot;Knowing the concrete type is the only way to guarantee that multiple iteration is safe.&quot; And then:<br>&gt; <br>&gt;&gt;&gt; Sure, you could come up with a new protocol, MultipassSequence, but you could just as easily have a MultipassGenerator that just means &quot;this generator is safe to copy&quot;. (That&#39;s basically InputIterator vs. ForwardIterator &lt;http://en.cppreference.com/w/cpp/iterator&gt; in C++.)<br>&gt; <br>&gt; <br>&gt; <br>&gt; Also:<br>&gt; <br>&gt;&gt; It also highlights that `ForwardIndexType` and `GeneratorType` are suspiciously similar, and would be even more so in a “collections move indices” world (e.g. SR-122, which I hope is adopted in some form).<br>&gt; <br>&gt; I guess this is true, in that both produce a single successor, but (a) ForwardIndexType is non-destructive whereas GeneratorType may be, and (b) in that new model, ForwardIndexType does not know its successor whereas GeneratorType does.<br></p><p>It’s not so much that they both produce a single successor; it’s that both of them can wind up with most of their “interesting&quot; logic essentially-shared.<br></p><p>Consider the following thought experiment:<br></p><p>protocol AlternativeCollectionType {<br>  typealias InternalPosition: Equatable<br>  typealias Item // so-named so as to avoid some later circularity<br>  <br>  var startPosition: InternalPosition { get }<br>  var endPosition: InternalPosition { get }<br>  subscript(position: InternalPosition) -&gt; Item { get }<br></p><p>  // - requires: `position != endPosition`<br>  func successorFor(position: InternalPosition) -&gt; InternalPosition<br>  <br>}<br></p><p>// assume `==` just examines position (which seems fair here):<br>struct ConcretePosition&lt;C:AlternativeCollectionType&gt; : Equatable {<br>  typealias Element = C.Item<br></p><p>  private let collection: C<br>  private var position: C.InternalPosition<br></p><p>  func isEndPosition() -&gt; Bool {<br>    return position == collection.endPosition<br>  }<br></p><p>  func dereference() -&gt; Element? {<br>    if isEndPosition() { return nil }<br>    return collection[position]<br>  }<br></p><p>  private func nextPosition() -&gt; C.InternalPosition {<br>    precondition(!isEndPosition())<br>    return collection.successorFor(position)<br>  }<br></p><p>}<br></p><p>extension ConcretePosition : ForwardIndexType {<br>  func successor() -&gt; ConcretePosition&lt;C&gt; { <br>    return ConcretePosition&lt;C&gt;(<br>      collection: collection,<br>      position: nextPosition()<br>    )<br>  }<br>}<br></p><p>extension ConcretePosition: GeneratorType {<br>  mutating func next() -&gt; Element? {<br>    guard let element = dereference() else { return nil }<br>    position = nextPosition()<br>    return element<br>  }<br>}<br></p><p>I think the *similarity* under this organization is pretty straightforward; although `successor()` and `next()` are definitely *not* identical, they can both be implemented as operations on the same base type, with a lot the logic being essentially common to both (that’s the part written here as `nextPosition`, which simply calls the collection&#39;s `successorFor`).<br></p><p>Note that under Swift’s current organization, that common logic winds up manually-inlined into both `next` and `successor`, often in ways that make the commonality harder to spot.<br></p><p>The above experiment’s connection-with “collections move indices” is also I hope pretty easy to spot; if you accept the premise that most concrete `ForwardIndexType` implementations will in fact need a back-reference — or the moral equivalent thereof — to be able to implement the ostensibly stand-alone `successor()`, then it seems reasonable to consider the possibility that the stand-alone `successor` is actually the special-case (a very handy case, but still a special case); if you don’t accept that premise, we’ll have to agree to disagree.<br></p><p>Thanks again for the consideration and the considered replies. I will be finishing up a proposal relating to this topic and it’ll be much the better for having received your responses (and Dmitri’s, also).<br></p><p>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/8c2b14fd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 11, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jan 6, 2016 at 10:42 AM, plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 6, 2016, at 11:37 AM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well<br>&gt; put it out publicly:<br>&gt;<br>&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever conform<br>&gt; to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass<br>&gt; indexed type (today&#39;s &quot;Collection&quot;). Some *operations* can meaningfully<br>&gt; use either one (like forEach or maxElement); these operations go on a<br>&gt; general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt;<br>&gt; In this world, both GeneratorType and CollectionType are refinements of<br>&gt; SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the<br>&gt; necessary default implementations. Maybe we rename some of the protocols in<br>&gt; the process. Again, no concrete type would ever conform to SequenceType;<br>&gt; it&#39;s just something you can use as a generic constraint.<br>&gt;<br>&gt; We can&#39;t actually do this today because it creates a circularity between<br>&gt; SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty<br>&gt; sure it&#39;s possible to change the compiler&#39;s protocol checking logic to<br>&gt; allow this, though.<br>&gt;<br>&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my<br>&gt; thoughts about Sequence, Collection, and Generator back when I was first<br>&gt; learning them.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; P.S. This idea falls apart if someone comes up with a model (concrete<br>&gt; type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able<br>&gt; to think of one back when I was originally thinking about this, but of<br>&gt; course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are<br>&gt; interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the<br>&gt; sequence/generator distinction that&#39;s really meaningful there.)<br>&gt;<br>&gt;<br>&gt; It’s not clear what you mean by a `SequenceType` that isn’t either a<br>&gt; `Collection` or a `Generator`, but if you mean a *concrete* sequence that:<br>&gt;<br>&gt; - can be re-iterated (thus not a `Generator`)<br>&gt; - has no meaningful index (!) (thus not a `Collection`)<br>&gt;<br>&gt; …then I can provide you with examples of such. The (!) is b/c you can of<br>&gt; course always use `Int` as an index, in the sense that “the value at index<br>&gt; `n` is obtained by iterating `n` steps from the start of the sequence”;<br>&gt; I’ll assume this doesn’t “count” as an index for purposes of this<br>&gt; discussion.<br>&gt;<br></p><p>You can use an opaque data type designed just for that collection, it is a<br>valid design.<br></p><p><br>&gt; Given the above, I will provide two examples.<br>&gt;<br>&gt; Here is one that is stable, re-iterable, infinite, and has no<br>&gt; “non-trivial&quot; index:<br>&gt;<br>&gt;     // Modest generalization of a seedable PRNG.<br>&gt;     // We assume that identically-seeded sources generate<br>&gt;     // identical elements (via `randomElement`), in identical order.<br>&gt;     protocol RandomElementSourceType {<br>&gt;<br>&gt;       typealias Element<br>&gt;       typealias Seed: Equatable<br>&gt;       // ^ `:Equatable` isn&#39;t actually necessary, but it&#39;s nice<br>&gt;<br>&gt;       init(seed: Seed)<br>&gt;<br>&gt;       mutating func randomElement() -&gt; Element<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     struct RandomElementGenerator&lt;R:RandomElementSourceType&gt; :<br>&gt; GeneratorType {<br>&gt;<br>&gt;       typealias Element = R.Element<br>&gt;<br>&gt;       private var source: R<br>&gt;<br>&gt;       mutating func next() -&gt; Element? {<br>&gt;         return source.randomElement() // &lt;- never stops!<br>&gt;       }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;     struct RandomElementSequence&lt;R:RandomElementSourceType&gt; : SequenceType<br>&gt; {<br>&gt;<br>&gt;       typealias Generator = RandomElementGenerator&lt;R&gt;<br>&gt;<br>&gt;       private let seed: R.Seed<br>&gt;<br>&gt;       func generate() -&gt; Generator {<br>&gt;         return Generator(source: R(seed: seed))<br>&gt;         // ^ as per assumptions, each iteration will be identical b/c<br>&gt;         //   because each iteration uses the same seed<br>&gt;       }<br>&gt;<br>&gt;     }<br>&gt;<br></p><p>RandomElementSequence is a forward collection.  You can create an index for<br>it that contains the generator state, and computes the next element when<br>the index is advanced.  Subscripting the collection with the index would<br>return the value contained in the index.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/9a8d516d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 6:22 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jan 6, 2016 at 10:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 11:37 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br>&gt;&gt; <br>&gt;&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some operations can meaningfully use either one (like forEach or maxElement); these operations go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt;&gt; <br>&gt;&gt; In this world, both GeneratorType and CollectionType are refinements of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the necessary default implementations. Maybe we rename some of the protocols in the process. Again, no concrete type would ever conform to SequenceType; it&#39;s just something you can use as a generic constraint.<br>&gt;&gt; <br>&gt;&gt; We can&#39;t actually do this today because it creates a circularity between SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s protocol checking logic to allow this, though.<br>&gt;&gt; <br>&gt;&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my thoughts about Sequence, Collection, and Generator back when I was first learning them.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. This idea falls apart if someone comes up with a model (concrete type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able to think of one back when I was originally thinking about this, but of course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the sequence/generator distinction that&#39;s really meaningful there.)<br>&gt; <br>&gt; It’s not clear what you mean by a `SequenceType` that isn’t either a `Collection` or a `Generator`, but if you mean a *concrete* sequence that:<br>&gt; <br>&gt; - can be re-iterated (thus not a `Generator`)<br>&gt; - has no meaningful index (!) (thus not a `Collection`)<br>&gt; <br>&gt; …then I can provide you with examples of such. The (!) is b/c you can of course always use `Int` as an index, in the sense that “the value at index `n` is obtained by iterating `n` steps from the start of the sequence”; I’ll assume this doesn’t “count” as an index for purposes of this discussion.<br>&gt; <br>&gt; You can use an opaque data type designed just for that collection, it is a valid design.<br></p><p>I suppose you’re right, but wouldn’t the opaque-Int-wrapper-as-Index still only work for a finite sequence with its exact length already-known, so you can provide an `endIndex` in O(1) time?<br></p><p>I may not be understanding what you mean, here.<br></p><p>&gt;  <br>&gt; Given the above, I will provide two examples.<br>&gt; <br>&gt; Here is one that is stable, re-iterable, infinite, and has no “non-trivial&quot; index:<br>&gt; <br>&gt;     // Modest generalization of a seedable PRNG.<br>&gt;     // We assume that identically-seeded sources generate<br>&gt;     // identical elements (via `randomElement`), in identical order.<br>&gt;     protocol RandomElementSourceType {<br>&gt; <br>&gt;       typealias Element<br>&gt;       typealias Seed: Equatable<br>&gt;       // ^ `:Equatable` isn&#39;t actually necessary, but it&#39;s nice<br>&gt;   <br>&gt;       init(seed: Seed)<br>&gt;   <br>&gt;       mutating func randomElement() -&gt; Element<br>&gt; <br>&gt;     }<br>&gt; <br>&gt;     struct RandomElementGenerator&lt;R:RandomElementSourceType&gt; : GeneratorType {<br>&gt; <br>&gt;       typealias Element = R.Element<br>&gt;   <br>&gt;       private var source: R<br>&gt;   <br>&gt;       mutating func next() -&gt; Element? {<br>&gt;         return source.randomElement() // &lt;- never stops!<br>&gt;       }<br>&gt;   <br>&gt;     }<br>&gt; <br>&gt;     struct RandomElementSequence&lt;R:RandomElementSourceType&gt; : SequenceType {<br>&gt; <br>&gt;       typealias Generator = RandomElementGenerator&lt;R&gt;<br>&gt;   <br>&gt;       private let seed: R.Seed<br>&gt;   <br>&gt;       func generate() -&gt; Generator {<br>&gt;         return Generator(source: R(seed: seed))<br>&gt;         // ^ as per assumptions, each iteration will be identical b/c<br>&gt;         //   because each iteration uses the same seed <br>&gt;       }<br>&gt; <br>&gt;     }<br>&gt; <br>&gt; RandomElementSequence is a forward collection.  You can create an index for it that contains the generator state, and computes the next element when the index is advanced.  Subscripting the collection with the index would return the value contained in the index.<br></p><p>This is a cool trick, but what’s a reasonable choice for `endIndex` here (that isn’t just some “artificial’ truncation of the sequence of random elements)?<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/0e18234d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, Jan 11, 2016 at 6:36 PM, plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 11, 2016, at 6:22 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jan 6, 2016 at 10:42 AM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 6, 2016, at 11:37 AM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as<br>&gt;&gt; well put it out publicly:<br>&gt;&gt;<br>&gt;&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever<br>&gt;&gt; conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a<br>&gt;&gt; multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some *operations* can<br>&gt;&gt; meaningfully use either one (like forEach or maxElement); these operations<br>&gt;&gt; go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt;&gt;<br>&gt;&gt; In this world, both GeneratorType and CollectionType are refinements of<br>&gt;&gt; SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the<br>&gt;&gt; necessary default implementations. Maybe we rename some of the protocols in<br>&gt;&gt; the process. Again, no concrete type would ever conform to SequenceType;<br>&gt;&gt; it&#39;s just something you can use as a generic constraint.<br>&gt;&gt;<br>&gt;&gt; We can&#39;t actually do this today because it creates a circularity between<br>&gt;&gt; SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty<br>&gt;&gt; sure it&#39;s possible to change the compiler&#39;s protocol checking logic to<br>&gt;&gt; allow this, though.<br>&gt;&gt;<br>&gt;&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my<br>&gt;&gt; thoughts about Sequence, Collection, and Generator back when I was first<br>&gt;&gt; learning them.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; P.S. This idea falls apart if someone comes up with a model (concrete<br>&gt;&gt; type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able<br>&gt;&gt; to think of one back when I was originally thinking about this, but of<br>&gt;&gt; course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are<br>&gt;&gt; interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the<br>&gt;&gt; sequence/generator distinction that&#39;s really meaningful there.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It’s not clear what you mean by a `SequenceType` that isn’t either a<br>&gt;&gt; `Collection` or a `Generator`, but if you mean a *concrete* sequence that:<br>&gt;&gt;<br>&gt;&gt; - can be re-iterated (thus not a `Generator`)<br>&gt;&gt; - has no meaningful index (!) (thus not a `Collection`)<br>&gt;&gt;<br>&gt;&gt; …then I can provide you with examples of such. The (!) is b/c you can of<br>&gt;&gt; course always use `Int` as an index, in the sense that “the value at index<br>&gt;&gt; `n` is obtained by iterating `n` steps from the start of the sequence”;<br>&gt;&gt; I’ll assume this doesn’t “count” as an index for purposes of this<br>&gt;&gt; discussion.<br>&gt;&gt;<br>&gt;<br>&gt; You can use an opaque data type designed just for that collection, it is a<br>&gt; valid design.<br>&gt;<br>&gt;<br>&gt; I suppose you’re right, but wouldn’t the opaque-Int-wrapper-as-Index still<br>&gt; only work for a finite sequence with its exact length already-known, so you<br>&gt; can provide an `endIndex` in O(1) time?<br>&gt;<br>&gt; I may not be understanding what you mean, here.<br>&gt;<br></p><p>Since the sequence is infinite, endIndex would be just a special value<br>distinct from any other index value.  You can construct that value in<br>O(1).  For example, Index can be wrapping an Optional of the PRNG state.<br>If the optional is nil, then the index is the endIndex.  Otherwise, it is<br>an index that can be advanced.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/757cebb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 10:35 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Jan 11, 2016 at 6:36 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 6:22 PM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jan 6, 2016 at 10:42 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 11:37 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some operations can meaningfully use either one (like forEach or maxElement); these operations go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this world, both GeneratorType and CollectionType are refinements of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the necessary default implementations. Maybe we rename some of the protocols in the process. Again, no concrete type would ever conform to SequenceType; it&#39;s just something you can use as a generic constraint.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can&#39;t actually do this today because it creates a circularity between SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s protocol checking logic to allow this, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my thoughts about Sequence, Collection, and Generator back when I was first learning them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S. This idea falls apart if someone comes up with a model (concrete type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able to think of one back when I was originally thinking about this, but of course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the sequence/generator distinction that&#39;s really meaningful there.)<br>&gt;&gt; <br>&gt;&gt; It’s not clear what you mean by a `SequenceType` that isn’t either a `Collection` or a `Generator`, but if you mean a *concrete* sequence that:<br>&gt;&gt; <br>&gt;&gt; - can be re-iterated (thus not a `Generator`)<br>&gt;&gt; - has no meaningful index (!) (thus not a `Collection`)<br>&gt;&gt; <br>&gt;&gt; …then I can provide you with examples of such. The (!) is b/c you can of course always use `Int` as an index, in the sense that “the value at index `n` is obtained by iterating `n` steps from the start of the sequence”; I’ll assume this doesn’t “count” as an index for purposes of this discussion.<br>&gt;&gt; <br>&gt;&gt; You can use an opaque data type designed just for that collection, it is a valid design.<br>&gt; <br>&gt; I suppose you’re right, but wouldn’t the opaque-Int-wrapper-as-Index still only work for a finite sequence with its exact length already-known, so you can provide an `endIndex` in O(1) time?<br>&gt; <br>&gt; I may not be understanding what you mean, here.<br>&gt; <br>&gt; Since the sequence is infinite, endIndex would be just a special value distinct from any other index value.  You can construct that value in O(1).  For example, Index can be wrapping an Optional of the PRNG state.  If the optional is nil, then the index is the endIndex.  Otherwise, it is an index that can be advanced.<br></p><p>Does such an `endIndex` count as “reachable” for purposes of `ForwardIndexType`? <br></p><p>I’d have assumed such “`endIndex` at infinity” constructs wouldn’t be considered reachable, but maybe that’s not the right interpretation in this context? <br></p><p>It’d certainly open up some design possibilities.<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/dab19cba/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>Thank you for this. Also, the book states: &quot;SequenceType makes no requirement on conforming types regarding whether they will be destructively &quot;consumed&quot; by iteration. To ensure non-destructive iteration, constrain your sequence to CollectionType.&quot;<br></p><p>Your magic DWIM Swift has generators (you call it a destructive iteration type) and collections (indexable, re-addressable types). I&#39;m trying to wrap my head these. I interpret the former as f() -&gt; U, with a progression of accesses with no memory that maps to a known type, and the latter being f(index) -&gt; V, where index belongs to a fixed index set and maps to the collection&#39;s contents.<br></p><p>What confuses me is that both of these seem to my inexperienced mind to be operations not types. You point out that a SequenceType doesn&#39;t actually concretely exist (&quot;Again, no concrete type would ever conform to SequenceType; it&#39;s just something you can use as a generic constraint.&quot;) If I were describing these, I&#39;d call them sequence generating functions and collection walk functions. The former would allow potentially non-terminating streams including random number generation, signal generation (for example sin or square waves), or soliciting user input. The latter would offer any kind of iteration or permutation.<br></p><p>I&#39;m not a language person (well not *that* kind of languages person) and I&#39;m not up to date on the particular terms of art that apply here, as I learned when it came to suggesting alternatives to associated type, but it seems like these words don&#39;t really describe the things you guys are giving us.<br></p><p>Does this better explain my confusion?<br></p><p>-- Erica<br></p><p><br>&gt; On Jan 6, 2016, at 10:37 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br>&gt; <br>&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some operations can meaningfully use either one (like forEach or maxElement); these operations go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt; <br>&gt; In this world, both GeneratorType and CollectionType are refinements of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType), including the necessary default implementations. Maybe we rename some of the protocols in the process. Again, no concrete type would ever conform to SequenceType; it&#39;s just something you can use as a generic constraint.<br>&gt; <br>&gt; We can&#39;t actually do this today because it creates a circularity between SequenceType and GeneratorType that the compiler can&#39;t handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s protocol checking logic to allow this, though.<br>&gt; <br>&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my thoughts about Sequence, Collection, and Generator back when I was first learning them.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. This idea falls apart if someone comes up with a model (concrete type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t able to think of one back when I was originally thinking about this, but of course that doesn&#39;t mean there isn&#39;t one. (Infinite collections are interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the sequence/generator distinction that&#39;s really meaningful there.)<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 9:52, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m trying to work them out, so it&#39;s still muddled.<br>&gt;&gt; <br>&gt;&gt; Right now, I think SequenceType is better described as CollectionWalkType but that&#39;s kind of (1) a mouthful and (2) not entirely accurate. <br>&gt;&gt; <br>&gt;&gt; Moving back a step: SequenceType is defined as: &quot;A type that can be iterated with a `for`...`in` loop.&quot; But it says nothing about whether that loop ever terminates and many stdlib sequence functions currently don&#39;t make sense (at least if they&#39;re not lazy) with respect to infinite sequences, which should probably be &quot;StreamType&quot; not sequences. A couple of examples:<br>&gt;&gt; Here&#39;s my fib: http://swiftstub.com/189513594/ &lt;http://swiftstub.com/189513594/&gt;<br>&gt;&gt; And here&#39;s Oisin&#39;s user-input sequence:  https://gist.github.com/oisdk/2c7ac33bf2188528842a &lt;https://gist.github.com/oisdk/2c7ac33bf2188528842a&gt;<br>&gt;&gt; Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br>&gt;&gt; <br>&gt;&gt; Hopefully that&#39;s enough of a starting point to indicate where my thinking is at and what I&#39;m trying to think through when it comes to this. -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &lt;open.gif&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/525413de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 22, 2016 at 07:00:00am</p></header><div class="content"><p>on Wed Jan 06 2016, Erica Sadun &lt;erica-AT-ericasadun.com&gt; wrote:<br></p><p>&gt; Thank you for this. Also, the book states: &quot;SequenceType makes no<br>&gt; requirement on conforming types regarding whether they will be<br>&gt; destructively &quot;consumed&quot; by iteration. To ensure non-destructive<br>&gt; iteration, constrain your sequence to CollectionType.&quot;<br>&gt;<br>&gt; Your magic DWIM Swift has generators (you call it a destructive<br>&gt; iteration type) and collections (indexable, re-addressable types). I&#39;m<br>&gt; trying to wrap my head these. I interpret the former as f() -&gt; U, with<br>&gt; a progression of accesses with no memory that maps to a known type,<br>&gt; and the latter being f(index) -&gt; V, where index belongs to a fixed<br>&gt; index set and maps to the collection&#39;s contents.<br></p><p>Yes.<br></p><p>&gt; What confuses me is that both of these seem to my inexperienced mind<br>&gt; to be operations not types. You point out that a SequenceType doesn&#39;t<br>&gt; actually concretely exist (&quot;Again, no concrete type would ever conform<br>&gt; to SequenceType; it&#39;s just something you can use as a generic<br>&gt; constraint.&quot;) If I were describing these, I&#39;d call them sequence<br>&gt; generating functions and collection walk functions. The former would<br>&gt; allow potentially non-terminating streams including random number<br>&gt; generation, signal generation (for example sin or square waves), or<br>&gt; soliciting user input. <br></p><p>The distinction we&#39;re interested in is not whether the stream is allowed<br>to be non-terminating, but whether it can be traversed<br>non-destructively.  That&#39;s at least important for optimizations like<br>measuring the stream before allocating an array buffer to hold its<br>contents.<br></p><p>&gt; The latter would offer any kind of iteration or permutation.<br>&gt;<br>&gt; I&#39;m not a language person (well not *that* kind of languages person)<br>&gt; and I&#39;m not up to date on the particular terms of art that apply here,<br>&gt; as I learned when it came to suggesting alternatives to associated<br>&gt; type, but it seems like these words don&#39;t really describe the things<br>&gt; you guys are giving us.<br>&gt;<br>&gt; Does this better explain my confusion?<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;&gt; On Jan 6, 2016, at 10:37 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br>&gt;&gt; <br>&gt;&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever<br>&gt;&gt; conform to: a destructive iteration type (today&#39;s &quot;Generator&quot;), and<br>&gt;&gt; a multi-pass indexed type (today&#39;s &quot;Collection&quot;). Some operations<br>&gt;&gt; can meaningfully use either one (like forEach or maxElement); these<br>&gt;&gt; operations go on a general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt;&gt; <br>&gt;&gt; In this world, both GeneratorType and CollectionType are refinements<br>&gt;&gt; of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType),<br>&gt;&gt; including the necessary default implementations. Maybe we rename<br>&gt;&gt; some of the protocols in the process. Again, no concrete type would<br>&gt;&gt; ever conform to SequenceType; it&#39;s just something you can use as a<br>&gt;&gt; generic constraint.<br>&gt;&gt; <br>&gt;&gt; We can&#39;t actually do this today because it creates a circularity<br>&gt;&gt; between SequenceType and GeneratorType that the compiler can&#39;t<br>&gt;&gt; handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s<br>&gt;&gt; protocol checking logic to allow this, though.<br>&gt;&gt; <br>&gt;&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my<br>&gt;&gt; thoughts about Sequence, Collection, and Generator back when I was<br>&gt;&gt; first learning them.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. This idea falls apart if someone comes up with a model<br>&gt;&gt; (concrete type) for SequenceType that isn&#39;t a Collection or<br>&gt;&gt; Generator. I wasn&#39;t able to think of one back when I was originally<br>&gt;&gt; thinking about this, but of course that doesn&#39;t mean there isn&#39;t<br>&gt;&gt; one. (Infinite collections are interesting as discussed on the<br>&gt;&gt; &quot;cycle&quot; thread, but it&#39;s not the sequence/generator distinction<br>&gt;&gt; that&#39;s really meaningful there.)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 9:52, Erica Sadun via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m trying to work them out, so it&#39;s still muddled.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, I think SequenceType is better described as<br>&gt;&gt;&gt; CollectionWalkType but that&#39;s kind of (1) a mouthful and (2) not<br>&gt;&gt;&gt; entirely accurate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moving back a step: SequenceType is defined as: &quot;A type that can be<br>&gt;&gt;&gt; iterated with a `for`...`in` loop.&quot; But it says nothing about<br>&gt;&gt;&gt; whether that loop ever terminates and many stdlib sequence<br>&gt;&gt;&gt; functions currently don&#39;t make sense (at least if they&#39;re not lazy)<br>&gt;&gt;&gt; with respect to infinite sequences, which should probably be<br>&gt;&gt;&gt; &quot;StreamType&quot; not sequences. A couple of examples:<br>&gt;&gt;&gt; Here&#39;s my fib: http://swiftstub.com/189513594/ &lt;http://swiftstub.com/189513594/&gt;<br>&gt;&gt;&gt; And here&#39;s Oisin&#39;s user-input sequence:<br>&gt;&gt;&gt; https://gist.github.com/oisdk/2c7ac33bf2188528842a<br>&gt;&gt;&gt; &lt;https://gist.github.com/oisdk/2c7ac33bf2188528842a&gt;<br>&gt;&gt;&gt; Both of these are theoretically filterable, but they aren&#39;t dropLast-able, suffix-able, properly split-able, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hopefully that&#39;s enough of a starting point to indicate where my<br>&gt;&gt;&gt; thinking is at and what I&#39;m trying to think through when it comes<br>&gt;&gt;&gt; to this. -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 10:09 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 9:05 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It does seem that in Swift the concepts of collection, sequence, permutation, stream, etc are a bit muddled.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a pretty vague critique.  Do you have specifics, and suggestions that address them?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 6:51 AM, Tino Heth via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Those are collections.  Collections can be iterated over multiple times.<br>&gt;&gt;&gt;&gt;&gt;&gt; Speaking of the Fibonacci-numbers:<br>&gt;&gt;&gt;&gt;&gt;&gt; Sure we can write an algorithm that iterates over them several<br>&gt;&gt;&gt;&gt;&gt;&gt; times — it just won&#39;t ever finish the first iteration ;-)<br>&gt;&gt;&gt;&gt;&gt;&gt; (only nitpicking — I just couldn&#39;t resist)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Happy new year!<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;open.gif&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>About the PermutationGenerator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 22, 2016 at 07:00:00am</p></header><div class="content"><p>on Wed Jan 06 2016, Jordan Rose &lt;jordan_rose-AT-apple.com&gt; wrote:<br></p><p>&gt; I&#39;ve bounced this idea off of Dave and Dmitri internally, so might as well put it out publicly:<br>&gt;<br>&gt; In Magic DWIM Swift, there would only be two types that you&#39;d ever<br>&gt; conform to: <br></p><p>You don&#39;t really mean that :-)<br></p><p>&gt; a destructive iteration type (today&#39;s &quot;Generator&quot;), and a multi-pass<br>&gt; indexed type (today&#39;s &quot;Collection&quot;). Some operations can meaningfully<br>&gt; use either one (like forEach or maxElement); these operations go on a<br>&gt; general &quot;traversable&quot; type (today&#39;s &quot;Sequence&quot;).<br>&gt;<br>&gt; In this world, both GeneratorType and CollectionType are refinements<br>&gt; of SequenceType (i.e. any GeneratorType &quot;is-a&quot; SequenceType),<br>&gt; including the necessary default implementations. Maybe we rename some<br>&gt; of the protocols in the process.  Again, no concrete type would ever<br>&gt; conform to SequenceType; it&#39;s just something you can use as a generic<br>&gt; constraint.<br></p><p>If GeneratorType and CollectionType conform to SequenceType, then lots<br>of concrete types will conform.  I think you just mean that none will<br>conform to SequenceType without also conforming to one of the others.<br></p><p>&gt; We can&#39;t actually do this today because it creates a circularity<br>&gt; between SequenceType and GeneratorType that the compiler can&#39;t<br>&gt; handle. I&#39;m pretty sure it&#39;s possible to change the compiler&#39;s<br>&gt; protocol checking logic to allow this, though.<br></p><p>Yes; the main obstacle is that our codegen model doesn&#39;t support it.  It<br>has something to do with the way witness tables get passed to generic<br>functions.<br></p><p>&gt; Anyway, that&#39;s that idea. At the very least it helped me clear up my<br>&gt; thoughts about Sequence, Collection, and Generator back when I was<br>&gt; first learning them.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; P.S. This idea falls apart if someone comes up with a model (concrete<br>&gt; type) for SequenceType that isn&#39;t a Collection or Generator. I wasn&#39;t<br>&gt; able to think of one back when I was originally thinking about this,<br>&gt; but of course that doesn&#39;t mean there isn&#39;t one. (Infinite collections<br>&gt; are interesting as discussed on the &quot;cycle&quot; thread, but it&#39;s not the<br>&gt; sequence/generator distinction that&#39;s really meaningful there.)<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
