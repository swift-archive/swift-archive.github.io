<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>June 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Due to considerably support on this thread<br>&lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;,<br>a draft proposal to revisit the core functional method exceptions to the<br>-ed/-ing rule.<br></p><p>Online version:<br>https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br></p><p>Apply -ed/-ing rule to core functional methods<br></p><p>   - Proposal: SE-NNNN<br>   &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>   - Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>   - Status: Awaiting review<br>   - Review manager: TBD<br></p><p>&lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;<br>Introduction<br></p><p>The Swift API Guidelines standardizes non-mutating method forms on verbs<br>ending in -ed/-ing (or nouns). However, a few non-mutating forms have been<br>kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and dropLast.<br>This proposal proposes to bring these in line with all other non-mutating<br>forms (e.g. filter =&gt; filtered).<br></p><p>Swift-evolution threads: Source<br>&lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;<br>Motivation<br></p><p>These method have been kept to preserve the terms of art. Generally, this<br>can have significant benefits:<br></p><p>   - Anyone familiar with the term will immediately understand it, and use<br>   their assumptions about how it works.<br>   - Users learning the term from Swift can use their knowledge when<br>   encountering it elsewhere.<br>   - Experienced users will be able to use the mental pattern matching<br>   they&#39;ve built-up for quickly recognizing common programming patterns.<br></p><p>However, basically all of the benefits of using a term of art still apply<br>to the modified forms: – For recognition, the modified forms are still very<br>close to the traditional terms of art. So both coming to and from Swift<br>you&#39;ll be able to use your knowledge pretty much unaffected.<br></p><p>   - If the user looks for e.g. filter they are pretty much guaranteed to<br>   quickly find the correct form, be it through code-completion, google or a<br>   fix-it.<br>   - There isn&#39;t really any violation of assumptions that might cause<br>   problems in this case.<br>   - Any mental pattern matching will likely transfer quickly due to the<br>   minimal difference.<br></p><p>&lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed<br>solution<br></p><p>The proposed solution modifies the method verbs to their -ed/-ing forms<br>(preferring the former).<br></p><p>It removes the last clear exceptions to the -ed/-ing rule from the standard<br>library, which previously were exactly the opposite of what one would<br>expect based on the API guidelines (and the rest of the language).<br></p><p>It also aids users in learning to pattern match on the -ed/-ing rule and<br>internalizing the API guidelines, since now all methods are named this way<br>– instead of the most commonly used methods defying the normal pattern.<br>&lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed<br>design<br></p><p>The change would rename the following method families:<br></p><p>map       =&gt; mapped<br>flatMap   =&gt; flatMapped<br>filter    =&gt; filtered<br>reduce    =&gt; reduced<br>dropFirst =&gt; droppingFirst<br>dropLast  =&gt; droppingLast<br></p><p>&lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact<br>on existing code<br></p><p>The Swift migrator and fix-its would be provided for the change.<br>&lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives<br>considered<br></p><p>   - Alternatively -ing suffixes could be used for map/flatMap/filter/reduce.<br>   However, these are normally reserved for when -ed doesn&#39;t really work (e.g.<br>   droppedFirst).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/0703878c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =?utf-8?Q?=3D&gt;_?=filtered)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 16, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 very much for consistency.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 16. Juni 2016 um 21:51:48, Patrick Pijnappel via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Due to considerably support on this thread, a draft proposal to revisit the core functional method exceptions to the -ed/-ing rule.<br></p><p>Online version: https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br></p><p>Apply -ed/-ing rule to core functional methods<br></p><p>Proposal: SE-NNNN<br>Author: Patrick Pijnappel<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>The Swift API Guidelines standardizes non-mutating method forms on verbs ending in -ed/-ing (or nouns). However, a few non-mutating forms have been kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and dropLast. This proposal proposes to bring these in line with all other non-mutating forms (e.g. filter =&gt; filtered).<br></p><p>Swift-evolution threads: Source<br></p><p>Motivation<br></p><p>These method have been kept to preserve the terms of art. Generally, this can have significant benefits:<br></p><p>Anyone familiar with the term will immediately understand it, and use their assumptions about how it works.<br>Users learning the term from Swift can use their knowledge when encountering it elsewhere.<br>Experienced users will be able to use the mental pattern matching they&#39;ve built-up for quickly recognizing common programming patterns.<br>However, basically all of the benefits of using a term of art still apply to the modified forms: – For recognition, the modified forms are still very close to the traditional terms of art. So both coming to and from Swift you&#39;ll be able to use your knowledge pretty much unaffected. <br></p><p>If the user looks for e.g. filter they are pretty much guaranteed to quickly find the correct form, be it through code-completion, google or a fix-it.<br>There isn&#39;t really any violation of assumptions that might cause problems in this case.<br>Any mental pattern matching will likely transfer quickly due to the minimal difference.<br>Proposed solution<br></p><p>The proposed solution modifies the method verbs to their -ed/-ing forms (preferring the former). <br></p><p>It removes the last clear exceptions to the -ed/-ing rule from the standard library, which previously were exactly the opposite of what one would expect based on the API guidelines (and the rest of the language).<br></p><p>It also aids users in learning to pattern match on the -ed/-ing rule and internalizing the API guidelines, since now all methods are named this way – instead of the most commonly used methods defying the normal pattern.<br></p><p>Detailed design<br></p><p>The change would rename the following method families:<br></p><p>map       =&gt; mapped<br>flatMap   =&gt; flatMapped  <br>filter    =&gt; filtered<br>reduce    =&gt; reduced<br>dropFirst =&gt; droppingFirst<br>dropLast  =&gt; droppingLast<br>Impact on existing code<br></p><p>The Swift migrator and fix-its would be provided for the change. <br></p><p>Alternatives considered<br></p><p>Alternatively -ing suffixes could be used for map/flatMap/filter/reduce. However, these are normally reserved for when -ed doesn&#39;t really work (e.g. droppedFirst).<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/bf1c7aeb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 16, 2016 at 02:00:00pm</p></header><div class="content"><p>-1, for the same reasons stated on the thread. These are neither guaranteed to be mutating or non-mutating until you get to Collection.<br></p><p>Changing map() to mapped() would be lying to the developer some of the time about the mutability of the interface.<br></p><p>-DW<br></p><p>&gt; On Jun 16, 2016, at 1:53 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 very much for consistency. <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 16. Juni 2016 um 21:51:48, Patrick Pijnappel via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; Due to considerably support on this thread &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;, a draft proposal to revisit the core functional method exceptions to the -ed/-ing rule.<br>&gt;&gt; <br>&gt;&gt; Online version: https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md&gt;<br>&gt;&gt; <br>&gt;&gt; Apply -ed/-ing rule to core functional methods<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>&gt;&gt; Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs ending in -ed/-ing (or nouns). However, a few non-mutating forms have been kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and dropLast. This proposal proposes to bring these in line with all other non-mutating forms (e.g. filter =&gt; filtered).<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads: Source &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&gt;&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; These method have been kept to preserve the terms of art. Generally, this can have significant benefits:<br>&gt;&gt; <br>&gt;&gt; Anyone familiar with the term will immediately understand it, and use their assumptions about how it works.<br>&gt;&gt; Users learning the term from Swift can use their knowledge when encountering it elsewhere.<br>&gt;&gt; Experienced users will be able to use the mental pattern matching they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt;&gt; However, basically all of the benefits of using a term of art still apply to the modified forms: – For recognition, the modified forms are still very close to the traditional terms of art. So both coming to and from Swift you&#39;ll be able to use your knowledge pretty much unaffected. <br>&gt;&gt; <br>&gt;&gt; If the user looks for e.g. filter they are pretty much guaranteed to quickly find the correct form, be it through code-completion, google or a fix-it.<br>&gt;&gt; There isn&#39;t really any violation of assumptions that might cause problems in this case.<br>&gt;&gt; Any mental pattern matching will likely transfer quickly due to the minimal difference.<br>&gt;&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution modifies the method verbs to their -ed/-ing forms (preferring the former). <br>&gt;&gt; <br>&gt;&gt; It removes the last clear exceptions to the -ed/-ing rule from the standard library, which previously were exactly the opposite of what one would expect based on the API guidelines (and the rest of the language).<br>&gt;&gt; <br>&gt;&gt; It also aids users in learning to pattern match on the -ed/-ing rule and internalizing the API guidelines, since now all methods are named this way – instead of the most commonly used methods defying the normal pattern.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The change would rename the following method families:<br>&gt;&gt; <br>&gt;&gt; map       =&gt; mapped<br>&gt;&gt; flatMap   =&gt; flatMapped  <br>&gt;&gt; filter    =&gt; filtered<br>&gt;&gt; reduce    =&gt; reduced<br>&gt;&gt; dropFirst =&gt; droppingFirst<br>&gt;&gt; dropLast  =&gt; droppingLast<br>&gt;&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The Swift migrator and fix-its would be provided for the change. <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Alternatively -ing suffixes could be used for map/flatMap/filter/reduce. However, these are normally reserved for when -ed doesn&#39;t really work (e.g. droppedFirst).<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/de7fda31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June 16, 2016 at 01:00:00pm</p></header><div class="content"><p>no<br></p><p>-1<br></p><p>I agree that the names of these methods are inconsistent in the abstract<br>but they are established terms of art, in my opinion.<br></p><p>On Thu, Jun 16, 2016 at 1:38 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; -1, for the same reasons stated on the thread. These are neither<br>&gt; guaranteed to be mutating or non-mutating until you get to Collection.<br>&gt;<br>&gt; Changing map() to mapped() would be lying to the developer some of the<br>&gt; time about the mutability of the interface.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br>&gt; On Jun 16, 2016, at 1:53 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 very much for consistency.<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 16. Juni 2016 um 21:51:48, Patrick Pijnappel via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; Due to considerably support on this thread<br>&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;,<br>&gt; a draft proposal to revisit the core functional method exceptions to the<br>&gt; -ed/-ing rule.<br>&gt;<br>&gt; Online version:<br>&gt; https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br>&gt;<br>&gt; Apply -ed/-ing rule to core functional methods<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>&gt;    - Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs<br>&gt; ending in -ed/-ing (or nouns). However, a few non-mutating forms have been<br>&gt; kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and<br>&gt; dropLast. This proposal proposes to bring these in line with all other<br>&gt; non-mutating forms (e.g. filter =&gt; filtered).<br>&gt;<br>&gt; Swift-evolution threads: Source<br>&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; These method have been kept to preserve the terms of art. Generally, this<br>&gt; can have significant benefits:<br>&gt;<br>&gt;    - Anyone familiar with the term will immediately understand it, and<br>&gt;    use their assumptions about how it works.<br>&gt;    - Users learning the term from Swift can use their knowledge when<br>&gt;    encountering it elsewhere.<br>&gt;    - Experienced users will be able to use the mental pattern matching<br>&gt;    they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt;<br>&gt; However, basically all of the benefits of using a term of art still apply<br>&gt; to the modified forms: – For recognition, the modified forms are still very<br>&gt; close to the traditional terms of art. So both coming to and from Swift<br>&gt; you&#39;ll be able to use your knowledge pretty much unaffected.<br>&gt;<br>&gt;    - If the user looks for e.g. filter they are pretty much guaranteed to<br>&gt;    quickly find the correct form, be it through code-completion, google or a<br>&gt;    fix-it.<br>&gt;    - There isn&#39;t really any violation of assumptions that might cause<br>&gt;    problems in this case.<br>&gt;    - Any mental pattern matching will likely transfer quickly due to the<br>&gt;    minimal difference.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The proposed solution modifies the method verbs to their -ed/-ing forms<br>&gt; (preferring the former).<br>&gt;<br>&gt; It removes the last clear exceptions to the -ed/-ing rule from the<br>&gt; standard library, which previously were exactly the opposite of what one<br>&gt; would expect based on the API guidelines (and the rest of the language).<br>&gt;<br>&gt; It also aids users in learning to pattern match on the -ed/-ing rule and<br>&gt; internalizing the API guidelines, since now all methods are named this way<br>&gt; – instead of the most commonly used methods defying the normal pattern.<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The change would rename the following method families:<br>&gt;<br>&gt; map       =&gt; mapped<br>&gt; flatMap   =&gt; flatMapped<br>&gt; filter    =&gt; filtered<br>&gt; reduce    =&gt; reduced<br>&gt; dropFirst =&gt; droppingFirst<br>&gt; dropLast  =&gt; droppingLast<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The Swift migrator and fix-its would be provided for the change.<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt;    - Alternatively -ing suffixes could be used for map/flatMap/filter/<br>&gt;    reduce. However, these are normally reserved for when -ed doesn&#39;t<br>&gt;    really work (e.g. droppedFirst).<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/2882521a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June 16, 2016 at 01:00:00pm</p></header><div class="content"><p>Thinking on it more after that–admittedly–visceral reaction, the proposed<br>changes would be an annoying break from the terms but would remain as<br>discoverable via autocomplete and can still be found easily when searching.<br>I&#39;d like to amend my vote to 0. If it makes the methods/functions easier to<br>read for others, go for it.<br></p><p><br></p><p>On Thu, Jun 16, 2016 at 1:40 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt; no<br>&gt;<br>&gt; -1<br>&gt;<br>&gt; I agree that the names of these methods are inconsistent in the abstract<br>&gt; but they are established terms of art, in my opinion.<br>&gt;<br>&gt; On Thu, Jun 16, 2016 at 1:38 PM, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; -1, for the same reasons stated on the thread. These are neither<br>&gt;&gt; guaranteed to be mutating or non-mutating until you get to Collection.<br>&gt;&gt;<br>&gt;&gt; Changing map() to mapped() would be lying to the developer some of the<br>&gt;&gt; time about the mutability of the interface.<br>&gt;&gt;<br>&gt;&gt; -DW<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 16, 2016, at 1:53 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; +1 very much for consistency.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 16. Juni 2016 um 21:51:48, Patrick Pijnappel via swift-evolution (<br>&gt;&gt; swift-evolution at swift.org) schrieb:<br>&gt;&gt;<br>&gt;&gt; Due to considerably support on this thread<br>&gt;&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;,<br>&gt;&gt; a draft proposal to revisit the core functional method exceptions to the<br>&gt;&gt; -ed/-ing rule.<br>&gt;&gt;<br>&gt;&gt; Online version:<br>&gt;&gt; https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br>&gt;&gt;<br>&gt;&gt; Apply -ed/-ing rule to core functional methods<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>&gt;&gt;    - Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs<br>&gt;&gt; ending in -ed/-ing (or nouns). However, a few non-mutating forms have been<br>&gt;&gt; kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and<br>&gt;&gt; dropLast. This proposal proposes to bring these in line with all other<br>&gt;&gt; non-mutating forms (e.g. filter =&gt; filtered).<br>&gt;&gt;<br>&gt;&gt; Swift-evolution threads: Source<br>&gt;&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; These method have been kept to preserve the terms of art. Generally, this<br>&gt;&gt; can have significant benefits:<br>&gt;&gt;<br>&gt;&gt;    - Anyone familiar with the term will immediately understand it, and<br>&gt;&gt;    use their assumptions about how it works.<br>&gt;&gt;    - Users learning the term from Swift can use their knowledge when<br>&gt;&gt;    encountering it elsewhere.<br>&gt;&gt;    - Experienced users will be able to use the mental pattern matching<br>&gt;&gt;    they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt;&gt;<br>&gt;&gt; However, basically all of the benefits of using a term of art still apply<br>&gt;&gt; to the modified forms: – For recognition, the modified forms are still very<br>&gt;&gt; close to the traditional terms of art. So both coming to and from Swift<br>&gt;&gt; you&#39;ll be able to use your knowledge pretty much unaffected.<br>&gt;&gt;<br>&gt;&gt;    - If the user looks for e.g. filter they are pretty much guaranteed<br>&gt;&gt;    to quickly find the correct form, be it through code-completion, google or<br>&gt;&gt;    a fix-it.<br>&gt;&gt;    - There isn&#39;t really any violation of assumptions that might cause<br>&gt;&gt;    problems in this case.<br>&gt;&gt;    - Any mental pattern matching will likely transfer quickly due to the<br>&gt;&gt;    minimal difference.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; The proposed solution modifies the method verbs to their -ed/-ing forms<br>&gt;&gt; (preferring the former).<br>&gt;&gt;<br>&gt;&gt; It removes the last clear exceptions to the -ed/-ing rule from the<br>&gt;&gt; standard library, which previously were exactly the opposite of what one<br>&gt;&gt; would expect based on the API guidelines (and the rest of the language).<br>&gt;&gt;<br>&gt;&gt; It also aids users in learning to pattern match on the -ed/-ing rule and<br>&gt;&gt; internalizing the API guidelines, since now all methods are named this way<br>&gt;&gt; – instead of the most commonly used methods defying the normal pattern.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; The change would rename the following method families:<br>&gt;&gt;<br>&gt;&gt; map       =&gt; mapped<br>&gt;&gt; flatMap   =&gt; flatMapped<br>&gt;&gt; filter    =&gt; filtered<br>&gt;&gt; reduce    =&gt; reduced<br>&gt;&gt; dropFirst =&gt; droppingFirst<br>&gt;&gt; dropLast  =&gt; droppingLast<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; The Swift migrator and fix-its would be provided for the change.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt;    - Alternatively -ing suffixes could be used for map/flatMap/filter/<br>&gt;&gt;    reduce. However, these are normally reserved for when -ed doesn&#39;t<br>&gt;&gt;    really work (e.g. droppedFirst).<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/1bc5095e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>June 16, 2016 at 02:00:00pm</p></header><div class="content"><p>-0.5<br></p><p>I find the &quot;term of art&quot; argument strong in this case, especially for map/filter/reduce.<br></p><p>These functions are different than for example `sort` because there can’t be a general mutating method of `map`. A variable of type `[A]` can’t be mutated to hold a `[B]` which would be the result of a map from `A -&gt; B`.<br></p><p>I acknowledge that it’s more consistent, and that - by being a suffix to the function name - autocompletion would still result in the correct function. However, I don’t find that the extra -ed/-ing suffixes provide a lot of extra clarity<br></p><p><br>&gt; On 16 Jun 2016, at 12:51, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Due to considerably support on this thread &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;, a draft proposal to revisit the core functional method exceptions to the -ed/-ing rule.<br>&gt; <br>&gt; Online version: https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md&gt;<br>&gt; <br>&gt; Apply -ed/-ing rule to core functional methods<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>&gt; Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;Introduction<br>&gt; <br>&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs ending in -ed/-ing (or nouns). However, a few non-mutating forms have been kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and dropLast. This proposal proposes to bring these in line with all other non-mutating forms (e.g. filter =&gt; filtered).<br>&gt; <br>&gt; Swift-evolution threads: Source &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;Motivation<br>&gt; <br>&gt; These method have been kept to preserve the terms of art. Generally, this can have significant benefits:<br>&gt; <br>&gt; Anyone familiar with the term will immediately understand it, and use their assumptions about how it works.<br>&gt; Users learning the term from Swift can use their knowledge when encountering it elsewhere.<br>&gt; Experienced users will be able to use the mental pattern matching they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt; However, basically all of the benefits of using a term of art still apply to the modified forms: – For recognition, the modified forms are still very close to the traditional terms of art. So both coming to and from Swift you&#39;ll be able to use your knowledge pretty much unaffected. <br>&gt; <br>&gt; If the user looks for e.g. filter they are pretty much guaranteed to quickly find the correct form, be it through code-completion, google or a fix-it.<br>&gt; There isn&#39;t really any violation of assumptions that might cause problems in this case.<br>&gt; Any mental pattern matching will likely transfer quickly due to the minimal difference.<br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposed solution modifies the method verbs to their -ed/-ing forms (preferring the former). <br>&gt; <br>&gt; It removes the last clear exceptions to the -ed/-ing rule from the standard library, which previously were exactly the opposite of what one would expect based on the API guidelines (and the rest of the language).<br>&gt; <br>&gt; It also aids users in learning to pattern match on the -ed/-ing rule and internalizing the API guidelines, since now all methods are named this way – instead of the most commonly used methods defying the normal pattern.<br>&gt; <br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The change would rename the following method families:<br>&gt; <br>&gt; map       =&gt; mapped<br>&gt; flatMap   =&gt; flatMapped <br>&gt; filter    =&gt; filtered<br>&gt; reduce    =&gt; reduced<br>&gt; dropFirst =&gt; droppingFirst<br>&gt; dropLast  =&gt; droppingLast<br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The Swift migrator and fix-its would be provided for the change. <br>&gt; <br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Alternatively -ing suffixes could be used for map/flatMap/filter/reduce. However, these are normally reserved for when -ed doesn&#39;t really work (e.g. droppedFirst).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/b7aebad0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 17, 2016 at 03:00:00pm</p></header><div class="content"><p>On 17.06.2016 0:07, Gmail via swift-evolution wrote:<br>&gt; -0.5<br>&gt;<br>&gt; I find the &quot;term of art&quot; argument strong in this case, especially for<br>&gt; map/filter/reduce.<br>&gt;<br>&gt; These functions are different than for example `sort` because there can’t<br>&gt; be a general mutating method of `map`. A variable of type `[A]` can’t be<br>&gt; mutated to hold a `[B]` which would be the result of a map from `A -&gt; B`.<br></p><p>Can you compare &#39;filter&#39; vs &#39;sort&#39; ? I.e. it is possible to have in-place <br>filter. Just like &#39;sort&#39;. Why &#39;sort&#39; is not a term-of-art but &quot;filter&quot; is?<br></p><p>Even more, I&#39;m confused right now, how should I name my own method in type <br>that will filter it in-place(i.e. mutating method)?<br></p><p>So, even I think we can leave map/reduce as-is, IMO &#39;filter&#39; should be <br>excluded from this group.<br></p><p>&gt;<br>&gt; I acknowledge that it’s more consistent, and that - by being a suffix to<br>&gt; the function name - autocompletion would still result in the<br>&gt; correct function. However, I don’t find that the extra -ed/-ing suffixes<br>&gt; provide a lot of extra clarity<br>&gt;<br>&gt;<br>&gt;&gt; On 16 Jun 2016, at 12:51, Patrick Pijnappel via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Due to considerably support on this thread<br>&gt;&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;,<br>&gt;&gt; a draft proposal to revisit the core functional method exceptions to the<br>&gt;&gt; -ed/-ing rule.<br>&gt;&gt;<br>&gt;&gt; Online<br>&gt;&gt; version: https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;   Apply -ed/-ing rule to core functional methods<br>&gt;&gt;<br>&gt;&gt;   * Proposal: SE-NNNN<br>&gt;&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>&gt;&gt;   * Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>&gt;&gt;   * Status: Awaiting review<br>&gt;&gt;   * Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;Introduction<br>&gt;&gt;<br>&gt;&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs<br>&gt;&gt; ending in -ed/-ing (or nouns). However, a few non-mutating forms have<br>&gt;&gt; been kept as &quot;Terms of<br>&gt;&gt; Art&quot;: |map|, |flatMap|, |filter|, |reduce|, |dropFirst| and |dropLast|.<br>&gt;&gt; This proposal proposes to bring these in line with all other non-mutating<br>&gt;&gt; forms (e.g. |filter =&gt; filtered|).<br>&gt;&gt;<br>&gt;&gt; Swift-evolution threads: Source<br>&gt;&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;Motivation<br>&gt;&gt;<br>&gt;&gt; These method have been kept to preserve the terms of art. Generally, this<br>&gt;&gt; can have significant benefits:<br>&gt;&gt;<br>&gt;&gt;   * Anyone familiar with the term will immediately understand it, and use<br>&gt;&gt;     their assumptions about how it works.<br>&gt;&gt;   * Users learning the term from Swift can use their knowledge when<br>&gt;&gt;     encountering it elsewhere.<br>&gt;&gt;   * Experienced users will be able to use the mental pattern matching<br>&gt;&gt;     they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt;&gt;<br>&gt;&gt; However, basically all of the benefits of using a term of art still apply<br>&gt;&gt; to the modified forms: – For recognition, the modified forms are still<br>&gt;&gt; very close to the traditional terms of art. So both coming to and from<br>&gt;&gt; Swift you&#39;ll be able to use your knowledge pretty much unaffected.<br>&gt;&gt;<br>&gt;&gt;   * If the user looks for e.g. |filter| they are pretty much guaranteed<br>&gt;&gt;     to quickly find the correct form, be it through code-completion,<br>&gt;&gt;     google or a fix-it.<br>&gt;&gt;   * There isn&#39;t really any violation of assumptions that might cause<br>&gt;&gt;     problems in this case.<br>&gt;&gt;   * Any mental pattern matching will likely transfer quickly due to the<br>&gt;&gt;     minimal difference.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed<br>&gt;&gt;     solution<br>&gt;&gt;<br>&gt;&gt; The proposed solution modifies the method verbs to their -ed/-ing forms<br>&gt;&gt; (preferring the former).<br>&gt;&gt;<br>&gt;&gt; It removes the last clear exceptions to the -ed/-ing rule from the<br>&gt;&gt; standard library, which previously were exactly the opposite of what one<br>&gt;&gt; would expect based on the API guidelines (and the rest of the language).<br>&gt;&gt;<br>&gt;&gt; It also aids users in learning to pattern match on the -ed/-ing rule and<br>&gt;&gt; internalizing the API guidelines, since now all methods are named this<br>&gt;&gt; way – instead of the most commonly used methods defying the normal pattern.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed<br>&gt;&gt;     design<br>&gt;&gt;<br>&gt;&gt; The change would rename the following method families:<br>&gt;&gt;<br>&gt;&gt; |map =&gt; mapped flatMap =&gt; flatMapped filter =&gt; filtered reduce =&gt; reduced<br>&gt;&gt; dropFirst =&gt; droppingFirst dropLast =&gt; droppingLast |<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact<br>&gt;&gt;     on existing code<br>&gt;&gt;<br>&gt;&gt; The Swift migrator and fix-its would be provided for the change.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives<br>&gt;&gt;     considered<br>&gt;&gt;<br>&gt;&gt;   * Alternatively -ing suffixes could be used<br>&gt;&gt;     for |map|/|flatMap|/|filter|/|reduce|. However, these are normally<br>&gt;&gt;     reserved for when -ed doesn&#39;t really work (e.g. droppedFirst).<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/57885cfd0c4b4db16653e76d9e6f0266?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Johan Jensen</string> &lt;jj at johanjensen.dk&gt;<p>June 17, 2016 at 12:00:00am</p></header><div class="content"><p>-1 for the aforementioned reasons by David Waite and T.J. Usiyan.<br></p><p>On Thu, Jun 16, 2016 at 9:51 PM, Patrick Pijnappel via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Due to considerably support on this thread<br>&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;,<br>&gt; a draft proposal to revisit the core functional method exceptions to the<br>&gt; -ed/-ing rule.<br>&gt;<br>&gt; Online version:<br>&gt; https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br>&gt;<br>&gt; Apply -ed/-ing rule to core functional methods<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>&gt;    - Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs<br>&gt; ending in -ed/-ing (or nouns). However, a few non-mutating forms have been<br>&gt; kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and<br>&gt; dropLast. This proposal proposes to bring these in line with all other<br>&gt; non-mutating forms (e.g. filter =&gt; filtered).<br>&gt;<br>&gt; Swift-evolution threads: Source<br>&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; These method have been kept to preserve the terms of art. Generally, this<br>&gt; can have significant benefits:<br>&gt;<br>&gt;    - Anyone familiar with the term will immediately understand it, and<br>&gt;    use their assumptions about how it works.<br>&gt;    - Users learning the term from Swift can use their knowledge when<br>&gt;    encountering it elsewhere.<br>&gt;    - Experienced users will be able to use the mental pattern matching<br>&gt;    they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt;<br>&gt; However, basically all of the benefits of using a term of art still apply<br>&gt; to the modified forms: – For recognition, the modified forms are still very<br>&gt; close to the traditional terms of art. So both coming to and from Swift<br>&gt; you&#39;ll be able to use your knowledge pretty much unaffected.<br>&gt;<br>&gt;    - If the user looks for e.g. filter they are pretty much guaranteed to<br>&gt;    quickly find the correct form, be it through code-completion, google or a<br>&gt;    fix-it.<br>&gt;    - There isn&#39;t really any violation of assumptions that might cause<br>&gt;    problems in this case.<br>&gt;    - Any mental pattern matching will likely transfer quickly due to the<br>&gt;    minimal difference.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The proposed solution modifies the method verbs to their -ed/-ing forms<br>&gt; (preferring the former).<br>&gt;<br>&gt; It removes the last clear exceptions to the -ed/-ing rule from the<br>&gt; standard library, which previously were exactly the opposite of what one<br>&gt; would expect based on the API guidelines (and the rest of the language).<br>&gt;<br>&gt; It also aids users in learning to pattern match on the -ed/-ing rule and<br>&gt; internalizing the API guidelines, since now all methods are named this way<br>&gt; – instead of the most commonly used methods defying the normal pattern.<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The change would rename the following method families:<br>&gt;<br>&gt; map       =&gt; mapped<br>&gt; flatMap   =&gt; flatMapped<br>&gt; filter    =&gt; filtered<br>&gt; reduce    =&gt; reduced<br>&gt; dropFirst =&gt; droppingFirst<br>&gt; dropLast  =&gt; droppingLast<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The Swift migrator and fix-its would be provided for the change.<br>&gt;<br>&gt; &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt;    - Alternatively -ing suffixes could be used for map/flatMap/filter/<br>&gt;    reduce. However, these are normally reserved for when -ed doesn&#39;t<br>&gt;    really work (e.g. droppedFirst).<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/8d4cf616/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 16, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; map       =&gt; mapped<br>&gt; flatMap   =&gt; flatMapped <br>&gt; filter    =&gt; filtered<br>&gt; reduce    =&gt; reduced<br></p><p>You posted before I finished responding to this on the other thread, so I guess I&#39;ll do it here.<br></p><p>You&#39;re right that renaming these operations wouldn&#39;t be terrible. But I think they&#39;re easily distinguishable from things like `dropFirst`, and distinguishable in a way that tilts rather strongly towards leaving these as-is.<br></p><p>`map`, `filter`, and `reduce` are *the* higher-order functions. Almost anything with any kind of block/lambda/closure feature supports them (I&#39;m giving the side-eye to Foundation here), and all three names are backed by *very* strong conventions:<br></p><p>* `map` is by far the strongest. It is universally supported among languages with higher-order collection operations, and is almost always called `map`. In Wikipedia&#39;s list of 32 languages with a `map` &lt;https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison&gt;, we find (grouping together similar names like `map` and `maplist`, and double-counting languages with several aliases):<br></p><p>	Map: 19<br>	Collect: 3<br>	Apply: 3<br>	Special syntax: 2<br>	Select: 1 (C#, which uses it in the SQL-inspired LINQ)<br>	Transform: 1 (C++, which uses a bizarre signature involving an out parameter)<br>	ForEach: 1 (XPath)<br></p><p>* `filter` is supported nearly as widely as `map`, and the name `filter` is used nearly as consistently as `map`. Wikipedia lists 27 languages supporting a `filter`-style function, and `filter` is by far the most common choice, arguably favored even more consistently than `map` &lt;https://en.wikipedia.org/wiki/Filter_(higher-order_function)&gt;:<br></p><p>	Filter: 17<br>	Select: 4<br>	Special syntax: 3<br>	FilteredArrayUsingPredicate: 1 (Foundation, doesn&#39;t actually take a closure)<br>	Where: 1 (C#, in LINQ)<br>	CopyIf: 1 (C++, bizarre signature)<br>	FindAll: 1<br>	Grep: 1<br>	RemoveIfNot: 1<br></p><p>* `reduce` is extremely popular among functional languages because it&#39;s a primitive list-handling operation, although it&#39;s a little less common among mainstream languages than the other two. It *does* actually have an alternate name, `fold`, which is nearly as common as `reduce`. However, languages using `fold` are usually those which support both leftward- and rightward-reducing versions of the operation, whereas languages using `reduce` usually don&#39;t. Swift falls into the second camp. From Wikipedia&#39;s 39-language list &lt;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&gt;:<br></p><p>	Reduce: 20	(with both left and right: 4)<br>	Fold: 18	(with both left and right: 12)<br>	Inject: 3<br>	Special syntax: 3<br>	Aggregate: 1 (C#, in LINQ)<br>	Accumulate: 1 (C++, bizarre signature)<br>	Partition: 1<br>	ToIterator: 1<br></p><p>(Note that, although I *would* have counted the -ed or -ing forms of these names with the originals, I don&#39;t believe I saw any.)<br></p><p>Another illustration of the strength of these names: Google named a distributed computing project MapReduce, and everyone basically understood what it meant.<br></p><p>If `map`, `filter`, and `reduce` are not covered by the term-of-art rule, we might as well rename it to the sin()-and-Int rule, because I don&#39;t know what else it would cover. There is remarkable consistency in the naming of these operations across dozens of languages.<br></p><p>(Incidentally, I think if we *do* decide to rename the main higher-order list APIs, they would be better named as `mapping(to:)`, `flatMapping(to:)`, `filtering(by:)`, and `reducing(from:with:)`. Unlike `sorted`, the parameters are mandatory and deeply necessary to understand what the call does, so they deserve grammatical labels. Grammatical labels usually imply -ing form, not -ed form. If we want to address Dave&#39;s complaint about the ambiguity of `filter`, we might rename that to `selecting(where:)`, which is crystal clear about whether it keeps the true elements or the false ones.)<br></p><p>&gt; dropFirst =&gt; droppingFirst<br>&gt; dropLast  =&gt; droppingLast<br></p><p>Here, however, I think you&#39;re being under-ambitious.<br></p><p>* Even with a nonmutating suffix, `dropping` carries such a strong connotation of deletion that I think it&#39;s a poor choice. I would prefer `skipping`, which is much more clearly an operation that doesn&#39;t change anything (and finds precedent in other languages—`skip*` functions are a common alternative name for `drop*` functions.)<br></p><p>* The `First` and `Last` suffixes are inappropriate for the versions of this function which take an argument. These are inverse operations to `prefix(_:)` and `suffix(_:)`, and should be named accordingly.<br></p><p>* `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` are sort of strange, because they&#39;re tied deeply into indices and aren&#39;t closely related to the other prefix/suffix methods. I would at least seriously consider renaming these to `upTo(_:)`, `through(_:)`, and `from(_:)`—or perhaps even reimagine these entirely as subscripts `[upTo:]`, `[through:]`, and `[from:]`.<br></p><p>This is the area where the term-of-art argument is weaker, the API is more inconsistent and difficult to understand, and the methods are more rarely seen and so more important to be understandable without remembering them. All of these factors combine to make the gains from rationalizing them greater.<br></p><p>`map`, `flatMap`, `filter`, and `reduce` are in some ways the &quot;sexy&quot; targets: We use them all over the place, and changing them would &quot;fix&quot; more lines of code. But these calls are so common, and so heavily precedented, that few users will be confused by them—they&#39;ve probably seen them before Swift, and even if they haven&#39;t, they&#39;ll see them enough to keep their meanings fresh in their minds. It is the dimmer, less loved corners of the standard library which we ought to focus on, because they stand to benefit much more from following the conventions than the things we use constantly.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 17, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 17 Jun 2016, at 8:21 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; map       =&gt; mapped<br>&gt;&gt; flatMap   =&gt; flatMapped <br>&gt;&gt; filter    =&gt; filtered<br>&gt;&gt; reduce    =&gt; reduced<br>&gt; <br>&gt; You posted before I finished responding to this on the other thread, so I guess I&#39;ll do it here.<br>&gt; <br>&gt; You&#39;re right that renaming these operations wouldn&#39;t be terrible. But I think they&#39;re easily distinguishable from things like `dropFirst`, and distinguishable in a way that tilts rather strongly towards leaving these as-is.<br>&gt; <br>&gt; `map`, `filter`, and `reduce` are *the* higher-order functions. Almost anything with any kind of block/lambda/closure feature supports them (I&#39;m giving the side-eye to Foundation here), and all three names are backed by *very* strong conventions:<br>&gt; <br>&gt; * `map` is by far the strongest. It is universally supported among languages with higher-order collection operations, and is almost always called `map`. In Wikipedia&#39;s list of 32 languages with a `map` &lt;https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison&gt;, we find (grouping together similar names like `map` and `maplist`, and double-counting languages with several aliases):<br>&gt; <br>&gt; 	Map: 19<br>&gt; 	Collect: 3<br>&gt; 	Apply: 3<br>&gt; 	Special syntax: 2<br>&gt; 	Select: 1 (C#, which uses it in the SQL-inspired LINQ)<br>&gt; 	Transform: 1 (C++, which uses a bizarre signature involving an out parameter)<br>&gt; 	ForEach: 1 (XPath)<br>&gt; <br>&gt; * `filter` is supported nearly as widely as `map`, and the name `filter` is used nearly as consistently as `map`. Wikipedia lists 27 languages supporting a `filter`-style function, and `filter` is by far the most common choice, arguably favored even more consistently than `map` &lt;https://en.wikipedia.org/wiki/Filter_(higher-order_function)&gt;:<br>&gt; <br>&gt; 	Filter: 17<br>&gt; 	Select: 4<br>&gt; 	Special syntax: 3<br>&gt; 	FilteredArrayUsingPredicate: 1 (Foundation, doesn&#39;t actually take a closure)<br>&gt; 	Where: 1 (C#, in LINQ)<br>&gt; 	CopyIf: 1 (C++, bizarre signature)<br>&gt; 	FindAll: 1<br>&gt; 	Grep: 1<br>&gt; 	RemoveIfNot: 1<br>&gt; <br>&gt; * `reduce` is extremely popular among functional languages because it&#39;s a primitive list-handling operation, although it&#39;s a little less common among mainstream languages than the other two. It *does* actually have an alternate name, `fold`, which is nearly as common as `reduce`. However, languages using `fold` are usually those which support both leftward- and rightward-reducing versions of the operation, whereas languages using `reduce` usually don&#39;t. Swift falls into the second camp. From Wikipedia&#39;s 39-language list &lt;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&gt;:<br>&gt; <br>&gt; 	Reduce: 20	(with both left and right: 4)<br>&gt; 	Fold: 18	(with both left and right: 12)<br>&gt; 	Inject: 3<br>&gt; 	Special syntax: 3<br>&gt; 	Aggregate: 1 (C#, in LINQ)<br>&gt; 	Accumulate: 1 (C++, bizarre signature)<br>&gt; 	Partition: 1<br>&gt; 	ToIterator: 1<br>&gt; <br>&gt; (Note that, although I *would* have counted the -ed or -ing forms of these names with the originals, I don&#39;t believe I saw any.)<br></p><p>Great research. Thanks for doing this.<br></p><p>&gt; <br>&gt; Another illustration of the strength of these names: Google named a distributed computing project MapReduce, and everyone basically understood what it meant.<br>&gt; <br>&gt; If `map`, `filter`, and `reduce` are not covered by the term-of-art rule, we might as well rename it to the sin()-and-Int rule, because I don&#39;t know what else it would cover. There is remarkable consistency in the naming of these operations across dozens of languages.<br>&gt; <br>&gt; (Incidentally, I think if we *do* decide to rename the main higher-order list APIs, they would be better named as `mapping(to:)`, `flatMapping(to:)`, `filtering(by:)`, and `reducing(from:with:)`. Unlike `sorted`, the parameters are mandatory and deeply necessary to understand what the call does, so they deserve grammatical labels. Grammatical labels usually imply -ing form, not -ed form. If we want to address Dave&#39;s complaint about the ambiguity of `filter`, we might rename that to `selecting(where:)`, which is crystal clear about whether it keeps the true elements or the false ones.)<br></p><p>It would seem strange in one way to get rid of such strong terms of art (and also since they are nice and short, they are easy to glance at), but it also seems very inconsistent to keep them. These are methods that will be used by new programmers to Swift, so is it better to keep the existing terms or to modify them?<br></p><p>Say my type has a method filtered(with: Author), is it then strange that I am changing tense within the method’s implementation?<br></p><p>filtered(with author: Author) -&gt; [Item] {<br>  return items.filter{ $0.author == author }<br>}<br></p><p>Would it not make more sense to write?<br></p><p>filtered(with author: Author) -&gt; [Item] {<br>  return items.filtered(where: { $0.author == author })<br>}<br></p><p>&gt; <br>&gt;&gt; dropFirst =&gt; droppingFirst<br>&gt;&gt; dropLast  =&gt; droppingLast<br>&gt; <br>&gt; Here, however, I think you&#39;re being under-ambitious.<br>&gt; <br>&gt; * Even with a nonmutating suffix, `dropping` carries such a strong connotation of deletion that I think it&#39;s a poor choice. I would prefer `skipping`, which is much more clearly an operation that doesn&#39;t change anything (and finds precedent in other languages—`skip*` functions are a common alternative name for `drop*` functions.)<br></p><p>+1 to skipping<br></p><p>&gt; <br>&gt; * The `First` and `Last` suffixes are inappropriate for the versions of this function which take an argument. These are inverse operations to `prefix(_:)` and `suffix(_:)`, and should be named accordingly.<br>&gt; <br>&gt; * `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` are sort of strange, because they&#39;re tied deeply into indices and aren&#39;t closely related to the other prefix/suffix methods. I would at least seriously consider renaming these to `upTo(_:)`, `through(_:)`, and `from(_:)`—or perhaps even reimagine these entirely as subscripts `[upTo:]`, `[through:]`, and `[from:]`.<br></p><p>I really like the subscript idea. Named subscripts are not used nearly enough as they could. This gives these similar index-related operations a common home, and I believe would work well with autocomplete after typing a `[`.<br></p><p>I could even imagine a `[filtering:]` / `[where:]` / `[passing:]` instead of `filtered()`, but can imagine it might be unpopular.<br></p><p>&gt; <br>&gt; This is the area where the term-of-art argument is weaker, the API is more inconsistent and difficult to understand, and the methods are more rarely seen and so more important to be understandable without remembering them. All of these factors combine to make the gains from rationalizing them greater.<br>&gt; <br>&gt; `map`, `flatMap`, `filter`, and `reduce` are in some ways the &quot;sexy&quot; targets: We use them all over the place, and changing them would &quot;fix&quot; more lines of code. But these calls are so common, and so heavily precedented, that few users will be confused by them—they&#39;ve probably seen them before Swift, and even if they haven&#39;t, they&#39;ll see them enough to keep their meanings fresh in their minds. It is the dimmer, less loved corners of the standard library which we ought to focus on, because they stand to benefit much more from following the conventions than the things we use constantly.<br></p><p>`filter` is the big one to me, as it is a common verb that people are likely to use in their own `filtered-` methods. `reduce` is also a common verb, so it does make sense to change to `reducing`, however I don’t imagine many people will be writing their own `reducing-` methods, and similarly `mapping-`, so these possibly fall more into the terms of art category for me; `filtered` is the most important one. Besides, the word &#39;map&#39; always suggests to me that a new array/sequence will be returned, and never replace each item by mutation.<br></p><p>`filtered`: +1<br>`reducing`: +0.7<br>`mapping`: + 0.2<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 17, 2016 at 02:00:00pm</p></header><div class="content"><p>Support Patrick&#39;s opinion. It seems for me that &#39;map&#39;(+&#39;flatMap&#39;) and <br>&#39;reduce&#39; could be leaved as-is as *true* terms of art. Nothing else should <br>be added to these exception group.<br></p><p>Also please consider this code:<br>let foo = elements .map {..} .reduce() {...} .filter {} .sorted {}<br>why is so: &quot;filter&quot; but &quot;sorted&quot;<br></p><p>Note, that if *non-mutating* versions of methods were chosen to have <br>&quot;normal&quot; names in Swift(as was before 3.0) - we&#39;ll have no questions <br>regarding &quot;map&quot;/&quot;reduce&quot;/&quot;filter&quot;/&quot;sort&quot;/etc IMO the reason we have this <br>questions now is *other* modern languages has non-mutating methods with <br>&quot;normal&quot; names.<br></p><p>So, as soon as Swift decided to move its own way, IMO it should take only <br>these 2(3) methods as &quot;term of art&quot; and change all other method names to <br>conform to Swift&#39;s own naming rules.<br></p><p>On 17.06.2016 14:30, Patrick Smith via swift-evolution wrote:<br>&gt;&gt; On 17 Jun 2016, at 8:21 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; map       =&gt; mapped<br>&gt;&gt;&gt; flatMap   =&gt; flatMapped<br>&gt;&gt;&gt; filter    =&gt; filtered<br>&gt;&gt;&gt; reduce    =&gt; reduced<br>&gt;&gt;<br>&gt;&gt; You posted before I finished responding to this on the other thread, so I guess I&#39;ll do it here.<br>&gt;&gt;<br>&gt;&gt; You&#39;re right that renaming these operations wouldn&#39;t be terrible. But I think they&#39;re easily distinguishable from things like `dropFirst`, and distinguishable in a way that tilts rather strongly towards leaving these as-is.<br>&gt;&gt;<br>&gt;&gt; `map`, `filter`, and `reduce` are *the* higher-order functions. Almost anything with any kind of block/lambda/closure feature supports them (I&#39;m giving the side-eye to Foundation here), and all three names are backed by *very* strong conventions:<br>&gt;&gt;<br>&gt;&gt; * `map` is by far the strongest. It is universally supported among languages with higher-order collection operations, and is almost always called `map`. In Wikipedia&#39;s list of 32 languages with a `map` &lt;https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison&gt;, we find (grouping together similar names like `map` and `maplist`, and double-counting languages with several aliases):<br>&gt;&gt;<br>&gt;&gt; 	Map: 19<br>&gt;&gt; 	Collect: 3<br>&gt;&gt; 	Apply: 3<br>&gt;&gt; 	Special syntax: 2<br>&gt;&gt; 	Select: 1 (C#, which uses it in the SQL-inspired LINQ)<br>&gt;&gt; 	Transform: 1 (C++, which uses a bizarre signature involving an out parameter)<br>&gt;&gt; 	ForEach: 1 (XPath)<br>&gt;&gt;<br>&gt;&gt; * `filter` is supported nearly as widely as `map`, and the name `filter` is used nearly as consistently as `map`. Wikipedia lists 27 languages supporting a `filter`-style function, and `filter` is by far the most common choice, arguably favored even more consistently than `map` &lt;https://en.wikipedia.org/wiki/Filter_(higher-order_function)&gt;:<br>&gt;&gt;<br>&gt;&gt; 	Filter: 17<br>&gt;&gt; 	Select: 4<br>&gt;&gt; 	Special syntax: 3<br>&gt;&gt; 	FilteredArrayUsingPredicate: 1 (Foundation, doesn&#39;t actually take a closure)<br>&gt;&gt; 	Where: 1 (C#, in LINQ)<br>&gt;&gt; 	CopyIf: 1 (C++, bizarre signature)<br>&gt;&gt; 	FindAll: 1<br>&gt;&gt; 	Grep: 1<br>&gt;&gt; 	RemoveIfNot: 1<br>&gt;&gt;<br>&gt;&gt; * `reduce` is extremely popular among functional languages because it&#39;s a primitive list-handling operation, although it&#39;s a little less common among mainstream languages than the other two. It *does* actually have an alternate name, `fold`, which is nearly as common as `reduce`. However, languages using `fold` are usually those which support both leftward- and rightward-reducing versions of the operation, whereas languages using `reduce` usually don&#39;t. Swift falls into the second camp. From Wikipedia&#39;s 39-language list &lt;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&gt;:<br>&gt;&gt;<br>&gt;&gt; 	Reduce: 20	(with both left and right: 4)<br>&gt;&gt; 	Fold: 18	(with both left and right: 12)<br>&gt;&gt; 	Inject: 3<br>&gt;&gt; 	Special syntax: 3<br>&gt;&gt; 	Aggregate: 1 (C#, in LINQ)<br>&gt;&gt; 	Accumulate: 1 (C++, bizarre signature)<br>&gt;&gt; 	Partition: 1<br>&gt;&gt; 	ToIterator: 1<br>&gt;&gt;<br>&gt;&gt; (Note that, although I *would* have counted the -ed or -ing forms of these names with the originals, I don&#39;t believe I saw any.)<br>&gt;<br>&gt; Great research. Thanks for doing this.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Another illustration of the strength of these names: Google named a distributed computing project MapReduce, and everyone basically understood what it meant.<br>&gt;&gt;<br>&gt;&gt; If `map`, `filter`, and `reduce` are not covered by the term-of-art rule, we might as well rename it to the sin()-and-Int rule, because I don&#39;t know what else it would cover. There is remarkable consistency in the naming of these operations across dozens of languages.<br>&gt;&gt;<br>&gt;&gt; (Incidentally, I think if we *do* decide to rename the main higher-order list APIs, they would be better named as `mapping(to:)`, `flatMapping(to:)`, `filtering(by:)`, and `reducing(from:with:)`. Unlike `sorted`, the parameters are mandatory and deeply necessary to understand what the call does, so they deserve grammatical labels. Grammatical labels usually imply -ing form, not -ed form. If we want to address Dave&#39;s complaint about the ambiguity of `filter`, we might rename that to `selecting(where:)`, which is crystal clear about whether it keeps the true elements or the false ones.)<br>&gt;<br>&gt; It would seem strange in one way to get rid of such strong terms of art (and also since they are nice and short, they are easy to glance at), but it also seems very inconsistent to keep them. These are methods that will be used by new programmers to Swift, so is it better to keep the existing terms or to modify them?<br>&gt;<br>&gt; Say my type has a method filtered(with: Author), is it then strange that I am changing tense within the method’s implementation?<br>&gt;<br>&gt; filtered(with author: Author) -&gt; [Item] {<br>&gt;   return items.filter{ $0.author == author }<br>&gt; }<br>&gt;<br>&gt; Would it not make more sense to write?<br>&gt;<br>&gt; filtered(with author: Author) -&gt; [Item] {<br>&gt;   return items.filtered(where: { $0.author == author })<br>&gt; }<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; dropFirst =&gt; droppingFirst<br>&gt;&gt;&gt; dropLast  =&gt; droppingLast<br>&gt;&gt;<br>&gt;&gt; Here, however, I think you&#39;re being under-ambitious.<br>&gt;&gt;<br>&gt;&gt; * Even with a nonmutating suffix, `dropping` carries such a strong connotation of deletion that I think it&#39;s a poor choice. I would prefer `skipping`, which is much more clearly an operation that doesn&#39;t change anything (and finds precedent in other languages—`skip*` functions are a common alternative name for `drop*` functions.)<br>&gt;<br>&gt; +1 to skipping<br>&gt;<br>&gt;&gt;<br>&gt;&gt; * The `First` and `Last` suffixes are inappropriate for the versions of this function which take an argument. These are inverse operations to `prefix(_:)` and `suffix(_:)`, and should be named accordingly.<br>&gt;&gt;<br>&gt;&gt; * `prefix(upTo:)`, `prefix(through:)`, and `suffix(from:)` are sort of strange, because they&#39;re tied deeply into indices and aren&#39;t closely related to the other prefix/suffix methods. I would at least seriously consider renaming these to `upTo(_:)`, `through(_:)`, and `from(_:)`—or perhaps even reimagine these entirely as subscripts `[upTo:]`, `[through:]`, and `[from:]`.<br>&gt;<br>&gt; I really like the subscript idea. Named subscripts are not used nearly enough as they could. This gives these similar index-related operations a common home, and I believe would work well with autocomplete after typing a `[`.<br>&gt;<br>&gt; I could even imagine a `[filtering:]` / `[where:]` / `[passing:]` instead of `filtered()`, but can imagine it might be unpopular.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; This is the area where the term-of-art argument is weaker, the API is more inconsistent and difficult to understand, and the methods are more rarely seen and so more important to be understandable without remembering them. All of these factors combine to make the gains from rationalizing them greater.<br>&gt;&gt;<br>&gt;&gt; `map`, `flatMap`, `filter`, and `reduce` are in some ways the &quot;sexy&quot; targets: We use them all over the place, and changing them would &quot;fix&quot; more lines of code. But these calls are so common, and so heavily precedented, that few users will be confused by them—they&#39;ve probably seen them before Swift, and even if they haven&#39;t, they&#39;ll see them enough to keep their meanings fresh in their minds. It is the dimmer, less loved corners of the standard library which we ought to focus on, because they stand to benefit much more from following the conventions than the things we use constantly.<br>&gt;<br>&gt; `filter` is the big one to me, as it is a common verb that people are likely to use in their own `filtered-` methods. `reduce` is also a common verb, so it does make sense to change to `reducing`, however I don’t imagine many people will be writing their own `reducing-` methods, and similarly `mapping-`, so these possibly fall more into the terms of art category for me; `filtered` is the most important one. Besides, the word &#39;map&#39; always suggests to me that a new array/sequence will be returned, and never replace each item by mutation.<br>&gt;<br>&gt; `filtered`: +1<br>&gt; `reducing`: +0.7<br>&gt; `mapping`: + 0.2<br>&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 16, 2016 at 04:00:00pm</p></header><div class="content"><p>-1 The Term of Art argument is very strong with these functions. I prefer them as-is.<br></p><p>&gt; On 16 Jun 2016, at 12:51, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Due to considerably support on this thread &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;, a draft proposal to revisit the core functional method exceptions to the -ed/-ing rule.<br>&gt; <br>&gt; Online version: https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md&gt;<br>&gt; <br>&gt; Apply -ed/-ing rule to core functional methods<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>&gt; Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;Introduction<br>&gt; <br>&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs ending in -ed/-ing (or nouns). However, a few non-mutating forms have been kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and dropLast. This proposal proposes to bring these in line with all other non-mutating forms (e.g. filter =&gt; filtered).<br>&gt; <br>&gt; Swift-evolution threads: Source &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;Motivation<br>&gt; <br>&gt; These method have been kept to preserve the terms of art. Generally, this can have significant benefits:<br>&gt; <br>&gt; Anyone familiar with the term will immediately understand it, and use their assumptions about how it works.<br>&gt; Users learning the term from Swift can use their knowledge when encountering it elsewhere.<br>&gt; Experienced users will be able to use the mental pattern matching they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt; However, basically all of the benefits of using a term of art still apply to the modified forms: – For recognition, the modified forms are still very close to the traditional terms of art. So both coming to and from Swift you&#39;ll be able to use your knowledge pretty much unaffected. <br>&gt; <br>&gt; If the user looks for e.g. filter they are pretty much guaranteed to quickly find the correct form, be it through code-completion, google or a fix-it.<br>&gt; There isn&#39;t really any violation of assumptions that might cause problems in this case.<br>&gt; Any mental pattern matching will likely transfer quickly due to the minimal difference.<br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The proposed solution modifies the method verbs to their -ed/-ing forms (preferring the former). <br>&gt; <br>&gt; It removes the last clear exceptions to the -ed/-ing rule from the standard library, which previously were exactly the opposite of what one would expect based on the API guidelines (and the rest of the language).<br>&gt; <br>&gt; It also aids users in learning to pattern match on the -ed/-ing rule and internalizing the API guidelines, since now all methods are named this way – instead of the most commonly used methods defying the normal pattern.<br>&gt; <br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The change would rename the following method families:<br>&gt; <br>&gt; map       =&gt; mapped<br>&gt; flatMap   =&gt; flatMapped <br>&gt; filter    =&gt; filtered<br>&gt; reduce    =&gt; reduced<br>&gt; dropFirst =&gt; droppingFirst<br>&gt; dropLast  =&gt; droppingLast<br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The Swift migrator and fix-its would be provided for the change. <br>&gt; <br>&gt;  &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Alternatively -ing suffixes could be used for map/flatMap/filter/reduce. However, these are normally reserved for when -ed doesn&#39;t really work (e.g. droppedFirst).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/c25b80a9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>June 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Isn&#39;t the rule only for the case where you can have a mutating and non-mutating variant?<br></p><p>The &#39;reduce()&#39; at its core take an array of element and reduce it to single element (could be of a different type) as such it cannot ever be mutating (if one really want it, one could reduce an array to the same array but it is not the goal of the function). For this one it sound to me nearly like asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br></p><p>Dany<br></p><p><br>&gt; Le 16 juin 2016 à 15:51, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Due to considerably support on this thread, a draft proposal to revisit the core functional method exceptions to the -ed/-ing rule.<br>&gt; <br>&gt; Online version: https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br>&gt; <br>&gt; Apply -ed/-ing rule to core functional methods<br>&gt; Proposal: SE-NNNN<br>&gt; Author: Patrick Pijnappel<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs ending in -ed/-ing (or nouns). However, a few non-mutating forms have been kept as &quot;Terms of Art&quot;: map, flatMap, filter, reduce, dropFirst and dropLast. This proposal proposes to bring these in line with all other non-mutating forms (e.g. filter =&gt; filtered).<br>&gt; <br>&gt; Swift-evolution threads: Source<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; These method have been kept to preserve the terms of art. Generally, this can have significant benefits:<br>&gt; <br>&gt; Anyone familiar with the term will immediately understand it, and use their assumptions about how it works.<br>&gt; Users learning the term from Swift can use their knowledge when encountering it elsewhere.<br>&gt; Experienced users will be able to use the mental pattern matching they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt; However, basically all of the benefits of using a term of art still apply to the modified forms: – For recognition, the modified forms are still very close to the traditional terms of art. So both coming to and from Swift you&#39;ll be able to use your knowledge pretty much unaffected. <br>&gt; <br>&gt; If the user looks for e.g. filter they are pretty much guaranteed to quickly find the correct form, be it through code-completion, google or a fix-it.<br>&gt; There isn&#39;t really any violation of assumptions that might cause problems in this case.<br>&gt; Any mental pattern matching will likely transfer quickly due to the minimal difference.<br>&gt; Proposed solution<br>&gt; <br>&gt; The proposed solution modifies the method verbs to their -ed/-ing forms (preferring the former). <br>&gt; <br>&gt; It removes the last clear exceptions to the -ed/-ing rule from the standard library, which previously were exactly the opposite of what one would expect based on the API guidelines (and the rest of the language).<br>&gt; <br>&gt; It also aids users in learning to pattern match on the -ed/-ing rule and internalizing the API guidelines, since now all methods are named this way – instead of the most commonly used methods defying the normal pattern.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; The change would rename the following method families:<br>&gt; <br>&gt; map       =&gt; mapped<br>&gt; flatMap   =&gt; flatMapped <br>&gt; filter    =&gt; filtered<br>&gt; reduce    =&gt; reduced<br>&gt; dropFirst =&gt; droppingFirst<br>&gt; dropLast  =&gt; droppingLast<br>&gt; Impact on existing code<br>&gt; <br>&gt; The Swift migrator and fix-its would be provided for the change. <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Alternatively -ing suffixes could be used for map/flatMap/filter/reduce. However, these are normally reserved for when -ed doesn&#39;t really work (e.g. droppedFirst).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/9eb258b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; The &#39;reduce()&#39; at its core take an array of element and reduce it to single element (could be of a different type) as such it cannot ever be mutating (if one really want it, one could reduce an array to the same array but it is not the goal of the function). For this one it sound to me nearly like asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br></p><p>`max`, `count`, and `sum` are all nouns—at least in the senses they are meant in those calls—so they do not take the -ed/-ing suffixes to form immutable variants. Instead, they would take the `form` prefix to form mutable variants, if they had them.<br></p><p>`map`, `filter`, and `reduce`—at least in the senses they must be interpreted in for the names of those calls to make sense—are verbs, and so they *would* normally take -ed/-ing suffixes. However, as broadly-accepted terms of art, we have left them alone until now.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>June 17, 2016 at 07:00:00am</p></header><div class="content"><p>&gt;<br>&gt; -1, for the same reasons stated on the thread. These are neither<br>&gt; guaranteed to be mutating or non-mutating until you get to Collection.<br>&gt; Changing map() to mapped() would be lying to the developer some of the<br>&gt; time about the mutability of the interface.<br>&gt; -DW<br></p><p><br>Actually the -ed/-ing suffix is *not *intended to guarantee<br>non-mutatability. It merely communicates whether it is a<br>&quot;return-a-transformed-version-of-the-instance&quot;-type method as opposed to an<br>in-place mutation. Clearly these are not in-place forms. Note that this is<br>my interpretation of the intent of the guidelines (or what should be the<br>intent) – if the core team agrees perhaps this deserves clarification in<br>the document.<br></p><p>These functions are different than for example `sort` because there can’t<br>&gt; be a general mutating method of `map`. A variable of type `[A]` can’t be<br>&gt; mutated to hold a `[B]` which would be the result of a map from `A -&gt; B`.<br></p><p><br>There could definitely be an in-place variant of filter. While a *fully*<br>general method would not be possible for the others, an user might<br>reasonable expect in-place variants of map/flatMap if T == U as with e.g. {<br>$0 * 2 } or Optionals, and of dropFirst/dropLast if SubSequence == Sequence<br>as with e.g. String.<br></p><p>Also note that the -ed/-ing rule should not be merely for ambiguous cases,<br>it should tell the user that the main use of the method is returning a<br>transformed version of the instance. Having this be a rule you can depend<br>on is important.<br></p><p>-1 The Term of Art argument is very strong with these functions. I prefer<br>&gt; them as-is.<br></p><p><br>What specific benefits do we obtain from using the *exact *terms of art vs.<br>the very slightly modified versions proposed?<br></p><p><br>On Fri, Jun 17, 2016 at 3:24 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; The &#39;reduce()&#39; at its core take an array of element and reduce it to<br>&gt; single element (could be of a different type) as such it cannot ever be<br>&gt; mutating (if one really want it, one could reduce an array to the same<br>&gt; array but it is not the goal of the function). For this one it sound to me<br>&gt; nearly like asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or<br>&gt; implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br>&gt;<br>&gt; `max`, `count`, and `sum` are all nouns—at least in the senses they are<br>&gt; meant in those calls—so they do not take the -ed/-ing suffixes to form<br>&gt; immutable variants. Instead, they would take the `form` prefix to form<br>&gt; mutable variants, if they had them.<br>&gt;<br>&gt; `map`, `filter`, and `reduce`—at least in the senses they must be<br>&gt; interpreted in for the names of those calls to make sense—are verbs, and so<br>&gt; they *would* normally take -ed/-ing suffixes. However, as broadly-accepted<br>&gt; terms of art, we have left them alone until now.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/e8c4fe99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 17, 2016 at 03:00:00pm</p></header><div class="content"><p>On 17.06.2016 8:02, Patrick Pijnappel via swift-evolution wrote:<br>&gt;     -1, for the same reasons stated on the thread. These are neither<br>&gt;     guaranteed to be mutating or non-mutating until you get to Collection.<br>&gt;     Changing map() to mapped() would be lying to the developer some of the<br>&gt;     time about the mutability of the interface.<br>&gt;     -DW<br>&gt;<br>&gt;<br>&gt; Actually the -ed/-ing suffix is *not *intended to guarantee<br>&gt; non-mutatability. It merely communicates whether it is a<br>&gt; &quot;return-a-transformed-version-of-the-instance&quot;-type method as opposed to an<br>&gt; in-place mutation. Clearly these are not in-place forms. Note that this is<br>&gt; my interpretation of the intent of the guidelines (or what should be the<br>&gt; intent) – if the core team agrees perhaps this deserves clarification in<br>&gt; the document.<br></p><p>Totally agree with you. I also understand this rule as separation of <br>&quot;in-place&quot;/&quot;returns transformed version&quot;. I.e. the suffix should say just <br>&quot;result of this operation will be returned and should be assigned to other <br>instance variable&quot;. Otherwise, as I understand, ANY method that will touch <br>or iterate the Sequence *could* mutate it and so potentially we should have <br>no -ing/-ed methods for Sequence - no?<br></p><p>&gt;<br>&gt;     These functions are different than for example `sort` because there<br>&gt;     can’t be a general mutating method of `map`. A variable of type `[A]`<br>&gt;     can’t be mutated to hold a `[B]` which would be the result of a map<br>&gt;     from `A -&gt; B`.<br>&gt;<br>&gt;<br>&gt; There could definitely be an in-place variant of filter. While a /fully/<br>&gt; general method would not be possible for the others, an user might<br>&gt; reasonable expect in-place variants of map/flatMap if T == U as with e.g. {<br>&gt; $0 * 2 } or Optionals, and of dropFirst/dropLast if SubSequence == Sequence<br>&gt; as with e.g. String.<br>&gt;<br>&gt; Also note that the -ed/-ing rule should not be merely for ambiguous cases,<br>&gt; it should tell the user that the main use of the method is returning a<br>&gt; transformed version of the instance. Having this be a rule you can depend<br>&gt; on is important.<br></p><p>+1<br></p><p>&gt;<br>&gt;     -1 The Term of Art argument is very strong with these functions. I<br>&gt;     prefer them as-is.<br>&gt;<br>&gt;<br>&gt; What specific benefits do we obtain from using the /exact /terms of art vs.<br>&gt; the very slightly modified versions proposed?<br></p><p>Although I believe we can leave map&amp;reduce as-is, I can understand if we&#39;ll <br>change them to mapped/reduced and will have consistent naming everywhere, <br>don&#39;t think this will cause any confusion for one who will start to use <br>them. In any case, we can add a hint in compiler like &quot;did you mean &#39;mapped&#39;?&quot;.<br></p><p>&gt;<br>&gt;<br>&gt; On Fri, Jun 17, 2016 at 3:24 AM, Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     &gt; The &#39;reduce()&#39; at its core take an array of element and reduce it to single element (could be of a different type) as such it cannot ever be mutating (if one really want it, one could reduce an array to the same array but it is not the goal of the function). For this one it sound to me nearly like asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br>&gt;<br>&gt;     `max`, `count`, and `sum` are all nouns—at least in the senses they are<br>&gt;     meant in those calls—so they do not take the -ed/-ing suffixes to form<br>&gt;     immutable variants. Instead, they would take the `form` prefix to form<br>&gt;     mutable variants, if they had them.<br>&gt;<br>&gt;     `map`, `filter`, and `reduce`—at least in the senses they must be<br>&gt;     interpreted in for the names of those calls to make sense—are verbs,<br>&gt;     and so they *would* normally take -ed/-ing suffixes. However, as<br>&gt;     broadly-accepted terms of art, we have left them alone until now.<br>&gt;<br>&gt;     --<br>&gt;     Brent Royal-Gordon<br>&gt;     Architechies<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>June 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; `map`, `filter`, and `reduce` are *the* higher-order functions. Almost<br>&gt; anything with any kind of block/lambda/closure feature supports them (I&#39;m<br>&gt; giving the side-eye to Foundation here), and all three names are backed by<br>&gt; *very* strong conventions<br></p><p><br></p><p>&gt; If `map`, `filter`, and `reduce` are not covered by the term-of-art rule,<br>&gt; we might as well rename it to the sin()-and-Int rule, because I don&#39;t know<br>&gt; what else it would cover. There is remarkable consistency in the naming of<br>&gt; these operations across dozens of languages.<br></p><p><br>The point the proposal raises is that the modified versions preserve the<br>the terms of art in all the senses that matter (i.e. all the benefits like<br>recognition etc. still apply).<br></p><p>On Fri, Jun 17, 2016 at 2:12 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; On 17.06.2016 8:02, Patrick Pijnappel via swift-evolution wrote:<br>&gt;<br>&gt;&gt;     -1, for the same reasons stated on the thread. These are neither<br>&gt;&gt;     guaranteed to be mutating or non-mutating until you get to Collection.<br>&gt;&gt;     Changing map() to mapped() would be lying to the developer some of the<br>&gt;&gt;     time about the mutability of the interface.<br>&gt;&gt;     -DW<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Actually the -ed/-ing suffix is *not *intended to guarantee<br>&gt;&gt; non-mutatability. It merely communicates whether it is a<br>&gt;&gt; &quot;return-a-transformed-version-of-the-instance&quot;-type method as opposed to<br>&gt;&gt; an<br>&gt;&gt; in-place mutation. Clearly these are not in-place forms. Note that this is<br>&gt;&gt; my interpretation of the intent of the guidelines (or what should be the<br>&gt;&gt; intent) – if the core team agrees perhaps this deserves clarification in<br>&gt;&gt; the document.<br>&gt;&gt;<br>&gt;<br>&gt; Totally agree with you. I also understand this rule as separation of<br>&gt; &quot;in-place&quot;/&quot;returns transformed version&quot;. I.e. the suffix should say just<br>&gt; &quot;result of this operation will be returned and should be assigned to other<br>&gt; instance variable&quot;. Otherwise, as I understand, ANY method that will touch<br>&gt; or iterate the Sequence *could* mutate it and so potentially we should have<br>&gt; no -ing/-ed methods for Sequence - no?<br>&gt;<br>&gt;<br>&gt;&gt;     These functions are different than for example `sort` because there<br>&gt;&gt;     can’t be a general mutating method of `map`. A variable of type `[A]`<br>&gt;&gt;     can’t be mutated to hold a `[B]` which would be the result of a map<br>&gt;&gt;     from `A -&gt; B`.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There could definitely be an in-place variant of filter. While a /fully/<br>&gt;&gt; general method would not be possible for the others, an user might<br>&gt;&gt; reasonable expect in-place variants of map/flatMap if T == U as with e.g.<br>&gt;&gt; {<br>&gt;&gt; $0 * 2 } or Optionals, and of dropFirst/dropLast if SubSequence ==<br>&gt;&gt; Sequence<br>&gt;&gt; as with e.g. String.<br>&gt;&gt;<br>&gt;&gt; Also note that the -ed/-ing rule should not be merely for ambiguous cases,<br>&gt;&gt; it should tell the user that the main use of the method is returning a<br>&gt;&gt; transformed version of the instance. Having this be a rule you can depend<br>&gt;&gt; on is important.<br>&gt;&gt;<br>&gt;<br>&gt; +1<br>&gt;<br>&gt;<br>&gt;&gt;     -1 The Term of Art argument is very strong with these functions. I<br>&gt;&gt;     prefer them as-is.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What specific benefits do we obtain from using the /exact /terms of art<br>&gt;&gt; vs.<br>&gt;&gt; the very slightly modified versions proposed?<br>&gt;&gt;<br>&gt;<br>&gt; Although I believe we can leave map&amp;reduce as-is, I can understand if<br>&gt; we&#39;ll change them to mapped/reduced and will have consistent naming<br>&gt; everywhere, don&#39;t think this will cause any confusion for one who will<br>&gt; start to use them. In any case, we can add a hint in compiler like &quot;did you<br>&gt; mean &#39;mapped&#39;?&quot;.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Jun 17, 2016 at 3:24 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     &gt; The &#39;reduce()&#39; at its core take an array of element and reduce it<br>&gt;&gt; to single element (could be of a different type) as such it cannot ever be<br>&gt;&gt; mutating (if one really want it, one could reduce an array to the same<br>&gt;&gt; array but it is not the goal of the function). For this one it sound to me<br>&gt;&gt; nearly like asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or<br>&gt;&gt; implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br>&gt;&gt;<br>&gt;&gt;     `max`, `count`, and `sum` are all nouns—at least in the senses they<br>&gt;&gt; are<br>&gt;&gt;     meant in those calls—so they do not take the -ed/-ing suffixes to form<br>&gt;&gt;     immutable variants. Instead, they would take the `form` prefix to form<br>&gt;&gt;     mutable variants, if they had them.<br>&gt;&gt;<br>&gt;&gt;     `map`, `filter`, and `reduce`—at least in the senses they must be<br>&gt;&gt;     interpreted in for the names of those calls to make sense—are verbs,<br>&gt;&gt;     and so they *would* normally take -ed/-ing suffixes. However, as<br>&gt;&gt;     broadly-accepted terms of art, we have left them alone until now.<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Brent Royal-Gordon<br>&gt;&gt;     Architechies<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/71cc8881/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>June 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;<br>&gt;  I suggest to leave map+flatMap+reduce as-is as true terms-of-art<br></p><p><br>Question still stands, what benefits do we gain from using the *exact*<br>terms that are not present in the slightly modified ones?<br></p><p>On Fri, Jun 17, 2016 at 2:26 PM, Patrick Pijnappel &lt;<br>patrickpijnappel at gmail.com&gt; wrote:<br></p><p>&gt; `map`, `filter`, and `reduce` are *the* higher-order functions. Almost<br>&gt;&gt; anything with any kind of block/lambda/closure feature supports them (I&#39;m<br>&gt;&gt; giving the side-eye to Foundation here), and all three names are backed by<br>&gt;&gt; *very* strong conventions<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; If `map`, `filter`, and `reduce` are not covered by the term-of-art rule,<br>&gt;&gt; we might as well rename it to the sin()-and-Int rule, because I don&#39;t know<br>&gt;&gt; what else it would cover. There is remarkable consistency in the naming of<br>&gt;&gt; these operations across dozens of languages.<br>&gt;<br>&gt;<br>&gt; The point the proposal raises is that the modified versions preserve the<br>&gt; the terms of art in all the senses that matter (i.e. all the benefits like<br>&gt; recognition etc. still apply).<br>&gt;<br>&gt; On Fri, Jun 17, 2016 at 2:12 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; On 17.06.2016 8:02, Patrick Pijnappel via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;     -1, for the same reasons stated on the thread. These are neither<br>&gt;&gt;&gt;     guaranteed to be mutating or non-mutating until you get to<br>&gt;&gt;&gt; Collection.<br>&gt;&gt;&gt;     Changing map() to mapped() would be lying to the developer some of<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt;     time about the mutability of the interface.<br>&gt;&gt;&gt;     -DW<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Actually the -ed/-ing suffix is *not *intended to guarantee<br>&gt;&gt;&gt; non-mutatability. It merely communicates whether it is a<br>&gt;&gt;&gt; &quot;return-a-transformed-version-of-the-instance&quot;-type method as opposed to<br>&gt;&gt;&gt; an<br>&gt;&gt;&gt; in-place mutation. Clearly these are not in-place forms. Note that this<br>&gt;&gt;&gt; is<br>&gt;&gt;&gt; my interpretation of the intent of the guidelines (or what should be the<br>&gt;&gt;&gt; intent) – if the core team agrees perhaps this deserves clarification in<br>&gt;&gt;&gt; the document.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Totally agree with you. I also understand this rule as separation of<br>&gt;&gt; &quot;in-place&quot;/&quot;returns transformed version&quot;. I.e. the suffix should say just<br>&gt;&gt; &quot;result of this operation will be returned and should be assigned to other<br>&gt;&gt; instance variable&quot;. Otherwise, as I understand, ANY method that will touch<br>&gt;&gt; or iterate the Sequence *could* mutate it and so potentially we should have<br>&gt;&gt; no -ing/-ed methods for Sequence - no?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;     These functions are different than for example `sort` because there<br>&gt;&gt;&gt;     can’t be a general mutating method of `map`. A variable of type `[A]`<br>&gt;&gt;&gt;     can’t be mutated to hold a `[B]` which would be the result of a map<br>&gt;&gt;&gt;     from `A -&gt; B`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There could definitely be an in-place variant of filter. While a /fully/<br>&gt;&gt;&gt; general method would not be possible for the others, an user might<br>&gt;&gt;&gt; reasonable expect in-place variants of map/flatMap if T == U as with<br>&gt;&gt;&gt; e.g. {<br>&gt;&gt;&gt; $0 * 2 } or Optionals, and of dropFirst/dropLast if SubSequence ==<br>&gt;&gt;&gt; Sequence<br>&gt;&gt;&gt; as with e.g. String.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also note that the -ed/-ing rule should not be merely for ambiguous<br>&gt;&gt;&gt; cases,<br>&gt;&gt;&gt; it should tell the user that the main use of the method is returning a<br>&gt;&gt;&gt; transformed version of the instance. Having this be a rule you can depend<br>&gt;&gt;&gt; on is important.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; +1<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;     -1 The Term of Art argument is very strong with these functions. I<br>&gt;&gt;&gt;     prefer them as-is.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What specific benefits do we obtain from using the /exact /terms of art<br>&gt;&gt;&gt; vs.<br>&gt;&gt;&gt; the very slightly modified versions proposed?<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Although I believe we can leave map&amp;reduce as-is, I can understand if<br>&gt;&gt; we&#39;ll change them to mapped/reduced and will have consistent naming<br>&gt;&gt; everywhere, don&#39;t think this will cause any confusion for one who will<br>&gt;&gt; start to use them. In any case, we can add a hint in compiler like &quot;did you<br>&gt;&gt; mean &#39;mapped&#39;?&quot;.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Jun 17, 2016 at 3:24 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt; The &#39;reduce()&#39; at its core take an array of element and reduce it<br>&gt;&gt;&gt; to single element (could be of a different type) as such it cannot ever be<br>&gt;&gt;&gt; mutating (if one really want it, one could reduce an array to the same<br>&gt;&gt;&gt; array but it is not the goal of the function). For this one it sound to me<br>&gt;&gt;&gt; nearly like asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or<br>&gt;&gt;&gt; implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     `max`, `count`, and `sum` are all nouns—at least in the senses they<br>&gt;&gt;&gt; are<br>&gt;&gt;&gt;     meant in those calls—so they do not take the -ed/-ing suffixes to<br>&gt;&gt;&gt; form<br>&gt;&gt;&gt;     immutable variants. Instead, they would take the `form` prefix to<br>&gt;&gt;&gt; form<br>&gt;&gt;&gt;     mutable variants, if they had them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     `map`, `filter`, and `reduce`—at least in the senses they must be<br>&gt;&gt;&gt;     interpreted in for the names of those calls to make sense—are verbs,<br>&gt;&gt;&gt;     and so they *would* normally take -ed/-ing suffixes. However, as<br>&gt;&gt;&gt;     broadly-accepted terms of art, we have left them alone until now.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     --<br>&gt;&gt;&gt;     Brent Royal-Gordon<br>&gt;&gt;&gt;     Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/dc52b0b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 17, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Question still stands, what benefits do we gain from using the exact terms that are not present in the slightly modified ones?<br></p><p>Instant, unambiguous recognition.<br></p><p>Look. You could make the exact same arguments about `sin`. We could create a `sine()` method on FloatingPoint and install a dummy `sin(_:)` function with a `renamed` attribute pointing to it. Why don&#39;t we do that? Because it&#39;s not the terminology used for that domain. There is a universal convention, stretching back hundreds of years, for how you write &quot;get the sine of this number&quot;, and `n.sine()` is not that convention, so we don&#39;t use it.<br></p><p>Similarly, there is a nearly universal convention, stretching back to Lisp&#39;s `maplist` function in 1959 (!!!), pointing at the term `map`. `reduce` dates back to APL in 1962, although of course that was the term used in the documentation, since APL relied so heavily on operators. These terms are steeped in history as rich as anything in programming. By sticking to the exact terms, there is no question that yes, this is the same function programmers have been using since the Eisenhower administration.<br></p><p>By contrast, changing the name would seem to hint that it *isn&#39;t* the standard `map` function. Maybe Swift, like Java, calls its dictionaries `Map`s, and `mapped` or `mapping` is an operation to convert an array into a `Map`. And even if it&#39;s not confusing, it&#39;s going to confound the muscle memory of programmers who use both Swift and another language with higher-order list functions.<br></p><p>Let me turn your question around: What concrete benefits do we gain from modifying terms which are extremely widely recognized? It is not consistent, but is there any reason to believe that causes actual confusion? If not, then why fix what isn&#39;t broken?<br></p><p>That&#39;s why I want to focus on the first/last/prefix/suffix methods. There I see real problems: misleading names, tangled and unclear relationships, and little reason to tolerate the situation to preserve terms of art. Renaming `map`, `reduce`, and `filter`, by contrast, seem to be mostly about consistency for the sake of consistency, not consistency for the sake of concrete benefits.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 17, 2016 at 05:00:00pm</p></header><div class="content"><p>On 17.06.2016 15:58, Patrick Pijnappel wrote:<br>&gt;      I suggest to leave map+flatMap+reduce as-is as true terms-of-art<br>&gt;<br>&gt;<br>&gt; Question still stands, what benefits do we gain from using the /exact/<br>&gt; terms that are not present in the slightly modified ones?<br></p><p>I don&#39;t know :-) I just see that many against renaming of <br>map/filter/reduce/etc and suggest a compromise : we leave map/reduce as-is, <br>but nothing else should be an exception to the naming rules.<br></p><p>&gt;<br>&gt; On Fri, Jun 17, 2016 at 2:26 PM, Patrick Pijnappel<br>&gt; &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;         `map`, `filter`, and `reduce` are *the* higher-order functions.<br>&gt;         Almost anything with any kind of block/lambda/closure feature<br>&gt;         supports them (I&#39;m giving the side-eye to Foundation here), and all<br>&gt;         three names are backed by *very* strong conventions<br>&gt;<br>&gt;<br>&gt;<br>&gt;         If `map`, `filter`, and `reduce` are not covered by the term-of-art<br>&gt;         rule, we might as well rename it to the sin()-and-Int rule, because<br>&gt;         I don&#39;t know what else it would cover. There is remarkable<br>&gt;         consistency in the naming of these operations across dozens of<br>&gt;         languages.<br>&gt;<br>&gt;<br>&gt;     The point the proposal raises is that the modified versions preserve<br>&gt;     the the terms of art in all the senses that matter (i.e. all the<br>&gt;     benefits like recognition etc. still apply).<br>&gt;<br>&gt;     On Fri, Jun 17, 2016 at 2:12 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;         On 17.06.2016 8:02, Patrick Pijnappel via swift-evolution wrote:<br>&gt;<br>&gt;                 -1, for the same reasons stated on the thread. These are<br>&gt;             neither<br>&gt;                 guaranteed to be mutating or non-mutating until you get to<br>&gt;             Collection.<br>&gt;                 Changing map() to mapped() would be lying to the developer<br>&gt;             some of the<br>&gt;                 time about the mutability of the interface.<br>&gt;                 -DW<br>&gt;<br>&gt;<br>&gt;             Actually the -ed/-ing suffix is *not *intended to guarantee<br>&gt;             non-mutatability. It merely communicates whether it is a<br>&gt;             &quot;return-a-transformed-version-of-the-instance&quot;-type method as<br>&gt;             opposed to an<br>&gt;             in-place mutation. Clearly these are not in-place forms. Note<br>&gt;             that this is<br>&gt;             my interpretation of the intent of the guidelines (or what<br>&gt;             should be the<br>&gt;             intent) – if the core team agrees perhaps this deserves<br>&gt;             clarification in<br>&gt;             the document.<br>&gt;<br>&gt;<br>&gt;         Totally agree with you. I also understand this rule as separation<br>&gt;         of &quot;in-place&quot;/&quot;returns transformed version&quot;. I.e. the suffix should<br>&gt;         say just &quot;result of this operation will be returned and should be<br>&gt;         assigned to other instance variable&quot;. Otherwise, as I understand,<br>&gt;         ANY method that will touch or iterate the Sequence *could* mutate<br>&gt;         it and so potentially we should have no -ing/-ed methods for<br>&gt;         Sequence - no?<br>&gt;<br>&gt;<br>&gt;                 These functions are different than for example `sort`<br>&gt;             because there<br>&gt;                 can’t be a general mutating method of `map`. A variable of<br>&gt;             type `[A]`<br>&gt;                 can’t be mutated to hold a `[B]` which would be the result<br>&gt;             of a map<br>&gt;                 from `A -&gt; B`.<br>&gt;<br>&gt;<br>&gt;             There could definitely be an in-place variant of filter. While<br>&gt;             a /fully/<br>&gt;             general method would not be possible for the others, an user might<br>&gt;             reasonable expect in-place variants of map/flatMap if T == U as<br>&gt;             with e.g. {<br>&gt;             $0 * 2 } or Optionals, and of dropFirst/dropLast if SubSequence<br>&gt;             == Sequence<br>&gt;             as with e.g. String.<br>&gt;<br>&gt;             Also note that the -ed/-ing rule should not be merely for<br>&gt;             ambiguous cases,<br>&gt;             it should tell the user that the main use of the method is<br>&gt;             returning a<br>&gt;             transformed version of the instance. Having this be a rule you<br>&gt;             can depend<br>&gt;             on is important.<br>&gt;<br>&gt;<br>&gt;         +1<br>&gt;<br>&gt;<br>&gt;                 -1 The Term of Art argument is very strong with these<br>&gt;             functions. I<br>&gt;                 prefer them as-is.<br>&gt;<br>&gt;<br>&gt;             What specific benefits do we obtain from using the /exact<br>&gt;             /terms of art vs.<br>&gt;             the very slightly modified versions proposed?<br>&gt;<br>&gt;<br>&gt;         Although I believe we can leave map&amp;reduce as-is, I can understand<br>&gt;         if we&#39;ll change them to mapped/reduced and will have consistent<br>&gt;         naming everywhere, don&#39;t think this will cause any confusion for<br>&gt;         one who will start to use them. In any case, we can add a hint in<br>&gt;         compiler like &quot;did you mean &#39;mapped&#39;?&quot;.<br>&gt;<br>&gt;<br>&gt;<br>&gt;             On Fri, Jun 17, 2016 at 3:24 AM, Brent Royal-Gordon via<br>&gt;             swift-evolution<br>&gt;             &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             &lt;mailto:swift-evolution at swift.org<br>&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;<br>&gt;                 &gt; The &#39;reduce()&#39; at its core take an array of element and<br>&gt;             reduce it to single element (could be of a different type) as<br>&gt;             such it cannot ever be mutating (if one really want it, one<br>&gt;             could reduce an array to the same array but it is not the goal<br>&gt;             of the function). For this one it sound to me nearly like<br>&gt;             asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or<br>&gt;             implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br>&gt;<br>&gt;                 `max`, `count`, and `sum` are all nouns—at least in the<br>&gt;             senses they are<br>&gt;                 meant in those calls—so they do not take the -ed/-ing<br>&gt;             suffixes to form<br>&gt;                 immutable variants. Instead, they would take the `form`<br>&gt;             prefix to form<br>&gt;                 mutable variants, if they had them.<br>&gt;<br>&gt;                 `map`, `filter`, and `reduce`—at least in the senses they<br>&gt;             must be<br>&gt;                 interpreted in for the names of those calls to make<br>&gt;             sense—are verbs,<br>&gt;                 and so they *would* normally take -ed/-ing suffixes.<br>&gt;             However, as<br>&gt;                 broadly-accepted terms of art, we have left them alone<br>&gt;             until now.<br>&gt;<br>&gt;                 --<br>&gt;                 Brent Royal-Gordon<br>&gt;                 Architechies<br>&gt;<br>&gt;                 _______________________________________________<br>&gt;                 swift-evolution mailing list<br>&gt;                 swift-evolution at swift.org<br>&gt;             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             &lt;mailto:swift-evolution at swift.org<br>&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>June 17, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;<br>&gt;  You could make the exact same arguments about `sin`.<br></p><p><br>– What sin(x) should do is unambiguous, unlike array.filter { ... }.<br>– There&#39;s very significant brevity issues here, e.g. hyperbolicArcTangent()<br>vs atanh().<br>– The relevant metric of the strength of a term of art would be for how<br>many users it already is a very much ingrained term (i.e. not how *long* it<br>has been around). For sin() this is the case for pretty much anyone who has<br>done high-school math. Conversely, map/filter/reduce will only be<br>significantly ingrained for experienced users of languages that are<br>functionally-centered enough to regularly use these, which is a much<br>smaller percentage (though not insignificant).<br></p><p>Let me turn your question around: What concrete benefits do we gain from<br>&gt; modifying terms which are extremely widely recognized? It is not<br>&gt; consistent, but is there any reason to believe that causes actual<br>&gt; confusion? If not, then why fix what isn&#39;t broken?<br></p><p><br>The benefits of renaming:<br>– It makes learning easier as it establishes a consistent way to read Swift<br>methods right from the start.<br>– It would help users in intuitively learning consistent naming for their<br>own methods, even if they haven&#39;t read the API guidelines.<br>– It allows defining e.g. an in-place filter variant.<br></p><p>I agree with your points on the problems with dropFirst/dropLast btw.<br></p><p>On Fri, Jun 17, 2016 at 4:05 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; On 17.06.2016 15:58, Patrick Pijnappel wrote:<br>&gt;<br>&gt;&gt;      I suggest to leave map+flatMap+reduce as-is as true terms-of-art<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Question still stands, what benefits do we gain from using the /exact/<br>&gt;&gt; terms that are not present in the slightly modified ones?<br>&gt;&gt;<br>&gt;<br>&gt; I don&#39;t know :-) I just see that many against renaming of<br>&gt; map/filter/reduce/etc and suggest a compromise : we leave map/reduce as-is,<br>&gt; but nothing else should be an exception to the naming rules.<br>&gt;<br>&gt;<br>&gt;&gt; On Fri, Jun 17, 2016 at 2:26 PM, Patrick Pijnappel<br>&gt;&gt; &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;         `map`, `filter`, and `reduce` are *the* higher-order functions.<br>&gt;&gt;         Almost anything with any kind of block/lambda/closure feature<br>&gt;&gt;         supports them (I&#39;m giving the side-eye to Foundation here), and<br>&gt;&gt; all<br>&gt;&gt;         three names are backed by *very* strong conventions<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         If `map`, `filter`, and `reduce` are not covered by the<br>&gt;&gt; term-of-art<br>&gt;&gt;         rule, we might as well rename it to the sin()-and-Int rule,<br>&gt;&gt; because<br>&gt;&gt;         I don&#39;t know what else it would cover. There is remarkable<br>&gt;&gt;         consistency in the naming of these operations across dozens of<br>&gt;&gt;         languages.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     The point the proposal raises is that the modified versions preserve<br>&gt;&gt;     the the terms of art in all the senses that matter (i.e. all the<br>&gt;&gt;     benefits like recognition etc. still apply).<br>&gt;&gt;<br>&gt;&gt;     On Fri, Jun 17, 2016 at 2:12 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;         On 17.06.2016 8:02, Patrick Pijnappel via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;                 -1, for the same reasons stated on the thread. These are<br>&gt;&gt;             neither<br>&gt;&gt;                 guaranteed to be mutating or non-mutating until you get to<br>&gt;&gt;             Collection.<br>&gt;&gt;                 Changing map() to mapped() would be lying to the developer<br>&gt;&gt;             some of the<br>&gt;&gt;                 time about the mutability of the interface.<br>&gt;&gt;                 -DW<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             Actually the -ed/-ing suffix is *not *intended to guarantee<br>&gt;&gt;             non-mutatability. It merely communicates whether it is a<br>&gt;&gt;             &quot;return-a-transformed-version-of-the-instance&quot;-type method as<br>&gt;&gt;             opposed to an<br>&gt;&gt;             in-place mutation. Clearly these are not in-place forms. Note<br>&gt;&gt;             that this is<br>&gt;&gt;             my interpretation of the intent of the guidelines (or what<br>&gt;&gt;             should be the<br>&gt;&gt;             intent) – if the core team agrees perhaps this deserves<br>&gt;&gt;             clarification in<br>&gt;&gt;             the document.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         Totally agree with you. I also understand this rule as separation<br>&gt;&gt;         of &quot;in-place&quot;/&quot;returns transformed version&quot;. I.e. the suffix<br>&gt;&gt; should<br>&gt;&gt;         say just &quot;result of this operation will be returned and should be<br>&gt;&gt;         assigned to other instance variable&quot;. Otherwise, as I understand,<br>&gt;&gt;         ANY method that will touch or iterate the Sequence *could* mutate<br>&gt;&gt;         it and so potentially we should have no -ing/-ed methods for<br>&gt;&gt;         Sequence - no?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 These functions are different than for example `sort`<br>&gt;&gt;             because there<br>&gt;&gt;                 can’t be a general mutating method of `map`. A variable of<br>&gt;&gt;             type `[A]`<br>&gt;&gt;                 can’t be mutated to hold a `[B]` which would be the result<br>&gt;&gt;             of a map<br>&gt;&gt;                 from `A -&gt; B`.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             There could definitely be an in-place variant of filter. While<br>&gt;&gt;             a /fully/<br>&gt;&gt;             general method would not be possible for the others, an user<br>&gt;&gt; might<br>&gt;&gt;             reasonable expect in-place variants of map/flatMap if T == U<br>&gt;&gt; as<br>&gt;&gt;             with e.g. {<br>&gt;&gt;             $0 * 2 } or Optionals, and of dropFirst/dropLast if<br>&gt;&gt; SubSequence<br>&gt;&gt;             == Sequence<br>&gt;&gt;             as with e.g. String.<br>&gt;&gt;<br>&gt;&gt;             Also note that the -ed/-ing rule should not be merely for<br>&gt;&gt;             ambiguous cases,<br>&gt;&gt;             it should tell the user that the main use of the method is<br>&gt;&gt;             returning a<br>&gt;&gt;             transformed version of the instance. Having this be a rule you<br>&gt;&gt;             can depend<br>&gt;&gt;             on is important.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         +1<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 -1 The Term of Art argument is very strong with these<br>&gt;&gt;             functions. I<br>&gt;&gt;                 prefer them as-is.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             What specific benefits do we obtain from using the /exact<br>&gt;&gt;             /terms of art vs.<br>&gt;&gt;             the very slightly modified versions proposed?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         Although I believe we can leave map&amp;reduce as-is, I can understand<br>&gt;&gt;         if we&#39;ll change them to mapped/reduced and will have consistent<br>&gt;&gt;         naming everywhere, don&#39;t think this will cause any confusion for<br>&gt;&gt;         one who will start to use them. In any case, we can add a hint in<br>&gt;&gt;         compiler like &quot;did you mean &#39;mapped&#39;?&quot;.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             On Fri, Jun 17, 2016 at 3:24 AM, Brent Royal-Gordon via<br>&gt;&gt;             swift-evolution<br>&gt;&gt;             &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;                 &gt; The &#39;reduce()&#39; at its core take an array of element and<br>&gt;&gt;             reduce it to single element (could be of a different type) as<br>&gt;&gt;             such it cannot ever be mutating (if one really want it, one<br>&gt;&gt;             could reduce an array to the same array but it is not the goal<br>&gt;&gt;             of the function). For this one it sound to me nearly like<br>&gt;&gt;             asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or<br>&gt;&gt;             implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br>&gt;&gt;<br>&gt;&gt;                 `max`, `count`, and `sum` are all nouns—at least in the<br>&gt;&gt;             senses they are<br>&gt;&gt;                 meant in those calls—so they do not take the -ed/-ing<br>&gt;&gt;             suffixes to form<br>&gt;&gt;                 immutable variants. Instead, they would take the `form`<br>&gt;&gt;             prefix to form<br>&gt;&gt;                 mutable variants, if they had them.<br>&gt;&gt;<br>&gt;&gt;                 `map`, `filter`, and `reduce`—at least in the senses they<br>&gt;&gt;             must be<br>&gt;&gt;                 interpreted in for the names of those calls to make<br>&gt;&gt;             sense—are verbs,<br>&gt;&gt;                 and so they *would* normally take -ed/-ing suffixes.<br>&gt;&gt;             However, as<br>&gt;&gt;                 broadly-accepted terms of art, we have left them alone<br>&gt;&gt;             until now.<br>&gt;&gt;<br>&gt;&gt;                 --<br>&gt;&gt;                 Brent Royal-Gordon<br>&gt;&gt;                 Architechies<br>&gt;&gt;<br>&gt;&gt;                 _______________________________________________<br>&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;                 swift-evolution at swift.org<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             _______________________________________________<br>&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/3ecd3590/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>June 17, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 for consistency.<br></p><p>—A<br></p><p>&gt; On Jun 17, 2016, at 12:04 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;  You could make the exact same arguments about `sin`.<br>&gt; <br>&gt; – What sin(x) should do is unambiguous, unlike array.filter { ... }.<br>&gt; – There&#39;s very significant brevity issues here, e.g. hyperbolicArcTangent() vs atanh().<br>&gt; – The relevant metric of the strength of a term of art would be for how many users it already is a very much ingrained term (i.e. not how long it has been around). For sin() this is the case for pretty much anyone who has done high-school math. Conversely, map/filter/reduce will only be significantly ingrained for experienced users of languages that are functionally-centered enough to regularly use these, which is a much smaller percentage (though not insignificant).<br>&gt; <br>&gt; Let me turn your question around: What concrete benefits do we gain from modifying terms which are extremely widely recognized? It is not consistent, but is there any reason to believe that causes actual confusion? If not, then why fix what isn&#39;t broken?<br>&gt;  <br>&gt; The benefits of renaming:<br>&gt; – It makes learning easier as it establishes a consistent way to read Swift methods right from the start.<br>&gt; – It would help users in intuitively learning consistent naming for their own methods, even if they haven&#39;t read the API guidelines.<br>&gt; – It allows defining e.g. an in-place filter variant.<br>&gt; <br>&gt; I agree with your points on the problems with dropFirst/dropLast btw.<br>&gt; <br>&gt; On Fri, Jun 17, 2016 at 4:05 PM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt; On 17.06.2016 15:58, Patrick Pijnappel wrote:<br>&gt;      I suggest to leave map+flatMap+reduce as-is as true terms-of-art<br>&gt; <br>&gt; <br>&gt; Question still stands, what benefits do we gain from using the /exact/<br>&gt; terms that are not present in the slightly modified ones?<br>&gt; <br>&gt; I don&#39;t know :-) I just see that many against renaming of map/filter/reduce/etc and suggest a compromise : we leave map/reduce as-is, but nothing else should be an exception to the naming rules.<br>&gt; <br>&gt; <br>&gt; On Fri, Jun 17, 2016 at 2:26 PM, Patrick Pijnappel<br>&gt; &lt;patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt; &lt;mailto:patrickpijnappel at gmail.com &lt;mailto:patrickpijnappel at gmail.com&gt;&gt;&gt; wrote:<br>&gt; <br>&gt;         `map`, `filter`, and `reduce` are *the* higher-order functions.<br>&gt;         Almost anything with any kind of block/lambda/closure feature<br>&gt;         supports them (I&#39;m giving the side-eye to Foundation here), and all<br>&gt;         three names are backed by *very* strong conventions<br>&gt; <br>&gt; <br>&gt; <br>&gt;         If `map`, `filter`, and `reduce` are not covered by the term-of-art<br>&gt;         rule, we might as well rename it to the sin()-and-Int rule, because<br>&gt;         I don&#39;t know what else it would cover. There is remarkable<br>&gt;         consistency in the naming of these operations across dozens of<br>&gt;         languages.<br>&gt; <br>&gt; <br>&gt;     The point the proposal raises is that the modified versions preserve<br>&gt;     the the terms of art in all the senses that matter (i.e. all the<br>&gt;     benefits like recognition etc. still apply).<br>&gt; <br>&gt;     On Fri, Jun 17, 2016 at 2:12 PM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;<br>&gt;     &lt;mailto:svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt;&gt; wrote:<br>&gt; <br>&gt;         On 17.06.2016 8:02, Patrick Pijnappel via swift-evolution wrote:<br>&gt; <br>&gt;                 -1, for the same reasons stated on the thread. These are<br>&gt;             neither<br>&gt;                 guaranteed to be mutating or non-mutating until you get to<br>&gt;             Collection.<br>&gt;                 Changing map() to mapped() would be lying to the developer<br>&gt;             some of the<br>&gt;                 time about the mutability of the interface.<br>&gt;                 -DW<br>&gt; <br>&gt; <br>&gt;             Actually the -ed/-ing suffix is *not *intended to guarantee<br>&gt;             non-mutatability. It merely communicates whether it is a<br>&gt;             &quot;return-a-transformed-version-of-the-instance&quot;-type method as<br>&gt;             opposed to an<br>&gt;             in-place mutation. Clearly these are not in-place forms. Note<br>&gt;             that this is<br>&gt;             my interpretation of the intent of the guidelines (or what<br>&gt;             should be the<br>&gt;             intent) – if the core team agrees perhaps this deserves<br>&gt;             clarification in<br>&gt;             the document.<br>&gt; <br>&gt; <br>&gt;         Totally agree with you. I also understand this rule as separation<br>&gt;         of &quot;in-place&quot;/&quot;returns transformed version&quot;. I.e. the suffix should<br>&gt;         say just &quot;result of this operation will be returned and should be<br>&gt;         assigned to other instance variable&quot;. Otherwise, as I understand,<br>&gt;         ANY method that will touch or iterate the Sequence *could* mutate<br>&gt;         it and so potentially we should have no -ing/-ed methods for<br>&gt;         Sequence - no?<br>&gt; <br>&gt; <br>&gt;                 These functions are different than for example `sort`<br>&gt;             because there<br>&gt;                 can’t be a general mutating method of `map`. A variable of<br>&gt;             type `[A]`<br>&gt;                 can’t be mutated to hold a `[B]` which would be the result<br>&gt;             of a map<br>&gt;                 from `A -&gt; B`.<br>&gt; <br>&gt; <br>&gt;             There could definitely be an in-place variant of filter. While<br>&gt;             a /fully/<br>&gt;             general method would not be possible for the others, an user might<br>&gt;             reasonable expect in-place variants of map/flatMap if T == U as<br>&gt;             with e.g. {<br>&gt;             $0 * 2 } or Optionals, and of dropFirst/dropLast if SubSequence<br>&gt;             == Sequence<br>&gt;             as with e.g. String.<br>&gt; <br>&gt;             Also note that the -ed/-ing rule should not be merely for<br>&gt;             ambiguous cases,<br>&gt;             it should tell the user that the main use of the method is<br>&gt;             returning a<br>&gt;             transformed version of the instance. Having this be a rule you<br>&gt;             can depend<br>&gt;             on is important.<br>&gt; <br>&gt; <br>&gt;         +1<br>&gt; <br>&gt; <br>&gt;                 -1 The Term of Art argument is very strong with these<br>&gt;             functions. I<br>&gt;                 prefer them as-is.<br>&gt; <br>&gt; <br>&gt;             What specific benefits do we obtain from using the /exact<br>&gt;             /terms of art vs.<br>&gt;             the very slightly modified versions proposed?<br>&gt; <br>&gt; <br>&gt;         Although I believe we can leave map&amp;reduce as-is, I can understand<br>&gt;         if we&#39;ll change them to mapped/reduced and will have consistent<br>&gt;         naming everywhere, don&#39;t think this will cause any confusion for<br>&gt;         one who will start to use them. In any case, we can add a hint in<br>&gt;         compiler like &quot;did you mean &#39;mapped&#39;?&quot;.<br>&gt; <br>&gt; <br>&gt; <br>&gt;             On Fri, Jun 17, 2016 at 3:24 AM, Brent Royal-Gordon via<br>&gt;             swift-evolution<br>&gt;             &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;             &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; <br>&gt;             &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;&gt; wrote:<br>&gt; <br>&gt;                 &gt; The &#39;reduce()&#39; at its core take an array of element and<br>&gt;             reduce it to single element (could be of a different type) as<br>&gt;             such it cannot ever be mutating (if one really want it, one<br>&gt;             could reduce an array to the same array but it is not the goal<br>&gt;             of the function). For this one it sound to me nearly like<br>&gt;             asking to rename &#39;max()&#39; to &#39;maxed()&#39;, &#39;count&#39; to &#39;counted&#39; or<br>&gt;             implement a &#39;summed()&#39; instead of a &#39;sum()&#39; for [Int].<br>&gt; <br>&gt;                 `max`, `count`, and `sum` are all nouns—at least in the<br>&gt;             senses they are<br>&gt;                 meant in those calls—so they do not take the -ed/-ing<br>&gt;             suffixes to form<br>&gt;                 immutable variants. Instead, they would take the `form`<br>&gt;             prefix to form<br>&gt;                 mutable variants, if they had them.<br>&gt; <br>&gt;                 `map`, `filter`, and `reduce`—at least in the senses they<br>&gt;             must be<br>&gt;                 interpreted in for the names of those calls to make<br>&gt;             sense—are verbs,<br>&gt;                 and so they *would* normally take -ed/-ing suffixes.<br>&gt;             However, as<br>&gt;                 broadly-accepted terms of art, we have left them alone<br>&gt;             until now.<br>&gt; <br>&gt;                 --<br>&gt;                 Brent Royal-Gordon<br>&gt;                 Architechies<br>&gt; <br>&gt;                 _______________________________________________<br>&gt;                 swift-evolution mailing list<br>&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;             &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/e285bb21/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 17, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; – What sin(x) should do is unambiguous, unlike array.filter { ... }.<br></p><p>A decent argument label, like `including` or even `to`, would fix the name `filter`. And as I said, if we feel `filter` is unsalvageable, the alternate Smalltalk-lineage `select` is clearer.<br></p><p>&gt; – There&#39;s very significant brevity issues here, e.g. hyperbolicArcTangent() vs atanh().<br></p><p>Sure, but `mappingAndFlattening(to:)` would have brevity issues as well. (You didn&#39;t think the API Guidelines merely meant &quot;add -ed or -ing to everything&quot;, did you?)<br></p><p>&gt; – The relevant metric of the strength of a term of art would be for how many users it already is a very much ingrained term (i.e. not how long it has been around). For sin() this is the case for pretty much anyone who has done high-school math. Conversely, map/filter/reduce will only be significantly ingrained for experienced users of languages that are functionally-centered enough to regularly use these, which is a much smaller percentage (though not insignificant).<br></p><p>I think &quot;languages that are functionally-centered enough to regularly use these&quot; makes this set of languages sound rather smaller than it really is. The languages with C in their names—C, C++, Objective-C, and C#—are almost the only ones in modern use which *don&#39;t* include higher-order functions. Few people would regard Perl, Javascript, Java, Python, or Ruby as &quot;functional&quot; languages, but all of them support `map`. If you look at RedMonk&#39;s list of 21 popular languages &lt;http://fossbytes.com/21-top-programming-languages-on-github-and-stack-overflowjanuary-2016/&gt;:<br></p><p>* 1 (CSS) has no real concept of lists or list operations.<br>* 2 (shell and C) do not have closures.<br>* 1 (Go) could support `map`, but K&amp;R still think it&#39;s 1973.<br>* 1 (Objective-C) could support `map`, but...well, if the Foundation guys want to tell us why they don&#39;t, they know where to find us.<br>* 16 have a version of `map`:<br>	* 1 (Matlab) has vectorization features which act like an implicit `map`.<br>	* 2 (C# and Visual Basic) have a `select` operation from LINQ<br>	* 3 (C++, R, and Groovy) have other names for `map`<br>	* 10 (Javascript, Java, PHP, Python, Ruby, Perl, Scala, Go, Haskell, Swift, and Clojure) call it `map`.<br></p><p>Of 16 languages with `map`, Scala, Haskell, Clojure, and maybe R and Matlab would typically be considered functional, and all of those are in the bottom half of the list. The other 11 languages with a version of `map` are all mainstream multi-paradigm languages of the sort people coming to Swift might be familiar with.<br></p><p>In short: Higher-order functions are not a specialized feature that only the functional eggheads use. Outside of a few small pockets—one of which is native Apple apps—they are a pervasive feature of modern programming environments. They are the rule, not the exception.<br></p><p>&gt;&gt; Let me turn your question around: What concrete benefits do we gain from modifying terms which are extremely widely recognized? It is not consistent, but is there any reason to believe that causes actual confusion? If not, then why fix what isn&#39;t broken?<br>&gt;  <br>&gt; The benefits of renaming:<br>&gt; – It makes learning easier as it establishes a consistent way to read Swift methods right from the start.<br>&gt; – It would help users in intuitively learning consistent naming for their own methods, even if they haven&#39;t read the API guidelines.<br></p><p>These are basically two ways of stating the same point, which again, is not considered strong enough to overcome strong terms-of-art in other areas.<br></p><p>&gt; – It allows defining e.g. an in-place filter variant.<br></p><p>Several people have mentioned this could be done, but has anyone actually *asked* for it? And if it did exist, wouldn&#39;t it be better to offer this functionality as a `remove(where:)` function, matching existing methods like `first(where:)` and `index(where:)`?<br></p><p>(Actually, if we&#39;re going to rename `filter`, `where` might not be a terrible name. It&#39;s valid after a dot, but not without one.)<br></p><p>Even if we *do* want to offer it for `filter`, the others are not good candidates for mutating variants. Mutating `map` could only be offered on certain sub-protocols of `Collection`, could not be guaranteed to be in-place (and probably wouldn&#39;t be for most collection types), and would have a severely restricted set of use cases compared to its nonmutating equivalent. Mutating `flatMap` would suffer even more from these limitations, making it desperately tricky to implement. And `reduce` simply couldn&#39;t be offered at all.<br></p><p>&gt; I agree with your points on the problems with dropFirst/dropLast btw.<br></p><p>Incidentally, I just noticed that `removeFirst(_:)`/`removeLast(_:)` ought to get this treatment too.<br></p><p>I&#39;ll see if I can write up at least a sketch of what I&#39;d like to do to these methods in the next few days, but I&#39;m busy today preparing for the local (Orange County, CA) Apple community&#39;s post-WWDC event. Need to come up with something to talk about. :^)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>June 18, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;<br>&gt; Sure, but `mappingAndFlattening(to:)` would have brevity issues as well.<br></p><p><br>My point was that if you want to transform sin() -&gt; sine() you&#39;d be pretty<br>much forced to also do atanh() -&gt; hyperbolicArcTangent(). However the<br>proposed transformation is for flatMap() to flatMapped(), which doesn&#39;t<br>have any brevity issues and is still very close to the exact term of art.<br></p><p>Higher-order functions are not a specialized feature that only the<br>&gt; functional eggheads use. Outside of a few small pockets—one of which is<br>&gt; native Apple apps—they are a pervasive feature of modern programming<br>&gt; environments. They are the rule, not the exception.<br></p><p><br>They do have significant usage, but the term of art will not be an<br>&quot;ingrained term&quot; for any of the following:<br>– Users new to programming.<br>– Users from languages that do not have these functions, or include them<br>under a different name.<br>– Users from languages that do have these functions under these names, but<br>haven&#39;t used them so regularly as to become an ingrained term. Which I&#39;d<br>estimate is a large group: Personally I&#39;ve used most of the mainstream<br>languages on your list, some for a very long time, without using these<br>functions very much at all.<br></p><p>Nevertheless I&#39;m also definitely in favor of keeping *the terms of art as<br>stems (*i.e. not moving to different words altogether) so we retain 90% of<br>the benefits, but just slightly modifying them.<br></p><p><br>On Sat, Jun 18, 2016 at 4:13 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; – What sin(x) should do is unambiguous, unlike array.filter { ... }.<br>&gt;<br>&gt; A decent argument label, like `including` or even `to`, would fix the name<br>&gt; `filter`. And as I said, if we feel `filter` is unsalvageable, the<br>&gt; alternate Smalltalk-lineage `select` is clearer.<br>&gt;<br>&gt; &gt; – There&#39;s very significant brevity issues here, e.g.<br>&gt; hyperbolicArcTangent() vs atanh().<br>&gt;<br>&gt; Sure, but `mappingAndFlattening(to:)` would have brevity issues as well.<br>&gt; (You didn&#39;t think the API Guidelines merely meant &quot;add -ed or -ing to<br>&gt; everything&quot;, did you?)<br>&gt;<br>&gt; &gt; – The relevant metric of the strength of a term of art would be for how<br>&gt; many users it already is a very much ingrained term (i.e. not how long it<br>&gt; has been around). For sin() this is the case for pretty much anyone who has<br>&gt; done high-school math. Conversely, map/filter/reduce will only be<br>&gt; significantly ingrained for experienced users of languages that are<br>&gt; functionally-centered enough to regularly use these, which is a much<br>&gt; smaller percentage (though not insignificant).<br>&gt;<br>&gt; I think &quot;languages that are functionally-centered enough to regularly use<br>&gt; these&quot; makes this set of languages sound rather smaller than it really is.<br>&gt; The languages with C in their names—C, C++, Objective-C, and C#—are almost<br>&gt; the only ones in modern use which *don&#39;t* include higher-order functions.<br>&gt; Few people would regard Perl, Javascript, Java, Python, or Ruby as<br>&gt; &quot;functional&quot; languages, but all of them support `map`. If you look at<br>&gt; RedMonk&#39;s list of 21 popular languages &lt;<br>&gt; http://fossbytes.com/21-top-programming-languages-on-github-and-stack-overflowjanuary-2016/<br>&gt; &gt;:<br>&gt;<br>&gt; * 1 (CSS) has no real concept of lists or list operations.<br>&gt; * 2 (shell and C) do not have closures.<br>&gt; * 1 (Go) could support `map`, but K&amp;R still think it&#39;s 1973.<br>&gt; * 1 (Objective-C) could support `map`, but...well, if the Foundation guys<br>&gt; want to tell us why they don&#39;t, they know where to find us.<br>&gt; * 16 have a version of `map`:<br>&gt;         * 1 (Matlab) has vectorization features which act like an implicit<br>&gt; `map`.<br>&gt;         * 2 (C# and Visual Basic) have a `select` operation from LINQ<br>&gt;         * 3 (C++, R, and Groovy) have other names for `map`<br>&gt;         * 10 (Javascript, Java, PHP, Python, Ruby, Perl, Scala, Go,<br>&gt; Haskell, Swift, and Clojure) call it `map`.<br>&gt;<br>&gt; Of 16 languages with `map`, Scala, Haskell, Clojure, and maybe R and<br>&gt; Matlab would typically be considered functional, and all of those are in<br>&gt; the bottom half of the list. The other 11 languages with a version of `map`<br>&gt; are all mainstream multi-paradigm languages of the sort people coming to<br>&gt; Swift might be familiar with.<br>&gt;<br>&gt; In short: Higher-order functions are not a specialized feature that only<br>&gt; the functional eggheads use. Outside of a few small pockets—one of which is<br>&gt; native Apple apps—they are a pervasive feature of modern programming<br>&gt; environments. They are the rule, not the exception.<br>&gt;<br>&gt; &gt;&gt; Let me turn your question around: What concrete benefits do we gain<br>&gt; from modifying terms which are extremely widely recognized? It is not<br>&gt; consistent, but is there any reason to believe that causes actual<br>&gt; confusion? If not, then why fix what isn&#39;t broken?<br>&gt; &gt;<br>&gt; &gt; The benefits of renaming:<br>&gt; &gt; – It makes learning easier as it establishes a consistent way to read<br>&gt; Swift methods right from the start.<br>&gt; &gt; – It would help users in intuitively learning consistent naming for<br>&gt; their own methods, even if they haven&#39;t read the API guidelines.<br>&gt;<br>&gt; These are basically two ways of stating the same point, which again, is<br>&gt; not considered strong enough to overcome strong terms-of-art in other areas.<br>&gt;<br>&gt; &gt; – It allows defining e.g. an in-place filter variant.<br>&gt;<br>&gt; Several people have mentioned this could be done, but has anyone actually<br>&gt; *asked* for it? And if it did exist, wouldn&#39;t it be better to offer this<br>&gt; functionality as a `remove(where:)` function, matching existing methods<br>&gt; like `first(where:)` and `index(where:)`?<br>&gt;<br>&gt; (Actually, if we&#39;re going to rename `filter`, `where` might not be a<br>&gt; terrible name. It&#39;s valid after a dot, but not without one.)<br>&gt;<br>&gt; Even if we *do* want to offer it for `filter`, the others are not good<br>&gt; candidates for mutating variants. Mutating `map` could only be offered on<br>&gt; certain sub-protocols of `Collection`, could not be guaranteed to be<br>&gt; in-place (and probably wouldn&#39;t be for most collection types), and would<br>&gt; have a severely restricted set of use cases compared to its nonmutating<br>&gt; equivalent. Mutating `flatMap` would suffer even more from these<br>&gt; limitations, making it desperately tricky to implement. And `reduce` simply<br>&gt; couldn&#39;t be offered at all.<br>&gt;<br>&gt; &gt; I agree with your points on the problems with dropFirst/dropLast btw.<br>&gt;<br>&gt; Incidentally, I just noticed that `removeFirst(_:)`/`removeLast(_:)` ought<br>&gt; to get this treatment too.<br>&gt;<br>&gt; I&#39;ll see if I can write up at least a sketch of what I&#39;d like to do to<br>&gt; these methods in the next few days, but I&#39;m busy today preparing for the<br>&gt; local (Orange County, CA) Apple community&#39;s post-WWDC event. Need to come<br>&gt; up with something to talk about. :^)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160618/27f54255/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Apply -ed/-ing rule to core functional methods (e.g. filter =&gt; filtered)</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 17, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 for naming consistency. Opposite to many other modern languages where <br>these methods/funcs exists, Swift choose another way(inverted) to name <br>func/methods - &quot;normal&quot; name for mutating methods and with -ing/-ed suffix <br>for non-mutating.<br></p><p>But as a compromise, I suggest to leave map+flatMap+reduce as-is as true <br>terms-of-art, and exclude all other names from this group of exceptions. To <br>have strong and clear naming rules you can rely on. Opinions? Probably this <br>could be a solution to this naming issue.<br></p><p>On 16.06.2016 22:51, Patrick Pijnappel via swift-evolution wrote:<br>&gt; Due to considerably support on this thread<br>&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;,<br>&gt; a draft proposal to revisit the core functional method exceptions to the<br>&gt; -ed/-ing rule.<br>&gt;<br>&gt; Online<br>&gt; version: https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md<br>&gt;<br>&gt;<br>&gt;   Apply -ed/-ing rule to core functional methods<br>&gt;<br>&gt;   * Proposal: SE-NNNN<br>&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/NNNN-functional-methods-ed-ing.md&gt;<br>&gt;   * Author: Patrick Pijnappel &lt;https://github.com/PatrickPijnappel&gt;<br>&gt;   * Status: Awaiting review<br>&gt;   * Review manager: TBD<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#introduction&gt;Introduction<br>&gt;<br>&gt; The Swift API Guidelines standardizes non-mutating method forms on verbs<br>&gt; ending in -ed/-ing (or nouns). However, a few non-mutating forms have been<br>&gt; kept as &quot;Terms of<br>&gt; Art&quot;: |map|, |flatMap|, |filter|, |reduce|, |dropFirst| and |dropLast|.<br>&gt; This proposal proposes to bring these in line with all other non-mutating<br>&gt; forms (e.g. |filter =&gt; filtered|).<br>&gt;<br>&gt; Swift-evolution threads: Source<br>&gt; &lt;http://news.gmane.org/find-root.php?group=gmane.comp.lang.swift.evolution&amp;article=20783&gt;<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#motivation&gt;Motivation<br>&gt;<br>&gt; These method have been kept to preserve the terms of art. Generally, this<br>&gt; can have significant benefits:<br>&gt;<br>&gt;   * Anyone familiar with the term will immediately understand it, and use<br>&gt;     their assumptions about how it works.<br>&gt;   * Users learning the term from Swift can use their knowledge when<br>&gt;     encountering it elsewhere.<br>&gt;   * Experienced users will be able to use the mental pattern matching<br>&gt;     they&#39;ve built-up for quickly recognizing common programming patterns.<br>&gt;<br>&gt; However, basically all of the benefits of using a term of art still apply<br>&gt; to the modified forms: – For recognition, the modified forms are still very<br>&gt; close to the traditional terms of art. So both coming to and from Swift<br>&gt; you&#39;ll be able to use your knowledge pretty much unaffected.<br>&gt;<br>&gt;   * If the user looks for e.g. |filter| they are pretty much guaranteed to<br>&gt;     quickly find the correct form, be it through code-completion, google or<br>&gt;     a fix-it.<br>&gt;   * There isn&#39;t really any violation of assumptions that might cause<br>&gt;     problems in this case.<br>&gt;   * Any mental pattern matching will likely transfer quickly due to the<br>&gt;     minimal difference.<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#proposed-solution&gt;Proposed<br>&gt;     solution<br>&gt;<br>&gt; The proposed solution modifies the method verbs to their -ed/-ing forms<br>&gt; (preferring the former).<br>&gt;<br>&gt; It removes the last clear exceptions to the -ed/-ing rule from the standard<br>&gt; library, which previously were exactly the opposite of what one would<br>&gt; expect based on the API guidelines (and the rest of the language).<br>&gt;<br>&gt; It also aids users in learning to pattern match on the -ed/-ing rule and<br>&gt; internalizing the API guidelines, since now all methods are named this way<br>&gt; – instead of the most commonly used methods defying the normal pattern.<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#detailed-design&gt;Detailed<br>&gt;     design<br>&gt;<br>&gt; The change would rename the following method families:<br>&gt;<br>&gt; |map =&gt; mapped flatMap =&gt; flatMapped filter =&gt; filtered reduce =&gt; reduced<br>&gt; dropFirst =&gt; droppingFirst dropLast =&gt; droppingLast |<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#impact-on-existing-code&gt;Impact<br>&gt;     on existing code<br>&gt;<br>&gt; The Swift migrator and fix-its would be provided for the change.<br>&gt;<br>&gt;<br>&gt;     &lt;https://github.com/PatrickPijnappel/swift-evolution/blob/functional-methods-ed-ing/proposals/XXXX-functional-methods-ed-ing.md#alternatives-considered&gt;Alternatives<br>&gt;     considered<br>&gt;<br>&gt;   * Alternatively -ing suffixes could be used<br>&gt;     for |map|/|flatMap|/|filter|/|reduce|. However, these are normally<br>&gt;     reserved for when -ed doesn&#39;t really work (e.g. droppedFirst).<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
