<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 18, 2016 at 02:00:00pm</p></header><div class="content"><p>on Thu Apr 14 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Apr 14, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, you can&#39;t, at least not usefully.  An Index that&#39;s at the end of one<br>&gt;&gt;&gt;&gt; collection is in the middle of another, or with a suitably-modified version<br>&gt;&gt;&gt;&gt; of the same collection.  <br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, in certain concrete scenarios it’s possible for one collection’s<br>&gt;&gt;&gt; indices to have such relationships to some other collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But, what of it? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a generic context you can’t assume this; <br>&gt;&gt; <br>&gt;&gt; That&#39;s incorrect.  A slice&#39;s indices are *documented* as having a<br>&gt;&gt; particular relationship to those of the thing it was sliced from.  This<br>&gt;&gt; applies everywhere.  A dictionary&#39;s keys and values use the same indices<br>&gt;&gt; as the dictionary itself, and have a correspondence.<br>&gt;<br>&gt; You’re right, of course; I rarely use slices and completely overlooked<br>&gt; them.<br>&gt;<br>&gt; I also phrased it badly, b/c what I was trying to express is that code<br>&gt; like the below is (I think?) unlikely to work generically:<br>&gt;<br>&gt;   extension Collection where Element:Equatable {<br>&gt;<br>&gt;      // plz don’t do this<br>&gt;      func hasValueMismatch(with other: Self, at index: Index) -&gt; Bool {<br>&gt;        return self[index] != other[index]<br>&gt;      }<br>&gt;<br>&gt;      // plz don’t do this either<br>&gt;     func hasValueMismatch&lt;K:Collection where K.Index == Index, K.Element == Self.Element&gt;(with other: K, at index: Index) -&gt; Bool { <br>&gt;       return self[index] != other[index]<br>&gt;     }<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; …(you would’t write the above anyway, but it illustrates the kind of<br>&gt; &quot;generic context&quot; I had in mind when I wrote it).<br></p><p>Yes, I understand that you weren&#39;t thinking of the cases where indices<br>from different collections *do* have a relationship in a generic context<br>:-).<br></p><p>&gt;&gt;&gt; in a concrete context you naturally have more information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Slices would become problematic, I’ll grant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var x = [1, 2]<br>&gt;&gt;&gt;&gt; let i = x.index(1, stepsFrom: x.startIndex)<br>&gt;&gt;&gt;&gt; x.removeLast()<br>&gt;&gt;&gt;&gt; x[i]           // fatal error: Index out of range<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indices can become invalid; this imposes preconditions. I don’t get<br>&gt;&gt;&gt; it.<br>&gt;&gt; <br>&gt;&gt; My point is that whether i is at the end or not cannot be encoded in i.<br>&gt;<br>&gt; I see the miscommunication, now. Of course you can’t encode that.<br></p><p>How can this be a miscommunication?  Your examples from earlier in the<br>thread include this:<br></p><p>  enum SaferIndex&lt;T:Comparable&gt; {<br>  case Position(T)<br>  case End<br>  }<br></p><p>which clearly does try to encode that information in the index.<br></p><p>&gt; I’ve put a couple examples down below as a last effort at<br>&gt; communicating what I’m getting at it.<br>&gt;<br>&gt;&gt;&gt;&gt; The converse is also true: subscripting on a collection&#39;s endIndex is<br>&gt;&gt;&gt;&gt; sometimes just fine, even with no mutation in sight.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = (0..&lt;10).reversed()<br>&gt;&gt;&gt;&gt; print(Array(a))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let b = a.prefix(9)<br>&gt;&gt;&gt;&gt; print(Array(b))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1]”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print(a[b.endIndex]) // “0” (correct, supported behavior)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe we are back to “subscripting one collection with *another*<br>&gt;&gt;&gt; collection&#39;s `endIndex`, no?<br>&gt;&gt; <br>&gt;&gt; Totally legit, as mentioned above.  a.prefix(9) returns a slice of a.<br>&gt;&gt; <br>&gt;&gt;&gt; Are there any circumstances where a collection *can* be<br>&gt;&gt;&gt; usefully-subscripted with its *own* `endIndex`?<br>&gt;&gt; <br>&gt;&gt; var a = [1]<br>&gt;&gt; let i = a.endIndex<br>&gt;&gt; a.append(2)<br>&gt;&gt; print(a[i]) // “2”<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; b[b.endIndex]        // As a matter of QOI: fatal error: out of bounds: index &gt;= endIndex<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would’ve been awkward to do this under the previous status quo—e.g. even for<br>&gt;&gt;&gt;&gt;&gt; arrays your indices would have to have a back-reference to get the count, and<br>&gt;&gt;&gt;&gt;&gt; thus couldn’t be plain integers—but the collection will now always be present to<br>&gt;&gt;&gt;&gt;&gt; provide such info.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cons:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - more overhead than “bare” indices<br>&gt;&gt;&gt;&gt;&gt; - doesn’t address invalidation (but what does, really?)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Pros:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - easier in some ways to handle things like e.g 0…Int.max<br>&gt;&gt;&gt;&gt;&gt; - the endIndex equivalent *never* invalidates <br>&gt;&gt;&gt;&gt;&gt; - compile-time help for end-index checking<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Overall this *would* bring the treatment of indices closer to that for `?`—e.g.,<br>&gt;&gt;&gt;&gt;&gt; redefine the core type to omit the `nil`-like value, <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, but that&#39;s the opposite of what `?` is doing: it *adds* a nil<br>&gt;&gt;&gt;&gt; value.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …I must have been unclear.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Step 1: Define T* = { &quot;all memory addresses” (nil included) }<br>&gt;&gt;&gt; Step 2: Define T = T* \ { nil } (e.g. &quot;non-null pointers&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …is what I was trying to summarize via “redefine the core type to omit<br>&gt;&gt;&gt; the `nil`-like value” (which is the important part here).<br>&gt;&gt; <br>&gt;&gt; Sorry, that&#39;s still unclear to me.  I just don&#39;t see what you&#39;re getting<br>&gt;&gt; at.<br>&gt;&gt; <br>&gt;&gt;&gt; Anyways, having `endIndex` directly inhabit the same type as the<br>&gt;&gt;&gt; “good” indices has some pros and some cons; it’s not an IMHO one-sided<br>&gt;&gt;&gt; situation as with `nil`.<br>&gt;&gt; <br>&gt;&gt; Maybe, but my point is that many things in the current model are<br>&gt;&gt; incompatible with the other arrangement.  If you wanted to change the<br>&gt;&gt; arrangement, you&#39;d need to re-think the current model from the ground<br>&gt;&gt; up, including index invalidation, how algorithms interact, the<br>&gt;&gt; relationship of slices to the thing they&#39;re sliced from, etc...<br>&gt;&gt; <br>&gt;&gt; So what you&#39;re suggesting is an interesting hypothesis, but to me it&#39;s<br>&gt;&gt; not by any means obviously workable.<br>&gt;<br>&gt; You’re completely right about slices. I’ll provide a couple concrete examples before addressing the rest.<br>&gt;<br>&gt; Here are three collection-combinators (or adapters I think you’d call them):<br>&gt;<br>&gt;   // Collection with elements of A, then elements of B.<br>&gt;   struct ChainCollection&lt;A:Collection,B:Collection&gt; : Collection {<br>&gt;     let a: A; let b: B;<br>&gt;   }<br>&gt;<br>&gt;   // Collection with elements `(a,b)` for each pair in the cartesian product of `A` and `B`.<br>&gt;   struct ProductCollection&lt;A:Collection,B:Collection&gt; : Collection {<br>&gt;     let a: A; let b: B;<br>&gt;   }<br>&gt;<br>&gt;   // Collection with adjacent elements from A<br>&gt;   struct AdjacentElementCollection&lt;A:Collection&gt; : Collection { <br>&gt;     let a: A<br>&gt;   }<br>&gt;<br>&gt; …each of which I’ve declared `: Collection` but each which will still need some suitable `Index` implementation.<br>&gt;<br>&gt; Here’s one way to write these indices (henceforth, the V1 indices):<br>&gt;<br>&gt;   // `endIndex` will be .InB(b.endIndex)<br>&gt;   enum ChainCollectionIndex&lt;A:Collection,B:Collection&gt; {<br>&gt;     // Precondition: the index isn’t `a.endIndex`.<br>&gt;     case InA(A.Index)<br>&gt;     case InB(B.Index) <br>&gt;   }<br>&gt;<br>&gt;   // `endIndex` will have both `.aIndex` and `.bIndex` equal to their “source”&#39;s `endIndex`<br>&gt;   struct ProductCollectionIndex&lt;A:Collection,B:Collection&gt; {<br>&gt;     let aIndex: A.Index<br>&gt;     let bIndex: B.Index<br>&gt;   }<br>&gt;<br>&gt;   // `endIndex` will be both of these set to `a.endIndex`<br>&gt;   // - all other situations expect `upper` is `lower`’s successor, and both != `endIndex`<br>&gt;   struct AdjacentElementCollectionIndex&lt;A:Collection&gt; {<br>&gt;     let lower: A.Index<br>&gt;     let upper: A.Index<br>&gt;   }<br>&gt;<br>&gt; …(I trust the index-manipulation boilerplate is easy to fill-in).<br>&gt;<br>&gt; There’s absolutely nothing wrong with the above! Each of these types<br>&gt; has the capability to represent the “good” indices, and also has a<br>&gt; reasonable way to represent `endIndex` values.<br>&gt;<br>&gt; But, they could also be written like so (henceforth, the V2 indices):<br>&gt;<br>&gt;   enum ChainCollectionIndex&lt;A:Collection,B:Collection&gt; {<br>&gt;     // Precondition: the index isn’t `a.endIndex`.<br>&gt;     case InA(A.Index)<br>&gt;     // Precondition: the index isn’t `b.endIndex`.<br>&gt;     case InB(B.Index)<br>&gt;     // `endIndex` sentinel<br>&gt;     case End<br>&gt;   }<br>&gt;<br>&gt;   enum ProductCollectionIndex&lt;A:Collection,B:Collection&gt; {<br>&gt;     // Precondition: neither index is the source collection’s `endIndex`<br>&gt;     case Item(A.Index, B.Index)<br>&gt;     // `endIndex` sentinel<br>&gt;     case End<br>&gt;   }<br>&gt;<br>&gt;   enum AdjacentElementCollectionIndex&lt;A:Collection&gt; {<br>&gt;     // Precondition: `upper` is `lower`’s successor, *both* are != `a.endIndex`<br>&gt;     case Adjacency(lower: A.Index, upper: A.Index)<br>&gt;     // `endIndex` sentinel<br>&gt;     case End<br>&gt;   }<br>&gt;<br>&gt; …each of which is essentially the V1 version, except now with a<br>&gt; dedicated `endIndex` value tacked-on. <br></p><p>Again you&#39;re encoding “I&#39;m at the end” in the index, which as we&#39;ve<br>agreed does not work.<br></p><p>&gt; Tacking on the dedicated `endIndex` isn’t necessary, but at least for<br>&gt; me taking V2-style approaches has been very advantageous.<br>&gt;<br>&gt; Most of the advantage has been from being able to enforce stricter<br>&gt; invariants on the non-endIndex indices, <br></p><p>I don&#39;t see how anything is lost in terms of the ability to enforce<br>invariants, if the collection handles index movement.<br></p><p>&gt; which generally makes the code simpler and also easier to reason<br>&gt; about; I’m also fortunate in that I’m not working on the standard<br>&gt; library, and thus can choose how heavily to weight “time to correct<br>&gt; implementation” vis-a-vis “proximity to maximum possible efficiency”.<br>&gt;<br>&gt; The above indices are drawn from what are admittedly simple<br>&gt; combinators/adaptors, but they feel like representative examples for<br>&gt; me; even for fancier, actually-custom things it’s almost always been<br>&gt; much more natural to go with a V2-style index (and sometimes no<br>&gt; natural V1-style approach even exists).<br>&gt;<br>&gt; I’ve done a fair amount of experimenting with the model implied<br>&gt; above—moving `endIndex` into a dedicated sentinel, etc.—and although<br>&gt; it’s pretty easy overall to translate back and forth between the two<br>&gt; models, the “alternative” approach *at best* comes out a wash...at<br>&gt; best.<br>&gt;<br>&gt; For the most part, invalidation is about the same between the two<br>&gt; models for all non-end-index—for such indices, the same mutations<br>&gt; invalidate the same indices under either approach.<br>&gt;<br>&gt; What *is* different between the two is that a cached `endIndex` will never become valid due to mutation, e.g. this won’t happen:<br>&gt;<br>&gt;   // status quo:<br>&gt;   var items = [“a”, “b”]<br>&gt;   let cachedEndIndex = items.endIndex // this is just `2`<br>&gt;   items.append[“c”]<br>&gt;   items[cachedEndIndex] // returns “c&quot;<br>&gt;<br>&gt;   // dedicated `endIndex`:<br>&gt;   var items = [“a”, “b”]<br>&gt;   let cachedEndIndex = items.endIndex<br>&gt;   items.append[“c”]<br>&gt;   items[cachedEndIndex] // goes boom, b/c `cachedEndIndex` is still the `endIndex`<br></p><p>So one special index value “moves automatically as the collection changes” and<br>all others do not.  Doesn&#39;t seem like an advantage to me.  It&#39;s easy to<br>imagine having subtle bugs due to this difference. <br></p><p>&gt; …and things like this wouldn&#39;t work the same way:<br>&gt;<br>&gt;   // status quo:<br>&gt;   var items = [“a”, “b”]<br>&gt;   let cachedEndIndex = items.endIndex // this is just `2`<br>&gt;   items.insert(“c”, at:  cachedEndIndex) // [“a”, “b”, “c”]<br>&gt;   items.insert(“d”, at:  cachedEndIndex) // [“a”, “b”, “d”, “c”]<br>&gt;<br>&gt;   // dedicated `endIndex`<br>&gt;   var items = [“a”, “b”]<br>&gt;   let cachedEndIndex = items.endIndex // this is `.End`<br>&gt;   items.insert(“c”, at:  cachedEndIndex) // [“a”, “b”, “c”]<br>&gt;   items.insert(“d”, at:  cachedEndIndex) // [“a”, “b”, “c&quot;, “d”]<br>&gt;<br>&gt; …because the end-index sentinel would *always* refer to the logical<br>&gt; end of the collection.<br></p><p>Yeah, that difference seems like an active problem to me.  <br></p><p>&gt; Slices would truly be problematic here. For the rest, it’s hard to see<br>&gt; insurmountable difficulties—especially given the ease of converting<br>&gt; between the two approaches, given access to the collection—but I’d<br>&gt; expect it to be far clunkier and a tad slower.<br></p><p>Not sure what you&#39;re saying would be clunkier.  I can tell you that<br>having a special-case index state for “past the end” is a great way to<br>introduce both clunky special-case code to manage the differences in<br>representation and behavior, and associated inefficiency.<br></p><p>&gt;&gt;&gt; On the one hand, in my own experience so far, it’s definitely been the<br>&gt;&gt;&gt; case that most custom collections I’d done have had indices that’re<br>&gt;&gt;&gt; effectively the `SaferIndex` above; it’s been rather rare that there’s<br>&gt;&gt;&gt; been a natural “1 past the rest” value to use of the same type as is<br>&gt;&gt;&gt; used to describe the position of a “good” index.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Seriously, just because Swift has Optionals and they&#39;re useful for<br>&gt;&gt;&gt;&gt; safety in some scenarios (compared with allowing everything to be<br>&gt;&gt;&gt;&gt; nullable) does not mean that it&#39;s going to be “Swiftier” to apply a<br>&gt;&gt;&gt;&gt; similar pattern everywhere.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; use an enum to reintroduce that value when necessary—than to `!`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think the above is an *improvement* over the proposal, but it’s a route<br>&gt;&gt;&gt;&gt;&gt; that could have been taken.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe it would be hard to make such a design work at all, and if you<br>&gt;&gt;&gt;&gt; could make it work I think you&#39;d end up with exactly the problem this<br>&gt;&gt;&gt;&gt; proposal aims to solve: references inside indices.  So, I don&#39;t think<br>&gt;&gt;&gt;&gt; it&#39;s even a possibility, really.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can’t say I see the impossibility. I definitely have experienced the<br>&gt;&gt;&gt; clunkiness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is getting too involved for a hypothetical I was explaining, but<br>&gt;&gt;&gt; not advocating.<br>&gt;&gt; <br>&gt;&gt; I will happily agree to drop this topic :-)<br>&gt;<br>&gt; It’s dropped, now; I only felt the need to reply one more time b/c I<br>&gt; could tell I’d previously failed to communicate clearly-enough.<br></p><p>Agh.  I had forgotten my offer to drop this and now I&#39;ve written this<br>whole reply, which might have some value so sending.  But I promise I<br>won&#39;t answer again!<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; This proposal and the new design is a good design!<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;<br>&gt; I really do mean it! Just look at those examples and think of how many<br>&gt; redundant back-references they used to need...<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;       To help illustrate the claim, here’s a strawman “safe” API—for<br>&gt;&gt;&gt;&gt;&gt;       illustration<br>&gt;&gt;&gt;&gt;&gt;       only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   I think there&#39;s a prevalent misunderstanding (IOW, I don&#39;t mean to<br>&gt;&gt;&gt;&gt;&gt;   single out this post or this poster) about what “safe” means in Swift<br>&gt;&gt;&gt;&gt;&gt;   and what the features of a Swifty API are and should be. This<br>&gt;&gt;&gt;&gt;&gt;   is a big topic worthy of much more time than I can devote here, but<br>&gt;&gt;&gt;&gt;&gt;   here&#39;s a thought to start with:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   A Swifty API helps you reason effectively about the correctness of your<br>&gt;&gt;&gt;&gt;&gt;   code, and in part that means we provide enough preconditions on<br>&gt;&gt;&gt;&gt;&gt;   arguments to avoid complicating result types, and code to handle<br>&gt;&gt;&gt;&gt;&gt;   results, with optional-ness.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   -- <br>&gt;&gt;&gt;&gt;&gt;   Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;   swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;   swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 18, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 18, 2016, at 4:52 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br></p><p>&gt; <br>&gt; Again you&#39;re encoding “I&#39;m at the end” in the index, which as we&#39;ve<br>&gt; agreed does not work.<br></p><p>If nothing else, it works—and seems natural—for linked lists. <br></p><p>Sorry; if I’d remembered this elementary example sooner I would’ve lead with it.<br></p><p>I’ll point it out then be completely done.<br></p><p>&gt; So one special index value “moves automatically as the collection changes” and<br>&gt; all others do not.  Doesn&#39;t seem like an advantage to me.  It&#39;s easy to<br>&gt; imagine having subtle bugs due to this difference. <br></p><p>Again, if you implement a textbook linked-list under collections-move-indices, the natural representation for the indices is arguably `ListNode&lt;T&gt;?` (or whatever), wherein you use `nil` for the end index. <br></p><p>As a consequence, at least in this scenario you wind up with the semantics/behavior sketched previously for `endIndex`. <br></p><p>No further reply is needed; thank you for sharing your insight.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/277702ab/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
