<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 31, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 in general, though I do wonder how this change will affect generic code. For example, if I have a function that returns a tuple, and another function that takes an argument list matching the same tuple type, can I still use generic functions like map() to call the second function with the tuple from the first? I&#39;m hoping the answer is &quot;yes&quot;, because the type of a function doesn&#39;t distinguish between functions that take multiple arguments vs functions that take a single argument of tuple type and so passing functions around as first-class values should be fine. Although I imagine this change will still prevent me from writing a closure like { funcOfTwoArgs($0) } which is unfortunate, but would be solved by a subsequent proposal to add an explicit splat operator.<br></p><p>-Kevin Ballard<br></p><p>&gt; On Jan 26, 2016, at 10:23 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For discussion: comments appreciated!<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Remove implicit tuple splat behavior from function applications<br>&gt; Proposal: SE-TBD<br>&gt; Author(s): Chris Lattner<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Function calls (which include several syntactic forms that apply an argument list to something of function type) currently have a dual nature in Swift.  Given something like:<br>&gt; <br>&gt; <br>&gt; 	func foo(a : Int, b : Int) {}<br>&gt; <br>&gt; <br>&gt; You can call it either with with the typical syntactic form that passes arguments to each of its parameters:<br>&gt; <br>&gt; <br>&gt; 	foo(42, b : 17)<br>&gt; <br>&gt; or you can take advantage of a little-known feature to pass an entire argument list as a single value (of tuple type):<br>&gt; <br>&gt; 	let x = (1, b: 2)<br>&gt; 	foo(x)<br>&gt; <br>&gt; <br>&gt; This proposal recommends removing the later form, which I affectionately refer to as the “tuple splat” form.  This feature is purely a sugar feature, it does not provide any expressive ability beyond passing the parameters manually.<br>&gt; <br>&gt; <br>&gt; Swift-evolution thread: TBD<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; This behavior is cute, precedented in other functional languages, and has some advantages, but it also has several major disadvantages, which are all related to its syntactic form.<br>&gt; <br>&gt; * A call to foo(x) looks like a call to an overloaded version of foo, both to the compiler and to the human who maintains the code.  This is extremely confusing if you don’t know the feature exists.<br>&gt; * There are real ambiguities in the syntax, e.g. involving Any arguments and situations where you want to pass a tuple value as a single parameter.<br>&gt; * The current implementation has a ton of implementation bugs - it doesn’t work reliably.<br>&gt; * The current implementation adds complexity to the type checker, slowing it down and adding maintenance burden.<br>&gt; * The current implementation doesn’t work the way we would want a tuple splat operation to work.  For example, arguably, you should be able to call foo with:<br>&gt; <br>&gt; 	func bar() -&gt; (Int, Int) { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; … but this is not allowed, since tuple labels are required to line up.  You have to write:<br>&gt; <br>&gt; 	func bar() -&gt; (Int, b: Int)  { … }<br>&gt; 	foo(bar())<br>&gt; <br>&gt; <br>&gt; This makes this feature very difficult to use in practice, because you have to _’ize a lot of parameters (violating naming conventions), perform manual shuffling (defeating the sugar benefits of the feature), or add parameter labels to the result of functions (which leads to odd tying between callers and callees).<br>&gt; <br>&gt; <br>&gt; The root problem here is that we use exactly the same syntax for both forms of function application.  If the two forms were differentiated (an option considered in “alternatives considered” below) then some of these problems would be defined away.<br>&gt; <br>&gt; From a historical perspective, the tuple splat form of function application dates back to very early Swift design (probably introduced in 2010, but possibly 2011) where all function application was of a single value to a function type.  For a large number of reasons (including default arguments, variadic arguments, labels, etc) we have completely abandoned this model, but we never came back to reevaluating the tuple splat behavior.<br>&gt; <br>&gt; If we didn’t already have this feature, we would not add it to Swift 3 (at least in its current form).<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The proposed solution is simple, we should just remove this feature from the Swift 3 compiler.  Ideally we would deprecate it in the Swift 2.2 compiler and remove it in Swift 3.  However, if there isn’t time to get the deprecation into Swift 2.2, the author believes it would be perfectly fine to just remove it in Swift 3 (with a fixit + migration help of course).<br>&gt; <br>&gt; One of the interesting aspect of this feature is that some of the people we’ve spoken to are very fond of it.  However, when pressed, they admit that they are not actually using it widely in their code, or if they are using it, they are abusing naming conventions (distorting their code) in order to use it.  This doesn’t seem like a positive contribution - this seems like a “clever” feature, not a practical one.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; The design is straight-forward.  In the Swift 3 time frame, we continue to parse and type check these expressions as we have so far, but produce an error + fixit hint when it is the tuple splat form.  The migrator would auto-apply the fixit hint as it does for other cases.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Any code that uses this feature will have to move to the traditional form.  In the case of the example above, this means rewriting the code from:<br>&gt; <br>&gt; 	foo(x)<br>&gt; <br>&gt; into a form like this:<br>&gt; <br>&gt; 	foo(x.0, x.b)<br>&gt; <br>&gt; In the case where “x” is a complex expression, a temporary variable will need to be introduced.  We believe that compiler fixits can handle the simple cases directly and that this extension is not widely used.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; The major problem with this feature is that it was not well considered and implemented properly (owing to its very old age, it has just been kept limping along).  The alternative then is to actually design a proper feature to support this.  Since the implicitness and syntactic ambiguity with normal function application is the problem, the solution is to introduce an explicit syntactic form to represent this.  For example, something like this could address the problems we have:<br>&gt; <br>&gt; 	foo(*x)    // NOT a serious syntax proposal<br>&gt; <br>&gt; However, actually designing this feature would be a non-trivial effort not core to the Swift 3 mission:<br>&gt; <br>&gt; * It is a pure-sugar feature, and therefore low priority.<br>&gt; * We don’t have an obvious sigil to use.  “prefix-star” should be kept as unused for now in case we want to use it to refer to memory-related operations in the future.<br>&gt; * Making the tuple splat operation great requires more than just fixing the syntactic ambiguities we have, it would require re-evaluating the semantics of the operation (e.g. in light of parameter labels, varargs and other features).<br>&gt; <br>&gt; If there is serious interest in pursuing this as a concept, we should do it as a follow-on proposal to this one.  If a good design emerges, we can evaluate that design based on its merits.<br>&gt; <br>&gt; <br>&gt; The final alternative is that we could leave the feature in the compiler.  However, that means living with its complexity “forever” or breaking code in the Swift 4 timeframe.  It would be preferable to tackle this breakage in the Swift 3 timeframe, since we know that migration will already be needed then.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/35d7be2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove implicit tuple splat behavior from function applications</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 31, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 31, 2016, at 5:00 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 in general, though I do wonder how this change will affect generic code. For example, if I have a function that returns a tuple, and another function that takes an argument list matching the same tuple type, can I still use generic functions like map() to call the second function with the tuple from the first? I&#39;m hoping the answer is &quot;yes&quot;, because the type of a function doesn&#39;t distinguish between functions that take multiple arguments vs functions that take a single argument of tuple type and so passing functions around as first-class values should be fine. Although I imagine this change will still prevent me from writing a closure like { funcOfTwoArgs($0) } which is unfortunate, but would be solved by a subsequent proposal to add an explicit splat operator.<br></p><p>Yes, AFAIK, generic code isn’t affected by the proposed change.  Type checking of generic code is modular, not aware of the concrete types the generic is instantiated with.<br></p><p>-Chris<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
