<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b18bf9a0c7bfa962aa136a3e8f18edb0?s=50"></div><header><strong>[Idea] Improved bridging of NSNumber and NSValue types</strong> from <string>Mike Kasianowicz</string> &lt;mike at ap14.com&gt;<p>February 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello, I heard this is the place to talk about things we’d like to see in Swift.<br></p><p>There are a few improvements I’d like to see with Objective-C bridging.  I find myself repeating the same three code patterns in order to have the best of both Objective-C and Swift worlds.<br></p><p>First, optional primitive types should map to optional NSNumber. Currently, they only map to NSNumber when used in an array or dictionary.  The implicitly generated code would look like the following:<br></p><p>    var optIntProperty: Int?<br>    <br>    @objc(optIntProperty)<br>    var objc_optIntProperty: NSNumber? {<br>        get {<br>            guard let value = self.optIntProperty else {<br>                return nil<br>            }<br>            return NSNumber(integer: value)<br>        }<br>        set {<br>            guard let value = newValue else {<br>                self.optIntProperty = nil<br>                return<br>            }<br>            <br>            self.optIntProperty = value.integerValue<br>        }<br>    }<br></p><p>In the code above, you cannot mark the Int? property dynamic - it causes a compiler error - but it would be nice if you could.  This feature would allow shared ObjC classes to be more Swifty, and enable existing runtime reflection/serialization code. I could also see utility of NSNull-nil bridging for values in collections, though this is a rarer case.<br></p><p><br> <br>Second, it would be nice for C-style structs to bridge to NSValue by default.  Currently, every C struct has to implement NSValue bridging manually. I think it’s safe to say that if you mark a struct array property as @objc or dynamic that you typically want it to bridge to NSValue.  Additionally, the same optional handling as noted above would be useful.<br></p><p>// pretend this struct were declared in C, or if we get struct exporting in the future (?)<br>public struct MyCStyleStruct {<br>    public var intProp: Int<br>    public var doubleProp: Float<br>}<br></p><p>extension MyCStyleStruct : _ObjectiveCBridgeable {<br>    public typealias _ObjectiveCType = NSValue<br>    public static func _isBridgedToObjectiveC() -&gt; Bool {<br>        return true<br>    }<br>    <br>    public static func _getObjectiveCType() -&gt; Any.Type {<br>        return NSValue.self<br>    }<br>    <br>    public func _bridgeToObjectiveC() -&gt; _ObjectiveCType {<br>        var sself = self<br>        // would need compiler to create the @encode()<br>        return NSValue(&amp;sself, withObjCType: &quot;{MyCStyleStruct=if}&quot;)<br>    }<br>    <br>    public static func _forceBridgeFromObjectiveC(source: _ObjectiveCType, inout result: MyCStyleStruct?) {<br>        source.getValue(&amp;result)<br>    }<br>    <br>    public static func _conditionallyBridgeFromObjectiveC(source: _ObjectiveCType, inout result: MyCStyleStruct?) -&gt; Bool {<br>        _forceBridgeFromObjectiveC(source, result: &amp;result)<br>        return true<br>    }<br>}<br></p><p><br></p><p><br>Finally, consider automatic bridging of RawRepresentable types (enums) as well, making the _ObjectiveCBridgeable code implicit in the following:<br></p><p>public enum MyEnum: Int {<br>    case Zero = 0<br>    case One = 1<br>    case Two = 2<br>    case Three = 3<br>}<br></p><p>extension MyEnum : _ObjectiveCBridgeable {<br>    public typealias _ObjectiveCType = NSNumber<br>    public static func _isBridgedToObjectiveC() -&gt; Bool {<br>        return true<br>    }<br>    <br>    public static func _getObjectiveCType() -&gt; Any.Type {<br>        return NSNumber.self<br>    }<br>    <br>    public func _bridgeToObjectiveC() -&gt; _ObjectiveCType {<br>        return NSNumber(integer: self.rawValue)<br>    }<br>    <br>    public static func _forceBridgeFromObjectiveC(source: _ObjectiveCType, inout result: MyEnum?) {<br>        result = MyEnum(rawValue: source.integerValue)<br>    }<br>    <br>    public static func _conditionallyBridgeFromObjectiveC(source: _ObjectiveCType, inout result: MyEnum?) -&gt; Bool {<br>        _forceBridgeFromObjectiveC(source, result: &amp;result)<br>        return true<br>    }<br>}<br></p><p><br></p><p>Opinions? Have any/all of these been discussed before?<br></p><p>Thanks!<br>Mike<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/f1ae6901/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Idea] Improved bridging of NSNumber and NSValue types</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>February 27, 2016 at 06:00:00pm</p></header><div class="content"><p>I was just discussing your first suggestion with a friend the other day. It’d be nice to see that happen so that more apis would be available to obj-c. I wonder how the following would be treated though?<br></p><p>swift:<br>class Foo: NSObject {<br>    class func printNumber(num: Int16?) {<br>        print(num)<br>    }<br>}<br></p><p>objc:<br>[Foo printNumber:[NSNumber numberWithInt:70000]];<br></p><p>Since NSNumber has no restrictions on what it can contain, it’s possible that one could pass a value that is outside the bounds of the type accepted by swift, which would likely crash your code.<br></p><p>If NSNumber were to bridge with optional scalars like this, the wrapped type for NSNumber would need to be present in the type signature of the obj-c code somehow so that the compiler could at the very least warn you. This could perhaps be done via obj-c lightweight generics (or per-scalar-type subclasses of NSNumber for each supported wrapped type, but that’s a bit odd).<br></p><p>You mention [Int] is bridged to NSArray&lt;NSNumber *&gt; * in objc, but [Int16] is not in my tests (probably for the reason I stated above). In my tests, [Bool], [Float], and [Double] also bridge today to that, so the same rules there could apply to optional versions.<br></p><p>--<br>Kevin Lundberg<br></p><p>&gt; On Feb 27, 2016, at 5:48 PM, Mike Kasianowicz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, I heard this is the place to talk about things we’d like to see in Swift.<br>&gt; <br>&gt; There are a few improvements I’d like to see with Objective-C bridging.  I find myself repeating the same three code patterns in order to have the best of both Objective-C and Swift worlds.<br>&gt; <br>&gt; First, optional primitive types should map to optional NSNumber. Currently, they only map to NSNumber when used in an array or dictionary.  The implicitly generated code would look like the following:<br>&gt; <br>&gt;     var optIntProperty: Int?<br>&gt;     <br>&gt;     @objc(optIntProperty)<br>&gt;     var objc_optIntProperty: NSNumber? {<br>&gt;         get {<br>&gt;             guard let value = self.optIntProperty else {<br>&gt;                 return nil<br>&gt;             }<br>&gt;             return NSNumber(integer: value)<br>&gt;         }<br>&gt;         set {<br>&gt;             guard let value = newValue else {<br>&gt;                 self.optIntProperty = nil<br>&gt;                 return<br>&gt;             }<br>&gt;             <br>&gt;             self.optIntProperty = value.integerValue<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; In the code above, you cannot mark the Int? property dynamic - it causes a compiler error - but it would be nice if you could.  This feature would allow shared ObjC classes to be more Swifty, and enable existing runtime reflection/serialization code. I could also see utility of NSNull-nil bridging for values in collections, though this is a rarer case.<br>&gt; <br>&gt; <br>&gt;  <br>&gt; Second, it would be nice for C-style structs to bridge to NSValue by default.  Currently, every C struct has to implement NSValue bridging manually. I think it’s safe to say that if you mark a struct array property as @objc or dynamic that you typically want it to bridge to NSValue.  Additionally, the same optional handling as noted above would be useful.<br>&gt; <br>&gt; // pretend this struct were declared in C, or if we get struct exporting in the future (?)<br>&gt; public struct MyCStyleStruct {<br>&gt;     public var intProp: Int<br>&gt;     public var doubleProp: Float<br>&gt; }<br>&gt; <br>&gt; extension MyCStyleStruct : _ObjectiveCBridgeable {<br>&gt;     public typealias _ObjectiveCType = NSValue<br>&gt;     public static func _isBridgedToObjectiveC() -&gt; Bool {<br>&gt;         return true<br>&gt;     }<br>&gt;     <br>&gt;     public static func _getObjectiveCType() -&gt; Any.Type {<br>&gt;         return NSValue.self<br>&gt;     }<br>&gt;     <br>&gt;     public func _bridgeToObjectiveC() -&gt; _ObjectiveCType {<br>&gt;         var sself = self<br>&gt;         // would need compiler to create the @encode()<br>&gt;         return NSValue(&amp;sself, withObjCType: &quot;{MyCStyleStruct=if}&quot;)<br>&gt;     }<br>&gt;     <br>&gt;     public static func _forceBridgeFromObjectiveC(source: _ObjectiveCType, inout result: MyCStyleStruct?) {<br>&gt;         source.getValue(&amp;result)<br>&gt;     }<br>&gt;     <br>&gt;     public static func _conditionallyBridgeFromObjectiveC(source: _ObjectiveCType, inout result: MyCStyleStruct?) -&gt; Bool {<br>&gt;         _forceBridgeFromObjectiveC(source, result: &amp;result)<br>&gt;         return true<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Finally, consider automatic bridging of RawRepresentable types (enums) as well, making the _ObjectiveCBridgeable code implicit in the following:<br>&gt; <br>&gt; public enum MyEnum: Int {<br>&gt;     case Zero = 0<br>&gt;     case One = 1<br>&gt;     case Two = 2<br>&gt;     case Three = 3<br>&gt; }<br>&gt; <br>&gt; extension MyEnum : _ObjectiveCBridgeable {<br>&gt;     public typealias _ObjectiveCType = NSNumber<br>&gt;     public static func _isBridgedToObjectiveC() -&gt; Bool {<br>&gt;         return true<br>&gt;     }<br>&gt;     <br>&gt;     public static func _getObjectiveCType() -&gt; Any.Type {<br>&gt;         return NSNumber.self<br>&gt;     }<br>&gt;     <br>&gt;     public func _bridgeToObjectiveC() -&gt; _ObjectiveCType {<br>&gt;         return NSNumber(integer: self.rawValue)<br>&gt;     }<br>&gt;     <br>&gt;     public static func _forceBridgeFromObjectiveC(source: _ObjectiveCType, inout result: MyEnum?) {<br>&gt;         result = MyEnum(rawValue: source.integerValue)<br>&gt;     }<br>&gt;     <br>&gt;     public static func _conditionallyBridgeFromObjectiveC(source: _ObjectiveCType, inout result: MyEnum?) -&gt; Bool {<br>&gt;         _forceBridgeFromObjectiveC(source, result: &amp;result)<br>&gt;         return true<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; Opinions? Have any/all of these been discussed before?<br>&gt; <br>&gt; Thanks!<br>&gt; Mike<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/638af40e/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
