<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>There are two functions isUniquelyReferencedNonObjC and isUniquelyReferenced, which do exactly the same thing. One has a more constrained type, only accepting Swift objects. The other one accepts ObjC objects as well, but always returns false. Regardless of whether it should (could?) work for ObjC objects, I think this duplication is confusing (it has confused me for a long time, and I’m happy that I can now see they’re implemented in exactly the same way).<br></p><p>I think probably accepting just Swift objects would be the right thing to do, as the function is useless for ObjC objects.<br></p><p>Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 8:50 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There are two functions isUniquelyReferencedNonObjC and isUniquelyReferenced, which do exactly the same thing. One has a more constrained type, only accepting Swift objects. The other one accepts ObjC objects as well, but always returns false. Regardless of whether it should (could?) work for ObjC objects, I think this duplication is confusing (it has confused me for a long time, and I’m happy that I can now see they’re implemented in exactly the same way).<br>&gt; <br>&gt; I think probably accepting just Swift objects would be the right thing to do, as the function is useless for ObjC objects.<br></p><p>+1, I think this is just legacy we haven&#39;t gotten around to cleaning up.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 8:56 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:50 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There are two functions isUniquelyReferencedNonObjC and isUniquelyReferenced, which do exactly the same thing. One has a more constrained type, only accepting Swift objects. The other one accepts ObjC objects as well, but always returns false. Regardless of whether it should (could?) work for ObjC objects, I think this duplication is confusing (it has confused me for a long time, and I’m happy that I can now see they’re implemented in exactly the same way).<br>&gt;&gt; <br>&gt;&gt; I think probably accepting just Swift objects would be the right thing to do, as the function is useless for ObjC objects.<br>&gt; <br>&gt; +1, I think this is just legacy we haven&#39;t gotten around to cleaning up.<br></p><p>cc&#39;ing Andy, who can confirm whether the distinction is still necessary.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 8:59 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:56 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 8:50 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two functions isUniquelyReferencedNonObjC and isUniquelyReferenced, which do exactly the same thing. One has a more constrained type, only accepting Swift objects. The other one accepts ObjC objects as well, but always returns false. Regardless of whether it should (could?) work for ObjC objects, I think this duplication is confusing (it has confused me for a long time, and I’m happy that I can now see they’re implemented in exactly the same way).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think probably accepting just Swift objects would be the right thing to do, as the function is useless for ObjC objects.<br>&gt;&gt; <br>&gt;&gt; +1, I think this is just legacy we haven&#39;t gotten around to cleaning up.<br>&gt; <br>&gt; cc&#39;ing Andy, who can confirm whether the distinction is still necessary.<br></p><p>Yes! The most efficient runtime call is already inferred from the object type. So there is no efficiency advantage in using one entry point over the other. I think I left both in place because they were already public API. But I think the “NonObjC” entry point should be removed and documented wherever we document API changes. Maybe CHANGLELOG.md.<br></p><p>Side note: internally we have a Builtin.isUnique_native that force casts Any object to Builtin.NativeObject in order to bypass the ObjC check for unknown types. It’s only useful for ObjC bridged types and we do not expose this through a public API.<br></p><p>Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December 10, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On 10 Dec 2015, at 12:38, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:59 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 8:56 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:50 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two functions isUniquelyReferencedNonObjC and isUniquelyReferenced, which do exactly the same thing. One has a more constrained type, only accepting Swift objects. The other one accepts ObjC objects as well, but always returns false. Regardless of whether it should (could?) work for ObjC objects, I think this duplication is confusing (it has confused me for a long time, and I’m happy that I can now see they’re implemented in exactly the same way).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think probably accepting just Swift objects would be the right thing to do, as the function is useless for ObjC objects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1, I think this is just legacy we haven&#39;t gotten around to cleaning up.<br>&gt;&gt; <br>&gt;&gt; cc&#39;ing Andy, who can confirm whether the distinction is still necessary.<br>&gt; <br>&gt; Yes! The most efficient runtime call is already inferred from the object type. So there is no efficiency advantage in using one entry point over the other. I think I left both in place because they were already public API. But I think the “NonObjC” entry point should be removed and documented wherever we document API changes. Maybe CHANGLELOG.md.<br>&gt; <br>&gt; Side note: internally we have a Builtin.isUnique_native that force casts Any object to Builtin.NativeObject in order to bypass the ObjC check for unknown types. It’s only useful for ObjC bridged types and we do not expose this through a public API.<br></p><p>Okay, great!<br></p><p>I can have a stab at this next week, when I’m back at my regular computer. Unless someone else feels like doing it before that, which is fine too =).<br></p><p>Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/1e1ec18c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 11:25 AM, Chris Eidhof via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 10 Dec 2015, at 12:38, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 8:59 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 8:56 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 8:50 AM, Chris Eidhof via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There are two functions isUniquelyReferencedNonObjC and<br>&gt; isUniquelyReferenced, which do exactly the same thing. One has a more<br>&gt; constrained type, only accepting Swift objects. The other one accepts ObjC<br>&gt; objects as well, but always returns false. Regardless of whether it should<br>&gt; (could?) work for ObjC objects, I think this duplication is confusing (it<br>&gt; has confused me for a long time, and I’m happy that I can now see they’re<br>&gt; implemented in exactly the same way).<br>&gt;<br>&gt; I think probably accepting just Swift objects would be the right thing to<br>&gt; do, as the function is useless for ObjC objects.<br>&gt;<br>&gt;<br>&gt; +1, I think this is just legacy we haven&#39;t gotten around to cleaning up.<br>&gt;<br>&gt;<br>&gt; cc&#39;ing Andy, who can confirm whether the distinction is still necessary.<br>&gt;<br>&gt;<br>&gt; Yes! The most efficient runtime call is already inferred from the object<br>&gt; type. So there is no efficiency advantage in using one entry point over the<br>&gt; other. I think I left both in place because they were already public API.<br>&gt; But I think the “NonObjC” entry point should be removed and documented<br>&gt; wherever we document API changes. Maybe CHANGLELOG.md.<br>&gt;<br>&gt; Side note: internally we have a Builtin.isUnique_native that force casts<br>&gt; Any object to Builtin.NativeObject in order to bypass the ObjC check for<br>&gt; unknown types. It’s only useful for ObjC bridged types and we do not expose<br>&gt; this through a public API.<br>&gt;<br>&gt;<br>&gt; Okay, great!<br>&gt;<br>&gt; I can have a stab at this next week, when I’m back at my regular computer.<br>&gt; Unless someone else feels like doing it before that, which is fine too =).<br>&gt;<br></p><p>Just wanted to point out that like every API change, this needs to be<br>proposed on swift-evolution.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/17f0c06c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/57885cfd0c4b4db16653e76d9e6f0266?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Johan Jensen</string> &lt;jj at johanjensen.dk&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>I thought this *was* the proposal on swift-evolution.<br>Or do you mean github.com/apple/swift-evolution?<br>Does this need a full proposal and review-cycle,<br>as well as a number and markdown-file on the above repository?<br></p><p><br>On Thu, Dec 10, 2015 at 9:12 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Dec 10, 2015 at 11:25 AM, Chris Eidhof via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On 10 Dec 2015, at 12:38, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 10, 2015, at 8:59 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 10, 2015, at 8:56 AM, Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 10, 2015, at 8:50 AM, Chris Eidhof via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; There are two functions isUniquelyReferencedNonObjC and<br>&gt;&gt; isUniquelyReferenced, which do exactly the same thing. One has a more<br>&gt;&gt; constrained type, only accepting Swift objects. The other one accepts ObjC<br>&gt;&gt; objects as well, but always returns false. Regardless of whether it should<br>&gt;&gt; (could?) work for ObjC objects, I think this duplication is confusing (it<br>&gt;&gt; has confused me for a long time, and I’m happy that I can now see they’re<br>&gt;&gt; implemented in exactly the same way).<br>&gt;&gt;<br>&gt;&gt; I think probably accepting just Swift objects would be the right thing to<br>&gt;&gt; do, as the function is useless for ObjC objects.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; +1, I think this is just legacy we haven&#39;t gotten around to cleaning up.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; cc&#39;ing Andy, who can confirm whether the distinction is still necessary.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes! The most efficient runtime call is already inferred from the object<br>&gt;&gt; type. So there is no efficiency advantage in using one entry point over the<br>&gt;&gt; other. I think I left both in place because they were already public API.<br>&gt;&gt; But I think the “NonObjC” entry point should be removed and documented<br>&gt;&gt; wherever we document API changes. Maybe CHANGLELOG.md.<br>&gt;&gt;<br>&gt;&gt; Side note: internally we have a Builtin.isUnique_native that force casts<br>&gt;&gt; Any object to Builtin.NativeObject in order to bypass the ObjC check for<br>&gt;&gt; unknown types. It’s only useful for ObjC bridged types and we do not expose<br>&gt;&gt; this through a public API.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Okay, great!<br>&gt;&gt;<br>&gt;&gt; I can have a stab at this next week, when I’m back at my regular<br>&gt;&gt; computer. Unless someone else feels like doing it before that, which is<br>&gt;&gt; fine too =).<br>&gt;&gt;<br>&gt;<br>&gt; Just wanted to point out that like every API change, this needs to be<br>&gt; proposed on swift-evolution.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/973cba48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 12:30 PM, Johan Jensen &lt;jj at johanjensen.dk&gt; wrote:<br></p><p>&gt; I thought this *was* the proposal on swift-evolution.<br>&gt; Or do you mean github.com/apple/swift-evolution?<br>&gt; Does this need a full proposal and review-cycle,<br>&gt; as well as a number and markdown-file on the above repository?<br>&gt;<br></p><p>Yes, the markdown file and review period.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/26571862/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>I think the name isUniquelyReferenced is better, and it should use the constraint to make sure it only works on Swift objects. That way there’s no confusion.<br></p><p>Chris<br></p><p>&gt; On 10 Dec 2015, at 11:56, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:50 AM, Chris Eidhof via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There are two functions isUniquelyReferencedNonObjC and isUniquelyReferenced, which do exactly the same thing. One has a more constrained type, only accepting Swift objects. The other one accepts ObjC objects as well, but always returns false. Regardless of whether it should (could?) work for ObjC objects, I think this duplication is confusing (it has confused me for a long time, and I’m happy that I can now see they’re implemented in exactly the same way).<br>&gt;&gt; <br>&gt;&gt; I think probably accepting just Swift objects would be the right thing to do, as the function is useless for ObjC objects.<br>&gt; <br>&gt; +1, I think this is just legacy we haven&#39;t gotten around to cleaning up.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 9:00 AM, Chris Eidhof &lt;chris at eidhof.nl&gt; wrote:<br>&gt; <br>&gt; I think the name isUniquelyReferenced is better, and it should use the constraint to make sure it only works on Swift objects. That way there’s no confusion.<br></p><p>I don&#39;t think the constraint is desirable. For most ObjC objects we just conservatively return &#39;false&#39;, but it isn&#39;t unreasonable to think that some ObjC types might be able to reliably answer isUniquelyReferenced in the future. Furthermore, IIRC the constraint works by requiring a `NonObjC` base class, and enforcing a common base class is not an acceptable design constraint for pure Swift code.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ade0c334ecff1448bb96f5f733bf1f83?s=50"></div><header><strong>Remove isUniquelyReferenced or isUniquelyReferencedNonObjC?</strong> from <string>Chris Eidhof</string> &lt;chris at eidhof.nl&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On 10 Dec 2015, at 12:03, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 9:00 AM, Chris Eidhof &lt;chris at eidhof.nl&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think the name isUniquelyReferenced is better, and it should use the constraint to make sure it only works on Swift objects. That way there’s no confusion.<br>&gt; <br>&gt; I don&#39;t think the constraint is desirable. For most ObjC objects we just conservatively return &#39;false&#39;, but it isn&#39;t unreasonable to think that some ObjC types might be able to reliably answer isUniquelyReferenced in the future. Furthermore, IIRC the constraint works by requiring a `NonObjC` base class, and enforcing a common base class is not an acceptable design constraint for pure Swift code.<br></p><p>I didn’t realise that NonObjc was a class, I somehow thought it was a compiler-inserted protocol for Swift objects, haha.<br></p><p>So that’d mean you’d instead have the constraint in the documentation, saying that “this will currently not work on ObjC types”? Seems fair.<br></p><p>Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
