<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Proposal: CustomConvertible protocol</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.<br></p><p>Swift introduced a few Convertible protocols, but it still needs some more If you ask me.<br></p><p>Something like this:<br></p><p>public protocol CustomConvertible {<br>     <br>    typealias CustomType<br>     <br>    public init(value: Self.CustomType) // or in a better way I can&#39;t come up with<br>}<br>But it should work in a way that we could create more different types like enums and ErrorType.<br></p><p>protocol AConvertible: CustomConvertible { /* some stuff here*/ }<br>protocol BConvertible: CustomConvertible { /* some stuff here*/ }<br></p><p>struct A {<br>    var foo: Int = 0<br>}<br></p><p>struct B {<br>    var boo: String = &quot;Hello World&quot;<br>}<br></p><p>struct C: AConvertible, BConvertible {<br>     <br>    typealias CustomAType = A<br>    typealias CustomBType = B<br>     <br>    var magical: SomeType<br>         <br>    init(value: CustomAType) {<br>        // implement it<br>    }<br>     <br>    init(value: CustomBType) {<br>        // implement it<br>    }<br>}<br></p><p>//===========================<br></p><p>let firstC: C = A() // this is what I&#39;m missing in Swift<br>let secondC: C = B() // this would be a great syntax sugar<br>What do you think?<br></p><p><br></p><p>??<br>Regards Adrian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/877dfd93/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2de9c65fa069dba3df6e3f77168d0f15?s=50"></div><header><strong>Proposal: CustomConvertible protocol</strong> from <string>Stepan Hruda</string> &lt;stepan.hruda at gmail.com&gt;<p>December  4, 2015 at 06:00:00am</p></header><div class="content"><p>This is not how *LiteralConvertible protocols work, though. You can only initialize variables with specific literal values recognized by the parser, it never magically casts a type to a different type for you. Similar implicit casts in my opinion confuse whoever reads the code afterwards.<br></p><p><br></p><p><br>```<br></p><p><br>class SomeConvertible: BooleanLiteralConvertible {<br></p><p>? ? typealias BooleanLiteralType = Bool<br></p><p>? ? let boolean: Bool<br></p><p><br></p><p><br>? ? internal required init(booleanLiteral value: SomeConvertible.BooleanLiteralType) {<br></p><p>? ? ? ? self.boolean = value<br></p><p>? ? }<br></p><p>}<br></p><p><br></p><p><br>func getBoolean() -&gt; Bool {<br></p><p>? ? return false<br></p><p>}<br></p><p><br></p><p><br>let validConvertible: SomeConvertible = false<br></p><p>// Line below doesn?t compile<br></p><p>let invalidConvertible: SomeConvertible = getBoolean()<br></p><p><br></p><p>```<br></p><p>On Fri, Dec 4, 2015 at 8:51 AM, Adrian Zubarev<br>&lt;adrian.zubarev at devandartist.com&gt; wrote:<br></p><p>&gt; We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.<br>&gt; Swift introduced a few Convertible protocols, but it still needs some more If you ask me.<br>&gt; Something like this:<br>&gt; public protocol CustomConvertible {<br>&gt;      <br>&gt;     typealias CustomType<br>&gt;      <br>&gt;     public init(value: Self.CustomType) // or in a better way I can&#39;t come up with<br>&gt; }<br>&gt; But it should work in a way that we could create more different types like enums and ErrorType.<br>&gt; protocol AConvertible: CustomConvertible { /* some stuff here*/ }<br>&gt; protocol BConvertible: CustomConvertible { /* some stuff here*/ }<br>&gt; struct A {<br>&gt;     var foo: Int = 0<br>&gt; }<br>&gt; struct B {<br>&gt;     var boo: String = &quot;Hello World&quot;<br>&gt; }<br>&gt; struct C: AConvertible, BConvertible {<br>&gt;      <br>&gt;     typealias CustomAType = A<br>&gt;     typealias CustomBType = B<br>&gt;      <br>&gt;     var magical: SomeType<br>&gt;          <br>&gt;     init(value: CustomAType) {<br>&gt;         // implement it<br>&gt;     }<br>&gt;      <br>&gt;     init(value: CustomBType) {<br>&gt;         // implement it<br>&gt;     }<br>&gt; }<br>&gt; //===========================<br>&gt; let firstC: C = A() // this is what I&#39;m missing in Swift<br>&gt; let secondC: C = B() // this would be a great syntax sugar<br>&gt; What do you think?<br>&gt; ??<br>&gt; Regards Adrian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0fbd63a3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: CustomConvertible protocol</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 5:51 AM, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br>&gt; We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.<br>&gt; <br>&gt; Swift introduced a few Convertible protocols, but it still needs some more If you ask me. <br>&gt; <br>&gt; Something like this:<br>&gt; <br>&gt; public protocol CustomConvertible {<br>&gt;      <br>&gt;     typealias CustomType<br>&gt;      <br>&gt;     public init(value: Self.CustomType) // or in a better way I can&#39;t come up with<br>&gt; }<br>&gt; But it should work in a way that we could create more different types like enums and ErrorType.<br>&gt; <br>&gt; protocol AConvertible: CustomConvertible { /* some stuff here*/ }<br>&gt; protocol BConvertible: CustomConvertible { /* some stuff here*/ }<br>&gt; <br>&gt; struct A {<br>&gt;     var foo: Int = 0<br>&gt; }<br>&gt; <br>&gt; struct B {<br>&gt;     var boo: String = &quot;Hello World&quot;<br>&gt; }<br>&gt; <br>&gt; struct C: AConvertible, BConvertible {<br>&gt;      <br>&gt;     typealias CustomAType = A<br>&gt;     typealias CustomBType = B<br>&gt;      <br>&gt;     var magical: SomeType<br>&gt;          <br>&gt;     init(value: CustomAType) {<br>&gt;         // implement it<br>&gt;     }<br>&gt;      <br>&gt;     init(value: CustomBType) {<br>&gt;         // implement it<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; //===========================<br>&gt; <br>&gt; let firstC: C = A() // this is what I&#39;m missing in Swift<br>&gt; let secondC: C = B() // this would be a great syntax sugar<br>&gt; What do you think?<br>&gt; <br>This is effectively a request for user-defined conversion operators.  We actually did support those at one point in the history of Swift, but we removed them because they both introduced a lot of confusion and errors into common user idioms and were very problematic for the type-checker.  It?s easy to look at obviously-contextually-typed examples like this and say that the type-checker should just make it work, but in the context of a general System F-sub type system, it is a massive source of added complexity.<br></p><p>In other words, at present, this is not an extension we feel we can deliver a satisfactory experience for, and to be taken seriously, any proposal is going need to demonstrate a lot of familiarity with type systems.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/2cd5dab6/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
