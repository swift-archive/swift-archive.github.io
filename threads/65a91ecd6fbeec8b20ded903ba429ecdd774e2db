<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Expose assert configuration functions in standard library</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 29, 2016 at 11:00:00am</p></header><div class="content"><p>Back in March, I somewhat foolishly agreed to pick up the gauntlet for a series of community-requested proposals centered on build configurations. Requested items included:<br></p><p>A way to test for destination platforms like Apple, Linux, Windows, Unix-like, UIKit-supporting, etc<br>A way to test for Simulator/Emulator vs Hardware targets<br>A way to test for debug builds<br>A way to test for platform conditions (bigendian, littlendian, bitwidth 32 and 64, objc-interop, see lib/Basic/LangOptions.cpp)<br></p><p>This splintered down into a series of draft proposals. The first adopted proposal, SE-0075 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md&gt; adds a build configuration import test similar to Clang&#39;s __has_include. It lets you test whether a module like UIKit is available, letting you customize code for specific modules.<br></p><p>Next up on my list is debug-specific coding. Summarizing to date:<br></p><p>There&#39;s a general consensus that a debug state occurs when assertions can fire and are not disabled by compile-time optimizations.<br>The concept of &quot;debug&quot; is nuanced enough that introducing a single  #if debug build configuration test is insufficient for substantial set of community members who interacted in previous discussions and Swift developers who have sent me feedback outside this list.<br>Conditioning debug on Xcode debug/release schemes is a no-go.<br>Hidden helper functions already exist in Swift.<br>Members of the core team believe using build configurations is the wrong point to conditionalize code. <br></p><p>Joe Groff wrote, &quot;We specifically avoided making debug/release an #if condition because we considered #if to be the wrong point at which to start conditionalizing code generation for assertions. Though the final executable image&#39;s behavior is unavoidably dependent on whether asserts are enabled, we didn&#39;t want the SIL for inlineable code to be, since that would mean libraries with inlineable code would need to ship three times the amount of serialized SIL to support the right behavior in -Onone, -O, and -Ounchecked builds. Instead, the standard library has some hidden helper functions, _isDebugAssertConfiguration, _isReleaseAssertConfiguration, and _isFastAssertConfiguration, which are guaranteed to be constant-folded away before final code generation.&quot;<br></p><p>My pitch: I want to promote these three helper functions to the standard library and remove their underscore prefixes. My primary use case is to limit logging and development-servicing functions (for example, statistical measurements) to &quot;debug&quot; builds. I believe a sufficient quorum of the community has similar needs that would be served by making these first class &quot;listed&quot; functions.<br></p><p>Doing so:<br></p><p>Eliminates the build configuration approach<br>Eliminates the need to define what &quot;debug&quot; means<br>Conditions configuration testing on assertion firing state not Xcode schemes or build flags (e.g. -D debug)<br>Uses already-existing global functions, requiring no coding<br></p><p>Thoughts?<br></p><p>-- E<br>p.s. I&#39;d warmly welcome any third party assistance with the outstanding requests<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/65a9e2db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Expose assert configuration functions in standard library</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 29, 2016 at 11:00:00am</p></header><div class="content"><p>Am I understanding correctly that<br></p><p>    -Onone  →  _isDebugAssertConfiguration is true<br>    -O → _isReleaseAssertConfiguration is true<br>    -Ounchecked → _isFastAssertConfiguration is true<br></p><p>?<br></p><p>If the goal is to expose the optimization level to user code, might I<br>suggest something like<br></p><p>    enum OptimizationLevel {<br>        case none<br>        case standard<br>        case unchecked<br>    }<br></p><p>    var optimizationLevel: OptimizationLevel { get }<br></p><p>IMO, users may still want to control certain things with per-configuration<br>flags, but that&#39;s still achievable with -DX and #if X. Exposing the<br>optimization level makes sense to me.<br></p><p>On Sun, May 29, 2016 at 10:59 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Back in March, I somewhat foolishly agreed to pick up the gauntlet for a<br>&gt; series of community-requested proposals centered on build configurations.<br>&gt; Requested items included:<br>&gt;<br>&gt;<br>&gt;    - A way to test for destination platforms like Apple, Linux,<br>&gt;    Windows, Unix-like, UIKit-supporting, etc<br>&gt;    - A way to test for Simulator/Emulator vs Hardware targets<br>&gt;    - A way to test for debug builds<br>&gt;    - A way to test for platform conditions (bigendian, littlendian,<br>&gt;    bitwidth 32 and 64, objc-interop, see lib/Basic/LangOptions.cpp)<br>&gt;<br>&gt;<br>&gt; This splintered down into a series of draft proposals. The first adopted<br>&gt; proposal, SE-0075<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0075-import-test.md&gt; adds<br>&gt; a build configuration import test similar to Clang&#39;s __has_include. It lets<br>&gt; you test whether a module like UIKit is available, letting you customize<br>&gt; code for specific modules.<br>&gt;<br>&gt; Next up on my list is debug-specific coding. Summarizing to date:<br>&gt;<br>&gt;<br>&gt;    - There&#39;s a general consensus that a debug state occurs when<br>&gt;    assertions can fire and are not disabled by compile-time optimizations.<br>&gt;    - The concept of &quot;debug&quot; is nuanced enough that introducing a single  #if<br>&gt;    debug build configuration test is insufficient for substantial set of<br>&gt;    community members who interacted in previous discussions and Swift<br>&gt;    developers who have sent me feedback outside this list.<br>&gt;    - Conditioning debug on Xcode debug/release schemes is a no-go.<br>&gt;    - Hidden helper functions already exist in Swift.<br>&gt;    - Members of the core team believe using build configurations is the<br>&gt;    wrong point to conditionalize code.<br>&gt;<br>&gt;<br>&gt; Joe Groff wrote, &quot;We specifically avoided making debug/release an #if<br>&gt; condition because we considered #if to be the wrong point at which to start<br>&gt; conditionalizing code generation for assertions. Though the final<br>&gt; executable image&#39;s behavior is unavoidably dependent on whether asserts are<br>&gt; enabled, we didn&#39;t want the SIL for inlineable code to be, since that would<br>&gt; mean libraries with inlineable code would need to ship three times the<br>&gt; amount of serialized SIL to support the right behavior in -Onone, -O, and<br>&gt; -Ounchecked builds. Instead, the standard library has some hidden helper<br>&gt; functions, _isDebugAssertConfiguration, _isReleaseAssertConfiguration, and<br>&gt; _isFastAssertConfiguration, which are guaranteed to be constant-folded away<br>&gt; before final code generation.&quot;<br>&gt;<br>&gt; My pitch: I want to promote these three helper functions to the standard<br>&gt; library and remove their underscore prefixes. My primary use case is to<br>&gt; limit logging and development-servicing functions (for example, statistical<br>&gt; measurements) to &quot;debug&quot; builds. I believe a sufficient quorum of the<br>&gt; community has similar needs that would be served by making these first<br>&gt; class &quot;listed&quot; functions.<br>&gt;<br>&gt; Doing so:<br>&gt;<br>&gt;<br>&gt;    - Eliminates the build configuration approach<br>&gt;    - Eliminates the need to define what &quot;debug&quot; means<br>&gt;    - Conditions configuration testing on assertion firing state not Xcode<br>&gt;    schemes or build flags (e.g. -D debug)<br>&gt;    - Uses already-existing global functions, requiring no coding<br>&gt;<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -- E<br>&gt; p.s. I&#39;d warmly welcome any third party assistance with the outstanding<br>&gt; requests<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/6508d8b1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Expose assert configuration functions in standard library</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; My pitch: I want to promote these three helper functions to the standard library and remove their underscore prefixes.<br></p><p>These functions currently have implementations like this:<br></p><p>	@_transparent<br>	@warn_unused_result<br>	public // @testable<br>	func _isDebugAssertConfiguration() -&gt; Bool {<br>	  // The values for the assert_configuration call are:<br>	  // 0: Debug<br>	  // 1: Release<br>	  // 2: Fast<br>	  return Int32(Builtin.assert_configuration()) == 0<br>	}<br></p><p>I think how this works is:<br></p><p>* @_transparent makes sure these functions are always inlined at the call site.<br>* Most things in the standard library are *also* @_transparent.<br>* Therefore, after both (or more!) inlinings happen, you get the `Builtin.assert_configuration()` of the code calling into the standard library.<br></p><p>Needless to say, this is *extremely* weird and magical, and I&#39;m skeptical of the idea that we should expose it as a normal function call.<br></p><p>I think a better design which would accurately convey its magic is to add a type to the standard library:<br></p><p>	enum BuildKind: Int32 { case debug, release, unchecked }<br></p><p>(Note: the names in this could use some bikeshedding. Put that aside.)<br></p><p>And then add a `#buildKind` compiler substitution which is equivalent to:<br></p><p>	BuildKind(rawValue: Int32(Builtin.assert_configuration()))<br></p><p>Now you can surround your debug-only code with `#buildKind == .debug`. Or you can capture the *call site&#39;s* build kind with a default parameter:<br></p><p>	func log(_ message: String, level: LogLevel = .info, buildKind: BuildKind = #buildKind)<br></p><p>Even the standard library might be able to do this if it wanted to, allowing your code to enable or disable asserts based on whether your caller&#39;s code is in debug mode or not:<br></p><p>	func assert(@autoclosure condition: () -&gt; Bool, @autoclosure _ message: () -&gt; String = default, file: StaticString= #file, line: UInt = #line, buildKind: BuildKind = #buildKind)<br></p><p>(I wouldn&#39;t suggest that every stdlib member add such a default parameter; most should continue to rely on `@_transparent`. But I think that could be useful for calls like `assert()` and `precondition()`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Expose assert configuration functions in standard library</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>Or, to be honest:<br></p><p>/// Offers user-facing public assert configuration test<br>@_transparent<br>public<br>func isDebugAssertConfiguration() -&gt; Bool {<br>  return _isDebugAssertConfiguration()<br>}<br></p><p>which covers, I believe, about 98% of the demand for this feature<br></p><p>-- E<br></p><p>&gt; On May 31, 2016, at 11:21 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; My pitch: I want to promote these three helper functions to the standard library and remove their underscore prefixes.<br>&gt; <br>&gt; These functions currently have implementations like this:<br>&gt; <br>&gt; 	@_transparent<br>&gt; 	@warn_unused_result<br>&gt; 	public // @testable<br>&gt; 	func _isDebugAssertConfiguration() -&gt; Bool {<br>&gt; 	  // The values for the assert_configuration call are:<br>&gt; 	  // 0: Debug<br>&gt; 	  // 1: Release<br>&gt; 	  // 2: Fast<br>&gt; 	  return Int32(Builtin.assert_configuration()) == 0<br>&gt; 	}<br>&gt; <br>&gt; I think how this works is:<br>&gt; <br>&gt; * @_transparent makes sure these functions are always inlined at the call site.<br>&gt; * Most things in the standard library are *also* @_transparent.<br>&gt; * Therefore, after both (or more!) inlinings happen, you get the `Builtin.assert_configuration()` of the code calling into the standard library.<br>&gt; <br>&gt; Needless to say, this is *extremely* weird and magical, and I&#39;m skeptical of the idea that we should expose it as a normal function call.<br>&gt; <br>&gt; I think a better design which would accurately convey its magic is to add a type to the standard library:<br>&gt; <br>&gt; 	enum BuildKind: Int32 { case debug, release, unchecked }<br>&gt; <br>&gt; (Note: the names in this could use some bikeshedding. Put that aside.)<br>&gt; <br>&gt; And then add a `#buildKind` compiler substitution which is equivalent to:<br>&gt; <br>&gt; 	BuildKind(rawValue: Int32(Builtin.assert_configuration()))<br>&gt; <br>&gt; Now you can surround your debug-only code with `#buildKind == .debug`. Or you can capture the *call site&#39;s* build kind with a default parameter:<br>&gt; <br>&gt; 	func log(_ message: String, level: LogLevel = .info, buildKind: BuildKind = #buildKind)<br>&gt; <br>&gt; Even the standard library might be able to do this if it wanted to, allowing your code to enable or disable asserts based on whether your caller&#39;s code is in debug mode or not:<br>&gt; <br>&gt; 	func assert(@autoclosure condition: () -&gt; Bool, @autoclosure _ message: () -&gt; String = default, file: StaticString= #file, line: UInt = #line, buildKind: BuildKind = #buildKind)<br>&gt; <br>&gt; (I wouldn&#39;t suggest that every stdlib member add such a default parameter; most should continue to rely on `@_transparent`. But I think that could be useful for calls like `assert()` and `precondition()`.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/03be5806/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Expose assert configuration functions in standard library</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 9:15 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Or, to be honest:<br>&gt; <br>&gt; /// Offers user-facing public assert configuration test<br>&gt; @_transparent<br>&gt; public<br>&gt; func isDebugAssertConfiguration() -&gt; Bool {<br>&gt;   return _isDebugAssertConfiguration()<br>&gt; }<br>&gt; <br>&gt; which covers, I believe, about 98% of the demand for this feature<br>&gt; <br>&gt; -- E<br></p><p><br>Following up to myself, now that I&#39;m actually using this, I realize that avoiding using a build configuration test might not be the best idea from the developer experience side of things: <br></p><p>main.swift:7:9: warning: will never be executed<br>        print(&quot;Not debug assert configuration&quot;)<br>        ^<br>main.swift:4:8: note: condition always evaluates to true<br>    if isDebugAssertConfiguration() {<br>       ^<br>Testing debug assertion<br></p><p>Whereas going with if #if debugassert() would simply make code &quot;disappear&quot;.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/b3335d9f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
