<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52752079730726d693332706c65540b8?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Sangjin Han</string> &lt;tinysun.net at gmail.com&gt;<p>May  3, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello swift-evolution,<br></p><p>This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br></p><p>Here is the brief history. (To avoid confusion, I used MSVC refer to<br>*-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br></p><p>I needed the #if method to distinct MSVC from Cygwin, for mapping the Int<br>to CLongLong not CLong on MSVC.<br>In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to<br>*-*-windows-msvc from *-*-windows-*, this solved my problem.<br></p><p>Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never<br>fixed to avoid breaking user applications.<br>There is more  participants and opinions, briefly,<br>- introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>- the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>- fundamentally, what do we gain from asking which os() is in use?<br>- &#39;env()&#39; is too vague<br>- what the right questions?<br></p><p>Forgive me the poor quotations of valuable opinions.<br></p><p><br>I hope we find out the solution or method everybody satisfied.<br></p><p><br>-Han Sangjin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/d2680de2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d82ae2358637a4680638eb4218c1e64a?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>hitstergtd+swiftevo at gmail.com</string> &lt;hitstergtd+swiftevo at gmail.com&gt;<p>May  3, 2016 at 10:00:00am</p></header><div class="content"><p>Why is there a need to support Cygwin/MingW and their variants as a<br>build target for Windows? MSVC is practically free these days.<br></p><p>Doesn&#39;t supporting multiple different ABI targets on Windows just<br>complicate matters unnecessarily? Isn&#39;t MSVC enough as a build target?<br></p><p>I am not dejecting; rather, just wondering the actual need.<br></p><p>On 3 May 2016 at 06:00, Sangjin Han via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello swift-evolution,<br>&gt;<br>&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;<br>&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to<br>&gt; *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;<br>&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to<br>&gt; CLongLong not CLong on MSVC.<br>&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to<br>&gt; *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;<br>&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never<br>&gt; fixed to avoid breaking user applications.<br>&gt; There is more  participants and opinions, briefly,<br>&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt; - &#39;env()&#39; is too vague<br>&gt; - what the right questions?<br>&gt;<br>&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;<br>&gt;<br>&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;<br>&gt;<br>&gt; -Han Sangjin<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>May  3, 2016 at 09:00:00am</p></header><div class="content"><p>I wouldn&#39;t personally use a Cygwin or MinGW target these days, but I can<br>see why a Cygwin target would be useful in a Swift context. I suspect most<br>Swift code is either going to be written for iOS/Mac, or Linux server code,<br>including third-party libraries. Lots of Swift code will probably have some<br>POSIX calls that wouldn&#39;t otherwise be available on Windows.<br></p><p>On Tue, May 3, 2016 at 2:44 AM, hitstergtd+swiftevo--- via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Why is there a need to support Cygwin/MingW and their variants as a<br>&gt; build target for Windows? MSVC is practically free these days.<br>&gt;<br>&gt; Doesn&#39;t supporting multiple different ABI targets on Windows just<br>&gt; complicate matters unnecessarily? Isn&#39;t MSVC enough as a build target?<br>&gt;<br>&gt; I am not dejecting; rather, just wondering the actual need.<br>&gt;<br>&gt; On 3 May 2016 at 06:00, Sangjin Han via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello swift-evolution,<br>&gt; &gt;<br>&gt; &gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351<br>&gt; ).<br>&gt; &gt;<br>&gt; &gt; Here is the brief history. (To avoid confusion, I used MSVC refer to<br>&gt; &gt; *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt; &gt;<br>&gt; &gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the<br>&gt; Int to<br>&gt; &gt; CLongLong not CLong on MSVC.<br>&gt; &gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to<br>&gt; &gt; *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt; &gt;<br>&gt; &gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will<br>&gt; never<br>&gt; &gt; fixed to avoid breaking user applications.<br>&gt; &gt; There is more  participants and opinions, briefly,<br>&gt; &gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt; &gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt; &gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt; &gt; - &#39;env()&#39; is too vague<br>&gt; &gt; - what the right questions?<br>&gt; &gt;<br>&gt; &gt; Forgive me the poor quotations of valuable opinions.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I hope we find out the solution or method everybody satisfied.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; -Han Sangjin<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/0d9ffd39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>May  3, 2016 at 09:00:00am</p></header><div class="content"><p>Historically, that&#39;s been true. However, I wonder if the new Linux subsystem work for Windows changes this. <br></p><p>https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/<br></p><p>And further, will we need a check for this on Windows?<br></p><p>-David<br></p><p>Sent from my iPhone<br></p><p>&gt; On May 3, 2016, at 9:07 AM, Michael Buckley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wouldn&#39;t personally use a Cygwin or MinGW target these days, but I can see why a Cygwin target would be useful in a Swift context. I suspect most Swift code is either going to be written for iOS/Mac, or Linux server code, including third-party libraries. Lots of Swift code will probably have some POSIX calls that wouldn&#39;t otherwise be available on Windows.<br>&gt; <br>&gt;&gt; On Tue, May 3, 2016 at 2:44 AM, hitstergtd+swiftevo--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Why is there a need to support Cygwin/MingW and their variants as a<br>&gt;&gt; build target for Windows? MSVC is practically free these days.<br>&gt;&gt; <br>&gt;&gt; Doesn&#39;t supporting multiple different ABI targets on Windows just<br>&gt;&gt; complicate matters unnecessarily? Isn&#39;t MSVC enough as a build target?<br>&gt;&gt; <br>&gt;&gt; I am not dejecting; rather, just wondering the actual need.<br>&gt;&gt; <br>&gt;&gt; On 3 May 2016 at 06:00, Sangjin Han via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Hello swift-evolution,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Here is the brief history. (To avoid confusion, I used MSVC refer to<br>&gt;&gt; &gt; *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to<br>&gt;&gt; &gt; CLongLong not CLong on MSVC.<br>&gt;&gt; &gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to<br>&gt;&gt; &gt; *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never<br>&gt;&gt; &gt; fixed to avoid breaking user applications.<br>&gt;&gt; &gt; There is more  participants and opinions, briefly,<br>&gt;&gt; &gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt; &gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt; &gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt; &gt; - &#39;env()&#39; is too vague<br>&gt;&gt; &gt; - what the right questions?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Han Sangjin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/e766822d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>May  3, 2016 at 09:00:00am</p></header><div class="content"><p>I may be fundamentally misunderstanding the Windows Subsystem for Linux,<br>but I believe it just provides binary compatibility for Linux x86_64<br>command-line tools, but doesn&#39;t quite implement enough of the Linux<br>syscalls to run a Linux window manager in order to run GUI programs. So<br>it&#39;s certainly something you could compile your server code for if you<br>wanted to host on a Windows server, but it&#39;s not something you could use to<br>distribute client software.<br></p><p>On Tue, May 3, 2016 at 9:11 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br></p><p>&gt; Historically, that&#39;s been true. However, I wonder if the new Linux<br>&gt; subsystem work for Windows changes this.<br>&gt;<br>&gt;<br>&gt; https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/<br>&gt;<br>&gt; And further, will we need a check for this on Windows?<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On May 3, 2016, at 9:07 AM, Michael Buckley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I wouldn&#39;t personally use a Cygwin or MinGW target these days, but I can<br>&gt; see why a Cygwin target would be useful in a Swift context. I suspect most<br>&gt; Swift code is either going to be written for iOS/Mac, or Linux server code,<br>&gt; including third-party libraries. Lots of Swift code will probably have some<br>&gt; POSIX calls that wouldn&#39;t otherwise be available on Windows.<br>&gt;<br>&gt; On Tue, May 3, 2016 at 2:44 AM, hitstergtd+swiftevo--- via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Why is there a need to support Cygwin/MingW and their variants as a<br>&gt;&gt; build target for Windows? MSVC is practically free these days.<br>&gt;&gt;<br>&gt;&gt; Doesn&#39;t supporting multiple different ABI targets on Windows just<br>&gt;&gt; complicate matters unnecessarily? Isn&#39;t MSVC enough as a build target?<br>&gt;&gt;<br>&gt;&gt; I am not dejecting; rather, just wondering the actual need.<br>&gt;&gt;<br>&gt;&gt; On 3 May 2016 at 06:00, Sangjin Han via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Hello swift-evolution,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This is continued from PR #2351(<br>&gt;&gt; https://github.com/apple/swift/pull/2351).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Here is the brief history. (To avoid confusion, I used MSVC refer to<br>&gt;&gt; &gt; *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the<br>&gt;&gt; Int to<br>&gt;&gt; &gt; CLongLong not CLong on MSVC.<br>&gt;&gt; &gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to<br>&gt;&gt; &gt; *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will<br>&gt;&gt; never<br>&gt;&gt; &gt; fixed to avoid breaking user applications.<br>&gt;&gt; &gt; There is more  participants and opinions, briefly,<br>&gt;&gt; &gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt; &gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt; &gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt; &gt; - &#39;env()&#39; is too vague<br>&gt;&gt; &gt; - what the right questions?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Han Sangjin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/04becadb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 3, 2016, at 9:22 AM, Michael Buckley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I may be fundamentally misunderstanding the Windows Subsystem for Linux, but I believe it just provides binary compatibility for Linux x86_64 command-line tools, but doesn&#39;t quite implement enough of the Linux syscalls to run a Linux window manager in order to run GUI programs. So it&#39;s certainly something you could compile your server code for if you wanted to host on a Windows server, but it&#39;s not something you could use to distribute client software.<br></p><p>I want to stop this thread of the conversation here.  This is not a general technology discussion forum; it&#39;s not our place to second-guess whether Cygwin is useful.  The Swift project&#39;s primary criterion for accepting a port is whether there are contributors willing to maintain it.  That&#39;s not the only criterion — I could certainly imagine ports that would be too burdensome on the compiler to be worth trying to support, like a platform with a 12-bit byte — but I have seen no argument that the Cygwin port comes close to crossing that line.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 9:35 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 3, 2016, at 9:22 AM, Michael Buckley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I may be fundamentally misunderstanding the Windows Subsystem for Linux, but I believe it just provides binary compatibility for Linux x86_64 command-line tools, but doesn&#39;t quite implement enough of the Linux syscalls to run a Linux window manager in order to run GUI programs. So it&#39;s certainly something you could compile your server code for if you wanted to host on a Windows server, but it&#39;s not something you could use to distribute client software.<br>&gt; <br>&gt; I want to stop this thread of the conversation here.  This is not a general technology discussion forum; it&#39;s not our place to second-guess whether Cygwin is useful.  The Swift project&#39;s primary criterion for accepting a port is whether there are contributors willing to maintain it. <br></p><p>+1.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 3, 2016, at 2:44 AM, hitstergtd+swiftevo--- via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why is there a need to support Cygwin/MingW and their variants as a<br>&gt; build target for Windows? MSVC is practically free these days.<br></p><p>Cygwin at least is still valuable for providing a more POSIX-like environment for portability, without the Win32 interop barriers that the old NT POSIX subsystem (and presumably the new Linux syscall layer thing) have. At the language level, MSVC&#39;s C and C++ frontends are still fairly idiosyncratic compared to GCC or Clang, so I know a number of people who prefer Mingw on those grounds too.<br></p><p>-Joe<br></p><p>&gt; Doesn&#39;t supporting multiple different ABI targets on Windows just<br>&gt; complicate matters unnecessarily? Isn&#39;t MSVC enough as a build target?<br>&gt; <br>&gt; I am not dejecting; rather, just wondering the actual need.<br>&gt; <br>&gt; On 3 May 2016 at 06:00, Sangjin Han via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;&gt; <br>&gt;&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to<br>&gt;&gt; *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt; <br>&gt;&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to<br>&gt;&gt; CLongLong not CLong on MSVC.<br>&gt;&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to<br>&gt;&gt; *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt; <br>&gt;&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never<br>&gt;&gt; fixed to avoid breaking user applications.<br>&gt;&gt; There is more  participants and opinions, briefly,<br>&gt;&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt; - &#39;env()&#39; is too vague<br>&gt;&gt; - what the right questions?<br>&gt;&gt; <br>&gt;&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Han Sangjin<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May  3, 2016 at 11:00:00am</p></header><div class="content"><p>We’ve had this kind of thing come up before, too, with the Linux/FreeBSD/Android group vs. the OSX/iOS/watchOS/tvOS group, or with 32-bit architectures vs. 64-bit architectures. Erica Sadun wrote up quite a few of the choices here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/12161/<br></p><p>…none of which quite match the MSVC vs. Cygwin distinction. (And where does MinGW fit in?)<br></p><p>(I think there was another thread with even more possible platform conditions, but I can’t find it.)<br></p><p>One thing that I’d like to keep is that os(…) (like arch(…)) is (a) non-overlapping and (b) covers everything, i.e. there should never be a platform Swift supports for which no os(…) predicate is true. That doesn’t have to be the case for other, new predicates, though.<br></p><p>I think one of the big questions (already identified in this thread) is “how often does the same code apply for both Cygwin and Windows?” If the answer is “pretty much never” or even “rarely&quot;, then treating them as separate “OSs” seems fine—in the rare case someone can use “os(Windows) || os(Cygwin)”. However, if the answer is “most of the time” (leaving the standard library out of it, since that’s not representative of average user code), then it feels like the common “os(Windows)” predicate makes more sense, and we should come up with something else to distinguish them.<br></p><p>(Again, “where does MinGW fit in?” might help clarify this direction.)<br></p><p>We’re also free to rename things in this discussion. If it turns out there’s a better word than “os”, we can switch to it.<br></p><p>Jordan<br></p><p><br></p><p>&gt; On May 2, 2016, at 22:00, Sangjin Han via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351 &lt;https://github.com/apple/swift/pull/2351&gt;).<br>&gt; <br>&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt; <br>&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to CLongLong not CLong on MSVC.<br>&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt; <br>&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never fixed to avoid breaking user applications.<br>&gt; There is more  participants and opinions, briefly,<br>&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt; - &#39;env()&#39; is too vague<br>&gt; - what the right questions?<br>&gt; <br>&gt; Forgive me the poor quotations of valuable opinions.<br>&gt; <br>&gt; <br>&gt; I hope we find out the solution or method everybody satisfied.<br>&gt; <br>&gt; <br>&gt; -Han Sangjin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/f8e87508/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 11:43 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We’ve had this kind of thing come up before, too, with the Linux/FreeBSD/Android group vs. the OSX/iOS/watchOS/tvOS group, or with 32-bit architectures vs. 64-bit architectures. Erica Sadun wrote up quite a few of the choices here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/12161/<br>&gt; <br>&gt; …none of which quite match the MSVC vs. Cygwin distinction. (And where does MinGW fit in?)<br>&gt; <br>&gt; (I think there was another thread with even more possible platform conditions, but I can’t find it.)<br>&gt; <br>&gt; One thing that I’d like to keep is that os(…) (like arch(…)) is (a) non-overlapping and (b) covers everything, i.e. there should never be a platform Swift supports for which no os(…) predicate is true. That doesn’t have to be the case for other, new predicates, though.<br>&gt; <br>&gt; I think one of the big questions (already identified in this thread) is “how often does the same code apply for both Cygwin and Windows?” If the answer is “pretty much never” or even “rarely&quot;, then treating them as separate “OSs” seems fine—in the rare case someone can use “os(Windows) || os(Cygwin)”. However, if the answer is “most of the time” (leaving the standard library out of it, since that’s not representative of average user code), then it feels like the common “os(Windows)” predicate makes more sense, and we should come up with something else to distinguish them.<br>&gt; <br>&gt; (Again, “where does MinGW fit in?” might help clarify this direction.)<br></p><p>Windows doesn&#39;t specify a standard C or C++ ABI, and until recently didn&#39;t even provide a common C runtime in the OS, so Cygwin/Mingw and MSVC are essentially completely different C environments. Cygwin and Mingw are more similar to each other ABI-wise, both being derived from GCC, but differ widely in the C APIs they provide, since Cygwin aims to provide a more complete POSIX-like environment, whereas Mingw only provides an implementation the standard C libraries. Where there&#39;s overlap between Cygwin, Mingw, and MSVC is in the Win32 system APIs, which do have de-facto standard ABIs. To me, this suggests considering them to be different &quot;os&quot; environments, but grouping them together under some new higher-level condition. Much like you could group Linux, BSD, and MacOS in a &quot;POSIX&quot; umbrella, Cygwin, Mingw, and MSVC could be grouped under a &quot;Win32&quot; umbrella (though Cygwin straddles the line somewhat).<br></p><p>-Joe<br></p><p>&gt; We’re also free to rename things in this discussion. If it turns out there’s a better word than “os”, we can switch to it.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 2, 2016, at 22:00, Sangjin Han via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;&gt; <br>&gt;&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt; <br>&gt;&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to CLongLong not CLong on MSVC.<br>&gt;&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt; <br>&gt;&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never fixed to avoid breaking user applications.<br>&gt;&gt; There is more  participants and opinions, briefly,<br>&gt;&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt; - &#39;env()&#39; is too vague<br>&gt;&gt; - what the right questions?<br>&gt;&gt; <br>&gt;&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Han Sangjin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On May 3, 2016, at 11:43 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We’ve had this kind of thing come up before, too, with the Linux/FreeBSD/Android group vs. the OSX/iOS/watchOS/tvOS group, or with 32-bit architectures vs. 64-bit architectures. Erica Sadun wrote up quite a few of the choices here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/12161/<br>&gt;&gt; <br>&gt;&gt; …none of which quite match the MSVC vs. Cygwin distinction. (And where does MinGW fit in?)<br>&gt;&gt; <br>&gt;&gt; (I think there was another thread with even more possible platform conditions, but I can’t find it.)<br>&gt;&gt; <br>&gt;&gt; One thing that I’d like to keep is that os(…) (like arch(…)) is (a) non-overlapping and (b) covers everything, i.e. there should never be a platform Swift supports for which no os(…) predicate is true. That doesn’t have to be the case for other, new predicates, though.<br>&gt;&gt; <br>&gt;&gt; I think one of the big questions (already identified in this thread) is “how often does the same code apply for both Cygwin and Windows?” If the answer is “pretty much never” or even “rarely&quot;, then treating them as separate “OSs” seems fine—in the rare case someone can use “os(Windows) || os(Cygwin)”. However, if the answer is “most of the time” (leaving the standard library out of it, since that’s not representative of average user code), then it feels like the common “os(Windows)” predicate makes more sense, and we should come up with something else to distinguish them.<br>&gt;&gt; <br>&gt;&gt; (Again, “where does MinGW fit in?” might help clarify this direction.)<br>&gt; <br>&gt; Windows doesn&#39;t specify a standard C or C++ ABI, and until recently didn&#39;t even provide a common C runtime in the OS, so Cygwin/Mingw and MSVC are essentially completely different C environments. Cygwin and Mingw are more similar to each other ABI-wise, both being derived from GCC, but differ widely in the C APIs they provide, since Cygwin aims to provide a more complete POSIX-like environment, whereas Mingw only provides an implementation the standard C libraries. Where there&#39;s overlap between Cygwin, Mingw, and MSVC is in the Win32 system APIs, which do have de-facto standard ABIs. To me, this suggests considering them to be different &quot;os&quot; environments, but grouping them together under some new higher-level condition. Much like you could group Linux, BSD, and MacOS in a &quot;POSIX&quot; umbrella, Cygwin, Mingw, and MSVC could be grouped under a &quot;Win32&quot; umbrella (though Cygwin straddles the line somewhat).<br></p><p>Should we have a condition that checks for these broad API sets, then?  API(POSIX), API(Windows), etc.?<br></p><p>Possible direction for growth: checking for the availability of a specific library, like #if hasLibrary(libjpeg).<br></p><p>John.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; We’re also free to rename things in this discussion. If it turns out there’s a better word than “os”, we can switch to it.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 22:00, Sangjin Han via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to CLongLong not CLong on MSVC.<br>&gt;&gt;&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never fixed to avoid breaking user applications.<br>&gt;&gt;&gt; There is more  participants and opinions, briefly,<br>&gt;&gt;&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt;&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt;&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt;&gt; - &#39;env()&#39; is too vague<br>&gt;&gt;&gt; - what the right questions?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Han Sangjin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/9e60c3f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 12:29 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 3, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On May 3, 2016, at 11:43 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We’ve had this kind of thing come up before, too, with the Linux/FreeBSD/Android group vs. the OSX/iOS/watchOS/tvOS group, or with 32-bit architectures vs. 64-bit architectures. Erica Sadun wrote up quite a few of the choices here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/12161/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …none of which quite match the MSVC vs. Cygwin distinction. (And where does MinGW fit in?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (I think there was another thread with even more possible platform conditions, but I can’t find it.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thing that I’d like to keep is that os(…) (like arch(…)) is (a) non-overlapping and (b) covers everything, i.e. there should never be a platform Swift supports for which no os(…) predicate is true. That doesn’t have to be the case for other, new predicates, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think one of the big questions (already identified in this thread) is “how often does the same code apply for both Cygwin and Windows?” If the answer is “pretty much never” or even “rarely&quot;, then treating them as separate “OSs” seems fine—in the rare case someone can use “os(Windows) || os(Cygwin)”. However, if the answer is “most of the time” (leaving the standard library out of it, since that’s not representative of average user code), then it feels like the common “os(Windows)” predicate makes more sense, and we should come up with something else to distinguish them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Again, “where does MinGW fit in?” might help clarify this direction.)<br>&gt;&gt; <br>&gt;&gt; Windows doesn&#39;t specify a standard C or C++ ABI, and until recently didn&#39;t even provide a common C runtime in the OS, so Cygwin/Mingw and MSVC are essentially completely different C environments. Cygwin and Mingw are more similar to each other ABI-wise, both being derived from GCC, but differ widely in the C APIs they provide, since Cygwin aims to provide a more complete POSIX-like environment, whereas Mingw only provides an implementation the standard C libraries. Where there&#39;s overlap between Cygwin, Mingw, and MSVC is in the Win32 system APIs, which do have de-facto standard ABIs. To me, this suggests considering them to be different &quot;os&quot; environments, but grouping them together under some new higher-level condition. Much like you could group Linux, BSD, and MacOS in a &quot;POSIX&quot; umbrella, Cygwin, Mingw, and MSVC could be grouped under a &quot;Win32&quot; umbrella (though Cygwin straddles the line somewhat).<br>&gt; <br>&gt; Should we have a condition that checks for these broad API sets, then?  API(POSIX), API(Windows), etc.?<br>&gt; <br>&gt; Possible direction for growth: checking for the availability of a specific library, like #if hasLibrary(libjpeg).<br></p><p>Yeah, in a previous thread the idea came up of an `imports(Module)` condition that would be true when Module was available for import. If we eventually grew standard POSIX and Win32 modules, that could cover those use cases.<br></p><p>-Joe<br></p><p>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; We’re also free to rename things in this discussion. If it turns out there’s a better word than “os”, we can switch to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 2, 2016, at 22:00, Sangjin Han via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to CLongLong not CLong on MSVC.<br>&gt;&gt;&gt;&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never fixed to avoid breaking user applications.<br>&gt;&gt;&gt;&gt; There is more  participants and opinions, briefly,<br>&gt;&gt;&gt;&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt;&gt;&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt;&gt;&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt;&gt;&gt; - &#39;env()&#39; is too vague<br>&gt;&gt;&gt;&gt; - what the right questions?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Han Sangjin<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9db7e0c3d3ce86e2bf80675a61fbc49c?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>James Berry</string> &lt;jberry at rogueorbit.com&gt;<p>May  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 12:15 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 3, 2016, at 11:43 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>...<br>&gt;&gt; <br>&gt;&gt; One thing that I’d like to keep is that os(…) (like arch(…)) is (a) non-overlapping and (b) covers everything, i.e. there should never be a platform Swift supports for which no os(…) predicate is true. That doesn’t have to be the case for other, new predicates, though.<br></p><p>So if os(…) should be exclusive, then os(Windows) should presumably cover Windows, Cygwin, and Mingw.<br></p><p>But it seems like there’s an argument for some new predicate that is not exclusive… see below...<br></p><p>&gt;&gt; <br>&gt;&gt; I think one of the big questions (already identified in this thread) is “how often does the same code apply for both Cygwin and Windows?” If the answer is “pretty much never” or even “rarely&quot;, then treating them as separate “OSs” seems fine—in the rare case someone can use “os(Windows) || os(Cygwin)”. However, if the answer is “most of the time” (leaving the standard library out of it, since that’s not representative of average user code), then it feels like the common “os(Windows)” predicate makes more sense, and we should come up with something else to distinguish them.<br>&gt;&gt; <br>&gt;&gt; (Again, “where does MinGW fit in?” might help clarify this direction.)<br>&gt; <br>&gt; Windows doesn&#39;t specify a standard C or C++ ABI, and until recently didn&#39;t even provide a common C runtime in the OS, so Cygwin/Mingw and MSVC are essentially completely different C environments. Cygwin and Mingw are more similar to each other ABI-wise, both being derived from GCC, but differ widely in the C APIs they provide, since Cygwin aims to provide a more complete POSIX-like environment, whereas Mingw only provides an implementation the standard C libraries. Where there&#39;s overlap between Cygwin, Mingw, and MSVC is in the Win32 system APIs, which do have de-facto standard ABIs. To me, this suggests considering them to be different &quot;os&quot; environments, but grouping them together under some new higher-level condition. Much like you could group Linux, BSD, and MacOS in a &quot;POSIX&quot; umbrella, Cygwin, Mingw, and MSVC could be<br>&gt; grouped under a &quot;Win32&quot; umbrella (though Cygwin straddles the line somewhat).<br></p><p>Right, so maybe there’s an api(…) predicate, that is not exclusive, that tells what api famiilies are supported.<br></p><p>MSVC would return true for api(Win32)<br>Cygwin would indicate api(Win32) and api(POSIX) maybe<br>Mingw: api(Win32) (don’t know what else as I don’t know much about Mingw)<br></p><p>Maybe this is also a way to indicate flavors of linux support, i.e., a linux API system might indicate api(linux) and api(posix), while a MacOSX system might indicate api(posix), api(darwin), api(macosx), api(BSD), (or whatever).<br></p><p>James<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; We’re also free to rename things in this discussion. If it turns out there’s a better word than “os”, we can switch to it.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 22:00, Sangjin Han via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to CLongLong not CLong on MSVC.<br>&gt;&gt;&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never fixed to avoid breaking user applications.<br>&gt;&gt;&gt; There is more  participants and opinions, briefly,<br>&gt;&gt;&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt;&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt;&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt;&gt; - &#39;env()&#39; is too vague<br>&gt;&gt;&gt; - what the right questions?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Han Sangjin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  3, 2016 at 09:00:00pm</p></header><div class="content"><p>On May 3, 2016, at 11:43 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; We’ve had this kind of thing come up before, too, with the Linux/FreeBSD/Android group vs. the OSX/iOS/watchOS/tvOS group, or with 32-bit architectures vs. 64-bit architectures. Erica Sadun wrote up quite a few of the choices here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/12161/ &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/12161/&gt;<br>&gt; <br>&gt; …none of which quite match the MSVC vs. Cygwin distinction. (And where does MinGW fit in?)<br></p><p>I am not a windows guru (and haven’t used it for over a decade) but my understanding is that Cygwin is a different target (as in different target triple, different ABI, different environment) from MSVC and MinGW.  If that is the case, it should be its own “arch” or “os”.  MSVC and MinGW (again, AFAIK) use the same C ABI, and thus could be treated as the same target.<br></p><p>I think it would be defensible to treat MSVC/MinGW as an os(Windows) but treat Cygwin as os(Cygwin).<br></p><p>How do other languages handle this?  What does dlang do, for example?<br></p><p>-Chris<br></p><p><br></p><p>&gt; <br>&gt; (I think there was another thread with even more possible platform conditions, but I can’t find it.)<br>&gt; <br>&gt; One thing that I’d like to keep is that os(…) (like arch(…)) is (a) non-overlapping and (b) covers everything, i.e. there should never be a platform Swift supports for which no os(…) predicate is true. That doesn’t have to be the case for other, new predicates, though.<br>&gt; <br>&gt; I think one of the big questions (already identified in this thread) is “how often does the same code apply for both Cygwin and Windows?” If the answer is “pretty much never” or even “rarely&quot;, then treating them as separate “OSs” seems fine—in the rare case someone can use “os(Windows) || os(Cygwin)”. However, if the answer is “most of the time” (leaving the standard library out of it, since that’s not representative of average user code), then it feels like the common “os(Windows)” predicate makes more sense, and we should come up with something else to distinguish them.<br>&gt; <br>&gt; (Again, “where does MinGW fit in?” might help clarify this direction.)<br>&gt; <br>&gt; We’re also free to rename things in this discussion. If it turns out there’s a better word than “os”, we can switch to it.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 2, 2016, at 22:00, Sangjin Han via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351 &lt;https://github.com/apple/swift/pull/2351&gt;).<br>&gt;&gt; <br>&gt;&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt; <br>&gt;&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to CLongLong not CLong on MSVC.<br>&gt;&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt; <br>&gt;&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never fixed to avoid breaking user applications.<br>&gt;&gt; There is more  participants and opinions, briefly,<br>&gt;&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt; - &#39;env()&#39; is too vague<br>&gt;&gt; - what the right questions?<br>&gt;&gt; <br>&gt;&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Han Sangjin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/ceeb20ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 9:27 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MSVC and MinGW (again, AFAIK) use the same C ABI, and thus could be treated as the same target.<br>&gt; <br>Part of the problem is that MSVC and Mingw *don&#39;t* share a C ABI or runtime. Only &#39;stdcall&#39; and COM stuff from the Win32 system APIs is portable between them at the binary level. <br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 9:39 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 3, 2016, at 9:27 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; MSVC and MinGW (again, AFAIK) use the same C ABI, and thus could be treated as the same target.<br>&gt;&gt; <br>&gt; Part of the problem is that MSVC and Mingw *don&#39;t* share a C ABI or runtime. Only &#39;stdcall&#39; and COM stuff from the Win32 system APIs is portable between them at the binary level. <br></p><p>I thought that MinGW worked with the system libc?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 9:40 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 3, 2016, at 9:39 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 3, 2016, at 9:27 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; MSVC and MinGW (again, AFAIK) use the same C ABI, and thus could be treated as the same target.<br>&gt;&gt;&gt; <br>&gt;&gt; Part of the problem is that MSVC and Mingw *don&#39;t* share a C ABI or runtime. Only &#39;stdcall&#39; and COM stuff from the Win32 system APIs is portable between them at the binary level. <br>&gt; <br>&gt; I thought that MinGW worked with the system libc?<br></p><p>There&#39;s no such thing on Windows (at least, until Windows 10, which introduced yet another &quot;universal&quot; C runtime). Older versions of mingw used to link against MSVCRT.DLL, which was an unsupported vintage C runtime intended for SPI use only, but now use their own glibc-derived C library.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 9:43 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 3, 2016, at 9:40 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 3, 2016, at 9:39 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 3, 2016, at 9:27 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; MSVC and MinGW (again, AFAIK) use the same C ABI, and thus could be treated as the same target.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; Part of the problem is that MSVC and Mingw *don&#39;t* share a C ABI or runtime. Only &#39;stdcall&#39; and COM stuff from the Win32 system APIs is portable between them at the binary level. <br>&gt;&gt; <br>&gt;&gt; I thought that MinGW worked with the system libc?<br>&gt; <br>&gt; There&#39;s no such thing on Windows (at least, until Windows 10, which introduced yet another &quot;universal&quot; C runtime). Older versions of mingw used to link against MSVCRT.DLL, which was an unsupported vintage C runtime intended for SPI use only, but now use their own glibc-derived C library.<br></p><p>Huh ok.  Well, I guess it too is its own OS or architecture.  Does anyone know how dlang or another language that grew-up-on-windows-then-got-ported-to-gcc-and-llvm handles this?<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d82ae2358637a4680638eb4218c1e64a?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>hitstergtd+swiftevo at gmail.com</string> &lt;hitstergtd+swiftevo at gmail.com&gt;<p>May  4, 2016 at 05:00:00am</p></header><div class="content"><p>Dear Joe, Chris, Swift Community,<br></p><p>Here is my quick fire view.<br></p><p>What about adding a builtin directive called environ(...) for holding<br>OS-specific environmental differences. So in the case of Windows, we would<br>potentially have environ(msvc), environ(cygwin), environ(mingw),<br>environ(nano) etc. Thus, having environment as a separate builtin directive<br>allows Swift and its users to cleanly handle significant divergence on a<br>single operating system by way of combinations.<br></p><p>Similarly, an environ(posix) could also be added in the same spirit, in the<br>future, if required, if a POSIX specific environment is required.<br></p><p>The good thing about the above is that it can be intuitively used to build<br>combinations such as the following and has good readability:<br></p><p>#if os(Windows)<br>// ... common stuff to Windows in general<br>#if environ(Cygwin) and arch(x86_64)<br>// ... specific stuff of Cygwin on 64-bit arch<br>#elseif environ(msvc)<br>// ... stuff specific to MSVC generally<br>#endif<br></p><p>#else<br>// ... Non Windows stuff.<br>#endif<br></p><p>Chris, for your reference, the following is how D does it:<br>https://dlang.org/spec/version.html#predefined-versions. TL;DR - precursory<br>look indicates that they cobble everything into version() with predefined<br>identifiers.<br></p><p>I have specifically left out any comments on OS versions such as Vista,<br>Windows 7 etc., as I am not sure on how it should be handled, either<br>presently or as a proposal. As for Cygwin and MinGW, I am not sure if it<br>should be called cygwin32 and mingw32 with their 64-bit analogues,<br>respectively, but AFAICS, not suffixing with 32 and 64 seems much cleaner.<br></p><p>Thanks.<br></p><p>On Wed, 4 May 2016 at 05:41, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 3, 2016, at 9:39 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 3, 2016, at 9:27 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; MSVC and MinGW (again, AFAIK) use the same C ABI, and thus could be<br>&gt; treated as the same target.<br>&gt; &gt;&gt;<br>&gt; &gt; Part of the problem is that MSVC and Mingw *don&#39;t* share a C ABI or<br>&gt; runtime. Only &#39;stdcall&#39; and COM stuff from the Win32 system APIs is<br>&gt; portable between them at the binary level.<br>&gt;<br>&gt; I thought that MinGW worked with the system libc?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/26f27bd2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52752079730726d693332706c65540b8?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Sangjin Han</string> &lt;tinysun.net at gmail.com&gt;<p>May  4, 2016 at 03:00:00pm</p></header><div class="content"><p>Dear Swift Community,<br></p><p>I think that the `imports(Module)` condition is more reasonable than &#39;os()&#39;<br>in writing module applications. But we need another condition, as this case<br>was origin to distinct LLP64 from LP64 for the library.<br></p><p>I hope we get any condition which can equivalent or covering &#39;triple()&#39; for<br>the following code.<br></p><p> (in core/CTypes.swift)<br></p><p> /// The C &#39;long&#39; type.<br> +#if triple(x86_64-*-windows-msvc) || triple(x86_64-*-windows-gnu)<br> +public typealias CLong = Int32<br> +#else<br>  public typealias CLong = Int<br> +#endif<br></p><p>  /// The C &#39;long long&#39; type.<br> +#if triple(x86_64-*-windows-msvc) || triple(x86_64-*-windows-gnu)<br> +public typealias CLongLong = Int<br> +#else<br>  public typealias CLongLong = Int64<br> +#endif<br></p><p>Moreover, it will be required to distinct MinGW(*-*-windows-gnu) from<br>*-*-windows-msvc, because MinGW and Cygwin can support Float80 differently<br>from MSVC.<br></p><p>We already have the &#39;arch()&#39; for the first part of the triple. How about<br>&#39;environ(windows-msvc)&#39;, &#39;environ(windows-cygnus)&#39; for portable module<br>writers to cover full triple?<br></p><p><br>- Han Sangjin<br></p><p><br>2016-05-04 14:31 GMT+09:00 hitstergtd+swiftevo--- via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Dear Joe, Chris, Swift Community,<br>&gt;<br>&gt; Here is my quick fire view.<br>&gt;<br>&gt; What about adding a builtin directive called environ(...) for holding<br>&gt; OS-specific environmental differences. So in the case of Windows, we would<br>&gt; potentially have environ(msvc), environ(cygwin), environ(mingw),<br>&gt; environ(nano) etc. Thus, having environment as a separate builtin directive<br>&gt; allows Swift and its users to cleanly handle significant divergence on a<br>&gt; single operating system by way of combinations.<br>&gt;<br>&gt; Similarly, an environ(posix) could also be added in the same spirit, in<br>&gt; the future, if required, if a POSIX specific environment is required.<br>&gt;<br>&gt; The good thing about the above is that it can be intuitively used to build<br>&gt; combinations such as the following and has good readability:<br>&gt;<br>&gt; #if os(Windows)<br>&gt; // ... common stuff to Windows in general<br>&gt; #if environ(Cygwin) and arch(x86_64)<br>&gt; // ... specific stuff of Cygwin on 64-bit arch<br>&gt; #elseif environ(msvc)<br>&gt; // ... stuff specific to MSVC generally<br>&gt; #endif<br>&gt;<br>&gt; #else<br>&gt; // ... Non Windows stuff.<br>&gt; #endif<br>&gt;<br>&gt; Chris, for your reference, the following is how D does it:<br>&gt; https://dlang.org/spec/version.html#predefined-versions. TL;DR -<br>&gt; precursory look indicates that they cobble everything into version() with<br>&gt; predefined identifiers.<br>&gt;<br>&gt; I have specifically left out any comments on OS versions such as Vista,<br>&gt; Windows 7 etc., as I am not sure on how it should be handled, either<br>&gt; presently or as a proposal. As for Cygwin and MinGW, I am not sure if it<br>&gt; should be called cygwin32 and mingw32 with their 64-bit analogues,<br>&gt; respectively, but AFAICS, not suffixing with 32 and 64 seems much cleaner.<br>&gt;<br>&gt; Thanks.<br>&gt;<br>&gt; On Wed, 4 May 2016 at 05:41, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On May 3, 2016, at 9:39 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On May 3, 2016, at 9:27 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; MSVC and MinGW (again, AFAIK) use the same C ABI, and thus could be<br>&gt;&gt; treated as the same target.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; Part of the problem is that MSVC and Mingw *don&#39;t* share a C ABI or<br>&gt;&gt; runtime. Only &#39;stdcall&#39; and COM stuff from the Win32 system APIs is<br>&gt;&gt; portable between them at the binary level.<br>&gt;&gt;<br>&gt;&gt; I thought that MinGW worked with the system libc?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/7dca3389/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May  4, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>just a quick question... would it maybe be feasible or practical to have &quot;sub-OSes&quot;, like e.g. `#if os(Windows.MSVC)`, `#if os(Windows.Cygwin)` or `#if os(Windows.MinGW)`?<br></p><p>-Michael<br></p><p>&gt; Am 03.05.2016 um 20:43 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; We’ve had this kind of thing come up before, too, with the Linux/FreeBSD/Android group vs. the OSX/iOS/watchOS/tvOS group, or with 32-bit architectures vs. 64-bit architectures. Erica Sadun wrote up quite a few of the choices here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/12161/<br>&gt; <br>&gt; …none of which quite match the MSVC vs. Cygwin distinction. (And where does MinGW fit in?)<br>&gt; <br>&gt; (I think there was another thread with even more possible platform conditions, but I can’t find it.)<br>&gt; <br>&gt; One thing that I’d like to keep is that os(…) (like arch(…)) is (a) non-overlapping and (b) covers everything, i.e. there should never be a platform Swift supports for which no os(…) predicate is true. That doesn’t have to be the case for other, new predicates, though.<br>&gt; <br>&gt; I think one of the big questions (already identified in this thread) is “how often does the same code apply for both Cygwin and Windows?” If the answer is “pretty much never” or even “rarely&quot;, then treating them as separate “OSs” seems fine—in the rare case someone can use “os(Windows) || os(Cygwin)”. However, if the answer is “most of the time” (leaving the standard library out of it, since that’s not representative of average user code), then it feels like the common “os(Windows)” predicate makes more sense, and we should come up with something else to distinguish them.<br>&gt; <br>&gt; (Again, “where does MinGW fit in?” might help clarify this direction.)<br>&gt; <br>&gt; We’re also free to rename things in this discussion. If it turns out there’s a better word than “os”, we can switch to it.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 2, 2016, at 22:00, Sangjin Han via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;&gt; <br>&gt;&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt; <br>&gt;&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to CLongLong not CLong on MSVC.<br>&gt;&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt; <br>&gt;&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never fixed to avoid breaking user applications.<br>&gt;&gt; There is more  participants and opinions, briefly,<br>&gt;&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt; - &#39;env()&#39; is too vague<br>&gt;&gt; - what the right questions?<br>&gt;&gt; <br>&gt;&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Han Sangjin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>#if os(Windows) and MSVC/Cygwin Compatibility</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May  4, 2016 at 09:00:00am</p></header><div class="content"><p>This is clever, but I’m not sure it’d get used anywhere else. In particular, I don’t think we want to demote the Apple OSs to be “Apple.OSX” and “Apple.iOS”, even though asking “am I on an Apple platform” is a reasonable question. Similarly, “POSIX?” is a reasonable query to ask of most OSs, but doesn’t fit into a hierarchy.<br></p><p>That said, sub-OSs of “Linux” would probably make plenty of sense…other than when a distro is forked. Hm.<br></p><p>Jordan<br></p><p><br>&gt; On May 4, 2016, at 09:07, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; just a quick question... would it maybe be feasible or practical to have &quot;sub-OSes&quot;, like e.g. `#if os(Windows.MSVC)`, `#if os(Windows.Cygwin)` or `#if os(Windows.MinGW)`?<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 03.05.2016 um 20:43 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; We’ve had this kind of thing come up before, too, with the Linux/FreeBSD/Android group vs. the OSX/iOS/watchOS/tvOS group, or with 32-bit architectures vs. 64-bit architectures. Erica Sadun wrote up quite a few of the choices here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/12161/<br>&gt;&gt; <br>&gt;&gt; …none of which quite match the MSVC vs. Cygwin distinction. (And where does MinGW fit in?)<br>&gt;&gt; <br>&gt;&gt; (I think there was another thread with even more possible platform conditions, but I can’t find it.)<br>&gt;&gt; <br>&gt;&gt; One thing that I’d like to keep is that os(…) (like arch(…)) is (a) non-overlapping and (b) covers everything, i.e. there should never be a platform Swift supports for which no os(…) predicate is true. That doesn’t have to be the case for other, new predicates, though.<br>&gt;&gt; <br>&gt;&gt; I think one of the big questions (already identified in this thread) is “how often does the same code apply for both Cygwin and Windows?” If the answer is “pretty much never” or even “rarely&quot;, then treating them as separate “OSs” seems fine—in the rare case someone can use “os(Windows) || os(Cygwin)”. However, if the answer is “most of the time” (leaving the standard library out of it, since that’s not representative of average user code), then it feels like the common “os(Windows)” predicate makes more sense, and we should come up with something else to distinguish them.<br>&gt;&gt; <br>&gt;&gt; (Again, “where does MinGW fit in?” might help clarify this direction.)<br>&gt;&gt; <br>&gt;&gt; We’re also free to rename things in this discussion. If it turns out there’s a better word than “os”, we can switch to it.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 22:00, Sangjin Han via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is continued from PR #2351(https://github.com/apple/swift/pull/2351).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is the brief history. (To avoid confusion, I used MSVC refer to *-*-windows-msvc and Cygwin refer to *-*-windows-cygnus in LLVM.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I needed the #if method to distinct MSVC from Cygwin, for mapping the Int to CLongLong not CLong on MSVC.<br>&gt;&gt;&gt; In PR #2351, I simply added &#39;os(Cygwin)&#39; and restrict &#39;os(Windows)&#39; to *-*-windows-msvc from *-*-windows-*, this solved my problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jake(@jakepetroules) pointed out that Cygwin is not an OS and it will never fixed to avoid breaking user applications.<br>&gt;&gt;&gt; There is more  participants and opinions, briefly,<br>&gt;&gt;&gt; - introduce another new one such as &#39;env(cygnus)&#39; or &#39;triple(Cygwin)&#39;<br>&gt;&gt;&gt; - the usability of the common condition &#39;os(Windows)&#39; for *-*-windows-*<br>&gt;&gt;&gt; - fundamentally, what do we gain from asking which os() is in use?<br>&gt;&gt;&gt; - &#39;env()&#39; is too vague<br>&gt;&gt;&gt; - what the right questions?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Forgive me the poor quotations of valuable opinions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope we find out the solution or method everybody satisfied.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Han Sangjin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
