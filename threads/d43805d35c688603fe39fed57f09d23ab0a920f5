<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December  4, 2015 at 11:00:00pm</p></header><div class="content"><p>There’s lots of boilerplate of initializing structs with stored properties<br>and initializer parameters. I’d like to create a syntax for alleviating<br>that in the 90% case.<br></p><p>```swift<br>struct Foo {<br>    let bar: String<br>    let baz: Int<br></p><p>    init(self.bar: String = &quot;default&quot;, counter self.baz: Int) {<br>    }<br>}<br>```<br></p><p>This would be identical to:<br>```swift<br>struct Foo {<br>    let bar: String<br>    let baz: Int<br></p><p>    init(bar: String = &quot;default&quot;, counter baz: Int) {<br>        self.bar = bar<br>        self.baz = baz<br>    }<br>}<br>```<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/d43820f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>December  5, 2015 at 03:00:00am</p></header><div class="content"><p>I&#39;m not sure how I feel about this, but in either case, why limit it to<br>default parameters? It&#39;s useful in other situations, too.<br></p><p>Take this for example:<br>struct Foo {<br>    let bar: String<br>    let bas: Int<br>    let baz: Double<br>    init(self.bar: String, self.bas: Int, bax: Int) {<br>        self.baz = Double(bax)<br>    }<br>}<br></p><p>where the need to say<br></p><p>self.bar = bar<br>self.bas = bas<br></p><p>is now avoided.<br></p><p>On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas &lt;me at tal.by&gt; wrote:<br></p><p>&gt; There’s lots of boilerplate of initializing structs with stored properties<br>&gt; and initializer parameters. I’d like to create a syntax for alleviating<br>&gt; that in the 90% case.<br>&gt;<br>&gt; ```swift<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let baz: Int<br>&gt;<br>&gt;     init(self.bar: String = &quot;default&quot;, counter self.baz: Int) {<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; This would be identical to:<br>&gt; ```swift<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let baz: Int<br>&gt;<br>&gt;     init(bar: String = &quot;default&quot;, counter baz: Int) {<br>&gt;         self.bar = bar<br>&gt;         self.baz = baz<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/901ade23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  4, 2015 at 09:00:00pm</p></header><div class="content"><p>I think this idea scratches at the surface of a problem with initializers that definitely merits some attention.  Boilerplate is common in initializers which can lead to types that don’t allow as much flexibility to callers as might be desirable.  <br></p><p>More importantly, it can also lead to “initialized” instances that are not fully or properly configured, (implicitly unwrapped?) optional members, and mutability that shouldn’t be necessary past the initial configuration stage of the instance.  For example, if a type provides a family of initializers, but also has several members which are intended to be initialized / configured directly by callers a developer could choose to avoid the boilerplate by declaring the additional members as as an implicitly unwrapped optional var members.  No doubt this is a bad idea.  If the caller does not initialize all of the additional members there is a bomb waiting to go off.  Furthermore, there is the potential for mutation after initialization that may not be expected or intended.  By requiring a nontrivial amount of boilerplate to avoid this situation the language is unintentionally nudging lazy developers towards bad practices like this.<br></p><p>Let&#39;s start with the current proposal but go a bit further and see how much boilerplate can be removed.  The type information is already known from the property declaration, and furthermore a default may also be available in the property declaration.<br></p><p>struct Foo {<br>    let bar: String<br>    let bas: Int = 1<br>    let bat:  Float = 0<br>    let bax: String = “default&quot;<br>    let baz: Double<br>    <br>    // self.bar is known to be a String but does not have a default value so it must be provided by the caller  <br>    // self.bas is known to be an Int and implicitly has a default value of 1 specified by the property <br>    // so it does not need to be provided by the caller<br>    // self.bat is known to be a Float, but the default is overridden to be 1 instead of 0<br>    // external labels are provided that correspond to the names of the properties<br>    init(self.bar, self.bas, self.bat = 1) {<br>	// the initializer does not receive a value for baz and the property does not provide a default <br>        // so it must be initialized here before the first phase of initialization is complete<br>        // if all stored properties had received values through parameters or through property defaults <br>        // the first phase of initialization would have already been completed when the body of the initializer was entered<br>        self.baz = someComputedDoubleValue()<br>        // now all stored properties have been initialized so the first phase of initialization is complete<br>    }<br>}<br></p><p>This structure allows us to remove the boilerplate of the property type and default value.  <br></p><p>Given the significant difference from regular function parameters, it may make sense to set these apart syntactically in some way, although I am not sure what would make the most sense.  For example, we could just have a second parameter tuple in the initializer declaration which represents the “member parameters” to the initializer like this:<br></p><p>init(foo: Int)(self.bar, self.bas, self.bat = 1)<br></p><p>or a vertical pipe like this:<br></p><p>init(foo: Int | self.bar, self.bas, self.bat = 1)<br></p><p>Setting these “member parameters” apart syntactically could also facilitate additional mechanisms to further reduce boilerplate if we find that the same group of “member parameters&quot; exist for several different initializers in the same type.  For example, it might become possible to implement a memberwise initializer like this:<br></p><p>// @automembers expands to match all stored properties<br>init()(@automembers) {}<br></p><p>At this point we have eliminated virtually all of the boilerplate, encouraging developers to use concise *and* safe, yet still flexible initialization strategies.  <br></p><p>Matthew<br></p><p><br></p><p>&gt; On Dec 4, 2015, at 9:05 PM, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure how I feel about this, but in either case, why limit it to default parameters? It&#39;s useful in other situations, too.<br>&gt; <br>&gt; Take this for example:<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let bas: Int<br>&gt;     let baz: Double<br>&gt;     init(self.bar: String, self.bas: Int, bax: Int) {<br>&gt;         self.baz = Double(bax)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; where the need to say<br>&gt; <br>&gt; self.bar = bar<br>&gt; self.bas = bas<br>&gt; <br>&gt; is now avoided.<br>&gt; <br>&gt; On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas &lt;me at tal.by &lt;mailto:me at tal.by&gt;&gt; wrote:<br>&gt; There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.<br>&gt; <br>&gt; ```swift<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let baz: Int<br>&gt; <br>&gt;     init(self.bar: String = &quot;default&quot;, counter self.baz: Int) {<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This would be identical to:<br>&gt; ```swift<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let baz: Int<br>&gt; <br>&gt;     init(bar: String = &quot;default&quot;, counter baz: Int) {<br>&gt;         self.bar = bar<br>&gt;         self.baz = baz<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Dan Appel<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/a1c79ea3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December  4, 2015 at 11:00:00pm</p></header><div class="content"><p>I&#39;m not entirely sure what your proposal changes, other than omitting the argument labels and us wing self to refer to the property. Could you try a trivial example that would be runnable if the change was implemented?<br></p><p>Thanks for your time,<br>Cole Kurkowski<br></p><p>On Dec 4, 2015, 21:59 -0600, Matthew Johnson&lt;matthew at anandabits.com&gt;, wrote:<br>&gt; I think this idea scratches at the surface of a problem with initializers that definitely merits some attention.Boilerplate is common in initializers which can lead to types that don’t allow as much flexibility to callers as might be desirable.<br>&gt;  <br>&gt; More importantly, it can also lead to “initialized” instances that are not fully or properly configured, (implicitly unwrapped?) optional members, and mutability that shouldn’t be necessary past the initial configuration stage of the instance.For example, if a type provides a family of initializers, but also has several members which are intended to be initialized / configured directly by callers a developer could choose to avoid the boilerplate by declaring the additional members as as an implicitly unwrapped optional var members.No doubt this is a bad idea.If the caller does not initialize all of the additional members there is a bomb waiting to go off.Furthermore, there is the potential for mutation after initialization that may not be expected or intended.By requiring a nontrivial amount of boilerplate to avoid this situation the language is unintentionally nudging lazy developers towards bad practices like this.<br>&gt;  <br>&gt; Let&#39;s start with the current proposal but go a bit further and see how much boilerplate can be removed.The type information is already known from the property declaration, and furthermore a default may also be available in the property declaration.<br>&gt;  <br>&gt; struct Foo {<br>&gt; let bar: String<br>&gt; let bas: Int = 1<br>&gt; let bat:Float = 0<br>&gt; let bax: String = “default&quot;<br>&gt; let baz: Double<br>&gt;  <br>&gt; // self.bar is known to be a String but does not have a default value so it must be provided by the caller<br>&gt; // self.bas is known to be an Int and implicitly has a default value of 1 specified by the property<br>&gt; // so it does not need to be provided by the caller<br>&gt; // self.bat is known to be a Float, but the default is overridden to be 1 instead of 0<br>&gt; // external labels are provided that correspond to the names of the properties<br>&gt; init(self.bar, self.bas, self.bat = 1) {<br>&gt; // the initializer does not receive a value for baz and the property does not provide a default<br>&gt; // so it must be initialized here before the first phase of initialization is complete<br>&gt; // if all stored properties had received values through parameters or through property defaults<br>&gt; // the first phase of initialization would have already been completed when the body of the initializer was entered<br>&gt; self.baz = someComputedDoubleValue()<br>&gt; // now all stored properties have been initialized so the first phase of initialization is complete<br>&gt; }<br>&gt; }<br>&gt;  <br>&gt; This structure allows us to remove the boilerplate of the property type and default value.<br>&gt;  <br>&gt; Given the significant difference from regular function parameters, it may make sense to set these apart syntactically in some way, although I am not sure what would make the most sense.For example, we could just have a second parameter tuple in the initializer declaration which represents the “member parameters” to the initializer like this:<br>&gt;  <br>&gt; init(foo: Int)(self.bar, self.bas, self.bat = 1)<br>&gt;  <br>&gt; or a vertical pipe like this:<br>&gt;  <br>&gt; init(foo: Int | self.bar, self.bas, self.bat = 1)<br>&gt;  <br>&gt; Setting these “member parameters” apart syntactically could also facilitate additional mechanisms to further reduce boilerplate if we find that the same group of “member parameters&quot; exist for several different initializers in the same type.For example, it might become possible to implement a memberwise initializer like this:<br>&gt;  <br>&gt; // @automembers expands to match all stored properties<br>&gt; init()(@automembers) {}<br>&gt;  <br>&gt; At this point we have eliminated virtually all of the boilerplate, encouraging developers to use concise *and* safe, yet still flexible initialization strategies.<br>&gt;  <br>&gt; Matthew<br>&gt;  <br>&gt;  <br>&gt;  <br>&gt; &gt; On Dec 4, 2015, at 9:05 PM, Dan Appel&lt;dan.appel00 at gmail.com(mailto:dan.appel00 at gmail.com)&gt;wrote:<br>&gt; &gt; I&#39;m not sure how I feel about this, but in either case, why limit it to default parameters? It&#39;s useful in other situations, too.<br>&gt; &gt;  <br>&gt; &gt; Take this for example:<br>&gt; &gt; struct Foo {<br>&gt; &gt; let bar: String<br>&gt; &gt; let bas: Int<br>&gt; &gt; let baz: Double<br>&gt; &gt; init(self.bar: String, self.bas: Int, bax: Int) {<br>&gt; &gt; self.baz = Double(bax)<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;  <br>&gt; &gt; where the need to say<br>&gt; &gt;  <br>&gt; &gt; self.bar = bar<br>&gt; &gt; self.bas = bas<br>&gt; &gt;  <br>&gt; &gt; is now avoided.<br>&gt; &gt; On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas&lt;me at tal.by(mailto:me at tal.by)&gt;wrote:<br>&gt; &gt; &gt; There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; ```swift<br>&gt; &gt; &gt; struct Foo {<br>&gt; &gt; &gt; let bar: String<br>&gt; &gt; &gt; let baz: Int<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; init(self.bar: String = &quot;default&quot;, counter self.baz: Int) {<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; ```<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; This would be identical to:<br>&gt; &gt; &gt; ```swift<br>&gt; &gt; &gt; struct Foo {<br>&gt; &gt; &gt; let bar: String<br>&gt; &gt; &gt; let baz: Int<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; init(bar: String = &quot;default&quot;, counter baz: Int) {<br>&gt; &gt; &gt; self.bar = bar<br>&gt; &gt; &gt; self.baz = baz<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; ```<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; --<br>&gt; &gt; Dan Appel<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/cd9a8125/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December  5, 2015 at 03:00:00pm</p></header><div class="content"><p>I still think that it should include the type in the initializer definition<br>because if you have private properties you’d need to expose the type<br>information somehow and that type inference doesn’t work that way anywhere<br>else in swift, so explicitly requiring the type information in the<br>initializer is consistent with the rest of swift.<br></p><p>On Sat, Dec 5, 2015 at 12:20 AM &lt;crk at fastmail.com&gt; wrote:<br></p><p>&gt; I&#39;m not entirely sure what your proposal changes, other than omitting the<br>&gt; argument labels and us wing self to refer to the property. Could you try a<br>&gt; trivial example that would be runnable if the change was implemented?<br>&gt;<br>&gt; Thanks for your time,<br>&gt; Cole Kurkowski<br>&gt;<br>&gt; On Dec 4, 2015, 21:59 -0600, Matthew Johnson &lt;matthew at anandabits.com&gt;,<br>&gt; wrote:<br>&gt;<br>&gt; I think this idea scratches at the surface of a problem with initializers<br>&gt; that definitely merits some attention.  Boilerplate is common in<br>&gt; initializers which can lead to types that don’t allow as much flexibility<br>&gt; to callers as might be desirable.<br>&gt;<br>&gt; More importantly, it can also lead to “initialized” instances that are not<br>&gt; fully or properly configured, (implicitly unwrapped?) optional members, and<br>&gt; mutability that shouldn’t be necessary past the initial configuration stage<br>&gt; of the instance.  For example, if a type provides a family of initializers,<br>&gt; but also has several members which are intended to be initialized /<br>&gt; configured directly by callers a developer could choose to avoid the<br>&gt; boilerplate by declaring the additional members as as an implicitly<br>&gt; unwrapped optional var members.  No doubt this is a bad idea.  If the<br>&gt; caller does not initialize all of the additional members there is a bomb<br>&gt; waiting to go off.  Furthermore, there is the potential for mutation after<br>&gt; initialization that may not be expected or intended.  By requiring a<br>&gt; nontrivial amount of boilerplate to avoid this situation the language is<br>&gt; unintentionally nudging lazy developers towards bad practices like this.<br>&gt;<br>&gt; Let&#39;s start with the current proposal but go a bit further and see how<br>&gt; much boilerplate can be removed.  The type information is already known<br>&gt; from the property declaration, and furthermore a default may also be<br>&gt; available in the property declaration.<br>&gt;<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let bas: Int = 1<br>&gt;     let bat:  Float = 0<br>&gt;     let bax: String = “default&quot;<br>&gt;     let baz: Double<br>&gt;<br>&gt;     // self.bar is known to be a String but does not have a default value<br>&gt; so it must be provided by the caller<br>&gt;     // self.bas is known to be an Int and implicitly has a default value<br>&gt; of 1 specified by the property<br>&gt;     // so it does not need to be provided by the caller<br>&gt;     // self.bat is known to be a Float, but the default is overridden to<br>&gt; be 1 instead of 0<br>&gt;     // external labels are provided that correspond to the names of the<br>&gt; properties<br>&gt;     init(self.bar, self.bas, self.bat = 1) {<br>&gt; // the initializer does not receive a value for baz and the property does<br>&gt; not provide a default<br>&gt;         // so it must be initialized here before the first phase of<br>&gt; initialization is complete<br>&gt;         // if all stored properties had received values through parameters<br>&gt; or through property defaults<br>&gt;         // the first phase of initialization would have already been<br>&gt; completed when the body of the initializer was entered<br>&gt;         self.baz = someComputedDoubleValue()<br>&gt;         // now all stored properties have been initialized so the first<br>&gt; phase of initialization is complete<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This structure allows us to remove the boilerplate of the property type<br>&gt; and default value.<br>&gt;<br>&gt; Given the significant difference from regular function parameters, it may<br>&gt; make sense to set these apart syntactically in some way, although I am not<br>&gt; sure what would make the most sense.  For example, we could just have a<br>&gt; second parameter tuple in the initializer declaration which represents the<br>&gt; “member parameters” to the initializer like this:<br>&gt;<br>&gt; init(foo: Int)(self.bar, self.bas, self.bat = 1)<br>&gt;<br>&gt; or a vertical pipe like this:<br>&gt;<br>&gt; init(foo: Int | self.bar, self.bas, self.bat = 1)<br>&gt;<br>&gt; Setting these “member parameters” apart syntactically could also<br>&gt; facilitate additional mechanisms to further reduce boilerplate if we find<br>&gt; that the same group of “member parameters&quot; exist for several different<br>&gt; initializers in the same type.  For example, it might become possible to<br>&gt; implement a memberwise initializer like this:<br>&gt;<br>&gt; // @automembers expands to match all stored properties<br>&gt; init()(@automembers) {}<br>&gt;<br>&gt; At this point we have eliminated virtually all of the boilerplate,<br>&gt; encouraging developers to use concise *and* safe, yet still flexible<br>&gt; initialization strategies.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 4, 2015, at 9:05 PM, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt;<br>&gt; I&#39;m not sure how I feel about this, but in either case, why limit it to<br>&gt; default parameters? It&#39;s useful in other situations, too.<br>&gt;<br>&gt; Take this for example:<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let bas: Int<br>&gt;     let baz: Double<br>&gt;     init(self.bar: String, self.bas: Int, bax: Int) {<br>&gt;         self.baz = Double(bax)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; where the need to say<br>&gt;<br>&gt; self.bar = bar<br>&gt; self.bas = bas<br>&gt;<br>&gt; is now avoided.<br>&gt;<br>&gt; On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt;<br>&gt;&gt; There’s lots of boilerplate of initializing structs with stored<br>&gt;&gt; properties and initializer parameters. I’d like to create a syntax for<br>&gt;&gt; alleviating that in the 90% case.<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; struct Foo {<br>&gt;&gt;     let bar: String<br>&gt;&gt;     let baz: Int<br>&gt;&gt;<br>&gt;&gt;     init(self.bar: String = &quot;default&quot;, counter self.baz: Int) {<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; This would be identical to:<br>&gt;&gt; ```swift<br>&gt;&gt; struct Foo {<br>&gt;&gt;     let bar: String<br>&gt;&gt;     let baz: Int<br>&gt;&gt;<br>&gt;&gt;     init(bar: String = &quot;default&quot;, counter baz: Int) {<br>&gt;&gt;         self.bar = bar<br>&gt;&gt;         self.baz = baz<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; Dan Appel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/7920b864/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  5, 2015 at 09:00:00am</p></header><div class="content"><p>Even though a private property is not visible to compilers it is visible to the compiler.  If the developer makes a request to expose that property in an initializer the compiler could easily insert the type information in the signature of the initializer.<br></p><p>That said, the most important point I want to emphasize is the problems caused by boilerplate in initializers.  I showed one way this problem could be solved building on the previous proposal syntactically.  The exact solution and syntax don’t really matter that much to me but I would like to see Swift better support flexible and safe initialization without requiring boilerplate in one way or another.<br></p><p>If there is interest I will try to track down some examples to make the discussion more concrete.<br></p><p>&gt; On Dec 5, 2015, at 9:23 AM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; I still think that it should include the type in the initializer definition because if you have private properties you’d need to expose the type information somehow and that type inference doesn’t work that way anywhere else in swift, so explicitly requiring the type information in the initializer is consistent with the rest of swift.<br>&gt; <br>&gt; On Sat, Dec 5, 2015 at 12:20 AM &lt;crk at fastmail.com &lt;mailto:crk at fastmail.com&gt;&gt; wrote:<br>&gt; I&#39;m not entirely sure what your proposal changes, other than omitting the argument labels and us wing self to refer to the property. Could you try a trivial example that would be runnable if the change was implemented?<br>&gt; <br>&gt; Thanks for your time,<br>&gt; Cole Kurkowski<br>&gt; <br>&gt; On Dec 4, 2015, 21:59 -0600, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;, wrote:<br>&gt;&gt; I think this idea scratches at the surface of a problem with initializers that definitely merits some attention.  Boilerplate is common in initializers which can lead to types that don’t allow as much flexibility to callers as might be desirable.  <br>&gt;&gt; <br>&gt;&gt; More importantly, it can also lead to “initialized” instances that are not fully or properly configured, (implicitly unwrapped?) optional members, and mutability that shouldn’t be necessary past the initial configuration stage of the instance.  For example, if a type provides a family of initializers, but also has several members which are intended to be initialized / configured directly by callers a developer could choose to avoid the boilerplate by declaring the additional members as as an implicitly unwrapped optional var members.  No doubt this is a bad idea.  If the caller does not initialize all of the additional members there is a bomb waiting to go off.  Furthermore, there is the potential for mutation after initialization that may not be expected or intended.  By requiring a nontrivial amount of boilerplate to avoid this situation the language is unintentionally nudging lazy developers towards bad practices like this.<br>&gt;&gt; <br>&gt;&gt; Let&#39;s start with the current proposal but go a bit further and see how much boilerplate can be removed.  The type information is already known from the property declaration, and furthermore a default may also be available in the property declaration.<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;     let bar: String<br>&gt;&gt;     let bas: Int = 1<br>&gt;&gt;     let bat:  Float = 0<br>&gt;&gt;     let bax: String = “default&quot;<br>&gt;&gt;     let baz: Double<br>&gt;&gt;     <br>&gt;&gt;     // self.bar is known to be a String but does not have a default value so it must be provided by the caller  <br>&gt;&gt;     // self.bas is known to be an Int and implicitly has a default value of 1 specified by the property <br>&gt;&gt;     // so it does not need to be provided by the caller<br>&gt;&gt;     // self.bat is known to be a Float, but the default is overridden to be 1 instead of 0<br>&gt;&gt;     // external labels are provided that correspond to the names of the properties<br>&gt;&gt;     init(self.bar, self.bas, self.bat = 1) {<br>&gt;&gt; // the initializer does not receive a value for baz and the property does not provide a default <br>&gt;&gt;         // so it must be initialized here before the first phase of initialization is complete<br>&gt;&gt;         // if all stored properties had received values through parameters or through property defaults <br>&gt;&gt;         // the first phase of initialization would have already been completed when the body of the initializer was entered<br>&gt;&gt;         self.baz = someComputedDoubleValue()<br>&gt;&gt;         // now all stored properties have been initialized so the first phase of initialization is complete<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This structure allows us to remove the boilerplate of the property type and default value.  <br>&gt;&gt; <br>&gt;&gt; Given the significant difference from regular function parameters, it may make sense to set these apart syntactically in some way, although I am not sure what would make the most sense.  For example, we could just have a second parameter tuple in the initializer declaration which represents the “member parameters” to the initializer like this:<br>&gt;&gt; <br>&gt;&gt; init(foo: Int)(self.bar, self.bas, self.bat = 1)<br>&gt;&gt; <br>&gt;&gt; or a vertical pipe like this:<br>&gt;&gt; <br>&gt;&gt; init(foo: Int | self.bar, self.bas, self.bat = 1)<br>&gt;&gt; <br>&gt;&gt; Setting these “member parameters” apart syntactically could also facilitate additional mechanisms to further reduce boilerplate if we find that the same group of “member parameters&quot; exist for several different initializers in the same type.  For example, it might become possible to implement a memberwise initializer like this:<br>&gt;&gt; <br>&gt;&gt; // @automembers expands to match all stored properties<br>&gt;&gt; init()(@automembers) {}<br>&gt;&gt; <br>&gt;&gt; At this point we have eliminated virtually all of the boilerplate, encouraging developers to use concise *and* safe, yet still flexible initialization strategies.  <br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 9:05 PM, Dan Appel &lt;dan.appel00 at gmail.com &lt;mailto:dan.appel00 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure how I feel about this, but in either case, why limit it to default parameters? It&#39;s useful in other situations, too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Take this for example:<br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     let bar: String<br>&gt;&gt;&gt;     let bas: Int<br>&gt;&gt;&gt;     let baz: Double<br>&gt;&gt;&gt;     init(self.bar: String, self.bas: Int, bax: Int) {<br>&gt;&gt;&gt;         self.baz = Double(bax)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where the need to say<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; self.bar = bar<br>&gt;&gt;&gt; self.bas = bas<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is now avoided.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Dec 4, 2015 at 3:16 PM Tal Atlas &lt;me at tal.by &lt;mailto:me at tal.by&gt;&gt; wrote:<br>&gt;&gt;&gt; There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     let bar: String<br>&gt;&gt;&gt;     let baz: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(self.bar: String = &quot;default&quot;, counter self.baz: Int) {<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would be identical to:<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     let bar: String<br>&gt;&gt;&gt;     let baz: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(bar: String = &quot;default&quot;, counter baz: Int) {<br>&gt;&gt;&gt;         self.bar = bar<br>&gt;&gt;&gt;         self.baz = baz<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dan Appel<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/1ae7233c/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.<br>&gt; <br>&gt; ```swift<br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let baz: Int<br>&gt; <br>&gt;     init(self.bar: String = &quot;default&quot;, counter self.baz: Int) {<br>&gt;     }<br>&gt; }<br>&gt; ```<br></p><p>I’d like to propose an alternative approach.<br></p><p>Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.<br></p><p>I propose that we make it possible to explicitly ask for that default initializer:<br></p><p>    struct Foo {<br>        let bar: String<br>        let baz: Int<br>        <br>        init() {<br>            bar = “default”<br>            baz = 0<br>        }<br></p><p>        init default	// automatically generates init(bar: String, baz: Int)<br>    }<br></p><p>Moreover, I propose we extend this to classes:<br></p><p>    struct Foo: Bar {<br>        let bar: String<br>        let baz: Int<br>        <br>        init() {<br>            bar = “default”<br>            baz = 0<br>        }<br></p><p>        init default()	// automatically generates init(bar: String, baz: Int) with super.init()<br>    }<br></p><p>In a class, the “default” statement must have parens after it; these indicate the parameters to be added for the superclass initializer. If you need to super up to an initializer that takes parameters, you add the needed parameters there:<br></p><p>    struct Foo {<br>        let bar: String<br>        let baz: Int<br>        <br>        init() {<br>            bar = “default”<br>            baz = 0<br>        }<br></p><p>        init default(quux: Double)	// automatically generates init(quux: Double, bar: String, baz: Int) with super.init(quux: quux)<br>    }<br></p><p>If you super up to a failable initializer, of course, that will have to be “init? default(quux: Double)”.<br></p><p>Now, one little quirk of the current system is that Swift may actually generate *two* default initializers: a parameterless initializer when all properties have default values, and a memberwise initializer which requires all values be provided. I further propose that these be unified into one default initializer by giving default values to parameters which map to properties with default values. This gives you all the parameter sets currently supported, plus a whole range in between.<br></p><p>    struct Foo {<br>        let bar: String = “default&quot;<br>        let baz: Int<br>        <br>        init() {<br>            bar = “default”<br>            baz = 0<br>        }<br></p><p>        init default	// automatically generates init(bar: String = “default&quot;, baz: Int)<br>    }<br></p><p>Finally, you can continue to decorate the “init” keyword with attributes as you normally would.<br></p><p>	public init default<br>	internal init default<br>	private init default<br>	required init default<br>	override init default<br>	@objc init default<br>	@objc public required init default<br></p><p>(I don’t think convenience initializers make much sense here.)<br></p><p>This does not, unfortunately, eliminate boilerplate in initializers which do more than just set properties. Nor does it allow you to rename parameters, as your example does with “counter”. <br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  5, 2015 at 03:00:00pm</p></header><div class="content"><p>Did you read through by reply to the original proposal?  I believe it provides the convenience you&#39;re looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.  <br></p><p>The syntax I used is a bit different, but not too much for the default initializer case (and isn&#39;t as important as expressive power IMO). <br></p><p>If you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.<br></p><p>Sent from my iPhone<br></p><p>On Dec 5, 2015, at 3:03 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; struct Foo {<br>&gt;&gt;    let bar: String<br>&gt;&gt;    let baz: Int<br>&gt;&gt; <br>&gt;&gt;    init(self.bar: String = &quot;default&quot;, counter self.baz: Int) {<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt; <br>&gt; I’d like to propose an alternative approach.<br>&gt; <br>&gt; Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.<br>&gt; <br>&gt; I propose that we make it possible to explicitly ask for that default initializer:<br>&gt; <br>&gt;    struct Foo {<br>&gt;        let bar: String<br>&gt;        let baz: Int<br>&gt; <br>&gt;        init() {<br>&gt;            bar = “default”<br>&gt;            baz = 0<br>&gt;        }<br>&gt; <br>&gt;        init default    // automatically generates init(bar: String, baz: Int)<br>&gt;    }<br>&gt; <br>&gt; Moreover, I propose we extend this to classes:<br>&gt; <br>&gt;    struct Foo: Bar {<br>&gt;        let bar: String<br>&gt;        let baz: Int<br>&gt; <br>&gt;        init() {<br>&gt;            bar = “default”<br>&gt;            baz = 0<br>&gt;        }<br>&gt; <br>&gt;        init default()    // automatically generates init(bar: String, baz: Int) with super.init()<br>&gt;    }<br>&gt; <br>&gt; In a class, the “default” statement must have parens after it; these indicate the parameters to be added for the superclass initializer. If you need to super up to an initializer that takes parameters, you add the needed parameters there:<br>&gt; <br>&gt;    struct Foo {<br>&gt;        let bar: String<br>&gt;        let baz: Int<br>&gt; <br>&gt;        init() {<br>&gt;            bar = “default”<br>&gt;            baz = 0<br>&gt;        }<br>&gt; <br>&gt;        init default(quux: Double)    // automatically generates init(quux: Double, bar: String, baz: Int) with super.init(quux: quux)<br>&gt;    }<br>&gt; <br>&gt; If you super up to a failable initializer, of course, that will have to be “init? default(quux: Double)”.<br>&gt; <br>&gt; Now, one little quirk of the current system is that Swift may actually generate *two* default initializers: a parameterless initializer when all properties have default values, and a memberwise initializer which requires all values be provided. I further propose that these be unified into one default initializer by giving default values to parameters which map to properties with default values. This gives you all the parameter sets currently supported, plus a whole range in between.<br>&gt; <br>&gt;    struct Foo {<br>&gt;        let bar: String = “default&quot;<br>&gt;        let baz: Int<br>&gt; <br>&gt;        init() {<br>&gt;            bar = “default”<br>&gt;            baz = 0<br>&gt;        }<br>&gt; <br>&gt;        init default    // automatically generates init(bar: String = “default&quot;, baz: Int)<br>&gt;    }<br>&gt; <br>&gt; Finally, you can continue to decorate the “init” keyword with attributes as you normally would.<br>&gt; <br>&gt;    public init default<br>&gt;    internal init default<br>&gt;    private init default<br>&gt;    required init default<br>&gt;    override init default<br>&gt;    @objc init default<br>&gt;    @objc public required init default<br>&gt; <br>&gt; (I don’t think convenience initializers make much sense here.)<br>&gt; <br>&gt; This does not, unfortunately, eliminate boilerplate in initializers which do more than just set properties. Nor does it allow you to rename parameters, as your example does with “counter”. <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  5, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; Did you read through by reply to the original proposal?  I believe it provides the convenience you&#39;re looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.  <br></p><p>I did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.<br></p><p>It’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:<br></p><p>    class Player {<br>        var name: String<br>        private(set) var points: Int<br></p><p>        func addPoints(additionalPoints: Int) {<br>            points += additionalPoints<br>        }<br>        <br>        // Creates init(name: String, score: Int)<br>        init default()<br>    }<br></p><p>Later, I decide to add syncing, and realize I need to change this model. I need to add a sync identifier, and I want to change `points` to be computed from a series of `PointChange` objects. (This is a common strategy to avoid sync conflicts.) However, I don’t want to disrupt any of my existing code when I do this.<br></p><p>    class Player {<br>        let syncIdentifier = NSUUID()<br>        var name: String<br>        private var pointChanges: Set&lt;PointChange&gt;<br>        <br>        var points: Int {<br>            get { return pointChanges.reduce(0, combine: +) }<br>        }<br>        <br>        func addPoints(additionalPoints: Int) {<br>            pointChanges.insert(PointChange(offset: additionalPoints)<br>        }<br>        <br>        // We can no longer use init default(), but we can still create an initializer with the same signature<br>        init(name: String, points: Int) {<br>            self.name = name<br>            pointChanges = [ PointChange(offset: score) ]<br>        }<br>    }<br></p><p>By *not* separating the properties into a different syntactical construct from the constructor parameters, I can update my type’s implementation without affecting its interface. If properties were separated syntactically from constructor parameters as you proposed, it would not be possible to change this seamlessly.<br></p><p>&gt; If you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.<br></p><p>Honestly, I would like to fix the boilerplate issue in more sophisticated initializers, but I don’t see a clean way to do that. The other proposals I’ve seen in this thread, along the lines of:<br></p><p>	init(self.name, self.points) {}<br></p><p>Frankly do too much violence to the parameter list. Swift’s declarations have a lovely feature where the declaration basically looks like the usage, except that the concrete values in the usage are replaced by types in the declaration. These proposals destroy that property—when I look at the declaration, I can no longer envision what the call site will look like.<br></p><p>Basically, I focused on default initializers because they’re *really* easy to solve and cover a good portion of the common case. I really have no idea how to solve the larger problem, and I haven’t liked any of the other ideas in this thread, but I do know how to solve this more limited problem.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  5, 2015 at 07:00:00pm</p></header><div class="content"><p>A possible syntax, then:<br></p><p>	init(set name:String, set score:Int) { }<br></p><p>set would be a fourth parameter modifier alongside let, var, and inout - only valid on initializers (not as useful and likely confusing in other contexts). The local name has to match a parameter on the type. Like let/var (but unlike inout) usage of ‘set’ on a initializer parameter does not affect the caller or prototype conformance.<br></p><p>-DW<br></p><p>&gt; On Dec 5, 2015, at 3:31 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Did you read through by reply to the original proposal?  I believe it provides the convenience you&#39;re looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.  <br>&gt; <br>&gt; I did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.<br>&gt; <br>&gt; It’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f7ed6ee1/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December  6, 2015 at 02:00:00am</p></header><div class="content"><p>This syntax is confusing with that of defining the external keyword for the<br>parameter.<br></p><p>On Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A possible syntax, then:<br>&gt;<br>&gt;         init(set name:String, set score:Int) { }<br>&gt;<br>&gt; set would be a fourth parameter modifier alongside let, var, and inout -<br>&gt; only valid on initializers (not as useful and likely confusing in other<br>&gt; contexts). The local name has to match a parameter on the type. Like<br>&gt; let/var (but unlike inout) usage of ‘set’ on a initializer parameter does<br>&gt; not affect the caller or prototype conformance.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; &gt; On Dec 5, 2015, at 3:31 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; Did you read through by reply to the original proposal?  I believe it<br>&gt; provides the convenience you&#39;re looking for here while still allowing for<br>&gt; the flexibility to avoid boilerplate in initializers that do more than just<br>&gt; set properties.<br>&gt; &gt;<br>&gt; &gt; I did, and I didn’t really like it. One of the syntaxes it proposed was<br>&gt; strange and ad-hoc; the other was a fairly arbitrary overloading of<br>&gt; parentheses, although it doesn’t actually conflict with anything since you<br>&gt; can’t overload “calling parentheses” on a non-function.<br>&gt; &gt;<br>&gt; &gt; It’s important to ensure that, when the implementation evolves, you can<br>&gt; replace the initializer transparently. For instance, suppose I have a type<br>&gt; which represents a player in a game. It uses a stored property called<br>&gt; `points`:<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/88c0be93/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  5, 2015 at 07:00:00pm</p></header><div class="content"><p>I don’t believe any more so than for let or var, which this effectively is a complement for.<br></p><p>func foo(var externalName internalName:String) { print(internalName) }<br></p><p>-DW<br></p><p>&gt; On Dec 5, 2015, at 7:25 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt; <br>&gt; This syntax is confusing with that of defining the external keyword for the parameter.<br>&gt; <br>&gt; On Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; A possible syntax, then:<br>&gt; <br>&gt;         init(set name:String, set score:Int) { }<br>&gt; <br>&gt; set would be a fourth parameter modifier alongside let, var, and inout - only valid on initializers (not as useful and likely confusing in other contexts). The local name has to match a parameter on the type. Like let/var (but unlike inout) usage of ‘set’ on a initializer parameter does not affect the caller or prototype conformance.<br>&gt; <br>&gt; -DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/ce470d64/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/ce470d64/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  5, 2015 at 06:00:00pm</p></header><div class="content"><p>The ability to use `var` in parameter lists / pattern matching is being<br>removed:<br>https://github.com/apple/swift-evolution/blob/7dc4dc47c43647dd1e60fe17074959dc3f056468/proposals/0003-remove-var-parameters-patterns.md<br></p><p>Jacob<br></p><p>On Sat, Dec 5, 2015 at 6:46 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don’t believe any more so than for let or var, which this effectively is<br>&gt; a complement for.<br>&gt;<br>&gt; func foo(var externalName internalName:String) { print(internalName) }<br>&gt;<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Dec 5, 2015, at 7:25 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br>&gt;<br>&gt; This syntax is confusing with that of defining the external keyword for<br>&gt; the parameter.<br>&gt;<br>&gt; On Sat, Dec 5, 2015 at 9:24 PM David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; A possible syntax, then:<br>&gt;&gt;<br>&gt;&gt;         init(set name:String, set score:Int) { }<br>&gt;&gt;<br>&gt;&gt; set would be a fourth parameter modifier alongside let, var, and inout -<br>&gt;&gt; only valid on initializers (not as useful and likely confusing in other<br>&gt;&gt; contexts). The local name has to match a parameter on the type. Like<br>&gt;&gt; let/var (but unlike inout) usage of ‘set’ on a initializer parameter does<br>&gt;&gt; not affect the caller or prototype conformance.<br>&gt;&gt;<br>&gt;&gt; -DW<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/4da71a39/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  5, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; I don’t believe any more so than for let or var, which this effectively is a complement for.<br></p><p>There is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  5, 2015 at 07:00:00pm</p></header><div class="content"><p>There is also a set keyword in the language already, although today its use is limited such that it may still be used as an identifier in non-conflicting contexts.<br></p><p>-DW<br></p><p>&gt; On Dec 5, 2015, at 7:51 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I don’t believe any more so than for let or var, which this effectively is a complement for.<br>&gt; <br>&gt; There is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/08428331/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 6:58 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is also a set keyword in the language already, although today its use is limited such that it may still be used as an identifier in non-conflicting contexts.<br></p><p>FWIW, “set” is a context sensitive keyword, not an actual keyword.  You can see the list of actual keywords here:<br></p><p>https://github.com/apple/swift/blob/master/include/swift/Parse/Tokens.def<br></p><p>-Chris<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 7:51 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I don’t believe any more so than for let or var, which this effectively is a complement for.<br>&gt;&gt; <br>&gt;&gt; There is no Let or Var type in the standard library, but there is a Set type. “Set” has many meanings, and some of them are relatively likely to be used as parameter keywords.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  5, 2015 at 11:00:00pm</p></header><div class="content"><p>Thank you for taking the time to provide this feedback!  <br></p><p>I was trying to focus more on the problem we need to solve and just quickly sketch something that would solve it by building on the previous proposal.  I agree the syntax (and likely semantics) left a lot to be desired and should be vastly improved.  I was primarily demonstrating that is *possible* to solve the problem, we just need to find the right solution.  <br></p><p>I’m glad to hear you also believe it’s a problem worth solving and just didn’t like specific details of the solution.  I do think it’s worth solving the more general problem even though a good solution may be more difficult to find.  If we adopt a simpler solution like the one you propose for default initializers it is likely to significantly constrain our options for solving the more general problem (in order to play nice with the simpler solution you propose).<br></p><p>I also believe that this problem is intimately related to the problem addressed in the “setup closures” thread as a general solution would supersede the need for “setup closures&quot;.<br></p><p>I would like to try coming at this problem from a different angle and see if that solution feels any better to us.  Let’s consider an @initializable attribute for members:<br></p><p>@initializable members that are set by the initializer are not generated as parameters by the compiler as the body of the initializer is taking responsibility for initializing that member.  The initializer is free to manually declare the a parameter with the name of the member it is initializing and use that if desired but it is not required to do so.  This will ensure boilerplate still works as expected when a programmer provides it.<br></p><p>@initializable members not set in the implementation of an initializer are generated as parameters automatically by the compiler at the end of the argument list (but before any variadic or trailing closure arguments) in the order the members are declared in the type itself.  If the member declares a default value, the compiler uses that as the default value for the argument.  Ideally the caller can re-order the labeled arguments as desired.<br></p><p>Private members are allowed to be @initializable and may be exposed through internal or public initializers.  The member itself is still hidden outside the scope of the file but any internal or public initializers should still be able to accept an initial value from a caller if desired, just as is possible with manual boilerplate today.<br></p><p>The general form of an initializer with automatically generated parameters would look something like this:<br></p><p>init() {<br>    // Compiler generated code to set the members for which it generated parameters.<br></p><p>    // The initializer is now free to access the value proved by the caller by accessing the member which has now been initialized by the compiler generated code.<br></p><p>    // The initializer sets any members it needs to directly.<br>    // This includes all members not marked @initializable that do not have default values.<br>}<br></p><p>There are probably some additional details to work out in relative to two-phase initialization of classes, but I think this conveys the basic idea.  <br></p><p>Here is an example:<br></p><p>struct S {<br>    @initializable let i: Int<br>    @initializable private let s: String = “s”<br>    let f: Float = 1<br>    let d: Double<br></p><p>    // i must be provided by the caller<br>    // s may be provided by the caller but is not required as there is a default value of “s”<br>    // f may be initialized directly but does not need to be as there is a default value of 1<br>    // d must be initialized directly by the initializer<br>    // callers see init(i: Int, s: String = “s&quot;)<br>    init() {<br>        // the initializer is free to read both i and s as the compiler automatically initializes them <br>        // with the value provided by the caller or the default value before the body of the initializer is entered<br>        d = Double(i)<br>        // f is initialized by the compiler to its default value<br>    }<br></p><p>    // s may be provided by the caller but is not required as there is a default value of “s”<br>    // callers see init(i: Int, j: Int, d: Double, s: String = “s&quot;)<br>    init(i: Int, j: Int, d: Double) {<br>        // the initializer is free to read s as the compiler automatically initializes it automatically<br>        // with the value provided by the caller or the default value before the body of the initializer is entered<br>        // this initializer may not read the value of i because the compiler does not automatically generate <br>        // an initializer for it as is initialized directly<br></p><p>        // the i parameter does not need to be used to directly initialize self.i and can be used to perform computation<br>        // if desired in order to provide backwards compatibility with existing code<br>        self.i = i + j<br>        self.d = d<br>        // f is initialized by the compiler to its default value<br>    }<br>}<br></p><p>One drawback to a solution like this is that it could result in the compiler generating parameters for an initializer that the developer did not intend but “forgot&quot; to initialize directly.  <br></p><p>When it does so for a member that does not contain a default value, tests and calling code should fail to compile calling attention to the problem.  In this case the problem is not too severe.  <br></p><p>On the other hand, if the member declares a default value calling code would still compile and the member would be initialized to the default value.  This is identical to the behavior of member not marked @initializable that a developer “forgets” to initialize if it declares a default value (i.e. the correct behavior for the initializer would require a value different than the default).  The primary difference is the compiler generated parameter for the @initializable member that the implementer “forgot” to initialize, potentially allowing a caller to provide a value and initialize the instance in an incorrect way that is *different* than the default value which should not have been used by the initializer.<br></p><p>Another drawback to this approach is that it is not explicitly clear when reading an initializer’s parameter list.  One way to mitigate this would be to require the initializer itself to be marked with @initializable in order to opt-in to the compiler generated parameters.  This at least alerts the reader that they exist.  It provides less information than the &quot;init default()” approach as some @initializable members might be initialized directly in the initializer body which would suppress the compiler generated parameter.  However, the semantics of @initializable are pretty straightforward so I don’t think this would cause too much confusion.<br></p><p>Documentation generated for the initializer, autocomplete, etc would all expose the full parameter including the parameters the compiler generated for @initializable members.<br></p><p>I would like to revisit the Player example to see how it would fare using this approach:<br></p><p>   class Player {<br>       @initializable var name: String<br>       @initializable private(set) var points: Int<br></p><p>       func addPoints(additionalPoints: Int) {<br>           points += additionalPoints<br>       }<br></p><p>       // the previous post stated ‘Creates init(name: String, score: Int)&#39; which does not match the members<br>       // this has been modified to match the members as was likely intended<br>       // Creates init(name: String, points: Int) <br>       init() {}<br>   }<br></p><p>later in Player’s life:<br></p><p>   class Player {<br>       let syncIdentifier = NSUUID()<br>       var name: String<br>       private var pointChanges: Set&lt;PointChange&gt;<br></p><p>       var points: Int {<br>           get { return pointChanges.reduce(0, combine: +) }<br>       }<br></p><p>       func addPoints(additionalPoints: Int) {<br>           pointChanges.insert(PointChange(offset: additionalPoints)<br>       }<br></p><p>       // We can no longer use the compiler generated parameters, but we can still create an initializer with the same signature.<br>       // Furthermore, if we do not need to be concerned about the declaration order of keyword arguments<br>       // we can now leave off the boilerplate for “name” and allow the compiler to generate it<br>       // without requiring any changes to call sites.<br>       init(name: String, points: Int) {<br>           self.name = name<br>           pointChanges = [ PointChange(offset: points) ] // the original post had score here which did not match the parameter name<br>       }<br>   }<br></p><p>Does this solution look any better to you than the previous idea?<br></p><p><br></p><p>&gt; On Dec 5, 2015, at 4:31 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Did you read through by reply to the original proposal?  I believe it provides the convenience you&#39;re looking for here while still allowing for the flexibility to avoid boilerplate in initializers that do more than just set properties.  <br>&gt; <br>&gt; I did, and I didn’t really like it. One of the syntaxes it proposed was strange and ad-hoc; the other was a fairly arbitrary overloading of parentheses, although it doesn’t actually conflict with anything since you can’t overload “calling parentheses” on a non-function.<br>&gt; <br>&gt; It’s important to ensure that, when the implementation evolves, you can replace the initializer transparently. For instance, suppose I have a type which represents a player in a game. It uses a stored property called `points`:<br>&gt; <br>&gt;    class Player {<br>&gt;        var name: String<br>&gt;        private(set) var points: Int<br>&gt; <br>&gt;        func addPoints(additionalPoints: Int) {<br>&gt;            points += additionalPoints<br>&gt;        }<br>&gt; <br>&gt;        // Creates init(name: String, score: Int)<br>&gt;        init default()<br>&gt;    }<br>&gt; <br>&gt; Later, I decide to add syncing, and realize I need to change this model. I need to add a sync identifier, and I want to change `points` to be computed from a series of `PointChange` objects. (This is a common strategy to avoid sync conflicts.) However, I don’t want to disrupt any of my existing code when I do this.<br>&gt; <br>&gt;    class Player {<br>&gt;        let syncIdentifier = NSUUID()<br>&gt;        var name: String<br>&gt;        private var pointChanges: Set&lt;PointChange&gt;<br>&gt; <br>&gt;        var points: Int {<br>&gt;            get { return pointChanges.reduce(0, combine: +) }<br>&gt;        }<br>&gt; <br>&gt;        func addPoints(additionalPoints: Int) {<br>&gt;            pointChanges.insert(PointChange(offset: additionalPoints)<br>&gt;        }<br>&gt; <br>&gt;        // We can no longer use init default(), but we can still create an initializer with the same signature<br>&gt;        init(name: String, points: Int) {<br>&gt;            self.name = name<br>&gt;            pointChanges = [ PointChange(offset: score) ]<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; By *not* separating the properties into a different syntactical construct from the constructor parameters, I can update my type’s implementation without affecting its interface. If properties were separated syntactically from constructor parameters as you proposed, it would not be possible to change this seamlessly.<br>&gt; <br>&gt;&gt; If you believe we should have a feature focused strictly on memberwise initializers and not also allow for less boilerplate in more sophisticated initializers I am interested to hear your rationale.<br>&gt; <br>&gt; Honestly, I would like to fix the boilerplate issue in more sophisticated initializers, but I don’t see a clean way to do that. The other proposals I’ve seen in this thread, along the lines of:<br>&gt; <br>&gt; 	init(self.name, self.points) {}<br>&gt; <br>&gt; Frankly do too much violence to the parameter list. Swift’s declarations have a lovely feature where the declaration basically looks like the usage, except that the concrete values in the usage are replaced by types in the declaration. These proposals destroy that property—when I look at the declaration, I can no longer envision what the call site will look like.<br>&gt; <br>&gt; Basically, I focused on default initializers because they’re *really* easy to solve and cover a good portion of the common case. I really have no idea how to solve the larger problem, and I haven’t liked any of the other ideas in this thread, but I do know how to solve this more limited problem.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/01673358/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 10:00:00pm</p></header><div class="content"><p>On Dec 5, 2015, at 1:03 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.<br></p><p>As a general comment, at this point, I’d personally prefer to stay away from purely syntactic sugar syntax optimizations, unless they are very broadly applicable across the language.  There are a ton of core things still missing from the swift language and type system, and I’d prefer that we stay focused on that.  Post-Swift 3 we can consider adding a hygienic macro system, and the baking out of other language features may lead to the eliminate for some of the sugar that would otherwise be added.<br></p><p>&gt; I’d like to propose an alternative approach.<br>&gt; <br>&gt; Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.<br></p><p>Yes, this is really unfortunate.  The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):<br></p><p>1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.<br>2) Access control + the memberwise init often requires you to implement it yourself.<br>3) We don’t get memberwise inits for classes.<br>4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.<br>5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).<br></p><p>One of the things missing is the ability to “utter” the memberwise initializer, I’d suggest syntax along the lines of:<br></p><p>  memberwise init()    // memberwise is a &quot;decl modifier&quot;<br></p><p>So you could say:<br></p><p>  public memberwise init()<br></p><p>to specifically say you want the default one given public access control (for example).<br></p><p><br>It would be really great for someone to tackle these problems holistically! <br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  6, 2015 at 09:00:00am</p></header><div class="content"><p>Thanks for chiming in on this thread.  I definitely understand the desire to wait on features like this until post-Swfit 3 and possibly post-hygienic macros as well.<br></p><p>I would add to your list of memberwise initializer deficiencies the fact that it is “all or nothing”.  I’m wondering what you think of generalizing our “utterance” of the memberwise initializer in a way that allows the flexibility for the initializer itself to handle initialization of some of the members while allowing the compiler to generate the implementation for other members.  I described one idea for doing this in a post last night where I described an @initializable member attribute.  I’m not tied to that specific solution, but I do think it is highly desirable to have complier-generated memberwise initialization that is more flexible than an “all or nothing” solution.  What are your thoughts?<br></p><p>Matthew<br></p><p>&gt; On Dec 6, 2015, at 12:34 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 5, 2015, at 1:03 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; There’s lots of boilerplate of initializing structs with stored properties and initializer parameters. I’d like to create a syntax for alleviating that in the 90% case.<br>&gt; <br>&gt; As a general comment, at this point, I’d personally prefer to stay away from purely syntactic sugar syntax optimizations, unless they are very broadly applicable across the language.  There are a ton of core things still missing from the swift language and type system, and I’d prefer that we stay focused on that.  Post-Swift 3 we can consider adding a hygienic macro system, and the baking out of other language features may lead to the eliminate for some of the sugar that would otherwise be added.<br>&gt; <br>&gt;&gt; I’d like to propose an alternative approach.<br>&gt;&gt; <br>&gt;&gt; Swift already generates a default initializer for structs that don’t have any initializers explicitly defined. However, the moment you write init(, that initializer disappears. It’s also never available on classes, because they have to dispatch to another initializer.<br>&gt; <br>&gt; Yes, this is really unfortunate.  The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):<br>&gt; <br>&gt; 1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.<br>&gt; 2) Access control + the memberwise init often requires you to implement it yourself.<br>&gt; 3) We don’t get memberwise inits for classes.<br>&gt; 4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.<br>&gt; 5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).<br>&gt; <br>&gt; One of the things missing is the ability to “utter” the memberwise initializer, I’d suggest syntax along the lines of:<br>&gt; <br>&gt;  memberwise init()    // memberwise is a &quot;decl modifier&quot;<br>&gt; <br>&gt; So you could say:<br>&gt; <br>&gt;  public memberwise init()<br>&gt; <br>&gt; to specifically say you want the default one given public access control (for example).<br>&gt; <br>&gt; <br>&gt; It would be really great for someone to tackle these problems holistically! <br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  6, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 7:41 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Thanks for chiming in on this thread.  I definitely understand the desire to wait on features like this until post-Swfit 3 and possibly post-hygienic macros as well.<br>&gt; <br>&gt; I would add to your list of memberwise initializer deficiencies the fact that it is “all or nothing”.  I’m wondering what you think of generalizing our “utterance” of the memberwise initializer in a way that allows the flexibility for the initializer itself to handle initialization of some of the members while allowing the compiler to generate the implementation for other members.  I described one idea for doing this in a post last night where I described an @initializable member attribute.  I’m not tied to that specific solution, but I do think it is highly desirable to have complier-generated memberwise initialization that is more flexible than an “all or nothing” solution.  What are your thoughts?<br></p><p>That would be great of course, but it depends on the details.  We’d need someone to make a specific proposal to hash out whether and how it can work.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December  6, 2015 at 11:00:00pm</p></header><div class="content"><p>I greatly appreciate the feedback from those working directly with the<br>language. Having read though the other proposals I would like to return to<br>my original proposal, as it seems to have the greatest flexibility and<br>simplicity from an api perspective. The most frequent pain point with<br>current initializers are structs with more than a few private stored<br>properties, the amount of boilerplate is rather annoying. The other benefit<br>is it gives the writer direct control over what the external api for the<br>given object is for each specific initializer. I”m not married to the<br>`init(self.var: Type)` syntax, but would be sad if any solution didn’t stem<br>from a similar sort of idea.<br></p><p>On Sun, Dec 6, 2015 at 6:02 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 6, 2015, at 7:41 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Thanks for chiming in on this thread.  I definitely understand the<br>&gt; desire to wait on features like this until post-Swfit 3 and possibly<br>&gt; post-hygienic macros as well.<br>&gt; &gt;<br>&gt; &gt; I would add to your list of memberwise initializer deficiencies the fact<br>&gt; that it is “all or nothing”.  I’m wondering what you think of generalizing<br>&gt; our “utterance” of the memberwise initializer in a way that allows the<br>&gt; flexibility for the initializer itself to handle initialization of some of<br>&gt; the members while allowing the compiler to generate the implementation for<br>&gt; other members.  I described one idea for doing this in a post last night<br>&gt; where I described an @initializable member attribute.  I’m not tied to that<br>&gt; specific solution, but I do think it is highly desirable to have<br>&gt; complier-generated memberwise initialization that is more flexible than an<br>&gt; “all or nothing” solution.  What are your thoughts?<br>&gt;<br>&gt; That would be great of course, but it depends on the details.  We’d need<br>&gt; someone to make a specific proposal to hash out whether and how it can work.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/2d4af16c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>Proposal: helpers for initializing properties of same name as parameters</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>December  6, 2015 at 11:00:00am</p></header><div class="content"><p>Yes! It feels silly to have to re-implement the default initializer just to make it public. I would love to see this.<br></p><p>Daniel<br>&gt; On Dec 6, 2015, at 1:34 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So you could say:<br>&gt; <br>&gt;  public memberwise init()<br>&gt; <br>&gt; to specifically say you want the default one given public access control (for example).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/678e1b5b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
