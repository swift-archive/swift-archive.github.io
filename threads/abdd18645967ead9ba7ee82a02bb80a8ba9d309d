<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January  9, 2016 at 12:00:00pm</p></header><div class="content"><p>Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br></p><p>Thanks all!<br></p><p>~Robert Widmann<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 14, 2016 at 09:00:00pm</p></header><div class="content"><p>Now that I think about it, `fold` is not a great name for the cata on Either, [too bad `either is taken!].  Rust calls it `unwrap_or`, so maybe `unwrapLeft`, `unwrap`, etc?  Also, we’ve found some use for partial projections in JSON parsing libraries, so it might be worth looking into adding them to the proposal.<br></p><p>extension Either {<br>	var fromLeft : LeftValue? {<br>		switch self {<br>		case let .Left(l):<br>			return l<br>		default:<br>			return nil<br>		}<br>	}<br></p><p>	var fromRight : RightValue? {<br>		switch self {<br>		case let .Right(r):<br>			return r<br>		default:<br>			return nil<br>		}<br>	}<br>}<br></p><p>&gt; On Jan 9, 2016, at 2:19 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt; <br>&gt; Thanks all!<br>&gt; <br>&gt; ~Robert Widmann<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/317acd16/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 20, 2016 at 10:00:00pm</p></header><div class="content"><p>Hey all,<br></p><p>Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br></p><p>https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br></p><p>~Robert Widmann<br></p><p>2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br></p><p>&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt; <br>&gt; Thanks all!<br>&gt; <br>&gt; ~Robert Widmann<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 23, 2016 at 11:00:00am</p></header><div class="content"><p>I was reading the proposal and I have to admit I do like Either and have used it extensively in Scala for normal exceptions (business validations) leaving exceptions to … exceptional circumstances.   If I went back I think I could get rid of quite a bit of stuff if I had put more thought into it.<br></p><p>When it comes to validations though I was wondering how you saw it coming together:  <br></p><p>i.e. you have a set of validations that you run (independent validations) where after you finished if any of them has a validation you just want a list of business exceptions.  <br></p><p>The other scenario I could see is dependent validations where certain validations you want to skip because a validation that it was dependent on failed - i.e. you don’t want to be flooded with other validations which occur solely due to an earlier failed validation.  (i.e. concise execution of a list of validations or something like that).<br></p><p><br></p><p><br></p><p>&gt; On 2016-01-21, at 10:17:34, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey all,<br>&gt; <br>&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt; <br>&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt;&gt; <br>&gt;&gt; Thanks all!<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 23, 2016 at 01:00:00am</p></header><div class="content"><p>Yes, you definitely can use this Either to recover the Validation monad a la Scala.  I think I have to draw up an implementation and submit it to Swiftz!<br></p><p>~Robert Widmann<br></p><p>2016/01/22 23:45、Craig Cruden &lt;ccruden at novafore.com&gt; のメッセージ:<br></p><p>&gt; I was reading the proposal and I have to admit I do like Either and have used it extensively in Scala for normal exceptions (business validations) leaving exceptions to … exceptional circumstances.   If I went back I think I could get rid of quite a bit of stuff if I had put more thought into it.<br>&gt; <br>&gt; When it comes to validations though I was wondering how you saw it coming together:  <br>&gt; <br>&gt; i.e. you have a set of validations that you run (independent validations) where after you finished if any of them has a validation you just want a list of business exceptions.  <br>&gt; <br>&gt; The other scenario I could see is dependent validations where certain validations you want to skip because a validation that it was dependent on failed - i.e. you don’t want to be flooded with other validations which occur solely due to an earlier failed validation.  (i.e. concise execution of a list of validations or something like that).<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-21, at 10:17:34, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all,<br>&gt;&gt; <br>&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt; <br>&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks all!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 24, 2016 at 06:00:00am</p></header><div class="content"><p>I would think that if Either is in core — and Validation is not to dependent on other functional concepts (too deeply tied to the rest of Swiftz) — and being a very core concept for any application that it would be bundled with Either in standard libraries as well.  Pretty well every business application — large or small — functional or not — would benefit from a very easy /non-verbose validation mechanism. <br></p><p>I view Either conceptually as part of the contract that a function provides (normal validation; e.g. Person’s birth cannot be future-dated) which is expected as part of the functions process…. (and are expected and will be dealt with by whatever is calling it)…. while Exceptions are for exceptional circumstances / technical failings that may not be expected during normal operation such as a catastrophic fail (e.g. Server not found).  An Either/Validation business validation would be returned in a message on the same server or to a calling service, while technical failings might do things like fail-over.  <br></p><p>Not sure if I am expressing myself correctly.<br></p><p><br></p><p><br>&gt; On 2016-01-23, at 13:32:06, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes, you definitely can use this Either to recover the Validation monad a la Scala.  I think I have to draw up an implementation and submit it to Swiftz!<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/22 23:45、Craig Cruden &lt;ccruden at novafore.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; I was reading the proposal and I have to admit I do like Either and have used it extensively in Scala for normal exceptions (business validations) leaving exceptions to … exceptional circumstances.   If I went back I think I could get rid of quite a bit of stuff if I had put more thought into it.<br>&gt;&gt; <br>&gt;&gt; When it comes to validations though I was wondering how you saw it coming together:  <br>&gt;&gt; <br>&gt;&gt; i.e. you have a set of validations that you run (independent validations) where after you finished if any of them has a validation you just want a list of business exceptions.  <br>&gt;&gt; <br>&gt;&gt; The other scenario I could see is dependent validations where certain validations you want to skip because a validation that it was dependent on failed - i.e. you don’t want to be flooded with other validations which occur solely due to an earlier failed validation.  (i.e. concise execution of a list of validations or something like that).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-21, at 10:17:34, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks all!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 23, 2016 at 06:00:00pm</p></header><div class="content"><p>Unfortunately, it is tied down to quite a few functional concepts (assuming you mean the Scalaz version of Validation).  For starters (apologies, I misspoke in the last reply), it’s only an Applicative and the standard library only provides Functor and Monad-like concepts.  On top of that, errors will have to pass through a Semigroup, something only Swiftz provides at the moment.<br></p><p>Seems the most extra power you can get is `Result&lt;T&gt;` at the current level of abstraction the Standard Library is at.<br></p><p>&gt; On Jan 23, 2016, at 6:41 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; I would think that if Either is in core — and Validation is not to dependent on other functional concepts (too deeply tied to the rest of Swiftz) — and being a very core concept for any application that it would be bundled with Either in standard libraries as well.  Pretty well every business application — large or small — functional or not — would benefit from a very easy /non-verbose validation mechanism. <br>&gt; <br>&gt; I view Either conceptually as part of the contract that a function provides (normal validation; e.g. Person’s birth cannot be future-dated) which is expected as part of the functions process…. (and are expected and will be dealt with by whatever is calling it)…. while Exceptions are for exceptional circumstances / technical failings that may not be expected during normal operation such as a catastrophic fail (e.g. Server not found).  An Either/Validation business validation would be returned in a message on the same server or to a calling service, while technical failings might do things like fail-over.  <br>&gt; <br>&gt; Not sure if I am expressing myself correctly.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-23, at 13:32:06, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, you definitely can use this Either to recover the Validation monad a la Scala.  I think I have to draw up an implementation and submit it to Swiftz!<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/22 23:45、Craig Cruden &lt;ccruden at novafore.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; I was reading the proposal and I have to admit I do like Either and have used it extensively in Scala for normal exceptions (business validations) leaving exceptions to … exceptional circumstances.   If I went back I think I could get rid of quite a bit of stuff if I had put more thought into it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When it comes to validations though I was wondering how you saw it coming together:  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; i.e. you have a set of validations that you run (independent validations) where after you finished if any of them has a validation you just want a list of business exceptions.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other scenario I could see is dependent validations where certain validations you want to skip because a validation that it was dependent on failed - i.e. you don’t want to be flooded with other validations which occur solely due to an earlier failed validation.  (i.e. concise execution of a list of validations or something like that).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2016-01-21, at 10:17:34, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hey all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks all!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 24, 2016 at 11:00:00am</p></header><div class="content"><p>OK, So If the eventual proposal for HKT get added - then Validation would flow fairly nicely (if it is only Semigroup in the way — that I gather would be a fairly small add to get such power in the standard language).<br></p><p><br>&gt; On 2016-01-24, at 6:56:28, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Unfortunately, it is tied down to quite a few functional concepts (assuming you mean the Scalaz version of Validation).  For starters (apologies, I misspoke in the last reply), it’s only an Applicative and the standard library only provides Functor and Monad-like concepts.  On top of that, errors will have to pass through a Semigroup, something only Swiftz provides at the moment.<br>&gt; <br>&gt; Seems the most extra power you can get is `Result&lt;T&gt;` at the current level of abstraction the Standard Library is at.<br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 6:41 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would think that if Either is in core — and Validation is not to dependent on other functional concepts (too deeply tied to the rest of Swiftz) — and being a very core concept for any application that it would be bundled with Either in standard libraries as well.  Pretty well every business application — large or small — functional or not — would benefit from a very easy /non-verbose validation mechanism. <br>&gt;&gt; <br>&gt;&gt; I view Either conceptually as part of the contract that a function provides (normal validation; e.g. Person’s birth cannot be future-dated) which is expected as part of the functions process…. (and are expected and will be dealt with by whatever is calling it)…. while Exceptions are for exceptional circumstances / technical failings that may not be expected during normal operation such as a catastrophic fail (e.g. Server not found).  An Either/Validation business validation would be returned in a message on the same server or to a calling service, while technical failings might do things like fail-over.  <br>&gt;&gt; <br>&gt;&gt; Not sure if I am expressing myself correctly.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-23, at 13:32:06, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, you definitely can use this Either to recover the Validation monad a la Scala.  I think I have to draw up an implementation and submit it to Swiftz!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/01/22 23:45、Craig Cruden &lt;ccruden at novafore.com&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was reading the proposal and I have to admit I do like Either and have used it extensively in Scala for normal exceptions (business validations) leaving exceptions to … exceptional circumstances.   If I went back I think I could get rid of quite a bit of stuff if I had put more thought into it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When it comes to validations though I was wondering how you saw it coming together:  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; i.e. you have a set of validations that you run (independent validations) where after you finished if any of them has a validation you just want a list of business exceptions.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The other scenario I could see is dependent validations where certain validations you want to skip because a validation that it was dependent on failed - i.e. you don’t want to be flooded with other validations which occur solely due to an earlier failed validation.  (i.e. concise execution of a list of validations or something like that).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-01-21, at 10:17:34, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hey all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks all!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>January 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;<br>&gt; Just added a section of motivating examples to the Either proposal.  Ping<br>&gt; me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;<br>&gt;<br>&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;<br>&gt;<br>Your motivating examples (including all the projects you linked except &quot;Any<br>many more&quot;) overwhelmingly use the Either (or similar type) to represent<br>success/failure. I&#39;m not sure there&#39;s a single example where the names Left<br>and Right actually make sense in the problem domain. I&#39;m not 100% sure<br>about func alternate in Madness/Alternation.swift. It definitely uses<br>Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them<br>as something else. Which makes those names all the more maddening.<br></p><p>I checked my company&#39;s largest Scala project, which is over 300,000 lines.<br>We use Scala&#39;s Try/Success/Failure in dozens of places. We use<br>Either/Left/Right once, in a thrown-together report-generating script,<br>which would probably have been written in awk or perl if it didn&#39;t need to<br>read binary log files. (The ability of IntelliJ to reliably find all uses<br>of a class or method is not to be underestimated. Hint hint, team Xcode.)<br></p><p>I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical<br>about generic Either/Left/Right.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/042df875/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 23, 2016 at 01:00:00am</p></header><div class="content"><p>My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br></p><p>~Robert Widmann<br></p><p>2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt; <br>&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt; <br>&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt; <br>&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt; <br>&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/1155eafa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 22, 2016 at 10:00:00pm</p></header><div class="content"><p>+1.<br></p><p>There have been discussions about generic typealiases/newtypes on this list before. If getting something in for Swift 2 isn&#39;t a must-have, I wonder if we could leverage those features to make both camps happy. Being able to partially apply a generic type to form a new generic type would allow us to have something like:<br></p><p>enum Either&lt;T, U&gt; {<br>  case Left&lt;T&gt;, Right&lt;U&gt;<br>}<br></p><p>typealias Result&lt;GoodType&gt; = Either&lt; GoodType, ErrorType&gt;<br></p><p>Of course, the above raises the question as to whether an &#39;Either&#39; that just happens to have the right type be an ErrorType should be interchangeable with the corresponding &#39;Result&#39;, etc.<br></p><p>However, the above proposal might be infeasible from a theoretical or implementation perspective; if that&#39;s the case let&#39;s not get sidetracked :).<br></p><p>Best,<br>Austin<br></p><p><br>&gt; On Jan 22, 2016, at 10:22 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt; <br>&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt; <br>&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt; <br>&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/ee09c8db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 23, 2016 at 01:00:00am</p></header><div class="content"><p>Precisely.  That&#39;s the plan.<br></p><p>Even if that doesn&#39;t go through, it isn&#39;t hard to just wrap it or declare a typealias yourself in an enum with no cases:<br></p><p>enum Result&lt;E : ErrorType, T&gt; {<br>   typealias T = Either&lt;E, T&gt;<br>}<br></p><p>func foo() -&gt; Result&lt;FooErrorType, ResultType&gt; {<br>    //...<br>}<br></p><p>~Robert Widmann<br></p><p>2016/01/23 1:34、Austin Zheng &lt;austinzheng at gmail.com&gt; のメッセージ:<br></p><p>&gt; +1.<br>&gt; <br>&gt; There have been discussions about generic typealiases/newtypes on this list before. If getting something in for Swift 2 isn&#39;t a must-have, I wonder if we could leverage those features to make both camps happy. Being able to partially apply a generic type to form a new generic type would allow us to have something like:<br>&gt; <br>&gt; enum Either&lt;T, U&gt; {<br>&gt;   case Left&lt;T&gt;, Right&lt;U&gt;<br>&gt; }<br>&gt; <br>&gt; typealias Result&lt;GoodType&gt; = Either&lt; GoodType, ErrorType&gt;<br>&gt; <br>&gt; Of course, the above raises the question as to whether an &#39;Either&#39; that just happens to have the right type be an ErrorType should be interchangeable with the corresponding &#39;Result&#39;, etc.<br>&gt; <br>&gt; However, the above proposal might be infeasible from a theoretical or implementation perspective; if that&#39;s the case let&#39;s not get sidetracked :).<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 10:22 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/3537810c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 23, 2016 at 01:00:00am</p></header><div class="content"><p>Whoops, dropped a `.T`, but you get the picture.<br></p><p>~Robert Widmann<br></p><p>2016/01/23 1:47、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br></p><p>&gt; Precisely.  That&#39;s the plan.<br>&gt; <br>&gt; Even if that doesn&#39;t go through, it isn&#39;t hard to just wrap it or declare a typealias yourself in an enum with no cases:<br>&gt; <br>&gt; enum Result&lt;E : ErrorType, T&gt; {<br>&gt;    typealias T = Either&lt;E, T&gt;<br>&gt; }<br>&gt; <br>&gt; func foo() -&gt; Result&lt;FooErrorType, ResultType&gt; {<br>&gt;     //...<br>&gt; }<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/23 1:34、Austin Zheng &lt;austinzheng at gmail.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; +1.<br>&gt;&gt; <br>&gt;&gt; There have been discussions about generic typealiases/newtypes on this list before. If getting something in for Swift 2 isn&#39;t a must-have, I wonder if we could leverage those features to make both camps happy. Being able to partially apply a generic type to form a new generic type would allow us to have something like:<br>&gt;&gt; <br>&gt;&gt; enum Either&lt;T, U&gt; {<br>&gt;&gt;   case Left&lt;T&gt;, Right&lt;U&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; typealias Result&lt;GoodType&gt; = Either&lt; GoodType, ErrorType&gt;<br>&gt;&gt; <br>&gt;&gt; Of course, the above raises the question as to whether an &#39;Either&#39; that just happens to have the right type be an ErrorType should be interchangeable with the corresponding &#39;Result&#39;, etc.<br>&gt;&gt; <br>&gt;&gt; However, the above proposal might be infeasible from a theoretical or implementation perspective; if that&#39;s the case let&#39;s not get sidetracked :).<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 10:22 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/1a33cea1/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 25, 2016 at 09:00:00pm</p></header><div class="content"><p>There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning.<br>`Either&lt;T&gt;` has *no intuitive meaning whatsoever*. It says absolutely<br>*nothing* about what it means beyond the fact that there are two<br>potential values. As a result, it is a largely useless type whose sole<br>redeeming feature is it allows developers to avoid having to define<br>their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you<br>actually *want* to define your own enum so you can attach meaning to<br>the value.<br></p><p>If it&#39;s not obvious, I&#39;m very strongly against having a generic Either<br>type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt; My overwhelming concern, after having a conversation with Chris, is<br>&gt; that implementing a Result&lt;T&gt; means we are strongly implying a<br>&gt; particular semantics and use case when we could generalize and<br>&gt; abstract for no cost but an extra generic parameter.  In F#,<br>&gt; Core.Choice can be used to build a Validation or Result monad, but the<br>&gt; converse is impossible.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.<br>&gt;&gt;&gt; Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did<br>&gt;&gt;&gt; miss a lot).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Your motivating examples (including all the projects you linked<br>&gt;&gt; except &quot;Any many more&quot;) overwhelmingly use the Either (or similar<br>&gt;&gt; type) to represent success/failure. I&#39;m not sure there&#39;s a single<br>&gt;&gt; example where the names Left and Right actually make sense in the<br>&gt;&gt; problem domain. I&#39;m not 100% sure about func alternate in<br>&gt;&gt; Madness/Alternation.swift. It definitely uses Left/Right to mean<br>&gt;&gt; Failure/Result, but I couldn&#39;t tell if it also uses them as something<br>&gt;&gt; else. Which makes those names all the more maddening.<br>&gt;&gt;<br>&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000<br>&gt;&gt; lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use<br>&gt;&gt; Either/Left/Right once, in a thrown-together report-generating<br>&gt;&gt; script, which would probably have been written in awk or perl if it<br>&gt;&gt; didn&#39;t need to read binary log files. (The ability of IntelliJ to<br>&gt;&gt; reliably find all uses of a class or method is not to be<br>&gt;&gt; underestimated. Hint hint, team Xcode.)<br>&gt;&gt;<br>&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very<br>&gt;&gt; skeptical about generic Either/Left/Right.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/f1cd01ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>I don’t agree that `Result` as a name is any more intuitive than `Either` (a disjointed union).  The end result of any function is a `resulting` value regardless of what type it is.  `Either` is just indicating that the function can return either of two types (generalized).  So when you are returning either of two types (regardless of whether it is validation) - it would intuitively be driven by what type you are returning.  I have never seen an Either used for the same type on both sides.  As such I don’t find `Result` being intuitive vs `Either` being not a very strong argument.  <br></p><p>`Either` is a type that is common to many functional languages, or functional implementations in more general languages.<br></p><p><br></p><p>&gt; On 2016-01-26, at 12:55:27, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;  <br>&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;  <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;  <br>&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/3027c67b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>January 26, 2016 at 12:00:00am</p></header><div class="content"><p>On Tue, Jan 26, 2016 at 12:13 AM, Craig Cruden via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don’t agree that `Result` as a name is any more intuitive than `Either`<br>&gt; (a disjointed union).  The end result of any function is a `resulting`<br>&gt; value regardless of what type it is.<br>&gt;<br></p><p>That&#39;s true. Outcome might be a better name than Result. Scala calls it Try.<br></p><p>Anyway, Success and Failure have clear, relevant meanings. Left and Right<br>have no relevant meaning in most uses of Either. The overwhelming majority<br>of the motivating examples in the proposal use a type named<br>Result/Success/Failure type, or use Either/Left/Right to mean<br>Result/Success/Failure (or Result/Failure/Success). The one example I found<br>(in Madness) where the names Left and Right are meaningful **also**<br>confusingly uses the Either type as a Result type in the same statements.<br>For example:<br></p><p>return .Right(.Right(tree), sourcePos)<br></p><p>The outer Right means Success; the inner Right means the right-hand branch<br>of an alternation operator (I think). So in the one example I could find<br>(from the proposal) where the names Left and Right are relevant, the code<br>would be clearer if it also used a separate Result/Success/Failure type.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/fa954252/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 25, 2016 at 11:00:00pm</p></header><div class="content"><p>On Mon, Jan 25, 2016 at 10:38 PM, Rob Mayoff via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; For example:<br>&gt;<br>&gt; return .Right(.Right(tree), sourcePos)<br>&gt;<br>&gt; The outer Right means Success; the inner Right means the right-hand branch<br>&gt; of an alternation operator (I think).<br></p><p>Your example is a perfect illustration of the problem with Either --<br>it does not have domain-specific semantics attached, and thus<br>compromises readability.<br></p><p>You had to add an extra sentence to explain what a supposedly simple<br>line of code does, and even then you had to add &quot;I think&quot;, which I<br>understood you used to express uncertainty about the explanation.  I<br>don&#39;t think promoting this kind of coding style is a goal for Swift.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 03:00:00am</p></header><div class="content"><p>Perhaps we can imply more semantics with a name, but not those specifically already covered by throws.  For example, I&#39;ve become fond of this variant of late<br></p><p>enum Choice&lt;This, That&gt; {<br>    case First(This)<br>    case Second(That)<br>}<br></p><p>Then this little tree example becomes more clear in my opinion:<br></p><p>func treeMe() -&gt; Choice&lt;(Choice&lt;Tree, Int&gt;, Int), Int&gt; {<br>    return .First(.First(tree), sourcePos)<br>}<br></p><p>~Robert Widmann<br></p><p>2016/01/26 2:24、Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; On Mon, Jan 25, 2016 at 10:38 PM, Rob Mayoff via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; return .Right(.Right(tree), sourcePos)<br>&gt;&gt; <br>&gt;&gt; The outer Right means Success; the inner Right means the right-hand branch<br>&gt;&gt; of an alternation operator (I think).<br>&gt; <br>&gt; Your example is a perfect illustration of the problem with Either --<br>&gt; it does not have domain-specific semantics attached, and thus<br>&gt; compromises readability.<br>&gt; <br>&gt; You had to add an extra sentence to explain what a supposedly simple<br>&gt; line of code does, and even then you had to add &quot;I think&quot;, which I<br>&gt; understood you used to express uncertainty about the explanation.  I<br>&gt; don&#39;t think promoting this kind of coding style is a goal for Swift.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 01:00:00am</p></header><div class="content"><p>Are you opposed to the name or the semantics?<br></p><p>I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br></p><p>~Robert Widmann<br></p><p>2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;  <br>&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;  <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;  <br>&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/96d634c9/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Then we are fundamentally at odds, because I am categorically opposed to any solution that does not have specific meaning attached to the two variants. Either is an awful type that only serves to make APIs harder to understand, and literally every non-trivial usage of Either I’ve actually seen in practice, it has been used exactly the way Result&lt;T&gt; would naturally be defined (where “trivial” means usage in any kind of actual API, as opposed to sample code or scratch functions using Either to prototype something that, if turned into actual API, would replace the usage of Either with a more well-defined enum). And the existence of Either only serves to encourage people to use it, which produces an overall negative effect on the quality of APIs.<br></p><p>-Kevin Ballard<br></p><p>&gt; On Jan 25, 2016, at 10:27 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Are you opposed to the name or the semantics?<br>&gt; <br>&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;  <br>&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/6467e806/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 02:00:00am</p></header><div class="content"><p>So you take issue with the name?  Have you seen our section of alternatives?<br></p><p>~Robert Widmann<br></p><p>2016/01/26 1:39、Kevin Ballard &lt;kevin at sb.org&gt; のメッセージ:<br></p><p>&gt; Then we are fundamentally at odds, because I am categorically opposed to any solution that does not have specific meaning attached to the two variants. Either is an awful type that only serves to make APIs harder to understand, and literally every non-trivial usage of Either I’ve actually seen in practice, it has been used exactly the way Result&lt;T&gt; would naturally be defined (where “trivial” means usage in any kind of actual API, as opposed to sample code or scratch functions using Either to prototype something that, if turned into actual API, would replace the usage of Either with a more well-defined enum). And the existence of Either only serves to encourage people to use it, which produces an overall negative effect on the quality of APIs.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt; <br>&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/491879f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 25, 2016 at 11:00:00pm</p></header><div class="content"><p>No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br></p><p>A type like this in the standard library will have a significant detrimental effect on the entire Swift ecosystem. Swift makes it so easy to define types with semantic meaning, but this type is only useful if people actually use it, and every time someone uses this they&#39;ll be losing the semantic meaning that would have been carried by the type they&#39;d have defined otherwise.<br></p><p>Also, FWIW, every single one of your motivating examples would be significantly improved by the use of a Result&lt;T&gt;or Result&lt;T,E&gt;instead of Either.<br></p><p>-Kevin Ballard<br></p><p>On Jan 25, 2016, 11:21 PM -0800, Developer&lt;devteam.codafi at gmail.com&gt;, wrote:<br>&gt; So you take issue with the name?Have you seen our section of alternatives?<br>&gt;  <br>&gt; ~Robert Widmann<br>&gt;  <br>&gt; 2016/01/26 1:39、Kevin Ballard&lt;kevin at sb.org(mailto:kevin at sb.org)&gt;のメッセージ:<br>&gt;  <br>&gt; &gt; Then we are fundamentally at odds, because I am categorically opposed to any solution that doesnothave specific meaning attached to the two variants. Either is an awful type that only serves to make APIs harder to understand, and literally every non-trivial usage of Either I’ve actually seen in practice, it has been used exactly the way Result&lt;T&gt;would naturally be defined (where “trivial” means usage in any kind of actual API, as opposed to sample code or scratch functions using Either to prototype something that, if turned into actual API, would replace the usage of Either with a more well-defined enum). And the existence of Either only serves to encourage people to use it, which produces an overall negative effect on the quality of APIs.<br>&gt; &gt;  <br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; &gt; On Jan 25, 2016, at 10:27 PM, Developer&lt;devteam.codafi at gmail.com(mailto:devteam.codafi at gmail.com)&gt;wrote:<br>&gt; &gt; &gt; Are you opposed to the name or the semantics?<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; I will not accept a revision that reduces the level of abstraction of the current proposal.I will, however, accept name changes.Result, though, I believe is out of the question.It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; ~Robert Widmann<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;のメッセージ:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` hasno intuitive meaning whatsoever. It says absolutelynothingabout what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt;you actuallywantto define your own enum so you can attach meaning to the value.<br>&gt; &gt; &gt; &gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt;or Result&lt;T,E&gt;.<br>&gt; &gt; &gt; &gt; -Kevin Ballard<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt; &gt; &gt; &gt; &gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt;means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt; &gt; &gt; &gt; &gt; ~Robert Widmann<br>&gt; &gt; &gt; &gt; &gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;のメッセージ:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Just added a section of motivating examples to the Either proposal.Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt; &gt; &gt; &gt; &gt; &gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt; &gt; &gt; &gt; &gt; &gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt; &gt; &gt; &gt; &gt; &gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/3cd3c186/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 02:00:00am</p></header><div class="content"><p>Because the shape is what matters to me most.  Whether the type is defined as <br></p><p>enum Either&lt;L, R&gt; { //... }<br>enum Result&lt;T, E&gt; { //... }<br>enum Choice&lt;This, That&gt; { //... }<br>enum XOR&lt;L, R&gt; { //... }<br>enum V&lt;L, R&gt; { //... }<br>enum These&lt;L, R&gt; { //... }<br></p><p>the point is that the standard library offers a sum type that doesn&#39;t attempt to invade the space taken over by throws (as I say in the proposal).  If we are to encourage that, then a type named Result that has a lobe specifically dedicated to error handling, in some cases even constrained by ErrorType, is an invasion indeed.   The type needn&#39;t carry semantics already provided by the language, and in that case it must carry the most general of semantics: those implied by structure and reinforced by documentation.<br></p><p>As for bias, I&#39;ll admit that it is insufficiently addressed in the proposal (however I do acknowledge this very question would arise).  We chose a left bias because of Rust&#39;s success and a lack of Haskell-style biased type application to deal with in type classes (not that we have any now anyway).  From a less technical perspective, the idea that an error should come first is counterintuitive.  It makes more sense to emphasize the successful case by placing it &quot;first&quot;.<br></p><p>I believe we disagree at such a level, outside of naming and what all that entails, because this seems like a Haskellism and Haskell&#39;s idea about error handling is opinionated to some and is made even more so by an implicit understanding required to interact with the rest of the ecosystem.  Either is not a fundamentally meaningless type in Haskell, or here, and it has a very precise interpretation computationally.  Trouble is, conveying that sentiment also inevitably leads to incredibly technical arguments that leaves novices with a bitter taste - who wants to learn about Profunctors to figure out why Either had a right-bias anyhow?  The proposal is aimed towards the Swift community, not the Haskell one.  <br></p><p>I request that you suspend any preconceptions and take this for what it is: A sum type, nothing more.  If we wished to cause damage to the community, this proposal would be about replacing throws entirely and forcing this change - or even a Result&lt;T&gt; variant of it - upon everybody.  In the short term this will make a few more people sit up and think about when they need throws and when they need a sum.  In the long term it will enable a new class of typesafe programs and higher-order patterns to be written without dependence on a third party.<br></p><p>So, that said, I&#39;m open to a name change, but we must keep the generality of the type intact to a point.<br></p><p>~Robert Widmann<br></p><p>2016/01/26 2:30、Kevin Ballard &lt;kevin at sb.org&gt; のメッセージ:<br></p><p>&gt; No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br>&gt; <br>&gt; A type like this in the standard library will have a significant detrimental effect on the entire Swift ecosystem. Swift makes it so easy to define types with semantic meaning, but this type is only useful if people actually use it, and every time someone uses this they&#39;ll be losing the semantic meaning that would have been carried by the type they&#39;d have defined otherwise.<br>&gt; <br>&gt; Also, FWIW, every single one of your motivating examples would be significantly improved by the use of a Result&lt;T&gt; or Result&lt;T,E&gt; instead of Either.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt;&gt; On Jan 25, 2016, 11:21 PM -0800, Developer &lt;devteam.codafi at gmail.com&gt;, wrote:<br>&gt;&gt; So you take issue with the name?  Have you seen our section of alternatives?<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/26 1:39、Kevin Ballard &lt;kevin at sb.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; Then we are fundamentally at odds, because I am categorically opposed to any solution that does not have specific meaning attached to the two variants. Either is an awful type that only serves to make APIs harder to understand, and literally every non-trivial usage of Either I’ve actually seen in practice, it has been used exactly the way Result&lt;T&gt; would naturally be defined (where “trivial” means usage in any kind of actual API, as opposed to sample code or scratch functions using Either to prototype something that, if turned into actual API, would replace the usage of Either with a more well-defined enum). And the existence of Either only serves to encourage people to use it, which produces an overall negative effect on the quality of APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/e6185499/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I believe we disagree at such a level, outside of naming and what all that entails, because this seems like a Haskellism and Haskell&#39;s idea about error handling is opinionated to some and is made even more so by an implicit understanding required to interact with the rest of the ecosystem.  Either is not a fundamentally meaningless type in Haskell, or here, and it has a very precise interpretation computationally.  Trouble is, conveying that sentiment also inevitably leads to incredibly technical arguments that leaves novices with a bitter taste - who wants to learn about Profunctors to figure out why Either had a right-bias anyhow?  The proposal is aimed towards the Swift community, not the Haskell one.  <br></p><p>Since this is more of a fundamental / glue type for functional paradigm — a common type between potential functional oriented libraries (you don’t want to have two libraries, then convert between the two — you want them to play together).   Without fleshing out the common usage within different functional implementations it may be a hard sell… (i.e. review in combination with other proposals).  <br></p><p>As for the earlier comment about Scala having Try, Scala also has Either - Either being implemented first then Try implemented as a wrapper for Try/Throw/Catch functionality (maybe something about try/catch are within one jvm thread which gets lost when you are implementing actors etc. which are across servers - so wrapping a java exception with a monadic type).  Swift already has try’s.  <br></p><p>PS if I am not coherent - it is because I am under the influence :o<br></p><p><br></p><p>  <br></p><p>&gt; On 2016-01-26, at 14:59:54, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Because the shape is what matters to me most.  Whether the type is defined as <br>&gt; <br>&gt; enum Either&lt;L, R&gt; { //... }<br>&gt; enum Result&lt;T, E&gt; { //... }<br>&gt; enum Choice&lt;This, That&gt; { //... }<br>&gt; enum XOR&lt;L, R&gt; { //... }<br>&gt; enum V&lt;L, R&gt; { //... }<br>&gt; enum These&lt;L, R&gt; { //... }<br>&gt; <br>&gt; the point is that the standard library offers a sum type that doesn&#39;t attempt to invade the space taken over by throws (as I say in the proposal).  If we are to encourage that, then a type named Result that has a lobe specifically dedicated to error handling, in some cases even constrained by ErrorType, is an invasion indeed.   The type needn&#39;t carry semantics already provided by the language, and in that case it must carry the most general of semantics: those implied by structure and reinforced by documentation.<br>&gt; <br>&gt; As for bias, I&#39;ll admit that it is insufficiently addressed in the proposal (however I do acknowledge this very question would arise).  We chose a left bias because of Rust&#39;s success and a lack of Haskell-style biased type application to deal with in type classes (not that we have any now anyway).  From a less technical perspective, the idea that an error should come first is counterintuitive.  It makes more sense to emphasize the successful case by placing it &quot;first&quot;.<br>&gt; <br>&gt; I believe we disagree at such a level, outside of naming and what all that entails, because this seems like a Haskellism and Haskell&#39;s idea about error handling is opinionated to some and is made even more so by an implicit understanding required to interact with the rest of the ecosystem.  Either is not a fundamentally meaningless type in Haskell, or here, and it has a very precise interpretation computationally.  Trouble is, conveying that sentiment also inevitably leads to incredibly technical arguments that leaves novices with a bitter taste - who wants to learn about Profunctors to figure out why Either had a right-bias anyhow?  The proposal is aimed towards the Swift community, not the Haskell one.  <br>&gt; <br>&gt; I request that you suspend any preconceptions and take this for what it is: A sum type, nothing more.  If we wished to cause damage to the community, this proposal would be about replacing throws entirely and forcing this change - or even a Result&lt;T&gt; variant of it - upon everybody.  In the short term this will make a few more people sit up and think about when they need throws and when they need a sum.  In the long term it will enable a new class of typesafe programs and higher-order patterns to be written without dependence on a third party.<br>&gt; <br>&gt; So, that said, I&#39;m open to a name change, but we must keep the generality of the type intact to a point.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/26 2:30、Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br>&gt;&gt; <br>&gt;&gt; A type like this in the standard library will have a significant detrimental effect on the entire Swift ecosystem. Swift makes it so easy to define types with semantic meaning, but this type is only useful if people actually use it, and every time someone uses this they&#39;ll be losing the semantic meaning that would have been carried by the type they&#39;d have defined otherwise.<br>&gt;&gt; <br>&gt;&gt; Also, FWIW, every single one of your motivating examples would be significantly improved by the use of a Result&lt;T&gt; or Result&lt;T,E&gt; instead of Either.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; On Jan 25, 2016, 11:21 PM -0800, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt;, wrote:<br>&gt;&gt;&gt; So you take issue with the name?  Have you seen our section of alternatives?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/01/26 1:39、Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then we are fundamentally at odds, because I am categorically opposed to any solution that does not have specific meaning attached to the two variants. Either is an awful type that only serves to make APIs harder to understand, and literally every non-trivial usage of Either I’ve actually seen in practice, it has been used exactly the way Result&lt;T&gt; would naturally be defined (where “trivial” means usage in any kind of actual API, as opposed to sample code or scratch functions using Either to prototype something that, if turned into actual API, would replace the usage of Either with a more well-defined enum). And the existence of Either only serves to encourage people to use it, which produces an overall negative effect on the quality of APIs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/ce8207cd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 26, 2016 at 08:00:00pm</p></header><div class="content"><p>It seems like the argument comes down to:<br> * An either-like type should be named something meaningful for the context<br>it is used<br> * There are a lot of cases where an either-like type is useful, there may<br>generalised functions that are often used on them<br> * Is defining or re-defining an either type hard?<br> * Is it too niche to be in the standard library<br></p><p>Personally I think defining an either type is not hard:<br></p><p><br>    enum Result&lt;T,E: ErrorType&gt; {<br></p><p>        case Value(T), Error(E)<br></p><p>    }<br></p><p>I think it may be too niche to be in the standard library, from the<br>&quot;meaningful context&quot; perspective.<br></p><p>Perhaps what we want is not an either type, but an easy to conform to<br>protocol that allows some reuse with Either-style types. Possibly with some<br>compiler magic to make it easy for enums to conform to it...<br></p><p>I&#39;ve thrown an example protocol together here:<br>    https://github.com/therealbnut/Either<br></p><p><br>On Tue, Jan 26, 2016 at 6:59 PM, Developer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Because the shape is what matters to me most.  Whether the type is defined<br>&gt; as<br>&gt;<br>&gt; enum Either&lt;L, R&gt; { //... }<br>&gt; enum Result&lt;T, E&gt; { //... }<br>&gt; enum Choice&lt;This, That&gt; { //... }<br>&gt; enum XOR&lt;L, R&gt; { //... }<br>&gt; enum V&lt;L, R&gt; { //... }<br>&gt; enum These&lt;L, R&gt; { //... }<br>&gt;<br>&gt; the point is that the standard library offers a sum type that doesn&#39;t<br>&gt; attempt to invade the space taken over by throws (as I say in the<br>&gt; proposal).  If we are to encourage that, then a type named Result that has<br>&gt; a lobe specifically dedicated to error handling, in some cases even<br>&gt; constrained by ErrorType, is an invasion indeed.   The type needn&#39;t carry<br>&gt; semantics already provided by the language, and in that case it must carry<br>&gt; the most general of semantics: those implied by structure and reinforced by<br>&gt; documentation.<br>&gt;<br>&gt; As for bias, I&#39;ll admit that it is insufficiently addressed in the<br>&gt; proposal (however I do acknowledge this very question would arise).  We<br>&gt; chose a left bias because of Rust&#39;s success and a lack of Haskell-style<br>&gt; biased type application to deal with in type classes (not that we have any<br>&gt; now anyway).  From a less technical perspective, the idea that an error<br>&gt; should come first is counterintuitive.  It makes more sense to emphasize<br>&gt; the successful case by placing it &quot;first&quot;.<br>&gt;<br>&gt; I believe we disagree at such a level, outside of naming and what all that<br>&gt; entails, because this seems like a Haskellism and Haskell&#39;s idea about<br>&gt; error handling is opinionated to some and is made even more so by an<br>&gt; implicit understanding required to interact with the rest of the<br>&gt; ecosystem.  Either is not a fundamentally meaningless type in Haskell, or<br>&gt; here, and it has a very precise interpretation computationally.  Trouble<br>&gt; is, conveying that sentiment also inevitably leads to incredibly technical<br>&gt; arguments that leaves novices with a bitter taste - who wants to learn<br>&gt; about Profunctors to figure out why Either had a right-bias anyhow?  The<br>&gt; proposal is aimed towards the Swift community, not the Haskell one.<br>&gt;<br>&gt; I request that you suspend any preconceptions and take this for what it<br>&gt; is: A sum type, nothing more.  If we wished to cause damage to the<br>&gt; community, this proposal would be about replacing throws entirely and<br>&gt; forcing this change - or even a Result&lt;T&gt; variant of it - upon everybody.<br>&gt; In the short term this will make a few more people sit up and think about<br>&gt; when they need throws and when they need a sum.  In the long term it will<br>&gt; enable a new class of typesafe programs and higher-order patterns to be<br>&gt; written without dependence on a third party.<br>&gt;<br>&gt; So, that said, I&#39;m open to a name change, but we must keep the generality<br>&gt; of the type intact to a point.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/26 2:30、Kevin Ballard &lt;kevin at sb.org&gt; のメッセージ:<br>&gt;<br>&gt; No, I take issue with the entire fundamental idea behind your proposal.<br>&gt; You&#39;ve explicitly defined this type purely by its shape, with no meaning<br>&gt; whatsoever given to either variant, except insofar as the type is<br>&gt; Left-biased (which only serves to be even more confusing; since there&#39;s no<br>&gt; actual meaning assigned to Left/Right, what is the justification for adding<br>&gt; the left-biasing?)<br>&gt;<br>&gt; A type like this in the standard library will have a significant<br>&gt; detrimental effect on the entire Swift ecosystem. Swift makes it so easy to<br>&gt; define types with semantic meaning, but this type is only useful if people<br>&gt; actually use it, and every time someone uses this they&#39;ll be losing the<br>&gt; semantic meaning that would have been carried by the type they&#39;d have<br>&gt; defined otherwise.<br>&gt;<br>&gt; Also, FWIW, every single one of your motivating examples would be<br>&gt; significantly improved by the use of a Result&lt;T&gt; or Result&lt;T,E&gt; instead of<br>&gt; Either.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Jan 25, 2016, 11:21 PM -0800, Developer &lt;devteam.codafi at gmail.com&gt;,<br>&gt; wrote:<br>&gt;<br>&gt; So you take issue with the name?  Have you seen our section of<br>&gt; alternatives?<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/26 1:39、Kevin Ballard &lt;kevin at sb.org&gt; のメッセージ:<br>&gt;<br>&gt; Then we are fundamentally at odds, because I am categorically opposed to<br>&gt; any solution that does *not* have specific meaning attached to the two<br>&gt; variants. Either is an awful type that only serves to make APIs harder to<br>&gt; understand, and literally every non-trivial usage of Either I’ve actually<br>&gt; seen in practice, it has been used exactly the way Result&lt;T&gt; would<br>&gt; naturally be defined (where “trivial” means usage in any kind of actual<br>&gt; API, as opposed to sample code or scratch functions using Either to<br>&gt; prototype something that, if turned into actual API, would replace the<br>&gt; usage of Either with a more well-defined enum). And the existence of Either<br>&gt; only serves to encourage people to use it, which produces an overall<br>&gt; negative effect on the quality of APIs.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Jan 25, 2016, at 10:27 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;<br>&gt; Are you opposed to the name or the semantics?<br>&gt;<br>&gt; I will not accept a revision that reduces the level of abstraction of the<br>&gt; current proposal.  I will, however, accept name changes.  Result, though, I<br>&gt; believe is out of the question.  It strongly implies a common but pointed<br>&gt; set of semantics that discourage thinking of this type as data and more as<br>&gt; an alternative to throws.  I do not wish to emphasize the error case, or<br>&gt; the theoretical case, I wish to encourage the general case.  We must<br>&gt; remember that despite Rust&#39;s success, they do not have to live alongside an<br>&gt; exceptions mechanism like Either does.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;<br>&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning.<br>&gt; `Either&lt;T&gt;` has *no intuitive meaning whatsoever*. It says absolutely<br>&gt; *nothing* about what it means beyond the fact that there are two<br>&gt; potential values. As a result, it is a largely useless type whose sole<br>&gt; redeeming feature is it allows developers to avoid having to define their<br>&gt; own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually<br>&gt; *want* to define your own enum so you can attach meaning to the value.<br>&gt;<br>&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either<br>&gt; type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;<br>&gt; My overwhelming concern, after having a conversation with Chris, is that<br>&gt; implementing a Result&lt;T&gt; means we are strongly implying a particular<br>&gt; semantics and use case when we could generalize and abstract for no cost<br>&gt; but an extra generic parameter.  In F#, Core.Choice can be used to build a<br>&gt; Validation or Result monad, but the converse is impossible.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; のメッセージ:<br>&gt;<br>&gt; Just added a section of motivating examples to the Either proposal.  Ping<br>&gt; me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;<br>&gt;<br>&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;<br>&gt;<br>&gt;<br>&gt; Your motivating examples (including all the projects you linked except<br>&gt; &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to<br>&gt; represent success/failure. I&#39;m not sure there&#39;s a single example where the<br>&gt; names Left and Right actually make sense in the problem domain. I&#39;m not<br>&gt; 100% sure about func alternate in Madness/Alternation.swift. It definitely<br>&gt; uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses<br>&gt; them as something else. Which makes those names all the more maddening.<br>&gt;<br>&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines.<br>&gt; We use Scala&#39;s Try/Success/Failure in dozens of places. We use<br>&gt; Either/Left/Right once, in a thrown-together report-generating script,<br>&gt; which would probably have been written in awk or perl if it didn&#39;t need to<br>&gt; read binary log files. (The ability of IntelliJ to reliably find all uses<br>&gt; of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;<br>&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical<br>&gt; about generic Either/Left/Right.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/40f9489e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fc40f95a5c6b063df44b3bc136d764b?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.com&gt;<p>January 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 26 Jan 2016, at 09:52, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems like the argument comes down to:<br>&gt;  * An either-like type should be named something meaningful for the context it is used<br>&gt;  * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br>&gt;  * Is defining or re-defining an either type hard?<br>&gt;  * Is it too niche to be in the standard library<br>&gt; <br>&gt; Personally I think defining an either type is not hard:<br>&gt; <br>&gt;     enum Result&lt;T,E: ErrorType&gt; {<br>&gt;         case Value(T), Error(E)<br>&gt;     }<br>&gt; <br>&gt; I think it may be too niche to be in the standard library, from the &quot;meaningful context&quot; perspective.<br>&gt; <br>&gt; Perhaps what we want is not an either type, but an easy to conform to protocol that allows some reuse with Either-style types. Possibly with some compiler magic to make it easy for enums to conform to it...<br>&gt; <br>&gt; I&#39;ve thrown an example protocol together here:<br>&gt;     https://github.com/therealbnut/Either &lt;https://github.com/therealbnut/Either&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Personally I agree that this is pretty niche these days; if I want to return either a result or an error, then I now have the option of throwing an exception, and this in my experience was the most common case where something like this was needed.<br></p><p>If the aim is to allow a function to return one of several possible types, then the question is… why only two? If we were looking at allowing several possible return types then what I’d really rather see is some kind of compiler magic that supports that, so I could do stuff like:<br></p><p>	func myFunc() -&gt; Int, Double, String { … }<br></p><p>This could then create an implicit enum that I could then check via cases like:<br></p><p>	case .Double(value): doSomething(value)<br>	case .Int(value): doSomethingElse(value)<br>	case .String(value): doSomethingStringy(value)<br></p><p>There could also be some kind of naming syntax, to enable returning one of two possible values of the same type, but with different meanings, otherwise the case would be implicitly named for the type of data that it holds.<br></p><p>Otherwise… I think use of Either is too specialised, and too easily done yourself with a name that’s more specific to your use-case.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/6c5f2778/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Same could be said of a n-tuple - it is pretty niche version of an array with n elements :p<br></p><p>I would argue that returning either of two types is a very common occurrence (more-so with functional style of programming).  If each functionally oriented library were to independently implement Either (which is what is happening now) — becomes a less than ideal situation.   I find it actually funny that there is talk about beefing up generics for generic programming, but generic types apparently are problematic :p.   <br></p><p>As for the the straw man argument if two then what about three — is that a common scenario?  I have never had a situation like that in any paradigm that was not a symptom of the coder doing something seriously wrong.<br></p><p>For procedural programmers you have the option of mutating (inout) parameter on a function (something I find really really ugly as a solution).  Throwing “try” exceptions for handling errors is common in things like Java and Swift (and as procedural error handling), but quickly become a nightmare of scrambled code.<br></p><p>I am looking right now at a Java class that has a couple hundred validations just on “Account” — some hard (i.e. error) some configurable (turn on or turn off for a logged on user), some overridable.  Because someone was afraid of a generalized solution and wanted a specific one situations like this may be unforeseen and not fit in a specialized (aka niche) solution.  Creating specialized implementations like `Result` requires a form of ESP to correction foresee every possible case, while Either is just really Either of two types (a common occurrence).<br></p><p>Throwing Exceptions (especially when you are returning a list of different property validations of everything that is wrong - so you don’t leave the user going back and fixing one property at a time then trying again) is not great.  <br></p><p><br></p><p><br>&gt; <br>&gt; Personally I agree that this is pretty niche these days; if I want to return either a result or an error, then I now have the option of throwing an exception, and this in my experience was the most common case where something like this was needed.<br>&gt; <br>&gt; If the aim is to allow a function to return one of several possible types, then the question is… why only two? If we were looking at allowing several possible return types then what I’d really rather see is some kind of compiler magic that supports that, so I could do stuff like:<br>&gt; <br>&gt; 	func myFunc() -&gt; Int, Double, String { … }<br>&gt; <br>&gt; This could then create an implicit enum that I could then check via cases like:<br>&gt; <br>&gt; 	case .Double(value): doSomething(value)<br>&gt; 	case .Int(value): doSomethingElse(value)<br>&gt; 	case .String(value): doSomethingStringy(value)<br>&gt; <br>&gt; There could also be some kind of naming syntax, to enable returning one of two possible values of the same type, but with different meanings, otherwise the case would be implicitly named for the type of data that it holds.<br>&gt; <br>&gt; Otherwise… I think use of Either is too specialised, and too easily done yourself with a name that’s more specific to your use-case.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/4673320e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 28, 2016 at 07:00:00am</p></header><div class="content"><p>As an alternative to Either for expressing a sum type I&#39;d like to throw real union types like Ceylon uses into the discussion.<br></p><p>http://ceylon-lang.org/documentation/1.2/tour/types/<br></p><p>-Thorsten <br></p><p>&gt; Am 26.01.2016 um 11:15 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On 26 Jan 2016, at 09:52, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It seems like the argument comes down to:<br>&gt;&gt;  * An either-like type should be named something meaningful for the context it is used<br>&gt;&gt;  * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br>&gt;&gt;  * Is defining or re-defining an either type hard?<br>&gt;&gt;  * Is it too niche to be in the standard library<br>&gt;&gt; <br>&gt;&gt; Personally I think defining an either type is not hard:<br>&gt;&gt; <br>&gt;&gt;     enum Result&lt;T,E: ErrorType&gt; {<br>&gt;&gt;         case Value(T), Error(E)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; I think it may be too niche to be in the standard library, from the &quot;meaningful context&quot; perspective.<br>&gt;&gt; <br>&gt;&gt; Perhaps what we want is not an either type, but an easy to conform to protocol that allows some reuse with Either-style types. Possibly with some compiler magic to make it easy for enums to conform to it...<br>&gt;&gt; <br>&gt;&gt; I&#39;ve thrown an example protocol together here:<br>&gt;&gt;     https://github.com/therealbnut/Either<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Personally I agree that this is pretty niche these days; if I want to return either a result or an error, then I now have the option of throwing an exception, and this in my experience was the most common case where something like this was needed.<br>&gt; <br>&gt; If the aim is to allow a function to return one of several possible types, then the question is… why only two? If we were looking at allowing several possible return types then what I’d really rather see is some kind of compiler magic that supports that, so I could do stuff like:<br>&gt; <br>&gt; 	func myFunc() -&gt; Int, Double, String { … }<br>&gt; <br>&gt; This could then create an implicit enum that I could then check via cases like:<br>&gt; <br>&gt; 	case .Double(value): doSomething(value)<br>&gt; 	case .Int(value): doSomethingElse(value)<br>&gt; 	case .String(value): doSomethingStringy(value)<br>&gt; <br>&gt; There could also be some kind of naming syntax, to enable returning one of two possible values of the same type, but with different meanings, otherwise the case would be implicitly named for the type of data that it holds.<br>&gt; <br>&gt; Otherwise… I think use of Either is too specialised, and too easily done yourself with a name that’s more specific to your use-case.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/27542da0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 12:00:00am</p></header><div class="content"><p>It actually looks interesting….  and more inline with what the spirit of the original proposal was about…  but of course a lot more work to implement than the simple Either.  (and of course getting rid of the “loaded” type name :p ).<br></p><p><br></p><p><br>&gt; On 2016-01-28, at 13:09:09, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As an alternative to Either for expressing a sum type I&#39;d like to throw real union types like Ceylon uses into the discussion.<br>&gt; <br>&gt; http://ceylon-lang.org/documentation/1.2/tour/types/ &lt;http://ceylon-lang.org/documentation/1.2/tour/types/&gt;<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 26.01.2016 um 11:15 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt;&gt; On 26 Jan 2016, at 09:52, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like the argument comes down to:<br>&gt;&gt;&gt;  * An either-like type should be named something meaningful for the context it is used<br>&gt;&gt;&gt;  * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br>&gt;&gt;&gt;  * Is defining or re-defining an either type hard?<br>&gt;&gt;&gt;  * Is it too niche to be in the standard library<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I think defining an either type is not hard:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enum Result&lt;T,E: ErrorType&gt; {<br>&gt;&gt;&gt;         case Value(T), Error(E)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it may be too niche to be in the standard library, from the &quot;meaningful context&quot; perspective.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps what we want is not an either type, but an easy to conform to protocol that allows some reuse with Either-style types. Possibly with some compiler magic to make it easy for enums to conform to it...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve thrown an example protocol together here:<br>&gt;&gt;&gt;     https://github.com/therealbnut/Either &lt;https://github.com/therealbnut/Either&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; Personally I agree that this is pretty niche these days; if I want to return either a result or an error, then I now have the option of throwing an exception, and this in my experience was the most common case where something like this was needed.<br>&gt;&gt; <br>&gt;&gt; If the aim is to allow a function to return one of several possible types, then the question is… why only two? If we were looking at allowing several possible return types then what I’d really rather see is some kind of compiler magic that supports that, so I could do stuff like:<br>&gt;&gt; <br>&gt;&gt; 	func myFunc() -&gt; Int, Double, String { … }<br>&gt;&gt; <br>&gt;&gt; This could then create an implicit enum that I could then check via cases like:<br>&gt;&gt; <br>&gt;&gt; 	case .Double(value): doSomething(value)<br>&gt;&gt; 	case .Int(value): doSomethingElse(value)<br>&gt;&gt; 	case .String(value): doSomethingStringy(value)<br>&gt;&gt; <br>&gt;&gt; There could also be some kind of naming syntax, to enable returning one of two possible values of the same type, but with different meanings, otherwise the case would be implicitly named for the type of data that it holds.<br>&gt;&gt; <br>&gt;&gt; Otherwise… I think use of Either is too specialised, and too easily done yourself with a name that’s more specific to your use-case.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f171aee2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 10:09 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As an alternative to Either for expressing a sum type I&#39;d like to throw real union types like Ceylon uses into the discussion.<br>&gt; <br>&gt; http://ceylon-lang.org/documentation/1.2/tour/types/ &lt;http://ceylon-lang.org/documentation/1.2/tour/types/&gt;<br>FWIW, this has been discussed before on swift-evolution.  Adding them isn’t out of the question, but it is a lot more complicated than it looks for the type checker.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/604807de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>So to summarize….<br></p><p>Either is too specialized and thus not a good add…<br></p><p>And the general implementation that is not specialized - is likely too complicated to easily add.<br></p><p>:o<br></p><p>&gt; On 2016-01-29, at 1:08:44, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 10:09 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As an alternative to Either for expressing a sum type I&#39;d like to throw real union types like Ceylon uses into the discussion.<br>&gt;&gt; <br>&gt;&gt; http://ceylon-lang.org/documentation/1.2/tour/types/ &lt;http://ceylon-lang.org/documentation/1.2/tour/types/&gt;<br>&gt; FWIW, this has been discussed before on swift-evolution.  Adding them isn’t out of the question, but it is a lot more complicated than it looks for the type checker.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/71e05bb0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 25, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Are you opposed to the name or the semantics?<br>&gt; <br>&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br></p><p>Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br></p><p>There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br></p><p>What will the advantage of Either be once enums get even more fully baked?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 02:00:00am</p></header><div class="content"><p>The proposal does not exist because it is &quot;hard or bad&quot; to define the type, but because it factors out a common pattern.  Adding language features on top of it should only serve to increase the power of the pattern, not decrease the effectiveness of the data type.  An Either with optional projections, for example, is literally the partial projection functions (called in Haskell [sometimes] fromLeft and fromRight).<br></p><p><br>~Robert Widmann<br></p><p>2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt; <br>&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt; <br>&gt; Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br>&gt; <br>&gt; There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br>&gt; <br>&gt; What will the advantage of Either be once enums get even more fully baked?<br>&gt; <br>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 26, 2016 at 07:00:00am</p></header><div class="content"><p>On Jan 25, 2016, at 11:20 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; The proposal does not exist because it is &quot;hard or bad&quot; to define the type, but because it factors out a common pattern.  <br></p><p>I know you intend that to be a positive statement, but design patterns are not always seen as a good thing.  See the criticism section of: https://en.m.wikipedia.org/wiki/Software_design_pattern for example.<br></p><p>We have a good language feature (enums/ADTs) that makes the win of Either extremely small or a loss (when you factor in the loss of specificity for a problem domain).<br></p><p>The bar for getting something into the stdlib is very high, and intentionally so.  Merely existing in some other language isn&#39;t enough, it needs to pull its weight given the context of Swift, and even there it needs to have strong justification.  Swift is intentionally designed so that third party packages can be on the same level as the standard library.<br></p><p>-Chris<br></p><p><br></p><p><br></p><p><br>&gt; Adding language features on top of it should only serve to increase the power of the pattern, not decrease the effectiveness of the data type.  An Either with optional projections, for example, is literally the partial projection functions (called in Haskell [sometimes] fromLeft and fromRight).<br>&gt; <br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt; <br>&gt;&gt; Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br>&gt;&gt; <br>&gt;&gt; There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br>&gt;&gt; <br>&gt;&gt; What will the advantage of Either be once enums get even more fully baked?<br>&gt;&gt; <br>&gt;&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Which is why I hope the proposal doesn&#39;t come off as &quot;let&#39;s play copycat&quot;.  That said, its success in languages that share either paradigms or common heritage with Swift cannot be discounted so easily.  Rust, for example, with no exceptions mechanism in place has used an Either to great effect.  F# with one in place offers the even more general Core.Choice that is often wrapped by framework authors and augmented with library-specific semantics as they see fit.  C++ (through boost) and D chose to implement this pattern without tags, and made the type variadic instead.  In all cases the result is the same: An increase in the power of each language, a new class of declarative programs being written, and richer libraries because of all these.<br></p><p>Currently, swift does not have the necessary language features to produce a variant, nor does it have the ability or the desire to factor this out with a structural typing scheme (see the last round of discussions).  So I see inclusion as the next most logical path.<br></p><p>If 3rd party packages are supposed to be first-class, then I have no problem dropping this.  But for now if I import two packages that both export this type I have no recourse other than to drop one or the other or risk linker errors or needless qualification that reduces readability and muddies intent.  A stronger module system or a stronger inclusion/exclusion mechanism invalidates one of our core motivations - to reduce duplicate implementations - but for now I don&#39;t see movement on that front.<br></p><p>~Robert Widmann<br></p><p>2016/01/26 10:59、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br></p><p>&gt;&gt; On Jan 25, 2016, at 11:20 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The proposal does not exist because it is &quot;hard or bad&quot; to define the type, but because it factors out a common pattern.  <br>&gt; <br>&gt; I know you intend that to be a positive statement, but design patterns are not always seen as a good thing.  See the criticism section of: https://en.m.wikipedia.org/wiki/Software_design_pattern for example.<br>&gt; <br>&gt; We have a good language feature (enums/ADTs) that makes the win of Either extremely small or a loss (when you factor in the loss of specificity for a problem domain).<br>&gt; <br>&gt; The bar for getting something into the stdlib is very high, and intentionally so.  Merely existing in some other language isn&#39;t enough, it needs to pull its weight given the context of Swift, and even there it needs to have strong justification.  Swift is intentionally designed so that third party packages can be on the same level as the standard library.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Adding language features on top of it should only serve to increase the power of the pattern, not decrease the effectiveness of the data type.  An Either with optional projections, for example, is literally the partial projection functions (called in Haskell [sometimes] fromLeft and fromRight).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What will the advantage of Either be once enums get even more fully baked?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt; type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br></p><p>-Kevin Ballard<br></p><p>On Tue, Jan 26, 2016, at 09:25 AM, Developer wrote:<br>&gt; Which is why I hope the proposal doesn&#39;t come off as &quot;let&#39;s play copycat&quot;.  That said, its success in languages that share either paradigms or common heritage with Swift cannot be discounted so easily.  Rust, for example, with no exceptions mechanism in place has used an Either to great effect.  F# with one in place offers the even more general Core.Choice that is often wrapped by framework authors and augmented with library-specific semantics as they see fit.  C++ (through boost) and D chose to implement this pattern without tags, and made the type variadic instead.  In all cases the result is the same: An increase in the power of each language, a new class of declarative programs being written, and richer libraries because of all these.<br>&gt; <br>&gt; Currently, swift does not have the necessary language features to produce a variant, nor does it have the ability or the desire to factor this out with a structural typing scheme (see the last round of discussions).  So I see inclusion as the next most logical path.<br>&gt; <br>&gt; If 3rd party packages are supposed to be first-class, then I have no problem dropping this.  But for now if I import two packages that both export this type I have no recourse other than to drop one or the other or risk linker errors or needless qualification that reduces readability and muddies intent.  A stronger module system or a stronger inclusion/exclusion mechanism invalidates one of our core motivations - to reduce duplicate implementations - but for now I don&#39;t see movement on that front.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/26 10:59、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt; <br>&gt; &gt;&gt; On Jan 25, 2016, at 11:20 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The proposal does not exist because it is &quot;hard or bad&quot; to define the type, but because it factors out a common pattern.  <br>&gt; &gt; <br>&gt; &gt; I know you intend that to be a positive statement, but design patterns are not always seen as a good thing.  See the criticism section of: https://en.m.wikipedia.org/wiki/Software_design_pattern for example.<br>&gt; &gt; <br>&gt; &gt; We have a good language feature (enums/ADTs) that makes the win of Either extremely small or a loss (when you factor in the loss of specificity for a problem domain).<br>&gt; &gt; <br>&gt; &gt; The bar for getting something into the stdlib is very high, and intentionally so.  Merely existing in some other language isn&#39;t enough, it needs to pull its weight given the context of Swift, and even there it needs to have strong justification.  Swift is intentionally designed so that third party packages can be on the same level as the standard library.<br>&gt; &gt; <br>&gt; &gt; -Chris<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt;&gt; Adding language features on top of it should only serve to increase the power of the pattern, not decrease the effectiveness of the data type.  An Either with optional projections, for example, is literally the partial projection functions (called in Haskell [sometimes] fromLeft and fromRight).<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; 2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; What will the advantage of Either be once enums get even more fully baked?<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Ah, so that’s what this has been.  When I say “Either” you immediately jump to “Haskell’s Either” when what I really mean is the structure forming the Either type.  Because I get the feeling you and Chris are coming from this from two different directions I’ve tried to be generic in my speech.  To me, both implementations are the same, one just happens to have a more immediately scintillating naming scheme.  By my count, this is the third time I’ve said this:<br></p><p>I am open to name changes, but we must preserve the genericity of the type.  <br></p><p>You haven’t yet convinced me of the latter half of that point.  Perhaps we should start again: How does Result, and the semantics is carries with it, maintain the genericity of the type over, say, something called Choice or XOR?  Down the road, when Swift decides to adopt a more generic approach or attempts to abstract over this kind of type, I’d like to say we were forward-thinking enough to have anticipated this rather than have to deal with un-Resultifying a datatype that should have been generic to start with.<br></p><p>&gt; On Jan 26, 2016, at 4:40 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt; type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Tue, Jan 26, 2016, at 09:25 AM, Developer wrote:<br>&gt;&gt; Which is why I hope the proposal doesn&#39;t come off as &quot;let&#39;s play copycat&quot;.  That said, its success in languages that share either paradigms or common heritage with Swift cannot be discounted so easily.  Rust, for example, with no exceptions mechanism in place has used an Either to great effect.  F# with one in place offers the even more general Core.Choice that is often wrapped by framework authors and augmented with library-specific semantics as they see fit.  C++ (through boost) and D chose to implement this pattern without tags, and made the type variadic instead.  In all cases the result is the same: An increase in the power of each language, a new class of declarative programs being written, and richer libraries because of all these.<br>&gt;&gt; <br>&gt;&gt; Currently, swift does not have the necessary language features to produce a variant, nor does it have the ability or the desire to factor this out with a structural typing scheme (see the last round of discussions).  So I see inclusion as the next most logical path.<br>&gt;&gt; <br>&gt;&gt; If 3rd party packages are supposed to be first-class, then I have no problem dropping this.  But for now if I import two packages that both export this type I have no recourse other than to drop one or the other or risk linker errors or needless qualification that reduces readability and muddies intent.  A stronger module system or a stronger inclusion/exclusion mechanism invalidates one of our core motivations - to reduce duplicate implementations - but for now I don&#39;t see movement on that front.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/26 10:59、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:20 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal does not exist because it is &quot;hard or bad&quot; to define the type, but because it factors out a common pattern.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know you intend that to be a positive statement, but design patterns are not always seen as a good thing.  See the criticism section of: https://en.m.wikipedia.org/wiki/Software_design_pattern for example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have a good language feature (enums/ADTs) that makes the win of Either extremely small or a loss (when you factor in the loss of specificity for a problem domain).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The bar for getting something into the stdlib is very high, and intentionally so.  Merely existing in some other language isn&#39;t enough, it needs to pull its weight given the context of Swift, and even there it needs to have strong justification.  Swift is intentionally designed so that third party packages can be on the same level as the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Adding language features on top of it should only serve to increase the power of the pattern, not decrease the effectiveness of the data type.  An Either with optional projections, for example, is literally the partial projection functions (called in Haskell [sometimes] fromLeft and fromRight).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What will the advantage of Either be once enums get even more fully baked?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>By my count, this is the third time I&#39;ve said this: I don&#39;t want genericity of type. The Result type is only useful because it carries the specific meaning of having one &quot;success&quot; variant and one &quot;failure&quot; variant. It may look structurally identical to a left-biased Either type, but the specific naming here is very important. By trying for genericity, you&#39;re losing the specific meaning of the Result type and thus defeating the entire point of having a Result type.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Jan 26, 2016, at 01:50 PM, Developer wrote:<br>&gt; Ah, so that’s what this has been.  When I say “Either” you immediately jump to “Haskell’s Either” when what I really mean is the structure forming the Either type.  Because I get the feeling you and Chris are coming from this from two different directions I’ve tried to be generic in my speech.  To me, both implementations are the same, one just happens to have a more immediately scintillating naming scheme.  By my count, this is the third time I’ve said this:<br>&gt; <br>&gt; I am open to name changes, but we must preserve the genericity of the type.  <br>&gt; <br>&gt; You haven’t yet convinced me of the latter half of that point.  Perhaps we should start again: How does Result, and the semantics is carries with it, maintain the genericity of the type over, say, something called Choice or XOR?  Down the road, when Swift decides to adopt a more generic approach or attempts to abstract over this kind of type, I’d like to say we were forward-thinking enough to have anticipated this rather than have to deal with un-Resultifying a datatype that should have been generic to start with.<br>&gt; <br>&gt; &gt; On Jan 26, 2016, at 4:40 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt; type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br>&gt; &gt; <br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; <br>&gt; &gt; On Tue, Jan 26, 2016, at 09:25 AM, Developer wrote:<br>&gt; &gt;&gt; Which is why I hope the proposal doesn&#39;t come off as &quot;let&#39;s play copycat&quot;.  That said, its success in languages that share either paradigms or common heritage with Swift cannot be discounted so easily.  Rust, for example, with no exceptions mechanism in place has used an Either to great effect.  F# with one in place offers the even more general Core.Choice that is often wrapped by framework authors and augmented with library-specific semantics as they see fit.  C++ (through boost) and D chose to implement this pattern without tags, and made the type variadic instead.  In all cases the result is the same: An increase in the power of each language, a new class of declarative programs being written, and richer libraries because of all these.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Currently, swift does not have the necessary language features to produce a variant, nor does it have the ability or the desire to factor this out with a structural typing scheme (see the last round of discussions).  So I see inclusion as the next most logical path.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; If 3rd party packages are supposed to be first-class, then I have no problem dropping this.  But for now if I import two packages that both export this type I have no recourse other than to drop one or the other or risk linker errors or needless qualification that reduces readability and muddies intent.  A stronger module system or a stronger inclusion/exclusion mechanism invalidates one of our core motivations - to reduce duplicate implementations - but for now I don&#39;t see movement on that front.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; 2016/01/26 10:59、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:20 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; The proposal does not exist because it is &quot;hard or bad&quot; to define the type, but because it factors out a common pattern.  <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I know you intend that to be a positive statement, but design patterns are not always seen as a good thing.  See the criticism section of: https://en.m.wikipedia.org/wiki/Software_design_pattern for example.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; We have a good language feature (enums/ADTs) that makes the win of Either extremely small or a loss (when you factor in the loss of specificity for a problem domain).<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; The bar for getting something into the stdlib is very high, and intentionally so.  Merely existing in some other language isn&#39;t enough, it needs to pull its weight given the context of Swift, and even there it needs to have strong justification.  Swift is intentionally designed so that third party packages can be on the same level as the standard library.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; -Chris<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Adding language features on top of it should only serve to increase the power of the pattern, not decrease the effectiveness of the data type.  An Either with optional projections, for example, is literally the partial projection functions (called in Haskell [sometimes] fromLeft and fromRight).<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; 2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; What will the advantage of Either be once enums get even more fully baked?<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Because nowhere in the proposal do we use the words “Result Type”.<br></p><p>&gt; This proposal details the addition of a left-biased sum type to the Swift Standard Library. Earlier attempts at adding this have been too specifically focused on error handling (duplicating functionality throws already provides), whereas this implementation will focus on data, organization, and type safety. We believe that adding the type to the standard library and simultaneously emphasizing its use cases -that is, when you need a type that represents exactly 2 disjoint possibilities- can dispel the confusion caused in other languages and quell the conflict with throws.<br></p><p>&gt; On Jan 26, 2016, at 4:55 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; By my count, this is the third time I&#39;ve said this: I don&#39;t want genericity of type. The Result type is only useful because it carries the specific meaning of having one &quot;success&quot; variant and one &quot;failure&quot; variant. It may look structurally identical to a left-biased Either type, but the specific naming here is very important. By trying for genericity, you&#39;re losing the specific meaning of the Result type and thus defeating the entire point of having a Result type.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Tue, Jan 26, 2016, at 01:50 PM, Developer wrote:<br>&gt;&gt; Ah, so that’s what this has been.  When I say “Either” you immediately jump to “Haskell’s Either” when what I really mean is the structure forming the Either type.  Because I get the feeling you and Chris are coming from this from two different directions I’ve tried to be generic in my speech.  To me, both implementations are the same, one just happens to have a more immediately scintillating naming scheme.  By my count, this is the third time I’ve said this:<br>&gt;&gt; <br>&gt;&gt; I am open to name changes, but we must preserve the genericity of the type.  <br>&gt;&gt; <br>&gt;&gt; You haven’t yet convinced me of the latter half of that point.  Perhaps we should start again: How does Result, and the semantics is carries with it, maintain the genericity of the type over, say, something called Choice or XOR?  Down the road, when Swift decides to adopt a more generic approach or attempts to abstract over this kind of type, I’d like to say we were forward-thinking enough to have anticipated this rather than have to deal with un-Resultifying a datatype that should have been generic to start with.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 4:40 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt; type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jan 26, 2016, at 09:25 AM, Developer wrote:<br>&gt;&gt;&gt;&gt; Which is why I hope the proposal doesn&#39;t come off as &quot;let&#39;s play copycat&quot;.  That said, its success in languages that share either paradigms or common heritage with Swift cannot be discounted so easily.  Rust, for example, with no exceptions mechanism in place has used an Either to great effect.  F# with one in place offers the even more general Core.Choice that is often wrapped by framework authors and augmented with library-specific semantics as they see fit.  C++ (through boost) and D chose to implement this pattern without tags, and made the type variadic instead.  In all cases the result is the same: An increase in the power of each language, a new class of declarative programs being written, and richer libraries because of all these.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, swift does not have the necessary language features to produce a variant, nor does it have the ability or the desire to factor this out with a structural typing scheme (see the last round of discussions).  So I see inclusion as the next most logical path.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If 3rd party packages are supposed to be first-class, then I have no problem dropping this.  But for now if I import two packages that both export this type I have no recourse other than to drop one or the other or risk linker errors or needless qualification that reduces readability and muddies intent.  A stronger module system or a stronger inclusion/exclusion mechanism invalidates one of our core motivations - to reduce duplicate implementations - but for now I don&#39;t see movement on that front.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/01/26 10:59、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:20 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The proposal does not exist because it is &quot;hard or bad&quot; to define the type, but because it factors out a common pattern.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know you intend that to be a positive statement, but design patterns are not always seen as a good thing.  See the criticism section of: https://en.m.wikipedia.org/wiki/Software_design_pattern for example.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have a good language feature (enums/ADTs) that makes the win of Either extremely small or a loss (when you factor in the loss of specificity for a problem domain).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The bar for getting something into the stdlib is very high, and intentionally so.  Merely existing in some other language isn&#39;t enough, it needs to pull its weight given the context of Swift, and even there it needs to have strong justification.  Swift is intentionally designed so that third party packages can be on the same level as the standard library.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Adding language features on top of it should only serve to increase the power of the pattern, not decrease the effectiveness of the data type.  An Either with optional projections, for example, is literally the partial projection functions (called in Haskell [sometimes] fromLeft and fromRight).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What will the advantage of Either be once enums get even more fully baked?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/6b81ef7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 26, 2016 at 02:00:00pm</p></header><div class="content"><p>Well yeah, that&#39;s why I objected to this proposal. You keep talking as<br>though you think I agree with you and are just quibbling on the name.<br>But that&#39;s not true at all. You very specifically want to have a type<br>that&#39;s more generic than a Result enum, and I very specifically want to<br>avoid having a type that&#39;s that generic in the stdlib. Hence my vocal<br>objections.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Jan 26, 2016, at 01:57 PM, Developer wrote:<br>&gt; Because nowhere in the proposal do we use the words “Result Type”.<br>&gt;<br>&gt;&gt; This proposal details the addition of a left-biased sum type to the<br>&gt;&gt; Swift Standard Library. Earlier attempts at adding this have been too<br>&gt;&gt; specifically focused on error handling (duplicating functionality<br>&gt;&gt; throws already provides), whereas this implementation will focus on<br>&gt;&gt; data, organization, and type safety. We believe that adding the type<br>&gt;&gt; to the standard library and simultaneously emphasizing its use cases<br>&gt;&gt; -that is, when you need a type that represents exactly 2 disjoint possibilities-<br>&gt;&gt; can dispel the confusion caused in other languages and quell the<br>&gt;&gt; conflict with throws.<br>&gt;<br>&gt;&gt; On Jan 26, 2016, at 4:55 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; By my count, this is the third time I&#39;ve said this: I don&#39;t want<br>&gt;&gt; genericity of type. The Result type is only useful because it<br>&gt;&gt; carries the specific meaning of having one &quot;success&quot; variant and<br>&gt;&gt; one &quot;failure&quot; variant. It may look structurally identical to a left-<br>&gt;&gt; biased Either type, but the specific naming here is very<br>&gt;&gt; important. By trying for genericity, you&#39;re losing the specific<br>&gt;&gt; meaning of the Result type and thus defeating the entire point of<br>&gt;&gt; having a Result type.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Tue, Jan 26, 2016, at 01:50 PM, Developer wrote:<br>&gt;&gt;&gt; Ah, so that’s what this has been.  When I say “Either” you<br>&gt;&gt;&gt; immediately jump to “Haskell’s Either” when what I really mean is<br>&gt;&gt;&gt; the structure forming the Either type.  Because I get the feeling<br>&gt;&gt;&gt; you and Chris are coming from this from two different directions<br>&gt;&gt;&gt; I’ve tried to be generic in my speech.  To me, both implementations<br>&gt;&gt;&gt; are the same, one just happens to have a more immediately<br>&gt;&gt;&gt; scintillating naming scheme.  By my count, this is the third time<br>&gt;&gt;&gt; I’ve said this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am open to name changes, but we must preserve the genericity of<br>&gt;&gt;&gt; the type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You haven’t yet convinced me of the latter half of that point.<br>&gt;&gt;&gt; Perhaps we should start again: How does Result, and the semantics is<br>&gt;&gt;&gt; carries with it, maintain the genericity of the type over, say,<br>&gt;&gt;&gt; something called Choice or XOR?  Down the road, when Swift decides<br>&gt;&gt;&gt; to adopt a more generic approach or attempts to abstract over this<br>&gt;&gt;&gt; kind of type, I’d like to say we were forward-thinking enough to<br>&gt;&gt;&gt; have anticipated this rather than have to deal with un-Resultifying<br>&gt;&gt;&gt; a datatype that should have been generic to start with.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 26, 2016, at 4:40 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust<br>&gt;&gt;&gt;&gt; does _not_ have an Either type. In fact, Rust&#39;s success is a great<br>&gt;&gt;&gt;&gt; example of how Either is unnecessary. What Rust does have is a<br>&gt;&gt;&gt;&gt; Result&lt;T,E&gt; type, and the lack of a more generically-named Either<br>&gt;&gt;&gt;&gt; type was an intentional decision (with pretty much the same<br>&gt;&gt;&gt;&gt; rationale that I&#39;ve been giving).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Jan 26, 2016, at 09:25 AM, Developer wrote:<br>&gt;&gt;&gt;&gt;&gt; Which is why I hope the proposal doesn&#39;t come off as &quot;let&#39;s play<br>&gt;&gt;&gt;&gt;&gt; copycat&quot;.  That said, its success in languages that share either<br>&gt;&gt;&gt;&gt;&gt; paradigms or common heritage with Swift cannot be discounted so<br>&gt;&gt;&gt;&gt;&gt; easily.  Rust, for example, with no exceptions mechanism in place<br>&gt;&gt;&gt;&gt;&gt; has used an Either to great effect.  F# with one in place offers<br>&gt;&gt;&gt;&gt;&gt; the even more general Core.Choice that is often wrapped by<br>&gt;&gt;&gt;&gt;&gt; framework authors and augmented with library-specific semantics as<br>&gt;&gt;&gt;&gt;&gt; they see fit.  C++ (through boost) and D chose to implement this<br>&gt;&gt;&gt;&gt;&gt; pattern without tags, and made the type variadic instead.  In all<br>&gt;&gt;&gt;&gt;&gt; cases the result is the same: An increase in the power of each<br>&gt;&gt;&gt;&gt;&gt; language, a new class of declarative programs being written, and<br>&gt;&gt;&gt;&gt;&gt; richer libraries because of all these.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Currently, swift does not have the necessary language features to<br>&gt;&gt;&gt;&gt;&gt; produce a variant, nor does it have the ability or the desire to<br>&gt;&gt;&gt;&gt;&gt; factor this out with a structural typing scheme (see the last<br>&gt;&gt;&gt;&gt;&gt; round of discussions).  So I see inclusion as the next most<br>&gt;&gt;&gt;&gt;&gt; logical path.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If 3rd party packages are supposed to be first-class, then I have<br>&gt;&gt;&gt;&gt;&gt; no problem dropping this.  But for now if I import two packages<br>&gt;&gt;&gt;&gt;&gt; that both export this type I have no recourse other than to drop<br>&gt;&gt;&gt;&gt;&gt; one or the other or risk linker errors or needless qualification<br>&gt;&gt;&gt;&gt;&gt; that reduces readability and muddies intent.  A stronger module<br>&gt;&gt;&gt;&gt;&gt; system or a stronger inclusion/exclusion mechanism invalidates one<br>&gt;&gt;&gt;&gt;&gt; of our core motivations - to reduce duplicate implementations -<br>&gt;&gt;&gt;&gt;&gt; but for now I don&#39;t see movement on that front.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 2016/01/26 10:59、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 11:20 PM, Developer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The proposal does not exist because it is &quot;hard or bad&quot; to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; define the type, but because it factors out a common pattern.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I know you intend that to be a positive statement, but design<br>&gt;&gt;&gt;&gt;&gt;&gt; patterns are not always seen as a good thing.  See the criticism<br>&gt;&gt;&gt;&gt;&gt;&gt; section of:<br>&gt;&gt;&gt;&gt;&gt;&gt; https://en.m.wikipedia.org/wiki/Software_design_pattern for<br>&gt;&gt;&gt;&gt;&gt;&gt; example.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; We have a good language feature (enums/ADTs) that makes the win<br>&gt;&gt;&gt;&gt;&gt;&gt; of Either extremely small or a loss (when you factor in the loss<br>&gt;&gt;&gt;&gt;&gt;&gt; of specificity for a problem domain).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The bar for getting something into the stdlib is very high, and<br>&gt;&gt;&gt;&gt;&gt;&gt; intentionally so.  Merely existing in some other language isn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; enough, it needs to pull its weight given the context of Swift,<br>&gt;&gt;&gt;&gt;&gt;&gt; and even there it needs to have strong justification.  Swift is<br>&gt;&gt;&gt;&gt;&gt;&gt; intentionally designed so that third party packages can be on the<br>&gt;&gt;&gt;&gt;&gt;&gt; same level as the standard library.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Adding language features on top of it should only serve to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; increase the power of the pattern, not decrease the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; effectiveness of the data type.  An Either with optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; projections, for example, is literally the partial projection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; functions (called in Haskell [sometimes] fromLeft and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fromRight).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction of the current proposal.  I will, however, accept<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; name changes.  Result, though, I believe is out of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; question.  It strongly implies a common but pointed set of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; semantics that discourage thinking of this type as data and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; more as an alternative to throws.  I do not wish to emphasize<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the error case, or the theoretical case, I wish to encourage<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the general case.  We must remember that despite Rust&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; success, they do not have to live alongside an exceptions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mechanism like Either does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here is my concern:  Swift enums should be good enough that we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; don’t need an Either type.  If defining your own custom enum is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; hard or bad, then we should fix that.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are a number of concepts floating around that would make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enums better in various ways.  One specific one would be to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; synthesize optional accessors that line up with enum cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What will the advantage of Either be once enums get even more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fully baked?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/3d97eb35/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 26, 2016 at 12:00:00pm</p></header><div class="content"><p>I can’t speak for everyone, but for myself:<br></p><p>I perceive a common Result/Either type as being desired for composability. If I have two libraries that define their own Result/Either/etc. types, my ability to compose functions across those libraries is impacted.<br></p><p>But for myself, this has’t been an impact yet. <br></p><p>I have a feeling that if Swift 4 adds concurrency as a goal, the language will need some sort of Result or Either then (just like it may add some sort of Promise/Future system). The language may also need to expand the current error system to support these. <br></p><p>Since my understanding is discussion about concurrency is off the table until after Swift 3, that impacts the ability to discuss the impact possible concurrency solutions to a Result/Either type, similarity to Promise types, and/or impacts the addition of any of these would have to the current error system. <br></p><p>Personally, I feel I was already shot down right at the beginning of evolution by proposing generator functions partially because they were *close* to concurrency, so I don’t plan to push anything else (even just forward-thinking) about concurrency unless requested :-)<br></p><p>-DW<br></p><p>&gt; On Jan 26, 2016, at 8:59 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jan 25, 2016, at 11:20 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The proposal does not exist because it is &quot;hard or bad&quot; to define the type, but because it factors out a common pattern.  <br>&gt; <br>&gt; I know you intend that to be a positive statement, but design patterns are not always seen as a good thing.  See the criticism section of: https://en.m.wikipedia.org/wiki/Software_design_pattern for example.<br>&gt; <br>&gt; We have a good language feature (enums/ADTs) that makes the win of Either extremely small or a loss (when you factor in the loss of specificity for a problem domain).<br>&gt; <br>&gt; The bar for getting something into the stdlib is very high, and intentionally so.  Merely existing in some other language isn&#39;t enough, it needs to pull its weight given the context of Swift, and even there it needs to have strong justification.  Swift is intentionally designed so that third party packages can be on the same level as the standard library.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Adding language features on top of it should only serve to increase the power of the pattern, not decrease the effectiveness of the data type.  An Either with optional projections, for example, is literally the partial projection functions (called in Haskell [sometimes] fromLeft and fromRight).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/26 2:02、Chris Lattner &lt;clattner at apple.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 25, 2016, at 10:27 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is my concern:  Swift enums should be good enough that we don’t need an Either type.  If defining your own custom enum is hard or bad, then we should fix that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a number of concepts floating around that would make enums better in various ways.  One specific one would be to synthesize optional accessors that line up with enum cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What will the advantage of Either be once enums get even more fully baked?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 26, 2016 at 07:00:00am</p></header><div class="content"><p>I’m generally with Kevin on this. I’d classify actual-usage of `Either` as one of these three:<br></p><p>- often: a rather poorly-named “Result” type (or a slight generalization thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s “X-or-why-not-X?&quot;)<br>- occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>- rarely: a use that’s not really either of the above<br></p><p>…which is why the early discussion veered into discussion of Result and structural unions.<br></p><p>Sticking to the topic at hand, I’ll actually pick on the `reduceEarly` function in the proposal (as currently-written), because to my eyes that&#39;s the only example that’s *perhaps* in that third category of interesting uses:<br></p><p>- on an infinite sequence it’s not a correct “early exit”; as-written, it’s a “never-exit” (defeating the purpose in situation you’d want it to actually, you know, exit early)<br>- even on a finite sequence, it’ll consume the entire sequence even on an “early-exit” (swift sequences are single-pass); this limits its usefulness as a building block for other constructs<br></p><p>These defects are, of course, easily fixable by manually writing-out the reduce logic; but, if you’re willing to write that out, the implementation cost will be about the same for a “direct&quot; solution and the solution using `Either`, and given that, it’s not clear that *users* wouldn’t generally wind up preferring something like this:<br></p><p>enum IterationDecision {<br>  Continue<br>  ExitEarly<br>}<br></p><p>func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt; (T,IterationDecision)) -&gt; T {<br>  var result: T = initial<br>  for element in self {<br>    let (update,decision) = combine(result,element)<br>    switch decision {<br>      case .Continue: result = update<br>      case .EarlyExit: return update<br>    }<br>  }<br>  return result<br>}<br></p><p>…where (as a user) the signature and the enumeration make its use essentially self-explanatory, versus, say, this:<br></p><p>func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt; Either&lt;T,T&gt;) -&gt; T {<br>  var result: T = initial<br>  for element in self {<br>    switch combine(result,element) {<br>      case let .Left(update): result = update<br>      case let .Right(update): return update<br>    }<br>  }<br>  return result<br>}<br></p><p>…where the user will likely have to check the documentation to see which of `.Left` and `.Right` means “early-exit” here (unless `Either`’s gone sufficiently-pervasive by then that such knowledge will be de rigueur).<br></p><p>If there are some great uses of `Either` that:<br></p><p>- (a) aren’t just Result/the “fat optional” <br>- (b) aren’t just a 2-way sum<br>- (c) support clean-and-*correct* implementations directly in terms of standard library functions (e.g., don’t force you to choose between &quot;not actually halting iteration” and “re-implementing `reduce` just to get it right” )<br></p><p>…then this proposal would be a lot stronger for including them.<br></p><p>&gt; On Jan 26, 2016, at 12:27 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Are you opposed to the name or the semantics?<br>&gt; <br>&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;  <br>&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/c2c693c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either` as one of these three:<br>&gt; <br>&gt; - often: a rather poorly-named “Result” type (or a slight generalization thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s “X-or-why-not-X?&quot;)<br></p><p>You&#39;ve described (T?, U?).  This is not a &quot;fat optional&quot;.  And if we must use the term, then it&#39;s better to think of the reverse: an Optional is a thin Either.  It is an Either that offers less information; a lobe of the type dedicated to () rather than an actual value.<br></p><p>&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br></p><p>Good thing Either&lt;Either&lt;...&gt;, Either&lt;...&gt;&gt; works.<br></p><p>&gt; - rarely: a use that’s not really either of the above<br></p><p>The ErrorT Monad Transformer?<br></p><p>&gt; If there are some great uses of `Either` that:<br>&gt; <br>&gt; - (a) aren’t just Result/the “fat optional” <br></p><p>The Validation type is just that.  I&#39;m going to draw one up and submit it to Swiftz.  I&#39;ll let you know when that happens.<br></p><p>&gt; - (b) aren’t just a 2-way sum<br></p><p>I don&#39;t understand? Are you literally asking for a non-sum-sum-type?<br></p><p>&gt; - (c) support clean-and-*correct* implementations directly in terms of standard library functions (e.g., don’t force you to choose between &quot;not actually halting iteration” and “re-implementing `reduce` just to get it right” )<br>&gt; <br></p><p>I can fix the example, but perhaps you&#39;ve mistaken its inclusion in the proposal for a call to actually include it in the STL.  It was just a romp through the capabilities of the type (see robrix&#39;s note about Continuation-Passing-isms).<br></p><p>&gt; …then this proposal would be a lot stronger for including them.<br></p><p>I agree somewhat.  See my notes above.<br></p><p>~Robert Widmann<br></p><p>2016/01/26 8:52、plx via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either` as one of these three:<br>&gt; <br>&gt; - often: a rather poorly-named “Result” type (or a slight generalization thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s “X-or-why-not-X?&quot;)<br>&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt; - rarely: a use that’s not really either of the above<br>&gt; <br>&gt; …which is why the early discussion veered into discussion of Result and structural unions.<br>&gt; <br>&gt; Sticking to the topic at hand, I’ll actually pick on the `reduceEarly` function in the proposal (as currently-written), because to my eyes that&#39;s the only example that’s *perhaps* in that third category of interesting uses:<br>&gt; <br>&gt; - on an infinite sequence it’s not a correct “early exit”; as-written, it’s a “never-exit” (defeating the purpose in situation you’d want it to actually, you know, exit early)<br>&gt; - even on a finite sequence, it’ll consume the entire sequence even on an “early-exit” (swift sequences are single-pass); this limits its usefulness as a building block for other constructs<br>&gt; <br>&gt; These defects are, of course, easily fixable by manually writing-out the reduce logic; but, if you’re willing to write that out, the implementation cost will be about the same for a “direct&quot; solution and the solution using `Either`, and given that, it’s not clear that *users* wouldn’t generally wind up preferring something like this:<br>&gt; <br>&gt; enum IterationDecision {<br>&gt;   Continue<br>&gt;   ExitEarly<br>&gt; }<br>&gt; <br>&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt; (T,IterationDecision)) -&gt; T {<br>&gt;   var result: T = initial<br>&gt;   for element in self {<br>&gt;     let (update,decision) = combine(result,element)<br>&gt;     switch decision {<br>&gt;       case .Continue: result = update<br>&gt;       case .EarlyExit: return update<br>&gt;     }<br>&gt;   }<br>&gt;   return result<br>&gt; }<br>&gt; <br>&gt; …where (as a user) the signature and the enumeration make its use essentially self-explanatory, versus, say, this:<br>&gt; <br>&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt; Either&lt;T,T&gt;) -&gt; T {<br>&gt;   var result: T = initial<br>&gt;   for element in self {<br>&gt;     switch combine(result,element) {<br>&gt;       case let .Left(update): result = update<br>&gt;       case let .Right(update): return update<br>&gt;     }<br>&gt;   }<br>&gt;   return result<br>&gt; }<br>&gt; <br>&gt; …where the user will likely have to check the documentation to see which of `.Left` and `.Right` means “early-exit” here (unless `Either`’s gone sufficiently-pervasive by then that such knowledge will be de rigueur).<br>&gt; <br>&gt; If there are some great uses of `Either` that:<br>&gt; <br>&gt; - (a) aren’t just Result/the “fat optional” <br>&gt; - (b) aren’t just a 2-way sum<br>&gt; - (c) support clean-and-*correct* implementations directly in terms of standard library functions (e.g., don’t force you to choose between &quot;not actually halting iteration” and “re-implementing `reduce` just to get it right” )<br>&gt; <br>&gt; …then this proposal would be a lot stronger for including them.<br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 12:27 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt; <br>&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/93889d39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Is there a way that we can capture the desired parts of this proposal in a<br>Protocol or Protocol-like structure? I&#39;m thinking of some way to specify<br>behavior that Enums possessing two cases which opt in can share. I<br>understand that much of it can be done with a protocol now, what stands in<br>the way of it being worthwhile?<br></p><p>On Tue, Jan 26, 2016 at 12:30 PM, Developer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either` as<br>&gt; one of these three:<br>&gt;<br>&gt; - often: a rather poorly-named “Result” type (or a slight generalization<br>&gt; thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s<br>&gt; “X-or-why-not-X?&quot;)<br>&gt;<br>&gt;<br>&gt; You&#39;ve described (T?, U?).  This is not a &quot;fat optional&quot;.  And if we must<br>&gt; use the term, then it&#39;s better to think of the reverse: an Optional is a<br>&gt; thin Either.  It is an Either that offers less information; a lobe of the<br>&gt; type dedicated to () rather than an actual value.<br>&gt;<br>&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c<br>&gt; its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;<br>&gt;<br>&gt; Good thing Either&lt;Either&lt;...&gt;, Either&lt;...&gt;&gt; works.<br>&gt;<br>&gt; - rarely: a use that’s not really either of the above<br>&gt;<br>&gt;<br>&gt; The ErrorT Monad Transformer?<br>&gt;<br>&gt; If there are some great uses of `Either` that:<br>&gt;<br>&gt; - (a) aren’t just Result/the “fat optional”<br>&gt;<br>&gt;<br>&gt; The Validation type is just that.  I&#39;m going to draw one up and submit it<br>&gt; to Swiftz.  I&#39;ll let you know when that happens.<br>&gt;<br>&gt; - (b) aren’t just a 2-way sum<br>&gt;<br>&gt;<br>&gt; I don&#39;t understand? Are you literally asking for a non-sum-sum-type?<br>&gt;<br>&gt; - (c) support clean-and-*correct* implementations directly in terms of<br>&gt; standard library functions (e.g., don’t force you to choose between &quot;not<br>&gt; actually halting iteration” and “re-implementing `reduce` just to get it<br>&gt; right” )<br>&gt;<br>&gt;<br>&gt; I can fix the example, but perhaps you&#39;ve mistaken its inclusion in the<br>&gt; proposal for a call to actually include it in the STL.  It was just a romp<br>&gt; through the capabilities of the type (see robrix&#39;s note about<br>&gt; Continuation-Passing-isms).<br>&gt;<br>&gt; …then this proposal would be a lot stronger for including them.<br>&gt;<br>&gt;<br>&gt; I agree somewhat.  See my notes above.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/26 8:52、plx via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; のメッセージ:<br>&gt;<br>&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either` as<br>&gt; one of these three:<br>&gt;<br>&gt; - often: a rather poorly-named “Result” type (or a slight generalization<br>&gt; thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s<br>&gt; “X-or-why-not-X?&quot;)<br>&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c<br>&gt; its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt; - rarely: a use that’s not really either of the above<br>&gt;<br>&gt; …which is why the early discussion veered into discussion of Result and<br>&gt; structural unions.<br>&gt;<br>&gt; Sticking to the topic at hand, I’ll actually pick on the `reduceEarly`<br>&gt; function in the proposal (as currently-written), because to my eyes that&#39;s<br>&gt; the only example that’s *perhaps* in that third category of interesting<br>&gt; uses:<br>&gt;<br>&gt; - on an infinite sequence it’s not a correct “early exit”; as-written,<br>&gt; it’s a “never-exit” (defeating the purpose in situation you’d want it to<br>&gt; actually, you know, exit early)<br>&gt; - even on a finite sequence, it’ll consume the entire sequence even on an<br>&gt; “early-exit” (swift sequences are single-pass); this limits its usefulness<br>&gt; as a building block for other constructs<br>&gt;<br>&gt; These defects are, of course, easily fixable by manually writing-out the<br>&gt; reduce logic; but, if you’re willing to write that out, the implementation<br>&gt; cost will be about the same for a “direct&quot; solution and the solution using<br>&gt; `Either`, and given that, it’s not clear that *users* wouldn’t generally<br>&gt; wind up preferring something like this:<br>&gt;<br>&gt; enum IterationDecision {<br>&gt;   Continue<br>&gt;   ExitEarly<br>&gt; }<br>&gt;<br>&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt;<br>&gt; (T,IterationDecision)) -&gt; T {<br>&gt;   var result: T = initial<br>&gt;   for element in self {<br>&gt;     let (update,decision) = combine(result,element)<br>&gt;     switch decision {<br>&gt;       case .Continue: result = update<br>&gt;       case .EarlyExit: return update<br>&gt;     }<br>&gt;   }<br>&gt;   return result<br>&gt; }<br>&gt;<br>&gt; …where (as a user) the signature and the enumeration make its use<br>&gt; essentially self-explanatory, versus, say, this:<br>&gt;<br>&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt;<br>&gt; Either&lt;T,T&gt;) -&gt; T {<br>&gt;   var result: T = initial<br>&gt;   for element in self {<br>&gt;     switch combine(result,element) {<br>&gt;       case let .Left(update): result = update<br>&gt;       case let .Right(update): return update<br>&gt;     }<br>&gt;   }<br>&gt;   return result<br>&gt; }<br>&gt;<br>&gt; …where the user will likely have to check the documentation to see which<br>&gt; of `.Left` and `.Right` means “early-exit” here (unless `Either`’s gone<br>&gt; sufficiently-pervasive by then that such knowledge will be de rigueur).<br>&gt;<br>&gt; If there are some great uses of `Either` that:<br>&gt;<br>&gt; - (a) aren’t just Result/the “fat optional”<br>&gt; - (b) aren’t just a 2-way sum<br>&gt; - (c) support clean-and-*correct* implementations directly in terms of<br>&gt; standard library functions (e.g., don’t force you to choose between &quot;not<br>&gt; actually halting iteration” and “re-implementing `reduce` just to get it<br>&gt; right” )<br>&gt;<br>&gt; …then this proposal would be a lot stronger for including them.<br>&gt;<br>&gt; On Jan 26, 2016, at 12:27 AM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Are you opposed to the name or the semantics?<br>&gt;<br>&gt; I will not accept a revision that reduces the level of abstraction of the<br>&gt; current proposal.  I will, however, accept name changes.  Result, though, I<br>&gt; believe is out of the question.  It strongly implies a common but pointed<br>&gt; set of semantics that discourage thinking of this type as data and more as<br>&gt; an alternative to throws.  I do not wish to emphasize the error case, or<br>&gt; the theoretical case, I wish to encourage the general case.  We must<br>&gt; remember that despite Rust&#39;s success, they do not have to live alongside an<br>&gt; exceptions mechanism like Either does.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;<br>&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning.<br>&gt; `Either&lt;T&gt;` has *no intuitive meaning whatsoever*. It says absolutely<br>&gt; *nothing* about what it means beyond the fact that there are two<br>&gt; potential values. As a result, it is a largely useless type whose sole<br>&gt; redeeming feature is it allows developers to avoid having to define their<br>&gt; own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually<br>&gt; *want* to define your own enum so you can attach meaning to the value.<br>&gt;<br>&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either<br>&gt; type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;<br>&gt; My overwhelming concern, after having a conversation with Chris, is that<br>&gt; implementing a Result&lt;T&gt; means we are strongly implying a particular<br>&gt; semantics and use case when we could generalize and abstract for no cost<br>&gt; but an extra generic parameter.  In F#, Core.Choice can be used to build a<br>&gt; Validation or Result monad, but the converse is impossible.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; のメッセージ:<br>&gt;<br>&gt; Just added a section of motivating examples to the Either proposal.  Ping<br>&gt; me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;<br>&gt;<br>&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;<br>&gt;<br>&gt;<br>&gt; Your motivating examples (including all the projects you linked except<br>&gt; &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to<br>&gt; represent success/failure. I&#39;m not sure there&#39;s a single example where the<br>&gt; names Left and Right actually make sense in the problem domain. I&#39;m not<br>&gt; 100% sure about func alternate in Madness/Alternation.swift. It definitely<br>&gt; uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses<br>&gt; them as something else. Which makes those names all the more maddening.<br>&gt;<br>&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines.<br>&gt; We use Scala&#39;s Try/Success/Failure in dozens of places. We use<br>&gt; Either/Left/Right once, in a thrown-together report-generating script,<br>&gt; which would probably have been written in awk or perl if it didn&#39;t need to<br>&gt; read binary log files. (The ability of IntelliJ to reliably find all uses<br>&gt; of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;<br>&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical<br>&gt; about generic Either/Left/Right.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/e392e183/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 12:00:00pm</p></header><div class="content"><p>I love the idea, and we tried it in Tyro, but the loss of structure is worrying.  Plus, there isn&#39;t a way to specify that a protocol should apply only to an enum like there is with a class, nor that there should be proper kind constraints on implementors.  e.g.<br></p><p>protocol EitherType {<br>  associatedtype L<br>  associatedtype R<br></p><p>  var left : L? { get }<br>  var right : R? { get }<br>}<br></p><p>This has a &quot;valid&quot; instance in every constructable type.<br></p><p>extension Int : EitherType {<br>  public L = String<br>  public R = NSGlyphGenerator<br></p><p>  // Omitted for brevity<br>}<br></p><p>You get the picture.<br></p><p>~Robert Widmann<br></p><p>2016/01/26 12:36、T.J. Usiyan &lt;griotspeak at gmail.com&gt; のメッセージ:<br></p><p>&gt; Is there a way that we can capture the desired parts of this proposal in a Protocol or Protocol-like structure? I&#39;m thinking of some way to specify behavior that Enums possessing two cases which opt in can share. I understand that much of it can be done with a protocol now, what stands in the way of it being worthwhile?<br>&gt; <br>&gt;&gt; On Tue, Jan 26, 2016 at 12:30 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either` as one of these three:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - often: a rather poorly-named “Result” type (or a slight generalization thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s “X-or-why-not-X?&quot;)<br>&gt;&gt; <br>&gt;&gt; You&#39;ve described (T?, U?).  This is not a &quot;fat optional&quot;.  And if we must use the term, then it&#39;s better to think of the reverse: an Optional is a thin Either.  It is an Either that offers less information; a lobe of the type dedicated to () rather than an actual value.<br>&gt;&gt; <br>&gt;&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;&gt; <br>&gt;&gt; Good thing Either&lt;Either&lt;...&gt;, Either&lt;...&gt;&gt; works.<br>&gt;&gt; <br>&gt;&gt;&gt; - rarely: a use that’s not really either of the above<br>&gt;&gt; <br>&gt;&gt; The ErrorT Monad Transformer?<br>&gt;&gt; <br>&gt;&gt;&gt; If there are some great uses of `Either` that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (a) aren’t just Result/the “fat optional” <br>&gt;&gt; <br>&gt;&gt; The Validation type is just that.  I&#39;m going to draw one up and submit it to Swiftz.  I&#39;ll let you know when that happens.<br>&gt;&gt; <br>&gt;&gt;&gt; - (b) aren’t just a 2-way sum<br>&gt;&gt; <br>&gt;&gt; I don&#39;t understand? Are you literally asking for a non-sum-sum-type?<br>&gt;&gt; <br>&gt;&gt;&gt; - (c) support clean-and-*correct* implementations directly in terms of standard library functions (e.g., don’t force you to choose between &quot;not actually halting iteration” and “re-implementing `reduce` just to get it right” )<br>&gt;&gt; <br>&gt;&gt; I can fix the example, but perhaps you&#39;ve mistaken its inclusion in the proposal for a call to actually include it in the STL.  It was just a romp through the capabilities of the type (see robrix&#39;s note about Continuation-Passing-isms).<br>&gt;&gt; <br>&gt;&gt;&gt; …then this proposal would be a lot stronger for including them.<br>&gt;&gt; <br>&gt;&gt; I agree somewhat.  See my notes above.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/26 8:52、plx via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either` as one of these three:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - often: a rather poorly-named “Result” type (or a slight generalization thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s “X-or-why-not-X?&quot;)<br>&gt;&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;&gt;&gt; - rarely: a use that’s not really either of the above<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …which is why the early discussion veered into discussion of Result and structural unions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sticking to the topic at hand, I’ll actually pick on the `reduceEarly` function in the proposal (as currently-written), because to my eyes that&#39;s the only example that’s *perhaps* in that third category of interesting uses:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - on an infinite sequence it’s not a correct “early exit”; as-written, it’s a “never-exit” (defeating the purpose in situation you’d want it to actually, you know, exit early)<br>&gt;&gt;&gt; - even on a finite sequence, it’ll consume the entire sequence even on an “early-exit” (swift sequences are single-pass); this limits its usefulness as a building block for other constructs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These defects are, of course, easily fixable by manually writing-out the reduce logic; but, if you’re willing to write that out, the implementation cost will be about the same for a “direct&quot; solution and the solution using `Either`, and given that, it’s not clear that *users* wouldn’t generally wind up preferring something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum IterationDecision {<br>&gt;&gt;&gt;   Continue<br>&gt;&gt;&gt;   ExitEarly<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt; (T,IterationDecision)) -&gt; T {<br>&gt;&gt;&gt;   var result: T = initial<br>&gt;&gt;&gt;   for element in self {<br>&gt;&gt;&gt;     let (update,decision) = combine(result,element)<br>&gt;&gt;&gt;     switch decision {<br>&gt;&gt;&gt;       case .Continue: result = update<br>&gt;&gt;&gt;       case .EarlyExit: return update<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   return result<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …where (as a user) the signature and the enumeration make its use essentially self-explanatory, versus, say, this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt; Either&lt;T,T&gt;) -&gt; T {<br>&gt;&gt;&gt;   var result: T = initial<br>&gt;&gt;&gt;   for element in self {<br>&gt;&gt;&gt;     switch combine(result,element) {<br>&gt;&gt;&gt;       case let .Left(update): result = update<br>&gt;&gt;&gt;       case let .Right(update): return update<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   return result<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …where the user will likely have to check the documentation to see which of `.Left` and `.Right` means “early-exit” here (unless `Either`’s gone sufficiently-pervasive by then that such knowledge will be de rigueur).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there are some great uses of `Either` that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (a) aren’t just Result/the “fat optional” <br>&gt;&gt;&gt; - (b) aren’t just a 2-way sum<br>&gt;&gt;&gt; - (c) support clean-and-*correct* implementations directly in terms of standard library functions (e.g., don’t force you to choose between &quot;not actually halting iteration” and “re-implementing `reduce` just to get it right” )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …then this proposal would be a lot stronger for including them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 26, 2016, at 12:27 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/3e55a13f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>So the first feature is the ability to limit it to enums.<br></p><p>Another feature that might make things better is the ability to nest types<br>in methods. This cuts in the opposite direction of Either in theory since<br>it becomes hyper specific. It think that it is similar to the suggestion<br>floating around for ad hoc sum types.<br></p><p>On Tue, Jan 26, 2016 at 12:48 PM, Developer &lt;devteam.codafi at gmail.com&gt;<br>wrote:<br></p><p>&gt; I love the idea, and we tried it in Tyro, but the loss of structure is<br>&gt; worrying.  Plus, there isn&#39;t a way to specify that a protocol should apply<br>&gt; only to an enum like there is with a class, nor that there should be proper<br>&gt; kind constraints on implementors.  e.g.<br>&gt;<br>&gt; protocol EitherType {<br>&gt;   associatedtype L<br>&gt;   associatedtype R<br>&gt;<br>&gt;   var left : L? { get }<br>&gt;   var right : R? { get }<br>&gt; }<br>&gt;<br>&gt; This has a &quot;valid&quot; instance in every constructable type.<br>&gt;<br>&gt; extension Int : EitherType {<br>&gt;   public L = String<br>&gt;   public R = NSGlyphGenerator<br>&gt;<br>&gt;   // Omitted for brevity<br>&gt; }<br>&gt;<br>&gt; You get the picture.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/26 12:36、T.J. Usiyan &lt;griotspeak at gmail.com&gt; のメッセージ:<br>&gt;<br>&gt; Is there a way that we can capture the desired parts of this proposal in a<br>&gt; Protocol or Protocol-like structure? I&#39;m thinking of some way to specify<br>&gt; behavior that Enums possessing two cases which opt in can share. I<br>&gt; understand that much of it can be done with a protocol now, what stands in<br>&gt; the way of it being worthwhile?<br>&gt;<br>&gt; On Tue, Jan 26, 2016 at 12:30 PM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either`<br>&gt;&gt; as one of these three:<br>&gt;&gt;<br>&gt;&gt; - often: a rather poorly-named “Result” type (or a slight generalization<br>&gt;&gt; thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s<br>&gt;&gt; “X-or-why-not-X?&quot;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You&#39;ve described (T?, U?).  This is not a &quot;fat optional&quot;.  And if we must<br>&gt;&gt; use the term, then it&#39;s better to think of the reverse: an Optional is a<br>&gt;&gt; thin Either.  It is an Either that offers less information; a lobe of the<br>&gt;&gt; type dedicated to () rather than an actual value.<br>&gt;&gt;<br>&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c<br>&gt;&gt; its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Good thing Either&lt;Either&lt;...&gt;, Either&lt;...&gt;&gt; works.<br>&gt;&gt;<br>&gt;&gt; - rarely: a use that’s not really either of the above<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The ErrorT Monad Transformer?<br>&gt;&gt;<br>&gt;&gt; If there are some great uses of `Either` that:<br>&gt;&gt;<br>&gt;&gt; - (a) aren’t just Result/the “fat optional”<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The Validation type is just that.  I&#39;m going to draw one up and submit it<br>&gt;&gt; to Swiftz.  I&#39;ll let you know when that happens.<br>&gt;&gt;<br>&gt;&gt; - (b) aren’t just a 2-way sum<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t understand? Are you literally asking for a non-sum-sum-type?<br>&gt;&gt;<br>&gt;&gt; - (c) support clean-and-*correct* implementations directly in terms of<br>&gt;&gt; standard library functions (e.g., don’t force you to choose between &quot;not<br>&gt;&gt; actually halting iteration” and “re-implementing `reduce` just to get it<br>&gt;&gt; right” )<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I can fix the example, but perhaps you&#39;ve mistaken its inclusion in the<br>&gt;&gt; proposal for a call to actually include it in the STL.  It was just a romp<br>&gt;&gt; through the capabilities of the type (see robrix&#39;s note about<br>&gt;&gt; Continuation-Passing-isms).<br>&gt;&gt;<br>&gt;&gt; …then this proposal would be a lot stronger for including them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree somewhat.  See my notes above.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/01/26 8:52、plx via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; のメッセージ:<br>&gt;&gt;<br>&gt;&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either`<br>&gt;&gt; as one of these three:<br>&gt;&gt;<br>&gt;&gt; - often: a rather poorly-named “Result” type (or a slight generalization<br>&gt;&gt; thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s<br>&gt;&gt; “X-or-why-not-X?&quot;)<br>&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c<br>&gt;&gt; its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;&gt; - rarely: a use that’s not really either of the above<br>&gt;&gt;<br>&gt;&gt; …which is why the early discussion veered into discussion of Result and<br>&gt;&gt; structural unions.<br>&gt;&gt;<br>&gt;&gt; Sticking to the topic at hand, I’ll actually pick on the `reduceEarly`<br>&gt;&gt; function in the proposal (as currently-written), because to my eyes that&#39;s<br>&gt;&gt; the only example that’s *perhaps* in that third category of interesting<br>&gt;&gt; uses:<br>&gt;&gt;<br>&gt;&gt; - on an infinite sequence it’s not a correct “early exit”; as-written,<br>&gt;&gt; it’s a “never-exit” (defeating the purpose in situation you’d want it to<br>&gt;&gt; actually, you know, exit early)<br>&gt;&gt; - even on a finite sequence, it’ll consume the entire sequence even on an<br>&gt;&gt; “early-exit” (swift sequences are single-pass); this limits its usefulness<br>&gt;&gt; as a building block for other constructs<br>&gt;&gt;<br>&gt;&gt; These defects are, of course, easily fixable by manually writing-out the<br>&gt;&gt; reduce logic; but, if you’re willing to write that out, the implementation<br>&gt;&gt; cost will be about the same for a “direct&quot; solution and the solution using<br>&gt;&gt; `Either`, and given that, it’s not clear that *users* wouldn’t generally<br>&gt;&gt; wind up preferring something like this:<br>&gt;&gt;<br>&gt;&gt; enum IterationDecision {<br>&gt;&gt;   Continue<br>&gt;&gt;   ExitEarly<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt;<br>&gt;&gt; (T,IterationDecision)) -&gt; T {<br>&gt;&gt;   var result: T = initial<br>&gt;&gt;   for element in self {<br>&gt;&gt;     let (update,decision) = combine(result,element)<br>&gt;&gt;     switch decision {<br>&gt;&gt;       case .Continue: result = update<br>&gt;&gt;       case .EarlyExit: return update<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   return result<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; …where (as a user) the signature and the enumeration make its use<br>&gt;&gt; essentially self-explanatory, versus, say, this:<br>&gt;&gt;<br>&gt;&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt;<br>&gt;&gt; Either&lt;T,T&gt;) -&gt; T {<br>&gt;&gt;   var result: T = initial<br>&gt;&gt;   for element in self {<br>&gt;&gt;     switch combine(result,element) {<br>&gt;&gt;       case let .Left(update): result = update<br>&gt;&gt;       case let .Right(update): return update<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   return result<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; …where the user will likely have to check the documentation to see which<br>&gt;&gt; of `.Left` and `.Right` means “early-exit” here (unless `Either`’s gone<br>&gt;&gt; sufficiently-pervasive by then that such knowledge will be de rigueur).<br>&gt;&gt;<br>&gt;&gt; If there are some great uses of `Either` that:<br>&gt;&gt;<br>&gt;&gt; - (a) aren’t just Result/the “fat optional”<br>&gt;&gt; - (b) aren’t just a 2-way sum<br>&gt;&gt; - (c) support clean-and-*correct* implementations directly in terms of<br>&gt;&gt; standard library functions (e.g., don’t force you to choose between &quot;not<br>&gt;&gt; actually halting iteration” and “re-implementing `reduce` just to get it<br>&gt;&gt; right” )<br>&gt;&gt;<br>&gt;&gt; …then this proposal would be a lot stronger for including them.<br>&gt;&gt;<br>&gt;&gt; On Jan 26, 2016, at 12:27 AM, Developer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;<br>&gt;&gt; I will not accept a revision that reduces the level of abstraction of the<br>&gt;&gt; current proposal.  I will, however, accept name changes.  Result, though, I<br>&gt;&gt; believe is out of the question.  It strongly implies a common but pointed<br>&gt;&gt; set of semantics that discourage thinking of this type as data and more as<br>&gt;&gt; an alternative to throws.  I do not wish to emphasize the error case, or<br>&gt;&gt; the theoretical case, I wish to encourage the general case.  We must<br>&gt;&gt; remember that despite Rust&#39;s success, they do not have to live alongside an<br>&gt;&gt; exceptions mechanism like Either does.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;<br>&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning.<br>&gt;&gt; `Either&lt;T&gt;` has *no intuitive meaning whatsoever*. It says absolutely<br>&gt;&gt; *nothing* about what it means beyond the fact that there are two<br>&gt;&gt; potential values. As a result, it is a largely useless type whose sole<br>&gt;&gt; redeeming feature is it allows developers to avoid having to define their<br>&gt;&gt; own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually<br>&gt;&gt; *want* to define your own enum so you can attach meaning to the value.<br>&gt;&gt;<br>&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either<br>&gt;&gt; type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that<br>&gt;&gt; implementing a Result&lt;T&gt; means we are strongly implying a particular<br>&gt;&gt; semantics and use case when we could generalize and abstract for no cost<br>&gt;&gt; but an extra generic parameter.  In F#, Core.Choice can be used to build a<br>&gt;&gt; Validation or Result monad, but the converse is impossible.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; のメッセージ:<br>&gt;&gt;<br>&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping<br>&gt;&gt; me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Your motivating examples (including all the projects you linked except<br>&gt;&gt; &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to<br>&gt;&gt; represent success/failure. I&#39;m not sure there&#39;s a single example where the<br>&gt;&gt; names Left and Right actually make sense in the problem domain. I&#39;m not<br>&gt;&gt; 100% sure about func alternate in Madness/Alternation.swift. It definitely<br>&gt;&gt; uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses<br>&gt;&gt; them as something else. Which makes those names all the more maddening.<br>&gt;&gt;<br>&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000<br>&gt;&gt; lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use<br>&gt;&gt; Either/Left/Right once, in a thrown-together report-generating script,<br>&gt;&gt; which would probably have been written in awk or perl if it didn&#39;t need to<br>&gt;&gt; read binary log files. (The ability of IntelliJ to reliably find all uses<br>&gt;&gt; of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;<br>&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very<br>&gt;&gt; skeptical about generic Either/Left/Right.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; *_______________________________________________*<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/2a17ac21/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>Thinking about it more, couldn&#39;t this syntax convey exactly what we want?<br></p><p>protocol EitherType {<br>  associatedtype L<br>  associated type R<br></p><p>  case left : L<br>  case right : R<br>}<br></p><p>On Tue, Jan 26, 2016 at 12:48 PM, Developer &lt;devteam.codafi at gmail.com&gt;<br>wrote:<br></p><p>&gt; I love the idea, and we tried it in Tyro, but the loss of structure is<br>&gt; worrying.  Plus, there isn&#39;t a way to specify that a protocol should apply<br>&gt; only to an enum like there is with a class, nor that there should be proper<br>&gt; kind constraints on implementors.  e.g.<br>&gt;<br>&gt; protocol EitherType {<br>&gt;   associatedtype L<br>&gt;   associatedtype R<br>&gt;<br>&gt;   var left : L? { get }<br>&gt;   var right : R? { get }<br>&gt; }<br>&gt;<br>&gt; This has a &quot;valid&quot; instance in every constructable type.<br>&gt;<br>&gt; extension Int : EitherType {<br>&gt;   public L = String<br>&gt;   public R = NSGlyphGenerator<br>&gt;<br>&gt;   // Omitted for brevity<br>&gt; }<br>&gt;<br>&gt; You get the picture.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/26 12:36、T.J. Usiyan &lt;griotspeak at gmail.com&gt; のメッセージ:<br>&gt;<br>&gt; Is there a way that we can capture the desired parts of this proposal in a<br>&gt; Protocol or Protocol-like structure? I&#39;m thinking of some way to specify<br>&gt; behavior that Enums possessing two cases which opt in can share. I<br>&gt; understand that much of it can be done with a protocol now, what stands in<br>&gt; the way of it being worthwhile?<br>&gt;<br>&gt; On Tue, Jan 26, 2016 at 12:30 PM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either`<br>&gt;&gt; as one of these three:<br>&gt;&gt;<br>&gt;&gt; - often: a rather poorly-named “Result” type (or a slight generalization<br>&gt;&gt; thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s<br>&gt;&gt; “X-or-why-not-X?&quot;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You&#39;ve described (T?, U?).  This is not a &quot;fat optional&quot;.  And if we must<br>&gt;&gt; use the term, then it&#39;s better to think of the reverse: an Optional is a<br>&gt;&gt; thin Either.  It is an Either that offers less information; a lobe of the<br>&gt;&gt; type dedicated to () rather than an actual value.<br>&gt;&gt;<br>&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c<br>&gt;&gt; its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Good thing Either&lt;Either&lt;...&gt;, Either&lt;...&gt;&gt; works.<br>&gt;&gt;<br>&gt;&gt; - rarely: a use that’s not really either of the above<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The ErrorT Monad Transformer?<br>&gt;&gt;<br>&gt;&gt; If there are some great uses of `Either` that:<br>&gt;&gt;<br>&gt;&gt; - (a) aren’t just Result/the “fat optional”<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The Validation type is just that.  I&#39;m going to draw one up and submit it<br>&gt;&gt; to Swiftz.  I&#39;ll let you know when that happens.<br>&gt;&gt;<br>&gt;&gt; - (b) aren’t just a 2-way sum<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t understand? Are you literally asking for a non-sum-sum-type?<br>&gt;&gt;<br>&gt;&gt; - (c) support clean-and-*correct* implementations directly in terms of<br>&gt;&gt; standard library functions (e.g., don’t force you to choose between &quot;not<br>&gt;&gt; actually halting iteration” and “re-implementing `reduce` just to get it<br>&gt;&gt; right” )<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I can fix the example, but perhaps you&#39;ve mistaken its inclusion in the<br>&gt;&gt; proposal for a call to actually include it in the STL.  It was just a romp<br>&gt;&gt; through the capabilities of the type (see robrix&#39;s note about<br>&gt;&gt; Continuation-Passing-isms).<br>&gt;&gt;<br>&gt;&gt; …then this proposal would be a lot stronger for including them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree somewhat.  See my notes above.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/01/26 8:52、plx via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; のメッセージ:<br>&gt;&gt;<br>&gt;&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either`<br>&gt;&gt; as one of these three:<br>&gt;&gt;<br>&gt;&gt; - often: a rather poorly-named “Result” type (or a slight generalization<br>&gt;&gt; thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s<br>&gt;&gt; “X-or-why-not-X?&quot;)<br>&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c<br>&gt;&gt; its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;&gt; - rarely: a use that’s not really either of the above<br>&gt;&gt;<br>&gt;&gt; …which is why the early discussion veered into discussion of Result and<br>&gt;&gt; structural unions.<br>&gt;&gt;<br>&gt;&gt; Sticking to the topic at hand, I’ll actually pick on the `reduceEarly`<br>&gt;&gt; function in the proposal (as currently-written), because to my eyes that&#39;s<br>&gt;&gt; the only example that’s *perhaps* in that third category of interesting<br>&gt;&gt; uses:<br>&gt;&gt;<br>&gt;&gt; - on an infinite sequence it’s not a correct “early exit”; as-written,<br>&gt;&gt; it’s a “never-exit” (defeating the purpose in situation you’d want it to<br>&gt;&gt; actually, you know, exit early)<br>&gt;&gt; - even on a finite sequence, it’ll consume the entire sequence even on an<br>&gt;&gt; “early-exit” (swift sequences are single-pass); this limits its usefulness<br>&gt;&gt; as a building block for other constructs<br>&gt;&gt;<br>&gt;&gt; These defects are, of course, easily fixable by manually writing-out the<br>&gt;&gt; reduce logic; but, if you’re willing to write that out, the implementation<br>&gt;&gt; cost will be about the same for a “direct&quot; solution and the solution using<br>&gt;&gt; `Either`, and given that, it’s not clear that *users* wouldn’t generally<br>&gt;&gt; wind up preferring something like this:<br>&gt;&gt;<br>&gt;&gt; enum IterationDecision {<br>&gt;&gt;   Continue<br>&gt;&gt;   ExitEarly<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt;<br>&gt;&gt; (T,IterationDecision)) -&gt; T {<br>&gt;&gt;   var result: T = initial<br>&gt;&gt;   for element in self {<br>&gt;&gt;     let (update,decision) = combine(result,element)<br>&gt;&gt;     switch decision {<br>&gt;&gt;       case .Continue: result = update<br>&gt;&gt;       case .EarlyExit: return update<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   return result<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; …where (as a user) the signature and the enumeration make its use<br>&gt;&gt; essentially self-explanatory, versus, say, this:<br>&gt;&gt;<br>&gt;&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt;<br>&gt;&gt; Either&lt;T,T&gt;) -&gt; T {<br>&gt;&gt;   var result: T = initial<br>&gt;&gt;   for element in self {<br>&gt;&gt;     switch combine(result,element) {<br>&gt;&gt;       case let .Left(update): result = update<br>&gt;&gt;       case let .Right(update): return update<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   return result<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; …where the user will likely have to check the documentation to see which<br>&gt;&gt; of `.Left` and `.Right` means “early-exit” here (unless `Either`’s gone<br>&gt;&gt; sufficiently-pervasive by then that such knowledge will be de rigueur).<br>&gt;&gt;<br>&gt;&gt; If there are some great uses of `Either` that:<br>&gt;&gt;<br>&gt;&gt; - (a) aren’t just Result/the “fat optional”<br>&gt;&gt; - (b) aren’t just a 2-way sum<br>&gt;&gt; - (c) support clean-and-*correct* implementations directly in terms of<br>&gt;&gt; standard library functions (e.g., don’t force you to choose between &quot;not<br>&gt;&gt; actually halting iteration” and “re-implementing `reduce` just to get it<br>&gt;&gt; right” )<br>&gt;&gt;<br>&gt;&gt; …then this proposal would be a lot stronger for including them.<br>&gt;&gt;<br>&gt;&gt; On Jan 26, 2016, at 12:27 AM, Developer via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;<br>&gt;&gt; I will not accept a revision that reduces the level of abstraction of the<br>&gt;&gt; current proposal.  I will, however, accept name changes.  Result, though, I<br>&gt;&gt; believe is out of the question.  It strongly implies a common but pointed<br>&gt;&gt; set of semantics that discourage thinking of this type as data and more as<br>&gt;&gt; an alternative to throws.  I do not wish to emphasize the error case, or<br>&gt;&gt; the theoretical case, I wish to encourage the general case.  We must<br>&gt;&gt; remember that despite Rust&#39;s success, they do not have to live alongside an<br>&gt;&gt; exceptions mechanism like Either does.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;<br>&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning.<br>&gt;&gt; `Either&lt;T&gt;` has *no intuitive meaning whatsoever*. It says absolutely<br>&gt;&gt; *nothing* about what it means beyond the fact that there are two<br>&gt;&gt; potential values. As a result, it is a largely useless type whose sole<br>&gt;&gt; redeeming feature is it allows developers to avoid having to define their<br>&gt;&gt; own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually<br>&gt;&gt; *want* to define your own enum so you can attach meaning to the value.<br>&gt;&gt;<br>&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either<br>&gt;&gt; type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that<br>&gt;&gt; implementing a Result&lt;T&gt; means we are strongly implying a particular<br>&gt;&gt; semantics and use case when we could generalize and abstract for no cost<br>&gt;&gt; but an extra generic parameter.  In F#, Core.Choice can be used to build a<br>&gt;&gt; Validation or Result monad, but the converse is impossible.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; のメッセージ:<br>&gt;&gt;<br>&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping<br>&gt;&gt; me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Your motivating examples (including all the projects you linked except<br>&gt;&gt; &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to<br>&gt;&gt; represent success/failure. I&#39;m not sure there&#39;s a single example where the<br>&gt;&gt; names Left and Right actually make sense in the problem domain. I&#39;m not<br>&gt;&gt; 100% sure about func alternate in Madness/Alternation.swift. It definitely<br>&gt;&gt; uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses<br>&gt;&gt; them as something else. Which makes those names all the more maddening.<br>&gt;&gt;<br>&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000<br>&gt;&gt; lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use<br>&gt;&gt; Either/Left/Right once, in a thrown-together report-generating script,<br>&gt;&gt; which would probably have been written in awk or perl if it didn&#39;t need to<br>&gt;&gt; read binary log files. (The ability of IntelliJ to reliably find all uses<br>&gt;&gt; of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;<br>&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very<br>&gt;&gt; skeptical about generic Either/Left/Right.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; *_______________________________________________*<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/3aadd402/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>January 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 9:30 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt; <br>&gt; Good thing Either&lt;Either&lt;...&gt;, Either&lt;...&gt;&gt; works.<br></p><p>This is another example of exactly why Either is terrible in practice. I understand that from a type algebra point of view this is perfectly reasonable and clean and that a 2-way sum is all that is necessary because larger sums are easily created by construction. Type theory-wise it’s lovely.<br></p><p>But from a literate programming point of view, when will &quot;case let .Left(.Left(a)): case let .Left(.Right(b)): case let .Right(.Left(c)): case let .Right(.Right(d)): “ ever be the most understandable way to express _anything_ in Swift? And why would we want to encourage such things?<br></p><p>	- Greg<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/c8fbc70c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>And as I&#39;ve said before, if you must generalize to higher amounts of cases, you must acknowledge the inclusion-exclusion principle (https://en.m.wikipedia.org/wiki/Inclusion–exclusion_principle) which produces a completely different type (often called These).  There is no amount of type system magic that is going to make this generalize like that, outside of a horrendous construction on a dependently typed language.  Nor is there a sufficient amount of type system magic to build the type that you wish for without an even more drastic change. <br></p><p>Besides, we&#39;re getting away from the fundamental use-cases of Either.  If you have a trinary or quaternary or etc. expression, you should be using throws.  Either is for a disjoint sum of possibilities, not recovering algebraic data types.  If you wish to go down that road, we need to discuss more pressing changes to the type system to support it.  For now, I won&#39;t make those demands.<br></p><p>~Robert Widmann<br></p><p>2016/01/26 12:40、Greg Titus via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 9:30 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;&gt; <br>&gt;&gt; Good thing Either&lt;Either&lt;...&gt;, Either&lt;...&gt;&gt; works.<br>&gt; <br>&gt; This is another example of exactly why Either is terrible in practice. I understand that from a type algebra point of view this is perfectly reasonable and clean and that a 2-way sum is all that is necessary because larger sums are easily created by construction. Type theory-wise it’s lovely.<br>&gt; <br>&gt; But from a literate programming point of view, when will &quot;case let .Left(.Left(a)): case let .Left(.Right(b)): case let .Right(.Left(c)): case let .Right(.Right(d)): “ ever be the most understandable way to express _anything_ in Swift? And why would we want to encourage such things?<br>&gt; <br>&gt; 	- Greg<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/96ae4746/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 10:03 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And as I&#39;ve said before, if you must generalize to higher amounts of cases, you must acknowledge the inclusion-exclusion principle (https://en.m.wikipedia.org/wiki/Inclusion–exclusion_principle &lt;https://en.m.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle&gt;) which produces a completely different type (often called These).  There is no amount of type system magic that is going to make this generalize like that, outside of a horrendous construction on a dependently typed language.  Nor is there a sufficient amount of type system magic to build the type that you wish for without an even more drastic change. <br>&gt; <br>&gt; Besides, we&#39;re getting away from the fundamental use-cases of Either.  If you have a trinary or quaternary or etc. expression, you should be using throws.  Either is for a disjoint sum of possibilities, not recovering algebraic data types.  If you wish to go down that road, we need to discuss more pressing changes to the type system to support it. <br></p><p>The type system already supports N-ary “either” types.  We call them enums.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/ffd7c320/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 26, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 11:30 AM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either` as one of these three:<br>&gt;&gt; <br>&gt;&gt; - often: a rather poorly-named “Result” type (or a slight generalization thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s “X-or-why-not-X?&quot;)<br>&gt; <br>&gt; You&#39;ve described (T?, U?).  This is not a &quot;fat optional&quot;.  And if we must use the term, then it&#39;s better to think of the reverse: an Optional is a thin Either.  It is an Either that offers less information; a lobe of the type dedicated to () rather than an actual value.<br></p><p>If I wrote “X-xor-why-no-X?” or even `(X|why-no-X)` the point would&#39;ve been clearer; it’s certainly not a new idea in this world.<br></p><p>The perspective that optional is a &quot;thin either&quot; is certainly also valid.<br></p><p>&gt; <br>&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt; <br>&gt; Good thing Either&lt;Either&lt;...&gt;, Either&lt;...&gt;&gt; works.<br></p><p>I’d say “works”, not works; the ergonomics are terrible, you are unlikely to be able to take advantage of the bias anymore, and even if we overlook all that, you still have to enforce an external convention to get mutual-interoperability at each n; otherwise, you may say Either&lt;Either&lt;,&gt;,Either&lt;,&gt;&gt; but I may say Either&lt;Either&lt;Either&lt;,&gt;,&gt;,&gt; and someone else may say Either&lt;,Either&lt;,Either&lt;,&gt;&gt;&gt; and someone else says Either&lt;,Either&lt;Either&lt;,&gt;,&gt;&gt; and so on…<br></p><p>Contrast with the homely-but-predictable Choice2/Sum2, Choice3/Sum3, etc., with homely but-predictable names First/Second, First/Second/Third, or A/B, A/B/C, (etc.). <br></p><p>&gt; <br>&gt;&gt; - rarely: a use that’s not really either of the above<br>&gt; <br>&gt; The ErrorT Monad Transformer?<br></p><p>I’d consider the concrete role played-by `Either` within that construct to fall well within the scope of “Result”.<br></p><p>&gt; <br>&gt;&gt; If there are some great uses of `Either` that:<br>&gt;&gt; <br>&gt;&gt; - (a) aren’t just Result/the “fat optional” <br>&gt; <br>&gt; The Validation type is just that.  I&#39;m going to draw one up and submit it to Swiftz.  I&#39;ll let you know when that happens.<br></p><p>Please do.<br></p><p>&gt; <br>&gt;&gt; - (b) aren’t just a 2-way sum<br>&gt; <br>&gt; I don&#39;t understand? Are you literally asking for a non-sum-sum-type?<br></p><p>I already said I think that although Either is usable as “just” a 2-way sum, it’s badly-named for that use.<br></p><p>I was trying to say that “attempts to sell either by demonstrating uses for “just” a 2-way sum are unlikely to change how I think here. EG: seeing this `static func imageFor(resource: Either&lt;String,NSURL&gt;) -&gt; UIImage?` doesn’t do anything for `Either`, for me.<br></p><p>&gt; <br>&gt;&gt; - (c) support clean-and-*correct* implementations directly in terms of standard library functions (e.g., don’t force you to choose between &quot;not actually halting iteration” and “re-implementing `reduce` just to get it right” )<br>&gt;&gt; <br>&gt; <br>&gt; I can fix the example, but perhaps you&#39;ve mistaken its inclusion in the proposal for a call to actually include it in the STL.  It was just a romp through the capabilities of the type (see robrix&#39;s note about Continuation-Passing-isms).<br></p><p>I may not have made the intended implication clear: if you could write it like it was there and have it work correctly, it’s actually a nice bit of example code (and perhaps worth the “easier to write, albeit slightly-obscure in use” tradeoff).<br></p><p>But as-written it’s not so good, and once the implementation is “fixed” it’s neither appreciably-cleaner than the purpose-built variant nor any easier for its users to use (until such time as `Either` usage has become sufficiently-pervasive the user can be assumed to infer the intended semantics from the declaration alone).<br></p><p>The unstated assumption is that many other “clever” uses — once made actually-correct — would fall into the same trap of paying a small user-comprehensibility tax without any corresponding gain in either correctness (by assumption) or implementation-difficulty (my suspicion).<br></p><p>&gt; <br>&gt;&gt; …then this proposal would be a lot stronger for including them.<br>&gt; <br>&gt; I agree somewhat.  See my notes above.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/26 8:52、plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; I’m generally with Kevin on this. I’d classify actual-usage of `Either` as one of these three:<br>&gt;&gt; <br>&gt;&gt; - often: a rather poorly-named “Result” type (or a slight generalization thereof into the “fat optional”, e.g. instead of “X-or-nothing”, it’s “X-or-why-not-X?&quot;)<br>&gt;&gt; - occasionally: a rather poorly-named, 2-way sum type (poorly-named b/c its convention won’t generalize to 3-way sums, or 4-ways sums, etc.)<br>&gt;&gt; - rarely: a use that’s not really either of the above<br>&gt;&gt; <br>&gt;&gt; …which is why the early discussion veered into discussion of Result and structural unions.<br>&gt;&gt; <br>&gt;&gt; Sticking to the topic at hand, I’ll actually pick on the `reduceEarly` function in the proposal (as currently-written), because to my eyes that&#39;s the only example that’s *perhaps* in that third category of interesting uses:<br>&gt;&gt; <br>&gt;&gt; - on an infinite sequence it’s not a correct “early exit”; as-written, it’s a “never-exit” (defeating the purpose in situation you’d want it to actually, you know, exit early)<br>&gt;&gt; - even on a finite sequence, it’ll consume the entire sequence even on an “early-exit” (swift sequences are single-pass); this limits its usefulness as a building block for other constructs<br>&gt;&gt; <br>&gt;&gt; These defects are, of course, easily fixable by manually writing-out the reduce logic; but, if you’re willing to write that out, the implementation cost will be about the same for a “direct&quot; solution and the solution using `Either`, and given that, it’s not clear that *users* wouldn’t generally wind up preferring something like this:<br>&gt;&gt; <br>&gt;&gt; enum IterationDecision {<br>&gt;&gt;   Continue<br>&gt;&gt;   ExitEarly<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt; (T,IterationDecision)) -&gt; T {<br>&gt;&gt;   var result: T = initial<br>&gt;&gt;   for element in self {<br>&gt;&gt;     let (update,decision) = combine(result,element)<br>&gt;&gt;     switch decision {<br>&gt;&gt;       case .Continue: result = update<br>&gt;&gt;       case .EarlyExit: return update<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   return result<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …where (as a user) the signature and the enumeration make its use essentially self-explanatory, versus, say, this:<br>&gt;&gt; <br>&gt;&gt; func reduceEarly&lt;T&gt;(initial: T, combine: (T,Generator.Element) -&gt; Either&lt;T,T&gt;) -&gt; T {<br>&gt;&gt;   var result: T = initial<br>&gt;&gt;   for element in self {<br>&gt;&gt;     switch combine(result,element) {<br>&gt;&gt;       case let .Left(update): result = update<br>&gt;&gt;       case let .Right(update): return update<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   return result<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …where the user will likely have to check the documentation to see which of `.Left` and `.Right` means “early-exit” here (unless `Either`’s gone sufficiently-pervasive by then that such knowledge will be de rigueur).<br>&gt;&gt; <br>&gt;&gt; If there are some great uses of `Either` that:<br>&gt;&gt; <br>&gt;&gt; - (a) aren’t just Result/the “fat optional” <br>&gt;&gt; - (b) aren’t just a 2-way sum<br>&gt;&gt; - (c) support clean-and-*correct* implementations directly in terms of standard library functions (e.g., don’t force you to choose between &quot;not actually halting iteration” and “re-implementing `reduce` just to get it right” )<br>&gt;&gt; <br>&gt;&gt; …then this proposal would be a lot stronger for including them.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 12:27 AM, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you opposed to the name or the semantics?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will not accept a revision that reduces the level of abstraction of the current proposal.  I will, however, accept name changes.  Result, though, I believe is out of the question.  It strongly implies a common but pointed set of semantics that discourage thinking of this type as data and more as an alternative to throws.  I do not wish to emphasize the error case, or the theoretical case, I wish to encourage the general case.  We must remember that despite Rust&#39;s success, they do not have to live alongside an exceptions mechanism like Either does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/01/26 0:55、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/8b361f42/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February  3, 2016 at 10:00:00am</p></header><div class="content"><p>+1 to Kevin Ballard&#39;s response below.<br></p><p><br>&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;  <br>&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;  <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;  <br>&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/6fb399cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  8, 2016 at 09:00:00pm</p></header><div class="content"><p>I ran into a scenario in old java code - where it parses things in (global to the whole system) where I would probably have used Either over Optional to store the date - if I were working in a functional language (and yes there are “ways” to handle it other than Either - but exceptions are rather heavy, maybe an enumeration type wrapping date - but even then…).<br></p><p>The date field has to hold a valid date.  The parser is parsing leniently as to not throw unnecessary errors - it was either lenient, pass back a null, or blow chunks while parsing).  <br></p><p>So the date passed in was “20092002” and they were expecting the “batch job” to give an invalid date error.  The parsing is global so this would be a special case - which means changing it to string and doing parsing elsewhere as a hack (rather than potentially affecting server wide change in all services).   Dealing with it leniently meant the date reaching the batch job was “20100802” (roll the overflow months).  <br></p><p>What would have been better - is not throwing an exception, and not having an optional since the date could be empty or it could be a valid date - but this is a third case.  <br></p><p>I would have probably just used an Either[String, Date],  Either[enum, Date] where enum is not necessarily an error - it could be a invalid( string) , and empty type, or a date type.  It would allow me to deal with special cases or not….  <br></p><p>Now I know with swift I could create my own “Date” wrapper as an enum with these, but it still fields weird to me.  <br></p><p>Not trying to convince anyone it should be in the standard library at this point, but it is the difference between validation and exceptions.  Exceptions throw up and force you to handle them — or potentially blow up later because it was not handled (i.e. ignored) while this is more the data can either be a date or string.<br></p><p><br></p><p><br>&gt; On 2016-02-03, at 22:58:59, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 to Kevin Ballard&#39;s response below.<br>&gt; <br>&gt; <br>&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;  <br>&gt;&gt; If it&#39;s not obvious, I&#39;m very strongly against having a generic Either type, but I do want a Result&lt;T&gt; or Result&lt;T,E&gt;.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; On Fri, Jan 22, 2016, at 10:22 PM, Developer via swift-evolution wrote:<br>&gt;&gt;&gt; My overwhelming concern, after having a conversation with Chris, is that implementing a Result&lt;T&gt; means we are strongly implying a particular semantics and use case when we could generalize and abstract for no cost but an extra generic parameter.  In F#, Core.Choice can be used to build a Validation or Result monad, but the converse is impossible.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; 2016/01/23 1:05、Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain. I&#39;m not 100% sure about func alternate in Madness/Alternation.swift. It definitely uses Left/Right to mean Failure/Result, but I couldn&#39;t tell if it also uses them as something else. Which makes those names all the more maddening.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I checked my company&#39;s largest Scala project, which is over 300,000 lines. We use Scala&#39;s Try/Success/Failure in dozens of places. We use Either/Left/Right once, in a thrown-together report-generating script, which would probably have been written in awk or perl if it didn&#39;t need to read binary log files. (The ability of IntelliJ to reliably find all uses of a class or method is not to be underestimated. Hint hint, team Xcode.)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I think a Result/Success/Failure type is warranted, but I&#39;m very skeptical about generic Either/Left/Right.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/ce1fc608/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  8, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; I would have probably just used an Either[String, Date],  Either[enum, Date] where enum is not necessarily an error - it could be a invalid( string) , and empty type, or a date type.  It would allow me to deal with special cases or not….  <br></p><p>Personally, rather than use Either&lt;String, NSDate&gt; with its generic .Left and .Right, I would think this would give you better code:<br></p><p>	enum ValidatedDate {<br>		static let dateFormatter = ...<br>		<br>		case Invalid (String)<br>		case Valid (NSDate)<br>		<br>		init(_ dateString: String) {<br>			if let date = ValidatedDate.dateFormatter.dateFromString(dateString) {<br>				self = .Valid (date)<br>			}<br>			else {<br>				self = .Invalid (dateString)<br>			}<br>		}<br>	}<br></p><p>Now there&#39;s no question whether Left is valid or invalid.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 27, 2016 at 12:00:00am</p></header><div class="content"><p>Hello all,<br></p><p>I’m going to try and round up a summary of arguments for and against this proposal and my response to them, because I think there is a clear sense in everybody’s mind what Either entails, but that sense differs widely depending on individual interactions with the parts of the proposal.  I take full responsibility for the rhetoric and the style of debate that has been going on for the past ~24 hours.  It was borderline unprofessional the way this was going and I want to apologize now to those involved for being so very unclear in my reasoning and my rhetoric as to stir up a senseless debate about points we essentially agreed on beforehand.  As such, I’ve made some revisions to the proposal, I request that you all please re-read it (at https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md) before we try again so we can refocus this debate on more productive avenues of discourse.<br></p><p>Throughout this reply I’ve made heavy use of quotes from other replies.  Those will appear in purple.  Quotes from the proposal will appear in blue.<br></p><p>The type “Either” that we describe in the proposal is a placeholder.  I feel that must be emphasized, because there have been arguments about the name.  We specifically mention this in the proposal:<br></p><p>&gt; The Swift Standard Library will be updated to include a left-biased sum type we have called Either - though other names may be appropriate depending on how the type is implemented.<br></p><p>What we are requesting is a finite-case, here precisely two-case, type that represents two disjoint possibilities.  As noted before, this type is often called Result by Swift framework authors and notably the programming language Rust which uses it in place of an exception handling mechanism.<br></p><p>&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain.<br></p><p>&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br></p><p><br>&gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt; type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br></p><p><br>We recognize that Result conveys a particular semantics that encourage this type to cross over into the error-handling domain.  As noted in the proposal, we don’t want to emphasize this case because a version of this proposal was already rejected for overlapping too heavily with throws.  If the community feels that the proposal deserves to be rewritten in a way that re-emphasizes this case and makes that point then I am up for it.  But, I request that this not be used as an argument to reduce the genericity of the type - which is to say I don’t wish to see a Result&lt;T&gt; or a Result&lt;T, E : ErrorType&gt; because they reduce the power of the original proposal.<br></p><p>When I use the term genericity, I am not arguing for the naming scheme of the Either we have, I’m arguing for the structure to be kept around as-is.  My biggest fear is that a Result with one lobe and an Error is going to be merged rather than the full proposal because this type and the discussion of it outside of here can become too absorbed in the error-handling case.  I do not wish to lose the structure of the type we have now, because that structure is precisely what a future Swift could generalize and abstract upon.  The name, however, is up for grabs.  We offer a list of alternatives at the end of the proposal, if you have any more to suggest please reply to me here and I’ll see about adding them.<br></p><p>At the same time, it has been brought up that Either conveys no immediate useful information.  At the time of writing this proposal, we do not believe that to be the case, but we recognize that by naming this Result we can reach a wider audience.  At the end of the day the proposal is about merging in a 2-case sum type.  We chose Either not because we wanted to see it merged, but precisely because it was so meaning-agnostic.  It’s our lorem-ipsum.  For those that think we’re trying to merge a Haskell-ism, I can say with complete confidence that no part of TypeLift intended that in the original proposal.  Whatever bad taste Haskell may have left in anybody’s mouth, the Either in our proposal is a placeholder for a name to be decided upon by the community.  I felt that this was clear from the line <br></p><p>&gt; though other names may be appropriate depending on how the type is implemented.<br></p><p>and<br></p><p>&gt; In addition, the name `Either` does not lend much to the imagination,<br>&gt; and the use of `Left` and `Right` have the potential to cause confusion to<br>&gt; novices expecting a `Result&lt;T&gt;`<br></p><p><br>in the original proposal, but I was wrong.  I have updated the draft accordingly.<br></p><p>Besides, even if the type in the proposal were to be merged right this very second, “meaningless&quot; names and all, a domain-specific Result type could easily be recovered from it.  The same is not true of a type that is immediately domain-specific like the reduced-generic forms of Result.  To translate that into the language of Result using Either as a template: If a Result&lt;T, E&gt; were not merged, then it could not be recovered from Result&lt;T&gt; in any meaningful manner.  However, a constrained Result&lt;T, E : ErrorType&gt; can be recovered from the fully generic type in the proposal.<br></p><p>&gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.  This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names.  Why should we add a type to the standard library that has very few remaining use cases, and leads to a code style that we don’t want?<br></p><p>This is in line with the goals of the proposal and I would certainly support this renaming if it serves the community’s best interest.  You all are, by now, aware of my qualms with the name, but I’m not one to dwell on these things when we’ve made it clear in the proposal that the type can go by many names.  It’s the structure of a sum that we’re after, and we’re willing to take it how it comes - but contingent on the shape of the type not differing from the proposal as written.  I request that if the name Result be brought up again, that it come with the specific number and kind of parameters involved so we can nail down the shape being discussed.<br></p><p>&gt; The argument is often made that we should have a generic “Either” type (though the name doesn’t matter, I’m talking about the semantics you’re describing) to complement tuples.  However, the Either type you are providing is not analogous to Swift tuples, because Swift tuples allow you to *name* the elements of the tuple, and is generic w.r.t. the number of elements.  Your Either type has neither of these features.<br></p><p><br>Contrary to the impression the other discussion has made, nowhere in the proposal do we wish to augment the type system.  If this is done correctly, the type in the proposal should be a ~40-line addition to the standard library, it should not wind up as a full-blown language change.  We are not advocating for an n-element sum type, nor are we arguing for a structural typing scheme that would put variadic sums in the language because we recognize that solution is untenable.  We are, however, advocating for the inclusion of a 2-case sum type we happen to call Either in writing.<br></p><p>&gt; The type system already supports N-ary “either” types.  We call them enums.<br>&gt; <br></p><p>&gt; This is another example of exactly why Either is terrible in practice. I understand that from a type algebra point of view this is perfectly reasonable and clean and that a 2-way sum is all that is necessary because larger sums are easily created by construction. Type theory-wise it’s lovely.<br></p><p><br>Because this is a non-goal of the type. The sum as presented in the proposal does not attempt to take the place of enums, nor does it make any bones about being a finite entity.  We are specifically emphasizing the two-element case.  Any other arguments that pertain to its inclusion as a feature of the type system should start at the last site of discussion and probably terminate in a separate proposal adding that kind of scheme to the Swift language itself.  We are arguing for a simple change to the standard library, nothing more.<br></p><p>&gt; As before, unlike `throws`, a disjoint union type can be applied in arbitrary<br>&gt; positions, used as a member, and easily checked for completeness<br>&gt; at compile time.  In addition, the lack of a standard union type has<br>&gt; led the Swift community to create [numerous](https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift) duplicate implementations of the<br>&gt; same mutually incompatible types over and over and over again.  In the<br>&gt; interest of promoting a type that there has received clear interest by the<br>&gt; community, the addition to the Standard Library is necessary.<br></p><p><br>The argument is not “let’s toss out all implementations of 2-case enums in favor of this sum” it’s “very often, when you’ve got a two-case enum with bias, you’ve got a sum described in the proposal”.  This pattern shows up in a sufficiently large number of cases that we feel that the standard library deserves to have the final say as to a community-guided implementation of this type because individual implementations seem to differ only in a few minor places like naming or generic positions.<br></p><p>&gt; I perceive a common Result/Either type as being desired for composability. If I have two libraries that define their own Result/Either/etc. types, my ability to compose functions across those libraries is impacted. <br></p><p><br>This is another motivating factor that lines up with a major tenant of the proposal.  We would not be suggesting this change to the standard library if we did not see this pattern show up in a number of large frameworks, applications, and everything in between.  We offer a section of motivating examples and links that should convince you of its commonality if that is still a sticking point.<br></p><p>&gt; I’d say “works”, not works; the ergonomics are terrible, you are unlikely to be able to take advantage of the bias anymore, and even if we overlook all that, you still have to enforce an external convention to get mutual-interoperability at each n; otherwise, you may say Either&lt;Either&lt;,&gt;,Either&lt;,&gt;&gt; but I may say Either&lt;Either&lt;Either&lt;,&gt;,&gt;,&gt; and someone else may say Either&lt;,Either&lt;,Either&lt;,&gt;&gt;&gt; and someone else says Either&lt;,Either&lt;Either&lt;,&gt;,&gt;&gt; and so on…<br></p><p><br>This point, while valid, is also an unfortunate feature of Optionals as well, which I have argued can be viewed as an Sum with one lobe “sealed” by Top, the empty tuple.  I have yet to see a use of a sum type that needs nesting like this, nor have I seen any type or type alias that attempts to use this to recover an n-ary Sum because it just doesn’t happen.  If you have a disjoint set of possibilities with order greater than two, as Chris noted, Swift already offers enums.  And if such a case has arisen, it needs to be refactored just as Optional&lt;Optional&lt;Optional&lt;...&gt;&gt;&gt; would be.<br></p><p>&gt;  * An either-like type should be named something meaningful for the context it is used<br></p><p>See above.<br></p><p>&gt;  * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br></p><p>See proposal.<br></p><p>&gt;  * Is defining or re-defining an either type hard?<br></p><p>See proposal.<br></p><p>&gt;  * Is it too niche to be in the standard library<br></p><p>We don’t believe so, see proposal.<br></p><p>&gt; No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br></p><p>The rationale given for bias has been updated in the latest draft.<br></p><p>tl;dr<br></p><p>&gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.  This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names. <br></p><p><br>&gt; On Jan 20, 2016, at 10:17 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hey all,<br>&gt; <br>&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt; <br>&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt;&gt; <br>&gt;&gt; Thanks all!<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/8240f81d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 27, 2016 at 12:00:00pm</p></header><div class="content"><p>The other minor point is that this type (TBD) may not in fact be a result of function (of which everything returned from a function is in fact a result) would be an erroneous name. <br></p><p>&gt; On 2016-01-27, at 12:09:07, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; I’m going to try and round up a summary of arguments for and against this proposal and my response to them, because I think there is a clear sense in everybody’s mind what Either entails, but that sense differs widely depending on individual interactions with the parts of the proposal.  I take full responsibility for the rhetoric and the style of debate that has been going on for the past ~24 hours.  It was borderline unprofessional the way this was going and I want to apologize now to those involved for being so very unclear in my reasoning and my rhetoric as to stir up a senseless debate about points we essentially agreed on beforehand.  As such, I’ve made some revisions to the proposal, I request that you all please re-read it (at https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md&gt;) before we try again so we can refocus this debate on more productive avenues of discourse.<br>&gt; <br>&gt; Throughout this reply I’ve made heavy use of quotes from other replies.  Those will appear in purple.  Quotes from the proposal will appear in blue.<br>&gt; <br>&gt; The type “Either” that we describe in the proposal is a placeholder.  I feel that must be emphasized, because there have been arguments about the name.  We specifically mention this in the proposal:<br>&gt; <br>&gt;&gt; The Swift Standard Library will be updated to include a left-biased sum type we have called Either - though other names may be appropriate depending on how the type is implemented.<br>&gt; <br>&gt; What we are requesting is a finite-case, here precisely two-case, type that represents two disjoint possibilities.  As noted before, this type is often called Result by Swift framework authors and notably the programming language Rust which uses it in place of an exception handling mechanism.<br>&gt; <br>&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain.<br>&gt; <br>&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt; <br>&gt; <br>&gt;&gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt; type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br>&gt; <br>&gt; <br>&gt; We recognize that Result conveys a particular semantics that encourage this type to cross over into the error-handling domain.  As noted in the proposal, we don’t want to emphasize this case because a version of this proposal was already rejected for overlapping too heavily with throws.  If the community feels that the proposal deserves to be rewritten in a way that re-emphasizes this case and makes that point then I am up for it.  But, I request that this not be used as an argument to reduce the genericity of the type - which is to say I don’t wish to see a Result&lt;T&gt; or a Result&lt;T, E : ErrorType&gt; because they reduce the power of the original proposal.<br>&gt; <br>&gt; When I use the term genericity, I am not arguing for the naming scheme of the Either we have, I’m arguing for the structure to be kept around as-is.  My biggest fear is that a Result with one lobe and an Error is going to be merged rather than the full proposal because this type and the discussion of it outside of here can become too absorbed in the error-handling case.  I do not wish to lose the structure of the type we have now, because that structure is precisely what a future Swift could generalize and abstract upon.  The name, however, is up for grabs.  We offer a list of alternatives at the end of the proposal, if you have any more to suggest please reply to me here and I’ll see about adding them.<br>&gt; <br>&gt; At the same time, it has been brought up that Either conveys no immediate useful information.  At the time of writing this proposal, we do not believe that to be the case, but we recognize that by naming this Result we can reach a wider audience.  At the end of the day the proposal is about merging in a 2-case sum type.  We chose Either not because we wanted to see it merged, but precisely because it was so meaning-agnostic.  It’s our lorem-ipsum.  For those that think we’re trying to merge a Haskell-ism, I can say with complete confidence that no part of TypeLift intended that in the original proposal.  Whatever bad taste Haskell may have left in anybody’s mouth, the Either in our proposal is a placeholder for a name to be decided upon by the community.  I felt that this was clear from the line <br>&gt; <br>&gt;&gt; though other names may be appropriate depending on how the type is implemented.<br>&gt; <br>&gt; and<br>&gt; <br>&gt;&gt; In addition, the name `Either` does not lend much to the imagination,<br>&gt;&gt; and the use of `Left` and `Right` have the potential to cause confusion to<br>&gt;&gt; novices expecting a `Result&lt;T&gt;`<br>&gt; <br>&gt; <br>&gt; in the original proposal, but I was wrong.  I have updated the draft accordingly.<br>&gt; <br>&gt; Besides, even if the type in the proposal were to be merged right this very second, “meaningless&quot; names and all, a domain-specific Result type could easily be recovered from it.  The same is not true of a type that is immediately domain-specific like the reduced-generic forms of Result.  To translate that into the language of Result using Either as a template: If a Result&lt;T, E&gt; were not merged, then it could not be recovered from Result&lt;T&gt; in any meaningful manner.  However, a constrained Result&lt;T, E : ErrorType&gt; can be recovered from the fully generic type in the proposal.<br>&gt; <br>&gt;&gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.  This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names.  Why should we add a type to the standard library that has very few remaining use cases, and leads to a code style that we don’t want?<br>&gt; <br>&gt; This is in line with the goals of the proposal and I would certainly support this renaming if it serves the community’s best interest.  You all are, by now, aware of my qualms with the name, but I’m not one to dwell on these things when we’ve made it clear in the proposal that the type can go by many names.  It’s the structure of a sum that we’re after, and we’re willing to take it how it comes - but contingent on the shape of the type not differing from the proposal as written.  I request that if the name Result be brought up again, that it come with the specific number and kind of parameters involved so we can nail down the shape being discussed.<br>&gt; <br>&gt;&gt; The argument is often made that we should have a generic “Either” type (though the name doesn’t matter, I’m talking about the semantics you’re describing) to complement tuples.  However, the Either type you are providing is not analogous to Swift tuples, because Swift tuples allow you to *name* the elements of the tuple, and is generic w.r.t. the number of elements.  Your Either type has neither of these features.<br>&gt; <br>&gt; <br>&gt; Contrary to the impression the other discussion has made, nowhere in the proposal do we wish to augment the type system.  If this is done correctly, the type in the proposal should be a ~40-line addition to the standard library, it should not wind up as a full-blown language change.  We are not advocating for an n-element sum type, nor are we arguing for a structural typing scheme that would put variadic sums in the language because we recognize that solution is untenable.  We are, however, advocating for the inclusion of a 2-case sum type we happen to call Either in writing.<br>&gt; <br>&gt;&gt; The type system already supports N-ary “either” types.  We call them enums.<br>&gt;&gt; <br>&gt; <br>&gt;&gt; This is another example of exactly why Either is terrible in practice. I understand that from a type algebra point of view this is perfectly reasonable and clean and that a 2-way sum is all that is necessary because larger sums are easily created by construction. Type theory-wise it’s lovely.<br>&gt; <br>&gt; <br>&gt; Because this is a non-goal of the type. The sum as presented in the proposal does not attempt to take the place of enums, nor does it make any bones about being a finite entity.  We are specifically emphasizing the two-element case.  Any other arguments that pertain to its inclusion as a feature of the type system should start at the last site of discussion and probably terminate in a separate proposal adding that kind of scheme to the Swift language itself.  We are arguing for a simple change to the standard library, nothing more.<br>&gt; <br>&gt;&gt; As before, unlike `throws`, a disjoint union type can be applied in arbitrary<br>&gt;&gt; positions, used as a member, and easily checked for completeness<br>&gt;&gt; at compile time.  In addition, the lack of a standard union type has<br>&gt;&gt; led the Swift community to create [numerous](https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift &lt;https://github.com/search?utf8=%E2%9C%93&amp;q=Either+language%3Aswift&gt;) duplicate implementations of the<br>&gt;&gt; same mutually incompatible types over and over and over again.  In the<br>&gt;&gt; interest of promoting a type that there has received clear interest by the<br>&gt;&gt; community, the addition to the Standard Library is necessary.<br>&gt; <br>&gt; <br>&gt; The argument is not “let’s toss out all implementations of 2-case enums in favor of this sum” it’s “very often, when you’ve got a two-case enum with bias, you’ve got a sum described in the proposal”.  This pattern shows up in a sufficiently large number of cases that we feel that the standard library deserves to have the final say as to a community-guided implementation of this type because individual implementations seem to differ only in a few minor places like naming or generic positions.<br>&gt; <br>&gt;&gt; I perceive a common Result/Either type as being desired for composability. If I have two libraries that define their own Result/Either/etc. types, my ability to compose functions across those libraries is impacted. <br>&gt; <br>&gt; <br>&gt; This is another motivating factor that lines up with a major tenant of the proposal.  We would not be suggesting this change to the standard library if we did not see this pattern show up in a number of large frameworks, applications, and everything in between.  We offer a section of motivating examples and links that should convince you of its commonality if that is still a sticking point.<br>&gt; <br>&gt;&gt; I’d say “works”, not works; the ergonomics are terrible, you are unlikely to be able to take advantage of the bias anymore, and even if we overlook all that, you still have to enforce an external convention to get mutual-interoperability at each n; otherwise, you may say Either&lt;Either&lt;,&gt;,Either&lt;,&gt;&gt; but I may say Either&lt;Either&lt;Either&lt;,&gt;,&gt;,&gt; and someone else may say Either&lt;,Either&lt;,Either&lt;,&gt;&gt;&gt; and someone else says Either&lt;,Either&lt;Either&lt;,&gt;,&gt;&gt; and so on…<br>&gt; <br>&gt; <br>&gt; This point, while valid, is also an unfortunate feature of Optionals as well, which I have argued can be viewed as an Sum with one lobe “sealed” by Top, the empty tuple.  I have yet to see a use of a sum type that needs nesting like this, nor have I seen any type or type alias that attempts to use this to recover an n-ary Sum because it just doesn’t happen.  If you have a disjoint set of possibilities with order greater than two, as Chris noted, Swift already offers enums.  And if such a case has arisen, it needs to be refactored just as Optional&lt;Optional&lt;Optional&lt;...&gt;&gt;&gt; would be.<br>&gt; <br>&gt;&gt;  * An either-like type should be named something meaningful for the context it is used<br>&gt; <br>&gt; See above.<br>&gt; <br>&gt;&gt;  * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br>&gt; <br>&gt; See proposal.<br>&gt; <br>&gt;&gt;  * Is defining or re-defining an either type hard?<br>&gt; <br>&gt; See proposal.<br>&gt; <br>&gt;&gt;  * Is it too niche to be in the standard library<br>&gt; <br>&gt; We don’t believe so, see proposal.<br>&gt; <br>&gt;&gt; No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br>&gt; <br>&gt; The rationale given for bias has been updated in the latest draft.<br>&gt; <br>&gt; tl;dr<br>&gt; <br>&gt;&gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.  This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names. <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 10:17 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all,<br>&gt;&gt; <br>&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt; <br>&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks all!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/2766ea1c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>January 26, 2016 at 09:00:00pm</p></header><div class="content"><p>FWIW, I think a preferable alternative to an Either or Result type is union types, which could work as a sort of on-the-fly enum. Silly example:<br></p><p>func getNameOrAge() -&gt;|String, Int| { // or maybe enum(String, Int)<br>if true {<br>return &quot;Butterscotch&quot;<br>} else {<br>return 25<br>}<br>}<br></p><p>switch getNameOrAge() {<br>case String(let name): print(&quot;Name: \(name)&quot;)<br>case Int(let age):print(&quot;Age: \(age)&quot;)<br>}<br></p><p>I&#39;ve run into a couple situations where I&#39;ve needed to return different types from some one-off function (outside of the result/error pattern), but didn&#39;t want to create another type for that hyper-specific use case, and I wished I had some way of inlining a one-off, either-or type. It&#39;s even temping to use a tuple with optional values to leverage its inlining behavior, but that produces extra unwanted code paths. Union types are a powerful and use-case-agnostic solution to that kind of problem.<br></p><p>Jarod<br></p><p><br>On Jan 26, 2016, 21:27 -0800, Craig Cruden via swift-evolution&lt;swift-evolution at swift.org&gt;, wrote:<br>&gt; The other minor point is that this type (TBD) may not in fact be a result of function (of which everything returned from a function is in fact a result) would be an erroneous name.<br>&gt;  <br>&gt; &gt; On 2016-01-27, at 12:09:07, Developer via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; Hello all,<br>&gt; &gt;  <br>&gt; &gt; I’m going to try and round up a summary of arguments for and against this proposal and my response to them, because I think there is a clear sense in everybody’s mind what Either entails, but that sense differs widely depending on individual interactions with the parts of the proposal.I take full responsibility for the rhetoric and the style of debate that has been going on for the past ~24 hours.It was borderline unprofessional the way this was going and I want to apologize now to those involved for being so very unclear in my reasoning and my rhetoric as to stir up a senseless debate about points we essentially agreed on beforehand.As such, I’ve made some revisions to the proposal, I request that you all please re-read it (athttps://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md) before we try again so we can refocus this debate on more productive avenues of discourse.<br>&gt; &gt;  <br>&gt; &gt; Throughout this reply I’ve made heavy use of quotes from other replies.Those will appear in purple.Quotes from the proposal will appear in blue.<br>&gt; &gt;  <br>&gt; &gt; The type “Either” that we describe in the proposal is a placeholder.I feel that must be emphasized, because there have been arguments about the name.We specifically mention this in the proposal:<br>&gt; &gt;  <br>&gt; &gt; &gt; The Swift Standard Library will be updated to include a left-biased sum type we have calledEither- though other names may be appropriate depending on how the type is implemented.<br>&gt; &gt;  <br>&gt; &gt; What we are requesting is a finite-case, here precisely two-case, type that represents two disjoint possibilities.As noted before, this type is often called Result by Swift framework authors and notably the programming language Rust which uses it in place of an exception handling mechanism.<br>&gt; &gt;  <br>&gt; &gt; &gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain.<br>&gt; &gt; &gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` hasno intuitive meaning whatsoever. It says absolutelynothingabout what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt;you actuallywantto define your own enum so you can attach meaning to the value.<br>&gt; &gt;  <br>&gt; &gt; &gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt;type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br>&gt; &gt;  <br>&gt; &gt; We recognize that Result conveys a particular semantics that encourage this type to cross over into the error-handling domain.As noted in the proposal, we don’t want to emphasize this case because a version of this proposal was already rejected for overlapping too heavily with throws.If the community feels that the proposal deserves to be rewritten in a way that re-emphasizes this case and makes that point then I am up for it.But, I request that this not be used as an argument to reduce the genericity of the type - which is to say I don’t wish to see a Result&lt;T&gt;or a Result&lt;T, E : ErrorType&gt;because they reduce the power of the original proposal.<br>&gt; &gt;  <br>&gt; &gt; When I use the term genericity, I am not arguing for the naming scheme of the Either we have, I’m arguing for the structure to be kept around as-is.My biggest fear is that a Result with one lobe and an Error is going to be merged rather than the full proposal because this type and the discussion of it outside of here can become too absorbed in the error-handling case.I do not wish to lose the structure of the type we have now, because that structure is precisely what a future Swift could generalize and abstract upon.The name, however, is up for grabs.We offer a list of alternatives at the end of the proposal, if you have any more to suggest please reply to me here and I’ll see about adding them.<br>&gt; &gt;  <br>&gt; &gt; At the same time, it has been brought up that Either conveys no immediate useful information.At the time of writing this proposal, we do not believe that to be the case, but we recognize that by naming this Result we can reach a wider audience.At the end of the day the proposal is about merging in a 2-case sum type.We chose Either not because we wanted to see it merged, but preciselybecause it was so meaning-agnostic.It’s our lorem-ipsum.For those that think we’re trying to merge a Haskell-ism, I can say with complete confidence that no part of TypeLift intended that in the original proposal.Whatever bad taste Haskell may have left in anybody’s mouth, the Either in our proposal is a placeholder for a name to be decided upon by the community.I felt that this was clear from the line<br>&gt; &gt;  <br>&gt; &gt; &gt; though other names may be appropriate depending on how the type is implemented.<br>&gt; &gt;  <br>&gt; &gt; and<br>&gt; &gt;  <br>&gt; &gt; &gt; In addition, the name `Either` does not lend much to the imagination,<br>&gt; &gt; &gt; and the use of `Left` and `Right` have the potential to cause confusion to<br>&gt; &gt; &gt; novices expecting a `Result&lt;T&gt;`<br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; in the original proposal, but I was wrong.I have updated the draft accordingly.<br>&gt; &gt;  <br>&gt; &gt; Besides, even if the type in the proposal were to be merged right this very second, “meaningless&quot; names and all, a domain-specific Result type could easily be recovered from it.The same is not true of a type that is immediately domain-specific like the reduced-generic forms of Result.To translate that into the language of Result using Either as a template: If a Result&lt;T, E&gt;were not merged, then it could not be recovered from Result&lt;T&gt;in any meaningful manner.However, a constrained Result&lt;T, E : ErrorType&gt;canbe recovered from the fully generic type in the proposal.<br>&gt; &gt;  <br>&gt; &gt; &gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names.Why should we add a type to the standard library that has very few remaining use cases, and leads to a code style that we don’t want?<br>&gt; &gt; This is in line with the goals of the proposal and I would certainly support this renaming if it serves the community’s best interest.You all are, by now, aware of my qualms with the name, but I’m not one to dwell on these things when we’ve made it clear in the proposal that the type can go by many names.It’s the structure of a sum that we’re after, and we’re willing to take it how it comes - but contingent on the shape of the type not differing from the proposal as written.I request that if the name Result be brought up again, that it come with the specific number and kind of parameters involved so we can nail down the shape being discussed.<br>&gt; &gt;  <br>&gt; &gt; &gt; The argument is often made that we should have a generic “Either” type (though the name doesn’t matter, I’m talking about the semantics you’re describing) to complement tuples.However, the Either type you are providing is not analogous to Swift tuples, because Swift tuples allow you to *name* the elements of the tuple, and is generic w.r.t. the number of elements.Your Either type has neither of these features.<br>&gt; &gt;  <br>&gt; &gt; Contrary to the impression the other discussion has made, nowhere in the proposal do we wish to augment the type system.If this is done correctly, the type in the proposal should be a ~40-line addition to the standard library, it should not wind up as a full-blown language change.We are not advocating for an n-element sum type, nor are we arguing for a structural typing scheme that would put variadic sums in the language because we recognize that solution is untenable.We are, however, advocating for the inclusion of a 2-case sum type we happen to call Either in writing.<br>&gt; &gt;  <br>&gt; &gt; &gt; The type system already supports N-ary “either” types.We call them enums.<br>&gt; &gt;  <br>&gt; &gt; &gt; This is another example of exactly why Either is terrible in practice. I understand that from a type algebra point of view this is perfectly reasonable and clean and that a 2-way sum is all that is necessary because larger sums are easily created by construction. Type theory-wise it’s lovely.<br>&gt; &gt;  <br>&gt; &gt; Because this is a non-goal of the type. The sum as presented in the proposal does not attempt to take the place of enums, nor does it make any bones about being a finite entity.We are specifically emphasizing the two-element case.Any other arguments that pertain to its inclusion as a feature of the type system should start at the last site of discussion and probably terminate in a separate proposal adding that kind of scheme to the Swift language itself.We are arguing for a simple change to the standard library, nothing more.<br>&gt; &gt;  <br>&gt; &gt; &gt; As before, unlike `throws`, a disjoint union type can be applied in arbitrary<br>&gt; &gt; &gt; positions, used as a member, and easily checked for completeness<br>&gt; &gt; &gt; at compile time.In addition, the lack of a standard union type has<br>&gt; &gt; &gt; led the Swift community to create [numerous](https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift(https://github.com/search?utf8=%E2%9C%93&amp;q=Either+language%3Aswift)) duplicate implementations of the<br>&gt; &gt; &gt; same mutually incompatible types over and over and over again.In the<br>&gt; &gt; &gt; interest of promoting a type that there has received clear interest by the<br>&gt; &gt; &gt; community, the addition to the Standard Library is necessary.<br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; The argument is not “let’s toss out all implementations of 2-case enums in favor of this sum” it’s “very often, when you’ve got a two-case enum with bias, you’ve got a sum described in the proposal”.This pattern shows up in a sufficiently large number of cases that we feel that the standard library deserves to have the final say as to a community-guided implementation of this type because individual implementations seem to differ only in a few minor places like naming or generic positions.<br>&gt; &gt;  <br>&gt; &gt; &gt; I perceive a common Result/Either type as being desired for composability. If I have two libraries that define their own Result/Either/etc. types, my ability to compose functions across those libraries is impacted.<br>&gt; &gt;  <br>&gt; &gt; This is another motivating factor that lines up with a major tenant of the proposal.We would not be suggesting this change to the standard library if we did not see this pattern show up in a number of large frameworks, applications, and everything in between.We offer a section of motivating examples and links that should convince you of its commonality if that is still a sticking point.<br>&gt; &gt;  <br>&gt; &gt; &gt; I’d say “works”, not works; the ergonomics are terrible, you are unlikely to be able to take advantage of the bias anymore, and even if we overlook all that, you still have to enforce an external convention to get mutual-interoperability at each n; otherwise, you may say Either&lt;Either&lt;,&gt;,Either&lt;,&gt;&gt;but I may say Either&lt;Either&lt;Either&lt;,&gt;,&gt;,&gt;and someone else may say Either&lt;,Either&lt;,Either&lt;,&gt;&gt;&gt;and someone else says Either&lt;,Either&lt;Either&lt;,&gt;,&gt;&gt;and so on…<br>&gt; &gt;  <br>&gt; &gt; This point, while valid, is also an unfortunate feature of Optionals as well, which I have argued can be viewed as an Sum with one lobe “sealed” by Top, the empty tuple.I have yet to see a use of a sum type that needs nesting like this, nor have I seen any type or type alias that attempts to use this to recover an n-ary Sum because it just doesn’t happen.If you have a disjoint set of possibilities with order greater than two, as Chris noted, Swift already offers enums.And if such a case has arisen, it needs to be refactored just as Optional&lt;Optional&lt;Optional&lt;...&gt;&gt;&gt;would be.<br>&gt; &gt;  <br>&gt; &gt; &gt; * An either-like type should be named something meaningful for the context it is used<br>&gt; &gt;  <br>&gt; &gt; See above.<br>&gt; &gt; &gt; * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br>&gt; &gt;  <br>&gt; &gt; See proposal.<br>&gt; &gt; &gt; * Is defining or re-defining an either type hard?<br>&gt; &gt;  <br>&gt; &gt; See proposal.<br>&gt; &gt;  <br>&gt; &gt; &gt; * Is it too niche to be in the standard library<br>&gt; &gt;  <br>&gt; &gt; We don’t believe so, see proposal.<br>&gt; &gt;  <br>&gt; &gt; &gt; No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br>&gt; &gt;  <br>&gt; &gt; The rationale given for bias has been updated in the latest draft.<br>&gt; &gt;  <br>&gt; &gt; tl;dr<br>&gt; &gt;  <br>&gt; &gt; &gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names.<br>&gt; &gt;  <br>&gt; &gt; &gt; On Jan 20, 2016, at 10:17 PM, Developer&lt;devteam.codafi at gmail.com(mailto:devteam.codafi at gmail.com)&gt;wrote:<br>&gt; &gt; &gt; Hey all,<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; Just added a section of motivating examples to the Either proposal.Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; ~Robert Widmann<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; 2016/01/09 14:19、Developer&lt;devteam.codafi at gmail.com(mailto:devteam.codafi at gmail.com)&gt;のメッセージ:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Thanks all!<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; ~Robert Widmann<br>&gt; &gt;  <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/0dc8ed81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 27, 2016 at 12:00:00am</p></header><div class="content"><p>Have you seen the last round of discussions (root https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html&gt;)?  I don’t want to continue discussing this specific thing here because it is outside the scope of the proposal as it stands.<br></p><p>&gt; On Jan 27, 2016, at 12:46 AM, Jarod Long via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; FWIW, I think a preferable alternative to an Either or Result type is union types, which could work as a sort of on-the-fly enum. Silly example:<br>&gt; <br>&gt; func getNameOrAge() -&gt; |String, Int| { // or maybe enum(String, Int)<br>&gt;     if true {<br>&gt;         return &quot;Butterscotch&quot;<br>&gt;     } else {<br>&gt;         return 25<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; switch getNameOrAge() {<br>&gt;     case String(let name): print(&quot;Name: \(name)&quot;)<br>&gt;     case Int(let age):     print(&quot;Age: \(age)&quot;)<br>&gt; }<br>&gt; <br>&gt; I&#39;ve run into a couple situations where I&#39;ve needed to return different types from some one-off function (outside of the result/error pattern), but didn&#39;t want to create another type for that hyper-specific use case, and I wished I had some way of inlining a one-off, either-or type. It&#39;s even temping to use a tuple with optional values to leverage its inlining behavior, but that produces extra unwanted code paths. Union types are a powerful and use-case-agnostic solution to that kind of problem.<br>&gt; <br>&gt; Jarod<br>&gt; <br>&gt; <br>&gt; On Jan 26, 2016, 21:27 -0800, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt;, wrote:<br>&gt;&gt; The other minor point is that this type (TBD) may not in fact be a result of function (of which everything returned from a function is in fact a result) would be an erroneous name. <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-27, at 12:09:07, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m going to try and round up a summary of arguments for and against this proposal and my response to them, because I think there is a clear sense in everybody’s mind what Either entails, but that sense differs widely depending on individual interactions with the parts of the proposal.  I take full responsibility for the rhetoric and the style of debate that has been going on for the past ~24 hours.  It was borderline unprofessional the way this was going and I want to apologize now to those involved for being so very unclear in my reasoning and my rhetoric as to stir up a senseless debate about points we essentially agreed on beforehand.  As such, I’ve made some revisions to the proposal, I request that you all please re-read it (at https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md&gt;) before we try again so we can refocus this debate on more productive avenues of discourse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Throughout this reply I’ve made heavy use of quotes from other replies.  Those will appear in purple.  Quotes from the proposal will appear in blue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The type “Either” that we describe in the proposal is a placeholder.  I feel that must be emphasized, because there have been arguments about the name.  We specifically mention this in the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The Swift Standard Library will be updated to include a left-biased sum type we have called Either - though other names may be appropriate depending on how the type is implemented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What we are requesting is a finite-case, here precisely two-case, type that represents two disjoint possibilities.  As noted before, this type is often called Result by Swift framework authors and notably the programming language Rust which uses it in place of an exception handling mechanism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt; type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We recognize that Result conveys a particular semantics that encourage this type to cross over into the error-handling domain.  As noted in the proposal, we don’t want to emphasize this case because a version of this proposal was already rejected for overlapping too heavily with throws.  If the community feels that the proposal deserves to be rewritten in a way that re-emphasizes this case and makes that point then I am up for it.  But, I request that this not be used as an argument to reduce the genericity of the type - which is to say I don’t wish to see a Result&lt;T&gt; or a Result&lt;T, E : ErrorType&gt; because they reduce the power of the original proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When I use the term genericity, I am not arguing for the naming scheme of the Either we have, I’m arguing for the structure to be kept around as-is.  My biggest fear is that a Result with one lobe and an Error is going to be merged rather than the full proposal because this type and the discussion of it outside of here can become too absorbed in the error-handling case.  I do not wish to lose the structure of the type we have now, because that structure is precisely what a future Swift could generalize and abstract upon.  The name, however, is up for grabs.  We offer a list of alternatives at the end of the proposal, if you have any more to suggest please reply to me here and I’ll see about adding them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At the same time, it has been brought up that Either conveys no immediate useful information.  At the time of writing this proposal, we do not believe that to be the case, but we recognize that by naming this Result we can reach a wider audience.  At the end of the day the proposal is about merging in a 2-case sum type.  We chose Either not because we wanted to see it merged, but precisely because it was so meaning-agnostic.  It’s our lorem-ipsum.  For those that think we’re trying to merge a Haskell-ism, I can say with complete confidence that no part of TypeLift intended that in the original proposal.  Whatever bad taste Haskell may have left in anybody’s mouth, the Either in our proposal is a placeholder for a name to be decided upon by the community.  I felt that this was clear from the line <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; though other names may be appropriate depending on how the type is implemented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition, the name `Either` does not lend much to the imagination,<br>&gt;&gt;&gt;&gt; and the use of `Left` and `Right` have the potential to cause confusion to<br>&gt;&gt;&gt;&gt; novices expecting a `Result&lt;T&gt;`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; in the original proposal, but I was wrong.  I have updated the draft accordingly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Besides, even if the type in the proposal were to be merged right this very second, “meaningless&quot; names and all, a domain-specific Result type could easily be recovered from it.  The same is not true of a type that is immediately domain-specific like the reduced-generic forms of Result.  To translate that into the language of Result using Either as a template: If a Result&lt;T, E&gt; were not merged, then it could not be recovered from Result&lt;T&gt; in any meaningful manner.  However, a constrained Result&lt;T, E : ErrorType&gt; can be recovered from the fully generic type in the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.  This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names.  Why should we add a type to the standard library that has very few remaining use cases, and leads to a code style that we don’t want?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is in line with the goals of the proposal and I would certainly support this renaming if it serves the community’s best interest.  You all are, by now, aware of my qualms with the name, but I’m not one to dwell on these things when we’ve made it clear in the proposal that the type can go by many names.  It’s the structure of a sum that we’re after, and we’re willing to take it how it comes - but contingent on the shape of the type not differing from the proposal as written.  I request that if the name Result be brought up again, that it come with the specific number and kind of parameters involved so we can nail down the shape being discussed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The argument is often made that we should have a generic “Either” type (though the name doesn’t matter, I’m talking about the semantics you’re describing) to complement tuples.  However, the Either type you are providing is not analogous to Swift tuples, because Swift tuples allow you to *name* the elements of the tuple, and is generic w.r.t. the number of elements.  Your Either type has neither of these features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Contrary to the impression the other discussion has made, nowhere in the proposal do we wish to augment the type system.  If this is done correctly, the type in the proposal should be a ~40-line addition to the standard library, it should not wind up as a full-blown language change.  We are not advocating for an n-element sum type, nor are we arguing for a structural typing scheme that would put variadic sums in the language because we recognize that solution is untenable.  We are, however, advocating for the inclusion of a 2-case sum type we happen to call Either in writing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The type system already supports N-ary “either” types.  We call them enums.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is another example of exactly why Either is terrible in practice. I understand that from a type algebra point of view this is perfectly reasonable and clean and that a 2-way sum is all that is necessary because larger sums are easily created by construction. Type theory-wise it’s lovely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because this is a non-goal of the type. The sum as presented in the proposal does not attempt to take the place of enums, nor does it make any bones about being a finite entity.  We are specifically emphasizing the two-element case.  Any other arguments that pertain to its inclusion as a feature of the type system should start at the last site of discussion and probably terminate in a separate proposal adding that kind of scheme to the Swift language itself.  We are arguing for a simple change to the standard library, nothing more.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As before, unlike `throws`, a disjoint union type can be applied in arbitrary<br>&gt;&gt;&gt;&gt; positions, used as a member, and easily checked for completeness<br>&gt;&gt;&gt;&gt; at compile time.  In addition, the lack of a standard union type has<br>&gt;&gt;&gt;&gt; led the Swift community to create [numerous](https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift &lt;https://github.com/search?utf8=%E2%9C%93&amp;q=Either+language%3Aswift&gt;) duplicate implementations of the<br>&gt;&gt;&gt;&gt; same mutually incompatible types over and over and over again.  In the<br>&gt;&gt;&gt;&gt; interest of promoting a type that there has received clear interest by the<br>&gt;&gt;&gt;&gt; community, the addition to the Standard Library is necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The argument is not “let’s toss out all implementations of 2-case enums in favor of this sum” it’s “very often, when you’ve got a two-case enum with bias, you’ve got a sum described in the proposal”.  This pattern shows up in a sufficiently large number of cases that we feel that the standard library deserves to have the final say as to a community-guided implementation of this type because individual implementations seem to differ only in a few minor places like naming or generic positions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I perceive a common Result/Either type as being desired for composability. If I have two libraries that define their own Result/Either/etc. types, my ability to compose functions across those libraries is impacted. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is another motivating factor that lines up with a major tenant of the proposal.  We would not be suggesting this change to the standard library if we did not see this pattern show up in a number of large frameworks, applications, and everything in between.  We offer a section of motivating examples and links that should convince you of its commonality if that is still a sticking point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d say “works”, not works; the ergonomics are terrible, you are unlikely to be able to take advantage of the bias anymore, and even if we overlook all that, you still have to enforce an external convention to get mutual-interoperability at each n; otherwise, you may say Either&lt;Either&lt;,&gt;,Either&lt;,&gt;&gt; but I may say Either&lt;Either&lt;Either&lt;,&gt;,&gt;,&gt; and someone else may say Either&lt;,Either&lt;,Either&lt;,&gt;&gt;&gt; and someone else says Either&lt;,Either&lt;Either&lt;,&gt;,&gt;&gt; and so on…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This point, while valid, is also an unfortunate feature of Optionals as well, which I have argued can be viewed as an Sum with one lobe “sealed” by Top, the empty tuple.  I have yet to see a use of a sum type that needs nesting like this, nor have I seen any type or type alias that attempts to use this to recover an n-ary Sum because it just doesn’t happen.  If you have a disjoint set of possibilities with order greater than two, as Chris noted, Swift already offers enums.  And if such a case has arisen, it needs to be refactored just as Optional&lt;Optional&lt;Optional&lt;...&gt;&gt;&gt; would be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  * An either-like type should be named something meaningful for the context it is used<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  * Is defining or re-defining an either type hard?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  * Is it too niche to be in the standard library<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don’t believe so, see proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rationale given for bias has been updated in the latest draft.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; tl;dr<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.  This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 20, 2016, at 10:17 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hey all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481 &lt;https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481&gt;) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html&gt;).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks all!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/581a9625/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>January 26, 2016 at 09:00:00pm</p></header><div class="content"><p>I hadn&#39;t, thanks for pointing me in the right direction.<br></p><p>Jarod<br></p><p><br>On Jan 26, 2016, 21:48 -0800, Developer&lt;devteam.codafi at gmail.com&gt;, wrote:<br>&gt; Have you seen the last round of discussions (roothttps://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html)?I don’t want to continue discussing this specific thing here because it is outside the scope of the proposal as it stands.<br>&gt;  <br>&gt; &gt; On Jan 27, 2016, at 12:46 AM, Jarod Long via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; FWIW, I think a preferable alternative to an Either or Result type is union types, which could work as a sort of on-the-fly enum. Silly example:<br>&gt; &gt;  <br>&gt; &gt; func getNameOrAge() -&gt;|String, Int| { // or maybe enum(String, Int)<br>&gt; &gt; if true {<br>&gt; &gt; return &quot;Butterscotch&quot;<br>&gt; &gt; } else {<br>&gt; &gt; return 25<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;  <br>&gt; &gt; switch getNameOrAge() {<br>&gt; &gt; case String(let name): print(&quot;Name: \(name)&quot;)<br>&gt; &gt; case Int(let age):print(&quot;Age: \(age)&quot;)<br>&gt; &gt; }<br>&gt; &gt;  <br>&gt; &gt; I&#39;ve run into a couple situations where I&#39;ve needed to return different types from some one-off function (outside of the result/error pattern), but didn&#39;t want to create another type for that hyper-specific use case, and I wished I had some way of inlining a one-off, either-or type. It&#39;s even temping to use a tuple with optional values to leverage its inlining behavior, but that produces extra unwanted code paths. Union types are a powerful and use-case-agnostic solution to that kind of problem.<br>&gt; &gt;  <br>&gt; &gt; Jarod<br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; On Jan 26, 2016, 21:27 -0800, Craig Cruden via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;, wrote:<br>&gt; &gt; &gt; The other minor point is that this type (TBD) may not in fact be a result of function (of which everything returned from a function is in fact a result) would be an erroneous name.<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; On 2016-01-27, at 12:09:07, Developer via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; Hello all,<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; I’m going to try and round up a summary of arguments for and against this proposal and my response to them, because I think there is a clear sense in everybody’s mind what Either entails, but that sense differs widely depending on individual interactions with the parts of the proposal.I take full responsibility for the rhetoric and the style of debate that has been going on for the past ~24 hours.It was borderline unprofessional the way this was going and I want to apologize now to those involved for being so very unclear in my reasoning and my rhetoric as to stir up a senseless debate about points we essentially agreed on beforehand.As such, I’ve made some revisions to the proposal, I request that you all please re-read it (athttps://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md) before we try again so we can refocus this debate on more productive avenues of discourse.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Throughout this reply I’ve made heavy use of quotes from other replies.Those will appear in purple.Quotes from the proposal will appear in blue.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; The type “Either” that we describe in the proposal is a placeholder.I feel that must be emphasized, because there have been arguments about the name.We specifically mention this in the proposal:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; The Swift Standard Library will be updated to include a left-biased sum type we have calledEither- though other names may be appropriate depending on how the type is implemented.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; What we are requesting is a finite-case, here precisely two-case, type that represents two disjoint possibilities.As noted before, this type is often called Result by Swift framework authors and notably the programming language Rust which uses it in place of an exception handling mechanism.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain.<br>&gt; &gt; &gt; &gt; &gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` hasno intuitive meaning whatsoever. It says absolutelynothingabout what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt;you actuallywantto define your own enum so you can attach meaning to the value.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt;type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; We recognize that Result conveys a particular semantics that encourage this type to cross over into the error-handling domain.As noted in the proposal, we don’t want to emphasize this case because a version of this proposal was already rejected for overlapping too heavily with throws.If the community feels that the proposal deserves to be rewritten in a way that re-emphasizes this case and makes that point then I am up for it.But, I request that this not be used as an argument to reduce the genericity of the type - which is to say I don’t wish to see a Result&lt;T&gt;or a Result&lt;T, E : ErrorType&gt;because they reduce the power of the original proposal.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; When I use the term genericity, I am not arguing for the naming scheme of the Either we have, I’m arguing for the structure to be kept around as-is.My biggest fear is that a Result with one lobe and an Error is going to be merged rather than the full proposal because this type and the discussion of it outside of here can become too absorbed in the error-handling case.I do not wish to lose the structure of the type we have now, because that structure is precisely what a future Swift could generalize and abstract upon.The name, however, is up for grabs.We offer a list of alternatives at the end of the proposal, if you have any more to suggest please reply to me here and I’ll see about adding them.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; At the same time, it has been brought up that Either conveys no immediate useful information.At the time of writing this proposal, we do not believe that to be the case, but we recognize that by naming this Result we can reach a wider audience.At the end of the day the proposal is about merging in a 2-case sum type.We chose Either not because we wanted to see it merged, but preciselybecause it was so meaning-agnostic.It’s our lorem-ipsum.For those that think we’re trying to merge a Haskell-ism, I can say with complete confidence that no part of TypeLift intended that in the original proposal.Whatever bad taste Haskell may have left in anybody’s mouth, the Either in our proposal is a placeholder for a name to be decided upon by the community.I felt that this was clear from the line<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; though other names may be appropriate depending on how the type is implemented.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; and<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; In addition, the name `Either` does not lend much to the imagination,<br>&gt; &gt; &gt; &gt; &gt; and the use of `Left` and `Right` have the potential to cause confusion to<br>&gt; &gt; &gt; &gt; &gt; novices expecting a `Result&lt;T&gt;`<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; in the original proposal, but I was wrong.I have updated the draft accordingly.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Besides, even if the type in the proposal were to be merged right this very second, “meaningless&quot; names and all, a domain-specific Result type could easily be recovered from it.The same is not true of a type that is immediately domain-specific like the reduced-generic forms of Result.To translate that into the language of Result using Either as a template: If a Result&lt;T, E&gt;were not merged, then it could not be recovered from Result&lt;T&gt;in any meaningful manner.However, a constrained Result&lt;T, E : ErrorType&gt;canbe recovered from the fully generic type in the proposal.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names.Why should we add a type to the standard library that has very few remaining use cases, and leads to a code style that we don’t want?<br>&gt; &gt; &gt; &gt; This is in line with the goals of the proposal and I would certainly support this renaming if it serves the community’s best interest.You all are, by now, aware of my qualms with the name, but I’m not one to dwell on these things when we’ve made it clear in the proposal that the type can go by many names.It’s the structure of a sum that we’re after, and we’re willing to take it how it comes - but contingent on the shape of the type not differing from the proposal as written.I request that if the name Result be brought up again, that it come with the specific number and kind of parameters involved so we can nail down the shape being discussed.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; The argument is often made that we should have a generic “Either” type (though the name doesn’t matter, I’m talking about the semantics you’re describing) to complement tuples.However, the Either type you are providing is not analogous to Swift tuples, because Swift tuples allow you to *name* the elements of the tuple, and is generic w.r.t. the number of elements.Your Either type has neither of these features.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Contrary to the impression the other discussion has made, nowhere in the proposal do we wish to augment the type system.If this is done correctly, the type in the proposal should be a ~40-line addition to the standard library, it should not wind up as a full-blown language change.We are not advocating for an n-element sum type, nor are we arguing for a structural typing scheme that would put variadic sums in the language because we recognize that solution is untenable.We are, however, advocating for the inclusion of a 2-case sum type we happen to call Either in writing.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; The type system already supports N-ary “either” types.We call them enums.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; This is another example of exactly why Either is terrible in practice. I understand that from a type algebra point of view this is perfectly reasonable and clean and that a 2-way sum is all that is necessary because larger sums are easily created by construction. Type theory-wise it’s lovely.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Because this is a non-goal of the type. The sum as presented in the proposal does not attempt to take the place of enums, nor does it make any bones about being a finite entity.We are specifically emphasizing the two-element case.Any other arguments that pertain to its inclusion as a feature of the type system should start at the last site of discussion and probably terminate in a separate proposal adding that kind of scheme to the Swift language itself.We are arguing for a simple change to the standard library, nothing more.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; As before, unlike `throws`, a disjoint union type can be applied in arbitrary<br>&gt; &gt; &gt; &gt; &gt; positions, used as a member, and easily checked for completeness<br>&gt; &gt; &gt; &gt; &gt; at compile time.In addition, the lack of a standard union type has<br>&gt; &gt; &gt; &gt; &gt; led the Swift community to create [numerous](https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift(https://github.com/search?utf8=%E2%9C%93&amp;q=Either+language%3Aswift)) duplicate implementations of the<br>&gt; &gt; &gt; &gt; &gt; same mutually incompatible types over and over and over again.In the<br>&gt; &gt; &gt; &gt; &gt; interest of promoting a type that there has received clear interest by the<br>&gt; &gt; &gt; &gt; &gt; community, the addition to the Standard Library is necessary.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; The argument is not “let’s toss out all implementations of 2-case enums in favor of this sum” it’s “very often, when you’ve got a two-case enum with bias, you’ve got a sum described in the proposal”.This pattern shows up in a sufficiently large number of cases that we feel that the standard library deserves to have the final say as to a community-guided implementation of this type because individual implementations seem to differ only in a few minor places like naming or generic positions.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; I perceive a common Result/Either type as being desired for composability. If I have two libraries that define their own Result/Either/etc. types, my ability to compose functions across those libraries is impacted.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; This is another motivating factor that lines up with a major tenant of the proposal.We would not be suggesting this change to the standard library if we did not see this pattern show up in a number of large frameworks, applications, and everything in between.We offer a section of motivating examples and links that should convince you of its commonality if that is still a sticking point.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; I’d say “works”, not works; the ergonomics are terrible, you are unlikely to be able to take advantage of the bias anymore, and even if we overlook all that, you still have to enforce an external convention to get mutual-interoperability at each n; otherwise, you may say Either&lt;Either&lt;,&gt;,Either&lt;,&gt;&gt;but I may say Either&lt;Either&lt;Either&lt;,&gt;,&gt;,&gt;and someone else may say Either&lt;,Either&lt;,Either&lt;,&gt;&gt;&gt;and someone else says Either&lt;,Either&lt;Either&lt;,&gt;,&gt;&gt;and so on…<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; This point, while valid, is also an unfortunate feature of Optionals as well, which I have argued can be viewed as an Sum with one lobe “sealed” by Top, the empty tuple.I have yet to see a use of a sum type that needs nesting like this, nor have I seen any type or type alias that attempts to use this to recover an n-ary Sum because it just doesn’t happen.If you have a disjoint set of possibilities with order greater than two, as Chris noted, Swift already offers enums.And if such a case has arisen, it needs to be refactored just as Optional&lt;Optional&lt;Optional&lt;...&gt;&gt;&gt;would be.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; * An either-like type should be named something meaningful for the context it is used<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; See above.<br>&gt; &gt; &gt; &gt; &gt; * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; See proposal.<br>&gt; &gt; &gt; &gt; &gt; * Is defining or re-defining an either type hard?<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; See proposal.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; * Is it too niche to be in the standard library<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; We don’t believe so, see proposal.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; The rationale given for bias has been updated in the latest draft.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; tl;dr<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; On Jan 20, 2016, at 10:17 PM, Developer&lt;devteam.codafi at gmail.com(mailto:devteam.codafi at gmail.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; Hey all,<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; Just added a section of motivating examples to the Either proposal.Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; ~Robert Widmann<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; 2016/01/09 14:19、Developer&lt;devteam.codafi at gmail.com(mailto:devteam.codafi at gmail.com)&gt;のメッセージ:<br>&gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html).<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; Thanks all!<br>&gt; &gt; &gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; &gt; &gt; ~Robert Widmann<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/47e2ba9a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 27, 2016 at 01:00:00pm</p></header><div class="content"><p>So Either as a type is problematic because of a name… or something like that that it is either to generic or too niche…<br></p><p>I was wondering if we could get to it by another way that would be interoperable between libraries but have absolutely no implementation in the general library - but would be able to be tacked on through external libraries.<br></p><p>Something like:<br></p><p>typealias MyEither = Int | String   // not sure how it would be done with generic typing.  <br></p><p>where Either may contain an Int or a String but not both.  <br></p><p>As well as a way for third parties to add on things (queriable somehow) like fold, map as their implementation needs.  Maybe also be able to define postfix operators for functions that decompose or use these “Either” types without calling them “Either”.<br></p><p><br>&gt; On 2016-01-27, at 12:52:38, Jarod Long via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I hadn&#39;t, thanks for pointing me in the right direction.<br>&gt; <br>&gt; Jarod<br>&gt; <br>&gt; <br>&gt; On Jan 26, 2016, 21:48 -0800, Developer &lt;devteam.codafi at gmail.com&gt;, wrote:<br>&gt;&gt; Have you seen the last round of discussions (root https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html&gt;)?  I don’t want to continue discussing this specific thing here because it is outside the scope of the proposal as it stands.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 12:46 AM, Jarod Long via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, I think a preferable alternative to an Either or Result type is union types, which could work as a sort of on-the-fly enum. Silly example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func getNameOrAge() -&gt; |String, Int| { // or maybe enum(String, Int)<br>&gt;&gt;&gt;     if true {<br>&gt;&gt;&gt;         return &quot;Butterscotch&quot;<br>&gt;&gt;&gt;     } else {<br>&gt;&gt;&gt;         return 25<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch getNameOrAge() {<br>&gt;&gt;&gt;     case String(let name): print(&quot;Name: \(name)&quot;)<br>&gt;&gt;&gt;     case Int(let age):     print(&quot;Age: \(age)&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve run into a couple situations where I&#39;ve needed to return different types from some one-off function (outside of the result/error pattern), but didn&#39;t want to create another type for that hyper-specific use case, and I wished I had some way of inlining a one-off, either-or type. It&#39;s even temping to use a tuple with optional values to leverage its inlining behavior, but that produces extra unwanted code paths. Union types are a powerful and use-case-agnostic solution to that kind of problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jarod<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, 21:27 -0800, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;, wrote:<br>&gt;&gt;&gt;&gt; The other minor point is that this type (TBD) may not in fact be a result of function (of which everything returned from a function is in fact a result) would be an erroneous name. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-01-27, at 12:09:07, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m going to try and round up a summary of arguments for and against this proposal and my response to them, because I think there is a clear sense in everybody’s mind what Either entails, but that sense differs widely depending on individual interactions with the parts of the proposal.  I take full responsibility for the rhetoric and the style of debate that has been going on for the past ~24 hours.  It was borderline unprofessional the way this was going and I want to apologize now to those involved for being so very unclear in my reasoning and my rhetoric as to stir up a senseless debate about points we essentially agreed on beforehand.  As such, I’ve made some revisions to the proposal, I request that you all please re-read it (at https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md&gt;) before we try again so we can refocus this debate on more productive avenues of discourse.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Throughout this reply I’ve made heavy use of quotes from other replies.  Those will appear in purple.  Quotes from the proposal will appear in blue.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The type “Either” that we describe in the proposal is a placeholder.  I feel that must be emphasized, because there have been arguments about the name.  We specifically mention this in the proposal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The Swift Standard Library will be updated to include a left-biased sum type we have called Either - though other names may be appropriate depending on how the type is implemented.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What we are requesting is a finite-case, here precisely two-case, type that represents two disjoint possibilities.  As noted before, this type is often called Result by Swift framework authors and notably the programming language Rust which uses it in place of an exception handling mechanism.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Your motivating examples (including all the projects you linked except &quot;Any many more&quot;) overwhelmingly use the Either (or similar type) to represent success/failure. I&#39;m not sure there&#39;s a single example where the names Left and Right actually make sense in the problem domain.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There absolutely is a cost. `Result&lt;T&gt;` has a rather intuitive meaning. `Either&lt;T&gt;` has no intuitive meaning whatsoever. It says absolutely nothing about what it means beyond the fact that there are two potential values. As a result, it is a largely useless type whose sole redeeming feature is it allows developers to avoid having to define their own enum, but in most cases that aren&#39;t covered by Result&lt;T&gt; you actually want to define your own enum so you can attach meaning to the value.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You&#39;ve mentioned Rust many times, but I don&#39;t understand why. Rust does _not_ have an Either type. In fact, Rust&#39;s success is a great example of how Either is unnecessary. What Rust does have is a Result&lt;T,E&gt; type, and the lack of a more generically-named Either type was an intentional decision (with pretty much the same rationale that I&#39;ve been giving).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We recognize that Result conveys a particular semantics that encourage this type to cross over into the error-handling domain.  As noted in the proposal, we don’t want to emphasize this case because a version of this proposal was already rejected for overlapping too heavily with throws.  If the community feels that the proposal deserves to be rewritten in a way that re-emphasizes this case and makes that point then I am up for it.  But, I request that this not be used as an argument to reduce the genericity of the type - which is to say I don’t wish to see a Result&lt;T&gt; or a Result&lt;T, E : ErrorType&gt; because they reduce the power of the original proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When I use the term genericity, I am not arguing for the naming scheme of the Either we have, I’m arguing for the structure to be kept around as-is.  My biggest fear is that a Result with one lobe and an Error is going to be merged rather than the full proposal because this type and the discussion of it outside of here can become too absorbed in the error-handling case.  I do not wish to lose the structure of the type we have now, because that structure is precisely what a future Swift could generalize and abstract upon.  The name, however, is up for grabs.  We offer a list of alternatives at the end of the proposal, if you have any more to suggest please reply to me here and I’ll see about adding them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; At the same time, it has been brought up that Either conveys no immediate useful information.  At the time of writing this proposal, we do not believe that to be the case, but we recognize that by naming this Result we can reach a wider audience.  At the end of the day the proposal is about merging in a 2-case sum type.  We chose Either not because we wanted to see it merged, but precisely because it was so meaning-agnostic.  It’s our lorem-ipsum.  For those that think we’re trying to merge a Haskell-ism, I can say with complete confidence that no part of TypeLift intended that in the original proposal.  Whatever bad taste Haskell may have left in anybody’s mouth, the Either in our proposal is a placeholder for a name to be decided upon by the community.  I felt that this was clear from the line <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; though other names may be appropriate depending on how the type is implemented.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In addition, the name `Either` does not lend much to the imagination,<br>&gt;&gt;&gt;&gt;&gt;&gt; and the use of `Left` and `Right` have the potential to cause confusion to<br>&gt;&gt;&gt;&gt;&gt;&gt; novices expecting a `Result&lt;T&gt;`<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; in the original proposal, but I was wrong.  I have updated the draft accordingly.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Besides, even if the type in the proposal were to be merged right this very second, “meaningless&quot; names and all, a domain-specific Result type could easily be recovered from it.  The same is not true of a type that is immediately domain-specific like the reduced-generic forms of Result.  To translate that into the language of Result using Either as a template: If a Result&lt;T, E&gt; were not merged, then it could not be recovered from Result&lt;T&gt; in any meaningful manner.  However, a constrained Result&lt;T, E : ErrorType&gt; can be recovered from the fully generic type in the proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.  This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names.  Why should we add a type to the standard library that has very few remaining use cases, and leads to a code style that we don’t want?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is in line with the goals of the proposal and I would certainly support this renaming if it serves the community’s best interest.  You all are, by now, aware of my qualms with the name, but I’m not one to dwell on these things when we’ve made it clear in the proposal that the type can go by many names.  It’s the structure of a sum that we’re after, and we’re willing to take it how it comes - but contingent on the shape of the type not differing from the proposal as written.  I request that if the name Result be brought up again, that it come with the specific number and kind of parameters involved so we can nail down the shape being discussed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The argument is often made that we should have a generic “Either” type (though the name doesn’t matter, I’m talking about the semantics you’re describing) to complement tuples.  However, the Either type you are providing is not analogous to Swift tuples, because Swift tuples allow you to *name* the elements of the tuple, and is generic w.r.t. the number of elements.  Your Either type has neither of these features.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Contrary to the impression the other discussion has made, nowhere in the proposal do we wish to augment the type system.  If this is done correctly, the type in the proposal should be a ~40-line addition to the standard library, it should not wind up as a full-blown language change.  We are not advocating for an n-element sum type, nor are we arguing for a structural typing scheme that would put variadic sums in the language because we recognize that solution is untenable.  We are, however, advocating for the inclusion of a 2-case sum type we happen to call Either in writing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The type system already supports N-ary “either” types.  We call them enums.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is another example of exactly why Either is terrible in practice. I understand that from a type algebra point of view this is perfectly reasonable and clean and that a 2-way sum is all that is necessary because larger sums are easily created by construction. Type theory-wise it’s lovely.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Because this is a non-goal of the type. The sum as presented in the proposal does not attempt to take the place of enums, nor does it make any bones about being a finite entity.  We are specifically emphasizing the two-element case.  Any other arguments that pertain to its inclusion as a feature of the type system should start at the last site of discussion and probably terminate in a separate proposal adding that kind of scheme to the Swift language itself.  We are arguing for a simple change to the standard library, nothing more.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As before, unlike `throws`, a disjoint union type can be applied in arbitrary<br>&gt;&gt;&gt;&gt;&gt;&gt; positions, used as a member, and easily checked for completeness<br>&gt;&gt;&gt;&gt;&gt;&gt; at compile time.  In addition, the lack of a standard union type has<br>&gt;&gt;&gt;&gt;&gt;&gt; led the Swift community to create [numerous](https://github.com/search?utf8=✓&amp;q=Either+language%3Aswift &lt;https://github.com/search?utf8=%E2%9C%93&amp;q=Either+language%3Aswift&gt;) duplicate implementations of the<br>&gt;&gt;&gt;&gt;&gt;&gt; same mutually incompatible types over and over and over again.  In the<br>&gt;&gt;&gt;&gt;&gt;&gt; interest of promoting a type that there has received clear interest by the<br>&gt;&gt;&gt;&gt;&gt;&gt; community, the addition to the Standard Library is necessary.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The argument is not “let’s toss out all implementations of 2-case enums in favor of this sum” it’s “very often, when you’ve got a two-case enum with bias, you’ve got a sum described in the proposal”.  This pattern shows up in a sufficiently large number of cases that we feel that the standard library deserves to have the final say as to a community-guided implementation of this type because individual implementations seem to differ only in a few minor places like naming or generic positions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I perceive a common Result/Either type as being desired for composability. If I have two libraries that define their own Result/Either/etc. types, my ability to compose functions across those libraries is impacted. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is another motivating factor that lines up with a major tenant of the proposal.  We would not be suggesting this change to the standard library if we did not see this pattern show up in a number of large frameworks, applications, and everything in between.  We offer a section of motivating examples and links that should convince you of its commonality if that is still a sticking point.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d say “works”, not works; the ergonomics are terrible, you are unlikely to be able to take advantage of the bias anymore, and even if we overlook all that, you still have to enforce an external convention to get mutual-interoperability at each n; otherwise, you may say Either&lt;Either&lt;,&gt;,Either&lt;,&gt;&gt; but I may say Either&lt;Either&lt;Either&lt;,&gt;,&gt;,&gt; and someone else may say Either&lt;,Either&lt;,Either&lt;,&gt;&gt;&gt; and someone else says Either&lt;,Either&lt;Either&lt;,&gt;,&gt;&gt; and so on…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This point, while valid, is also an unfortunate feature of Optionals as well, which I have argued can be viewed as an Sum with one lobe “sealed” by Top, the empty tuple.  I have yet to see a use of a sum type that needs nesting like this, nor have I seen any type or type alias that attempts to use this to recover an n-ary Sum because it just doesn’t happen.  If you have a disjoint set of possibilities with order greater than two, as Chris noted, Swift already offers enums.  And if such a case has arisen, it needs to be refactored just as Optional&lt;Optional&lt;Optional&lt;...&gt;&gt;&gt; would be.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  * An either-like type should be named something meaningful for the context it is used<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; See above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  * There are a lot of cases where an either-like type is useful, there may generalised functions that are often used on them<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; See proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  * Is defining or re-defining an either type hard?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; See proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  * Is it too niche to be in the standard library<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We don’t believe so, see proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No, I take issue with the entire fundamental idea behind your proposal. You&#39;ve explicitly defined this type purely by its shape, with no meaning whatsoever given to either variant, except insofar as the type is Left-biased (which only serves to be even more confusing; since there&#39;s no actual meaning assigned to Left/Right, what is the justification for adding the left-biasing?)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The rationale given for bias has been updated in the latest draft.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; tl;dr<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree with Kevin and others that we’re likely to be destined to introduce a real Result type.  This will serve the most common cases that you’re citing as use cases for a fully generic Either type, and provide good names. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 20, 2016, at 10:17 PM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hey all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just added a section of motivating examples to the Either proposal.  Ping me if you have any more that I missed (&#39;cause I&#39;m sure I did miss a lot).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples &lt;https://github.com/typelift/swift-evolution/blob/either-or/proposals/0024-either.md#motivating-examples&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016/01/09 14:19、Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; のメッセージ:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because the last discussion, while substantive and very much appreciated, did not debate the proposal much, I&#39;d like to begin discussion anew about the addition of an Either type to the Swift Standard Library.  The proposal can be found here (https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481 &lt;https://github.com/apple/swift-evolution/pull/67#issuecomment-170269481&gt;) and a link to the root our previous round of discussion is here (https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001394.html&gt;).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks all!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/8ea1bef0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 30, 2016 at 12:00:00pm</p></header><div class="content"><p>As this thread is already quite huge, and discussion could go on forever, maybe you don&#39;t mind a crosspost:<br>I really don&#39;t think &quot;Either&quot; belongs to the standard library, but I also think it is bad to have a thousand nearly identical implementations of it.<br>So, what is the right place for Either?<br>My answer to that question is written in another thread:<br>http://thread.gmane.org/gmane.comp.lang.swift.evolution/4640/focus=4667<br></p><p>There are no signs anyone at Apple would support a standard library for functional programming, but maybe we as a community are strong enough to establish it on our own.<br></p><p>David already created something (https://github.com/swift-breeze) that could act as a starting point.<br>I have no idea if this will work out well, but I&#39;m planning to push aside vanity and contribute to a project that is neither my own nor lures with the fame associated with core Swift itself.<br></p><p>So, why not simply push back discussion and start coding &amp; committing? ;-)<br></p><p>Tino<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
