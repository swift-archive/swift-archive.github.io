<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5ed5581b2484d8de8d56161beabbe8c2?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Hugues Bernet-Rollande</string> &lt;hugues at xdev.fr&gt;<p>March 24, 2016 at 03:00:00am</p></header><div class="content"><p>In a strongly typed language, such as Swift is, type inference is greatly<br>appreciated as it declutter the instance type definition.<br></p><p>  <br></p><p>For example, in the following statement, the compiler easily deduct the type<br>of `aString` by the return type of `String.init()`<br></p><p>  <br></p><p>```<br></p><p>let aString = String()<br></p><p>```<br></p><p>  <br></p><p>Optional are generic enum which can contain a value of a generic type or nil<br>(https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift)<br></p><p>  <br></p><p>Sometime you may want specify that the instance is of type optional in which<br>even if you are a the same time assigning a value to this instance.<br></p><p>In which case you loose the type inference mechanism and you have to define<br>both (the optionality as well as the type).<br></p><p>For example, you may want specify an optional String with a default value.<br></p><p>  <br></p><p>```<br></p><p>var a:String? = String()<br></p><p>// or<br></p><p>var b = String() as String?<br></p><p>// or<br></p><p>var c:Optional&amp;lt;String&amp;gt; = String()  <br></p><p>```<br></p><p>  <br></p><p>But the compiler can already infer the variable type from this assignment, it<br>just miss the &quot;optionality&quot; of the variable.<br></p><p>It would be nice to be able to express this.<br></p><p>  <br></p><p>Then for, I propose the following syntax evolution:<br></p><p>  <br></p><p>```<br></p><p>var a:? = String()<br></p><p>// and/or (not recommended because more prone to typo and unclear...)<br></p><p>var a = String() as?<br></p><p>```<br></p><p>  <br></p><p>This would allow for more synthetic optional declaration.<br></p><p>  <br></p><p>I&#39;ve draft a proposal on my `swift-evolution` fork:<br></p><p>https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-type-<br>inference/proposals/0057-optionality-type-with-type-inference.md<br></p><p>  <br></p><p>Let me know what you think.<br></p><p>  <br></p><p>  <br></p><p>Hugues BERNET-ROLLANDE<br></p><p>  <br></p><p>\--<br></p><p>hugues at xdev.fr<br></p><p>http://www.xdev.fr<br></p><p>http://www.linkedin.com/in/huguesbr<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/a7e6e623/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>March 24, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi Huges,<br></p><p>You can achieve a very similar result like this:<br></p><p>let x = 123<br></p><p>let y: Optional = x<br></p><p><br>The generic arguments can be inferred in more complicated cases too, for<br>example:<br></p><p>let z: Set = [1, 2, 3]<br></p><p><br>Which creates a Set&lt;Int&gt; rather than an Array&lt;Int&gt;.<br></p><p><br>I hope this helps!<br></p><p>Andrew Bennett<br></p><p><br></p><p>On Thu, Mar 24, 2016 at 9:22 PM, Hugues Bernet-Rollande via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In a strongly typed language, such as Swift is, type inference is greatly<br>&gt; appreciated as it declutter the instance type definition.<br>&gt;<br>&gt; For example, in the following statement, the compiler easily deduct the<br>&gt; type of `aString` by the return type of `String.init()`<br>&gt;<br>&gt; ```<br>&gt; let aString = String()<br>&gt; ```<br>&gt;<br>&gt; Optional are generic enum which can contain a value of a generic type or<br>&gt; nil (<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift<br>&gt; )<br>&gt;<br>&gt; Sometime you may want specify that the instance is of type optional in<br>&gt; which even if you are a the same time assigning a value to this instance.<br>&gt; In which case you loose the type inference mechanism and you have to<br>&gt; define both (the optionality as well as the type).<br>&gt; For example, you may want specify an optional String with a default value.<br>&gt;<br>&gt; ```<br>&gt; var a:String? = String()<br>&gt; // or<br>&gt; var b = String() as String?<br>&gt; // or<br>&gt; var c:Optional&lt;String&gt; = String()<br>&gt; ```<br>&gt;<br>&gt; But the compiler can already infer the variable type from this assignment,<br>&gt; it just miss the &quot;optionality&quot; of the variable.<br>&gt; It would be nice to be able to express this.<br>&gt;<br>&gt; Then for, I propose the following syntax evolution:<br>&gt;<br>&gt; ```<br>&gt; var a:? = String()<br>&gt; // and/or (not recommended because more prone to typo and unclear...)<br>&gt; var a = String() as?<br>&gt; ```<br>&gt;<br>&gt; This would allow for more synthetic optional declaration.<br>&gt;<br>&gt; I&#39;ve draft a proposal on my `swift-evolution` fork:<br>&gt;<br>&gt; https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-type-inference/proposals/0057-optionality-type-with-type-inference.md<br>&gt;<br>&gt; Let me know what you think.<br>&gt;<br>&gt;<br>&gt; Hugues BERNET-ROLLANDE<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; hugues at xdev.fr<br>&gt;<br>&gt; http://www.xdev.fr<br>&gt;<br>&gt; http://www.linkedin.com/in/huguesbr<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/efe20931/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5ed5581b2484d8de8d56161beabbe8c2?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Hugues Bernet-Rollande</string> &lt;hugues at xdev.fr&gt;<p>March 24, 2016 at 03:00:00am</p></header><div class="content"><p>Oh my,<br></p><p>  <br></p><p>I totally miss this one.<br></p><p>The generic one is pretty cool too.<br></p><p>  <br></p><p>You think the `?` shortcut could still make sense?<br></p><p>  <br></p><p>let y: ? = 123  <br></p><p>  <br></p><p>Thanks!<br></p><p>  <br></p><p>  <br></p><p>Hugues BERNET-ROLLANDE<br></p><p>  <br></p><p>&gt; On Mar 24 2016, at 11:41 am, Andrew Bennett &amp;lt;cacoyi at gmail.com&amp;gt; wrote:  <br></p><p>&gt;<br></p><p>&gt; Hi Huges,<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; You can achieve a very similar result like this:<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; let x = 123<br></p><p>&gt;<br></p><p>&gt; let y: Optional = x<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; The generic arguments can be inferred in more complicated cases too, for<br>example:<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; let z: Set = [1, 2, 3]<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; Which creates a Set&amp;lt;Int&amp;gt; rather than an Array&amp;lt;Int&amp;gt;.  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; I hope this helps!<br></p><p>&gt;<br></p><p>&gt; Andrew Bennett  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; On Thu, Mar 24, 2016 at 9:22 PM, Hugues Bernet-Rollande via swift-evolution<br>&amp;lt;[swift-evolution at swift.org](mailto:swift-evolution at swift.org)&amp;gt; wrote:  <br></p><p>&gt;<br></p><p>&gt;&gt; In a strongly typed language, such as Swift is, type inference is greatly<br>appreciated as it declutter the instance type definition.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; For example, in the following statement, the compiler easily deduct the<br>type of `aString` by the return type of `String.init()`<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; let aString = String()<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Optional are generic enum which can contain a value of a generic type or<br>nil (&lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.s<br>wift&gt;)<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Sometime you may want specify that the instance is of type optional in<br>which even if you are a the same time assigning a value to this instance.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; In which case you loose the type inference mechanism and you have to define<br>both (the optionality as well as the type).<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; For example, you may want specify an optional String with a default value.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var a:String? = String()<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; // or<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var b = String() as String?<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; // or<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var c:Optional&amp;lt;String&amp;gt; = String()  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; But the compiler can already infer the variable type from this assignment,<br>it just miss the &quot;optionality&quot; of the variable.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; It would be nice to be able to express this.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Then for, I propose the following syntax evolution:<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var a:? = String()<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; // and/or (not recommended because more prone to typo and unclear...)<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var a = String() as?<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; This would allow for more synthetic optional declaration.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; I&#39;ve draft a proposal on my `swift-evolution` fork:<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; &lt;https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-<br>type-inference/proposals/0057-optionality-type-with-type-inference.md&gt;<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Let me know what you think.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Hugues BERNET-ROLLANDE<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; \--<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; [hugues at xdev.fr](mailto:hugues at xdev.fr)<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; &lt;http://www.xdev.fr&gt;<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; &lt;http://www.linkedin.com/in/huguesbr&gt;<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br>_______________________________________________  <br>swift-evolution mailing list  <br>[swift-evolution at swift.org](mailto:swift-evolution at swift.org)  <br>&lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;  <br>  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/7f5b9e12/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 24, 2016 at 11:00:00am</p></header><div class="content"><p>Sorry, but I don&#39;t see an advantage over the current form. Introducing a new syntactical variant just to be able to drop the type name does not pull its own weight IMO.<br></p><p>-Thorsten <br></p><p>&gt; Am 24.03.2016 um 11:22 schrieb Hugues Bernet-Rollande via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; In a strongly typed language, such as Swift is, type inference is greatly appreciated as it declutter the instance type definition.<br>&gt; <br>&gt; For example, in the following statement, the compiler easily deduct the type of `aString` by the return type of `String.init()`<br>&gt; <br>&gt; ```<br>&gt; let aString = String()<br>&gt; ```<br>&gt; <br>&gt; Optional are generic enum which can contain a value of a generic type or nil (https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift)<br>&gt; <br>&gt; Sometime you may want specify that the instance is of type optional in which even if you are a the same time assigning a value to this instance.<br>&gt; In which case you loose the type inference mechanism and you have to define both (the optionality as well as the type). <br>&gt; For example, you may want specify an optional String with a default value.<br>&gt; <br>&gt; ```<br>&gt; var a:String? = String()<br>&gt; // or<br>&gt; var b = String() as String?<br>&gt; // or<br>&gt; var c:Optional&lt;String&gt; = String()<br>&gt; ```<br>&gt; <br>&gt; But the compiler can already infer the variable type from this assignment, it just miss the &quot;optionality&quot; of the variable.<br>&gt; It would be nice to be able to express this.<br>&gt; <br>&gt; Then for, I propose the following syntax evolution:<br>&gt; <br>&gt; ```<br>&gt; var a:? = String()<br>&gt; // and/or (not recommended because more prone to typo and unclear...)<br>&gt; var a = String() as?<br>&gt; ```<br>&gt; <br>&gt; This would allow for more synthetic optional declaration.<br>&gt; <br>&gt; I&#39;ve draft a proposal on my `swift-evolution` fork:<br>&gt; 	https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-type-inference/proposals/0057-optionality-type-with-type-inference.md<br>&gt; <br>&gt; Let me know what you think.<br>&gt; <br>&gt; <br>&gt; Hugues BERNET-ROLLANDE<br>&gt; <br>&gt; --<br>&gt; hugues at xdev.fr<br>&gt; http://www.xdev.fr<br>&gt; http://www.linkedin.com/in/huguesbr<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/6dc66d52/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bbea2d379c2fdc51fe02db1c3caa15de?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Dan Raviv</string> &lt;dan.raviv at gmail.com&gt;<p>March 24, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Hughes,<br></p><p>What&#39;s wrong with:<br>let s = Optional(String(&quot;abc&quot;))<br></p><p><br>On Thu, Mar 24, 2016 at 12:22 PM, Hugues Bernet-Rollande via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In a strongly typed language, such as Swift is, type inference is greatly<br>&gt; appreciated as it declutter the instance type definition.<br>&gt;<br>&gt; For example, in the following statement, the compiler easily deduct the<br>&gt; type of `aString` by the return type of `String.init()`<br>&gt;<br>&gt; ```<br>&gt; let aString = String()<br>&gt; ```<br>&gt;<br>&gt; Optional are generic enum which can contain a value of a generic type or<br>&gt; nil (<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift<br>&gt; )<br>&gt;<br>&gt; Sometime you may want specify that the instance is of type optional in<br>&gt; which even if you are a the same time assigning a value to this instance.<br>&gt; In which case you loose the type inference mechanism and you have to<br>&gt; define both (the optionality as well as the type).<br>&gt; For example, you may want specify an optional String with a default value.<br>&gt;<br>&gt; ```<br>&gt; var a:String? = String()<br>&gt; // or<br>&gt; var b = String() as String?<br>&gt; // or<br>&gt; var c:Optional&lt;String&gt; = String()<br>&gt; ```<br>&gt;<br>&gt; But the compiler can already infer the variable type from this assignment,<br>&gt; it just miss the &quot;optionality&quot; of the variable.<br>&gt; It would be nice to be able to express this.<br>&gt;<br>&gt; Then for, I propose the following syntax evolution:<br>&gt;<br>&gt; ```<br>&gt; var a:? = String()<br>&gt; // and/or (not recommended because more prone to typo and unclear...)<br>&gt; var a = String() as?<br>&gt; ```<br>&gt;<br>&gt; This would allow for more synthetic optional declaration.<br>&gt;<br>&gt; I&#39;ve draft a proposal on my `swift-evolution` fork:<br>&gt;<br>&gt; https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-type-inference/proposals/0057-optionality-type-with-type-inference.md<br>&gt;<br>&gt; Let me know what you think.<br>&gt;<br>&gt;<br>&gt; Hugues BERNET-ROLLANDE<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; hugues at xdev.fr<br>&gt;<br>&gt; http://www.xdev.fr<br>&gt;<br>&gt; http://www.linkedin.com/in/huguesbr<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/0a06f376/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5ed5581b2484d8de8d56161beabbe8c2?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Hugues Bernet-Rollande</string> &lt;hugues at xdev.fr&gt;<p>March 24, 2016 at 03:00:00am</p></header><div class="content"><p>Hey All,<br></p><p>  <br></p><p>I think Andrew already nailed my proposal.<br></p><p>  <br></p><p>Thank you all.<br></p><p>  <br></p><p>  <br></p><p>Hugues BERNET-ROLLANDE<br></p><p>  <br></p><p>\--<br></p><p>hugues at xdev.fr<br></p><p>http://www.xdev.fr<br></p><p>http://www.linkedin.com/in/huguesbr<br></p><p>&gt; On Mar 24 2016, at 11:56 am, Dan Raviv &amp;lt;dan.raviv at gmail.com&amp;gt; wrote:  <br></p><p>&gt;<br></p><p>&gt; Hi Hughes,<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; What&#39;s wrong with:  <br>let s = Optional(String(&quot;abc&quot;))  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; On Thu, Mar 24, 2016 at 12:22 PM, Hugues Bernet-Rollande via swift-evolution<br>&amp;lt;[swift-evolution at swift.org](mailto:swift-evolution at swift.org)&amp;gt; wrote:  <br></p><p>&gt;<br></p><p>&gt;&gt; In a strongly typed language, such as Swift is, type inference is greatly<br>appreciated as it declutter the instance type definition.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; For example, in the following statement, the compiler easily deduct the<br>type of `aString` by the return type of `String.init()`<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; let aString = String()<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Optional are generic enum which can contain a value of a generic type or<br>nil (&lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.s<br>wift&gt;)<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Sometime you may want specify that the instance is of type optional in<br>which even if you are a the same time assigning a value to this instance.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; In which case you loose the type inference mechanism and you have to define<br>both (the optionality as well as the type).<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; For example, you may want specify an optional String with a default value.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var a:String? = String()<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; // or<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var b = String() as String?<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; // or<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var c:Optional&amp;lt;String&amp;gt; = String()  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; But the compiler can already infer the variable type from this assignment,<br>it just miss the &quot;optionality&quot; of the variable.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; It would be nice to be able to express this.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Then for, I propose the following syntax evolution:<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var a:? = String()<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; // and/or (not recommended because more prone to typo and unclear...)<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var a = String() as?<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; This would allow for more synthetic optional declaration.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; I&#39;ve draft a proposal on my `swift-evolution` fork:<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; &lt;https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-<br>type-inference/proposals/0057-optionality-type-with-type-inference.md&gt;<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Let me know what you think.<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Hugues BERNET-ROLLANDE<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; \--<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; [hugues at xdev.fr](mailto:hugues at xdev.fr)<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; &lt;http://www.xdev.fr&gt;<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; &lt;http://www.linkedin.com/in/huguesbr&gt;<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br>_______________________________________________  <br>swift-evolution mailing list  <br>[swift-evolution at swift.org](mailto:swift-evolution at swift.org)  <br>&lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;  <br>  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/755dfeba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>March 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Only to be complete:<br></p><p>let str1 = String?() // nil<br>let str2 = String?(&quot;&quot;) // &quot;&quot;<br></p><p>Kind regards<br>- Maximilian<br></p><p>&gt; Am 24.03.2016 um 11:57 schrieb Hugues Bernet-Rollande via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hey All,<br>&gt; <br>&gt; I think Andrew already nailed my proposal.<br>&gt; <br>&gt; Thank you all.<br>&gt; <br>&gt; <br>&gt; Hugues BERNET-ROLLANDE<br>&gt; <br>&gt; --<br>&gt; hugues at xdev.fr<br>&gt; http://www.xdev.fr<br>&gt; http://www.linkedin.com/in/huguesbr<br>&gt;&gt; On Mar 24 2016, at 11:56 am, Dan Raviv &lt;dan.raviv at gmail.com&gt; wrote: <br>&gt;&gt; Hi Hughes,<br>&gt;&gt; <br>&gt;&gt; What&#39;s wrong with:<br>&gt;&gt; let s = Optional(String(&quot;abc&quot;))<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Mar 24, 2016 at 12:22 PM, Hugues Bernet-Rollande via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; In a strongly typed language, such as Swift is, type inference is greatly appreciated as it declutter the instance type definition.<br>&gt;&gt; <br>&gt;&gt; For example, in the following statement, the compiler easily deduct the type of `aString` by the return type of `String.init()`<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let aString = String()<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Optional are generic enum which can contain a value of a generic type or nil (https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift)<br>&gt;&gt; <br>&gt;&gt; Sometime you may want specify that the instance is of type optional in which even if you are a the same time assigning a value to this instance.<br>&gt;&gt; In which case you loose the type inference mechanism and you have to define both (the optionality as well as the type). <br>&gt;&gt; For example, you may want specify an optional String with a default value.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; var a:String? = String()<br>&gt;&gt; // or<br>&gt;&gt; var b = String() as String?<br>&gt;&gt; // or<br>&gt;&gt; var c:Optional&lt;String&gt; = String()<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; But the compiler can already infer the variable type from this assignment, it just miss the &quot;optionality&quot; of the variable.<br>&gt;&gt; It would be nice to be able to express this.<br>&gt;&gt; <br>&gt;&gt; Then for, I propose the following syntax evolution:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; var a:? = String()<br>&gt;&gt; // and/or (not recommended because more prone to typo and unclear...)<br>&gt;&gt; var a = String() as?<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; This would allow for more synthetic optional declaration.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve draft a proposal on my `swift-evolution` fork:<br>&gt;&gt; 	https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-type-inference/proposals/0057-optionality-type-with-type-inference.md<br>&gt;&gt; <br>&gt;&gt; Let me know what you think.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hugues BERNET-ROLLANDE<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; hugues at xdev.fr<br>&gt;&gt; http://www.xdev.fr<br>&gt;&gt; http://www.linkedin.com/in/huguesbr<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/9a08d249/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>March 27, 2016 at 07:00:00pm</p></header><div class="content"><p>I think it would make sense if a postfix &quot;?&quot; would make the variable<br>optional:<br></p><p>    var x = &quot;some string&quot;?<br>    x = nil  // allowed because x has type Optional&lt;String&gt;<br></p><p>This parallels the optional pattern: `if case &quot;foo&quot;? = x { ... }`<br></p><p>Jacob<br></p><p>On Sun, Mar 27, 2016 at 3:13 PM, Maximilian Hünenberger &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Only to be complete:<br>&gt;<br>&gt; let str1 = String?() // nil<br>&gt; let str2 = String?(&quot;&quot;) // &quot;&quot;<br>&gt;<br>&gt; Kind regards<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 24.03.2016 um 11:57 schrieb Hugues Bernet-Rollande via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Hey All,<br>&gt;<br>&gt; I think Andrew already nailed my proposal.<br>&gt;<br>&gt; Thank you all.<br>&gt;<br>&gt;<br>&gt; Hugues BERNET-ROLLANDE<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; hugues at xdev.fr<br>&gt;<br>&gt; http://www.xdev.fr<br>&gt;<br>&gt; http://www.linkedin.com/in/huguesbr<br>&gt;<br>&gt;&gt; On Mar 24 2016, at 11:56 am, Dan Raviv &lt;dan.raviv at gmail.com&gt; wrote:<br>&gt;&gt; Hi Hughes,<br>&gt;&gt;<br>&gt;&gt; What&#39;s wrong with:<br>&gt;&gt; let s = Optional(String(&quot;abc&quot;))<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Mar 24, 2016 at 12:22 PM, Hugues Bernet-Rollande via<br>&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; In a strongly typed language, such as Swift is, type inference is greatly<br>&gt;&gt; appreciated as it declutter the instance type definition.<br>&gt;&gt;<br>&gt;&gt; For example, in the following statement, the compiler easily deduct the<br>&gt;&gt; type of `aString` by the return type of `String.init()`<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; let aString = String()<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; Optional are generic enum which can contain a value of a generic type or<br>&gt;&gt; nil (<br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift<br>&gt;&gt; )<br>&gt;&gt;<br>&gt;&gt; Sometime you may want specify that the instance is of type optional in<br>&gt;&gt; which even if you are a the same time assigning a value to this instance.<br>&gt;&gt; In which case you loose the type inference mechanism and you have to<br>&gt;&gt; define both (the optionality as well as the type).<br>&gt;&gt; For example, you may want specify an optional String with a default value.<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; var a:String? = String()<br>&gt;&gt; // or<br>&gt;&gt; var b = String() as String?<br>&gt;&gt; // or<br>&gt;&gt; var c:Optional&lt;String&gt; = String()<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; But the compiler can already infer the variable type from this<br>&gt;&gt; assignment, it just miss the &quot;optionality&quot; of the variable.<br>&gt;&gt; It would be nice to be able to express this.<br>&gt;&gt;<br>&gt;&gt; Then for, I propose the following syntax evolution:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; var a:? = String()<br>&gt;&gt; // and/or (not recommended because more prone to typo and unclear...)<br>&gt;&gt; var a = String() as?<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; This would allow for more synthetic optional declaration.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve draft a proposal on my `swift-evolution` fork:<br>&gt;&gt;<br>&gt;&gt; https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-type-inference/proposals/0057-optionality-type-with-type-inference.md<br>&gt;&gt;<br>&gt;&gt; Let me know what you think.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hugues BERNET-ROLLANDE<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; hugues at xdev.fr<br>&gt;&gt;<br>&gt;&gt; http://www.xdev.fr<br>&gt;&gt;<br>&gt;&gt; http://www.linkedin.com/in/huguesbr<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/ec99c7b1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March 31, 2016 at 01:00:00pm</p></header><div class="content"><p>Could you give us one or two real-world examples where you’d want to do this?<br></p><p>I really can’t think of a situation where I would want to assign a non-optional to an optional variable. Even if I transform it later such that it might produce nil, it’s desirable to assign it to two different constants:<br></p><p>	let a = String()<br>	let b = a.thisMightMakeMeNil()<br></p><p>— Radek<br></p><p>&gt; On 24 Mar 2016, at 11:22, Hugues Bernet-Rollande via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In a strongly typed language, such as Swift is, type inference is greatly appreciated as it declutter the instance type definition.<br>&gt; <br>&gt; For example, in the following statement, the compiler easily deduct the type of `aString` by the return type of `String.init()`<br>&gt; <br>&gt; ```<br>&gt; let aString = String()<br>&gt; ```<br>&gt; <br>&gt; Optional are generic enum which can contain a value of a generic type or nil (https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift)<br>&gt; <br>&gt; Sometime you may want specify that the instance is of type optional in which even if you are a the same time assigning a value to this instance.<br>&gt; In which case you loose the type inference mechanism and you have to define both (the optionality as well as the type). <br>&gt; For example, you may want specify an optional String with a default value.<br>&gt; <br>&gt; ```<br>&gt; var a:String? = String()<br>&gt; // or<br>&gt; var b = String() as String?<br>&gt; // or<br>&gt; var c:Optional&lt;String&gt; = String()<br>&gt; ```<br>&gt; <br>&gt; But the compiler can already infer the variable type from this assignment, it just miss the &quot;optionality&quot; of the variable.<br>&gt; It would be nice to be able to express this.<br>&gt; <br>&gt; Then for, I propose the following syntax evolution:<br>&gt; <br>&gt; ```<br>&gt; var a:? = String()<br>&gt; // and/or (not recommended because more prone to typo and unclear...)<br>&gt; var a = String() as?<br>&gt; ```<br>&gt; <br>&gt; This would allow for more synthetic optional declaration.<br>&gt; <br>&gt; I&#39;ve draft a proposal on my `swift-evolution` fork:<br>&gt; 	https://github.com/huguesbr/swift-evolution/blob/optionality-type-with-type-inference/proposals/0057-optionality-type-with-type-inference.md<br>&gt; <br>&gt; Let me know what you think.<br>&gt; <br>&gt; <br>&gt; Hugues BERNET-ROLLANDE<br>&gt; <br>&gt; --<br>&gt; hugues at xdev.fr<br>&gt; http://www.xdev.fr<br>&gt; <br>&gt; http://www.linkedin.com/in/huguesbr<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/72754b2a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 31, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 4:22 AM, Hugues Bernet-Rollande via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; ```<br>&gt; var a:String? = String()<br>&gt; // or<br>&gt; var b = String() as String?<br>&gt; // or<br>&gt; var c:Optional&lt;String&gt; = String()<br>&gt; ```<br></p><p>When I need to force an optional (primarily for sample code) I can do this already:<br></p><p>```<br>var myOptionalString = Optional(&quot;&quot;)<br>```<br></p><p>In this example, `myOptionalString ` picks up the type as well as the optionality.<br>Does this not meet your requirement of &quot;Allowing to specify only the optionality part of <br>a variable type while still having the actual wrapped type infered by the assignement&quot; in existing<br>Swift?<br></p><p>Beyond that, can you offer any compelling use-cases that motivate this change?<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/ac8a9d7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5ed5581b2484d8de8d56161beabbe8c2?s=50"></div><header><strong>allowing to specify optionality with type inference</strong> from <string>Hugues Bernet-Rollande</string> &lt;hugues at xdev.fr&gt;<p>March 31, 2016 at 08:00:00am</p></header><div class="content"><p>Hey All,<br></p><p>  <br></p><p>I think Andrew already pointed out the solution.<br></p><p>  <br></p><p>In first place I wasn&#39;t sure if there was a syntax to express the Optionality<br>of a variable while keeping the inference type.<br></p><p>  <br></p><p>I was just suggesting to use the &quot;?&quot; syntax to do so:<br></p><p>  <br></p><p>```<br></p><p>// Optional string  with an existing without declaring a specific type except<br>it&#39;s optionality, gaining for free the String type inference<br></p><p>var c: ? = &quot;I could become nil&quot;<br></p><p>```<br></p><p>  <br></p><p>But Andrew pointed out that an alternative syntax already exist:<br></p><p>  <br></p><p>```<br></p><p>var a: Optional = &quot;I could become nil&quot;  <br>var b:Optional&amp;lt;String&amp;gt; = &quot;me too&quot;  <br>```<br></p><p>  <br></p><p>And thanks to Erika, another one:<br></p><p>  <br></p><p>```<br></p><p>let c = Optional(&quot;Also me, thanks to Erika&quot;)  <br></p><p>```<br></p><p>  <br></p><p>I think it could still make sense to allow the &quot;?&quot; syntax previously<br>described, as it is more synthetic than the other one and match the Optional<br>usage (with &quot;?&quot;) and could also be completed with a &quot;!&quot; syntax:<br></p><p>  <br></p><p>```<br></p><p>// Optional String with an existing value as a String using inference type<br></p><p>var e:? = &quot;I&#39;m a synthetic version of the above&quot;<br></p><p>// equivalent of<br></p><p>var f: Optional =  &quot;I&#39;m a synthetic version of the above&quot;<br></p><p>  <br></p><p>// Unwrapped Optional with an existing as a String using inference type<br></p><p>var g:! = &quot;I could be nil but will crash if access directly&quot;<br></p><p>// equivalent of<br></p><p>var h:Optional = &quot;I could be nil but will crash if access directly&quot;<br></p><p>```<br></p><p>  <br></p><p>To close (or open for who wants to) this debate, I think Optional have already<br>enough syntax.<br></p><p>  <br></p><p>Hugues<br></p><p>  <br></p><p>On Mar 31 2016, at 4:22 pm, Erica Sadun &amp;lt;erica at ericasadun.com&amp;gt; wrote:  <br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;&gt; On Mar 24, 2016, at 4:22 AM, Hugues Bernet-Rollande via swift-evolution &amp;lt<br>;[swift-evolution at swift.org](mailto:swift-evolution at swift.org)&amp;gt; wrote:<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var a:String? = String()<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; // or<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var b = String() as String?<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; // or<br></p><p>&gt;&gt;<br></p><p>&gt;&gt; var c:Optional&amp;lt;String&amp;gt; = String()  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; ```<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; When I need to force an optional (primarily for sample code) I can do this<br>already:<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; ```<br></p><p>&gt;<br></p><p>&gt; var myOptionalString = Optional(&quot;&quot;)<br></p><p>&gt;<br></p><p>&gt; ```<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; In this example, `myOptionalString ` picks up the type as well as the<br>optionality.<br></p><p>&gt;<br></p><p>&gt; Does this not meet your requirement of &quot;_Allowing to specify only the<br>optionality part of _<br></p><p>&gt;<br></p><p>&gt; _a variable type __while still having the actual wrapped type infered by the<br>assignement_&quot; in existing<br></p><p>&gt;<br></p><p>&gt; Swift?<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; Beyond that, can you offer any compelling use-cases that motivate this<br>change?<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; \-- E<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/e28546ea/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
