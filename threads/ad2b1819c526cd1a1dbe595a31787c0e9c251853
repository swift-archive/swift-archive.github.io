<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  9, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi All,<br></p><p>I’ve started prototyping generic type aliases in master, but we’d like to run this through the evolution process for discussion.  Comments and discussion are welcome.  Here’s the start of the email thread for the actual formal proposal:<br></p><p><br>Introduction<br></p><p>This proposal aims to add generic typealiases to Swift.<br></p><p>Swift-evolution thread: &lt;you are here&gt;<br></p><p>Motivation<br></p><p>Generic typealiases are a somewhat obvious generalization of the existing Swift model for type aliases, which allow you to provide a name for an existing nominal generic type, or to provide a name for a non-nominal type (e.g. tuples, functions, etc) with generic parameters.<br></p><p>Proposed solution<br></p><p>The solution solution is straight-forward: allow type aliases to introduce type parameters, which are in scope for their definition.  This allows one to express things like:<br></p><p>    typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>    typealias IntFunction&lt;T&gt; = (T) -&gt; Int<br>    typealias MatchingTriple&lt;T&gt; = (T, T, T)<br>    typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1)<br></p><p>This is consistent with the rest of Swift’s approach to generics, and slots directly into the model.<br></p><p>Detailed design<br></p><p>This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br></p><p>    typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br></p><p>Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br></p><p>Impact on existing code<br></p><p>This is a new feature, so there is no impact on existing code.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/ad2b1853/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 10, 2016 at 03:00:00pm</p></header><div class="content"><p>+1. It would be handy for:<br></p><p>typealias Vec3&lt;T&gt; = (T, T, T)<br>typealias Mat3x3&lt;T&gt; = (Vec3&lt;T&gt;, Vec3&lt;T&gt;, Vec3&lt;T&gt;)<br></p><p><br>  -- Howard.<br></p><p>On 10 March 2016 at 15:47, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi All,<br>&gt;<br>&gt; I’ve started prototyping generic type aliases in master, but we’d like to<br>&gt; run this through the evolution process for discussion.  Comments and<br>&gt; discussion are welcome.  Here’s the start of the email thread for the<br>&gt; actual formal proposal:<br>&gt;<br>&gt;<br>&gt; *Introduction*<br>&gt;<br>&gt; This proposal aims to add generic typealiases to Swift.<br>&gt;<br>&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt;<br>&gt; *Motivation*<br>&gt;<br>&gt; Generic typealiases are a somewhat obvious generalization of the existing<br>&gt; Swift model for type aliases, which allow you to provide a name for an<br>&gt; existing nominal generic type, or to provide a name for a non-nominal type<br>&gt; (e.g. tuples, functions, etc) with generic parameters.<br>&gt;<br>&gt; *Proposed solution*<br>&gt;<br>&gt; The solution solution is straight-forward: allow type aliases to introduce<br>&gt; type parameters, which are in scope for their definition.  This allows one<br>&gt; to express things like:<br>&gt;<br>&gt;     typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>&gt;     typealias IntFunction&lt;T&gt; = (T) -&gt; Int<br>&gt;     typealias MatchingTriple&lt;T&gt; = (T, T, T)<br>&gt;     typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1)<br>&gt;<br>&gt; This is consistent with the rest of Swift’s approach to generics, and<br>&gt; slots directly into the model.<br>&gt;<br>&gt; *Detailed design*<br>&gt;<br>&gt; This is a minimal proposal for introducing type aliases into Swift, and<br>&gt; intentionally chooses to keep them limited to being “aliases”.  As such,<br>&gt; additional constraints are not allowed in this base proposal, e.g. you<br>&gt; can’t write:<br>&gt;<br>&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String,<br>&gt; T&gt;<br>&gt;<br>&gt; Otherwise, generic type aliases follow the model of type aliases and the<br>&gt; precedent of the other generic declarations in Swift.  For example, they<br>&gt; allow the usual access control features that type aliases support.<br>&gt; Similarly, like non-generic type aliases, generic type aliases cannot be<br>&gt; “resilient”.<br>&gt;<br>&gt; *Impact on existing code*<br>&gt;<br>&gt; This is a new feature, so there is no impact on existing code.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/b5d3a7c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>March 10, 2016 at 01:00:00pm</p></header><div class="content"><p>+1 It looks good to me.<br></p><p>Probably a first step toward something more.<br></p><p>Pierre<br></p><p>&gt; Le 10 mars 2016 à 05:54, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; +1. It would be handy for:<br>&gt; <br>&gt; typealias Vec3&lt;T&gt; = (T, T, T)<br>&gt; typealias Mat3x3&lt;T&gt; = (Vec3&lt;T&gt;, Vec3&lt;T&gt;, Vec3&lt;T&gt;)<br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt;&gt; On 10 March 2016 at 15:47, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi All,<br>&gt;&gt; <br>&gt;&gt; I’ve started prototyping generic type aliases in master, but we’d like to run this through the evolution process for discussion.  Comments and discussion are welcome.  Here’s the start of the email thread for the actual formal proposal:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal aims to add generic typealiases to Swift.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Generic typealiases are a somewhat obvious generalization of the existing Swift model for type aliases, which allow you to provide a name for an existing nominal generic type, or to provide a name for a non-nominal type (e.g. tuples, functions, etc) with generic parameters.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution solution is straight-forward: allow type aliases to introduce type parameters, which are in scope for their definition.  This allows one to express things like:<br>&gt;&gt; <br>&gt;&gt;     typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>&gt;&gt;     typealias IntFunction&lt;T&gt; = (T) -&gt; Int<br>&gt;&gt;     typealias MatchingTriple&lt;T&gt; = (T, T, T)<br>&gt;&gt;     typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1)<br>&gt;&gt; <br>&gt;&gt; This is consistent with the rest of Swift’s approach to generics, and slots directly into the model.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br>&gt;&gt; <br>&gt;&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br>&gt;&gt; <br>&gt;&gt; Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a new feature, so there is no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/c650c452/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 10, 2016 at 07:00:00pm</p></header><div class="content"><p>+1<br>This is very welcome!<br></p><p>-Thorsten <br></p><p>&gt; Am 10.03.2016 um 05:47 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; I’ve started prototyping generic type aliases in master, but we’d like to run this through the evolution process for discussion.  Comments and discussion are welcome.  Here’s the start of the email thread for the actual formal proposal:<br>&gt; <br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal aims to add generic typealiases to Swift.<br>&gt; <br>&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Generic typealiases are a somewhat obvious generalization of the existing Swift model for type aliases, which allow you to provide a name for an existing nominal generic type, or to provide a name for a non-nominal type (e.g. tuples, functions, etc) with generic parameters.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution solution is straight-forward: allow type aliases to introduce type parameters, which are in scope for their definition.  This allows one to express things like:<br>&gt; <br>&gt;     typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>&gt;     typealias IntFunction&lt;T&gt; = (T) -&gt; Int<br>&gt;     typealias MatchingTriple&lt;T&gt; = (T, T, T)<br>&gt;     typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1)<br>&gt; <br>&gt; This is consistent with the rest of Swift’s approach to generics, and slots directly into the model.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br>&gt; <br>&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br>&gt; <br>&gt; Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a new feature, so there is no impact on existing code.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160310/bcc00936/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 8:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br>&gt; <br>&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br>&gt; <br></p><p>What is the rationale for not supporting constraints? Generic type aliases have value without constraints but I can also see a lot of uses for allowing them, especially in some cases where the type constraints are fairly complex and repetitive. It also serves the same self-documenting-code purposes.<br></p><p>In this example it would be nonsense to have a “MatcherFunction” that can’t compare values. Why not express that in the constraint?<br></p><p>    typealias MatcherFunction&lt;T where T : Comparable&gt; = (T, T) -&gt; MatchResult<br></p><p><br></p><p><br>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/30b01ddb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 12:23 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 8:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br>&gt;&gt; <br>&gt;&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br>&gt;&gt; <br>&gt; <br>&gt; What is the rationale for not supporting constraints? Generic type aliases have value without constraints but I can also see a lot of uses for allowing them, especially in some cases where the type constraints are fairly complex and repetitive. It also serves the same self-documenting-code purposes.<br>&gt; <br>&gt; In this example it would be nonsense to have a “MatcherFunction” that can’t compare values. Why not express that in the constraint?<br>&gt; <br>&gt;     typealias MatcherFunction&lt;T where T : Comparable&gt; = (T, T) -&gt; MatchResult<br></p><p>I totally see the value in extending the model to support this.  My rationale for excluding it from the initial proposal is to start with something that is “obvious” to get the feature in, then allow the more controversial pieces to be discussed as independent extensions, which can be motivated by specific use cases as necessary.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/50533ad4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 8:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br>&gt; <br>&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br>&gt; <br>&gt; Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br></p><p>Can we at least infer existing constraints from the aliased type? For example, in something like:<br></p><p>typealias FakeSet&lt;T&gt; = Dictionary&lt;T, ()&gt;<br></p><p>you&#39;d need to propagate the `T: Hashable` constraint from `Dictionary`&#39;s first parameter to the typealias for it to be sound.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/da6d2b8d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 12:39 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 8:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br>&gt;&gt; <br>&gt;&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br>&gt;&gt; <br>&gt;&gt; Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br>&gt; <br>&gt; Can we at least infer existing constraints from the aliased type? For example, in something like:<br>&gt; <br>&gt; typealias FakeSet&lt;T&gt; = Dictionary&lt;T, ()&gt;<br>&gt; <br>&gt; you&#39;d need to propagate the `T: Hashable` constraint from `Dictionary`&#39;s first parameter to the typealias for it to be sound.<br></p><p>Since writing the proposal up (and since discussing it with you), I have come around to disagree with the proposal as I wrote it.  Specifically, I think that constraints of the aliasee *should* be specified in the typealias declaration.  You should be required to write:<br></p><p>	typealias DictionaryOfString&lt;T : Hashable&gt; = Dictionary&lt;T, String&gt;<br></p><p>We shouldn’t infer it the requirement.<br></p><p>Rationale: I see this as analogous (in two ways) to why we don’t infer hashability of T in:<br></p><p>func f&lt;T&gt;(…) {<br>  let x : Dictionary&lt;T, String&gt;<br>}<br></p><p>First, we want the source code for the decl to be obvious and self describing.<br></p><p>Second, this simplifies the type checker, by eliminating the need for it to do global analysis.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/ce685698/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 4:42 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 16, 2016, at 12:39 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 8:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br>&gt;&gt; <br>&gt;&gt; Can we at least infer existing constraints from the aliased type? For example, in something like:<br>&gt;&gt; <br>&gt;&gt; typealias FakeSet&lt;T&gt; = Dictionary&lt;T, ()&gt;<br>&gt;&gt; <br>&gt;&gt; you&#39;d need to propagate the `T: Hashable` constraint from `Dictionary`&#39;s first parameter to the typealias for it to be sound.<br>&gt; <br>&gt; Since writing the proposal up (and since discussing it with you), I have come around to disagree with the proposal as I wrote it.  Specifically, I think that constraints of the aliasee *should* be specified in the typealias declaration.  You should be required to write:<br>&gt; <br>&gt; 	typealias DictionaryOfString&lt;T : Hashable&gt; = Dictionary&lt;T, String&gt;<br>&gt; <br>&gt; We shouldn’t infer it the requirement.<br>&gt; <br>&gt; Rationale: I see this as analogous (in two ways) to why we don’t infer hashability of T in:<br>&gt; <br>&gt; func f&lt;T&gt;(…) {<br>&gt;   let x : Dictionary&lt;T, String&gt;<br>&gt; }<br></p><p>However, we do infer the `T: Hashable` in a case like this:<br></p><p>func foo&lt;T&gt;(x: Dictionary&lt;T, String&gt;) {}<br></p><p>`typealias` feels similar to that to me. It doesn&#39;t have to be a global analysis, just an analysis of the RHS of the typealias.<br></p><p>-Joe<br></p><p>&gt; First, we want the source code for the decl to be obvious and self describing.<br>&gt; <br>&gt; Second, this simplifies the type checker, by eliminating the need for it to do global analysis.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/16490e4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mar 16, 2016, at 4:56 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; We shouldn’t infer it the requirement.<br>&gt;&gt; <br>&gt;&gt; Rationale: I see this as analogous (in two ways) to why we don’t infer hashability of T in:<br>&gt;&gt; <br>&gt;&gt; func f&lt;T&gt;(…) {<br>&gt;&gt;   let x : Dictionary&lt;T, String&gt;<br>&gt;&gt; }<br>&gt; <br>&gt; However, we do infer the `T: Hashable` in a case like this:<br>&gt; <br>&gt; func foo&lt;T&gt;(x: Dictionary&lt;T, String&gt;) {}<br>&gt; <br>&gt; `typealias` feels similar to that to me. It doesn&#39;t have to be a global analysis, just an analysis of the RHS of the typealias.<br></p><p>I consider the RHS of the typealias to be the “body” of the type alias, and parameters to be part of the “signature” of the funcdecl.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/838a3b07/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; However, we do infer the `T: Hashable` in a case like this:<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T&gt;(x: Dictionary&lt;T, String&gt;) {}<br>&gt;&gt; <br>&gt;&gt; `typealias` feels similar to that to me. It doesn&#39;t have to be a global analysis, just an analysis of the RHS of the typealias.<br>&gt; <br>&gt; I consider the RHS of the typealias to be the “body” of the type alias, and parameters to be part of the “signature” of the funcdecl.<br></p><p>The RHS of a stored variable declaration is essentially its body, but we infer types across that boundary. (Granted, not generic constraints since variables can&#39;t be generic yet.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 5:02 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Mar 16, 2016, at 4:56 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; We shouldn’t infer it the requirement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rationale: I see this as analogous (in two ways) to why we don’t infer hashability of T in:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f&lt;T&gt;(…) {<br>&gt;&gt;&gt;   let x : Dictionary&lt;T, String&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, we do infer the `T: Hashable` in a case like this:<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T&gt;(x: Dictionary&lt;T, String&gt;) {}<br>&gt;&gt; <br>&gt;&gt; `typealias` feels similar to that to me. It doesn&#39;t have to be a global analysis, just an analysis of the RHS of the typealias.<br>&gt; <br>&gt; I consider the RHS of the typealias to be the “body” of the type alias, and parameters to be part of the “signature” of the funcdecl.<br></p><p>I&#39;m OK starting with the base design that constraints have to be explicit. My gut tells me though that `typealias` is close enough syntactically to `var` that many people will expect the inference to occur, but we can always add it later.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/2467fb46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>March 17, 2016 at 05:00:00pm</p></header><div class="content"><p>Big +1 on this proposal from me.<br></p><p>Does this proposal allow a protocol can have generic associated types?<br></p><p>   - associatedtype Something&lt;T&gt;<br>   - associatedtype Something&lt;T: Hashable&gt;<br></p><p>It&#39;s not mentioned, but I think it would be necessary at some point for<br>completeness.<br></p><p><br>On Thu, Mar 17, 2016 at 2:32 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 16, 2016, at 5:02 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt; On Mar 16, 2016, at 4:56 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt; We shouldn’t infer it the requirement.<br>&gt;<br>&gt; Rationale: I see this as analogous (in two ways) to why we don’t infer<br>&gt; hashability of T in:<br>&gt;<br>&gt; func f&lt;T&gt;(…) {<br>&gt;   let x : Dictionary&lt;T, String&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; However, we do infer the `T: Hashable` in a case like this:<br>&gt;<br>&gt; func foo&lt;T&gt;(x: Dictionary&lt;T, String&gt;) {}<br>&gt;<br>&gt; `typealias` feels similar to that to me. It doesn&#39;t have to be a global<br>&gt; analysis, just an analysis of the RHS of the typealias.<br>&gt;<br>&gt;<br>&gt; I consider the RHS of the typealias to be the “body” of the type alias,<br>&gt; and parameters to be part of the “signature” of the funcdecl.<br>&gt;<br>&gt;<br>&gt; I&#39;m OK starting with the base design that constraints have to be explicit.<br>&gt; My gut tells me though that `typealias` is close enough syntactically to<br>&gt; `var` that many people will expect the inference to occur, but we can<br>&gt; always add it later.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160317/68018d27/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March 16, 2016 at 04:00:00pm</p></header><div class="content"><p>I would love to have this feature.<br></p><p>I&#39;ve tried to do this before in Swift, assuming it was supported. I&#39;m sure I&#39;m not the only one.<br></p><p><br></p><p>&gt; On Mar 9, 2016, at 11:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; I’ve started prototyping generic type aliases in master, but we’d like to run this through the evolution process for discussion.  Comments and discussion are welcome.  Here’s the start of the email thread for the actual formal proposal:<br>&gt; <br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal aims to add generic typealiases to Swift.<br>&gt; <br>&gt; Swift-evolution thread: &lt;you are here&gt;<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Generic typealiases are a somewhat obvious generalization of the existing Swift model for type aliases, which allow you to provide a name for an existing nominal generic type, or to provide a name for a non-nominal type (e.g. tuples, functions, etc) with generic parameters.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution solution is straight-forward: allow type aliases to introduce type parameters, which are in scope for their definition.  This allows one to express things like:<br>&gt; <br>&gt;     typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>&gt;     typealias IntFunction&lt;T&gt; = (T) -&gt; Int<br>&gt;     typealias MatchingTriple&lt;T&gt; = (T, T, T)<br>&gt;     typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1)<br>&gt; <br>&gt; This is consistent with the rest of Swift’s approach to generics, and slots directly into the model.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br>&gt; <br>&gt;     typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br>&gt; <br>&gt; Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a new feature, so there is no impact on existing code.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/26b2c64e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>March 21, 2016 at 11:00:00am</p></header><div class="content"><p>Will this feature allow something like this?<br></p><p>```swift<br>protocol SomeProtocol: class { /* some functions here */ }<br>typealias ProtoView&lt;T: UIView where T: SomeProtocol&gt; = T<br>```<br></p><p>I recently came across a design issue where I needed this type to be global instead of the generic top level of a class:<br>```swift<br>class A&lt;T: UIView where T: SomeProtocol&gt; { /*...*/ }<br>```<br></p><p>I couldn’t do something like this in my project and was forced to extend UIView with some kind of an extra backdoor protocol.  <br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. März 2016 bei 05:47:50, Chris Lattner via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Hi All,<br></p><p>I’ve started prototyping generic type aliases in master, but we’d like to run this through the evolution process for discussion.  Comments and discussion are welcome.  Here’s the start of the email thread for the actual formal proposal:<br></p><p><br>Introduction<br></p><p>This proposal aims to add generic typealiases to Swift.<br></p><p>Swift-evolution thread: &lt;you are here&gt;<br></p><p>Motivation<br></p><p>Generic typealiases are a somewhat obvious generalization of the existing Swift model for type aliases, which allow you to provide a name for an existing nominal generic type, or to provide a name for a non-nominal type (e.g. tuples, functions, etc) with generic parameters.<br></p><p>Proposed solution<br></p><p>The solution solution is straight-forward: allow type aliases to introduce type parameters, which are in scope for their definition.  This allows one to express things like:<br></p><p>    typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>    typealias IntFunction&lt;T&gt; = (T) -&gt; Int<br>    typealias MatchingTriple&lt;T&gt; = (T, T, T)<br>    typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1)<br></p><p>This is consistent with the rest of Swift’s approach to generics, and slots directly into the model.<br></p><p>Detailed design<br></p><p>This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br></p><p>    typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br></p><p>Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br></p><p>Impact on existing code<br></p><p>This is a new feature, so there is no impact on existing code.<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160321/07f855d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[proposal] Generic type aliases</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>March 21, 2016 at 08:00:00pm</p></header><div class="content"><p>Ok I read all the previous posts and I’m totally fine with this feature as it’s mentioned in its base form. Looking forward to see generic typealias allowing type constraints.<br></p><p>There is one thing still on my mind: how do we use a generic typealias?<br></p><p>typealias SomeTuple&lt;T&gt; = (T, T)<br></p><p>func foo&lt;U&gt;(tuple: SomeTuple&lt;U&gt;) { /*…*/ }<br></p><p>or only for Ints<br></p><p>func foo(tuple: SomeTuple&lt;Int&gt;) { /*…*/ }<br></p><p>What about global generic typealias?<br></p><p>class Boo&lt;T&gt; {<br></p><p>	var tuple: SomeTuple&lt;T&gt;<br></p><p>	init(tuple: SomeTuple&lt;T&gt;) {<br></p><p>		self.tuple = tuple // what is T here?<br>	}<br>}<br></p><p>Lets say generic typealias already has the possibility to specify type constraints at this point.<br>Here is a quick minimal sample code where I would want to use a global generic typealias and keep the class as non-generic:<br></p><p>```swift<br></p><p>protocol ChildProtocol: class {<br>	func foo()<br>}<br></p><p>protocol Delegate: class {<br>	// easy to use because MyClass is non-generic<br>	func parentDidSomething(class: ParentClass)<br>}<br></p><p>// for any type <br>// typealias ViewWithProtocol&lt;T: ChildProtocol&gt; = T<br></p><p>// or better allowing only UIView as base class + ChildProtocol<br>typealias ViewWithProtocol&lt;T: UIView where T: ChildProtocol&gt; = T<br></p><p>class ParentClass {<br></p><p>	var delegate: MyDelegate?<br></p><p>	var child: ViewWithProtocol&lt;UIView&gt; // any UIView that extends with ChildProtocol can be stored here<br>		<br>	init(child: ViewWithProtocol&lt;UIView&gt;) {<br>			<br>		self.child = child<br>		self.doSomeWork()<br>	}<br></p><p>	// it’s easy to access the property<br>	func doSomeWork() {<br>			<br>		self.child.foo()<br>		self.child.tag = 42 // since it’s a UIView which has the `tag` property<br>	}<br>}<br>```<br></p><p>One additional cool feature of generic typealias would be the possibility to access default implementation functions which are not specified inside the protocol body itself:<br></p><p>```swift<br></p><p>protocol SomeProtocol {}<br></p><p>extension SomeProtocol where Self: BaseClass {<br>		<br>	func print(text: String) {<br>		print(text)<br>	}<br>}<br></p><p>class BaseClass {}<br>class SubClass: BaseClass {<br>		<br>	var text = &quot;hello world&quot;<br>}<br></p><p>typealias BaseClassWithProtocol&lt;T: BaseClass where T: SomeProtocol&gt; = T<br></p><p>func printSomethingWith(instance: BaseClassWithProtocol&lt;SubClass&gt;) {<br></p><p>	instance.print(instance.text) // should print &quot;hello world&quot;<br>}<br>```<br></p><p>+1 for this feature<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 21. März 2016 bei 11:16:06, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Will this feature allow something like this?<br></p><p>```swift<br>protocol SomeProtocol: class { /* some functions here */ }<br>typealias ProtoView&lt;T: UIView where T: SomeProtocol&gt; = T<br>```<br></p><p>I recently came across a design issue where I needed this type to be global instead of the generic top level of a class:<br>```swift<br>class A&lt;T: UIView where T: SomeProtocol&gt; { /*...*/ }<br>```<br></p><p>I couldn’t do something like this in my project and was forced to extend UIView with some kind of an extra backdoor protocol.  <br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. März 2016 bei 05:47:50, Chris Lattner via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Hi All,<br></p><p>I’ve started prototyping generic type aliases in master, but we’d like to run this through the evolution process for discussion.  Comments and discussion are welcome.  Here’s the start of the email thread for the actual formal proposal:<br></p><p><br>Introduction<br></p><p>This proposal aims to add generic typealiases to Swift.<br></p><p>Swift-evolution thread: &lt;you are here&gt;<br></p><p>Motivation<br></p><p>Generic typealiases are a somewhat obvious generalization of the existing Swift model for type aliases, which allow you to provide a name for an existing nominal generic type, or to provide a name for a non-nominal type (e.g. tuples, functions, etc) with generic parameters.<br></p><p>Proposed solution<br></p><p>The solution solution is straight-forward: allow type aliases to introduce type parameters, which are in scope for their definition.  This allows one to express things like:<br></p><p>    typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>    typealias IntFunction&lt;T&gt; = (T) -&gt; Int<br>    typealias MatchingTriple&lt;T&gt; = (T, T, T)<br>    typealias BackwardTriple&lt;T1,T2,T3&gt; = (T3, T2, T1)<br></p><p>This is consistent with the rest of Swift’s approach to generics, and slots directly into the model.<br></p><p>Detailed design<br></p><p>This is a minimal proposal for introducing type aliases into Swift, and intentionally chooses to keep them limited to being “aliases”.  As such, additional constraints are not allowed in this base proposal, e.g. you can’t write:<br></p><p>    typealias StringDictionary&lt;T where T : Hashable&gt; = Dictionary&lt;String, T&gt;<br></p><p>Otherwise, generic type aliases follow the model of type aliases and the precedent of the other generic declarations in Swift.  For example, they allow the usual access control features that type aliases support.  Similarly, like non-generic type aliases, generic type aliases cannot be “resilient”.<br></p><p>Impact on existing code<br></p><p>This is a new feature, so there is no impact on existing code.<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160321/64672d57/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
