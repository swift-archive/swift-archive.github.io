<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Feb 03 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; After reading these guidelines and seeing the responses I am glad to<br>&gt; see some consideration given to argument labeling.<br>&gt;<br>&gt; After thinking it over, I think the rules *I* would like to see can be<br>&gt; expressed very straightforwardly much more can be made much A minor<br>&gt; point, but I think it’s important to distinguish between<br>&gt; single-argument functions and multi-argument functions; doing so seems<br>&gt; to simplify the rules (even if there are more of them).<br></p><p>I imagine that probably leaves you with very odd results for functions of<br>the form<br></p><p>    a.doThisTo(that, options: [ .animated ], backwards: true)<br></p><p>beecause this method is effectively a single-argument method with some<br>auxilliary information.<br></p><p>Okay, this is pretty big.  I&#39;ll have to come back to it, but for now let<br>me leave you with a thought and a question:<br></p><p>1. Anything that takes this much explanation to describe is too big for<br>   the guidelines.  If it can be condensed (a lot) it might be made to<br>   work.<br></p><p>2. Does this actually produce different results than the guidelines I<br>   have suggested?<br></p><p>Thanks,<br>Dave<br></p><p>&gt; Everything that follows is my preferences, but I generally agree with<br>&gt; Erica’s suggestions in the concrete cases. I also think the emphasis<br>&gt; on quasi-grammatical rules-and-roles is something of a dead-end for<br>&gt; design guidelines and won’t include such considerations in what<br>&gt; follows.<br>&gt;<br>&gt; ## RULES<br>&gt;<br>&gt; ### I. Single-Argument Functions:<br>&gt;<br>&gt; #### RULES:<br>&gt;<br>&gt; - general rule: don’t label the first argument<br>&gt; - exceptions:<br>&gt;   - (a) the argument has a default value (`removeAll(keepCapacity: Bool = default)`)<br>&gt;   - (b) the function acts-like a constructor (covered in your rule 2)<br>&gt;   - (c) the “ecosystem rule” (see section III)<br>&gt;   - (d) the semantics of the argument are non-obvious (see below)<br>&gt;<br>&gt; #### REMARKS:<br>&gt;<br>&gt; I’m not sure (d) actually exists, though; every concrete example I can<br>&gt; think up either falls under rule (b) or rule (c). It may not actually<br>&gt; need to be a rule (other than as, perhaps, the underlying motivation<br>&gt; for rules (b) and (c)).<br>&gt;<br>&gt; My intent with (d) was to address a similar concern as in Erica’s<br>&gt; `init(truncating …)` and `init(saturating …)`: “if a reasonable reader<br>&gt; would be unclear which of N plausible implementation choices you are<br>&gt; making, you may wish to label the argument, even if you only have a<br>&gt; single such function”…but, again, it’s hard to find any examples for<br>&gt; (d) that aren’t also some mixture of (b) and/or (c).<br>&gt;<br>&gt; ### II. Multi-Argument Functions:<br>&gt;<br>&gt; #### RULES:<br>&gt;<br>&gt; - general rule: label all arguments<br>&gt; - exceptions:<br>&gt;   - (a) omit the first label whenever the first argument is the<br>&gt; semantic focus, and the other arguments are some mix of “details,<br>&gt; adjustments, or modifiers”<br>&gt;   - (b) omit labels entirely whenever argument-ordering is irrelevant to the output (see below)<br>&gt;<br>&gt; #### REMARKS:<br>&gt;<br>&gt; For (a), the assumption is that we have a general consensus that “in<br>&gt; methods for which one of the arguments is the semantic focus, that<br>&gt; argument should be the first argument”; this seems pretty widely<br>&gt; followed.<br>&gt;<br>&gt; This rule seems to cover e.g. `addObserver(_:forKeyPath:)` and<br>&gt; `addObserver(_:selector:name:object:)` and `encodeObject(_:forKey:)`<br>&gt; and `present(_:animated:completion:)` (née<br>&gt; `presentViewController(_:animated:completion:)`), and so on.<br>&gt;<br>&gt; A point to bring up is that under these rules, the “evolution” of a<br>&gt; name would be different: the just-so story for how<br>&gt; `addObserver(_:forKeyPath:)` came to be so-called is that it *began*<br>&gt; as `add(observer:forKeyPath:)`, but b/c the `observer` argument is the<br>&gt; semantic focus it &quot;made sense to move `observer` into the method<br>&gt; name”; that is, the assumption is that functions like<br>&gt; `addObserver(_:forKeyPath:)` are considered to be exceptions to the<br>&gt; &quot;base convention” and need to be justified.<br>&gt;<br>&gt; Also note that &quot;counter-examples&quot; to rule (a) are anything for which<br>&gt; no one argument is easily-identifiable as the semantic focus.<br>&gt;<br>&gt; EG, in a function like:<br>&gt; `adjudicate(plaintiff:defendant:circumstances:)` we can colorably<br>&gt; claim `circumstances` is a modifier-type parameter, but we don’t—and<br>&gt; shouldn’t!—treat either `plaintiff` or `defendant` as the<br>&gt; semantic-focus. If you have two focuses then you have no focus, as it<br>&gt; were.<br>&gt;<br>&gt; For (b), the intuition is that whenever argument-order is irrelevant,<br>&gt; arguments should be unlabelled; thus e.g.:<br>&gt;<br>&gt; - min/max: don’t label the arguments<br>&gt; - hypot: don’t label the arguments<br>&gt; - copysign: ideally, label the arguments<br>&gt; - atan2: ideally, label the arguments<br>&gt;<br>&gt; …and so on. Note that these examples are all &quot;free functions”; there<br>&gt; don’t seem to be many natural examples that *aren’t* free<br>&gt; functions. Also, please don’t be mislead by your familiarity with<br>&gt; e.g. `copysign` and/or `atan2`; they are used here to illustrate a<br>&gt; general principle (argument-ordering) only, but in practice such<br>&gt; highly-familiar “legacy functions” might be best-off given<br>&gt; special-case handling.<br>&gt;<br>&gt; ### III. Naming Functions/Ecosystem Rule<br>&gt;<br>&gt; The previous sections essentially assumed the function names are<br>&gt; already-chosen (in line with existing conventions) and voice specific<br>&gt; argument-labeling preferences.<br>&gt;<br>&gt; This section deals with a few changes to how function names should be chosen.<br>&gt;<br>&gt; The over-arching consideration is what I’ve been calling the<br>&gt; “Ecosystem rule”: whenever a method a member of a “method family&quot;—or<br>&gt; could foreseeably become a member of such—one should aim for<br>&gt; consistency in the base name, and use argument-labels as necessary;<br>&gt; note that method families need not *require* argument labels:<br>&gt;<br>&gt; `contains(_: Point)`<br>&gt; `contains(_: Line)`<br>&gt; `contains(_: Shape)`<br>&gt;<br>&gt; …but they *may* require them, as for example in the `login` function<br>&gt; that has already been discussed.<br>&gt;<br>&gt; The “ecosystem-rule&quot; can also be applied somewhat more-broadly;<br>&gt; consider the following name suggestions:<br>&gt;<br>&gt; `animate(duration:animations:)`<br>&gt; `animate(duration:animations:completion:)`<br>&gt; `animate(duration:delay:options:animations:completion:)`<br>&gt; `animateUsingKeyFrames(duration:delay:options:animations:completion:)`<br>&gt; `animateUsingSpring(duration:delay:damping:initialVelocity:options:animations:completion:)`<br>&gt;<br>&gt; …where the first three form an obvious family, and the next two are<br>&gt; obvious “cousins” of that family due to choice of base names.<br>&gt;<br>&gt; A corollary of this policy is that the rule (3) suggestion—of omitting<br>&gt; something like `…ForIdentifier...` or `(forIdentifier:…)`—will<br>&gt; sometimes be overruled out of ecosystem concerns, but I suspect this<br>&gt; will be somewhat rare in practice.<br>&gt;<br>&gt; For example, consider the following naming suggestions for the “tracks” example:<br>&gt;<br>&gt; // solo method (not part of any family)<br>&gt; asset.trackWith(trackID)<br>&gt;<br>&gt; // family<br>&gt; asset.allTracksWith(mediaCharacteristic: …)<br>&gt; asset.allTracksWith(mediaType: ...<br>&gt;<br>&gt; // the below, instead of `trackWith` or `track(<br>&gt; asset.firstTrackWith(mediaCharacteristic: ...)<br>&gt; asset.firstTrackWith(mediaType: …)<br>&gt;<br>&gt; …or the same again, but perhaps dropping the `With` if that’s the overall preference.<br>&gt;<br>&gt; In any case, the overall goal behind the &quot;ecosystem rule” is that<br>&gt; similar things should be named similarly, and when semantic<br>&gt; differences are small-enough it makes sense to use argument labels to<br>&gt; make distinctions; different base names should be for functions that<br>&gt; are at least a little different from each other.<br>&gt;<br>&gt; ## GENERAL REMARKS<br>&gt;<br>&gt; Note that with the way I’ve tried to formulate these rules the Swift<br>&gt; standard library should largely stay as-is. In particular:<br>&gt;<br>&gt; - methods without an identifiable “semantic focus” seem rare in a<br>&gt; standard-library context; IMHO they occur naturally, but only really<br>&gt; within UI/application-level code, not “basic building blocks” code<br>&gt; - &quot;method families” seem somewhat unnatural in “Swift-y” code outside<br>&gt; of a small number of special-case scenarios (`contains`, various<br>&gt; `init` families, etc.); they seem more common in UI/application-level<br>&gt; code (e.g. for Objective-C interoperation), as default arguments cover<br>&gt; most of the motivating use-cases<br>&gt;<br>&gt; …and most of the intent in these rules is to free up some room in the<br>&gt; guidelines so that application-level code can be written to the<br>&gt; guidelines without going through bizarre contortions (e.g. no one<br>&gt; would ever have *chosen* `func<br>&gt; dismissViewControllerAnimated(_:completion:)`, and we shouldn’t have<br>&gt; to chose between either (a) using equally-awkward constructs in our<br>&gt; own code or (b) being “non-guideline-compliant”).<br>&gt;<br>&gt; ## REMARKS ON RULE 3<br>&gt;<br>&gt; Separately, I think rule 3 is a hair too coarse to be a good guideline as-stated.<br>&gt;<br>&gt; I would split the “asking for X by name/identifier/etc.” into two cases:<br>&gt;<br>&gt; - (a) asking for X by some well-known/canonical $ID (e.g., such that<br>&gt; it is a *major* error if no X is found for $ID)<br>&gt; - (b) asking for X by some identifier (without a strong expectation as<br>&gt; to whether or not such an X will or won’t be found)<br>&gt;<br>&gt; …and at least as a code-reader:<br>&gt;<br>&gt; - I have no objection to the proposed rule (3) in scenario (a)<br>&gt; - I find rule (3) very odd in scenario (b)<br>&gt; - I think very differently about scenario (a) and scenario (b), and<br>&gt; would thus prefer that they look different<br>&gt;<br>&gt; …and that’s my thoughts, here.<br>&gt;<br>&gt;&gt; On Feb 2, 2016, at 6:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt; guidelines that:<br>&gt;&gt; <br>&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt; * are understandable by humans<br>&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt; <br>&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;   beginning in the base name and describing the primary semantics of<br>&gt;&gt;   the call, it gets no argument label:<br>&gt;&gt; <br>&gt;&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt; <br>&gt;&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;&gt;                            // thus we add a label for b.<br>&gt;&gt; <br>&gt;&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;                              // but doesn&#39;t describe the primary <br>&gt;&gt;                              // semantics, which are to move in both<br>&gt;&gt;                              // x and y.  Thus, x gets a label.<br>&gt;&gt; <br>&gt;&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;                              // the primary semantics, so u gets no<br>&gt;&gt;                              // label. b is an<br>&gt;&gt;                              // option that tunes the primary<br>&gt;&gt;                              // semantics<br>&gt;&gt; <br>&gt;&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;&gt;   conversions and indistinguishable peers]<br>&gt;&gt; <br>&gt;&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;   first argument, we skip it in considering this criterion:<br>&gt;&gt; <br>&gt;&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;                       // making this determination.<br>&gt;&gt; <br>&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;  universally-understood term.<br>&gt;&gt; <br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;   should go in the base name rather than in a label:<br>&gt;&gt; <br>&gt;&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt; <br>&gt;&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; <br>&gt;&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;   ambiguous]<br>&gt;&gt; <br>&gt;&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;&gt;   initializers):<br>&gt;&gt; <br>&gt;&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt; <br>&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;   describe it in the base name.<br>&gt;&gt; <br>&gt;&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt; <br>&gt;&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February  3, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 5:02 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Feb 03 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; After reading these guidelines and seeing the responses I am glad to<br>&gt;&gt; see some consideration given to argument labeling.<br>&gt;&gt; <br>&gt;&gt; After thinking it over, I think the rules *I* would like to see can be<br>&gt;&gt; expressed very straightforwardly much more can be made much A minor<br>&gt;&gt; point, but I think it’s important to distinguish between<br>&gt;&gt; single-argument functions and multi-argument functions; doing so seems<br>&gt;&gt; to simplify the rules (even if there are more of them).<br>&gt; <br>&gt; I imagine that probably leaves you with very odd results for functions of<br>&gt; the form<br>&gt; <br>&gt;    a.doThisTo(that, options: [ .animated ], backwards: true)<br>&gt; <br>&gt; beecause this method is effectively a single-argument method with some<br>&gt; auxilliary information.<br></p><p>This is a multi-argument function and is addressed in the multi-argument section.<br></p><p>&gt; <br>&gt; Okay, this is pretty big.  I&#39;ll have to come back to it, but for now let<br>&gt; me leave you with a thought and a question:<br>&gt; <br>&gt; 1. Anything that takes this much explanation to describe is too big for<br>&gt;   the guidelines.  If it can be condensed (a lot) it might be made to<br>&gt;   work.<br></p><p>The proposed rules are short (and stated tersely). There’s probably a way to expand them into a 1-2 sentence/each that doesn’t need as much explanation.<br></p><p>&gt; <br>&gt; 2. Does this actually produce different results than the guidelines I<br>&gt;   have suggested?<br></p><p>On “Swift-stdlib” code I don’t think it gets different results.<br></p><p>On application code it falls in the camp that wants e.g. tracksWith(mediaCharacteristic...) and tracksWith(mediaType…), rather than `tracksWithMediaCharacteristic(...` and `tracksWithMediaType(…`.<br></p><p>Other than that, it tries to avoid any reference to grammatical rules in its formulation.<br></p><p>&gt; <br>&gt; Thanks,<br>&gt; Dave<br>&gt; <br>&gt;&gt; Everything that follows is my preferences, but I generally agree with<br>&gt;&gt; Erica’s suggestions in the concrete cases. I also think the emphasis<br>&gt;&gt; on quasi-grammatical rules-and-roles is something of a dead-end for<br>&gt;&gt; design guidelines and won’t include such considerations in what<br>&gt;&gt; follows.<br>&gt;&gt; <br>&gt;&gt; ## RULES<br>&gt;&gt; <br>&gt;&gt; ### I. Single-Argument Functions:<br>&gt;&gt; <br>&gt;&gt; #### RULES:<br>&gt;&gt; <br>&gt;&gt; - general rule: don’t label the first argument<br>&gt;&gt; - exceptions:<br>&gt;&gt;  - (a) the argument has a default value (`removeAll(keepCapacity: Bool = default)`)<br>&gt;&gt;  - (b) the function acts-like a constructor (covered in your rule 2)<br>&gt;&gt;  - (c) the “ecosystem rule” (see section III)<br>&gt;&gt;  - (d) the semantics of the argument are non-obvious (see below)<br>&gt;&gt; <br>&gt;&gt; #### REMARKS:<br>&gt;&gt; <br>&gt;&gt; I’m not sure (d) actually exists, though; every concrete example I can<br>&gt;&gt; think up either falls under rule (b) or rule (c). It may not actually<br>&gt;&gt; need to be a rule (other than as, perhaps, the underlying motivation<br>&gt;&gt; for rules (b) and (c)).<br>&gt;&gt; <br>&gt;&gt; My intent with (d) was to address a similar concern as in Erica’s<br>&gt;&gt; `init(truncating …)` and `init(saturating …)`: “if a reasonable reader<br>&gt;&gt; would be unclear which of N plausible implementation choices you are<br>&gt;&gt; making, you may wish to label the argument, even if you only have a<br>&gt;&gt; single such function”…but, again, it’s hard to find any examples for<br>&gt;&gt; (d) that aren’t also some mixture of (b) and/or (c).<br>&gt;&gt; <br>&gt;&gt; ### II. Multi-Argument Functions:<br>&gt;&gt; <br>&gt;&gt; #### RULES:<br>&gt;&gt; <br>&gt;&gt; - general rule: label all arguments<br>&gt;&gt; - exceptions:<br>&gt;&gt;  - (a) omit the first label whenever the first argument is the<br>&gt;&gt; semantic focus, and the other arguments are some mix of “details,<br>&gt;&gt; adjustments, or modifiers”<br>&gt;&gt;  - (b) omit labels entirely whenever argument-ordering is irrelevant to the output (see below)<br>&gt;&gt; <br>&gt;&gt; #### REMARKS:<br>&gt;&gt; <br>&gt;&gt; For (a), the assumption is that we have a general consensus that “in<br>&gt;&gt; methods for which one of the arguments is the semantic focus, that<br>&gt;&gt; argument should be the first argument”; this seems pretty widely<br>&gt;&gt; followed.<br>&gt;&gt; <br>&gt;&gt; This rule seems to cover e.g. `addObserver(_:forKeyPath:)` and<br>&gt;&gt; `addObserver(_:selector:name:object:)` and `encodeObject(_:forKey:)`<br>&gt;&gt; and `present(_:animated:completion:)` (née<br>&gt;&gt; `presentViewController(_:animated:completion:)`), and so on.<br>&gt;&gt; <br>&gt;&gt; A point to bring up is that under these rules, the “evolution” of a<br>&gt;&gt; name would be different: the just-so story for how<br>&gt;&gt; `addObserver(_:forKeyPath:)` came to be so-called is that it *began*<br>&gt;&gt; as `add(observer:forKeyPath:)`, but b/c the `observer` argument is the<br>&gt;&gt; semantic focus it &quot;made sense to move `observer` into the method<br>&gt;&gt; name”; that is, the assumption is that functions like<br>&gt;&gt; `addObserver(_:forKeyPath:)` are considered to be exceptions to the<br>&gt;&gt; &quot;base convention” and need to be justified.<br>&gt;&gt; <br>&gt;&gt; Also note that &quot;counter-examples&quot; to rule (a) are anything for which<br>&gt;&gt; no one argument is easily-identifiable as the semantic focus.<br>&gt;&gt; <br>&gt;&gt; EG, in a function like:<br>&gt;&gt; `adjudicate(plaintiff:defendant:circumstances:)` we can colorably<br>&gt;&gt; claim `circumstances` is a modifier-type parameter, but we don’t—and<br>&gt;&gt; shouldn’t!—treat either `plaintiff` or `defendant` as the<br>&gt;&gt; semantic-focus. If you have two focuses then you have no focus, as it<br>&gt;&gt; were.<br>&gt;&gt; <br>&gt;&gt; For (b), the intuition is that whenever argument-order is irrelevant,<br>&gt;&gt; arguments should be unlabelled; thus e.g.:<br>&gt;&gt; <br>&gt;&gt; - min/max: don’t label the arguments<br>&gt;&gt; - hypot: don’t label the arguments<br>&gt;&gt; - copysign: ideally, label the arguments<br>&gt;&gt; - atan2: ideally, label the arguments<br>&gt;&gt; <br>&gt;&gt; …and so on. Note that these examples are all &quot;free functions”; there<br>&gt;&gt; don’t seem to be many natural examples that *aren’t* free<br>&gt;&gt; functions. Also, please don’t be mislead by your familiarity with<br>&gt;&gt; e.g. `copysign` and/or `atan2`; they are used here to illustrate a<br>&gt;&gt; general principle (argument-ordering) only, but in practice such<br>&gt;&gt; highly-familiar “legacy functions” might be best-off given<br>&gt;&gt; special-case handling.<br>&gt;&gt; <br>&gt;&gt; ### III. Naming Functions/Ecosystem Rule<br>&gt;&gt; <br>&gt;&gt; The previous sections essentially assumed the function names are<br>&gt;&gt; already-chosen (in line with existing conventions) and voice specific<br>&gt;&gt; argument-labeling preferences.<br>&gt;&gt; <br>&gt;&gt; This section deals with a few changes to how function names should be chosen.<br>&gt;&gt; <br>&gt;&gt; The over-arching consideration is what I’ve been calling the<br>&gt;&gt; “Ecosystem rule”: whenever a method a member of a “method family&quot;—or<br>&gt;&gt; could foreseeably become a member of such—one should aim for<br>&gt;&gt; consistency in the base name, and use argument-labels as necessary;<br>&gt;&gt; note that method families need not *require* argument labels:<br>&gt;&gt; <br>&gt;&gt; `contains(_: Point)`<br>&gt;&gt; `contains(_: Line)`<br>&gt;&gt; `contains(_: Shape)`<br>&gt;&gt; <br>&gt;&gt; …but they *may* require them, as for example in the `login` function<br>&gt;&gt; that has already been discussed.<br>&gt;&gt; <br>&gt;&gt; The “ecosystem-rule&quot; can also be applied somewhat more-broadly;<br>&gt;&gt; consider the following name suggestions:<br>&gt;&gt; <br>&gt;&gt; `animate(duration:animations:)`<br>&gt;&gt; `animate(duration:animations:completion:)`<br>&gt;&gt; `animate(duration:delay:options:animations:completion:)`<br>&gt;&gt; `animateUsingKeyFrames(duration:delay:options:animations:completion:)`<br>&gt;&gt; `animateUsingSpring(duration:delay:damping:initialVelocity:options:animations:completion:)`<br>&gt;&gt; <br>&gt;&gt; …where the first three form an obvious family, and the next two are<br>&gt;&gt; obvious “cousins” of that family due to choice of base names.<br>&gt;&gt; <br>&gt;&gt; A corollary of this policy is that the rule (3) suggestion—of omitting<br>&gt;&gt; something like `…ForIdentifier...` or `(forIdentifier:…)`—will<br>&gt;&gt; sometimes be overruled out of ecosystem concerns, but I suspect this<br>&gt;&gt; will be somewhat rare in practice.<br>&gt;&gt; <br>&gt;&gt; For example, consider the following naming suggestions for the “tracks” example:<br>&gt;&gt; <br>&gt;&gt; // solo method (not part of any family)<br>&gt;&gt; asset.trackWith(trackID)<br>&gt;&gt; <br>&gt;&gt; // family<br>&gt;&gt; asset.allTracksWith(mediaCharacteristic: …)<br>&gt;&gt; asset.allTracksWith(mediaType: ...<br>&gt;&gt; <br>&gt;&gt; // the below, instead of `trackWith` or `track(<br>&gt;&gt; asset.firstTrackWith(mediaCharacteristic: ...)<br>&gt;&gt; asset.firstTrackWith(mediaType: …)<br>&gt;&gt; <br>&gt;&gt; …or the same again, but perhaps dropping the `With` if that’s the overall preference.<br>&gt;&gt; <br>&gt;&gt; In any case, the overall goal behind the &quot;ecosystem rule” is that<br>&gt;&gt; similar things should be named similarly, and when semantic<br>&gt;&gt; differences are small-enough it makes sense to use argument labels to<br>&gt;&gt; make distinctions; different base names should be for functions that<br>&gt;&gt; are at least a little different from each other.<br>&gt;&gt; <br>&gt;&gt; ## GENERAL REMARKS<br>&gt;&gt; <br>&gt;&gt; Note that with the way I’ve tried to formulate these rules the Swift<br>&gt;&gt; standard library should largely stay as-is. In particular:<br>&gt;&gt; <br>&gt;&gt; - methods without an identifiable “semantic focus” seem rare in a<br>&gt;&gt; standard-library context; IMHO they occur naturally, but only really<br>&gt;&gt; within UI/application-level code, not “basic building blocks” code<br>&gt;&gt; - &quot;method families” seem somewhat unnatural in “Swift-y” code outside<br>&gt;&gt; of a small number of special-case scenarios (`contains`, various<br>&gt;&gt; `init` families, etc.); they seem more common in UI/application-level<br>&gt;&gt; code (e.g. for Objective-C interoperation), as default arguments cover<br>&gt;&gt; most of the motivating use-cases<br>&gt;&gt; <br>&gt;&gt; …and most of the intent in these rules is to free up some room in the<br>&gt;&gt; guidelines so that application-level code can be written to the<br>&gt;&gt; guidelines without going through bizarre contortions (e.g. no one<br>&gt;&gt; would ever have *chosen* `func<br>&gt;&gt; dismissViewControllerAnimated(_:completion:)`, and we shouldn’t have<br>&gt;&gt; to chose between either (a) using equally-awkward constructs in our<br>&gt;&gt; own code or (b) being “non-guideline-compliant”).<br>&gt;&gt; <br>&gt;&gt; ## REMARKS ON RULE 3<br>&gt;&gt; <br>&gt;&gt; Separately, I think rule 3 is a hair too coarse to be a good guideline as-stated.<br>&gt;&gt; <br>&gt;&gt; I would split the “asking for X by name/identifier/etc.” into two cases:<br>&gt;&gt; <br>&gt;&gt; - (a) asking for X by some well-known/canonical $ID (e.g., such that<br>&gt;&gt; it is a *major* error if no X is found for $ID)<br>&gt;&gt; - (b) asking for X by some identifier (without a strong expectation as<br>&gt;&gt; to whether or not such an X will or won’t be found)<br>&gt;&gt; <br>&gt;&gt; …and at least as a code-reader:<br>&gt;&gt; <br>&gt;&gt; - I have no objection to the proposed rule (3) in scenario (a)<br>&gt;&gt; - I find rule (3) very odd in scenario (b)<br>&gt;&gt; - I think very differently about scenario (a) and scenario (b), and<br>&gt;&gt; would thus prefer that they look different<br>&gt;&gt; <br>&gt;&gt; …and that’s my thoughts, here.<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 2, 2016, at 6:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt;&gt; guidelines that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt;&gt; * are understandable by humans<br>&gt;&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;&gt;  beginning in the base name and describing the primary semantics of<br>&gt;&gt;&gt;  the call, it gets no argument label:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;&gt;    a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;&gt;                           // doesn&#39;t describe the semantics at all, <br>&gt;&gt;&gt;                           // thus we add a label for b.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;&gt;                             // but doesn&#39;t describe the primary <br>&gt;&gt;&gt;                             // semantics, which are to move in both<br>&gt;&gt;&gt;                             // x and y.  Thus, x gets a label.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;&gt;                             // the primary semantics, so u gets no<br>&gt;&gt;&gt;                             // label. b is an<br>&gt;&gt;&gt;                             // option that tunes the primary<br>&gt;&gt;&gt;                             // semantics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;&gt;  all the default argument cases too, so maybe that exception can be<br>&gt;&gt;&gt;  dropped.  We still need the exceptions for full-width type<br>&gt;&gt;&gt;  conversions and indistinguishable peers]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;&gt;  first argument, we skip it in considering this criterion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;&gt;                      // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;&gt;                      // making this determination.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;&gt; clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;&gt; https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;&gt; point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;&gt; universally-understood term.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;  should go in the base name rather than in a label:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;     a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;     a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;  ambiguous]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;  go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;  initializers):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;     trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;&gt;  *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;&gt;  describe it in the base name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;&gt;     a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;&gt;     let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;&gt;     let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
