<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 20, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Apr 20 2016, Stephen Canon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Comments inline.<br>&gt;<br>&gt;&gt; On Apr 20, 2016, at 12:04 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Apr 20, 2016 at 5:38 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt;&gt; Hi Xiaodi —<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the detailed comments.  Some thoughts inline.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 19, 2016, at 6:34 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 in intent. Specifics require further refinement. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Internal inconsistencies in capitalization:<br>&gt;&gt;&gt;&gt; * `signalingNaN` but `isSignalingNan` and `isNan`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a typo.  Should be signalingNan.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Parameter labels, or whatever they&#39;re called now, do not reflect newly<br>&gt;&gt;&gt;&gt; adopted Swift syntax in SE-0046:<br>&gt;&gt;&gt;&gt; * `static func maximum(x: Self, _ y: Self) -&gt; Self` should be `static<br>&gt;&gt;&gt;&gt; func maximum(_ x: Self, _ y: Self) -&gt; Self`, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Infelicitous use of prepositions to conform superficially to new<br>&gt;&gt;&gt;&gt; naming guidelines:<br>&gt;&gt;&gt;&gt; * `isEqual(to:)` is fine, but for consistency there&#39;s<br>&gt;&gt;&gt;&gt; `isLessThanOrEqual(to:)`, which is not fine, because the preposition<br>&gt;&gt;&gt;&gt; &quot;to&quot; applies only to &quot;equal&quot; and not to &quot;less than”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since `adding(_:)` is instead now an operator in the current version<br>&gt;&gt;&gt;&gt; of the proposal, could comparison functions also be operators only?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They could, but you still need isUnordered(with: ) and isTotallyOrdered(with: ), as they don’t have operator equivalents.<br>&gt;&gt; <br>&gt;&gt; My two cents are that the comparison functions that have operators<br>&gt;&gt; should stick with those operators only instead of the names.<br>&gt;&gt; Stylistically, I think `isLessThanOrEqual(to:)` is less than<br>&gt;&gt; cromulent.<br>&gt;&gt; <br>&gt;&gt; Some thoughts on `isUnordered(with:)` and `isTotallyOrdered(with:)`--<br>&gt;&gt; <br>&gt;&gt; 1. As you mention below, implementations are free to expose<br>&gt;&gt; IEEE754-mandated operations with names that differ from the<br>&gt;&gt; specification. Looking to Java and C# as examples of how other C-style<br>&gt;&gt; languages implement floating point types, C-style languages have taken<br>&gt;&gt; a free hand in how they deal with comparison with NaN.<br>&gt;&gt; <br>&gt;&gt; So long as we&#39;re not going down the road of having methods that expose<br>&gt;&gt; distinct unordered-quiet and unordered-signaling comparison predicates<br>&gt;&gt; as defined in IEEE754 (do any C-style languages do that?), there&#39;s<br>&gt;&gt; probably some freedom to determine whether `isUnordered(with:)` is<br>&gt;&gt; necessary as a standalone method or whether it&#39;s already sufficiently<br>&gt;&gt; provided for by other methods. In the end, `x.isUnordered(with: y)` is<br>&gt;&gt; really equivalent to `x.isNan || y.isNan`, which can be immediately<br>&gt;&gt; grokked by any reader of code.<br>&gt;&gt; <br>&gt;&gt; 2. `isTotallyOrdered(with:)` isn&#39;t quite apt as a name. As I<br>&gt;&gt; understand it, totalOrder(x, y) &quot;reflects&quot; a total ordering such that,<br>&gt;&gt; when x is ordered &quot;below&quot; y, the return value is true. (Both quoted<br>&gt;&gt; words reflect the terminology used in the specification.) So perhaps<br>&gt;&gt; `isTotallyOrdered(below:)` or even just `isOrdered(below:)` would be<br>&gt;&gt; more apt. Certainly `with` is not the correct label for the parameter,<br>&gt;&gt; as any two values that don&#39;t compare unordered should be &quot;totally<br>&gt;&gt; ordered with&quot; each other. This is especially problematic if we&#39;re<br>&gt;&gt; going to keep `isUnordered(with:)`, since those two methods would<br>&gt;&gt; suggest a complementary logical relationship that just isn&#39;t there.<br>&gt;<br>&gt; Yes, if we drop isUnordered(with:), then renaming this isOrdered(below:) would work.  I’m OK with this approach.<br>&gt;<br>&gt;&gt;&gt;&gt; Incorrect nomenclature in an attempt to correct previously misleading<br>&gt;&gt;&gt;&gt; nomenclature:<br>&gt;&gt;&gt;&gt; * `leastMagnitude` should be `leastPositive` or `minPositive`, because<br>&gt;&gt;&gt;&gt; magnitudes can be zero: it&#39;s bonkers that<br>&gt;&gt;&gt;&gt; `Double.minimumMagnitude(0.0, Double.leastMagnitude) &lt;<br>&gt;&gt;&gt;&gt; Double.leastMagnitude`!<br>&gt;&gt;&gt;&gt; (Likewise, `leastNormalMagnitude` should be `leastNormalPositive` or<br>&gt;&gt;&gt;&gt; `minPositive`, and `greatestFiniteMagnitude` should be<br>&gt;&gt;&gt;&gt; `greatestFinite` or `maxFinite`)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Inconsistencies with Integer protocols (at least, as they are currently):<br>&gt;&gt;&gt;&gt; * properties named &quot;least...&quot; or &quot;greatest...&quot; are inconsistent with<br>&gt;&gt;&gt;&gt; conceptually similar properties such as `Int.min` and `Int.max`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `min` and `max` were deliberately avoided based on a discussion<br>&gt;&gt;&gt; with the Apple standard library team; these properties don’t really<br>&gt;&gt;&gt; behave like the integer bounds properties, so naming them similarly<br>&gt;&gt;&gt; may be confusing.<br>&gt;&gt; <br>&gt;&gt; I agree absolutely that `min` and `max`, standalone, are misleading<br>&gt;&gt; and shouldn&#39;t be used. That said, I would argue that `maxFinite` is<br>&gt;&gt; demonstrably the correct name because it&#39;s the most succinct one<br>&gt;&gt; that&#39;s both accurate and consistent with other usage. Adding<br>&gt;&gt; &quot;magnitude&quot; clarifies nothing here and in fact made me do a<br>&gt;&gt; double-take on first reading: I had to think for a split second<br>&gt;&gt; whether there exists a greater floating point value that&#39;s a finite<br>&gt;&gt; non-magnitude: it&#39;s of course absurd, but you have to think about it<br>&gt;&gt; the first time. Meanwhile, `greatestFinite` means exactly the same<br>&gt;&gt; thing as `maxFinite`, but now you&#39;re introducing a different word<br>&gt;&gt; where it&#39;s not necessary to clarify the meaning or differentiate from<br>&gt;&gt; standalone `max`.<br>&gt;<br>&gt; My biggest concern with `maxFinite` is that it would seem to also<br>&gt; require a `minFinite`, which would then be easily confused with<br>&gt; e.g. DBL_MIN (which means something radically different), and also<br>&gt; implies that they might not be symmetric after all.  To my ear,<br>&gt; “magnitude” more readily suggests the existing symmetry: namely that I<br>&gt; can get the finite bounds as +/-.greatestFiniteMagnitude.<br>&gt;<br>&gt; FWIW, 754 actually explicitly describes least[Positive]Magnitude as<br>&gt; “the positive number of least magnitude” (the definition of nextUp,<br>&gt; 5.3.1).<br>&gt;<br>&gt;&gt;&gt; Your point about magnitudes being non-zero is reasonable, but I<br>&gt;&gt;&gt; think you’ve taken it a step to far; it could be corrected by<br>&gt;&gt;&gt; simply changing `leastMagnitude` to either `leastPositiveMagnitude`<br>&gt;&gt;&gt; or `leastNonzeroMagnitude`.<br>&gt;&gt; <br>&gt;&gt; By the same reasoning here, `minPositive` (instead of<br>&gt;&gt; `leastMagnitude`) is equally accurate, more consistent with usage<br>&gt;&gt; elsewhere, and probably more accessible to non-native English<br>&gt;&gt; speakers. Throughout the IEEE specification, &quot;magnitude&quot; is used in<br>&gt;&gt; relation to absolute values, which is not really in play here.<br>&gt;&gt; <br>&gt;&gt; In any case, we agree that `leastMagnitude` must at minimum be renamed<br>&gt;&gt; to exclude zero.<br>&gt;&gt; <br>&gt;&gt;&gt; `leastNormalMagnitude` and `greatestFiniteMagnitude` are accurate<br>&gt;&gt;&gt; as is.  (`minPositive`, on the other hand, would be exceedingly<br>&gt;&gt;&gt; misleading).  Can you expand on why you want to change them?  It<br>&gt;&gt;&gt; seems like you simply prefer “positive” to “magnitude”?<br>&gt;&gt; <br>&gt;&gt; I made a typo here (I blame jetlag): `minPositiveNormal` was what I<br>&gt;&gt; meant to type. Again, my rationale is that it is the least deviation<br>&gt;&gt; from `min` that accurately describes what&#39;s going on using the<br>&gt;&gt; simplest words. Here, the distinction between normal and subnormal is<br>&gt;&gt; unavoidable, but we don&#39;t need to talk about magnitudes, and there<br>&gt;&gt; really is no difference between &quot;min&quot; and &quot;least”.<br>&gt;<br>&gt; One is a word, the other is an abbreviation.  The swift guidelines,<br>&gt; for better or worse, counsel us to “avoid abbreviations”.  The fact<br>&gt; that “min&quot; is a term of art makes it plausible, but I don’t think<br>&gt; we’re desperate to save two characters in the name.<br>&gt;<br>&gt;&gt; Also potentially useful (actually, definitely useful in implementing<br>&gt;&gt; floating point strides) would be the properties `maxExactInteger`<br>&gt;&gt; (and, I suppose, a corresponding `minExactInteger`).<br>&gt;<br>&gt; An early draft of the protocol had these.  Naming this property is<br>&gt; *hard*, because every floating-point value larger than<br>&gt; `maxExactInteger` is … an exact integer.  If you want to be<br>&gt; unambiguously precise, you end up with something horrible.  Ultimately<br>&gt; I punted on this issue, but I would definitely support adding it in<br>&gt; the future if an appropriate name can be found, or if a compelling use<br>&gt; case arises (I don’t think it’s actually needed for implementing<br>&gt; strides).<br></p><p>Isn&#39;t this really maxResultOfAdding1?<br></p><p>&gt;<br>&gt;<br>&gt;&gt;&gt;&gt; Use of one term-of-art (`ulp`), as Swift naming guidelines allow and<br>&gt;&gt;&gt;&gt; even encourage, but failure to use more widely understood terms of<br>&gt;&gt;&gt;&gt; art:<br>&gt;&gt;&gt;&gt; * `squareRoot()` should be `sqrt()`<br>&gt;&gt;&gt;&gt; * something really ought to be done about<br>&gt;&gt;&gt;&gt; `truncatingRemainder(dividingBy:)`--the fact that the comments tell<br>&gt;&gt;&gt;&gt; the reader that `truncatingRemainder(dividingBy:)` is equivalent to C<br>&gt;&gt;&gt;&gt; `fmod` suggests to me that `fmod` may be a widely understood<br>&gt;&gt;&gt;&gt; term-of-art<br>&gt;&gt;&gt;&gt; I argue strongly that Swift&#39;s naming guidelines about terms-of-art<br>&gt;&gt;&gt;&gt; should be understood to encourage terms used widely in other languages<br>&gt;&gt;&gt;&gt; for basic mathematical functions instead of written-out English<br>&gt;&gt;&gt;&gt; equivalents--e.g. `asinh` instead of`inverseHyperbolicSine`. Looking<br>&gt;&gt;&gt;&gt; to other C-style languages, all seem to accept these shorter terms<br>&gt;&gt;&gt;&gt; as-is without writing them out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; sqrt( ) I could support, but fmod( ) is an absolutely terrible name<br>&gt;&gt;&gt; for a relatively rarely-used function.  If there were a good<br>&gt;&gt;&gt; term-of-art, I would want to use it, but AFAIK there isn’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I should note that the free functions sqrt( ) and fmod( ) won’t go<br>&gt;&gt;&gt; away with this proposal.  They will continue to be supplied by the<br>&gt;&gt;&gt; math overlay for Float, Double, CGFloat, just not for the<br>&gt;&gt;&gt; FloatingPoint protocol.  So why do we need them in the<br>&gt;&gt;&gt; FloatingPoint protocol at all?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The squareRoot( ) and remainder( ) methods are distinct from most<br>&gt;&gt;&gt; of the other &lt;math.h&gt; functions in that IEEE 754 considers them to<br>&gt;&gt;&gt; be &quot;basic operations” as defined by clause 5 of the standard (IEEE<br>&gt;&gt;&gt; 754 spells out the name “squareRoot” FWIW, though there’s no<br>&gt;&gt;&gt; requirement that we follow that).<br>&gt;&gt; <br>&gt;&gt; Even IEEE754 is interestingly inconsistent here. Throughout, it&#39;s<br>&gt;&gt; written as &quot;squareRoot&quot;, but when it comes to &quot;recommended&quot; functions,<br>&gt;&gt; the reciprocal of the square root is written &quot;rSqrt&quot; (see table 9.1).<br>&gt;&gt; I&#39;d highly recommend setting a good example of when things are<br>&gt;&gt; terms-of-art by going with &quot;sqrt”.<br>&gt;<br>&gt; Clause 9, being non-normative, didn&#39;t receive nearly as much editorial attention.<br>&gt;<br>&gt;&gt; While we&#39;re on the topic of IEEE754 section 5 functions, we&#39;re missing<br>&gt;&gt; abs(x) in the protocol.<br>&gt;<br>&gt; abs() would have come from SignedArithmetic, but you’re right that it’s now missing and should be added to FloatingPoint.<br>&gt;<br>&gt;&gt; And speaking of absolute value functions, IEEE754 calls it &quot;minNumMag&quot;<br>&gt;&gt; and &quot;maxNumMag&quot; when comparing two values but, when it comes to<br>&gt;&gt; summing, recommends a function called &quot;sumAbs&quot;. A missed opportunity<br>&gt;&gt; for consistency, IMO. When implementing in Swift, then, was there a<br>&gt;&gt; rationale for having `minimumMagnitude` instead of the much shorter<br>&gt;&gt; but equally grokkable `minAbs` (abs being, IMO, a term-of-art like<br>&gt;&gt; sqrt)?<br>&gt;<br>&gt; maxAbs is unclear (to me); I could easily imagine that it returns<br>&gt; max(abs(x), abs(y)).  Given that these methods have no precedent in<br>&gt; C-family languages, there isn’t an actual term of art to follow, and<br>&gt; the meaning of maxAbs isn’t particularly obvious.<br>&gt;<br>&gt;&gt; And then speaking of implementations of IEEE minNum and maxNum--are<br>&gt;&gt; those static methods necessary in the protocol? What is gained over<br>&gt;&gt; having just the comparison operators?<br>&gt;<br>&gt; While one can write these operations in terms of the comparison<br>&gt; operators, it’s a bit unwieldy to do so, and requires some heroics<br>&gt; from the optimizer to turn such an expanded definition into e.g. the<br>&gt; arm64 FMAXNM instruction or the AVX-512 VRANGE instruction.  It’s<br>&gt; somewhat easier to wire up those optimizations this way.<br>&gt;<br>&gt; Similarly, having these methods directly available is a useful<br>&gt; optimization hook for user-defined types that conform to the protocol<br>&gt; (though the protocol *will* provide default implementations, so you’re<br>&gt; not obligated to do so).<br>&gt;<br>&gt;&gt;&gt; Because of this it makes sense to require them as methods in the<br>&gt;&gt;&gt; FloatingPoint protocol, rather than only as free functions.<br>&gt;&gt;&gt; [truncatingRemainder( ) is not required by IEEE 754, but it doesn’t<br>&gt;&gt;&gt; impose a significant implementation burden and eases the transition<br>&gt;&gt;&gt; for folks currently using operator %.]<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I buy the &quot;ease&quot; argument. Surely, if folks are using<br>&gt;&gt; operator %, it&#39;s equivalently difficult to transition either to the<br>&gt;&gt; free function or to `truncatingRemainder()`? Suppose you deprecate %<br>&gt;&gt; and recommend fmod(), then just leave `truncatingRemainder()` out of<br>&gt;&gt; the protocol. After all, the rationale for deprecation is that people<br>&gt;&gt; aren&#39;t using it correctly...<br>&gt;<br>&gt; fmod() wraps the C stdlib fmod(), so only exists for types supported<br>&gt; by the C stdlib.  The truncatingRemainder() method is available for<br>&gt; all FloatingPoint types (these two sets of types are equivalent for<br>&gt; Swift today, but if someone wants to write a library type that<br>&gt; conforms to FloatingPoint, it would provide truncatingRemainder).<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 20, 2016 at 04:00:00pm</p></header><div class="content"><p>On Apr 20, 2016, at 4:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Isn&#39;t this really maxResultOfAdding1<br></p><p>(Assuming default rounding) yes, that’s one of the things that you could call it.<br></p><p>- Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/c4c88557/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>April 22, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Le 20 avr. 2016 à 16:07, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; on Wed Apr 20 2016, Stephen Canon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Comments inline.<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 20, 2016, at 12:04 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also potentially useful (actually, definitely useful in implementing<br>&gt;&gt;&gt; floating point strides) would be the properties `maxExactInteger`<br>&gt;&gt;&gt; (and, I suppose, a corresponding `minExactInteger`).<br>&gt;&gt; <br>&gt;&gt; An early draft of the protocol had these.  Naming this property is<br>&gt;&gt; *hard*, because every floating-point value larger than<br>&gt;&gt; `maxExactInteger` is … an exact integer.  If you want to be<br>&gt;&gt; unambiguously precise, you end up with something horrible.  Ultimately<br>&gt;&gt; I punted on this issue, but I would definitely support adding it in<br>&gt;&gt; the future if an appropriate name can be found, or if a compelling use<br>&gt;&gt; case arises (I don’t think it’s actually needed for implementing<br>&gt;&gt; strides).<br>&gt; <br>&gt; Isn&#39;t this really maxResultOfAdding1?<br></p><p>Would a more generic:<br>maxResultOfAdding(_:Self)<br>make sense?<br></p><p>Dany<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
