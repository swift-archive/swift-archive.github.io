<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Stdlib closure argument labels and parameter names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 21, 2016 at 02:00:00pm</p></header><div class="content"><p>on Mon Jun 20 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; A couple of weeks ago we started to notice that we had some poorly-named<br>&gt;&gt; closure parameters and argument labels in the standard library, so we<br>&gt;&gt; did a complete audit of the standard library&#39;s APIs and came up with a<br>&gt;&gt; preliminary proposal for changes, which we applied in a branch and you<br>&gt;&gt; can review in https://github.com/apple/swift/pull/2981.  Let&#39;s please<br>&gt;&gt; carry on further discussion here rather than in the pull request, though.<br>&gt;<br>&gt; In general, I like this; `orderingBy` is a particularly nice<br>&gt; improvement over the old `isOrderedBefore` convention. <br></p><p>I don&#39;t really love the use of “by”, FWIW, but I thought `orderingWith`<br>was more confusable (ordering A with B might swap A and B, whereas the<br>parameter is a closure).  It could be argued, though, that I am being<br>overly concerned with unlikely misinterpretations, at the cost of<br>“naturalness”—a known weakness of mine ;-).  Anyway, as ever I&#39;m open to<br>discussion on this.<br></p><p>&gt; A few specific comments about things I don&#39;t like:<br>&gt;<br>&gt; * In `map` and `flatMap`, I&#39;m not sure how much `transform` buys us<br>&gt;   over `elementTransform`.<br></p><p>I think you mean the converse.  And I agree that `elementTransform`<br>is probably not an improvement over `transform`.<br></p><p>&gt; * In general, I&#39;m not a fan of most of the changes away from `where`<br>&gt; labels. <br></p><p>The only such changes I can find are in<br>https://github.com/apple/swift/pull/2981/commits/3418eede88d724ad23731fe8f412f51e03cf5106<br></p><p>Note that part of this change was to make all filter closures<br>consistent; in the main `filter` API there was no label at all.<br>However, we felt that there&#39;s a real clarity problem with the polarity<br>of the argument (we talk about “filtering things out” but the closure<br>indicates which elements to keep).  And we couldn&#39;t find a “where”-based<br>name that began to clarify it.<br></p><p>I will argue that even changing to “suchThat,” as in the PR, does not<br>sufficiently clarify the closure&#39;s polarity, and the only true fix for<br>filter is to use a different base name (some have suggested “select,”<br>and I have other ideas), but that is out of scope for this particular<br>set of changes.  So if the community is happier with a “where” label<br>here I can live with it.  I do think “suchThat” is marginally clearer.<br></p><p>&gt; Those are a nice, straightforward convention applied broadly across<br>&gt; the Sequence APIs. (Yes, I criticized `where` as a method name in<br>&gt; another thread, but I don&#39;t think `where` is a problem when there&#39;s a<br>&gt; function base name to give it context.) When they don&#39;t work, that&#39;s<br>&gt; usually because of a less-than-ideal base name. I&#39;m not saying that<br>&gt; *all* base names that aren&#39;t compatible with `where` should be<br>&gt; changed, but rather that if `where` is not enough, that&#39;s an API<br>&gt; smell.<br>&gt;<br>&gt; * In particular, `elementWhere` is not a good label for the same<br>&gt; reason that `removeElement` is not a good name. Session 403 last week<br>&gt; actually talked about this between roughly minutes 8 and 11. (I&#39;m sure<br>&gt; you know about its content; you probably saw it before we did.)<br></p><p>Yes I do, and I think you misinterpreted the message in that session.<br>There&#39;s nothing wrong with repeating type information when it&#39;s<br>necessary for clarity or fluency at the use-site.  In the case of<br>`contains(elementWhere:)`, it&#39;s there for fluency:<br></p><p>       customers.contains(where: isSingle)<br></p><p>doesn&#39;t read as well as:<br></p><p>       customers.contains(elementWhere: isSingle)<br></p><p>The point is not to imagine that every argument should be preceded by a<br>noun, and repetition of type information is often the result of trying<br>to do that.<br></p><p>&gt; * I like `separatedWhere` on `split`, but I think the Equatable<br>&gt; version needs a similar renaming. <br></p><p>That&#39;s a nice thought; I think it&#39;s arguably out-of-scope here, though.<br></p><p>&gt; Perhaps `separatedBy`?  `separatedOn`? The usual opposite of `where`,<br>&gt; `of`, doesn&#39;t work here. (Alternatively, `separatedWhere` could be<br>&gt; `separatorWhere` instead, but that&#39;s not quite as elegant.)<br></p><p>I&#39;d want to consider variations of `separatingAt` or `onSeparator` or<br>`atSeparator` too... which makes me thing “separatedWhere” might not be<br>as good as “separatingWhere” for the closure version.<br></p><p>&gt; * I&#39;m very uncomfortable with the amount of weight<br>&gt; `accumulatingResultBy` adds to `reduce`. `combinedBy` seems perfectly<br>&gt; cromulent to me. I&#39;m even more concerned by your suggestion in the<br>&gt; pull request body of<br>&gt; `accumulating(startingFrom:combiningBy:)`. `reduce` is a subtle and<br>&gt; slightly confusing operation; adding more words to its call sites will<br>&gt; not solve that problem. If you want to invent a new name from whole<br>&gt; cloth, I would probably use something like `combining(with<br>&gt; initialResult: T, by nextResult: (T, Element) -&gt; T)`. (For that<br>&gt; matter, while we&#39;re working in this area, `sequence(first:next:)`<br>&gt; could use a similar coat of paint.)<br></p><p>As with `filter(suchThat:`, `reduce(accumulatingResultBy:` is attempting<br>to solve with an argument label what IMO is a grave weakness in clarity<br>of the base name.  If you read the documentation for `reduce`, you&#39;ll<br>see that it&#39;s all about accumulating a result, and if you consider that<br>its current signature often leads to O(N^2) behavior and we are thinking<br>about adding an overload that takes its “accumulator” inout, the<br>arguments for avoiding the name “accumulate” get progressively weaker.<br>But as noted earlier, changing base names is out-of-scope for this<br>proposal.  As with “filter,” I could live with leaving this alone,<br>though I do believe “accumulatingResultBy:” is a real improvement in<br>clarity.<br></p><p>&gt; * I agree with the comment on GitHub that `invoke` should be<br>&gt; `execute`. <br></p><p>Why?  Rationales help.<br></p><p>&gt; If you see a distinction between the two cases on the number of<br>&gt; arguments, I would then suggest `passTo` as the label on these<br>&gt; methods: `views.forEach(passTo: addSubview)`,<br>&gt; `withUnsafeBufferPointer(&amp;bytes, passTo: Data.init(buffer:))`.<br></p><p>Those are intriguing ideas, but that direction tends to suggest this<br>would be better:<br></p><p>  views.passEach(to: addSubview)<br>  passUnsafeBufferPointer(to: Data.init(buffer:))<br></p><p>...until you pass a trailing closure:<br></p><p>  views.passEach { addSubView($0) }<br>  passUnsafeBufferPointer { Data.init(buffer:$0) }<br></p><p>(note: withUnsafeBufferPointer takes only one argument, a closure).<br></p><p>&gt;<br>&gt; * It&#39;s a little odd that you&#39;re using `comparingBy` for `Equatable`<br>&gt; and `orderingBy` for `Comparable`. Did you judge `equatingBy` to be<br>&gt; too awkward? <br></p><p>Yes, and because it&#39;s not “equating,” which would mean using equality<br>(==) it&#39;s “testing equivalence” with respect to the predicate.<br></p><p>&gt; Perhaps the real problem is that `Equatable` ought to be `Comparable`<br>&gt; and `Comparable` ought to be `Orderable`? <br></p><p>I don&#39;t think so, personally, but regardless I consider such a change<br>out-of-scope for this proposal.<br></p><p>&gt; Or maybe `comparingBy` should just be something more general, like<br>&gt; `matchingBy`? That would make perfectly sensible but slightly odd use<br>&gt; cases like this one read better:<br>&gt;<br>&gt; 	let isAnIdiot = luggageCombination.starts(with: [1, 2, 3, 4,<br>&gt; 5], matchingBy: &lt;=) // Matches [1,2,3,4,5], but also [1,1,1,1,1],<br>&gt; [1,2,3,2,1], etc.<br></p><p>That would not be legal, as &lt;= is not an equivalence relation.  You<br>could think about redefining the meaning of `starts(with:` to not<br>require an equivalence relation, but that&#39;s something I&#39;m not confident<br>*I* know how to do meaningfully, and regardless is again out-of-scope.<br></p><p>&gt; Very soon (hopefully), I will be posting an early draft of a proposal<br>&gt; renaming the various first/last/prefix/suffix/etc. APIs. I believe the<br>&gt; only place it touches on your proposal is in<br>&gt; `starts(with:isEquivalent:)`, but I think your changes to the second<br>&gt; parameter label can be easily incorporated into what I&#39;m doing.<br></p><p>Great!<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
