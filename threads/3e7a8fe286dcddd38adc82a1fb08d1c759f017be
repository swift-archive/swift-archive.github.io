<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cd2919ebf2f35a905b24e5002b4dd836?s=50"></div><header><strong>Proposal: XCTest Support for Swift Error Handling</strong> from <string>Chris Hanson</string> &lt;chanson at apple.com&gt;<p>January 10, 2016 at 08:00:00pm</p></header><div class="content"><p>(I originally sent this only to swift-evolution, I intended to send it both swift-evolution and swift-corelibs-dev since there may be people only signed up for the latter who may nonetheless want to provide input.)<br></p><p>We’d like feedback on a proposed design for adding support for Swift error handling to XCTest, attached below. I’ll mostly let the proposal speak for itself, but there are three components to it: Allowing test methods to throw errors, allowing the expressions evaluated by assertions to throw errors, and adding an assertion for checking error handling.<br></p><p>We’re particularly interested in some feedback on the idea of allowing the expressions evaluated by assertions to throw errors; it’s generated some debate because it results in writing test code slightly differently than other code that makes use of Swift error handling, so any thoughts on it would be particularly appreciated.<br></p><p>  -- Chris Hanson (chanson at apple.com &lt;mailto:chanson at apple.com&gt;)<br></p><p><br>XCTest Support for Swift Error Handling<br>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Chris Hanson &lt;https://github.com/eschaton&gt;<br>Status: Review<br>Review manager: TBD<br>Introduction<br>Swift 2 introduced a new error handling mechanism that, for completeness, needs to be accommodated by our testing frameworks. Right now, to write tests that involve methods that may throw an error, a developer needs to incorporate significant boilerplate into their test. We should move this into the framework in several ways, so tests of code that interacts with Swift error handling is concise and intention-revealing.<br></p><p>Motivation<br>Currently, if a developer wants to use a call that may throw an error in a test, they need to use Swift&#39;s do..catch construct in their test because tests are not themselves allowed to throw errors.<br></p><p>As an example, a vending machine object that has had insufficient funds deposited may throw an error if asked to vend an item. A test for that situation could reasonably use the do..catchconstruct to check that this occurs as expected. However, that means all other tests also need to use either a do..catch or try! construct — and the failure of a try! is catastrophic, so do..catch would be preferred simply for better reporting within tests.<br></p><p>func testVendingOneItem() {<br>    do {<br>        vendingMachine.deposit(5)<br>        let item = try vendingMachine.vend(row: 1, column: 1)<br>        XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>    } catch {<br>        XCTFail(&quot;Unexpected failure: \(error)&quot;)<br>    }<br>}<br>If the implementation of VendingMachine.vend(row:column:) changes during development such that it throws an error in this situation, the test will fail as it should.<br></p><p>One other downside of the above is that a failure caught this way will be reported as an expected failure, which would normally be a failure for which XCTest is explicitly testing via an assertion. This failure should ideally be treated as an unexpected failure, as it&#39;s not one that&#39;s anticipated in the execution of the test.<br></p><p>In addition, tests do not currently support throwing an error from within an assertion, requiring any code that throws an error to be invoked outside the assertion itself using the same techniques described above.<br></p><p>Finally, since Swift error handling is a general mechanism that developers should be implementing in their own applications and frameworks, we need to make it straightforward to write tests that ensure code that implements error handling does so correctly.<br></p><p>Proposed solution<br>I propose several related solutions to this issue:<br></p><p>Allow test methods to throw errors.<br>Allow test assertion expressions to throw errors.<br>Add an assertion for checking errors.<br>These solutions combine to make writing tests that involve thrown errors much more succinct.<br></p><p>Allowing Test Methods to Throw Errors<br></p><p>First, we can allow test methods to throw errors if desired, thus allowing the do..catch construct to be omitted when the test isn&#39;t directly checking error handling. This makes the code a developer writes when they&#39;re not explicitly trying to test error handling much cleaner.<br></p><p>Moving the handling of errors thrown by tests into XCTest itself also ensures they can be treated as unexpected failures, since the mechanism to do so is currently private to the framework.<br></p><p>With this, the test from the previous section can become:<br></p><p>func testVendingOneItem() throws {<br>    vendingMachine.deposit(5)<br>    let item = try vendingMachine.vend(row: 1, column: 1)<br>    XCTAssertEqual(item, &quot;Candy Bar&quot;)<br>}<br>This shows much more directly that the test is intended to check a specific non-error case, and that the developer is relying on the framework to handle unexpected errors.<br></p><p>Allowing Test Assertions to Throw Errors<br></p><p>We can also allow the @autoclosure expression that is passed into an assertion to throw an error, and treat that error as an unexpected failure (since the code is being invoked in an assertion that isn&#39;t directly related to error handling). For example:<br></p><p>func testVendingMultipleItemsWithSufficientFunds() {<br>    vendingMachine.deposit(10)<br>    XCTAssertEqual(try vendingMachine.vend(row: 1, column: 1), &quot;Candy Bar&quot;)<br>    XCTAssertEqual(try vendingMachine.vend(row: 1, column: 2), &quot;Chips&quot;)<br>}<br>This can eliminate otherwise-dangerous uses of try! and streamline code that needs to make multiple assertions in a row.<br></p><p>Adding a &quot;Throws Error&quot; Assertion<br></p><p>In order to test code that throws an error, it would be useful to have an assertion that expects an error to be thrown in a particular case. Right now a developer writing code to test that an error is thrown has to test that error themselves:<br></p><p>    func testVendingFailsWithInsufficientFunds() {<br>        vendingMachine.deposit(1)<br>        var vendingFailed = false<br>        do {<br>            _ = try vendingMachine.vend(row: 1, column: 1))<br>        } catch {<br>            vendingFailed = true<br>        }<br>        XCTAssert(vendingFailed)<br>    }<br>If we add an assertion that specifically checks whether an error was thrown, this code will be significantly streamlined:<br></p><p>    func testVendingFailsWithInsufficientFunds() {<br>        vendingMachine.deposit(1)<br>        XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1))<br>    }<br>Of course, some code may want to just detect that an error was thrown, but other code may need to check that the details of the thrown error are correct. We can take advantage of Swift&#39;s trailing closure syntax to enable this, by passing the thrown error (if any) to a closure that can itself contain assertions:<br></p><p>    XCTAssertThrowsError(_ = try vendingMachine.vend(row: 1, column: 1)) { error in<br>        guard let vendingError = error as? VendingMachineError else {<br>            XCTFail(&quot;Unexpected type of error thrown: \(error)&quot;)<br>            return<br>        }<br>        <br>        XCTAssertEquals(vendingError.item, &quot;Candy Bar&quot;)<br>        XCTAssertEquals(vendingError.price, 5)<br>        XCTAssertEquals(vendingError.message, &quot;A Candy Bar costs 5 coins&quot;)<br>    }<br>This lets a developer very concisely describe an error condition for their code, in whatever level of detail they desire.<br></p><p>Detailed design<br>The design of each of the above components is slightly different, based on the functionality provided.<br></p><p>Tests That Throw<br></p><p>In order to enable test methods to throw an error, we will need to update XCTest to support test methods with a () throws -&gt; Void signature in addition to test methods with a () -&gt; Voidsignature as it already supports.<br></p><p>We will need to ensure tests that do throw an error have that error caught, and that it registers an unexpected failure.<br></p><p>Assertions That Throw<br></p><p>In order to allow assertions to throw an exception, we will need to enhance our existing assertions&#39; @autoclosure expression parameters to add throws to their signature.<br></p><p>Because Swift defines a closure that can throw an error to be a proper supertype of a closure that does not, this will not result in a combinatorial explosion of assertion overrides, and will let developers naturally write code that may throw an error within an assertion.<br></p><p>We will treat any error thrown from within an assertion expression as an unexpected failure because while all assertions represent a test for some form of failure, they&#39;re not specifically checking for a thrown error.<br></p><p>The &quot;Throws Error&quot; Assertion<br></p><p>To write tests for code that throws error, we will add a new assertion function to XCTest with the following prototype:<br></p><p>public func XCTAssertThrowsError(<br>    @autoclosure expression: () throws -&gt; Void,<br>                  _ message: String = &quot;&quot;,<br>                       file: StaticString = __FILE__,<br>                       line: UInt = __LINE__,<br>             _ errorHandler: (error: ErrorType) -&gt; Void = { _ in })<br>Rather than treat an error thrown from its expression as a failure, this will treat the lack of an error thrown from its expression as an expected failure.<br></p><p>Furthermore, so long as an error is thrown, the error will be passed to the errorHandler block passed as a trailing closure, where the developer may make further assertions against it.<br></p><p>In both cases, the new assertion function is generic on an ErrorType in order to ensure that little to no casting will be required in the trailing closure.<br></p><p>Impact on existing code<br>There should be little impact on existing test code because we are only adding features and API, not changing existing features or API.<br></p><p>All existing tests should continue to work as implemented, and can easily adopt the new conventions we&#39;re making available to become more concise and intention-revealing with respect to their error handling as shown above.<br></p><p>Alternatives considered<br>We considered asking developers continue using XCTest as-is, and encouraging them to use Swift&#39;s native error handling to both suppress and check the validity of errors. We also considered adding additional ways of registering failures when doing this, so that developers could register unexpected failures themselves.<br></p><p>While this would result in developers using the language the same way in their tests as in their functional code, this would also result in much more verbose tests. We rejected this approach because such verbosity can be a significant obstacle to testing.<br></p><p>Making it quick and clean to write tests for error handling could also encourage developers to implement error handling in their code as they need it, rather than to try to work around the feature because of any perceived difficulty in testing.<br></p><p>We considered adding the ability to check that a specific error was thrown in XCTAssertThrowsError, but this would require the ErrorType passed to also conform to Equatable, which is also unnecessary given that this can easily be checked in a trailing closure if desired. (In some cases a developer may just want to ensure an error is thrown rather than a specific error is thrown.)<br></p><p>We explicitly chose not to offer a comprehensive suite of DoesNotThrowError assertions for XCTest in Swift, though we do offer such DoesNotThrow assertions for XCTest in Objective-C. We feel these are of limited utility given that our plan is for all assertions (except XCTAssertThrowsError) to treat any thrown error as a failure.<br></p><p>We explicitly chose not to offer any additional support for Objective-C exceptions beyond what we already provide: In the Xcode implementation of XCTest, an Objective-C exception that occurs within one of our existing assertions or tests will result in a test failure; doing more than this is not practical given that it&#39;s possible to neither catch and handle nor generate an Objective-C exception in Swift.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160110/3e7a17be/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
