<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 10, 2015 at 04:00:00pm</p></header><div class="content"><p>I would very much like to implement multi-line string literals in swift and<br>get feedback on what this should look like, as i&#39;ve been informed there are<br>several competing suggestions filed as radars.<br></p><p>My initial improvement request is here: https://bugs.swift.org/browse/SR-170<br></p><p>It is only an opinion, but it&#39;s my belief that simple python-style<br>multi-line string literals are the way to go. They&#39;re simple and, in the<br>end, exactly the same as normal string literals. They begin and end with<br>triple quotes, can contain newlines, can contain single quotes, and that&#39;s<br>all that&#39;s special in their parsing. The same block of code in Lexer.cpp<br>could be used for both types of literal, ensuring behavior is always<br>consistent regardless of any future changes.<br></p><p>There is also the potential suggestion of removing consistent indentation<br>if there is any so as to make formatting of a multi-line string literal<br>look more clean when indented. For me, it would be a nice to have, but not<br>a make or break feature... and for some it may be confusing.<br></p><p>I&#39;d like to state that I&#39;m not proposing heredoc-style functionality, as I<br>believe that to be an entirely separate feature. The potential to have one<br>heredoc embedded within another would certainly make parsing more painful<br>than i&#39;m happy with.<br></p><p>For an example of code that would benefit significantly from multi-line<br>string literals, please look at docopt.swift:<br>https://github.com/docopt/docopt.swift/blob/master/Examples/Swift/arguments_example/main.swift#L9-L25<br></p><p>Docopt does the opposite of what most command line argument libraries do:<br>rather than defining options and auto-generating the help text based on<br>that... You write the help text and it auto-generates a CLI with exactly<br>those options and arguments. It makes writing CLI applications an absolute<br>pleasure, but without multi-line string literals in swift it&#39;s currently<br>less pleasant than it could be.<br></p><p>Please send me your thoughts. ^_^b<br></p><p><br>-Travis Tilley<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/fc0cc99e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>multi-line string literals</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>Conceptually for this, especially for server side utility. I think there’s<br>a plethora of options out there, “”” seems to be the most modern one, and<br>i’d vote for it having the same interpolation as standard strings \()<br></p><p>On Thu, Dec 10, 2015 at 4:57 PM Travis Tilley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I would very much like to implement multi-line string literals in swift<br>&gt; and get feedback on what this should look like, as i&#39;ve been informed there<br>&gt; are several competing suggestions filed as radars.<br>&gt;<br>&gt; My initial improvement request is here:<br>&gt; https://bugs.swift.org/browse/SR-170<br>&gt;<br>&gt; It is only an opinion, but it&#39;s my belief that simple python-style<br>&gt; multi-line string literals are the way to go. They&#39;re simple and, in the<br>&gt; end, exactly the same as normal string literals. They begin and end with<br>&gt; triple quotes, can contain newlines, can contain single quotes, and that&#39;s<br>&gt; all that&#39;s special in their parsing. The same block of code in Lexer.cpp<br>&gt; could be used for both types of literal, ensuring behavior is always<br>&gt; consistent regardless of any future changes.<br>&gt;<br>&gt; There is also the potential suggestion of removing consistent indentation<br>&gt; if there is any so as to make formatting of a multi-line string literal<br>&gt; look more clean when indented. For me, it would be a nice to have, but not<br>&gt; a make or break feature... and for some it may be confusing.<br>&gt;<br>&gt; I&#39;d like to state that I&#39;m not proposing heredoc-style functionality, as I<br>&gt; believe that to be an entirely separate feature. The potential to have one<br>&gt; heredoc embedded within another would certainly make parsing more painful<br>&gt; than i&#39;m happy with.<br>&gt;<br>&gt; For an example of code that would benefit significantly from multi-line<br>&gt; string literals, please look at docopt.swift:<br>&gt; https://github.com/docopt/docopt.swift/blob/master/Examples/Swift/arguments_example/main.swift#L9-L25<br>&gt;<br>&gt; Docopt does the opposite of what most command line argument libraries do:<br>&gt; rather than defining options and auto-generating the help text based on<br>&gt; that... You write the help text and it auto-generates a CLI with exactly<br>&gt; those options and arguments. It makes writing CLI applications an absolute<br>&gt; pleasure, but without multi-line string literals in swift it&#39;s currently<br>&gt; less pleasant than it could be.<br>&gt;<br>&gt; Please send me your thoughts. ^_^b<br>&gt;<br>&gt;<br>&gt; -Travis Tilley<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/60b02739/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 10, 2015 at 07:00:00pm</p></header><div class="content"><p>If implemented as an argument to `Lexer::lexStringLiteral()`, then it would<br>behave exactly like a typical string literal except where multi-line<br>behavior is concerned (and being terminated by triple quotes instead of a<br>single quote). This would include interpolation, as well as any future<br>functionality.<br></p><p>The function in question wouldn&#39;t require much modification:<br>https://github.com/apple/swift/blob/0bfba2972ec718bb23c006d5fdd9736c506f681e/lib/Parse/Lexer.cpp#L1121<br></p><p>As well as slight modification here to detect triple quoted strings and<br>pass on that information:<br>https://github.com/apple/swift/blob/0bfba2972ec718bb23c006d5fdd9736c506f681e/lib/Parse/Lexer.cpp#L1654-L1656<br></p><p>But that would be an implementation detail, and only if others agree to<br>using triple quote syntax.<br></p><p><br>- Travis Tilley<br></p><p><br>On Thu, Dec 10, 2015 at 5:43 PM, Tal Atlas &lt;me at tal.by&gt; wrote:<br></p><p>&gt; Conceptually for this, especially for server side utility. I think there’s<br>&gt; a plethora of options out there, “”” seems to be the most modern one, and<br>&gt; i’d vote for it having the same interpolation as standard strings \()<br>&gt;<br>&gt; On Thu, Dec 10, 2015 at 4:57 PM Travis Tilley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I would very much like to implement multi-line string literals in swift<br>&gt;&gt; and get feedback on what this should look like, as i&#39;ve been informed there<br>&gt;&gt; are several competing suggestions filed as radars.<br>&gt;&gt;<br>&gt;&gt; My initial improvement request is here:<br>&gt;&gt; https://bugs.swift.org/browse/SR-170<br>&gt;&gt;<br>&gt;&gt; It is only an opinion, but it&#39;s my belief that simple python-style<br>&gt;&gt; multi-line string literals are the way to go. They&#39;re simple and, in the<br>&gt;&gt; end, exactly the same as normal string literals. They begin and end with<br>&gt;&gt; triple quotes, can contain newlines, can contain single quotes, and that&#39;s<br>&gt;&gt; all that&#39;s special in their parsing. The same block of code in Lexer.cpp<br>&gt;&gt; could be used for both types of literal, ensuring behavior is always<br>&gt;&gt; consistent regardless of any future changes.<br>&gt;&gt;<br>&gt;&gt; There is also the potential suggestion of removing consistent indentation<br>&gt;&gt; if there is any so as to make formatting of a multi-line string literal<br>&gt;&gt; look more clean when indented. For me, it would be a nice to have, but not<br>&gt;&gt; a make or break feature... and for some it may be confusing.<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to state that I&#39;m not proposing heredoc-style functionality, as<br>&gt;&gt; I believe that to be an entirely separate feature. The potential to have<br>&gt;&gt; one heredoc embedded within another would certainly make parsing more<br>&gt;&gt; painful than i&#39;m happy with.<br>&gt;&gt;<br>&gt;&gt; For an example of code that would benefit significantly from multi-line<br>&gt;&gt; string literals, please look at docopt.swift:<br>&gt;&gt; https://github.com/docopt/docopt.swift/blob/master/Examples/Swift/arguments_example/main.swift#L9-L25<br>&gt;&gt;<br>&gt;&gt; Docopt does the opposite of what most command line argument libraries do:<br>&gt;&gt; rather than defining options and auto-generating the help text based on<br>&gt;&gt; that... You write the help text and it auto-generates a CLI with exactly<br>&gt;&gt; those options and arguments. It makes writing CLI applications an absolute<br>&gt;&gt; pleasure, but without multi-line string literals in swift it&#39;s currently<br>&gt;&gt; less pleasant than it could be.<br>&gt;&gt;<br>&gt;&gt; Please send me your thoughts. ^_^b<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Travis Tilley<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/b30c3b92/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/703fe08ddf2c01b5fbfb9e1c75085ddc?s=50"></div><header><strong>multi-line string literals</strong> from <string>Casey Cady</string> &lt;casey at kckd.org&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 10, 2015, at 1:56 PM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would very much like to implement multi-line string literals in swift and get feedback on what this should look like, as i&#39;ve been informed there are several competing suggestions filed as radars.<br>&gt; <br>&gt; My initial improvement request is here: https://bugs.swift.org/browse/SR-170<br>&gt; <br>&gt; It is only an opinion, but it&#39;s my belief that simple python-style multi-line string literals are the way to go. They&#39;re simple and, in the end, exactly the same as normal string literals. They begin and end with triple quotes, can contain newlines, can contain single quotes, and that&#39;s all that&#39;s special in their parsing. The same block of code in Lexer.cpp could be used for both types of literal, ensuring behavior is always consistent regardless of any future changes.<br>&gt; <br>&gt; There is also the potential suggestion of removing consistent indentation if there is any so as to make formatting of a multi-line string literal look more clean when indented. For me, it would be a nice to have, but not a make or break feature... and for some it may be confusing.<br>&gt; <br>&gt; I&#39;d like to state that I&#39;m not proposing heredoc-style functionality, as I believe that to be an entirely separate feature. The potential to have one heredoc embedded within another would certainly make parsing more painful than i&#39;m happy with.<br>&gt; <br>&gt; For an example of code that would benefit significantly from multi-line string literals, please look at docopt.swift: https://github.com/docopt/docopt.swift/blob/master/Examples/Swift/arguments_example/main.swift#L9-L25<br>&gt; <br>&gt; Docopt does the opposite of what most command line argument libraries do: rather than defining options and auto-generating the help text based on that... You write the help text and it auto-generates a CLI with exactly those options and arguments. It makes writing CLI applications an absolute pleasure, but without multi-line string literals in swift it&#39;s currently less pleasant than it could be.<br>&gt; <br>&gt; Please send me your thoughts. ^_^b<br>&gt; <br>&gt; <br>&gt; -Travis Tilley<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/4836d76c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/703fe08ddf2c01b5fbfb9e1c75085ddc?s=50"></div><header><strong>multi-line string literals</strong> from <string>Casey Cady</string> &lt;casey at kckd.org&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>I really like the idea but I wonder how this would interact with NSLocalizedString exporting within XCode.<br></p><p>&gt; On Dec 10, 2015, at 1:56 PM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would very much like to implement multi-line string literals in swift and get feedback on what this should look like, as i&#39;ve been informed there are several competing suggestions filed as radars.<br>&gt; <br>&gt; My initial improvement request is here: https://bugs.swift.org/browse/SR-170<br>&gt; <br>&gt; It is only an opinion, but it&#39;s my belief that simple python-style multi-line string literals are the way to go. They&#39;re simple and, in the end, exactly the same as normal string literals. They begin and end with triple quotes, can contain newlines, can contain single quotes, and that&#39;s all that&#39;s special in their parsing. The same block of code in Lexer.cpp could be used for both types of literal, ensuring behavior is always consistent regardless of any future changes.<br>&gt; <br>&gt; There is also the potential suggestion of removing consistent indentation if there is any so as to make formatting of a multi-line string literal look more clean when indented. For me, it would be a nice to have, but not a make or break feature... and for some it may be confusing.<br>&gt; <br>&gt; I&#39;d like to state that I&#39;m not proposing heredoc-style functionality, as I believe that to be an entirely separate feature. The potential to have one heredoc embedded within another would certainly make parsing more painful than i&#39;m happy with.<br>&gt; <br>&gt; For an example of code that would benefit significantly from multi-line string literals, please look at docopt.swift: https://github.com/docopt/docopt.swift/blob/master/Examples/Swift/arguments_example/main.swift#L9-L25<br>&gt; <br>&gt; Docopt does the opposite of what most command line argument libraries do: rather than defining options and auto-generating the help text based on that... You write the help text and it auto-generates a CLI with exactly those options and arguments. It makes writing CLI applications an absolute pleasure, but without multi-line string literals in swift it&#39;s currently less pleasant than it could be.<br>&gt; <br>&gt; Please send me your thoughts. ^_^b<br>&gt; <br>&gt; <br>&gt; -Travis Tilley<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/f1f7ccf7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 10, 2015 at 08:00:00pm</p></header><div class="content"><p>I have no idea how genstrings and so forth work, but if they actually parse<br>the code (which seems likely), then they&#39;ll be getting back the same AST<br>they would for normal strings (since this feature would be implemented<br>pretty much entirely in the swift lexer).<br></p><p>If I am wrong, someone please correct me. I&#39;m non-apple and don&#39;t know how<br>all of this works. ;)<br></p><p><br>-Travis Tilley<br></p><p><br>On Thu, Dec 10, 2015 at 8:12 PM, Casey Cady &lt;casey at kckd.org&gt; wrote:<br></p><p>&gt; I really like the idea but I wonder how this would interact with<br>&gt; NSLocalizedString exporting within XCode.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/bd157566/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December 11, 2015 at 01:00:00am</p></header><div class="content"><p>What do you all think about automatic dedenting of these literals? The<br>excess whitespace is rarely useful; and usually spawns a dedent function<br>which comes to decorate all such strings.<br></p><p>On Thu, 10 Dec 2015 at 17:43 Travis Tilley via swift-evolution<br>swift-evolution at swift.org &lt;http://mailto:swift-evolution at swift.org&gt; wrote:<br></p><p>I have no idea how genstrings and so forth work, but if they actually parse<br>&gt; the code (which seems likely), then they&#39;ll be getting back the same AST<br>&gt; they would for normal strings (since this feature would be implemented<br>&gt; pretty much entirely in the swift lexer).<br>&gt;<br>&gt; If I am wrong, someone please correct me. I&#39;m non-apple and don&#39;t know how<br>&gt; all of this works. ;)<br>&gt;<br>&gt;<br>&gt; -Travis Tilley<br>&gt;<br>&gt;<br>&gt; On Thu, Dec 10, 2015 at 8:12 PM, Casey Cady &lt;casey at kckd.org&gt; wrote:<br>&gt;<br>&gt;&gt; I really like the idea but I wonder how this would interact with<br>&gt;&gt; NSLocalizedString exporting within XCode.<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/7fb703c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>That would be my preference, especially since I can be lazy and re-use the<br>existing indentation detection code in Lexer.cpp. However, one could argue<br>that it could be confusing if indentation was intentional so I&#39;d like to<br>hear more people weigh in on that one, especially core team members.<br></p><p>- Travis Tilley<br></p><p><br>On Thu, Dec 10, 2015 at 8:46 PM, Jason Dusek &lt;jason.dusek at gmail.com&gt; wrote:<br></p><p>&gt; What do you all think about automatic dedenting of these literals? The<br>&gt; excess whitespace is rarely useful; and usually spawns a dedent function<br>&gt; which comes to decorate all such strings.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/3e9ebca6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December 11, 2015 at 02:00:00am</p></header><div class="content"><p>The worse that could happen is people sometimes (very rarely) need an<br>`indent` function to explicitly set and indent level for their multiline<br>string. Doesn&#39;t seem like the worst thing ever.<br></p><p>On Thu, 10 Dec 2015 at 18:04 Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br></p><p>&gt; That would be my preference, especially since I can be lazy and re-use the<br>&gt; existing indentation detection code in Lexer.cpp. However, one could argue<br>&gt; that it could be confusing if indentation was intentional so I&#39;d like to<br>&gt; hear more people weigh in on that one, especially core team members.<br>&gt;<br>&gt; - Travis Tilley<br>&gt;<br>&gt;<br>&gt; On Thu, Dec 10, 2015 at 8:46 PM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; What do you all think about automatic dedenting of these literals? The<br>&gt;&gt; excess whitespace is rarely useful; and usually spawns a dedent function<br>&gt;&gt; which comes to decorate all such strings.<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/fe133738/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 9:08 PM, Jason Dusek &lt;jason.dusek at gmail.com&gt; wrote:<br></p><p>&gt; The worse that could happen is people sometimes (very rarely) need an<br>&gt; `indent` function to explicitly set and indent level for their multiline<br>&gt; string. Doesn&#39;t seem like the worst thing ever.<br>&gt;<br></p><p>​I am with you 100% on that. ​Python has a variety of indentation helpers<br>and that&#39;s something i&#39;d like to avoid. Detecting the indentation of the<br>first line and removing it from all lines, if consistent (excluding blank<br>lines), would be nice. Still... Even though I&#39;m not proposing heredocs,<br>every language with them has two syntaxes for it specifically to make the<br>indentation issue unambiguous. Waiting for more feedback can&#39;t hurt.<br></p><p><br>​- Travis Tilley<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/b9bc8bf3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/703fe08ddf2c01b5fbfb9e1c75085ddc?s=50"></div><header><strong>multi-line string literals</strong> from <string>Casey Cady</string> &lt;casey at kckd.org&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>Keep in mind that there&#39;s both genstrings and the new xliff exporter, and the latter was a hot mess for quite a while and only recently started working properly, so I have zero confidence that it would just work. But as you say, we really do need someone from Apple to weigh in. :)<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 10, 2015, at 5:42 PM, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have no idea how genstrings and so forth work, but if they actually parse the code (which seems likely), then they&#39;ll be getting back the same AST they would for normal strings (since this feature would be implemented pretty much entirely in the swift lexer).<br>&gt; <br>&gt; If I am wrong, someone please correct me. I&#39;m non-apple and don&#39;t know how all of this works. ;)<br>&gt; <br>&gt; <br>&gt; -Travis Tilley<br>&gt; <br>&gt; <br>&gt;&gt; On Thu, Dec 10, 2015 at 8:12 PM, Casey Cady &lt;casey at kckd.org&gt; wrote:<br>&gt;&gt; I really like the idea but I wonder how this would interact with NSLocalizedString exporting within XCode.<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/9f7f1596/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 1:56 PM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would very much like to implement multi-line string literals in swift and get feedback on what this should look like, as i&#39;ve been informed there are several competing suggestions filed as radars.<br></p><p>I’m positive about adding some syntax for multi-line string literals.  Some questions to think about and debate on this list:<br></p><p>1) What concrete syntax should be used?  There are a lot of options in this space across a wide range of languages.  C++ has raw strings, and this page has more examples:<br>http://rigaux.org/language-study/syntax-across-languages.html#StrngMltLine<br></p><p>2) Should escapes like \n be processed always, should they never be processed, or should they be processed by default but disable-able in the syntax?<br></p><p>3) What other policy decisions make sense to expose on these literals?  Since this will be the “powerful form of string literals”, it makes sense to be the place to put weird knobs that are seldom used but important in various cases.<br></p><p>I assume that this would tie into the existing literal convertible protocols, and if/when escaping is supported that it would support interpolation as well.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; My initial improvement request is here: https://bugs.swift.org/browse/SR-170 &lt;https://bugs.swift.org/browse/SR-170&gt;<br>&gt; <br>&gt; It is only an opinion, but it&#39;s my belief that simple python-style multi-line string literals are the way to go. They&#39;re simple and, in the end, exactly the same as normal string literals. They begin and end with triple quotes, can contain newlines, can contain single quotes, and that&#39;s all that&#39;s special in their parsing. The same block of code in Lexer.cpp could be used for both types of literal, ensuring behavior is always consistent regardless of any future changes.<br>&gt; <br>&gt; There is also the potential suggestion of removing consistent indentation if there is any so as to make formatting of a multi-line string literal look more clean when indented. For me, it would be a nice to have, but not a make or break feature... and for some it may be confusing.<br>&gt; <br>&gt; I&#39;d like to state that I&#39;m not proposing heredoc-style functionality, as I believe that to be an entirely separate feature. The potential to have one heredoc embedded within another would certainly make parsing more painful than i&#39;m happy with.<br>&gt; <br>&gt; For an example of code that would benefit significantly from multi-line string literals, please look at docopt.swift: https://github.com/docopt/docopt.swift/blob/master/Examples/Swift/arguments_example/main.swift#L9-L25 &lt;https://github.com/docopt/docopt.swift/blob/master/Examples/Swift/arguments_example/main.swift#L9-L25&gt;<br>&gt; <br>&gt; Docopt does the opposite of what most command line argument libraries do: rather than defining options and auto-generating the help text based on that... You write the help text and it auto-generates a CLI with exactly those options and arguments. It makes writing CLI applications an absolute pleasure, but without multi-line string literals in swift it&#39;s currently less pleasant than it could be.<br>&gt; <br>&gt; Please send me your thoughts. ^_^b<br>&gt; <br>&gt; <br>&gt; -Travis Tilley<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/59949df4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015 at 8:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; 1) What concrete syntax should be used?  There are a lot of options in<br>&gt; this space across a wide range of languages.  C++ has raw strings, and this<br>&gt; page has more examples:<br>&gt; http://rigaux.org/language-study/syntax-across-languages.html#StrngMltLine<br>&gt;<br></p><p><br>​I am open to any and all suggestions, though I&#39;ve already stated my<br>personal fondness for python&#39;s style. ;)​<br></p><p><br></p><p>&gt; 2) Should escapes like \n be processed always, should they never be<br>&gt; processed, or should they be processed by default but disable-able in the<br>&gt; syntax?<br>&gt;<br></p><p><br>I would want multi-line string literals to behave as much like normal<br>string literals as possible for consistency. To optimize for developer<br>happiness, to steal the ruby saying, unexpected behavior should be kept to<br>a minimum. If \n works in a normal string literal, it should work in a<br>multi-line string literal... even if you could just hit enter instead.<br></p><p><br></p><p>&gt; 3) What other policy decisions make sense to expose on these literals?<br>&gt; Since this will be the “powerful form of string literals”, it makes sense<br>&gt; to be the place to put weird knobs that are seldom used but important in<br>&gt; various cases.<br>&gt;<br></p><p><br>​I would have to depend entirely on you to inform me of both these knobs<br>and use cases. ​I&#39;d love to hear about them, that&#39;s for sure.<br></p><p>My initial goal was the minimal possible work required to decrease the<br>noise of writing large blocks of multi-line text and not have to poke<br>around too much in the lexer and parser code (being completely unfamiliar<br>with the swift codebase, having it just become open source recently).<br></p><p><br></p><p>&gt; I assume that this would tie into the existing literal convertible<br>&gt; protocols, and if/when escaping is supported that it would support<br>&gt; interpolation as well.<br>&gt;<br></p><p><br>​I actually wanted to re-use the same function for handling normal string<br>literals so that the functionality available would be exactly the same, and<br>the output would be the exact same `​tok::string_literal`.<br></p><p><br>- Travis Tilley<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/46b1ae55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>On Dec 10, 2015, at 6:01 PM, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt; 2) Should escapes like \n be processed always, should they never be processed, or should they be processed by default but disable-able in the syntax?<br>&gt; <br>&gt; <br>&gt; I would want multi-line string literals to behave as much like normal string literals as possible for consistency. To optimize for developer happiness, to steal the ruby saying, unexpected behavior should be kept to a minimum. If \n works in a normal string literal, it should work in a multi-line string literal... even if you could just hit enter instead.<br></p><p>Yes, I agree that should be the default.<br></p><p>&gt; 3) What other policy decisions make sense to expose on these literals?  Since this will be the “powerful form of string literals”, it makes sense to be the place to put weird knobs that are seldom used but important in various cases.<br>&gt; <br>&gt; <br>&gt; ​I would have to depend entirely on you to inform me of both these knobs and use cases. ​I&#39;d love to hear about them, that&#39;s for sure.<br></p><p>The reason I raise the question is that some languages have multiple quote styles (Perl 5 has something like 3 or 4 different string literal styles IIRC?) with different policies.  One reason for this is to disable processing of escapes: if you’re using string literals to enter something that uses \ or “ frequently, it can be irritating and ugly to have a lot of \\&#39;s &lt;smb://&#39;s&gt;.  In some dialects of inline assembly in C, for example, this can lead to very ugly code.<br></p><p>When introducing a feature like this, I think it would be useful to survey a range of popular languages (and yes, even perl ;-) to understand what facilities they provide and why (i.e. what problems they are solving) and synthesize a good swift design that can solve the same problems with a hopefully simple approach.<br></p><p>I haven’t looked into this area deeply myself, so I can’t give you a recipe to just follow, some research is required :)<br></p><p><br>&gt; My initial goal was the minimal possible work required to decrease the noise of writing large blocks of multi-line text and not have to poke around too much in the lexer and parser code (being completely unfamiliar with the swift codebase, having it just become open source recently).<br></p><p>Understood, but our first goal is to get the best solution, independent of implementation complexity.  In this case, I suspect that the hard part in this feature is scoping it out and hashing out the right design with the community.  I can’t imagine that we’d end up with a design that is that difficult to implement in any case.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/11bc3b9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>multi-line string literals</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 10, 2015 at 11:00:00pm</p></header><div class="content"><p>In the OP, Travis wrote:<br></p><p>&gt; There is also the potential suggestion of removing consistent indentation if there is any so as to make formatting of a multi-line string literal look more clean when indented. <br></p><p><br>Ruby has … oh, on the order of 2^9 different string syntaxes, but none of them address this indentation problem, and it’s a constant complaint. Hacks for it abound.<br></p><p>• • • <br></p><p>In Ruby in the wild, off the top of my head and totally unscientifically, the most widely-used flavors I’ve seen are the heredoc with interpolation and terminator indentation:<br></p><p>    string = &lt;&lt;-EOS<br>      gone is music<br>      yet you sing<br>    EOS<br></p><p>…and just putting newlines inside a double-quoted string:<br></p><p>    string = &quot;<br>      gone is music<br>      yet you sing<br>    &quot;<br></p><p>…probably in that order.<br></p><p>Useful notes on the heredoc variants, typical of Ruby’s “the more syntaxes the merrier!” approach to things:<br></p><p>	http://blog.jayfields.com/2006/12/ruby-multiline-strings-here-doc-or.html<br></p><p>Cheers, P<br></p><p>&gt; On Dec 10, 2015, at 11:02 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 10, 2015, at 6:01 PM, Travis Tilley &lt;ttilley at gmail.com &lt;mailto:ttilley at gmail.com&gt;&gt; wrote:<br>&gt;&gt; 2) Should escapes like \n be processed always, should they never be processed, or should they be processed by default but disable-able in the syntax?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would want multi-line string literals to behave as much like normal string literals as possible for consistency. To optimize for developer happiness, to steal the ruby saying, unexpected behavior should be kept to a minimum. If \n works in a normal string literal, it should work in a multi-line string literal... even if you could just hit enter instead.<br>&gt; <br>&gt; Yes, I agree that should be the default.<br>&gt; <br>&gt;&gt; 3) What other policy decisions make sense to expose on these literals?  Since this will be the “powerful form of string literals”, it makes sense to be the place to put weird knobs that are seldom used but important in various cases.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ​I would have to depend entirely on you to inform me of both these knobs and use cases. ​I&#39;d love to hear about them, that&#39;s for sure.<br>&gt; <br>&gt; The reason I raise the question is that some languages have multiple quote styles (Perl 5 has something like 3 or 4 different string literal styles IIRC?) with different policies.  One reason for this is to disable processing of escapes: if you’re using string literals to enter something that uses \ or “ frequently, it can be irritating and ugly to have a lot of \\&#39;s &lt;smb://&#39;s&gt;.  In some dialects of inline assembly in C, for example, this can lead to very ugly code.<br>&gt; <br>&gt; When introducing a feature like this, I think it would be useful to survey a range of popular languages (and yes, even perl ;-) to understand what facilities they provide and why (i.e. what problems they are solving) and synthesize a good swift design that can solve the same problems with a hopefully simple approach.<br>&gt; <br>&gt; I haven’t looked into this area deeply myself, so I can’t give you a recipe to just follow, some research is required :)<br>&gt; <br>&gt; <br>&gt;&gt; My initial goal was the minimal possible work required to decrease the noise of writing large blocks of multi-line text and not have to poke around too much in the lexer and parser code (being completely unfamiliar with the swift codebase, having it just become open source recently).<br>&gt; <br>&gt; Understood, but our first goal is to get the best solution, independent of implementation complexity.  In this case, I suspect that the hard part in this feature is scoping it out and hashing out the right design with the community.  I can’t imagine that we’d end up with a design that is that difficult to implement in any case.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/025274ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 12:00:00am</p></header><div class="content"><p>The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip<br>indentation if necessary. Technically, it searches for the &quot;least indented<br>line&quot; in the whole string, and removes exactly that amount from each line.<br>So yes, the indentation problem -is- solved in ruby (though it might break<br>entirely if you have empty lines, since the least indented line has no<br>indentation).<br></p><p><br>On Fri, Dec 11, 2015 at 12:36 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;<br>&gt; In Ruby in the wild, off the top of my head and totally unscientifically,<br>&gt; the most widely-used flavors I’ve seen are the heredoc with interpolation<br>&gt; and terminator indentation:<br>&gt;<br>&gt;     string = &lt;&lt;-EOS<br>&gt;       gone is music<br>&gt;       yet you sing<br>&gt;     EOS<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/789bbc48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>multi-line string literals</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 10, 2015 at 11:00:00pm</p></header><div class="content"><p>The &lt;&lt;- only does that for the EOS terminator, not for every line of the string:<br></p><p>$ irb<br>2.2.0 :001 &gt;     string = &lt;&lt;-EOS<br>2.2.0 :002&quot;&gt;       gone is music<br>2.2.0 :003&quot;&gt;       yet you sing<br>2.2.0 :004&quot;&gt;     EOS<br> =&gt; &quot;      gone is music\n      yet you sing\n&quot; <br></p><p>(Ruby 2.2)<br></p><p>&gt; On Dec 10, 2015, at 11:45 PM, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt; <br>&gt; The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip indentation if necessary. Technically, it searches for the &quot;least indented line&quot; in the whole string, and removes exactly that amount from each line. So yes, the indentation problem -is- solved in ruby (though it might break entirely if you have empty lines, since the least indented line has no indentation).<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 12:36 AM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt; In Ruby in the wild, off the top of my head and totally unscientifically, the most widely-used flavors I’ve seen are the heredoc with interpolation and terminator indentation:<br>&gt; <br>&gt;     string = &lt;&lt;-EOS<br>&gt;       gone is music<br>&gt;       yet you sing<br>&gt;     EOS<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/5d967228/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December 11, 2015 at 06:00:00am</p></header><div class="content"><p>On Thu, 10 Dec 2015 at 21:45, Travis Tilley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip<br>&gt; indentation if necessary. Technically, it searches for the &quot;least indented<br>&gt; line&quot; in the whole string, and removes exactly that amount from each line.<br>&gt; So yes, the indentation problem -is- solved in ruby (though it might break<br>&gt; entirely if you have empty lines, since the least indented line has no<br>&gt; indentation).<br>&gt;<br>To my mind, the rules should be:<br></p><p>   1. The indentation level is set from the least indented line that is not<br>   the first line and is not empty.<br>   2. A leading empty line is removed.<br>   3. The leading line, if there is any text in it, is not subject to<br>   de-indentation.<br></p><p>I genuinely believe these three rules taken together address all the errors<br>and infelicities to which triple quotes and HEREDOCs subject us. Here are<br>some examples:<br></p><p>text = &quot;&quot;&quot;<br>    Some<br></p><p>  Features<br>    Are<br>    Discussed<br>&quot;&quot;&quot;# From (1): The indentation is taken from the third line below<br>`text`, so it&#39;s 2.# From (2): First line is: &quot;\n&quot; so it is removed.#<br>&gt;From (3): No effect.<br></p><p>text = &quot;&quot;&quot;  Some<br></p><p>          Features<br>            Are<br>            Discussed<br>&quot;&quot;&quot;# From (1): The indentation is taken again from the line reading<br>&quot;Features&quot;. Here it is 10.# From (2): No effect.# From (3): The<br>leading whitespace in `  Some` is preserved.<br></p><p>Do you all think these rules pass muster?<br></p><p>A fourth rule — one which seems advisable but also less necessary than the<br>others — is that a string constructed in this way always ends with a<br>newline. It is a rule that perhaps leads to surprises and inconsistencies.<br></p><p>Best Regards,<br></p><p>Jason<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/fc814401/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 01:00:00am</p></header><div class="content"><p>I had been operating on the assumption that a leading blank line would be<br>stripped if present, since the syntax in code would look much cleaner, but<br>a trailing line would not since it would likely be intentional. I guess<br>that&#39;s another detail that would need to be fleshed out if we decide to go<br>with triple quote syntax (which, at this point, isn&#39;t a given... chris<br>lattner brings up some very good points that might require more involved,<br>potentially heredoc-like, syntax to solve).<br></p><p>Your fourth rule, however, I don&#39;t agree with at all. It should be obvious<br>from where you place the final quotes whether or not the string includes a<br>trailing newline. Just like in ruby, I believe in and value the principle<br>of least surprize.<br></p><p><br>- Travis Tilley<br></p><p><br>On Fri, Dec 11, 2015 at 1:04 AM, Jason Dusek &lt;jason.dusek at gmail.com&gt; wrote:<br></p><p>&gt; On Thu, 10 Dec 2015 at 21:45, Travis Tilley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip<br>&gt;&gt; indentation if necessary. Technically, it searches for the &quot;least indented<br>&gt;&gt; line&quot; in the whole string, and removes exactly that amount from each line.<br>&gt;&gt; So yes, the indentation problem -is- solved in ruby (though it might break<br>&gt;&gt; entirely if you have empty lines, since the least indented line has no<br>&gt;&gt; indentation).<br>&gt;&gt;<br>&gt; To my mind, the rules should be:<br>&gt;<br>&gt;    1. The indentation level is set from the least indented line that is<br>&gt;    not the first line and is not empty.<br>&gt;    2. A leading empty line is removed.<br>&gt;    3. The leading line, if there is any text in it, is not subject to<br>&gt;    de-indentation.<br>&gt;<br>&gt; I genuinely believe these three rules taken together address all the<br>&gt; errors and infelicities to which triple quotes and HEREDOCs subject us.<br>&gt; Here are some examples:<br>&gt;<br>&gt; text = &quot;&quot;&quot;<br>&gt;     Some<br>&gt;<br>&gt;   Features<br>&gt;     Are<br>&gt;     Discussed<br>&gt; &quot;&quot;&quot;# From (1): The indentation is taken from the third line below `text`, so it&#39;s 2.# From (2): First line is: &quot;\n&quot; so it is removed.# From (3): No effect.<br>&gt;<br>&gt; text = &quot;&quot;&quot;  Some<br>&gt;<br>&gt;           Features<br>&gt;             Are<br>&gt;             Discussed<br>&gt; &quot;&quot;&quot;# From (1): The indentation is taken again from the line reading &quot;Features&quot;. Here it is 10.# From (2): No effect.# From (3): The leading whitespace in `  Some` is preserved.<br>&gt;<br>&gt; Do you all think these rules pass muster?<br>&gt;<br>&gt; A fourth rule — one which seems advisable but also less necessary than the<br>&gt; others — is that a string constructed in this way always ends with a<br>&gt; newline. It is a rule that perhaps leads to surprises and inconsistencies.<br>&gt;<br>&gt; Best Regards,<br>&gt;<br>&gt; Jason<br>&gt; ​<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/8e5920c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December 11, 2015 at 06:00:00am</p></header><div class="content"><p>Yeah, I can&#39;t say I am totally committed to the fourth one.<br></p><p>On Thu, 10 Dec 2015 at 22:34 Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br></p><p>&gt; I had been operating on the assumption that a leading blank line would be<br>&gt; stripped if present, since the syntax in code would look much cleaner, but<br>&gt; a trailing line would not since it would likely be intentional. I guess<br>&gt; that&#39;s another detail that would need to be fleshed out if we decide to go<br>&gt; with triple quote syntax (which, at this point, isn&#39;t a given... chris<br>&gt; lattner brings up some very good points that might require more involved,<br>&gt; potentially heredoc-like, syntax to solve).<br>&gt;<br>&gt; Your fourth rule, however, I don&#39;t agree with at all. It should be obvious<br>&gt; from where you place the final quotes whether or not the string includes a<br>&gt; trailing newline. Just like in ruby, I believe in and value the principle<br>&gt; of least surprize.<br>&gt;<br>&gt;<br>&gt; - Travis Tilley<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 1:04 AM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Thu, 10 Dec 2015 at 21:45, Travis Tilley via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip<br>&gt;&gt;&gt; indentation if necessary. Technically, it searches for the &quot;least indented<br>&gt;&gt;&gt; line&quot; in the whole string, and removes exactly that amount from each line.<br>&gt;&gt;&gt; So yes, the indentation problem -is- solved in ruby (though it might break<br>&gt;&gt;&gt; entirely if you have empty lines, since the least indented line has no<br>&gt;&gt;&gt; indentation).<br>&gt;&gt;&gt;<br>&gt;&gt; To my mind, the rules should be:<br>&gt;&gt;<br>&gt;&gt;    1. The indentation level is set from the least indented line that is<br>&gt;&gt;    not the first line and is not empty.<br>&gt;&gt;    2. A leading empty line is removed.<br>&gt;&gt;    3. The leading line, if there is any text in it, is not subject to<br>&gt;&gt;    de-indentation.<br>&gt;&gt;<br>&gt;&gt; I genuinely believe these three rules taken together address all the<br>&gt;&gt; errors and infelicities to which triple quotes and HEREDOCs subject us.<br>&gt;&gt; Here are some examples:<br>&gt;&gt;<br>&gt;&gt; text = &quot;&quot;&quot;<br>&gt;&gt;     Some<br>&gt;&gt;<br>&gt;&gt;   Features<br>&gt;&gt;     Are<br>&gt;&gt;     Discussed<br>&gt;&gt; &quot;&quot;&quot;# From (1): The indentation is taken from the third line below `text`, so it&#39;s 2.# From (2): First line is: &quot;\n&quot; so it is removed.# From (3): No effect.<br>&gt;&gt;<br>&gt;&gt; text = &quot;&quot;&quot;  Some<br>&gt;&gt;<br>&gt;&gt;           Features<br>&gt;&gt;             Are<br>&gt;&gt;             Discussed<br>&gt;&gt; &quot;&quot;&quot;# From (1): The indentation is taken again from the line reading &quot;Features&quot;. Here it is 10.# From (2): No effect.# From (3): The leading whitespace in `  Some` is preserved.<br>&gt;&gt;<br>&gt;&gt; Do you all think these rules pass muster?<br>&gt;&gt;<br>&gt;&gt; A fourth rule — one which seems advisable but also less necessary than<br>&gt;&gt; the others — is that a string constructed in this way always ends with a<br>&gt;&gt; newline. It is a rule that perhaps leads to surprises and inconsistencies.<br>&gt;&gt;<br>&gt;&gt; Best Regards,<br>&gt;&gt;<br>&gt;&gt; Jason<br>&gt;&gt; ​<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/81c784ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>Just a thought: what about something more generalized &amp; explicit, like a<br>MultilineLiteral type (a.k.a. StaticString), and a String initializer with<br>parameters for the options:<br></p><p>String.init(removeLeadingNewline: Bool = false, removeIndentation: Bool =<br>false, _ mulitilineLiteral: MultilineLiteral)<br></p><p>let str = &quot;&quot;&quot;<br>   raw string; nothing changed<br>&quot;&quot;&quot;<br></p><p>let str2 = String(removeLeadingNewline: true, &quot;&quot;&quot;<br>    leading newline is removed, but indentation remains<br>&quot;&quot;&quot;)<br></p><p>let str3 = String(removeIndentation: true, &quot;&quot;&quot;<br>    leading newline remains, but as much indentation as possible is removed<br>&quot;&quot;&quot;)<br></p><p><br>(I&#39;m not a fan of the trailing close-paren, but can&#39;t really think of a way<br>around it. Maybe an exception like trailing-closure syntax for<br>trailing-multiline-literals?)<br></p><p>Jacob<br></p><p>On Thu, Dec 10, 2015 at 10:38 PM, Jason Dusek via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yeah, I can&#39;t say I am totally committed to the fourth one.<br>&gt;<br>&gt; On Thu, 10 Dec 2015 at 22:34 Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I had been operating on the assumption that a leading blank line would be<br>&gt;&gt; stripped if present, since the syntax in code would look much cleaner, but<br>&gt;&gt; a trailing line would not since it would likely be intentional. I guess<br>&gt;&gt; that&#39;s another detail that would need to be fleshed out if we decide to go<br>&gt;&gt; with triple quote syntax (which, at this point, isn&#39;t a given... chris<br>&gt;&gt; lattner brings up some very good points that might require more involved,<br>&gt;&gt; potentially heredoc-like, syntax to solve).<br>&gt;&gt;<br>&gt;&gt; Your fourth rule, however, I don&#39;t agree with at all. It should be<br>&gt;&gt; obvious from where you place the final quotes whether or not the string<br>&gt;&gt; includes a trailing newline. Just like in ruby, I believe in and value the<br>&gt;&gt; principle of least surprize.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - Travis Tilley<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015 at 1:04 AM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Thu, 10 Dec 2015 at 21:45, Travis Tilley via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip<br>&gt;&gt;&gt;&gt; indentation if necessary. Technically, it searches for the &quot;least indented<br>&gt;&gt;&gt;&gt; line&quot; in the whole string, and removes exactly that amount from each line.<br>&gt;&gt;&gt;&gt; So yes, the indentation problem -is- solved in ruby (though it might break<br>&gt;&gt;&gt;&gt; entirely if you have empty lines, since the least indented line has no<br>&gt;&gt;&gt;&gt; indentation).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; To my mind, the rules should be:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    1. The indentation level is set from the least indented line that is<br>&gt;&gt;&gt;    not the first line and is not empty.<br>&gt;&gt;&gt;    2. A leading empty line is removed.<br>&gt;&gt;&gt;    3. The leading line, if there is any text in it, is not subject to<br>&gt;&gt;&gt;    de-indentation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I genuinely believe these three rules taken together address all the<br>&gt;&gt;&gt; errors and infelicities to which triple quotes and HEREDOCs subject us.<br>&gt;&gt;&gt; Here are some examples:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; text = &quot;&quot;&quot;<br>&gt;&gt;&gt;     Some<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   Features<br>&gt;&gt;&gt;     Are<br>&gt;&gt;&gt;     Discussed<br>&gt;&gt;&gt; &quot;&quot;&quot;# From (1): The indentation is taken from the third line below `text`, so it&#39;s 2.# From (2): First line is: &quot;\n&quot; so it is removed.# From (3): No effect.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; text = &quot;&quot;&quot;  Some<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;           Features<br>&gt;&gt;&gt;             Are<br>&gt;&gt;&gt;             Discussed<br>&gt;&gt;&gt; &quot;&quot;&quot;# From (1): The indentation is taken again from the line reading &quot;Features&quot;. Here it is 10.# From (2): No effect.# From (3): The leading whitespace in `  Some` is preserved.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Do you all think these rules pass muster?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A fourth rule — one which seems advisable but also less necessary than<br>&gt;&gt;&gt; the others — is that a string constructed in this way always ends with a<br>&gt;&gt;&gt; newline. It is a rule that perhaps leads to surprises and inconsistencies.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best Regards,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jason<br>&gt;&gt;&gt; ​<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/93351681/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December 11, 2015 at 06:00:00am</p></header><div class="content"><p>But I think str3 is what most of us want most of the time -- so why do we<br>have to pass options for it? Let the unusual cases have options.<br></p><p>On Thu, 10 Dec 2015 at 22:46 Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br></p><p>&gt; Just a thought: what about something more generalized &amp; explicit, like a<br>&gt; MultilineLiteral type (a.k.a. StaticString), and a String initializer with<br>&gt; parameters for the options:<br>&gt;<br>&gt; String.init(removeLeadingNewline: Bool = false, removeIndentation: Bool =<br>&gt; false, _ mulitilineLiteral: MultilineLiteral)<br>&gt;<br>&gt; let str = &quot;&quot;&quot;<br>&gt;    raw string; nothing changed<br>&gt; &quot;&quot;&quot;<br>&gt;<br>&gt; let str2 = String(removeLeadingNewline: true, &quot;&quot;&quot;<br>&gt;     leading newline is removed, but indentation remains<br>&gt; &quot;&quot;&quot;)<br>&gt;<br>&gt; let str3 = String(removeIndentation: true, &quot;&quot;&quot;<br>&gt;     leading newline remains, but as much indentation as possible is removed<br>&gt; &quot;&quot;&quot;)<br>&gt;<br>&gt;<br>&gt; (I&#39;m not a fan of the trailing close-paren, but can&#39;t really think of a<br>&gt; way around it. Maybe an exception like trailing-closure syntax for<br>&gt; trailing-multiline-literals?)<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Thu, Dec 10, 2015 at 10:38 PM, Jason Dusek via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Yeah, I can&#39;t say I am totally committed to the fourth one.<br>&gt;&gt;<br>&gt;<br>&gt;&gt; On Thu, 10 Dec 2015 at 22:34 Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I had been operating on the assumption that a leading blank line would<br>&gt;&gt;&gt; be stripped if present, since the syntax in code would look much cleaner,<br>&gt;&gt;&gt; but a trailing line would not since it would likely be intentional. I guess<br>&gt;&gt;&gt; that&#39;s another detail that would need to be fleshed out if we decide to go<br>&gt;&gt;&gt; with triple quote syntax (which, at this point, isn&#39;t a given... chris<br>&gt;&gt;&gt; lattner brings up some very good points that might require more involved,<br>&gt;&gt;&gt; potentially heredoc-like, syntax to solve).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Your fourth rule, however, I don&#39;t agree with at all. It should be<br>&gt;&gt;&gt; obvious from where you place the final quotes whether or not the string<br>&gt;&gt;&gt; includes a trailing newline. Just like in ruby, I believe in and value the<br>&gt;&gt;&gt; principle of least surprize.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Travis Tilley<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Dec 11, 2015 at 1:04 AM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Thu, 10 Dec 2015 at 21:45, Travis Tilley via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip<br>&gt;&gt;&gt;&gt;&gt; indentation if necessary. Technically, it searches for the &quot;least indented<br>&gt;&gt;&gt;&gt;&gt; line&quot; in the whole string, and removes exactly that amount from each line.<br>&gt;&gt;&gt;&gt;&gt; So yes, the indentation problem -is- solved in ruby (though it might break<br>&gt;&gt;&gt;&gt;&gt; entirely if you have empty lines, since the least indented line has no<br>&gt;&gt;&gt;&gt;&gt; indentation).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; To my mind, the rules should be:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    1. The indentation level is set from the least indented line that<br>&gt;&gt;&gt;&gt;    is not the first line and is not empty.<br>&gt;&gt;&gt;&gt;    2. A leading empty line is removed.<br>&gt;&gt;&gt;&gt;    3. The leading line, if there is any text in it, is not subject to<br>&gt;&gt;&gt;&gt;    de-indentation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I genuinely believe these three rules taken together address all the<br>&gt;&gt;&gt;&gt; errors and infelicities to which triple quotes and HEREDOCs subject us.<br>&gt;&gt;&gt;&gt; Here are some examples:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; text = &quot;&quot;&quot;<br>&gt;&gt;&gt;&gt;     Some<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   Features<br>&gt;&gt;&gt;&gt;     Are<br>&gt;&gt;&gt;&gt;     Discussed<br>&gt;&gt;&gt;&gt; &quot;&quot;&quot;# From (1): The indentation is taken from the third line below `text`, so it&#39;s 2.# From (2): First line is: &quot;\n&quot; so it is removed.# From (3): No effect.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; text = &quot;&quot;&quot;  Some<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;           Features<br>&gt;&gt;&gt;&gt;             Are<br>&gt;&gt;&gt;&gt;             Discussed<br>&gt;&gt;&gt;&gt; &quot;&quot;&quot;# From (1): The indentation is taken again from the line reading &quot;Features&quot;. Here it is 10.# From (2): No effect.# From (3): The leading whitespace in `  Some` is preserved.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Do you all think these rules pass muster?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A fourth rule — one which seems advisable but also less necessary than<br>&gt;&gt;&gt;&gt; the others — is that a string constructed in this way always ends with a<br>&gt;&gt;&gt;&gt; newline. It is a rule that perhaps leads to surprises and inconsistencies.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Best Regards,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jason<br>&gt;&gt;&gt;&gt; ​<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/1edba847/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>multi-line string literals</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 11, 2015 at 01:00:00am</p></header><div class="content"><p>I think I’d rather treat the multiline literal as a fenced block.<br></p><p>let text =<br>    &quot;&quot;&quot;<br>    The position of the first &quot; is where the indentation is considered the left-edge.<br>    <br>        This line is indented four spaces.<br></p><p>    <br></p><p><br>    If I want a newline at the end of the string, I simply put one.<br></p><p>    &quot;&quot;&quot;<br></p><p>This creates very easy rules to understand:<br></p><p>The position of the opening &quot;&quot;&quot; dictates the left-edge for indentation purposes.<br>It’s invalid to have any text on the lines that contain the start and stop tokens: &quot;&quot;&quot;<br>The start and stop tokens must be left-edge aligned.<br>Text cannot be in a column that preceding the column the tokens start on, unless it is only whitespace.<br></p><p>More examples:<br></p><p>let text =<br>    &quot;&quot;&quot; Invalid: This is not allowed.<br>    &quot;&quot;&quot;<br></p><p>let text = &quot;&quot;&quot; Invalid; edges are not aligned.<br>    <br>    &quot;&quot;&quot;<br></p><p>let text = &quot;&quot;&quot; <br>    Invalid: Text cannot start before the &quot;&quot;&quot; tokens.<br>    <br>           &quot;&quot;&quot;<br></p><p>let text = &quot;&quot;&quot; <br>           This is ok.<br>    <br>           &quot;&quot;&quot;<br></p><p>let text = &quot;&quot;&quot; <br>           Escaped characters are interpreted as normal: \n\n<br>           There will be two newlines above this string when rendered.<br>    <br>           &quot;&quot;&quot;<br></p><p>-David<br></p><p>&gt; On Dec 10, 2015, at 10:33 PM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I had been operating on the assumption that a leading blank line would be stripped if present, since the syntax in code would look much cleaner, but a trailing line would not since it would likely be intentional. I guess that&#39;s another detail that would need to be fleshed out if we decide to go with triple quote syntax (which, at this point, isn&#39;t a given... chris lattner brings up some very good points that might require more involved, potentially heredoc-like, syntax to solve).<br>&gt; <br>&gt; Your fourth rule, however, I don&#39;t agree with at all. It should be obvious from where you place the final quotes whether or not the string includes a trailing newline. Just like in ruby, I believe in and value the principle of least surprize. <br>&gt; <br>&gt; <br>&gt; - Travis Tilley<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 1:04 AM, Jason Dusek &lt;jason.dusek at gmail.com &lt;mailto:jason.dusek at gmail.com&gt;&gt; wrote:<br>&gt; On Thu, 10 Dec 2015 at 21:45, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip indentation if necessary. Technically, it searches for the &quot;least indented line&quot; in the whole string, and removes exactly that amount from each line. So yes, the indentation problem -is- solved in ruby (though it might break entirely if you have empty lines, since the least indented line has no indentation).<br>&gt; <br>&gt; <br>&gt; To my mind, the rules should be:<br>&gt; <br>&gt; The indentation level is set from the least indented line that is not the first line and is not empty.<br>&gt; A leading empty line is removed.<br>&gt; The leading line, if there is any text in it, is not subject to de-indentation.<br>&gt; I genuinely believe these three rules taken together address all the errors and infelicities to which triple quotes and HEREDOCs subject us. Here are some examples:<br>&gt; <br>&gt; text = &quot;&quot;&quot;<br>&gt;     Some<br>&gt; <br>&gt;   Features<br>&gt;     Are<br>&gt;     Discussed<br>&gt; &quot;&quot;&quot;<br>&gt; # From (1): The indentation is taken from the third line below `text`, so it&#39;s 2.<br>&gt; # From (2): First line is: &quot;\n&quot; so it is removed.<br>&gt; # From (3): No effect.<br>&gt; <br>&gt; text = &quot;&quot;&quot;  Some<br>&gt; <br>&gt;           Features<br>&gt;             Are<br>&gt;             Discussed<br>&gt; &quot;&quot;&quot;<br>&gt; # From (1): The indentation is taken again from the line reading &quot;Features&quot;. Here it is 10.<br>&gt; # From (2): No effect.<br>&gt; # From (3): The leading whitespace in `  Some` is preserved.<br>&gt; Do you all think these rules pass muster?<br>&gt; <br>&gt; A fourth rule — one which seems advisable but also less necessary than the others — is that a string constructed in this way always ends with a newline. It is a rule that perhaps leads to surprises and inconsistencies.<br>&gt; <br>&gt; Best Regards,<br>&gt; <br>&gt; Jason<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/4b5c4b2c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>multi-line string literals</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 01:00:00pm</p></header><div class="content"><p>This example will break easily when tabs are used for indentation or when<br>using refactoring tools to rename the variable:<br></p><p>let text = &quot;&quot;&quot;<br>           This is ok.<br></p><p>           &quot;&quot;&quot;<br></p><p>Rather I&#39;d suggest that when there is no newline before the opening<br>triple-quote then the indentation is ignored completely, like in the<br>example from Drew Crawford:<br></p><p>let sampleJSON = &quot;&quot;&quot;<br>{<br>  &quot;foo&quot;: &quot;bar&quot;,<br>  &quot;baz&quot;: &quot;bap\nbap&quot;<br>}<br>&quot;&quot;&quot;<br></p><p>This is great for cases where you don&#39;t need to care about indentation or<br>where you want to copy&amp;paste something without re-indenting it.<br>It also works fine no matter if the developer uses tabs or spaces for<br>indentation.<br></p><p>On Fri, Dec 11, 2015 at 10:26 AM, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think I’d rather treat the multiline literal as a fenced block.<br>&gt;<br>&gt; let text =<br>&gt;     &quot;&quot;&quot;<br>&gt;     The position of the first &quot; is where the indentation is considered<br>&gt; the left-edge.<br>&gt;<br>&gt;         This line is indented four spaces.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;     If I want a newline at the end of the string, I simply put one.<br>&gt;<br>&gt;     &quot;&quot;&quot;<br>&gt;<br>&gt; This creates very easy rules to understand:<br>&gt;<br>&gt;<br>&gt;    1. The position of the opening &quot;&quot;&quot; dictates the left-edge for<br>&gt;    indentation purposes.<br>&gt;    2. It’s invalid to have any text on the lines that contain the start<br>&gt;    and stop tokens: &quot;&quot;&quot;<br>&gt;    3. The start and stop tokens must be left-edge aligned.<br>&gt;    4. Text cannot be in a column that preceding the column the tokens<br>&gt;    start on, unless it is only whitespace.<br>&gt;<br>&gt;<br>&gt; More examples:<br>&gt;<br>&gt; let text =<br>&gt;     &quot;&quot;&quot; Invalid: This is not allowed.<br>&gt;     &quot;&quot;&quot;<br>&gt;<br>&gt; let text = &quot;&quot;&quot; Invalid; edges are not aligned.<br>&gt;<br>&gt;     &quot;&quot;&quot;<br>&gt;<br>&gt; let text = &quot;&quot;&quot;<br>&gt;     Invalid: Text cannot start before the &quot;&quot;&quot; tokens.<br>&gt;<br>&gt;            &quot;&quot;&quot;<br>&gt;<br>&gt; let text = &quot;&quot;&quot;<br>&gt;            This is ok.<br>&gt;<br>&gt;            &quot;&quot;&quot;<br>&gt;<br>&gt; let text = &quot;&quot;&quot;<br>&gt;            Escaped characters are interpreted as normal: \n\n<br>&gt;            There will be two newlines above this string when rendered.<br>&gt;<br>&gt;            &quot;&quot;&quot;<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Dec 10, 2015, at 10:33 PM, Travis Tilley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I had been operating on the assumption that a leading blank line would be<br>&gt; stripped if present, since the syntax in code would look much cleaner, but<br>&gt; a trailing line would not since it would likely be intentional. I guess<br>&gt; that&#39;s another detail that would need to be fleshed out if we decide to go<br>&gt; with triple quote syntax (which, at this point, isn&#39;t a given... chris<br>&gt; lattner brings up some very good points that might require more involved,<br>&gt; potentially heredoc-like, syntax to solve).<br>&gt;<br>&gt; Your fourth rule, however, I don&#39;t agree with at all. It should be obvious<br>&gt; from where you place the final quotes whether or not the string includes a<br>&gt; trailing newline. Just like in ruby, I believe in and value the principle<br>&gt; of least surprize.<br>&gt;<br>&gt;<br>&gt; - Travis Tilley<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 1:04 AM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Thu, 10 Dec 2015 at 21:45, Travis Tilley via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The ruby &lt;&lt;- heredoc syntax, unlike the &lt;&lt; heredoc syntax, will strip<br>&gt;&gt;&gt; indentation if necessary. Technically, it searches for the &quot;least indented<br>&gt;&gt;&gt; line&quot; in the whole string, and removes exactly that amount from each line.<br>&gt;&gt;&gt; So yes, the indentation problem -is- solved in ruby (though it might break<br>&gt;&gt;&gt; entirely if you have empty lines, since the least indented line has no<br>&gt;&gt;&gt; indentation).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; To my mind, the rules should be:<br>&gt;&gt;<br>&gt;&gt;    1. The indentation level is set from the least indented line that is<br>&gt;&gt;    not the first line and is not empty.<br>&gt;&gt;    2. A leading empty line is removed.<br>&gt;&gt;    3. The leading line, if there is any text in it, is not subject to<br>&gt;&gt;    de-indentation.<br>&gt;&gt;<br>&gt;&gt; I genuinely believe these three rules taken together address all the<br>&gt;&gt; errors and infelicities to which triple quotes and HEREDOCs subject us.<br>&gt;&gt; Here are some examples:<br>&gt;&gt;<br>&gt;&gt; text = &quot;&quot;&quot;<br>&gt;&gt;     Some<br>&gt;&gt;<br>&gt;&gt;   Features<br>&gt;&gt;     Are<br>&gt;&gt;     Discussed<br>&gt;&gt; &quot;&quot;&quot;# From (1): The indentation is taken from the third line below `text`, so it&#39;s 2.# From (2): First line is: &quot;\n&quot; so it is removed.# From (3): No effect.<br>&gt;&gt;<br>&gt;&gt; text = &quot;&quot;&quot;  Some<br>&gt;&gt;<br>&gt;&gt;           Features<br>&gt;&gt;             Are<br>&gt;&gt;             Discussed<br>&gt;&gt; &quot;&quot;&quot;# From (1): The indentation is taken again from the line reading &quot;Features&quot;. Here it is 10.# From (2): No effect.# From (3): The leading whitespace in `  Some` is preserved.<br>&gt;&gt;<br>&gt;&gt; Do you all think these rules pass muster?<br>&gt;&gt;<br>&gt;&gt; A fourth rule — one which seems advisable but also less necessary than<br>&gt;&gt; the others — is that a string constructed in this way always ends with a<br>&gt;&gt; newline. It is a rule that perhaps leads to surprises and inconsistencies.<br>&gt;&gt;<br>&gt;&gt; Best Regards,<br>&gt;&gt;<br>&gt;&gt; Jason<br>&gt;&gt; ​<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/de54869a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>multi-line string literals</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 11, 2015 at 08:00:00am</p></header><div class="content"><p>I really don’t like the left-edge being in the zero column as it is completely inconsistent with the formatting of the rest of the language.<br></p><p>class CommandLineTool {<br>    func showHelp() {<br>        let text =<br>            &quot;&quot;&quot; <br>            OVERVIEW: Swift compiler<br></p><p>            USAGE: swiftc [options] &lt;inputs&gt;<br></p><p>            MODES:<br>              -dump-ast        Parse and type-check input file(s) and dump AST(s)<br>              -dump-parse      Parse input file(s) and dump AST(s)<br>              -dump-type-refinement-contexts<br>                               Type-check input file(s) and dump type refinement contexts(s)<br>              -emit-assembly   Emit assembly file(s) (-S)<br>              -emit-bc         Emit LLVM BC file(s)<br></p><p>            ...<br></p><p>            &quot;&quot;&quot;<br></p><p>         print(text)<br>     }<br>}<br></p><p>What you’re suggesting is that the above code should be this:<br></p><p>class CommandLineTool {<br>    func showHelp() {<br>        let text = &quot;&quot;&quot; <br>OVERVIEW: Swift compiler<br></p><p>USAGE: swiftc [options] &lt;inputs&gt;<br></p><p>MODES:<br>  -dump-ast        Parse and type-check input file(s) and dump AST(s)<br>  -dump-parse      Parse input file(s) and dump AST(s)<br>  -dump-type-refinement-contexts<br>                   Type-check input file(s) and dump type refinement contexts(s)<br>  -emit-assembly   Emit assembly file(s) (-S)<br>  -emit-bc         Emit LLVM BC file(s)<br></p><p>...<br></p><p>&quot;&quot;&quot;<br></p><p>         print(text)<br>     }<br>}<br></p><p>That’s a compromise I’d rather not have to see in my code.<br></p><p>Another use case for this is for the content of test cases. Having many of these string literals within that file that are all left-edge aligned reduces the readability of the code.<br></p><p>-David<br></p><p>&gt; On Dec 11, 2015, at 4:20 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; This example will break easily when tabs are used for indentation or when using refactoring tools to rename the variable:<br>&gt; <br>&gt; let text = &quot;&quot;&quot; <br>&gt;            This is ok.<br>&gt;     <br>&gt;            &quot;&quot;&quot;<br></p><p>All that suggests is this form should be preferred:<br></p><p>let text =<br>    &quot;&quot;&quot; <br>    This is ok.<br>    &quot;&quot;&quot;<br></p><p><br>I write a lot of my text these days in markdown, so I’m pretty heavily influenced by the simplicity of that.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/86730146/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>multi-line string literals</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>What I suggest is to support both:<br></p><p>   - standalone triple-quote will use indentation as in your first example<br>   - triple-quote which is not stand-alone will use indentation as in your<br>   second example<br></p><p><br>On Fri, Dec 11, 2015 at 5:52 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br></p><p>&gt; I really don’t like the left-edge being in the zero column as it is<br>&gt; completely inconsistent with the formatting of the rest of the language.<br>&gt;<br>&gt; class CommandLineTool {<br>&gt;     func showHelp() {<br>&gt;         let text =<br>&gt;             &quot;&quot;&quot;<br>&gt;             OVERVIEW: Swift compiler<br>&gt;<br>&gt;             USAGE: swiftc [options] &lt;inputs&gt;<br>&gt;<br>&gt;             MODES:<br>&gt;               -dump-ast        Parse and type-check input file(s) and<br>&gt; dump AST(s)<br>&gt;               -dump-parse      Parse input file(s) and dump AST(s)<br>&gt;               -dump-type-refinement-contexts<br>&gt;                                Type-check input file(s) and dump type<br>&gt; refinement contexts(s)<br>&gt;               -emit-assembly   Emit assembly file(s) (-S)<br>&gt;               -emit-bc         Emit LLVM BC file(s)<br>&gt;<br>&gt;             ...<br>&gt;<br>&gt;             &quot;&quot;&quot;<br>&gt;<br>&gt;          print(text)<br>&gt;      }<br>&gt; }<br>&gt;<br>&gt; What you’re suggesting is that the above code should be this:<br>&gt;<br>&gt; class CommandLineTool {<br>&gt;     func showHelp() {<br>&gt;         let text = &quot;&quot;&quot;<br>&gt; OVERVIEW: Swift compiler<br>&gt;<br>&gt; USAGE: swiftc [options] &lt;inputs&gt;<br>&gt;<br>&gt; MODES:<br>&gt;   -dump-ast        Parse and type-check input file(s) and dump AST(s)<br>&gt;   -dump-parse      Parse input file(s) and dump AST(s)<br>&gt;   -dump-type-refinement-contexts<br>&gt;                    Type-check input file(s) and dump type refinement<br>&gt; contexts(s)<br>&gt;   -emit-assembly   Emit assembly file(s) (-S)<br>&gt;   -emit-bc         Emit LLVM BC file(s)<br>&gt;<br>&gt; ...<br>&gt;<br>&gt; &quot;&quot;&quot;<br>&gt;<br>&gt;          print(text)<br>&gt;      }<br>&gt; }<br>&gt;<br>&gt; That’s a compromise I’d rather not have to see in my code.<br>&gt;<br>&gt; Another use case for this is for the content of test cases. Having many of<br>&gt; these string literals within that file that are all left-edge aligned<br>&gt; reduces the readability of the code.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; On Dec 11, 2015, at 4:20 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt; This example will break easily when tabs are used for indentation or when<br>&gt; using refactoring tools to rename the variable:<br>&gt;<br>&gt; let text = &quot;&quot;&quot;<br>&gt;            This is ok.<br>&gt;<br>&gt;            &quot;&quot;&quot;<br>&gt;<br>&gt;<br>&gt; All that suggests is this form should be preferred:<br>&gt;<br>&gt; let text =<br>&gt;&gt;     &quot;&quot;&quot;<br>&gt;&gt;     This is ok.<br>&gt;&gt;     &quot;&quot;&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; I write a lot of my text these days in markdown, so I’m pretty heavily<br>&gt; influenced by the simplicity of that.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/c756aba2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 12:00:00am</p></header><div class="content"><p>On Fri, Dec 11, 2015 at 12:02 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; The reason I raise the question is that some languages have multiple quote<br>&gt; styles (Perl 5 has something like 3 or 4 different string literal styles<br>&gt; IIRC?) with different policies.  One reason for this is to disable<br>&gt; processing of escapes: if you’re using string literals to enter something<br>&gt; that uses \ or “ frequently, it can be irritating and ugly to have a lot of<br>&gt; \\&#39;s.  In some dialects of inline assembly in C, for example, this can<br>&gt; lead to very ugly code.<br>&gt;<br></p><p>​Since the suggestion is python style multi-line string literals, the only<br>valid terminator would be a triple quote, allowing the use of both &quot; and &#39;<br>within the literal without having to be escaped (or &quot;&quot; or &#39;&#39;, if you&#39;re<br>feeling perverse). As for anything else... I hadn&#39;t really thought of it.<br>​I&#39;d really need more feedback on the mailing list.<br></p><p>When introducing a feature like this, I think it would be useful to survey<br>&gt; a range of popular languages (and yes, even perl ;-) to understand what<br>&gt; facilities they provide and why (i.e. what problems they are solving) and<br>&gt; synthesize a good swift design that can solve the same problems with a<br>&gt; hopefully simple approach.<br>&gt;<br></p><p>​Perl and Erlang are unique in that valid code in either language looks<br>essentially like line noise. I&#39;d rather take inspiration from languages<br>like ruby, python, and elixir.​<br></p><p>Solving a variety of problems and use cases was not my original intention,<br>and will probably involve implementing full heredoc style syntax (or more).<br>If that&#39;s where you want the proposal to go, then that&#39;s where it will have<br>to go... but for myself, I don&#39;t need anything nearly that complex.​ I only<br>need multi-line string literals that behave the same as existing string<br>literals, only without the noise of &quot;foo\n&quot; + &quot;bar\n&quot; + &quot;baz\n&quot; + etc.<br></p><p>Understood, but our first goal is to get the best solution, independent of<br>&gt; implementation complexity.  In this case, I suspect that the hard part in<br>&gt; this feature is scoping it out and hashing out the right design with the<br>&gt; community.  I can’t imagine that we’d end up with a design that is that<br>&gt; difficult to implement in any case.<br>&gt;<br></p><p>​Fair enough. Lets give the idea some time to ferment and community members<br>time to chime in. ;)<br></p><p>As an aside, I am absolutely loving that Apple is making such an effort to<br>care about its community. This is something that I wouldn&#39;t have expected<br>just a few years ago and is amazing in my humblest of opinions. &lt;3<br></p><p><br>​- Travis Tilley<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/b5ae6ecb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 02:00:00am</p></header><div class="content"><p>Chris - due to the complexity involved, would it make sense to have<br>multiple proposals? One syntax need not fulfill the needs of every use<br>case. My immediate and personal concern is the simplest possible syntax for<br>multi-line string literals with no behavioral differences from normal<br>string literals other than 1) the ability to span multiple lines and 2) the<br>ability to contain unescaped quotes as long as they are not triple quotes.<br>As additional features, the potential indentation handling previously<br>discussed in this thread would be a massive bonus that&#39;d make life easier.<br></p><p>Additional proposals for full-on heredoc syntax with both indentation aware<br>and ignoring syntax (as is typical in other languages) could be made and<br>implemented separately.<br></p><p>I have no use for an escape-ignoring/escape-unrequiring syntax and would<br>have to leave that up to others to flesh out and/or implement. This would<br>make most sense with a heredoc style syntax where the terminator is a very<br>specific string.<br></p><p>I also have no use for specifying a dialect for a string, which Jordan Rose<br>suggests is useful for shaders, and have no idea how to implement such a<br>feature.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/c8e16295/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 11:07 PM, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt; <br>&gt; Chris - due to the complexity involved, would it make sense to have multiple proposals? One syntax need not fulfill the needs of every use case.<br></p><p>I’m not sure how to interpret this question.  Are you asking whether a proposal should start out simple, then have new things piled on top of it?  Or are you suggesting it would be better to have multiple new language features solving different problems?<br></p><p>In this case, my personal preference is to have a really well thought out long term vision for what we are doing in this space, and then subset the implementation to start with the simple pieces.  This avoids painting ourselves into a corner.  Further, I really hope we can avoid adding N new string literal syntaxes.  I see the existing one as the “simple” case, and the multiline case as the “advanced” case which can have knobs put on it for other advanced uses.<br></p><p>-Chris<br></p><p><br>&gt; My immediate and personal concern is the simplest possible syntax for multi-line string literals with no behavioral differences from normal string literals other than 1) the ability to span multiple lines and 2) the ability to contain unescaped quotes as long as they are not triple quotes. As additional features, the potential indentation handling previously discussed in this thread would be a massive bonus that&#39;d make life easier.<br>&gt; <br>&gt; Additional proposals for full-on heredoc syntax with both indentation aware and ignoring syntax (as is typical in other languages) could be made and implemented separately.<br>&gt; <br>&gt; I have no use for an escape-ignoring/escape-unrequiring syntax and would have to leave that up to others to flesh out and/or implement. This would make most sense with a heredoc style syntax where the terminator is a very specific string.<br>&gt; <br>&gt; I also have no use for specifying a dialect for a string, which Jordan Rose suggests is useful for shaders, and have no idea how to implement such a feature.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/7230d33e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 12:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 11:07 PM, Travis Tilley &lt;ttilley at gmail.com &lt;mailto:ttilley at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Chris - due to the complexity involved, would it make sense to have multiple proposals? One syntax need not fulfill the needs of every use case.<br>&gt; <br>&gt; I’m not sure how to interpret this question.  Are you asking whether a proposal should start out simple, then have new things piled on top of it?  Or are you suggesting it would be better to have multiple new language features solving different problems?<br>&gt; <br>&gt; In this case, my personal preference is to have a really well thought out long term vision for what we are doing in this space, and then subset the implementation to start with the simple pieces.  This avoids painting ourselves into a corner.  Further, I really hope we can avoid adding N new string literal syntaxes.  I see the existing one as the “simple” case, and the multiline case as the “advanced” case which can have knobs put on it for other advanced uses.<br></p><p>Catching up with the rest of this thread, here’s what I’d suggest:<br></p><p>- Please don’t extend simple “foo” strings to multiple lines.<br>- The ``` syntax is actually pretty interesting, I think that exploring it makes sense.  “”” doesn’t seem problematic to me though.<br>- Please consider ways that the string can have extensible options applied to it.  I haven’t thought much about this space, but the &quot;String literal suffixes for defining types” has some interesting ideas (though using prefixes instead of suffixes seems appealing as was pointed out in some email). <br>- I completely agree with Brent’s observation that we shouldn’t optimize for multi-line literals embedded into the middle of some other large expression.<br></p><p>The “configuration” aspect of this feature has come up several times.  It seems clear that the multi line literal has some obvious strong defaults: leading whitespace should be stripped, and escapes should be processed (including interpolation).  That said, being able to disable these independent of each other is important, and there are lots of other behaviors that can be considered as well.  I consider it a good thing for these behaviors to be explicit in the code.<br></p><p>As a strawman proposal (i.e. don’t take it seriously) to illustrate what I mean, you could use attributes for this, e.g. something like:<br></p><p>let foo = @disable_escape_processing ```<br>blah <br>blah<br> blah```<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/415fbd9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>I was thinking of keeping it really simple and having just a few main rules.<br></p><p>1) using &quot; means that the string contents are escaped<br>2) using &#39; means that the string contents are unescaped/raw<br>3) using &quot;&quot;&quot; or &#39;&#39;&#39; means that it&#39;s a multi-line string and indentation<br>erasure rules are in effect<br>4) indentation erasure is from the least indented line (from start of line,<br>not start of quote)<br>5) the first line, if it contains only a newline, is removed entirely (this<br>lets you just start your text on the next line)<br></p><p>I&#39;m wibbly wobbly about the last line containing only a newline. I&#39;m not<br>sure whether to err on the side of caution and assume it&#39;s intentional, or<br>remove it as well. At the moment I&#39;m leaning toward assuming it&#39;s<br>intentional.<br></p><p>I&#39;m also not entirely sure what to do in the case of mixed indentation. I<br>could absolutely see the leading indentation being tabs (with the editor<br>displaying them as equivalent to 4 spaces), but the slight indentation of<br>one to three characters being spaces.<br></p><p>Here is the SQL example for reference to show what I mean:<br></p><p>func findMentions(account: String) -&gt; Array&lt;String&gt; {<br>    let db = databaseFactory().findDatabase()<br>    let q = &#39;&#39;&#39;SELECT array_agg(mentioner.id)<br>                 FROM account<br>                 JOIN mention ON (account.id = mentioned)<br>                 JOIN account AS mentioner ON (mentioner.id = mentioner)<br>                WHERE account.handle = :1<br>                ORDER BY timestamp DESC<br>                LIMIT 1&#39;&#39;&#39;<br></p><p>    return db.query(q).parameterize(account).run()<br>}<br></p><p>​- Travis Tilley​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/57101ebf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; 2) using &#39; means that the string contents are unescaped/raw<br></p><p>I wonder if that&#39;s too subtle. Like Chris, I would prefer advanced knobs to be (i) more distinctive than &#39; vs &quot;, and possibly (ii) only attached to the advanced string type.<br></p><p>&gt; 5) the first line, if it contains only a newline, is removed entirely (this lets you just start your text on the next line)<br>&gt; <br>&gt; I&#39;m wibbly wobbly about the last line containing only a newline. I&#39;m not sure whether to err on the side of caution and assume it&#39;s intentional, or remove it as well. At the moment I&#39;m leaning toward assuming it&#39;s intentional.<br></p><p>I&#39;d say trim &#39;em all, because right now I&#39;m using ` literals in Go tests and trimming them like crazy, and I don&#39;t remember ever using a heredoc without passing it through trim.<br></p><p>&gt; 4) indentation erasure is from the least indented line (from start of line, not start of quote)<br>&gt; <br>&gt; I&#39;m also not entirely sure what to do in the case of mixed indentation. I could absolutely see the leading indentation being tabs (with the editor displaying them as equivalent to 4 spaces), but the slight indentation of one to three characters being spaces. <br></p><p>Ideally, a tab character would be a syntax error in Swift, period. Eat it, Go.<br></p><p>More realistically, you want to issue a syntax error if all non-empty lines don&#39;t share a common whitespace prefix that entirely covers at least one of the whitespace prefixes.<br></p><p>&gt; Here is the SQL example for reference to show what I mean:<br></p><p>To be fair, SQL doesn&#39;t care about the leading whitespace, so it would be quite fine with any sort of trimming we implement.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/a4bc53af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015 at 5:14 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt;<br>wrote:<br></p><p>&gt; 2) using &#39; means that the string contents are unescaped/raw<br>&gt;<br>&gt;<br>&gt; I wonder if that&#39;s too subtle. Like Chris, I would prefer advanced knobs<br>&gt; to be (i) more distinctive than &#39; vs &quot;, and possibly (ii) only attached to<br>&gt; the advanced string type.<br>&gt;<br></p><p>Anyone coming from ruby would feel right at home, but i&#39;m having trouble<br>finding precedent in any other language for that behavior. You may be right.<br></p><p>Ideally, a tab character would be a syntax error in Swift, period. Eat it,<br>&gt; Go.<br>&gt;<br>&gt; More realistically, you want to issue a syntax error if all non-empty<br>&gt; lines don&#39;t share a common whitespace prefix that entirely covers at least<br>&gt; one of the whitespace prefixes.<br>&gt;<br></p><p>​I don&#39;t think it&#39;s the language&#39;s job to enforce preferences here,<br>especially given that holy wars have been fought over indentation (as well<br>as things much less important). Having 3 lines all started by the same<br>number of tabs, but with two having spaces as well for sub-tab-length<br>indentation, should never be an error.<br></p><p><br>​-Travis Tilley<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/09e02168/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; I don&#39;t think it&#39;s the language&#39;s job to enforce preferences here, especially given that holy wars have been fought over indentation (as well as things much less important)<br></p><p>Actually, as Go shows (and perhaps the Ada&#39;s style checking mode a few decades before it), it&#39;s precisely the language&#39;s job, for exactly that reason. Any bikeshedding that can be avoided, should be. (I&#39;m also enjoying the Standard JavaScript movement of late.)<br></p><p>&gt; Having 3 lines all started by the same number of tabs, but with two having spaces as well for sub-tab-length indentation, should never be an error.<br></p><p>But to be clear, that wouldn&#39;t be an error in my proposed rule, which is, again (I wish I knew how to say this in a simpler way):<br></p><p>&gt; you want to issue a syntax error if all non-empty lines don&#39;t share a common whitespace prefix that entirely covers at least one of the whitespace prefixes.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/3a2e8edd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; 2) using &#39; means that the string contents are unescaped/raw<br>&gt; <br>&gt; I wonder if that&#39;s too subtle. Like Chris, I would prefer advanced knobs to be (i) more distinctive than &#39; vs &quot;, and possibly (ii) only attached to the advanced string type.<br>&gt; <br>&gt; Anyone coming from ruby would feel right at home, but i&#39;m having trouble finding precedent in any other language for that behavior. You may be right.<br></p><p>Ruby copied this feature from Perl, which copied it from Unix shells. (I will not attempt to untangle the history of Unix shells in order to figure out which one invented this.) I’m not necessarily saying it’s a good idea, but programming systems have been doing this for at least thirty years, and likely forty or more. There’s ample precedent.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>...you know, I&#39;ve been considering Bourne such a core part of the *nix<br>experience for so long that I didn&#39;t even think of it as a programming<br>language. It didn&#39;t even exist as a consideration in my mind. *shakes his<br>head*<br></p><p>Thank you.<br></p><p><br>-Travis Tilley<br></p><p><br>On Mon, Dec 14, 2015 at 5:38 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt;&gt; 2) using &#39; means that the string contents are unescaped/raw<br>&gt; &gt;<br>&gt; &gt; I wonder if that&#39;s too subtle. Like Chris, I would prefer advanced knobs<br>&gt; to be (i) more distinctive than &#39; vs &quot;, and possibly (ii) only attached to<br>&gt; the advanced string type.<br>&gt; &gt;<br>&gt; &gt; Anyone coming from ruby would feel right at home, but i&#39;m having trouble<br>&gt; finding precedent in any other language for that behavior. You may be right.<br>&gt;<br>&gt; Ruby copied this feature from Perl, which copied it from Unix shells. (I<br>&gt; will not attempt to untangle the history of Unix shells in order to figure<br>&gt; out which one invented this.) I’m not necessarily saying it’s a good idea,<br>&gt; but programming systems have been doing this for at least thirty years, and<br>&gt; likely forty or more. There’s ample precedent.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/3b5acb1b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015 at 5:27 PM, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br></p><p>&gt; On Mon, Dec 14, 2015 at 5:14 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; 2) using &#39; means that the string contents are unescaped/raw<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I wonder if that&#39;s too subtle. Like Chris, I would prefer advanced knobs<br>&gt;&gt; to be (i) more distinctive than &#39; vs &quot;, and possibly (ii) only attached to<br>&gt;&gt; the advanced string type.<br>&gt;&gt;<br>&gt;<br>&gt; Anyone coming from ruby would feel right at home, but i&#39;m having trouble<br>&gt; finding precedent in any other language for that behavior. You may be right.<br>&gt;<br></p><p>​Then again, similar behavior in python (prefixing a string with r to<br>qualify it as a &#39;raw&#39; string) would be completely unintuitive because<br>backslash behavior is... weird. For example, r&quot;\&quot; is not a valid string.<br>You can&#39;t have a string that&#39;s just a backslash just in case it can be<br>processed as an escape even though raw strings aren&#39;t supposed to process<br>escapes. Some other things are weird... So having blanket &quot;yes, it&#39;s really<br>raw&quot; behavior -might- be unintuitive for people coming from python.<br></p><p>BUT... And this is a massive but... It -would- tie into the discussion that<br>currently exists for typed literals (something i&#39;m currently mostly<br>ignorant of and would love to hear more about). Especially since it would<br>put the qualifier in front of the literal.<br></p><p><br>​-Travis Tilley<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/332768c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; BUT... And this is a massive but... It -would- tie into the discussion that currently exists for typed literals (something i&#39;m currently mostly ignorant of and would love to hear more about). Especially since it would put the qualifier in front of the literal.<br></p><p>I&#39;m basically expecting a prefix like r&#39;c:\program files\swift\swift.exe&#39; to be the best solution. :-)<br></p><p>And yes, would be nice to have other and user-defined prefixes, although I would say that it should wait until a proper macro support. A user-definable prefix *is* a simple form of a macro, after all.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/b2e5cb6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>StringLiteralConvertable is more than sufficient for bending string<br>literals to your will. There&#39;s already several libraries that make use of<br>that, plus custom operators, to implement regular expression literals. Lets<br>not get too carried away and stick to defining the syntax for the literal<br>itself... I&#39;m pretty sure the community will amaze us with what happens<br>afterwards and none of it will require macros.<br></p><p><br>​-Travis Tilley​<br></p><p><br></p><p>On Mon, Dec 14, 2015 at 5:51 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt;<br>wrote:<br></p><p>&gt; BUT... And this is a massive but... It -would- tie into the discussion<br>&gt; that currently exists for typed literals (something i&#39;m currently mostly<br>&gt; ignorant of and would love to hear more about). Especially since it would<br>&gt; put the qualifier in front of the literal.<br>&gt;<br>&gt;<br>&gt; I&#39;m basically expecting a prefix like r&#39;c:\program files\swift\swift.exe&#39;<br>&gt; to be the best solution. :-)<br>&gt;<br>&gt; And yes, would be nice to have other and user-defined prefixes, although I<br>&gt; would say that it should wait until a proper macro support. A<br>&gt; user-definable prefix *is* a simple form of a macro, after all.<br>&gt;<br>&gt; A.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/77526f24/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>What about the following proposal, I’m afraid I don’t know if it’s possible to implement, but it really represents everything that I would like to see in a multiline String solution because it has no special syntax and the results are extremely straight forward and non-magical.<br></p><p>let x =<br>&quot;This is a proposal for a multiline literal String in Swift. This syntax solves a number of problems that<br>&quot;are common in other language&#39;s implementations of multiline Strings. This syntax is meant to be a<br>&quot;a generalization of regular Swift literal Strings, whereby a String is considered to begin with an open quote<br>&quot;and continue indefinitely until and including the end of the line (newline character),<br>&quot;or the String is closed with an ending quote.<br>&quot;<br>&quot;Firstly, indentation is now very clear and explicit. It is easy to see what the resulting string will be.<br>&quot;   This is one level of indentation.<br>&quot;       This is two levels.<br>&quot;<br>&quot;Secondly, there is no need for newline character processesing since it is well defined what newline behavior<br>&quot;should be.<br>&quot;<br>&quot;If a newline should be present in the code, but not in the resulting String it can be escaped with &#39;\\&#39; \<br>&quot; like so.<br>&quot;<br>&quot;Alternatively, perhaps that behavior could be left out and still accomplished by appending Strings in the<br>&quot; normal way with + or implicitly concatonated by the complier. Like so:<br>&quot; This is a long single line literal String. This is a long single line literal String. This is a long single&quot;<br>&quot;line literal String.&quot;<br>&quot;<br>&quot;Thirdly, the indent level of these strings is decoupled from the indent level of the code, since there is a<br>        &quot;well defined starting point for the String on each line.<br>    &quot;   Thus you can indent the code and the string independently.<br>&quot;<br>&quot;Lastly, I don&#39;t actually know if this is even possible to implement. I don&#39;t know if these creates ambiguities<br>&quot;for the compiler, but it doesn&#39;t seem like it does at first glance.<br></p><p>This would require that adjacent Strings are automatically appended to each other by the compiler, (e.g. let x = “blah” “blah”, would be valid and x would equal “blahblah”. I don’t know how others would feel about something like this, but I’ve always wanted this behavior in multiline Strings. Perhaps I’ve forgotten some edge cases?<br></p><p>Tyler<br></p><p>&gt; On Dec 14, 2015, at 12:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 12:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 11:07 PM, Travis Tilley &lt;ttilley at gmail.com &lt;mailto:ttilley at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Chris - due to the complexity involved, would it make sense to have multiple proposals? One syntax need not fulfill the needs of every use case.<br>&gt;&gt; <br>&gt;&gt; I’m not sure how to interpret this question.  Are you asking whether a proposal should start out simple, then have new things piled on top of it?  Or are you suggesting it would be better to have multiple new language features solving different problems?<br>&gt;&gt; <br>&gt;&gt; In this case, my personal preference is to have a really well thought out long term vision for what we are doing in this space, and then subset the implementation to start with the simple pieces.  This avoids painting ourselves into a corner.  Further, I really hope we can avoid adding N new string literal syntaxes.  I see the existing one as the “simple” case, and the multiline case as the “advanced” case which can have knobs put on it for other advanced uses.<br>&gt; <br>&gt; Catching up with the rest of this thread, here’s what I’d suggest:<br>&gt; <br>&gt; - Please don’t extend simple “foo” strings to multiple lines.<br>&gt; - The ``` syntax is actually pretty interesting, I think that exploring it makes sense.  “”” doesn’t seem problematic to me though.<br>&gt; - Please consider ways that the string can have extensible options applied to it.  I haven’t thought much about this space, but the &quot;String literal suffixes for defining types” has some interesting ideas (though using prefixes instead of suffixes seems appealing as was pointed out in some email). <br>&gt; - I completely agree with Brent’s observation that we shouldn’t optimize for multi-line literals embedded into the middle of some other large expression.<br>&gt; <br>&gt; The “configuration” aspect of this feature has come up several times.  It seems clear that the multi line literal has some obvious strong defaults: leading whitespace should be stripped, and escapes should be processed (including interpolation).  That said, being able to disable these independent of each other is important, and there are lots of other behaviors that can be considered as well.  I consider it a good thing for these behaviors to be explicit in the code.<br>&gt; <br>&gt; As a strawman proposal (i.e. don’t take it seriously) to illustrate what I mean, you could use attributes for this, e.g. something like:<br>&gt; <br>&gt; let foo = @disable_escape_processing ```<br>&gt; blah <br>&gt; blah<br>&gt;  blah```<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/6c038673/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>Also the concern about <br></p><p>let x = “foo<br></p><p>would not be a problem with this proposal since only the currently line plus the new line character would be considered part of the String. The weird thing here is that this would be valid syntax and x would be “foo\n”. Which is not so good.<br></p><p>Tyler<br></p><p>&gt; On Dec 14, 2015, at 1:50 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about the following proposal, I’m afraid I don’t know if it’s possible to implement, but it really represents everything that I would like to see in a multiline String solution because it has no special syntax and the results are extremely straight forward and non-magical.<br>&gt; <br>&gt; let x =<br>&gt; &quot;This is a proposal for a multiline literal String in Swift. This syntax solves a number of problems that<br>&gt; &quot;are common in other language&#39;s implementations of multiline Strings. This syntax is meant to be a<br>&gt; &quot;a generalization of regular Swift literal Strings, whereby a String is considered to begin with an open quote<br>&gt; &quot;and continue indefinitely until and including the end of the line (newline character),<br>&gt; &quot;or the String is closed with an ending quote.<br>&gt; &quot;<br>&gt; &quot;Firstly, indentation is now very clear and explicit. It is easy to see what the resulting string will be.<br>&gt; &quot;   This is one level of indentation.<br>&gt; &quot;       This is two levels.<br>&gt; &quot;<br>&gt; &quot;Secondly, there is no need for newline character processesing since it is well defined what newline behavior<br>&gt; &quot;should be.<br>&gt; &quot;<br>&gt; &quot;If a newline should be present in the code, but not in the resulting String it can be escaped with &#39;\\&#39; &lt;smb://&#39;&gt; \<br>&gt; &quot; like so.<br>&gt; &quot;<br>&gt; &quot;Alternatively, perhaps that behavior could be left out and still accomplished by appending Strings in the<br>&gt; &quot; normal way with + or implicitly concatonated by the complier. Like so:<br>&gt; &quot; This is a long single line literal String. This is a long single line literal String. This is a long single&quot;<br>&gt; &quot;line literal String.&quot;<br>&gt; &quot;<br>&gt; &quot;Thirdly, the indent level of these strings is decoupled from the indent level of the code, since there is a<br>&gt;         &quot;well defined starting point for the String on each line.<br>&gt;     &quot;   Thus you can indent the code and the string independently.<br>&gt; &quot;<br>&gt; &quot;Lastly, I don&#39;t actually know if this is even possible to implement. I don&#39;t know if these creates ambiguities<br>&gt; &quot;for the compiler, but it doesn&#39;t seem like it does at first glance.<br>&gt; <br>&gt; This would require that adjacent Strings are automatically appended to each other by the compiler, (e.g. let x = “blah” “blah”, would be valid and x would equal “blahblah”. I don’t know how others would feel about something like this, but I’ve always wanted this behavior in multiline Strings. Perhaps I’ve forgotten some edge cases?<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 12:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 12:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 11:07 PM, Travis Tilley &lt;ttilley at gmail.com &lt;mailto:ttilley at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Chris - due to the complexity involved, would it make sense to have multiple proposals? One syntax need not fulfill the needs of every use case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure how to interpret this question.  Are you asking whether a proposal should start out simple, then have new things piled on top of it?  Or are you suggesting it would be better to have multiple new language features solving different problems?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case, my personal preference is to have a really well thought out long term vision for what we are doing in this space, and then subset the implementation to start with the simple pieces.  This avoids painting ourselves into a corner.  Further, I really hope we can avoid adding N new string literal syntaxes.  I see the existing one as the “simple” case, and the multiline case as the “advanced” case which can have knobs put on it for other advanced uses.<br>&gt;&gt; <br>&gt;&gt; Catching up with the rest of this thread, here’s what I’d suggest:<br>&gt;&gt; <br>&gt;&gt; - Please don’t extend simple “foo” strings to multiple lines.<br>&gt;&gt; - The ``` syntax is actually pretty interesting, I think that exploring it makes sense.  “”” doesn’t seem problematic to me though.<br>&gt;&gt; - Please consider ways that the string can have extensible options applied to it.  I haven’t thought much about this space, but the &quot;String literal suffixes for defining types” has some interesting ideas (though using prefixes instead of suffixes seems appealing as was pointed out in some email). <br>&gt;&gt; - I completely agree with Brent’s observation that we shouldn’t optimize for multi-line literals embedded into the middle of some other large expression.<br>&gt;&gt; <br>&gt;&gt; The “configuration” aspect of this feature has come up several times.  It seems clear that the multi line literal has some obvious strong defaults: leading whitespace should be stripped, and escapes should be processed (including interpolation).  That said, being able to disable these independent of each other is important, and there are lots of other behaviors that can be considered as well.  I consider it a good thing for these behaviors to be explicit in the code.<br>&gt;&gt; <br>&gt;&gt; As a strawman proposal (i.e. don’t take it seriously) to illustrate what I mean, you could use attributes for this, e.g. something like:<br>&gt;&gt; <br>&gt;&gt; let foo = @disable_escape_processing ```<br>&gt;&gt; blah <br>&gt;&gt; blah<br>&gt;&gt;  blah```<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/aacb4b74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>Also copying and pasting is not so fun, unless the beginning quotes were automatically added by the IDE.<br></p><p>Tyler<br></p><p><br>&gt; On Dec 14, 2015, at 1:53 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt; Also the concern about <br>&gt; <br>&gt; let x = “foo<br>&gt; <br>&gt; would not be a problem with this proposal since only the currently line plus the new line character would be considered part of the String. The weird thing here is that this would be valid syntax and x would be “foo\n”. Which is not so good.<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 1:50 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about the following proposal, I’m afraid I don’t know if it’s possible to implement, but it really represents everything that I would like to see in a multiline String solution because it has no special syntax and the results are extremely straight forward and non-magical.<br>&gt;&gt; <br>&gt;&gt; let x =<br>&gt;&gt; &quot;This is a proposal for a multiline literal String in Swift. This syntax solves a number of problems that<br>&gt;&gt; &quot;are common in other language&#39;s implementations of multiline Strings. This syntax is meant to be a<br>&gt;&gt; &quot;a generalization of regular Swift literal Strings, whereby a String is considered to begin with an open quote<br>&gt;&gt; &quot;and continue indefinitely until and including the end of the line (newline character),<br>&gt;&gt; &quot;or the String is closed with an ending quote.<br>&gt;&gt; &quot;<br>&gt;&gt; &quot;Firstly, indentation is now very clear and explicit. It is easy to see what the resulting string will be.<br>&gt;&gt; &quot;   This is one level of indentation.<br>&gt;&gt; &quot;       This is two levels.<br>&gt;&gt; &quot;<br>&gt;&gt; &quot;Secondly, there is no need for newline character processesing since it is well defined what newline behavior<br>&gt;&gt; &quot;should be.<br>&gt;&gt; &quot;<br>&gt;&gt; &quot;If a newline should be present in the code, but not in the resulting String it can be escaped with &#39;\\&#39; &lt;smb://&#39;&gt; \<br>&gt;&gt; &quot; like so.<br>&gt;&gt; &quot;<br>&gt;&gt; &quot;Alternatively, perhaps that behavior could be left out and still accomplished by appending Strings in the<br>&gt;&gt; &quot; normal way with + or implicitly concatonated by the complier. Like so:<br>&gt;&gt; &quot; This is a long single line literal String. This is a long single line literal String. This is a long single&quot;<br>&gt;&gt; &quot;line literal String.&quot;<br>&gt;&gt; &quot;<br>&gt;&gt; &quot;Thirdly, the indent level of these strings is decoupled from the indent level of the code, since there is a<br>&gt;&gt;         &quot;well defined starting point for the String on each line.<br>&gt;&gt;     &quot;   Thus you can indent the code and the string independently.<br>&gt;&gt; &quot;<br>&gt;&gt; &quot;Lastly, I don&#39;t actually know if this is even possible to implement. I don&#39;t know if these creates ambiguities<br>&gt;&gt; &quot;for the compiler, but it doesn&#39;t seem like it does at first glance.<br>&gt;&gt; <br>&gt;&gt; This would require that adjacent Strings are automatically appended to each other by the compiler, (e.g. let x = “blah” “blah”, would be valid and x would equal “blahblah”. I don’t know how others would feel about something like this, but I’ve always wanted this behavior in multiline Strings. Perhaps I’ve forgotten some edge cases?<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 12:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 14, 2015, at 12:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 11:07 PM, Travis Tilley &lt;ttilley at gmail.com &lt;mailto:ttilley at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Chris - due to the complexity involved, would it make sense to have multiple proposals? One syntax need not fulfill the needs of every use case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure how to interpret this question.  Are you asking whether a proposal should start out simple, then have new things piled on top of it?  Or are you suggesting it would be better to have multiple new language features solving different problems?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case, my personal preference is to have a really well thought out long term vision for what we are doing in this space, and then subset the implementation to start with the simple pieces.  This avoids painting ourselves into a corner.  Further, I really hope we can avoid adding N new string literal syntaxes.  I see the existing one as the “simple” case, and the multiline case as the “advanced” case which can have knobs put on it for other advanced uses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Catching up with the rest of this thread, here’s what I’d suggest:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Please don’t extend simple “foo” strings to multiple lines.<br>&gt;&gt;&gt; - The ``` syntax is actually pretty interesting, I think that exploring it makes sense.  “”” doesn’t seem problematic to me though.<br>&gt;&gt;&gt; - Please consider ways that the string can have extensible options applied to it.  I haven’t thought much about this space, but the &quot;String literal suffixes for defining types” has some interesting ideas (though using prefixes instead of suffixes seems appealing as was pointed out in some email). <br>&gt;&gt;&gt; - I completely agree with Brent’s observation that we shouldn’t optimize for multi-line literals embedded into the middle of some other large expression.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The “configuration” aspect of this feature has come up several times.  It seems clear that the multi line literal has some obvious strong defaults: leading whitespace should be stripped, and escapes should be processed (including interpolation).  That said, being able to disable these independent of each other is important, and there are lots of other behaviors that can be considered as well.  I consider it a good thing for these behaviors to be explicit in the code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a strawman proposal (i.e. don’t take it seriously) to illustrate what I mean, you could use attributes for this, e.g. something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let foo = @disable_escape_processing ```<br>&gt;&gt;&gt; blah <br>&gt;&gt;&gt; blah<br>&gt;&gt;&gt;  blah```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/97081e53/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; let x =<br>&gt; &quot;This is a proposal for a multiline literal String in Swift. This syntax solves a number of problems that<br>&gt; &quot;are common in other language&#39;s implementations of multiline Strings. This syntax is meant to be a<br>&gt; &quot;a generalization of regular Swift literal Strings, whereby a String is considered to begin with an open quote<br>&gt; &quot;and continue indefinitely until and including the end of the line (newline character),<br>&gt; &quot;or the String is closed with an ending quote.<br></p><p>Damn, why didn’t I think of that? It’s something like my email-style syntax, but based on regular English punctuation conventions instead of Internet ones. (I assume, incidentally, that there’s meant to be a closing quote on the last line, and it would be a syntax error if there weren’t.) <br></p><p>You would want a “toggle line quoting” command in your editor, the same way many editors have a “toggle commenting” commandz. In Xcode, the natural keystroke would be Cmd-‘ or Cmd-&quot;, but that’s currently used for Jump to Next Issue/Jump to Previous Issue. If this feature is added, hopefully the Xcode guys see how much this needs that mapping.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>Yes, you are right, Brent, there should be a closing quote on the last line otherwise it would be a syntax error. That’s a much better idea! That would also fix the <br></p><p>let x = “foo<br></p><p>being valid syntax problem.<br></p><p>Tyler<br></p><p><br>&gt; On Dec 14, 2015, at 2:10 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; let x =<br>&gt;&gt; &quot;This is a proposal for a multiline literal String in Swift. This syntax solves a number of problems that<br>&gt;&gt; &quot;are common in other language&#39;s implementations of multiline Strings. This syntax is meant to be a<br>&gt;&gt; &quot;a generalization of regular Swift literal Strings, whereby a String is considered to begin with an open quote<br>&gt;&gt; &quot;and continue indefinitely until and including the end of the line (newline character),<br>&gt;&gt; &quot;or the String is closed with an ending quote.<br>&gt; <br>&gt; Damn, why didn’t I think of that? It’s something like my email-style syntax, but based on regular English punctuation conventions instead of Internet ones. (I assume, incidentally, that there’s meant to be a closing quote on the last line, and it would be a syntax error if there weren’t.) <br>&gt; <br>&gt; You would want a “toggle line quoting” command in your editor, the same way many editors have a “toggle commenting” commandz. In Xcode, the natural keystroke would be Cmd-‘ or Cmd-&quot;, but that’s currently used for Jump to Next Issue/Jump to Previous Issue. If this feature is added, hopefully the Xcode guys see how much this needs that mapping.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; Yes, you are right, Brent, there should be a closing quote on the last line otherwise it would be a syntax error. That’s a much better idea! That would also fix the <br>&gt; <br>&gt; let x = “foo<br>&gt; <br>&gt; being valid syntax problem.<br></p><p><br>Guys, you know this is crazy, right? :-)<br></p><p>1) copy &amp; paste would be really annoying (on that note, Xcode should totally get multiple cursors support like in Sublime)<br></p><p>2) any non-specialized syntax highlighter would parse them all completely incorrectly, which is not a show-stopper, but shouldn&#39;t be taken lightly. (Think a generic indented code block in Markdown on GitHub.)<br></p><p>3) it&#39;s just cruel — https://xkcd.com/859/<br></p><p><br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/78af7c25/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: (.png<br>Type: image/png<br>Size: 8714 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/78af7c25/attachment.png&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 2:21 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt;&gt; Yes, you are right, Brent, there should be a closing quote on the last line otherwise it would be a syntax error. That’s a much better idea! That would also fix the <br>&gt;&gt; <br>&gt;&gt; let x = “foo<br>&gt;&gt; <br>&gt;&gt; being valid syntax problem.<br>&gt; <br>&gt; <br>&gt; Guys, you know this is crazy, right? :-)<br>&gt; <br>&gt; 1) copy &amp; paste would be really annoying (on that note, Xcode should totally get multiple cursors support like in Sublime)<br>&gt; <br>&gt; 2) any non-specialized syntax highlighter would parse them all completely incorrectly, which is not a show-stopper, but shouldn&#39;t be taken lightly. (Think a generic indented code block in Markdown on GitHub.)<br>&gt; <br>&gt; 3) it&#39;s just cruel — https://xkcd.com/859/ &lt;https://xkcd.com/859/&gt;<br>&gt; <br></p><p>Haha, perhaps it is cruel. Just think of it as a closing quote out at infinity. ;-)<br></p><p>Tyler<br></p><p>&gt; &lt;(.png&gt;<br>&gt; <br>&gt; A.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/827c8a62/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; 3) it&#39;s just cruel — https://xkcd.com/859/<br></p><p>Only if your mental parser doesn’t match Swift’s. :^)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>multi-line string literals</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 15, 2015 at 04:00:00pm</p></header><div class="content"><p>@1: Or Xcode could simply continue the string if you hit enter without terminating it. (Same if you open a string literal, and then paste a multiline text)<br>To copy out of Xcode, use alt-click selection to cut away leading &quot;.<br></p><p>@2: +1<br></p><p>@3: +1. Don&#39;t see the point why this should be better than simply adding strings up with +.<br></p><p><br>Generally, I&#39;m kind of sceptical about this. Especially trailing whitespace becomes invisible.<br>You don&#39;t know if your editor cuts out trailing whitespace. You no longer see where each line ends.<br></p><p>Maybe with Xcode, the IDE could display kind of a rectangle that shows what&#39;s the left / right border of each line<br>(maybe background color the parts that are within the string, so you actually see trailing whitespace).<br></p><p>Still, even then I fail to see the real need for multiline string literals if you assume that your IDE is smart enough<br>to detect whether you are editing a string, and to automatically insert the &quot; +  on the current line and the indentation &quot; on the next line<br>when you press enter or paste a multiline text in that context.<br></p><p><br>-1 for Heredoc proposal. It&#39;s just ugly, and even in languages that have it (e.g. PHP) I&#39;ve never seen it used in current code,<br>with the exception of XML (where it&#39;s the only option I guess).<br></p><p><br></p><p><br>As for escaping vs non-escaping, just adding a few other languages as reference.<br></p><p>PHP uses &quot; ... &quot; to denote strings with interpolation and \n transformation etc., and &#39; ... &#39; for verbatim strings.<br>C# uses &quot; ... &quot; for normal strings and @&quot; ... &quot; for verbatim strings (e.g. Windows paths that incorporate lots of \).<br></p><p><br>Etan<br></p><p><br>&gt; On 14 Dec 2015, at 23:21, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Yes, you are right, Brent, there should be a closing quote on the last line otherwise it would be a syntax error. That’s a much better idea! That would also fix the<br>&gt;&gt; <br>&gt;&gt; let x = “foo<br>&gt;&gt; <br>&gt;&gt; being valid syntax problem.<br>&gt; <br>&gt; <br>&gt; Guys, you know this is crazy, right? :-)<br>&gt; <br>&gt; 1) copy &amp; paste would be really annoying (on that note, Xcode should totally get multiple cursors support like in Sublime)<br>&gt; <br>&gt; 2) any non-specialized syntax highlighter would parse them all completely incorrectly, which is not a show-stopper, but shouldn&#39;t be taken lightly. (Think a generic indented code block in Markdown on GitHub.)<br>&gt; <br>&gt; 3) it&#39;s just cruel — https://xkcd.com/859/ &lt;https://xkcd.com/859/&gt;<br>&gt; <br>&gt; &lt;(.png&gt;<br>&gt; <br>&gt; A.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/50fda5a8/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/50fda5a8/attachment.sig&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Yes, you are right, Brent, there should be a closing quote on the last line otherwise it would be a syntax error. That’s a much better idea! That would also fix the <br>&gt; <br>&gt; let x = “foo<br>&gt; <br>&gt; being valid syntax problem.<br></p><p>So, based on this idea, here’s what I propose. We have two orthogonal features:<br></p><p>ADJUSTABLE DELIMITERS:<br></p><p>Any odd number of “ characters can be used to delimit a quoted string. That means you can start and end one with “, “””, “””””, “””””””, etc. (In practice, more than three would probably only be used when generating code which itself includes multiline strings.) This only affects how many quotes in a row you have to backslash inside the string; it does not imply the string is multiline.<br></p><p>MULTILINE STRINGS:<br></p><p>If a quoted string does not terminate by the end of the line, Swift examines the next line of code. If that line starts with zero or more whitespace characters, followed by the same string delimiter used to open the string on the previous line, then the string literal includes the newline character at the end of the previous line and then continues on the next line.<br></p><p>If the next line has anything else before the delimiter—including a string delimiter which is not long enough, a comment, or a newline—Swift concludes that the string does not continue onto this line and emits an unterminated string error on the previous line. Thus, an unterminated multi-line string is always detectable in and of itself.<br></p><p>Swift does not do any other special processing of the string, like removing indentation (all indentation should be before the string delimiter on that line) or trimming newlines at the beginning or end. All escapes function as normal; any modification of escaping is reserved for other mechanisms outside the scope of this thread.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 15, 2015 at 04:00:00pm</p></header><div class="content"><p>On Dec 14, 2015, at 3:51 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; Yes, you are right, Brent, there should be a closing quote on the last line otherwise it would be a syntax error. That’s a much better idea! That would also fix the <br>&gt;&gt; <br>&gt;&gt; let x = “foo<br>&gt;&gt; <br>&gt;&gt; being valid syntax problem.<br>&gt; <br>&gt; So, based on this idea, here’s what I propose. We have two orthogonal features:<br>&gt; <br>&gt; ADJUSTABLE DELIMITERS:<br>&gt; <br>&gt; Any odd number of “ characters can be used to delimit a quoted string. That means you can start and end one with “, “””, “””””, “””””””, etc. (In practice, more than three would probably only be used when generating code which itself includes multiline strings.) This only affects how many quotes in a row you have to backslash inside the string; it does not imply the string is multiline.<br></p><p>This is an interesting approach to avoid having to escape “’s in some common situations.  One corner case: how do you write a string literal that starts or ends with “?    How do you express the equivalent of “\”foo”?  A concern is that this could make escape processing “feel” less predictable.<br></p><p>&gt; MULTILINE STRINGS:<br>&gt; <br>&gt; If a quoted string does not terminate by the end of the line, Swift examines the next line of code. If that line starts with zero or more whitespace characters, followed by the same string delimiter used to open the string on the previous line, then the string literal includes the newline character at the end of the previous line and then continues on the next line.<br>&gt; <br>&gt; If the next line has anything else before the delimiter—including a string delimiter which is not long enough, a comment, or a newline—Swift concludes that the string does not continue onto this line and emits an unterminated string error on the previous line. Thus, an unterminated multi-line string is always detectable in and of itself.<br>&gt; <br>&gt; Swift does not do any other special processing of the string, like removing indentation (all indentation should be before the string delimiter on that line) or trimming newlines at the beginning or end. All escapes function as normal; any modification of escaping is reserved for other mechanisms outside the scope of this thread.<br></p><p>This sounds very interesting, and could be workable, I agree that this solves the error recovery problem.  I still think we’d want a way to disable escape processing.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 15, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; One corner case: how do you write a string literal that starts or ends with “?    How do you express the equivalent of “\”foo”?  A concern is that this could make escape processing “feel” less predictable.<br></p><p>Technically, the rule that there must be an odd number of double-quotes in the delimiter solves this: `“”””foo”””` can only be interpreted as `”foo` delimited by `“””`. But that’s obviously not an ideal answer.<br></p><p>One possibility is that, when you use a multi-character string literal delimiter, you could insert a single whitespace character after the opening delimiter (and any continuations on other lines), and before the terminating delimiter:<br></p><p>	let foo = &quot;&quot;&quot; &quot;To be, or not to be;<br>	          &quot;&quot;&quot;  That is the question.&quot; &quot;”&quot; <br>	// =&gt; “\”To be, or not to be;\n that is the question.\”&quot;<br></p><p>To keep this from introducing ambiguity about whitespace stripping, the space would be required, and its absence would trigger a syntax error. I’m not totally satisfied with this approach, though.<br></p><p>&gt; I still think we’d want a way to disable escape processing.<br></p><p>I agree, but I think it’s orthogonal to this proposal. Whether we use `’foo&#39;`, or `r”foo”`, or `@“foo”` (following C#), or `@raw “foo”`, that can easily extend to multiline and long-delimiter strings.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>multi-line string literals</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>I like the idea of simple line prefixes, as often my reason for wanting a multi-line string literal is to express a formatted ‘screen’ of text (such as a command line help output). <br></p><p>Perhaps we can use an initial character other than double-quote to indicate a multi-line string in order to improve any ambiguity with the compiler? I think single quote is even available.<br></p><p>However, I think multi-line strings make the ability to disable escaping/interpolation more important, as there is a higher chance of a block of text just copy/pasted into place.<br></p><p>This does create issues for statement completion on the previous line, for instance you would likely need to do<br></p><p>	return “”+<br>	“Hello, World<br></p><p>-DW<br></p><p>&gt; On Dec 14, 2015, at 2:50 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about the following proposal, I’m afraid I don’t know if it’s possible to implement, but it really represents everything that I would like to see in a multiline String solution because it has no special syntax and the results are extremely straight forward and non-magical.<br>&gt; <br>&gt; let x =<br>&gt; &quot;This is a proposal for a multiline literal String in Swift. This syntax solves a number of problems that<br>&gt; &quot;are common in other language&#39;s implementations of multiline Strings. This syntax is meant to be a<br>&gt; &quot;a generalization of regular Swift literal Strings, whereby a String is considered to begin with an open quote<br>&gt; &quot;and continue indefinitely until and including the end of the line (newline character),<br>&gt; &quot;or the String is closed with an ending quote.<br>&gt; &quot;<br>&gt; &quot;Firstly, indentation is now very clear and explicit. It is easy to see what the resulting string will be.<br>&gt; &quot;   This is one level of indentation.<br>&gt; &quot;       This is two levels.<br>&gt; &quot;<br>&gt; &quot;Secondly, there is no need for newline character processesing since it is well defined what newline behavior<br>&gt; &quot;should be.<br>&gt; &quot;<br>&gt; &quot;If a newline should be present in the code, but not in the resulting String it can be escaped with &#39;\\&#39; &lt;smb://&#39;&gt; \<br>&gt; &quot; like so.<br>&gt; &quot;<br>&gt; &quot;Alternatively, perhaps that behavior could be left out and still accomplished by appending Strings in the<br>&gt; &quot; normal way with + or implicitly concatonated by the complier. Like so:<br>&gt; &quot; This is a long single line literal String. This is a long single line literal String. This is a long single&quot;<br>&gt; &quot;line literal String.&quot;<br>&gt; &quot;<br>&gt; &quot;Thirdly, the indent level of these strings is decoupled from the indent level of the code, since there is a<br>&gt;         &quot;well defined starting point for the String on each line.<br>&gt;     &quot;   Thus you can indent the code and the string independently.<br>&gt; &quot;<br>&gt; &quot;Lastly, I don&#39;t actually know if this is even possible to implement. I don&#39;t know if these creates ambiguities<br>&gt; &quot;for the compiler, but it doesn&#39;t seem like it does at first glance.<br>&gt; <br>&gt; This would require that adjacent Strings are automatically appended to each other by the compiler, (e.g. let x = “blah” “blah”, would be valid and x would equal “blahblah”. I don’t know how others would feel about something like this, but I’ve always wanted this behavior in multiline Strings. Perhaps I’ve forgotten some edge cases?<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 12:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 12:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 11:07 PM, Travis Tilley &lt;ttilley at gmail.com &lt;mailto:ttilley at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Chris - due to the complexity involved, would it make sense to have multiple proposals? One syntax need not fulfill the needs of every use case. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure how to interpret this question.  Are you asking whether a proposal should start out simple, then have new things piled on top of it?  Or are you suggesting it would be better to have multiple new language features solving different problems?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case, my personal preference is to have a really well thought out long term vision for what we are doing in this space, and then subset the implementation to start with the simple pieces.  This avoids painting ourselves into a corner.  Further, I really hope we can avoid adding N new string literal syntaxes.  I see the existing one as the “simple” case, and the multiline case as the “advanced” case which can have knobs put on it for other advanced uses.<br>&gt;&gt; <br>&gt;&gt; Catching up with the rest of this thread, here’s what I’d suggest:<br>&gt;&gt; <br>&gt;&gt; - Please don’t extend simple “foo” strings to multiple lines.<br>&gt;&gt; - The ``` syntax is actually pretty interesting, I think that exploring it makes sense.  “”” doesn’t seem problematic to me though.<br>&gt;&gt; - Please consider ways that the string can have extensible options applied to it.  I haven’t thought much about this space, but the &quot;String literal suffixes for defining types” has some interesting ideas (though using prefixes instead of suffixes seems appealing as was pointed out in some email). <br>&gt;&gt; - I completely agree with Brent’s observation that we shouldn’t optimize for multi-line literals embedded into the middle of some other large expression.<br>&gt;&gt; <br>&gt;&gt; The “configuration” aspect of this feature has come up several times.  It seems clear that the multi line literal has some obvious strong defaults: leading whitespace should be stripped, and escapes should be processed (including interpolation).  That said, being able to disable these independent of each other is important, and there are lots of other behaviors that can be considered as well.  I consider it a good thing for these behaviors to be explicit in the code.<br>&gt;&gt; <br>&gt;&gt; As a strawman proposal (i.e. don’t take it seriously) to illustrate what I mean, you could use attributes for this, e.g. something like:<br>&gt;&gt; <br>&gt;&gt; let foo = @disable_escape_processing ```<br>&gt;&gt; blah <br>&gt;&gt; blah<br>&gt;&gt;  blah```<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/058378bd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 03:00:00am</p></header><div class="content"><p>I am going to wait until friday the 18th to submit a formal swift-evolution<br>review for this feature. I&#39;m not sure if a week is enough time to get the<br>feedback I need, but hopefully that will be the case. I&#39;m quite new to the<br>project and this procedure. I&#39;d certainly like to hear from more core team<br>members than just Chris Lattner, no matter how much of a badass he might<br>be. Hopefully my desire to keep things simple doesn&#39;t clash with the<br>community goals.<br></p><p>-Travis Tilley<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/8127b1a2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 11, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; I would very much like to implement multi-line string literals in swift and get feedback on what this should look like, as i&#39;ve been informed there are several competing suggestions filed as radars.<br></p><p>Some principles:<br></p><p>1. You do not want to plop enormous multi-line string constants in the middle of expressions. This makes the expressions impossible to read. Instead, you want a placeholder for the string in the expression, and then the string on a separate line.<br></p><p>2. Having said that, when there are several placeholders, you also want it to be obvious which text goes with which placeholder.<br></p><p>3. You want a syntax which clearly indicates which indentation is meant to line up the string literal with the code, and which is meant to be *in* the string literal.<br></p><p>With these principles in mind, I suggest something like:<br></p><p>	onMessage(DAVE&gt;, sendMessage: HAL&gt;)<br>	DAVE&gt;Open the pod bay doors,<br>	DAVE&gt;	HAL!<br>	HAL&gt;I’m sorry, Dave,<br>	HAL&gt;	I’m afraid I can’t <br>	HAL&gt;	do that.<br></p><p>A multiline literal reference consists of an identifier followed by a closing angle bracket in postfix operator position. After the end of any statement containing a multiline literal reference, Swift starts looking for the actual multiline literals mentioned in that statement. Leading whitespace is consumed and discarded up to a matching identifier and angle bracket; the text on the line after the literal, up to the newline, is the text of the literal. Once Swift encounters a line that doesn’t start with whitespace, an identifier, and an angle bracket, it switches back to looking for ordinary statements.<br></p><p>(By the way, the all-caps is a stylistic suggestion, not a requirement, and I’m not at all sure it’s the *right* stylistic suggestion.)<br></p><p>As a shorthand for lines with only one string, you might be able to say:<br></p><p>	sendMessage(_&gt;)<br>	&gt;I’m sorry, Dave,<br>	&gt;	I’m afraid I can’t<br>	&gt;	do that.<br></p><p>While this solves the indentation problem, it doesn’t answer the question of whether the trailing \n is part of the literal. I think it is. I’m actually tempted to say that *all* newlines are ignored and you need \n if you want a real newline, but that seems like it would do a lot of violence to the entire concept of a multiline literal.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>I&#39;m not entirely sure how to respond to this, but I think some of your<br>suggestions might go against the goal of having less noise in defining a<br>multi-line string. It&#39;s actually more to type than:<br></p><p>&gt; &quot;this is the first line \n&quot; +<br>&gt; &quot;this is the second line \n&quot;<br></p><p>​...which we can already do.<br></p><p>Your suggestion that each line should end in \n makes me think you&#39;re<br>actually trying to have a bit of fun with me, but I can&#39;t really tell and I<br>really don&#39;t want to be rude by making that assumption.<br></p><p>​<br></p><p><br>On Fri, Dec 11, 2015 at 5:10 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I would very much like to implement multi-line string literals in swift<br>&gt; and get feedback on what this should look like, as i&#39;ve been informed there<br>&gt; are several competing suggestions filed as radars.<br>&gt;<br>&gt; Some principles:<br>&gt;<br>&gt; 1. You do not want to plop enormous multi-line string constants in the<br>&gt; middle of expressions. This makes the expressions impossible to read.<br>&gt; Instead, you want a placeholder for the string in the expression, and then<br>&gt; the string on a separate line.<br>&gt;<br>&gt; 2. Having said that, when there are several placeholders, you also want it<br>&gt; to be obvious which text goes with which placeholder.<br>&gt;<br>&gt; 3. You want a syntax which clearly indicates which indentation is meant to<br>&gt; line up the string literal with the code, and which is meant to be *in* the<br>&gt; string literal.<br>&gt;<br>&gt; With these principles in mind, I suggest something like:<br>&gt;<br>&gt;         onMessage(DAVE&gt;, sendMessage: HAL&gt;)<br>&gt;         DAVE&gt;Open the pod bay doors,<br>&gt;         DAVE&gt;   HAL!<br>&gt;         HAL&gt;I’m sorry, Dave,<br>&gt;         HAL&gt;    I’m afraid I can’t<br>&gt;         HAL&gt;    do that.<br>&gt;<br>&gt; A multiline literal reference consists of an identifier followed by a<br>&gt; closing angle bracket in postfix operator position. After the end of any<br>&gt; statement containing a multiline literal reference, Swift starts looking<br>&gt; for the actual multiline literals mentioned in that statement. Leading<br>&gt; whitespace is consumed and discarded up to a matching identifier and angle<br>&gt; bracket; the text on the line after the literal, up to the newline, is the<br>&gt; text of the literal. Once Swift encounters a line that doesn’t start with<br>&gt; whitespace, an identifier, and an angle bracket, it switches back to<br>&gt; looking for ordinary statements.<br>&gt;<br>&gt; (By the way, the all-caps is a stylistic suggestion, not a requirement,<br>&gt; and I’m not at all sure it’s the *right* stylistic suggestion.)<br>&gt;<br>&gt; As a shorthand for lines with only one string, you might be able to say:<br>&gt;<br>&gt;         sendMessage(_&gt;)<br>&gt;         &gt;I’m sorry, Dave,<br>&gt;         &gt;       I’m afraid I can’t<br>&gt;         &gt;       do that.<br>&gt;<br>&gt; While this solves the indentation problem, it doesn’t answer the question<br>&gt; of whether the trailing \n is part of the literal. I think it is. I’m<br>&gt; actually tempted to say that *all* newlines are ignored and you need \n if<br>&gt; you want a real newline, but that seems like it would do a lot of violence<br>&gt; to the entire concept of a multiline literal.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/d5e3625b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>multi-line string literals</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>Speaking of line endings…<br></p><p>&quot;&quot;&quot;<br>Line1<br>Line2<br>Line3<br>&quot;&quot;&quot;<br></p><p>On Mac/Unix the lines in the source file would likely end in \n while on<br>Windows the would likely end in \r\n.<br>What line endings would the resulting string have? The one from the source<br>file or would it be normalized to \n?<br></p><p>On Fri, Dec 11, 2015 at 11:31 PM, Travis Tilley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m not entirely sure how to respond to this, but I think some of your<br>&gt; suggestions might go against the goal of having less noise in defining a<br>&gt; multi-line string. It&#39;s actually more to type than:<br>&gt;<br>&gt;&gt; &quot;this is the first line \n&quot; +<br>&gt;&gt; &quot;this is the second line \n&quot;<br>&gt;<br>&gt; ​...which we can already do.<br>&gt;<br>&gt; Your suggestion that each line should end in \n makes me think you&#39;re<br>&gt; actually trying to have a bit of fun with me, but I can&#39;t really tell and I<br>&gt; really don&#39;t want to be rude by making that assumption.<br>&gt;<br>&gt; ​<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 5:10 PM, Brent Royal-Gordon &lt;<br>&gt; brent at architechies.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; I would very much like to implement multi-line string literals in swift<br>&gt;&gt; and get feedback on what this should look like, as i&#39;ve been informed there<br>&gt;&gt; are several competing suggestions filed as radars.<br>&gt;&gt;<br>&gt;&gt; Some principles:<br>&gt;&gt;<br>&gt;&gt; 1. You do not want to plop enormous multi-line string constants in the<br>&gt;&gt; middle of expressions. This makes the expressions impossible to read.<br>&gt;&gt; Instead, you want a placeholder for the string in the expression, and then<br>&gt;&gt; the string on a separate line.<br>&gt;&gt;<br>&gt;&gt; 2. Having said that, when there are several placeholders, you also want<br>&gt;&gt; it to be obvious which text goes with which placeholder.<br>&gt;&gt;<br>&gt;&gt; 3. You want a syntax which clearly indicates which indentation is meant<br>&gt;&gt; to line up the string literal with the code, and which is meant to be *in*<br>&gt;&gt; the string literal.<br>&gt;&gt;<br>&gt;&gt; With these principles in mind, I suggest something like:<br>&gt;&gt;<br>&gt;&gt;         onMessage(DAVE&gt;, sendMessage: HAL&gt;)<br>&gt;&gt;         DAVE&gt;Open the pod bay doors,<br>&gt;&gt;         DAVE&gt;   HAL!<br>&gt;&gt;         HAL&gt;I’m sorry, Dave,<br>&gt;&gt;         HAL&gt;    I’m afraid I can’t<br>&gt;&gt;         HAL&gt;    do that.<br>&gt;&gt;<br>&gt;&gt; A multiline literal reference consists of an identifier followed by a<br>&gt;&gt; closing angle bracket in postfix operator position. After the end of any<br>&gt;&gt; statement containing a multiline literal reference, Swift starts looking<br>&gt;&gt; for the actual multiline literals mentioned in that statement. Leading<br>&gt;&gt; whitespace is consumed and discarded up to a matching identifier and angle<br>&gt;&gt; bracket; the text on the line after the literal, up to the newline, is the<br>&gt;&gt; text of the literal. Once Swift encounters a line that doesn’t start with<br>&gt;&gt; whitespace, an identifier, and an angle bracket, it switches back to<br>&gt;&gt; looking for ordinary statements.<br>&gt;&gt;<br>&gt;&gt; (By the way, the all-caps is a stylistic suggestion, not a requirement,<br>&gt;&gt; and I’m not at all sure it’s the *right* stylistic suggestion.)<br>&gt;&gt;<br>&gt;&gt; As a shorthand for lines with only one string, you might be able to say:<br>&gt;&gt;<br>&gt;&gt;         sendMessage(_&gt;)<br>&gt;&gt;         &gt;I’m sorry, Dave,<br>&gt;&gt;         &gt;       I’m afraid I can’t<br>&gt;&gt;         &gt;       do that.<br>&gt;&gt;<br>&gt;&gt; While this solves the indentation problem, it doesn’t answer the question<br>&gt;&gt; of whether the trailing \n is part of the literal. I think it is. I’m<br>&gt;&gt; actually tempted to say that *all* newlines are ignored and you need \n if<br>&gt;&gt; you want a real newline, but that seems like it would do a lot of violence<br>&gt;&gt; to the entire concept of a multiline literal.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/fabdb8aa/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 11, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; I&#39;m not entirely sure how to respond to this, but I think some of your suggestions might go against the goal of having less noise in defining a multi-line string. It&#39;s actually more to type than:<br>&gt; &quot;this is the first line \n&quot; +<br>&gt; &quot;this is the second line \n&quot;<br>&gt; ​...which we can already do.<br>&gt; <br>&gt; Your suggestion that each line should end in \n makes me think you&#39;re actually trying to have a bit of fun with me, but I can&#39;t really tell and I really don&#39;t want to be rude by making that assumption.<br></p><p>I am being serious. This proposal does require more characters, it’s true. However, it doesn’t require more *reading*—because the leading indicators will generally line up, you can ignore them and read everything to the right, like the “&gt; “ used to demarcate your text above from my text—and with an editor feature to select several lines and quote them (the way you can with comments in most editors), it wouldn’t require more *writing* either. And although it uses more characters, it *also* unmistakably sets off quoted material from code, comments, other multiline string literals, and anything else, while being unambiguous about whether indentation is intended to style the literal or be part of it, without a bunch of funky obscure modifier characters like &quot;&lt;&lt;-END&quot;.<br></p><p>The \n thing was an idle thought being presented for discussion, not a concrete suggestion, but it was also not a joke. (I realized after sending it, however, that the trailing newline problem can be solved by simply having a rule that you strip one trailing newline. If you want your string to end with a newline, include a sacrificial blank “Foo&gt;” line at the end of the literal. Some sort of modifier to indicate the trailing newline behavior is possible too, but see the previous paragraph for my thoughts on those.)<br></p><p>I’ve used and loved heredocs in Perl and Ruby, but I always understood that they have significant problems. That experience shaped this proposal.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 07:00:00pm</p></header><div class="content"><p>Ah. My sincerest apologies for making that assumption then.<br></p><p>Your suggestion doesn&#39;t solve my use case, personally. I&#39;m also *hoping* to<br>officially propose something less complex than heredocs once there&#39;s been<br>enough feedback.<br></p><p><br>-Travis Tilley<br></p><p><br>On Fri, Dec 11, 2015 at 5:52 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I&#39;m not entirely sure how to respond to this, but I think some of your<br>&gt; suggestions might go against the goal of having less noise in defining a<br>&gt; multi-line string. It&#39;s actually more to type than:<br>&gt; &gt; &quot;this is the first line \n&quot; +<br>&gt; &gt; &quot;this is the second line \n&quot;<br>&gt; &gt; ​...which we can already do.<br>&gt; &gt;<br>&gt; &gt; Your suggestion that each line should end in \n makes me think you&#39;re<br>&gt; actually trying to have a bit of fun with me, but I can&#39;t really tell and I<br>&gt; really don&#39;t want to be rude by making that assumption.<br>&gt;<br>&gt; I am being serious. This proposal does require more characters, it’s true.<br>&gt; However, it doesn’t require more *reading*—because the leading indicators<br>&gt; will generally line up, you can ignore them and read everything to the<br>&gt; right, like the “&gt; “ used to demarcate your text above from my text—and<br>&gt; with an editor feature to select several lines and quote them (the way you<br>&gt; can with comments in most editors), it wouldn’t require more *writing*<br>&gt; either. And although it uses more characters, it *also* unmistakably sets<br>&gt; off quoted material from code, comments, other multiline string literals,<br>&gt; and anything else, while being unambiguous about whether indentation is<br>&gt; intended to style the literal or be part of it, without a bunch of funky<br>&gt; obscure modifier characters like &quot;&lt;&lt;-END&quot;.<br>&gt;<br>&gt; The \n thing was an idle thought being presented for discussion, not a<br>&gt; concrete suggestion, but it was also not a joke. (I realized after sending<br>&gt; it, however, that the trailing newline problem can be solved by simply<br>&gt; having a rule that you strip one trailing newline. If you want your string<br>&gt; to end with a newline, include a sacrificial blank “Foo&gt;” line at the end<br>&gt; of the literal. Some sort of modifier to indicate the trailing newline<br>&gt; behavior is possible too, but see the previous paragraph for my thoughts on<br>&gt; those.)<br>&gt;<br>&gt; I’ve used and loved heredocs in Perl and Ruby, but I always understood<br>&gt; that they have significant problems. That experience shaped this proposal.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/6ea570fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>multi-line string literals</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 12, 2015 at 01:00:00am</p></header><div class="content"><p>What about #?<br></p><p>###<br>string<br>###<br></p><p>If your string does contain &quot;###&quot; you can simply guard the string with more<br># until it fits. Must be symmetrical though. No escaping necessary.<br></p><p>On Sat, Dec 12, 2015 at 1:08 AM, Travis Tilley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Ah. My sincerest apologies for making that assumption then.<br>&gt;<br>&gt; Your suggestion doesn&#39;t solve my use case, personally. I&#39;m also *hoping*<br>&gt; to officially propose something less complex than heredocs once there&#39;s<br>&gt; been enough feedback.<br>&gt;<br>&gt;<br>&gt; -Travis Tilley<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 5:52 PM, Brent Royal-Gordon &lt;<br>&gt; brent at architechies.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; I&#39;m not entirely sure how to respond to this, but I think some of your<br>&gt;&gt; suggestions might go against the goal of having less noise in defining a<br>&gt;&gt; multi-line string. It&#39;s actually more to type than:<br>&gt;&gt; &gt; &quot;this is the first line \n&quot; +<br>&gt;&gt; &gt; &quot;this is the second line \n&quot;<br>&gt;&gt; &gt; ​...which we can already do.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Your suggestion that each line should end in \n makes me think you&#39;re<br>&gt;&gt; actually trying to have a bit of fun with me, but I can&#39;t really tell and I<br>&gt;&gt; really don&#39;t want to be rude by making that assumption.<br>&gt;&gt;<br>&gt;&gt; I am being serious. This proposal does require more characters, it’s<br>&gt;&gt; true. However, it doesn’t require more *reading*—because the leading<br>&gt;&gt; indicators will generally line up, you can ignore them and read everything<br>&gt;&gt; to the right, like the “&gt; “ used to demarcate your text above from my<br>&gt;&gt; text—and with an editor feature to select several lines and quote them (the<br>&gt;&gt; way you can with comments in most editors), it wouldn’t require more<br>&gt;&gt; *writing* either. And although it uses more characters, it *also*<br>&gt;&gt; unmistakably sets off quoted material from code, comments, other multiline<br>&gt;&gt; string literals, and anything else, while being unambiguous about whether<br>&gt;&gt; indentation is intended to style the literal or be part of it, without a<br>&gt;&gt; bunch of funky obscure modifier characters like &quot;&lt;&lt;-END&quot;.<br>&gt;&gt;<br>&gt;&gt; The \n thing was an idle thought being presented for discussion, not a<br>&gt;&gt; concrete suggestion, but it was also not a joke. (I realized after sending<br>&gt;&gt; it, however, that the trailing newline problem can be solved by simply<br>&gt;&gt; having a rule that you strip one trailing newline. If you want your string<br>&gt;&gt; to end with a newline, include a sacrificial blank “Foo&gt;” line at the end<br>&gt;&gt; of the literal. Some sort of modifier to indicate the trailing newline<br>&gt;&gt; behavior is possible too, but see the previous paragraph for my thoughts on<br>&gt;&gt; those.)<br>&gt;&gt;<br>&gt;&gt; I’ve used and loved heredocs in Perl and Ruby, but I always understood<br>&gt;&gt; that they have significant problems. That experience shaped this proposal.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/efdba5cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>multi-line string literals</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>This would probably conflict with Swift&#39;s non-official (hopefully official in the future) macro-system (the .gyb files), which makes heavy use of &quot;#&quot;.<br></p><p>&gt; On 12 Dec 2015, at 01:13, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about #?<br>&gt; <br>&gt; ###<br>&gt; string<br>&gt; ###<br>&gt; <br>&gt; If your string does contain &quot;###&quot; you can simply guard the string with more # until it fits. Must be symmetrical though. No escaping necessary.<br>&gt; <br>&gt;&gt; On Sat, Dec 12, 2015 at 1:08 AM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Ah. My sincerest apologies for making that assumption then.<br>&gt;&gt; <br>&gt;&gt; Your suggestion doesn&#39;t solve my use case, personally. I&#39;m also hoping to officially propose something less complex than heredocs once there&#39;s been enough feedback.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Travis Tilley<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Dec 11, 2015 at 5:52 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; &gt; I&#39;m not entirely sure how to respond to this, but I think some of your suggestions might go against the goal of having less noise in defining a multi-line string. It&#39;s actually more to type than:<br>&gt;&gt;&gt; &gt; &quot;this is the first line \n&quot; +<br>&gt;&gt;&gt; &gt; &quot;this is the second line \n&quot;<br>&gt;&gt;&gt; &gt; ​...which we can already do.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Your suggestion that each line should end in \n makes me think you&#39;re actually trying to have a bit of fun with me, but I can&#39;t really tell and I really don&#39;t want to be rude by making that assumption.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am being serious. This proposal does require more characters, it’s true. However, it doesn’t require more *reading*—because the leading indicators will generally line up, you can ignore them and read everything to the right, like the “&gt; “ used to demarcate your text above from my text—and with an editor feature to select several lines and quote them (the way you can with comments in most editors), it wouldn’t require more *writing* either. And although it uses more characters, it *also* unmistakably sets off quoted material from code, comments, other multiline string literals, and anything else, while being unambiguous about whether indentation is intended to style the literal or be part of it, without a bunch of funky obscure modifier characters like &quot;&lt;&lt;-END&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The \n thing was an idle thought being presented for discussion, not a concrete suggestion, but it was also not a joke. (I realized after sending it, however, that the trailing newline problem can be solved by simply having a rule that you strip one trailing newline. If you want your string to end with a newline, include a sacrificial blank “Foo&gt;” line at the end of the literal. Some sort of modifier to indicate the trailing newline behavior is possible too, but see the previous paragraph for my thoughts on those.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve used and loved heredocs in Perl and Ruby, but I always understood that they have significant problems. That experience shaped this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/dd185d08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>multi-line string literals</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>Whops sorry I got the symbols mixed up, Swift&#39;s macro system uses &quot;%&quot;, but the preprocessor uses &quot;#&quot;. By using &quot;#&quot; as a delimiter, the lexer would have to be adjusted quite a bit to work for both literals and the preprocessor.<br></p><p>&gt; On 12 Dec 2015, at 02:09, Kametrixom Tikara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This would probably conflict with Swift&#39;s non-official (hopefully official in the future) macro-system (the .gyb files), which makes heavy use of &quot;#&quot;.<br>&gt; <br>&gt;&gt; On 12 Dec 2015, at 01:13, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about #?<br>&gt;&gt; <br>&gt;&gt; ###<br>&gt;&gt; string<br>&gt;&gt; ###<br>&gt;&gt; <br>&gt;&gt; If your string does contain &quot;###&quot; you can simply guard the string with more # until it fits. Must be symmetrical though. No escaping necessary.<br>&gt;&gt; <br>&gt;&gt;&gt; On Sat, Dec 12, 2015 at 1:08 AM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Ah. My sincerest apologies for making that assumption then.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your suggestion doesn&#39;t solve my use case, personally. I&#39;m also hoping to officially propose something less complex than heredocs once there&#39;s been enough feedback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Travis Tilley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Dec 11, 2015 at 5:52 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; I&#39;m not entirely sure how to respond to this, but I think some of your suggestions might go against the goal of having less noise in defining a multi-line string. It&#39;s actually more to type than:<br>&gt;&gt;&gt;&gt; &gt; &quot;this is the first line \n&quot; +<br>&gt;&gt;&gt;&gt; &gt; &quot;this is the second line \n&quot;<br>&gt;&gt;&gt;&gt; &gt; ​...which we can already do.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Your suggestion that each line should end in \n makes me think you&#39;re actually trying to have a bit of fun with me, but I can&#39;t really tell and I really don&#39;t want to be rude by making that assumption.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am being serious. This proposal does require more characters, it’s true. However, it doesn’t require more *reading*—because the leading indicators will generally line up, you can ignore them and read everything to the right, like the “&gt; “ used to demarcate your text above from my text—and with an editor feature to select several lines and quote them (the way you can with comments in most editors), it wouldn’t require more *writing* either. And although it uses more characters, it *also* unmistakably sets off quoted material from code, comments, other multiline string literals, and anything else, while being unambiguous about whether indentation is intended to style the literal or be part of it, without a bunch of funky obscure modifier characters like &quot;&lt;&lt;-END&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The \n thing was an idle thought being presented for discussion, not a concrete suggestion, but it was also not a joke. (I realized after sending it, however, that the trailing newline problem can be solved by simply having a rule that you strip one trailing newline. If you want your string to end with a newline, include a sacrificial blank “Foo&gt;” line at the end of the literal. Some sort of modifier to indicate the trailing newline behavior is possible too, but see the previous paragraph for my thoughts on those.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve used and loved heredocs in Perl and Ruby, but I always understood that they have significant problems. That experience shaped this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/0b7c2a9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 12, 2015 at 07:00:00am</p></header><div class="content"><p>My 5 cents:<br></p><p>+1 for indentation removal as the default (and maybe the only option). This is really the only common case.<br></p><p>+1 for removing all indentation based on either the first or the least indented line;<br>-1 for using the position of &quot;&quot;&quot; to indicate the amount of indentation to remove — nothing is more stupid than forcing to write an extra newline before &quot;&quot;&quot;.<br></p><p>+1 for &quot;&quot;&quot;, it communicates the fact that this is a regular string, just a bit longer than other strings;<br>-1 for ```, I believe that backticks communicate a bigger difference than there is.<br></p><p>+1 for not complicating it further than that.<br></p><p>+100 for the feature, overall.<br></p><p>A.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>multi-line string literals</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>How about this: a pseudo-function that will just include the contents of another file into your code?<br></p><p>let bigString = StringLiteral(“MyLifeStory”)<br></p><p>You have another file called “MyLifeStory.swiftstring” alongside your source file. Then there is no thinking about escaping, line endings, etc. Anything in that file is processed as the string.<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ea02b9a2f6e3d188e9e974e30d565e0?s=50"></div><header><strong>multi-line string literals</strong> from <string>Riley Avron</string> &lt;ravron at dropbox.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>&gt;<br>&gt; How about this: a pseudo-function that will just include the contents of<br>&gt; another file into your code?<br>&gt; let bigString = StringLiteral(“MyLifeStory”)<br>&gt; You have another file called “MyLifeStory.swiftstring” alongside your<br>&gt; source file. Then there is no thinking about escaping, line endings, etc.<br>&gt; Anything in that file is processed as the string.<br></p><p><br>This makes sense for truly long strings, but could get unwieldy in the case<br>of a handful of strings spanning a few lines each, which I would posit is<br>the more common case.<br></p><p>Riley<br></p><p>On 14 December 2015 at 10:56, Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; How about this: a pseudo-function that will just include the contents of<br>&gt; another file into your code?<br>&gt;<br>&gt; let bigString = StringLiteral(“MyLifeStory”)<br>&gt;<br>&gt; You have another file called “MyLifeStory.swiftstring” alongside your<br>&gt; source file. Then there is no thinking about escaping, line endings, etc.<br>&gt; Anything in that file is processed as the string.<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/7c170fa4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
