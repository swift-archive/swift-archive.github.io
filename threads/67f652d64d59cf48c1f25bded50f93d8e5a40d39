<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>protocol-scoped methods</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October  2, 2016 at 03:00:00am</p></header><div class="content"><p>Howdy,<br></p><p>Several months ago, there were a few well-received ideas on the list of adding functions which would have static-like dispatch directly scoped to protocols, instead of only to types conforming to those protocols.<br>From a review of the mailing list, it looks like these ideas got lost amongst some others, and the goal at the time was “cut &amp; fix”, not “add”.<br>I’m concerned these may require ABI changes, and I’ve noticed their absence negatively affects my code designs, so I’m bring them back up.<br></p><p>The first, and maybe most obvious is protocol-scoped functions.<br></p><p>Right now, static functions require a conforming type, even when default implementations exist.<br></p><p>protocol Usable {<br>	static func use()<br>}<br></p><p>extension Usable {<br>	static func use() { }<br>}<br></p><p>struct User : Usable {<br>}<br></p><p>User.use()	//compiles<br>type(of:User()).use()	//compiles<br></p><p>struct AnotherUser : Usable {<br>	static func use() { }<br>}<br></p><p>AnotherUser.use()	//compiles &amp; calls  AnotherUser’s implementation instead of protocol default<br></p><p>While that is useful, and I’m not suggesting removing it, there is room for another kind of static-like method, one which does not require knowledge of an instance of a conforming type, nor of a conforming type.  A protocol-scoped method<br></p><p>protocol Usable {<br>}<br></p><p>extension Usable {<br>	protocol func use() { }<br>}<br></p><p>Usable.use()	//if accepted, this would compile end execute.<br></p><p>Right now, “static” methods must have a supported type.<br></p><p>Without this feature:<br>1. many methods become global, which feels very inappropriate in Swift<br>2. To get nice inits for “Struct clusters”, they become become enums, which does not leave them open for extension, the opposite of the intention of protocols.<br></p><p>With this feature:<br>Common pre-validation or -pre-instantiation logic would be available to code which works directly with protocols , instead of only code in another module which knows about concrete types of it.<br>The function is not included in the original protocol definition, because it is not something which must be implemented by the conforming type.<br></p><p>A derivative concept is protocol-scoped stored vars/lets.  Like static vars &amp; let, protocol-scoped vars &amp; lets have static storage, but are name spaced by the protocol, instead of getting dumped into the global name space.<br></p><p>As an example, I have a protocol which creates URLRequests for data serialized as JSON.  I’d like to have a protocol-scoped “jsonMimeType” var for insertion in my algorithm, but that is not currently allowed, at least not using a good name-space.  In fact, it’s not even allowed as a static var/let right now, at least with a default implementation.  And since this is something that shouldn’t be overridden, it doesn’t make sense in a static, who’s default implementation could be replaced by a conforming type’s implementation.<br></p><p>Protocol Nested Types.<br>I understand there’s a lot of work to do to support nested generics, but surely nested non-generics are pretty straight forward?<br></p><p>For instance, I have a protocol which requires instances to implement a method which returns a case of an enum which is peculiar to that protocol.  I may very well wish to make the enum a nested type of the protocol.  This feels like a natural extension of the language.<br></p><p>Two of the emails mentioned the desire for “existential protocols”, but in an hour of searching, I did not find an “existential protocol manifesto”, so I don’t know.<br></p><p>Questions:<br>1. Have I missed something, and these features are already supported in Swift?<br>2. Would these features benefit your use of Swift?<br>3. Would these features affect the ABI?<br>4. Are these features part of a larger initiative already considered? (links please)<br></p><p>-Ben Spratling<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>protocol-scoped methods</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>October  2, 2016 at 11:00:00am</p></header><div class="content"><p>Honestly I am a bit concerned with protocols getting more and more code in them, default methods included.<br></p><p>Protocols for me are best to abstract away, to decouple api behaviour from implementation... which also makes the system a lot easier to mock.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 2 Oct 2016, at 10:42, Benjamin Spratling via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Howdy,<br>&gt; <br>&gt; Several months ago, there were a few well-received ideas on the list of adding functions which would have static-like dispatch directly scoped to protocols, instead of only to types conforming to those protocols.<br>&gt; From a review of the mailing list, it looks like these ideas got lost amongst some others, and the goal at the time was “cut &amp; fix”, not “add”.<br>&gt; I’m concerned these may require ABI changes, and I’ve noticed their absence negatively affects my code designs, so I’m bring them back up.<br>&gt; <br>&gt; The first, and maybe most obvious is protocol-scoped functions.<br>&gt; <br>&gt; Right now, static functions require a conforming type, even when default implementations exist.<br>&gt; <br>&gt; protocol Usable {<br>&gt;    static func use()<br>&gt; }<br>&gt; <br>&gt; extension Usable {<br>&gt;    static func use() { }<br>&gt; }<br>&gt; <br>&gt; struct User : Usable {<br>&gt; }<br>&gt; <br>&gt; User.use()    //compiles<br>&gt; type(of:User()).use()    //compiles<br>&gt; <br>&gt; struct AnotherUser : Usable {<br>&gt;    static func use() { }<br>&gt; }<br>&gt; <br>&gt; AnotherUser.use()    //compiles &amp; calls  AnotherUser’s implementation instead of protocol default<br>&gt; <br>&gt; While that is useful, and I’m not suggesting removing it, there is room for another kind of static-like method, one which does not require knowledge of an instance of a conforming type, nor of a conforming type.  A protocol-scoped method<br>&gt; <br>&gt; protocol Usable {<br>&gt; }<br>&gt; <br>&gt; extension Usable {<br>&gt;    protocol func use() { }<br>&gt; }<br>&gt; <br>&gt; Usable.use()    //if accepted, this would compile end execute.<br>&gt; <br>&gt; Right now, “static” methods must have a supported type.<br>&gt; <br>&gt; Without this feature:<br>&gt; 1. many methods become global, which feels very inappropriate in Swift<br>&gt; 2. To get nice inits for “Struct clusters”, they become become enums, which does not leave them open for extension, the opposite of the intention of protocols.<br>&gt; <br>&gt; With this feature:<br>&gt; Common pre-validation or -pre-instantiation logic would be available to code which works directly with protocols , instead of only code in another module which knows about concrete types of it.<br>&gt; The function is not included in the original protocol definition, because it is not something which must be implemented by the conforming type.<br>&gt; <br>&gt; A derivative concept is protocol-scoped stored vars/lets.  Like static vars &amp; let, protocol-scoped vars &amp; lets have static storage, but are name spaced by the protocol, instead of getting dumped into the global name space.<br>&gt; <br>&gt; As an example, I have a protocol which creates URLRequests for data serialized as JSON.  I’d like to have a protocol-scoped “jsonMimeType” var for insertion in my algorithm, but that is not currently allowed, at least not using a good name-space.  In fact, it’s not even allowed as a static var/let right now, at least with a default implementation.  And since this is something that shouldn’t be overridden, it doesn’t make sense in a static, who’s default implementation could be replaced by a conforming type’s implementation.<br>&gt; <br>&gt; Protocol Nested Types.<br>&gt; I understand there’s a lot of work to do to support nested generics, but surely nested non-generics are pretty straight forward?<br>&gt; <br>&gt; For instance, I have a protocol which requires instances to implement a method which returns a case of an enum which is peculiar to that protocol.  I may very well wish to make the enum a nested type of the protocol.  This feels like a natural extension of the language.<br>&gt; <br>&gt; Two of the emails mentioned the desire for “existential protocols”, but in an hour of searching, I did not find an “existential protocol manifesto”, so I don’t know.<br>&gt; <br>&gt; Questions:<br>&gt; 1. Have I missed something, and these features are already supported in Swift?<br>&gt; 2. Would these features benefit your use of Swift?<br>&gt; 3. Would these features affect the ABI?<br>&gt; 4. Are these features part of a larger initiative already considered? (links please)<br>&gt; <br>&gt; -Ben Spratling<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
