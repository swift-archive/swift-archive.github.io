<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/45dfb57f85e0233b013388436140a922?s=50"></div><header><strong>[Swift3][Linux][URLSession]: Core dump when trying to make simple HTTP request</strong> from <string>Steven Harms</string> &lt;sgharms at stevengharms.com&gt;<p>October 27, 2016 at 08:00:00am</p></header><div class="content"><p>Hello Swift,<br></p><p>I&#39;ve been trying out Swift as a general utility language on the server<br>(replacing Ruby or Node). I&#39;m trying to write a simple image retriever via<br>HTTP as a learning project.<br></p><p>Inspired by this [gist][], I&#39;ve written the following:<br></p><p>let queue = DispatchQueue.global(qos: .background)<br></p><p>let sessionConfiguration = URLSessionConfiguration.default<br>let session = URLSession(configuration: sessionConfiguration)<br></p><p>print(&quot;staring sync&quot;)<br>queue.async(execute: {<br>    print(&quot;&gt;&gt;&gt; [\(queue.label)]: At the queue start&quot;)<br>    print(&quot;x&quot;)<br>    let task = session.dataTask(with: URL(string: &quot;http://google.com&quot;)!,<br>completionHandler: {<br>        (data, response, error) in<br>        print(&quot;Task ran!&quot;)<br>    })<br>    print(&quot;y&quot;)<br>    task.resume()<br>    print(&quot;z&quot;)<br>})<br>print(&quot;ending sync&quot;)<br></p><p>With output:<br></p><p>staring sync<br>ending sync<br></p><p>or...<br></p><p>staring sync<br>ending sync<br>&gt;&gt;&gt; [com.apple.root.background-qos]: At the queue start<br>x<br>y<br>y<br>z<br></p><p>Whoa.<br></p><p>At this point I&#39;m going to have to confess that I need some help clarifying<br>my model.<br></p><p>1. How did point &quot;y&quot; get fired twice? Or how did it happen not at all?<br></p><p>2. How did my callback for dataTask *never* fire? Even if the connection<br>task *failed* the handler ought have fired, no?<br></p><p>3. I didn&#39;t want to bring this whole queue business into the picture, but<br>it appears that without it the program exits before the handler has a<br>chance to fire.<br></p><p>4. Changing to a queue.sync from queue.async consistently produces the<br>output I expect, but does not fire my completionHandler still.<br></p><p>5. Is there a canonical reference for doing this simplest of tasks?<br></p><p>Thanks for the help,<br></p><p>Steven<br></p><p>References:<br></p><p>[gist]: https://gist.github.com/stinger/71000c4d5fb4a25fb7686bae116df0a5<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161027/63ecaf84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be9ef3374a2b459cd3db6b2a2a8db686?s=50"></div><header><strong>[Swift3][Linux][URLSession]: Core dump when trying to make simple HTTP request</strong> from <string>Evtim Papushev</string> &lt;e.papushev at me.com&gt;<p>October 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Steven,<br></p><p>Do you run your project in Xcode Playgrounds or under Linux?<br></p><p>Generally processes are associated with a single thread, the main thread. Once it exits the process and all executing threads are terminated.<br></p><p>1. Queue.async only schedules a task to be executed, then continues with the rest of the statements. In your case it prints &quot;ending sync”, then it reaches the end and the process terminates.<br></p><p>2. Queue.sync schedules the block for execution, but it also does not return until this block gets executed. So, it effectively pauses the main thread waiting for the task to complete.<br></p><p>In both cases, however, you have an implicit asynchrony as all URLSession tasks run asynchronously. Imagine that it internally calls someQueue.async(…)<br></p><p>There are a few different approaches that you might want to investigate.<br></p><p>1. Make explicit synchronization:<br></p><p>print(&quot;staring sync&quot;)<br></p><p>let group = DispatchGroup()<br></p><p>group.enter()<br>queue.async(execute: {<br>    print(&quot;&gt;&gt;&gt; [\(queue.label)]: At the queue start&quot;)<br>    print(&quot;x&quot;)<br>    let task = session.dataTask(with: URL(string: &quot;http://google.com&quot;)!, completionHandler: {<br>        (data, response, error) in<br>        print(&quot;Task ran!&quot;)<br>        group.leave()<br>    })<br>    print(&quot;y&quot;)<br>    task.resume()<br>    print(&quot;z&quot;)<br>})<br>print(&quot;ending sync&quot;)<br>group.wait()<br></p><p>I would go further and note, that since all URLSession tasks are asynchronous, there is absolutely no need to use additional queues:<br>(I took the liberty to add a set of URLs)<br></p><p>let sessionConfiguration = URLSessionConfiguration.default<br>let session = URLSession(configuration: sessionConfiguration)<br></p><p>let urls = [&quot;https://www.google.com&quot;, &quot;https://www.apple.com&quot;]<br></p><p>let group = DispatchGroup()<br></p><p>print(&quot;staring sync&quot;)<br></p><p>urls.forEach { url in<br>    group.enter()<br>    session.dataTask(with: URL(string: url)!, completionHandler: {<br>        (data, response, error) in<br>        print(&quot;Task ran!&quot;)<br>        group.leave()<br>    }).resume()<br>}<br></p><p>print(&quot;ending sync&quot;)<br>group.wait()<br></p><p>2. Investigate the use of dispatch_main() <br>https://developer.apple.com/reference/dispatch/1452860-dispatch_main<br></p><p>Best,<br>Evtim<br></p><p>&gt; On Oct 27, 2016, at 15:01, Steven Harms via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift,<br>&gt; <br>&gt; I&#39;ve been trying out Swift as a general utility language on the server (replacing Ruby or Node). I&#39;m trying to write a simple image retriever via HTTP as a learning project.<br>&gt; <br>&gt; Inspired by this [gist][], I&#39;ve written the following:<br>&gt; <br>&gt; let queue = DispatchQueue.global(qos: .background)<br>&gt; <br>&gt; let sessionConfiguration = URLSessionConfiguration.default<br>&gt; let session = URLSession(configuration: sessionConfiguration)<br>&gt; <br>&gt; print(&quot;staring sync&quot;)<br>&gt; queue.async(execute: {<br>&gt;     print(&quot;&gt;&gt;&gt; [\(queue.label)]: At the queue start&quot;)<br>&gt;     print(&quot;x&quot;)<br>&gt;     let task = session.dataTask(with: URL(string: &quot;http://google.com &lt;http://google.com/&gt;&quot;)!, completionHandler: {<br>&gt;         (data, response, error) in<br>&gt;         print(&quot;Task ran!&quot;)<br>&gt;     })<br>&gt;     print(&quot;y&quot;)<br>&gt;     task.resume()<br>&gt;     print(&quot;z&quot;)<br>&gt; })<br>&gt; print(&quot;ending sync&quot;)<br>&gt; <br>&gt; With output:<br>&gt; <br>&gt; staring sync<br>&gt; ending sync<br>&gt; <br>&gt; or...<br>&gt; <br>&gt; staring sync<br>&gt; ending sync<br>&gt; &gt;&gt;&gt; [com.apple.root.background-qos]: At the queue start<br>&gt; x<br>&gt; y<br>&gt; y<br>&gt; z<br>&gt; <br>&gt; Whoa.<br>&gt; <br>&gt; At this point I&#39;m going to have to confess that I need some help clarifying my model.<br>&gt; <br>&gt; 1. How did point &quot;y&quot; get fired twice? Or how did it happen not at all?<br>&gt; <br>&gt; 2. How did my callback for dataTask *never* fire? Even if the connection task *failed* the handler ought have fired, no?<br>&gt; <br>&gt; 3. I didn&#39;t want to bring this whole queue business into the picture, but it appears that without it the program exits before the handler has a chance to fire.<br>&gt; <br>&gt; 4. Changing to a queue.sync from queue.async consistently produces the output I expect, but does not fire my completionHandler still.<br>&gt; <br>&gt; 5. Is there a canonical reference for doing this simplest of tasks?<br>&gt; <br>&gt; Thanks for the help,<br>&gt; <br>&gt; Steven<br>&gt; <br>&gt; References:<br>&gt; <br>&gt; [gist]: https://gist.github.com/stinger/71000c4d5fb4a25fb7686bae116df0a5 &lt;https://gist.github.com/stinger/71000c4d5fb4a25fb7686bae116df0a5&gt;_______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161027/cab94f82/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>[Swift3][Linux][URLSession]: Core dump when trying to make simple HTTP request</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>October 28, 2016 at 09:00:00am</p></header><div class="content"><p>On 27 Oct 2016, at 13:01, Steven Harms via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; At this point I&#39;m going to have to confess that I need some help clarifying my model.<br></p><p>Quite.  There two real issues here:<br></p><p>* You don’t need to create a queue just to start a request.  It’s fine to start the request from any context.  Thus, your `queue.async(…)` call is not needed.<br></p><p>* URLSession will run requests asynchronously, thus you need to prevent your process from terminating until the relevant requests are done.  In a real program the framework you’re using typically does this for you.  In a test project like this you have two options:<br></p><p>- dispatchMain() — That is, just add a line containing `dispatchMain()` to the bottom of your ‘main’ code.<br></p><p>- synthetic synchronous — Traditionally this is done using dispatch semaphores; I won’t show it here because a) you’ll find lots of example of it, and b) it’s not recommended, for obscure reasons related to QoS propagation.<br></p><p>&gt; 1. How did point &quot;y&quot; get fired twice? Or how did it happen not at all?<br></p><p>I ran your code verbatim (except that I added a `dispatchMain()` at the end) on my Mac running 10.11.6, built with Xcode 8, and I didn’t see the second copy of `y`.<br></p><p>&gt; 2. How did my callback for dataTask *never* fire? Even if the connection task *failed* the handler ought have fired, no?<br></p><p>Because the process terminated before the request finished.<br></p><p>&gt; 3. I didn&#39;t want to bring this whole queue business into the picture, but it appears that without it the program exits before the handler has a chance to fire.<br></p><p>Correct.<br></p><p>&gt; 4. Changing to a queue.sync from queue.async consistently produces the output I expect, but does not fire my completionHandler still.<br></p><p>Right, because that’s about how the request /starts/, not about how the request’s completion handler runs.<br></p><p>&gt; 5. Is there a canonical reference for doing this simplest of tasks?<br></p><p>Here’s a minimal example of a command line tool that fetches a URL.<br></p><p>---------------------------------------------------------------------------<br>import Foundation<br></p><p>URLSession.shared.dataTask(with: URL(string: &quot;http://www.example.com&quot;)!) { (data, response, error) in<br>    if let error = error {<br>        print(&quot;error: \(error)&quot;)<br>        exit(1)<br>    } else {<br>        let response = response as! HTTPURLResponse<br>        let data = data!<br>        print(&quot;status: \(response.statusCode)&quot;)<br>        for (key, value) in response.allHeaderFields {<br>            print(&quot;header: \(key) = \(value)&quot;)<br>        }<br>        print(&quot;body: \(data as NSData)&quot;)<br>        exit(0)<br>    }<br>}.resume()<br>dispatchMain()<br>---------------------------------------------------------------------------<br></p><p>When I run this (same environment as above) I get this:<br></p><p>status: 200<br>header: Date = Fri, 28 Oct 2016 08:02:04 GMT<br>header: Content-Length = 606<br>header: Etag = &quot;359670651&quot;<br>header: x-ec-custom-error = 1<br>header: Last-Modified = Fri, 09 Aug 2013 23:54:35 GMT<br>header: Accept-Ranges = bytes<br>header: Vary = Accept-Encoding<br>header: X-Cache = HIT<br>header: Content-Type = text/html<br>header: Expires = Fri, 04 Nov 2016 08:02:04 GMT<br>header: Server = ECS (ewr/15BD)<br>header: Content-Encoding = gzip<br>header: Cache-Control = max-age=604800<br>body: &lt;3c21646f 63747970 65206874 6d6c3e0a 3c68746d …&gt;<br></p><p>The only weird thing in the code above is that `key` is of type `AnyHashable` rather than `String`.  That’s because the type of `allHeaderFields` is wrong 	&lt;rdar://problem/27805863&gt;.<br></p><p>Alas, I’m not set up to run this on Linux )-:<br></p><p>Share and Enjoy <br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
