<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 22, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams<br>&gt;&gt; &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;&gt; not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;&gt; anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;&gt; an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;&gt; correctness.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s<br>&gt;&gt;&gt;&gt; an algorithm that manipulates it.  That said, I still don&#39;t have a<br>&gt;&gt;&gt;&gt; concrete example of how view configuration can depend on these<br>&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;  The algorithm might just be &quot;copy x bit of data to y view<br>&gt;&gt;&gt; property, etc&quot;.  That is so trivial that it feels like a stretch to<br>&gt;&gt;&gt; call it an algorithm.<br>&gt;&gt;<br>&gt;&gt;  Algorithms can be trivial.<br>&gt;<br>&gt; Fair enough.  Although in most contexts people don’t use the word when<br>&gt; discussing the trivial.<br></p><p>Yes, quite a shame, that.<br></p><p>&gt;&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it<br>&gt;&gt;&gt; executes at a single point in time.  However, a view controller<br>&gt;&gt;&gt; might depend on that property in order to render properly across<br>&gt;&gt;&gt; time (for example, configuring cells as they scroll on and off<br>&gt;&gt;&gt; screen).<br>&gt;&gt;  The example is too abstract for me to understand.<br>&gt;&gt; <br>&gt;&gt; Let me put this differently: I recognize that your concept of<br>&gt;&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt;&gt; algorithm/component to work, but it is never a *necessary*<br>&gt;&gt; condition, because genericity (or use of a superclass or protocol<br>&gt;&gt; type) erases details of the actual types involved from the point of<br>&gt;&gt; view of the algorithm/component.  It doesn&#39;t matter if your type<br>&gt;&gt; contains a class reference if it has value semantic properties.  My<br>&gt;&gt; claim is that PureValue is an overly-restrictive constraint that<br>&gt;&gt; makes many things less useful than they should be.<br>&gt;<br>&gt; In many cases this is true - you don’t need more than value semantics<br>&gt; as you define it.  However it is not at all true that PureValue is<br>&gt; never necessary for the correctness of code.  I’m going to provide an<br>&gt; example to the contrary below.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; This property allows us to separate values from non-local mutation<br>&gt;&gt;&gt; and make such separation a requirement.  Rather than observing<br>&gt;&gt;&gt; mutations of objects with KVO, etc we might prefer to observe<br>&gt;&gt;&gt; something that provides a new aggregate value instead, while<br>&gt;&gt;&gt; requiring the entire aggregate value itself to be (observably)<br>&gt;&gt;&gt; immutable at all times (because we stored it with a let property<br>&gt;&gt;&gt; locally).  This can make it easier to reason about correct behavior<br>&gt;&gt;&gt; of your code.  But it doesn&#39;t work unless all visible parts of the<br>&gt;&gt;&gt; aggregate are immutable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth<br>&gt;&gt;&gt; taking a look.<br>&gt;&gt;  That&#39;s a pretty broad link.  At which parts do you think I should<br>&gt;&gt; look?<br>&gt;<br>&gt; The piece that matters here is state management.  The core concept is<br>&gt; to tightly control how mutations happen.  It is modeled in terms of<br>&gt; state type T, an initial value t, an action type A (instances of which<br>&gt; are mutation commands, as in the command pattern), and a reducer<br>&gt; function (T, A) -&gt; T which produces a new state.<br>&gt;<br>&gt; Here’s a toy implementation that is somewhat simplistic but captures<br>&gt; the essence of the concept:<br>&gt;<br>&gt; class Store&lt;State, Action&gt; {<br>&gt;     typealias Reducer = (State, Action) -&gt; State<br>&gt; <br>&gt;     var stateHistory: [State]<br>&gt;     let reducer: Reducer<br>&gt; <br>&gt;     init(initialState: State, reducer: Reducer) {<br>&gt;         stateHistory = [initialState]<br>&gt;         self.reducer = reducer<br>&gt;     }<br>&gt; <br>&gt;     func applyAction(action: Action) {<br>&gt;         let newState = reducer(stateHistory.last!, action)<br>&gt;         stateHistory.append(newState)<br>&gt;     }<br>&gt; <br>&gt;     var currentState: State {<br>&gt;         return stateHistory.last!<br>&gt;     }<br>&gt; <br>&gt;     var canUndo: Bool {<br>&gt;         return stateHistory.count &gt; 1<br>&gt;     }<br>&gt; <br>&gt;     func undo() {<br>&gt;         if canUndo {<br>&gt;             stateHistory.popLast()<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This design relies on State being a PureValue.  The whole idea is that<br>&gt; the only way any path of observation rooted at currentState can change<br>&gt; is when the reducer returns a new state when it is called by<br>&gt; `applyAction`.  That guarantee <br></p><p>I&#39;m sorry, I can&#39;t understand what guarantee you&#39;re describing here.<br>Can you describe it in terms of preconditions, postconditions, and<br>invariants?<br></p><p>Just looking at the code, it seems to me that the only actual<br>requirement for sane results here is that the result (and effects) of<br>the `reducer` function depends only on the values of its arguments.<br>This is a highly precedented kind of requirement.  For example, you<br>don&#39;t expect sort() to produce meaningful results if the comparison<br>function&#39;s result changes based on something other than the values of<br>the elements being compared.<br></p><p>&gt; cannot be provided by value semantics alone under your definition of<br>&gt; value semantics.  Further, each state in the history is intended to be<br>&gt; a static snapshot of the “currentState” state at a specific point in<br>&gt; time.  All states should be logically independent from each other and<br>&gt; from anything anywhere else in the program.  This cannot be guaranteed<br>&gt; under your definition of value semantics.<br></p><p>That is exactly my definition of value semantics (modulo aggregation; a<br>value that is composed of other values obviously is dependent on the<br>values it&#39;s composed of).  But distinct instances of types with value<br>semantics have values that are logically independent.<br></p><p>&gt; If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value<br>&gt; semantics under your definition it is clear that we should have no<br>&gt; expectation that the desired properties are preserved.  <br>&gt; The Store class is fundamentally broken if it can be used with State<br>&gt; types that are not pure values.<br></p><p>It depends on the semantic requirements placed on `reducer`.  If you<br>insist that `reducer` should be able to do anything at all, then clearly<br>you need to constrain `State` in ways that make this component less<br>useful than it might otherwise be.  But even then, you can&#39;t allow<br>`reducer` to *whatever* it wants because it could circle back and modify<br>the `Store` instance.<br></p><p>&gt; I’m not sure why it didn’t occur to me sooner, but this strategy for<br>&gt; managing app state is very similar in nature to what Sean Parent<br>&gt; discusses in his value semantics talk<br>&gt; (https://www.youtube.com/watch?v=_BpMYeUFXv8<br>&gt; &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt; and related<br>&gt; https://www.youtube.com/watch?v=bIhUE5uUFOA<br>&gt; &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;).<br>&gt;<br>&gt; Sean discusses using value semantics to model applications state (he<br>&gt; calls it document).  His examples don’t use reified actions and<br>&gt; reducer functions so it is a bit different but it relies on the same<br>&gt; pure value semantics.  The demo he gives in the talk is a toy example<br>&gt; modeled on the design Photoshop uses to implement its history feature.<br>&gt; This design relies on each document in the history being an aggregate<br>&gt; which is a PureValue.  This is not an academic discussion, but on with<br>&gt; real world practical utility.<br></p><p>I&#39;m very familiar with this talk; it was a major inspiration for my<br>presentation at WWDC last year.  I&#39;ll freely admit I get most of my good<br>ideas from Sean ;-)<br></p><p>&gt; Sean says “value semantics is similar to functional programming,<br>&gt; except objects still have addresses and in-situ operations… You&#39;re<br>&gt; trying to maintain the ability to locally reason about your code but<br>&gt; you&#39;re not denying the fact that the machine has memory and you can do<br>&gt; in-situ operations on it”.  <br>&gt;<br>&gt; Towards the end he quotes from a discussion he had with John Backus<br>&gt; (inventor of FP).  John said: “it always annoyed me that FP and the no<br>&gt; side effect way of programming had become a religion.  With FP I was<br>&gt; trying to come up with a mathematically rigorous way to program and I<br>&gt; understood the complexities of having side effects.  I always knew we<br>&gt; had to deal with side effects, I just wanted a structured way to do<br>&gt; it.”  John agreed that Sean’s approach to value semantics provides<br>&gt; such a structure.  Allowing shared mutable references throws away that<br>&gt; structured approach.  (As an aside, this is the most exciting thing<br>&gt; about value semantics IMO - it provides a structured approach to side<br>&gt; effects, allowing local reasoning about code).<br>&gt;<br>&gt; Sean gives an example of how references break the ability to reason<br>&gt; locally where he has two shared_ptrs that point to the same object:<br>&gt;<br>&gt; &quot;If you look at it in terms of just the individual types you kind of<br>&gt; do have value semantics.  When I copy a shared pointer it copies the<br>&gt; pointer with value semantic operations...  The problem is the<br>&gt; references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if<br>&gt; I have the object.  <br></p><p>This is the key phrase; it is about the implied programming model for<br>shared_ptr, which is a cultural phenomenon, not an absolute truth.  Yes,<br>when people get a reference to a class instance in Swift, they normally<br>don&#39;t even think about what&#39;s stored in the instance as being distinct<br>from the value of the reference, and indeed the language syntax is more<br>hostile to making that distinction than the syntax of C++.  Defining the<br>value of a reference to be the address it points at (unless the instance<br>is immutable) allows everything to fall back into place, logically<br>speaking.<br></p><p>Whether programmers can learn to understand the world this way is<br>certainly debatable, but it&#39;s pretty clear to me that leaving “the value<br>of a reference” undefined is untenable, and defining it in any way that<br>doesn&#39;t result in a reference having value semantics would make<br>describing algorithm semantics almost impossible.  So what&#39;s the<br>alternative?<br></p><p>&gt; So really what I have is two objects that intersect.  So really my<br>&gt; object in the program is this whole connected mess.  At any particular<br>&gt; point in code I have difficulty reasoning about the whole thing.  The<br>&gt; shared structure breaks our ability to reason locally about code.&quot;<br>&gt;<br>&gt; Sean makes an important distinction between looking at individual<br>&gt; types and looking at the aggregate as a whole.  It is very important<br>&gt; to him that the entire aggregate be logically independent as this<br>&gt; facilitates local reasoning.  This is exactly what I have been calling<br>&gt; a pure value.  Pure value never allows any intersection to be observed<br></p><p>Yes, but: you can only measure an intersection of two values if *you<br>stay within the boundaries of those values*.  A value type can contain a<br>reference to a shared cache as an incidental part, and this reference<br>can even be observable, as long as it is clearly distinguished as *not*<br>being within the boundaries of the value.  One consequence of that is<br>that the results of equality comparison would never depend on the state<br>of the cache.<br></p><p>&gt; (immutable intersections are allowed because they cannot be observed,<br>&gt; which Sean alludes to in passing).  Incidentally, it is pretty clear<br>&gt; from the talk that immutable intersection is heavily used in Photoshop<br>&gt; history in order to keep memory use reasonable.  This falls into the<br>&gt; category of persistent data structures.<br>&gt;<br>&gt; My impression is that Sean’s definition of &quot;value semantics” excludes<br>&gt; “intersecting objects” (where the intersection is mutable) and is<br>&gt; aligned with John’s “full value semantics” and the notion of “pure<br>&gt; value” we have been discussing.<br></p><p>I think I discussed this with Sean a week ago...<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 12:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams<br>&gt;&gt;&gt; &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;&gt;&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;&gt;&gt; not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;&gt;&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;&gt;&gt; anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;&gt;&gt; correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s<br>&gt;&gt;&gt;&gt;&gt; an algorithm that manipulates it.  That said, I still don&#39;t have a<br>&gt;&gt;&gt;&gt;&gt; concrete example of how view configuration can depend on these<br>&gt;&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt; The algorithm might just be &quot;copy x bit of data to y view<br>&gt;&gt;&gt;&gt; property, etc&quot;.  That is so trivial that it feels like a stretch to<br>&gt;&gt;&gt;&gt; call it an algorithm.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Algorithms can be trivial.<br>&gt;&gt; <br>&gt;&gt; Fair enough.  Although in most contexts people don’t use the word when<br>&gt;&gt; discussing the trivial.<br>&gt; <br>&gt; Yes, quite a shame, that.<br>&gt; <br>&gt;&gt;&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it<br>&gt;&gt;&gt;&gt; executes at a single point in time.  However, a view controller<br>&gt;&gt;&gt;&gt; might depend on that property in order to render properly across<br>&gt;&gt;&gt;&gt; time (for example, configuring cells as they scroll on and off<br>&gt;&gt;&gt;&gt; screen).<br>&gt;&gt;&gt; The example is too abstract for me to understand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me put this differently: I recognize that your concept of<br>&gt;&gt;&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt;&gt;&gt; algorithm/component to work, but it is never a *necessary*<br>&gt;&gt;&gt; condition, because genericity (or use of a superclass or protocol<br>&gt;&gt;&gt; type) erases details of the actual types involved from the point of<br>&gt;&gt;&gt; view of the algorithm/component.  It doesn&#39;t matter if your type<br>&gt;&gt;&gt; contains a class reference if it has value semantic properties.  My<br>&gt;&gt;&gt; claim is that PureValue is an overly-restrictive constraint that<br>&gt;&gt;&gt; makes many things less useful than they should be.<br>&gt;&gt; <br>&gt;&gt; In many cases this is true - you don’t need more than value semantics<br>&gt;&gt; as you define it.  However it is not at all true that PureValue is<br>&gt;&gt; never necessary for the correctness of code.  I’m going to provide an<br>&gt;&gt; example to the contrary below.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This property allows us to separate values from non-local mutation<br>&gt;&gt;&gt;&gt; and make such separation a requirement.  Rather than observing<br>&gt;&gt;&gt;&gt; mutations of objects with KVO, etc we might prefer to observe<br>&gt;&gt;&gt;&gt; something that provides a new aggregate value instead, while<br>&gt;&gt;&gt;&gt; requiring the entire aggregate value itself to be (observably)<br>&gt;&gt;&gt;&gt; immutable at all times (because we stored it with a let property<br>&gt;&gt;&gt;&gt; locally).  This can make it easier to reason about correct behavior<br>&gt;&gt;&gt;&gt; of your code.  But it doesn&#39;t work unless all visible parts of the<br>&gt;&gt;&gt;&gt; aggregate are immutable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth<br>&gt;&gt;&gt;&gt; taking a look.<br>&gt;&gt;&gt; That&#39;s a pretty broad link.  At which parts do you think I should<br>&gt;&gt;&gt; look?<br>&gt;&gt; <br>&gt;&gt; The piece that matters here is state management.  The core concept is<br>&gt;&gt; to tightly control how mutations happen.  It is modeled in terms of<br>&gt;&gt; state type T, an initial value t, an action type A (instances of which<br>&gt;&gt; are mutation commands, as in the command pattern), and a reducer<br>&gt;&gt; function (T, A) -&gt; T which produces a new state.<br>&gt;&gt; <br>&gt;&gt; Here’s a toy implementation that is somewhat simplistic but captures<br>&gt;&gt; the essence of the concept:<br>&gt;&gt; <br>&gt;&gt; class Store&lt;State, Action&gt; {<br>&gt;&gt;    typealias Reducer = (State, Action) -&gt; State<br>&gt;&gt; <br>&gt;&gt;    var stateHistory: [State]<br>&gt;&gt;    let reducer: Reducer<br>&gt;&gt; <br>&gt;&gt;    init(initialState: State, reducer: Reducer) {<br>&gt;&gt;        stateHistory = [initialState]<br>&gt;&gt;        self.reducer = reducer<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func applyAction(action: Action) {<br>&gt;&gt;        let newState = reducer(stateHistory.last!, action)<br>&gt;&gt;        stateHistory.append(newState)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var currentState: State {<br>&gt;&gt;        return stateHistory.last!<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var canUndo: Bool {<br>&gt;&gt;        return stateHistory.count &gt; 1<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func undo() {<br>&gt;&gt;        if canUndo {<br>&gt;&gt;            stateHistory.popLast()<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This design relies on State being a PureValue.  The whole idea is that<br>&gt;&gt; the only way any path of observation rooted at currentState can change<br>&gt;&gt; is when the reducer returns a new state when it is called by<br>&gt;&gt; `applyAction`.  That guarantee <br>&gt; <br>&gt; I&#39;m sorry, I can&#39;t understand what guarantee you&#39;re describing here.<br>&gt; Can you describe it in terms of preconditions, postconditions, and<br>&gt; invariants?<br></p><p>I don’t think so.  You could state precondition, postconditions, and invariants that would all rely on `==`.  However, if reference semantic types implement `==` as `===` these would not be strong enough to provide the intended guarantee.<br></p><p>The guarantee depends on preventing *other code* from mutating values in `stateHistory`.  If State is Array&lt;TypeWithMutableReferenceSemantics&gt; and some other code has a reference to the objects in the array the *other* code might mutate those objects.  This would violate the semantic guarantee that is intended.  But any preconditions, postconditions, and invariants stated using `==` would still be preserved because those shared mutable references still compare equal.<br></p><p>&gt; <br>&gt; Just looking at the code, it seems to me that the only actual<br>&gt; requirement for sane results here is that the result (and effects) of<br>&gt; the `reducer` function depends only on the values of its arguments.<br>&gt; This is a highly precedented kind of requirement.  For example, you<br>&gt; don&#39;t expect sort() to produce meaningful results if the comparison<br>&gt; function&#39;s result changes based on something other than the values of<br>&gt; the elements being compared.<br></p><p>Yes, the reducer must be pure.  But that is not enough for `Store` to behave as intended.<br></p><p>&gt; <br>&gt;&gt; cannot be provided by value semantics alone under your definition of<br>&gt;&gt; value semantics.  Further, each state in the history is intended to be<br>&gt;&gt; a static snapshot of the “currentState” state at a specific point in<br>&gt;&gt; time.  All states should be logically independent from each other and<br>&gt;&gt; from anything anywhere else in the program.  This cannot be guaranteed<br>&gt;&gt; under your definition of value semantics.<br>&gt; <br>&gt; That is exactly my definition of value semantics (modulo aggregation; a<br>&gt; value that is composed of other values obviously is dependent on the<br>&gt; values it&#39;s composed of).  But distinct instances of types with value<br>&gt; semantics have values that are logically independent.<br></p><p>The modulo aggregation thing is exactly what this whole thread hinges on.  What I am saying is that sometimes it is important that the aggregate as a whole have value semantics.  In other words, if any of it’s salient attributes are references the objects they point to must have value semantics (which requires immutability).<br></p><p>&gt; <br>&gt;&gt; If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value<br>&gt;&gt; semantics under your definition it is clear that we should have no<br>&gt;&gt; expectation that the desired properties are preserved.  <br>&gt;&gt; The Store class is fundamentally broken if it can be used with State<br>&gt;&gt; types that are not pure values.<br>&gt; <br>&gt; It depends on the semantic requirements placed on `reducer`.  If you<br>&gt; insist that `reducer` should be able to do anything at all, then clearly<br>&gt; you need to constrain `State` in ways that make this component less<br>&gt; useful than it might otherwise be.  But even then, you can&#39;t allow<br>&gt; `reducer` to *whatever* it wants because it could circle back and modify<br>&gt; the `Store` instance.<br></p><p>`reducer` is intended to be pure.  I didn’t specify that because Swift doesn’t have syntax for it.  I was just giving valid Swift code and discussing the latent requirements of `State`.<br></p><p>Requiring `reducer` to be pure is not enough if we allow `State` to have salient mutable reference semantics attributes.  The references contained in `initialState` and visible via `currentState` could be captured and mutated by any code working with the store.<br></p><p>&gt; <br>&gt;&gt; I’m not sure why it didn’t occur to me sooner, but this strategy for<br>&gt;&gt; managing app state is very similar in nature to what Sean Parent<br>&gt;&gt; discusses in his value semantics talk<br>&gt;&gt; (https://www.youtube.com/watch?v=_BpMYeUFXv8<br>&gt;&gt; &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt; and related<br>&gt;&gt; https://www.youtube.com/watch?v=bIhUE5uUFOA<br>&gt;&gt; &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;).<br>&gt;&gt; <br>&gt;&gt; Sean discusses using value semantics to model applications state (he<br>&gt;&gt; calls it document).  His examples don’t use reified actions and<br>&gt;&gt; reducer functions so it is a bit different but it relies on the same<br>&gt;&gt; pure value semantics.  The demo he gives in the talk is a toy example<br>&gt;&gt; modeled on the design Photoshop uses to implement its history feature.<br>&gt;&gt; This design relies on each document in the history being an aggregate<br>&gt;&gt; which is a PureValue.  This is not an academic discussion, but on with<br>&gt;&gt; real world practical utility.<br>&gt; <br>&gt; I&#39;m very familiar with this talk; it was a major inspiration for my<br>&gt; presentation at WWDC last year.  I&#39;ll freely admit I get most of my good<br>&gt; ideas from Sean ;-)<br></p><p>Great!  I would be pretty surprised if Sean thinks the distinction I am trying to make is unimportant.  His talk indicates that he is very concerned about shared mutable state.  All I am looking for is a constraint that lets me say “the aggregate rooted at type Foo does not contain shared mutable state”.<br></p><p>&gt; <br>&gt;&gt; Sean says “value semantics is similar to functional programming,<br>&gt;&gt; except objects still have addresses and in-situ operations… You&#39;re<br>&gt;&gt; trying to maintain the ability to locally reason about your code but<br>&gt;&gt; you&#39;re not denying the fact that the machine has memory and you can do<br>&gt;&gt; in-situ operations on it”.  <br>&gt;&gt; <br>&gt;&gt; Towards the end he quotes from a discussion he had with John Backus<br>&gt;&gt; (inventor of FP).  John said: “it always annoyed me that FP and the no<br>&gt;&gt; side effect way of programming had become a religion.  With FP I was<br>&gt;&gt; trying to come up with a mathematically rigorous way to program and I<br>&gt;&gt; understood the complexities of having side effects.  I always knew we<br>&gt;&gt; had to deal with side effects, I just wanted a structured way to do<br>&gt;&gt; it.”  John agreed that Sean’s approach to value semantics provides<br>&gt;&gt; such a structure.  Allowing shared mutable references throws away that<br>&gt;&gt; structured approach.  (As an aside, this is the most exciting thing<br>&gt;&gt; about value semantics IMO - it provides a structured approach to side<br>&gt;&gt; effects, allowing local reasoning about code).<br>&gt;&gt; <br>&gt;&gt; Sean gives an example of how references break the ability to reason<br>&gt;&gt; locally where he has two shared_ptrs that point to the same object:<br>&gt;&gt; <br>&gt;&gt; &quot;If you look at it in terms of just the individual types you kind of<br>&gt;&gt; do have value semantics.  When I copy a shared pointer it copies the<br>&gt;&gt; pointer with value semantic operations...  The problem is the<br>&gt;&gt; references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if<br>&gt;&gt; I have the object.  <br>&gt; <br>&gt; This is the key phrase; it is about the implied programming model for<br>&gt; shared_ptr, which is a cultural phenomenon, not an absolute truth.  <br></p><p>I’m not quite sure I follow you here.  Sean has a slide in the presentation which shows two shared_ptrs to the same object.  He draws a boundary around the whole thing and calls that (both shared_ptrs *and* the object) the value.  His point is that you cannot consider the shared_ptr on its own, or even one of the shared_ptrs and the object that is referenced.  They are intricately inter-related.<br></p><p>&gt; Yes,<br>&gt; when people get a reference to a class instance in Swift, they normally<br>&gt; don&#39;t even think about what&#39;s stored in the instance as being distinct<br>&gt; from the value of the reference, and indeed the language syntax is more<br>&gt; hostile to making that distinction than the syntax of C++.  Defining the<br>&gt; value of a reference to be the address it points at (unless the instance<br>&gt; is immutable) allows everything to fall back into place, logically<br>&gt; speaking.<br>&gt; <br>&gt; Whether programmers can learn to understand the world this way is<br>&gt; certainly debatable, but it&#39;s pretty clear to me that leaving “the value<br>&gt; of a reference” undefined is untenable, and defining it in any way that<br>&gt; doesn&#39;t result in a reference having value semantics would make<br>&gt; describing algorithm semantics almost impossible.  So what&#39;s the<br>&gt; alternative?<br></p><p>I agree that this is the right approach when you are writing algorithms like `rotate`, etc.  The reference is the value you’re concerned with.<br></p><p>I also think it is important to be able to make a distinction between an aggregate that is logically independent from any other data structures in your program and an aggregate which contains shared references to mutable state that is also referenced elsewhere in your program.  In this case you are concerned with the state that is referenced (specifically, whether it the state is mutable and whether you have a reference that is guaranteed to always be unique - like unique_ptr or an owned reference in Rust - or not).<br></p><p>We need to be able to look at the world both ways.  They are both very useful in different contexts.<br></p><p>&gt; <br>&gt;&gt; So really what I have is two objects that intersect.  So really my<br>&gt;&gt; object in the program is this whole connected mess.  At any particular<br>&gt;&gt; point in code I have difficulty reasoning about the whole thing.  The<br>&gt;&gt; shared structure breaks our ability to reason locally about code.&quot;<br>&gt;&gt; <br>&gt;&gt; Sean makes an important distinction between looking at individual<br>&gt;&gt; types and looking at the aggregate as a whole.  It is very important<br>&gt;&gt; to him that the entire aggregate be logically independent as this<br>&gt;&gt; facilitates local reasoning.  This is exactly what I have been calling<br>&gt;&gt; a pure value.  Pure value never allows any intersection to be observed<br>&gt; <br>&gt; Yes, but: you can only measure an intersection of two values if *you<br>&gt; stay within the boundaries of those values*.  <br></p><p>If you consider a shared_ptr to define the boundary of its value then this is not what Sean said.  In Sean’s talk he calls the object that two shared_ptrs reference the “intersection”.  He crosses the reference when measuring intersection.<br></p><p>&gt; A value type can contain a<br>&gt; reference to a shared cache as an incidental part, and this reference<br>&gt; can even be observable, as long as it is clearly distinguished as *not*<br>&gt; being within the boundaries of the value.  One consequence of that is<br>&gt; that the results of equality comparison would never depend on the state<br>&gt; of the cache.<br></p><p>Agree.  I’m not sure why you would expose the cache, but it is effectively the same as the capacity of an array.  It is incidental and implementation related, not part of the salient semantics of the type.<br></p><p>&gt; <br>&gt;&gt; (immutable intersections are allowed because they cannot be observed,<br>&gt;&gt; which Sean alludes to in passing).  Incidentally, it is pretty clear<br>&gt;&gt; from the talk that immutable intersection is heavily used in Photoshop<br>&gt;&gt; history in order to keep memory use reasonable.  This falls into the<br>&gt;&gt; category of persistent data structures.<br>&gt;&gt; <br>&gt;&gt; My impression is that Sean’s definition of &quot;value semantics” excludes<br>&gt;&gt; “intersecting objects” (where the intersection is mutable) and is<br>&gt;&gt; aligned with John’s “full value semantics” and the notion of “pure<br>&gt;&gt; value” we have been discussing.<br>&gt; <br>&gt; I think I discussed this with Sean a week ago…<br></p><p>And what was the outcome of that discussion?  I would be very interested in hearing what he had to say. <br></p><p>Let’s consider the Photoshop history example since that ties back to something we know has proven to work very well in practice in a large scale application.  <br></p><p>I’ll approximate based on what I could infer from Sean’s talk.  Among other things, the document aggregate contains bitmap values.  These are structured as a container of pointers to pixel buffers.  The entire document aggregate is a persistent data structure that uses CoW to share as much memory as possible between snapshots.  When a drawing operation is performed, relevant pixel buffers are copied and mutated by the operation and a new document snapshot is added to the history.<br></p><p>It is absolutely essential to this design that the pixel buffer pointers are not shared with code that can write to them.  If this was allowed many snapshots would likely be affected and the history would be corrupted.<br></p><p>The `Store` example above is intended to preserve the same semantics as Photoshop does with its history feature.  This depends on `State` being a pure value.  If `State` is `Array&lt;MutableReferenceSemanticType&gt;` those semantics simply cannot be preserved.  It is admittedly a toy example but I think it serves to demonstrate the point.<br></p><p>You could argue it is unnecessarily limiting to constrain `State` to be a pure value.  I don’t think that’s a fair critique.  In any practical scenario where you would use `State` you actually *want* this constraint and want as much help as possible in ensuring that your program adheres to it.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/814b94f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 24, 2016 at 02:00:00am</p></header><div class="content"><p>I just want to highlight the Photoshop history example. I agree you’d want as much state and memory shared between steps in the history.<br></p><p>However, I see nothing wrong with having pointers to pixel buffer, and that affecting the ‘purity’ of the state. The way Photoshop’s history is implemented, is every image is broken up into tiles. Changes are recorded only within touched tiles. (http://www.photoshopforphotographers.com/CC_2013/Help_guide/tp/History_palette.html &lt;http://www.photoshopforphotographers.com/CC_2013/Help_guide/tp/History_palette.html&gt;) This improves memory usage compared to a single pixel buffer. With a graphics programming workflow, say where a background thread or the GPU is involved, the contents of those pixel buffers are going to change independently to the history stack. I think there would no problem for the history steps to have pointers to their mutable pixel buffers. Once the thread/GPU has finished processing changes within a step’s pixel buffer, it is ‘sealed’ say with a flag, and can’t be mutated later.<br></p><p>The only other way I could think of is for each history step to use UUIDs to reference tile pixel buffers, and manage a separate map of [UUID: PixelBuffer]. Possibly this approach might have other benefits, but I think it doesn’t differ practically in ‘purity’ of state vs one state tree involving pointers. The purity is from the point of view of the programmer, where they know their system is purely additive.<br></p><p>The guarantee is in the system the programmer has created. Not allowing pointers to carefully managed mutable state is too rigid.<br></p><p><br>&gt; On 23 May 2016, at 5:12 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 22, 2016, at 12:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; an algorithm that manipulates it.  That said, I still don&#39;t have a<br>&gt;&gt;&gt;&gt;&gt;&gt; concrete example of how view configuration can depend on these<br>&gt;&gt;&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt;&gt; The algorithm might just be &quot;copy x bit of data to y view<br>&gt;&gt;&gt;&gt;&gt; property, etc&quot;.  That is so trivial that it feels like a stretch to<br>&gt;&gt;&gt;&gt;&gt; call it an algorithm.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Algorithms can be trivial.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair enough.  Although in most contexts people don’t use the word when<br>&gt;&gt;&gt; discussing the trivial.<br>&gt;&gt; <br>&gt;&gt; Yes, quite a shame, that.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it<br>&gt;&gt;&gt;&gt;&gt; executes at a single point in time.  However, a view controller<br>&gt;&gt;&gt;&gt;&gt; might depend on that property in order to render properly across<br>&gt;&gt;&gt;&gt;&gt; time (for example, configuring cells as they scroll on and off<br>&gt;&gt;&gt;&gt;&gt; screen).<br>&gt;&gt;&gt;&gt; The example is too abstract for me to understand.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me put this differently: I recognize that your concept of<br>&gt;&gt;&gt;&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt;&gt;&gt;&gt; algorithm/component to work, but it is never a *necessary*<br>&gt;&gt;&gt;&gt; condition, because genericity (or use of a superclass or protocol<br>&gt;&gt;&gt;&gt; type) erases details of the actual types involved from the point of<br>&gt;&gt;&gt;&gt; view of the algorithm/component.  It doesn&#39;t matter if your type<br>&gt;&gt;&gt;&gt; contains a class reference if it has value semantic properties.  My<br>&gt;&gt;&gt;&gt; claim is that PureValue is an overly-restrictive constraint that<br>&gt;&gt;&gt;&gt; makes many things less useful than they should be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In many cases this is true - you don’t need more than value semantics<br>&gt;&gt;&gt; as you define it.  However it is not at all true that PureValue is<br>&gt;&gt;&gt; never necessary for the correctness of code.  I’m going to provide an<br>&gt;&gt;&gt; example to the contrary below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This property allows us to separate values from non-local mutation<br>&gt;&gt;&gt;&gt;&gt; and make such separation a requirement.  Rather than observing<br>&gt;&gt;&gt;&gt;&gt; mutations of objects with KVO, etc we might prefer to observe<br>&gt;&gt;&gt;&gt;&gt; something that provides a new aggregate value instead, while<br>&gt;&gt;&gt;&gt;&gt; requiring the entire aggregate value itself to be (observably)<br>&gt;&gt;&gt;&gt;&gt; immutable at all times (because we stored it with a let property<br>&gt;&gt;&gt;&gt;&gt; locally).  This can make it easier to reason about correct behavior<br>&gt;&gt;&gt;&gt;&gt; of your code.  But it doesn&#39;t work unless all visible parts of the<br>&gt;&gt;&gt;&gt;&gt; aggregate are immutable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth<br>&gt;&gt;&gt;&gt;&gt; taking a look.<br>&gt;&gt;&gt;&gt; That&#39;s a pretty broad link.  At which parts do you think I should<br>&gt;&gt;&gt;&gt; look?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The piece that matters here is state management.  The core concept is<br>&gt;&gt;&gt; to tightly control how mutations happen.  It is modeled in terms of<br>&gt;&gt;&gt; state type T, an initial value t, an action type A (instances of which<br>&gt;&gt;&gt; are mutation commands, as in the command pattern), and a reducer<br>&gt;&gt;&gt; function (T, A) -&gt; T which produces a new state.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a toy implementation that is somewhat simplistic but captures<br>&gt;&gt;&gt; the essence of the concept:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Store&lt;State, Action&gt; {<br>&gt;&gt;&gt;    typealias Reducer = (State, Action) -&gt; State<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var stateHistory: [State]<br>&gt;&gt;&gt;    let reducer: Reducer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    init(initialState: State, reducer: Reducer) {<br>&gt;&gt;&gt;        stateHistory = [initialState]<br>&gt;&gt;&gt;        self.reducer = reducer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func applyAction(action: Action) {<br>&gt;&gt;&gt;        let newState = reducer(stateHistory.last!, action)<br>&gt;&gt;&gt;        stateHistory.append(newState)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var currentState: State {<br>&gt;&gt;&gt;        return stateHistory.last!<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var canUndo: Bool {<br>&gt;&gt;&gt;        return stateHistory.count &gt; 1<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func undo() {<br>&gt;&gt;&gt;        if canUndo {<br>&gt;&gt;&gt;            stateHistory.popLast()<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This design relies on State being a PureValue.  The whole idea is that<br>&gt;&gt;&gt; the only way any path of observation rooted at currentState can change<br>&gt;&gt;&gt; is when the reducer returns a new state when it is called by<br>&gt;&gt;&gt; `applyAction`.  That guarantee <br>&gt;&gt; <br>&gt;&gt; I&#39;m sorry, I can&#39;t understand what guarantee you&#39;re describing here.<br>&gt;&gt; Can you describe it in terms of preconditions, postconditions, and<br>&gt;&gt; invariants?<br>&gt; <br>&gt; I don’t think so.  You could state precondition, postconditions, and invariants that would all rely on `==`.  However, if reference semantic types implement `==` as `===` these would not be strong enough to provide the intended guarantee.<br>&gt; <br>&gt; The guarantee depends on preventing *other code* from mutating values in `stateHistory`.  If State is Array&lt;TypeWithMutableReferenceSemantics&gt; and some other code has a reference to the objects in the array the *other* code might mutate those objects.  This would violate the semantic guarantee that is intended.  But any preconditions, postconditions, and invariants stated using `==` would still be preserved because those shared mutable references still compare equal.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Just looking at the code, it seems to me that the only actual<br>&gt;&gt; requirement for sane results here is that the result (and effects) of<br>&gt;&gt; the `reducer` function depends only on the values of its arguments.<br>&gt;&gt; This is a highly precedented kind of requirement.  For example, you<br>&gt;&gt; don&#39;t expect sort() to produce meaningful results if the comparison<br>&gt;&gt; function&#39;s result changes based on something other than the values of<br>&gt;&gt; the elements being compared.<br>&gt; <br>&gt; Yes, the reducer must be pure.  But that is not enough for `Store` to behave as intended.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; cannot be provided by value semantics alone under your definition of<br>&gt;&gt;&gt; value semantics.  Further, each state in the history is intended to be<br>&gt;&gt;&gt; a static snapshot of the “currentState” state at a specific point in<br>&gt;&gt;&gt; time.  All states should be logically independent from each other and<br>&gt;&gt;&gt; from anything anywhere else in the program.  This cannot be guaranteed<br>&gt;&gt;&gt; under your definition of value semantics.<br>&gt;&gt; <br>&gt;&gt; That is exactly my definition of value semantics (modulo aggregation; a<br>&gt;&gt; value that is composed of other values obviously is dependent on the<br>&gt;&gt; values it&#39;s composed of).  But distinct instances of types with value<br>&gt;&gt; semantics have values that are logically independent.<br>&gt; <br>&gt; The modulo aggregation thing is exactly what this whole thread hinges on.  What I am saying is that sometimes it is important that the aggregate as a whole have value semantics.  In other words, if any of it’s salient attributes are references the objects they point to must have value semantics (which requires immutability).<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value<br>&gt;&gt;&gt; semantics under your definition it is clear that we should have no<br>&gt;&gt;&gt; expectation that the desired properties are preserved.  <br>&gt;&gt;&gt; The Store class is fundamentally broken if it can be used with State<br>&gt;&gt;&gt; types that are not pure values.<br>&gt;&gt; <br>&gt;&gt; It depends on the semantic requirements placed on `reducer`.  If you<br>&gt;&gt; insist that `reducer` should be able to do anything at all, then clearly<br>&gt;&gt; you need to constrain `State` in ways that make this component less<br>&gt;&gt; useful than it might otherwise be.  But even then, you can&#39;t allow<br>&gt;&gt; `reducer` to *whatever* it wants because it could circle back and modify<br>&gt;&gt; the `Store` instance.<br>&gt; <br>&gt; `reducer` is intended to be pure.  I didn’t specify that because Swift doesn’t have syntax for it.  I was just giving valid Swift code and discussing the latent requirements of `State`.<br>&gt; <br>&gt; Requiring `reducer` to be pure is not enough if we allow `State` to have salient mutable reference semantics attributes.  The references contained in `initialState` and visible via `currentState` could be captured and mutated by any code working with the store.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I’m not sure why it didn’t occur to me sooner, but this strategy for<br>&gt;&gt;&gt; managing app state is very similar in nature to what Sean Parent<br>&gt;&gt;&gt; discusses in his value semantics talk<br>&gt;&gt;&gt; (https://www.youtube.com/watch?v=_BpMYeUFXv8 &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt;<br>&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8 &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt;&gt; and related<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=bIhUE5uUFOA &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;<br>&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sean discusses using value semantics to model applications state (he<br>&gt;&gt;&gt; calls it document).  His examples don’t use reified actions and<br>&gt;&gt;&gt; reducer functions so it is a bit different but it relies on the same<br>&gt;&gt;&gt; pure value semantics.  The demo he gives in the talk is a toy example<br>&gt;&gt;&gt; modeled on the design Photoshop uses to implement its history feature.<br>&gt;&gt;&gt; This design relies on each document in the history being an aggregate<br>&gt;&gt;&gt; which is a PureValue.  This is not an academic discussion, but on with<br>&gt;&gt;&gt; real world practical utility.<br>&gt;&gt; <br>&gt;&gt; I&#39;m very familiar with this talk; it was a major inspiration for my<br>&gt;&gt; presentation at WWDC last year.  I&#39;ll freely admit I get most of my good<br>&gt;&gt; ideas from Sean ;-)<br>&gt; <br>&gt; Great!  I would be pretty surprised if Sean thinks the distinction I am trying to make is unimportant.  His talk indicates that he is very concerned about shared mutable state.  All I am looking for is a constraint that lets me say “the aggregate rooted at type Foo does not contain shared mutable state”.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Sean says “value semantics is similar to functional programming,<br>&gt;&gt;&gt; except objects still have addresses and in-situ operations… You&#39;re<br>&gt;&gt;&gt; trying to maintain the ability to locally reason about your code but<br>&gt;&gt;&gt; you&#39;re not denying the fact that the machine has memory and you can do<br>&gt;&gt;&gt; in-situ operations on it”.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Towards the end he quotes from a discussion he had with John Backus<br>&gt;&gt;&gt; (inventor of FP).  John said: “it always annoyed me that FP and the no<br>&gt;&gt;&gt; side effect way of programming had become a religion.  With FP I was<br>&gt;&gt;&gt; trying to come up with a mathematically rigorous way to program and I<br>&gt;&gt;&gt; understood the complexities of having side effects.  I always knew we<br>&gt;&gt;&gt; had to deal with side effects, I just wanted a structured way to do<br>&gt;&gt;&gt; it.”  John agreed that Sean’s approach to value semantics provides<br>&gt;&gt;&gt; such a structure.  Allowing shared mutable references throws away that<br>&gt;&gt;&gt; structured approach.  (As an aside, this is the most exciting thing<br>&gt;&gt;&gt; about value semantics IMO - it provides a structured approach to side<br>&gt;&gt;&gt; effects, allowing local reasoning about code).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sean gives an example of how references break the ability to reason<br>&gt;&gt;&gt; locally where he has two shared_ptrs that point to the same object:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;If you look at it in terms of just the individual types you kind of<br>&gt;&gt;&gt; do have value semantics.  When I copy a shared pointer it copies the<br>&gt;&gt;&gt; pointer with value semantic operations...  The problem is the<br>&gt;&gt;&gt; references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if<br>&gt;&gt;&gt; I have the object.  <br>&gt;&gt; <br>&gt;&gt; This is the key phrase; it is about the implied programming model for<br>&gt;&gt; shared_ptr, which is a cultural phenomenon, not an absolute truth.  <br>&gt; <br>&gt; I’m not quite sure I follow you here.  Sean has a slide in the presentation which shows two shared_ptrs to the same object.  He draws a boundary around the whole thing and calls that (both shared_ptrs *and* the object) the value.  His point is that you cannot consider the shared_ptr on its own, or even one of the shared_ptrs and the object that is referenced.  They are intricately inter-related.<br>&gt; <br>&gt;&gt; Yes,<br>&gt;&gt; when people get a reference to a class instance in Swift, they normally<br>&gt;&gt; don&#39;t even think about what&#39;s stored in the instance as being distinct<br>&gt;&gt; from the value of the reference, and indeed the language syntax is more<br>&gt;&gt; hostile to making that distinction than the syntax of C++.  Defining the<br>&gt;&gt; value of a reference to be the address it points at (unless the instance<br>&gt;&gt; is immutable) allows everything to fall back into place, logically<br>&gt;&gt; speaking.<br>&gt;&gt; <br>&gt;&gt; Whether programmers can learn to understand the world this way is<br>&gt;&gt; certainly debatable, but it&#39;s pretty clear to me that leaving “the value<br>&gt;&gt; of a reference” undefined is untenable, and defining it in any way that<br>&gt;&gt; doesn&#39;t result in a reference having value semantics would make<br>&gt;&gt; describing algorithm semantics almost impossible.  So what&#39;s the<br>&gt;&gt; alternative?<br>&gt; <br>&gt; I agree that this is the right approach when you are writing algorithms like `rotate`, etc.  The reference is the value you’re concerned with.<br>&gt; <br>&gt; I also think it is important to be able to make a distinction between an aggregate that is logically independent from any other data structures in your program and an aggregate which contains shared references to mutable state that is also referenced elsewhere in your program.  In this case you are concerned with the state that is referenced (specifically, whether it the state is mutable and whether you have a reference that is guaranteed to always be unique - like unique_ptr or an owned reference in Rust - or not).<br>&gt; <br>&gt; We need to be able to look at the world both ways.  They are both very useful in different contexts.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; So really what I have is two objects that intersect.  So really my<br>&gt;&gt;&gt; object in the program is this whole connected mess.  At any particular<br>&gt;&gt;&gt; point in code I have difficulty reasoning about the whole thing.  The<br>&gt;&gt;&gt; shared structure breaks our ability to reason locally about code.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sean makes an important distinction between looking at individual<br>&gt;&gt;&gt; types and looking at the aggregate as a whole.  It is very important<br>&gt;&gt;&gt; to him that the entire aggregate be logically independent as this<br>&gt;&gt;&gt; facilitates local reasoning.  This is exactly what I have been calling<br>&gt;&gt;&gt; a pure value.  Pure value never allows any intersection to be observed<br>&gt;&gt; <br>&gt;&gt; Yes, but: you can only measure an intersection of two values if *you<br>&gt;&gt; stay within the boundaries of those values*.  <br>&gt; <br>&gt; If you consider a shared_ptr to define the boundary of its value then this is not what Sean said.  In Sean’s talk he calls the object that two shared_ptrs reference the “intersection”.  He crosses the reference when measuring intersection.<br>&gt; <br>&gt;&gt; A value type can contain a<br>&gt;&gt; reference to a shared cache as an incidental part, and this reference<br>&gt;&gt; can even be observable, as long as it is clearly distinguished as *not*<br>&gt;&gt; being within the boundaries of the value.  One consequence of that is<br>&gt;&gt; that the results of equality comparison would never depend on the state<br>&gt;&gt; of the cache.<br>&gt; <br>&gt; Agree.  I’m not sure why you would expose the cache, but it is effectively the same as the capacity of an array.  It is incidental and implementation related, not part of the salient semantics of the type.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; (immutable intersections are allowed because they cannot be observed,<br>&gt;&gt;&gt; which Sean alludes to in passing).  Incidentally, it is pretty clear<br>&gt;&gt;&gt; from the talk that immutable intersection is heavily used in Photoshop<br>&gt;&gt;&gt; history in order to keep memory use reasonable.  This falls into the<br>&gt;&gt;&gt; category of persistent data structures.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My impression is that Sean’s definition of &quot;value semantics” excludes<br>&gt;&gt;&gt; “intersecting objects” (where the intersection is mutable) and is<br>&gt;&gt;&gt; aligned with John’s “full value semantics” and the notion of “pure<br>&gt;&gt;&gt; value” we have been discussing.<br>&gt;&gt; <br>&gt;&gt; I think I discussed this with Sean a week ago…<br>&gt; <br>&gt; And what was the outcome of that discussion?  I would be very interested in hearing what he had to say. <br>&gt; <br>&gt; Let’s consider the Photoshop history example since that ties back to something we know has proven to work very well in practice in a large scale application.  <br>&gt; <br>&gt; I’ll approximate based on what I could infer from Sean’s talk.  Among other things, the document aggregate contains bitmap values.  These are structured as a container of pointers to pixel buffers.  The entire document aggregate is a persistent data structure that uses CoW to share as much memory as possible between snapshots.  When a drawing operation is performed, relevant pixel buffers are copied and mutated by the operation and a new document snapshot is added to the history.<br>&gt; <br>&gt; It is absolutely essential to this design that the pixel buffer pointers are not shared with code that can write to them.  If this was allowed many snapshots would likely be affected and the history would be corrupted.<br>&gt; <br>&gt; The `Store` example above is intended to preserve the same semantics as Photoshop does with its history feature.  This depends on `State` being a pure value.  If `State` is `Array&lt;MutableReferenceSemanticType&gt;` those semantics simply cannot be preserved.  It is admittedly a toy example but I think it serves to demonstrate the point.<br>&gt; <br>&gt; You could argue it is unnecessarily limiting to constrain `State` to be a pure value.  I don’t think that’s a fair critique.  In any practical scenario where you would use `State` you actually *want* this constraint and want as much help as possible in ensuring that your program adheres to it.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/0e860087/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 11:19 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; I just want to highlight the Photoshop history example. I agree you’d want as much state and memory shared between steps in the history.<br>&gt; <br>&gt; However, I see nothing wrong with having pointers to pixel buffer, and that affecting the ‘purity’ of the state.<br></p><p>I don’t have a problem with pointers to pixel buffers.  What I have a problem with is pointers to shared mutable state.  All you need to do is implement a value type that wraps the pointer and performs CoW before updating.  Now you have an efficient pixel buffer that is a pure value type.<br></p><p>&gt; The way Photoshop’s history is implemented, is every image is broken up into tiles. Changes are recorded only within touched tiles. (http://www.photoshopforphotographers.com/CC_2013/Help_guide/tp/History_palette.html &lt;http://www.photoshopforphotographers.com/CC_2013/Help_guide/tp/History_palette.html&gt;) This improves memory usage compared to a single pixel buffer.<br></p><p>Yep, I know how it is implemented and believe I described this upthread.  <br></p><p>&gt; With a graphics programming workflow, say where a background thread or the GPU is involved, the contents of those pixel buffers are going to change independently to the history stack. I think there would no problem for the history steps to have pointers to their mutable pixel buffers. Once the thread/GPU has finished processing changes within a step’s pixel buffer, it is ‘sealed’ say with a flag, and can’t be mutated later.<br></p><p>If you don’t know what the new value is synchronously then it certainly isn’t quite as simple.  But you can still encapsulate this in a type that holds the pointer, performs CoW when necessary, and ensures that the pixel buffer isn’t written to other than by the job that is processing the pixels for this step.  The physical pixels are mutated, but the “logical value” isn’t.  The logical value is the result of a pure function “applyEditToPixels(oldPixels)” which is captured by the new step in the history.  The mutation is tightly encapsulated as an implementation detail.  <br></p><p>I agree that we need to allow for implementation details like this.  But we should find other ways when possible.  And we should probably have to be explicitly clear about our intent if we want to implement a pure value which is hiding an implementation like this.<br></p><p>&gt; <br>&gt; The only other way I could think of is for each history step to use UUIDs to reference tile pixel buffers, and manage a separate map of [UUID: PixelBuffer]. Possibly this approach might have other benefits, but I think it doesn’t differ practically in ‘purity’ of state vs one state tree involving pointers. The purity is from the point of view of the programmer, where they know their system is purely additive.<br>&gt; <br>&gt; The guarantee is in the system the programmer has created. Not allowing pointers to carefully managed mutable state is too rigid.<br></p><p>I am not suggesting they shouldn’t be allowed.  I absolutely agree that they *should* be allowed!  This is one reason why I love Swift!  It blends functional and imperative in a very nice way.<br></p><p>It seems likely that we will eventually have ownership semantics of some kind in Swift.  When we have that we will have the ability to have unique references to mutable state.  I have no problem viewing that as a pure value, because the mutation is local.  It is really no different than a `var Int`, it is just indirect.<br></p><p>However, if we share references to the mutable state then we are introducing potential for non-local mutation.  I believe it is extremely useful to have *parts* of our program that don’t allow for this, and ideally get the compilers help with ensuring this.<br></p><p>I hope that doesn’t seem like to rigid a request!  I want *choice* not rigidity!<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On 23 May 2016, at 5:12 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 12:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm that manipulates it.  That said, I still don&#39;t have a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; concrete example of how view configuration can depend on these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt;&gt;&gt; The algorithm might just be &quot;copy x bit of data to y view<br>&gt;&gt;&gt;&gt;&gt;&gt; property, etc&quot;.  That is so trivial that it feels like a stretch to<br>&gt;&gt;&gt;&gt;&gt;&gt; call it an algorithm.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Algorithms can be trivial.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fair enough.  Although in most contexts people don’t use the word when<br>&gt;&gt;&gt;&gt; discussing the trivial.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, quite a shame, that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it<br>&gt;&gt;&gt;&gt;&gt;&gt; executes at a single point in time.  However, a view controller<br>&gt;&gt;&gt;&gt;&gt;&gt; might depend on that property in order to render properly across<br>&gt;&gt;&gt;&gt;&gt;&gt; time (for example, configuring cells as they scroll on and off<br>&gt;&gt;&gt;&gt;&gt;&gt; screen).<br>&gt;&gt;&gt;&gt;&gt; The example is too abstract for me to understand.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me put this differently: I recognize that your concept of<br>&gt;&gt;&gt;&gt;&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt;&gt;&gt;&gt;&gt; algorithm/component to work, but it is never a *necessary*<br>&gt;&gt;&gt;&gt;&gt; condition, because genericity (or use of a superclass or protocol<br>&gt;&gt;&gt;&gt;&gt; type) erases details of the actual types involved from the point of<br>&gt;&gt;&gt;&gt;&gt; view of the algorithm/component.  It doesn&#39;t matter if your type<br>&gt;&gt;&gt;&gt;&gt; contains a class reference if it has value semantic properties.  My<br>&gt;&gt;&gt;&gt;&gt; claim is that PureValue is an overly-restrictive constraint that<br>&gt;&gt;&gt;&gt;&gt; makes many things less useful than they should be.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In many cases this is true - you don’t need more than value semantics<br>&gt;&gt;&gt;&gt; as you define it.  However it is not at all true that PureValue is<br>&gt;&gt;&gt;&gt; never necessary for the correctness of code.  I’m going to provide an<br>&gt;&gt;&gt;&gt; example to the contrary below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This property allows us to separate values from non-local mutation<br>&gt;&gt;&gt;&gt;&gt;&gt; and make such separation a requirement.  Rather than observing<br>&gt;&gt;&gt;&gt;&gt;&gt; mutations of objects with KVO, etc we might prefer to observe<br>&gt;&gt;&gt;&gt;&gt;&gt; something that provides a new aggregate value instead, while<br>&gt;&gt;&gt;&gt;&gt;&gt; requiring the entire aggregate value itself to be (observably)<br>&gt;&gt;&gt;&gt;&gt;&gt; immutable at all times (because we stored it with a let property<br>&gt;&gt;&gt;&gt;&gt;&gt; locally).  This can make it easier to reason about correct behavior<br>&gt;&gt;&gt;&gt;&gt;&gt; of your code.  But it doesn&#39;t work unless all visible parts of the<br>&gt;&gt;&gt;&gt;&gt;&gt; aggregate are immutable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth<br>&gt;&gt;&gt;&gt;&gt;&gt; taking a look.<br>&gt;&gt;&gt;&gt;&gt; That&#39;s a pretty broad link.  At which parts do you think I should<br>&gt;&gt;&gt;&gt;&gt; look?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The piece that matters here is state management.  The core concept is<br>&gt;&gt;&gt;&gt; to tightly control how mutations happen.  It is modeled in terms of<br>&gt;&gt;&gt;&gt; state type T, an initial value t, an action type A (instances of which<br>&gt;&gt;&gt;&gt; are mutation commands, as in the command pattern), and a reducer<br>&gt;&gt;&gt;&gt; function (T, A) -&gt; T which produces a new state.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s a toy implementation that is somewhat simplistic but captures<br>&gt;&gt;&gt;&gt; the essence of the concept:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Store&lt;State, Action&gt; {<br>&gt;&gt;&gt;&gt;    typealias Reducer = (State, Action) -&gt; State<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    var stateHistory: [State]<br>&gt;&gt;&gt;&gt;    let reducer: Reducer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    init(initialState: State, reducer: Reducer) {<br>&gt;&gt;&gt;&gt;        stateHistory = [initialState]<br>&gt;&gt;&gt;&gt;        self.reducer = reducer<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func applyAction(action: Action) {<br>&gt;&gt;&gt;&gt;        let newState = reducer(stateHistory.last!, action)<br>&gt;&gt;&gt;&gt;        stateHistory.append(newState)<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    var currentState: State {<br>&gt;&gt;&gt;&gt;        return stateHistory.last!<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    var canUndo: Bool {<br>&gt;&gt;&gt;&gt;        return stateHistory.count &gt; 1<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func undo() {<br>&gt;&gt;&gt;&gt;        if canUndo {<br>&gt;&gt;&gt;&gt;            stateHistory.popLast()<br>&gt;&gt;&gt;&gt;        }<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This design relies on State being a PureValue.  The whole idea is that<br>&gt;&gt;&gt;&gt; the only way any path of observation rooted at currentState can change<br>&gt;&gt;&gt;&gt; is when the reducer returns a new state when it is called by<br>&gt;&gt;&gt;&gt; `applyAction`.  That guarantee <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m sorry, I can&#39;t understand what guarantee you&#39;re describing here.<br>&gt;&gt;&gt; Can you describe it in terms of preconditions, postconditions, and<br>&gt;&gt;&gt; invariants?<br>&gt;&gt; <br>&gt;&gt; I don’t think so.  You could state precondition, postconditions, and invariants that would all rely on `==`.  However, if reference semantic types implement `==` as `===` these would not be strong enough to provide the intended guarantee.<br>&gt;&gt; <br>&gt;&gt; The guarantee depends on preventing *other code* from mutating values in `stateHistory`.  If State is Array&lt;TypeWithMutableReferenceSemantics&gt; and some other code has a reference to the objects in the array the *other* code might mutate those objects.  This would violate the semantic guarantee that is intended.  But any preconditions, postconditions, and invariants stated using `==` would still be preserved because those shared mutable references still compare equal.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just looking at the code, it seems to me that the only actual<br>&gt;&gt;&gt; requirement for sane results here is that the result (and effects) of<br>&gt;&gt;&gt; the `reducer` function depends only on the values of its arguments.<br>&gt;&gt;&gt; This is a highly precedented kind of requirement.  For example, you<br>&gt;&gt;&gt; don&#39;t expect sort() to produce meaningful results if the comparison<br>&gt;&gt;&gt; function&#39;s result changes based on something other than the values of<br>&gt;&gt;&gt; the elements being compared.<br>&gt;&gt; <br>&gt;&gt; Yes, the reducer must be pure.  But that is not enough for `Store` to behave as intended.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; cannot be provided by value semantics alone under your definition of<br>&gt;&gt;&gt;&gt; value semantics.  Further, each state in the history is intended to be<br>&gt;&gt;&gt;&gt; a static snapshot of the “currentState” state at a specific point in<br>&gt;&gt;&gt;&gt; time.  All states should be logically independent from each other and<br>&gt;&gt;&gt;&gt; from anything anywhere else in the program.  This cannot be guaranteed<br>&gt;&gt;&gt;&gt; under your definition of value semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is exactly my definition of value semantics (modulo aggregation; a<br>&gt;&gt;&gt; value that is composed of other values obviously is dependent on the<br>&gt;&gt;&gt; values it&#39;s composed of).  But distinct instances of types with value<br>&gt;&gt;&gt; semantics have values that are logically independent.<br>&gt;&gt; <br>&gt;&gt; The modulo aggregation thing is exactly what this whole thread hinges on.  What I am saying is that sometimes it is important that the aggregate as a whole have value semantics.  In other words, if any of it’s salient attributes are references the objects they point to must have value semantics (which requires immutability).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value<br>&gt;&gt;&gt;&gt; semantics under your definition it is clear that we should have no<br>&gt;&gt;&gt;&gt; expectation that the desired properties are preserved.  <br>&gt;&gt;&gt;&gt; The Store class is fundamentally broken if it can be used with State<br>&gt;&gt;&gt;&gt; types that are not pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It depends on the semantic requirements placed on `reducer`.  If you<br>&gt;&gt;&gt; insist that `reducer` should be able to do anything at all, then clearly<br>&gt;&gt;&gt; you need to constrain `State` in ways that make this component less<br>&gt;&gt;&gt; useful than it might otherwise be.  But even then, you can&#39;t allow<br>&gt;&gt;&gt; `reducer` to *whatever* it wants because it could circle back and modify<br>&gt;&gt;&gt; the `Store` instance.<br>&gt;&gt; <br>&gt;&gt; `reducer` is intended to be pure.  I didn’t specify that because Swift doesn’t have syntax for it.  I was just giving valid Swift code and discussing the latent requirements of `State`.<br>&gt;&gt; <br>&gt;&gt; Requiring `reducer` to be pure is not enough if we allow `State` to have salient mutable reference semantics attributes.  The references contained in `initialState` and visible via `currentState` could be captured and mutated by any code working with the store.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure why it didn’t occur to me sooner, but this strategy for<br>&gt;&gt;&gt;&gt; managing app state is very similar in nature to what Sean Parent<br>&gt;&gt;&gt;&gt; discusses in his value semantics talk<br>&gt;&gt;&gt;&gt; (https://www.youtube.com/watch?v=_BpMYeUFXv8 &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt;<br>&gt;&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8 &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt;&gt; and related<br>&gt;&gt;&gt;&gt; https://www.youtube.com/watch?v=bIhUE5uUFOA &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;<br>&gt;&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;&gt;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean discusses using value semantics to model applications state (he<br>&gt;&gt;&gt;&gt; calls it document).  His examples don’t use reified actions and<br>&gt;&gt;&gt;&gt; reducer functions so it is a bit different but it relies on the same<br>&gt;&gt;&gt;&gt; pure value semantics.  The demo he gives in the talk is a toy example<br>&gt;&gt;&gt;&gt; modeled on the design Photoshop uses to implement its history feature.<br>&gt;&gt;&gt;&gt; This design relies on each document in the history being an aggregate<br>&gt;&gt;&gt;&gt; which is a PureValue.  This is not an academic discussion, but on with<br>&gt;&gt;&gt;&gt; real world practical utility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m very familiar with this talk; it was a major inspiration for my<br>&gt;&gt;&gt; presentation at WWDC last year.  I&#39;ll freely admit I get most of my good<br>&gt;&gt;&gt; ideas from Sean ;-)<br>&gt;&gt; <br>&gt;&gt; Great!  I would be pretty surprised if Sean thinks the distinction I am trying to make is unimportant.  His talk indicates that he is very concerned about shared mutable state.  All I am looking for is a constraint that lets me say “the aggregate rooted at type Foo does not contain shared mutable state”.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean says “value semantics is similar to functional programming,<br>&gt;&gt;&gt;&gt; except objects still have addresses and in-situ operations… You&#39;re<br>&gt;&gt;&gt;&gt; trying to maintain the ability to locally reason about your code but<br>&gt;&gt;&gt;&gt; you&#39;re not denying the fact that the machine has memory and you can do<br>&gt;&gt;&gt;&gt; in-situ operations on it”.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Towards the end he quotes from a discussion he had with John Backus<br>&gt;&gt;&gt;&gt; (inventor of FP).  John said: “it always annoyed me that FP and the no<br>&gt;&gt;&gt;&gt; side effect way of programming had become a religion.  With FP I was<br>&gt;&gt;&gt;&gt; trying to come up with a mathematically rigorous way to program and I<br>&gt;&gt;&gt;&gt; understood the complexities of having side effects.  I always knew we<br>&gt;&gt;&gt;&gt; had to deal with side effects, I just wanted a structured way to do<br>&gt;&gt;&gt;&gt; it.”  John agreed that Sean’s approach to value semantics provides<br>&gt;&gt;&gt;&gt; such a structure.  Allowing shared mutable references throws away that<br>&gt;&gt;&gt;&gt; structured approach.  (As an aside, this is the most exciting thing<br>&gt;&gt;&gt;&gt; about value semantics IMO - it provides a structured approach to side<br>&gt;&gt;&gt;&gt; effects, allowing local reasoning about code).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean gives an example of how references break the ability to reason<br>&gt;&gt;&gt;&gt; locally where he has two shared_ptrs that point to the same object:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;If you look at it in terms of just the individual types you kind of<br>&gt;&gt;&gt;&gt; do have value semantics.  When I copy a shared pointer it copies the<br>&gt;&gt;&gt;&gt; pointer with value semantic operations...  The problem is the<br>&gt;&gt;&gt;&gt; references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if<br>&gt;&gt;&gt;&gt; I have the object.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the key phrase; it is about the implied programming model for<br>&gt;&gt;&gt; shared_ptr, which is a cultural phenomenon, not an absolute truth.  <br>&gt;&gt; <br>&gt;&gt; I’m not quite sure I follow you here.  Sean has a slide in the presentation which shows two shared_ptrs to the same object.  He draws a boundary around the whole thing and calls that (both shared_ptrs *and* the object) the value.  His point is that you cannot consider the shared_ptr on its own, or even one of the shared_ptrs and the object that is referenced.  They are intricately inter-related.<br>&gt;&gt; <br>&gt;&gt;&gt; Yes,<br>&gt;&gt;&gt; when people get a reference to a class instance in Swift, they normally<br>&gt;&gt;&gt; don&#39;t even think about what&#39;s stored in the instance as being distinct<br>&gt;&gt;&gt; from the value of the reference, and indeed the language syntax is more<br>&gt;&gt;&gt; hostile to making that distinction than the syntax of C++.  Defining the<br>&gt;&gt;&gt; value of a reference to be the address it points at (unless the instance<br>&gt;&gt;&gt; is immutable) allows everything to fall back into place, logically<br>&gt;&gt;&gt; speaking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whether programmers can learn to understand the world this way is<br>&gt;&gt;&gt; certainly debatable, but it&#39;s pretty clear to me that leaving “the value<br>&gt;&gt;&gt; of a reference” undefined is untenable, and defining it in any way that<br>&gt;&gt;&gt; doesn&#39;t result in a reference having value semantics would make<br>&gt;&gt;&gt; describing algorithm semantics almost impossible.  So what&#39;s the<br>&gt;&gt;&gt; alternative?<br>&gt;&gt; <br>&gt;&gt; I agree that this is the right approach when you are writing algorithms like `rotate`, etc.  The reference is the value you’re concerned with.<br>&gt;&gt; <br>&gt;&gt; I also think it is important to be able to make a distinction between an aggregate that is logically independent from any other data structures in your program and an aggregate which contains shared references to mutable state that is also referenced elsewhere in your program.  In this case you are concerned with the state that is referenced (specifically, whether it the state is mutable and whether you have a reference that is guaranteed to always be unique - like unique_ptr or an owned reference in Rust - or not).<br>&gt;&gt; <br>&gt;&gt; We need to be able to look at the world both ways.  They are both very useful in different contexts.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So really what I have is two objects that intersect.  So really my<br>&gt;&gt;&gt;&gt; object in the program is this whole connected mess.  At any particular<br>&gt;&gt;&gt;&gt; point in code I have difficulty reasoning about the whole thing.  The<br>&gt;&gt;&gt;&gt; shared structure breaks our ability to reason locally about code.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean makes an important distinction between looking at individual<br>&gt;&gt;&gt;&gt; types and looking at the aggregate as a whole.  It is very important<br>&gt;&gt;&gt;&gt; to him that the entire aggregate be logically independent as this<br>&gt;&gt;&gt;&gt; facilitates local reasoning.  This is exactly what I have been calling<br>&gt;&gt;&gt;&gt; a pure value.  Pure value never allows any intersection to be observed<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but: you can only measure an intersection of two values if *you<br>&gt;&gt;&gt; stay within the boundaries of those values*.  <br>&gt;&gt; <br>&gt;&gt; If you consider a shared_ptr to define the boundary of its value then this is not what Sean said.  In Sean’s talk he calls the object that two shared_ptrs reference the “intersection”.  He crosses the reference when measuring intersection.<br>&gt;&gt; <br>&gt;&gt;&gt; A value type can contain a<br>&gt;&gt;&gt; reference to a shared cache as an incidental part, and this reference<br>&gt;&gt;&gt; can even be observable, as long as it is clearly distinguished as *not*<br>&gt;&gt;&gt; being within the boundaries of the value.  One consequence of that is<br>&gt;&gt;&gt; that the results of equality comparison would never depend on the state<br>&gt;&gt;&gt; of the cache.<br>&gt;&gt; <br>&gt;&gt; Agree.  I’m not sure why you would expose the cache, but it is effectively the same as the capacity of an array.  It is incidental and implementation related, not part of the salient semantics of the type.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (immutable intersections are allowed because they cannot be observed,<br>&gt;&gt;&gt;&gt; which Sean alludes to in passing).  Incidentally, it is pretty clear<br>&gt;&gt;&gt;&gt; from the talk that immutable intersection is heavily used in Photoshop<br>&gt;&gt;&gt;&gt; history in order to keep memory use reasonable.  This falls into the<br>&gt;&gt;&gt;&gt; category of persistent data structures.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My impression is that Sean’s definition of &quot;value semantics” excludes<br>&gt;&gt;&gt;&gt; “intersecting objects” (where the intersection is mutable) and is<br>&gt;&gt;&gt;&gt; aligned with John’s “full value semantics” and the notion of “pure<br>&gt;&gt;&gt;&gt; value” we have been discussing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I discussed this with Sean a week ago…<br>&gt;&gt; <br>&gt;&gt; And what was the outcome of that discussion?  I would be very interested in hearing what he had to say. <br>&gt;&gt; <br>&gt;&gt; Let’s consider the Photoshop history example since that ties back to something we know has proven to work very well in practice in a large scale application.  <br>&gt;&gt; <br>&gt;&gt; I’ll approximate based on what I could infer from Sean’s talk.  Among other things, the document aggregate contains bitmap values.  These are structured as a container of pointers to pixel buffers.  The entire document aggregate is a persistent data structure that uses CoW to share as much memory as possible between snapshots.  When a drawing operation is performed, relevant pixel buffers are copied and mutated by the operation and a new document snapshot is added to the history.<br>&gt;&gt; <br>&gt;&gt; It is absolutely essential to this design that the pixel buffer pointers are not shared with code that can write to them.  If this was allowed many snapshots would likely be affected and the history would be corrupted.<br>&gt;&gt; <br>&gt;&gt; The `Store` example above is intended to preserve the same semantics as Photoshop does with its history feature.  This depends on `State` being a pure value.  If `State` is `Array&lt;MutableReferenceSemanticType&gt;` those semantics simply cannot be preserved.  It is admittedly a toy example but I think it serves to demonstrate the point.<br>&gt;&gt; <br>&gt;&gt; You could argue it is unnecessarily limiting to constrain `State` to be a pure value.  I don’t think that’s a fair critique.  In any practical scenario where you would use `State` you actually *want* this constraint and want as much help as possible in ensuring that your program adheres to it.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/f3cbed17/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
