<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>March 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; (starting a new thread by DaveA&#39;s request)<br>&gt; <br>&gt; There&#39;s a definition of equality that makes sense as a default for nearly every type in our system:<br>&gt; <br>&gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined equality,<br>&gt; - Structs and tuples can be considered equal if their corresponding fields are equal,<br>&gt; - Enums can be considered equal if they carry the same, equal payload,<br></p><p>+1 for Equality, Comparable and Hashable especially for enums and tuples. <br></p><p>I know that equality was added for tuples but I think that enums are perfect for adding automatic generation of conformance to Equality, Comparable and Hashable. <br></p><p>Take a look at this toy example of an Enum with 9 cases<br></p><p>boiler plate to conform to Equatable<br>https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L151-L189 &lt;https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L151-L189&gt;<br></p><p>boiler plate to conform to Comparable<br>https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L191-L245 &lt;https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L191-L245&gt;<br></p><p><br>&gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense as universal operations; I&#39;m not so sure about Comparable.<br>&gt; <br>&gt; -Joe<br></p><p>For enums a defaultComparable protocol could just rank on the order the fields are declared:<br>https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L211-L212 &lt;https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L211-L212&gt;<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160311/8c40cf8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7a6e4cc366f8f533b056936cf9bcb85d?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Mark Sands</string> &lt;marksands07 at gmail.com&gt;<p>May 24, 2016 at 10:00:00am</p></header><div class="content"><p>I apologize upfront for necromancing this thread. Is there any momentum on<br>this proposal?<br></p><p>My team was discussing the merits of default (opt-in) Equality. As soon as<br>the equality function has been written then the compiler is satisfied, but<br>there is no way to get compile time correctness for the equality. Unit<br>tests can only go so far with ensuring the equality function is robust.<br>Once a new property is added to a struct, for instance, the equality<br>function is no longer correct and without warning. Currently there is no<br>way to safeguard this situation. This would be a welcome addition to Swift.<br></p><p>Mark<br></p><p>On Fri, Mar 11, 2016 at 11:19 AM, Jose Cheyo Jimenez via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; (starting a new thread by DaveA&#39;s request)<br>&gt; &gt;<br>&gt; &gt; There&#39;s a definition of equality that makes sense as a default for<br>&gt; nearly every type in our system:<br>&gt; &gt;<br>&gt; &gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined<br>&gt; equality,<br>&gt; &gt; - Structs and tuples can be considered equal if their corresponding<br>&gt; fields are equal,<br>&gt; &gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt;<br>&gt; +1 for Equality, Comparable and Hashable especially for enums and tuples.<br>&gt;<br>&gt; I know that equality was added for tuples but I think that enums are<br>&gt; perfect for adding automatic generation of conformance to Equality,<br>&gt; Comparable and Hashable.<br>&gt;<br>&gt; Take a look at this toy example of an Enum with 9 cases<br>&gt;<br>&gt; boiler plate to conform to Equatable<br>&gt;<br>&gt; https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L151-L189<br>&gt;<br>&gt; boiler plate to conform to Comparable<br>&gt;<br>&gt; https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L191-L245<br>&gt;<br>&gt;<br>&gt; &gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense as<br>&gt; universal operations; I&#39;m not so sure about Comparable.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt;<br>&gt; For enums a defaultComparable protocol could just rank on the order the<br>&gt; fields are declared:<br>&gt;<br>&gt; https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L211-L212<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/63397db8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Universal Equatability, Hashability, and Comparability</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>This is something I&#39;ve wanted for a while (ever since basic equality was<br>added to tuples), and I&#39;ve considered writing a proposal but never had the<br>time to jot something down. I&#39;m glad other people have had the same<br>thoughts. I&#39;ve become frustrated at having to write the switch-case-let<br>boilerplate for enums, especially.<br></p><p>I&#39;d like to see the following rules:<br></p><p>For structs:<br>- A struct should implicitly conform* to Equatable if all of its fields<br>conform (either explicitly or implicitly by these rules) to Equatable. The<br>compiler will auto-generate an implementation that is simply the AND of the<br>field-wise comparisons.<br>- A struct should implicitly conform to Hashable if all of its fields<br>conform (exp. or imp.) to Hashable. The compiler will auto-generate an<br>implementation that computes a hash value using a universal hash function<br>(say, Knuth&#39;s) based on the hash values of its fields. (Order matters here,<br>so declaration order?)<br></p><p>For enums:<br>- An enum should implicitly conform to Equatable if all of the types of all<br>associated values across all cases conform to Equatable. The compiler will<br>auto-generate an implementation that switches on the case and if they are<br>the same, compares the associated values.<br>- An enum should implicitly conform to Hashable if all of its fields<br>conform (exp. or imp.) to Hashable. The compiler will auto-generate an<br>implementation that computes a hash value using a universal hash value<br>where the first term is the case&#39;s ordinal (position in declaration order)<br>followed by terms coming from its associated values&#39; hash values.<br></p><p>I&#39;m not 100% sold on Comparable being a good idea to support here; when<br>implementing Comparable over multiple fields, there&#39;s often a specific<br>order that mattersâ€”you encounter a pair of fields that are equal so you<br>move on to the next one. I don&#39;t think we want to tie that to field<br>declaration order or anything like that... it seems to surprising. But it<br>would be nice to get rid of that boilerplate as well.<br></p><p>* When I say &quot;implicitly conform&quot; above, I&#39;m torn about whether that should<br>mean:<br>- the struct or enum doesn&#39;t have to list Equatable/Hashable at all, but it<br>gets it anyway (kind of like how enums that extend a scalar type get<br>RawRepresentable automatically), or<br>- the struct or enum gets implicit implementations of ==/hashValue, but you<br>still have to explicitly declare that it conforms to Equatable/Hashable<br></p><p>On the one hand, getting the conformance implicitly matches how<br>RawRepresentable is already treated, and makes getting the conformance zero<br>effort. On the other hand, it makes error handling trickier: if you add a<br>non-Equatable/non-Hashable field or associated value to a struct/enum, all<br>of your call sites break. (I guess they would even if you declared the<br>conformance, but at least there you&#39;d also get the &quot;Type does not conform<br>to Equatable/Hashable&quot; error at the struct/enum itself, and the compiler<br>could even potentially flag the offending field/associated value that&#39;s<br>causing the conformance to fail.) Thoughts?<br></p><p>If there&#39;s interest, I&#39;d be happy to put this into the actual proposal<br>template.<br></p><p><br>On Tue, May 24, 2016 at 8:46 AM Mark Sands via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I apologize upfront for necromancing this thread. Is there any momentum on<br>&gt; this proposal?<br>&gt;<br>&gt; My team was discussing the merits of default (opt-in) Equality. As soon as<br>&gt; the equality function has been written then the compiler is satisfied, but<br>&gt; there is no way to get compile time correctness for the equality. Unit<br>&gt; tests can only go so far with ensuring the equality function is robust.<br>&gt; Once a new property is added to a struct, for instance, the equality<br>&gt; function is no longer correct and without warning. Currently there is no<br>&gt; way to safeguard this situation. This would be a welcome addition to Swift.<br>&gt;<br>&gt; Mark<br>&gt;<br>&gt; On Fri, Mar 11, 2016 at 11:19 AM, Jose Cheyo Jimenez via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; (starting a new thread by DaveA&#39;s request)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There&#39;s a definition of equality that makes sense as a default for<br>&gt;&gt; nearly every type in our system:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Basic types like IntNN, FloatNN, String, etc. have domain-defined<br>&gt;&gt; equality,<br>&gt;&gt; &gt; - Structs and tuples can be considered equal if their corresponding<br>&gt;&gt; fields are equal,<br>&gt;&gt; &gt; - Enums can be considered equal if they carry the same, equal payload,<br>&gt;&gt;<br>&gt;&gt; +1 for Equality, Comparable and Hashable especially for enums and tuples.<br>&gt;&gt;<br>&gt;&gt; I know that equality was added for tuples but I think that enums are<br>&gt;&gt; perfect for adding automatic generation of conformance to Equality,<br>&gt;&gt; Comparable and Hashable.<br>&gt;&gt;<br>&gt;&gt; Take a look at this toy example of an Enum with 9 cases<br>&gt;&gt;<br>&gt;&gt; boiler plate to conform to Equatable<br>&gt;&gt;<br>&gt;&gt; https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L151-L189<br>&gt;&gt;<br>&gt;&gt; boiler plate to conform to Comparable<br>&gt;&gt;<br>&gt;&gt; https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L191-L245<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; It&#39;s my feeling that Equatable and Hashable would make a lot of sense<br>&gt;&gt; as universal operations; I&#39;m not so sure about Comparable.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt;<br>&gt;&gt; For enums a defaultComparable protocol could just rank on the order the<br>&gt;&gt; fields are declared:<br>&gt;&gt;<br>&gt;&gt; https://github.com/exercism/xswift/blob/master/exercises/poker/PokerExample.swift#L211-L212<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/92a46cab/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
