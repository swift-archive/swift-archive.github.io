<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/84b4aed8b3080333730be6bef799c32e?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Shannon Potter</string> &lt;mspotter at icloud.com&gt;<p>April 27, 2016 at 02:00:00pm</p></header><div class="content"><p>Consider a relatively-common init pattern:<br></p><p>class SomeViewController: UIViewController {<br>    <br>    // MARK: Properties<br></p><p>    private var videoPlayer: AVPlayer<br>    private var videoPlayerLayer: AVPlayerLayer<br></p><p>    // MARK: - Object Lifecycle<br></p><p>    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>        super.init(nibName: nibName, bundle: nibBundle)<br>        <br>        commonInitialization()<br>    }<br></p><p>    required init?(coder decoder: NSCoder) {<br>        super.init(coder: decoder)<br>        <br>        commonInitialization()<br>    }<br></p><p>    private func commonInitialization() {<br>        videoPlayer = AVPlayer(...)<br>        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>    }<br>    <br>}<br></p><p>This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br></p><p>What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br></p><p>func commonInit() {<br></p><p>}<br></p><p>or<br></p><p>@extend_init private func commonInitialization() {<br></p><p>}<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8def0d36f56d3e6720a44e41bf6f9a71?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Basem Emara</string> &lt;contact at basememara.com&gt;<p>April 28, 2016 at 12:00:00pm</p></header><div class="content"><p>I see what you’re saying and the forced optionals is pretty inconvenient.<br></p><p>As far as syntax, how about more of a “deferred” init that gets triggered regardless like this:<br></p><p>defer init() {<br>    // Always gets called no matter what designated init triggers<br>}<br></p><p>&gt; On Apr 27, 2016, at 5:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Consider a relatively-common init pattern:<br>&gt; <br>&gt; class SomeViewController: UIViewController {<br>&gt; <br>&gt;    // MARK: Properties<br>&gt; <br>&gt;    private var videoPlayer: AVPlayer<br>&gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt; <br>&gt;    // MARK: - Object Lifecycle<br>&gt; <br>&gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt; <br>&gt;        commonInitialization()<br>&gt;    }<br>&gt; <br>&gt;    required init?(coder decoder: NSCoder) {<br>&gt;        super.init(coder: decoder)<br>&gt; <br>&gt;        commonInitialization()<br>&gt;    }<br>&gt; <br>&gt;    private func commonInitialization() {<br>&gt;        videoPlayer = AVPlayer(...)<br>&gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt; <br>&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt; <br>&gt; func commonInit() {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt; @extend_init private func commonInitialization() {<br>&gt; <br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>I think I like this idea. It is clear that it is init() and &#39;defer&#39; says <br>that it is called at the end of each init. IMO we need exactly some kind of <br>&#39;init&#39; as only in init we can set un-initialized stored properties.<br></p><p>But, why implicitly unwrapped optionals are not solution here? I.e.<br></p><p>private var videoPlayer: AVPlayer!<br>private var videoPlayerLayer: AVPlayerLayer!<br></p><p><br>On 28.04.2016 19:04, Basem Emara via swift-evolution wrote:<br>&gt; I see what you’re saying and the forced optionals is pretty inconvenient.<br>&gt;<br>&gt; As far as syntax, how about more of a “deferred” init that gets triggered regardless like this:<br>&gt;<br>&gt; defer init() {<br>&gt;     // Always gets called no matter what designated init triggers<br>&gt; }<br>&gt;<br>&gt;&gt; On Apr 27, 2016, at 5:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Consider a relatively-common init pattern:<br>&gt;&gt;<br>&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt;<br>&gt;&gt;    // MARK: Properties<br>&gt;&gt;<br>&gt;&gt;    private var videoPlayer: AVPlayer<br>&gt;&gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt;<br>&gt;&gt;    // MARK: - Object Lifecycle<br>&gt;&gt;<br>&gt;&gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt;<br>&gt;&gt;        commonInitialization()<br>&gt;&gt;    }<br>&gt;&gt;<br>&gt;&gt;    required init?(coder decoder: NSCoder) {<br>&gt;&gt;        super.init(coder: decoder)<br>&gt;&gt;<br>&gt;&gt;        commonInitialization()<br>&gt;&gt;    }<br>&gt;&gt;<br>&gt;&gt;    private func commonInitialization() {<br>&gt;&gt;        videoPlayer = AVPlayer(...)<br>&gt;&gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;&gt;    }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt;&gt;<br>&gt;&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt;&gt;<br>&gt;&gt; func commonInit() {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; or<br>&gt;&gt;<br>&gt;&gt; @extend_init private func commonInitialization() {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8def0d36f56d3e6720a44e41bf6f9a71?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Basem Emara</string> &lt;contact at basememara.com&gt;<p>April 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Good point about unwrapped optionals, but there&#39;s no compiler checks to make sure they get initialized.<br></p><p>The &quot;defer init&quot; solves the same problem that &quot;defer&quot; within functions resolved. There&#39;s no need to duplicate the function call in every init, or forget to call one as new initializers are added. <br></p><p>&gt; On Apr 28, 2016, at 12:50 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think I like this idea. It is clear that it is init() and &#39;defer&#39; says that it is called at the end of each init. IMO we need exactly some kind of &#39;init&#39; as only in init we can set un-initialized stored properties.<br>&gt; <br>&gt; But, why implicitly unwrapped optionals are not solution here? I.e.<br>&gt; <br>&gt; private var videoPlayer: AVPlayer!<br>&gt; private var videoPlayerLayer: AVPlayerLayer!<br>&gt; <br>&gt; <br>&gt;&gt; On 28.04.2016 19:04, Basem Emara via swift-evolution wrote:<br>&gt;&gt; I see what you’re saying and the forced optionals is pretty inconvenient.<br>&gt;&gt; <br>&gt;&gt; As far as syntax, how about more of a “deferred” init that gets triggered regardless like this:<br>&gt;&gt; <br>&gt;&gt; defer init() {<br>&gt;&gt;    // Always gets called no matter what designated init triggers<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 27, 2016, at 5:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider a relatively-common init pattern:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // MARK: Properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   private var videoPlayer: AVPlayer<br>&gt;&gt;&gt;   private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // MARK: - Object Lifecycle<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt;&gt;       super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       commonInitialization()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   required init?(coder decoder: NSCoder) {<br>&gt;&gt;&gt;       super.init(coder: decoder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       commonInitialization()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   private func commonInitialization() {<br>&gt;&gt;&gt;       videoPlayer = AVPlayer(...)<br>&gt;&gt;&gt;       videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func commonInit() {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @extend_init private func commonInitialization() {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 28, 2016 at 08:00:00pm</p></header><div class="content"><p>They *will* be initialized with nil. It&#39;s your business to fill any other <br>value to them. So you do this in commonInitialization()<br>But again, I agree that such &quot;defer init()&quot; will be the best(IMO) solution <br>here.<br></p><p>On 28.04.2016 20:27, Basem Emara wrote:<br>&gt; Good point about unwrapped optionals, but there&#39;s no compiler checks to make sure they get initialized.<br>&gt;<br>&gt; The &quot;defer init&quot; solves the same problem that &quot;defer&quot; within functions resolved. There&#39;s no need to duplicate the function call in every init, or forget to call one as new initializers are added.<br>&gt;<br>&gt;&gt; On Apr 28, 2016, at 12:50 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think I like this idea. It is clear that it is init() and &#39;defer&#39; says that it is called at the end of each init. IMO we need exactly some kind of &#39;init&#39; as only in init we can set un-initialized stored properties.<br>&gt;&gt;<br>&gt;&gt; But, why implicitly unwrapped optionals are not solution here? I.e.<br>&gt;&gt;<br>&gt;&gt; private var videoPlayer: AVPlayer!<br>&gt;&gt; private var videoPlayerLayer: AVPlayerLayer!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 28.04.2016 19:04, Basem Emara via swift-evolution wrote:<br>&gt;&gt;&gt; I see what you’re saying and the forced optionals is pretty inconvenient.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As far as syntax, how about more of a “deferred” init that gets triggered regardless like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; defer init() {<br>&gt;&gt;&gt;    // Always gets called no matter what designated init triggers<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Apr 27, 2016, at 5:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Consider a relatively-common init pattern:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   // MARK: Properties<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   private var videoPlayer: AVPlayer<br>&gt;&gt;&gt;&gt;   private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   // MARK: - Object Lifecycle<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt;&gt;&gt;       super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       commonInitialization()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   required init?(coder decoder: NSCoder) {<br>&gt;&gt;&gt;&gt;       super.init(coder: decoder)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       commonInitialization()<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   private func commonInitialization() {<br>&gt;&gt;&gt;&gt;       videoPlayer = AVPlayer(...)<br>&gt;&gt;&gt;&gt;       videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func commonInit() {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; @extend_init private func commonInitialization() {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 11:50 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think I like this idea. It is clear that it is init() and &#39;defer&#39; says that it is called at the end of each init. IMO we need exactly some kind of &#39;init&#39; as only in init we can set un-initialized stored properties.<br>&gt; <br>&gt; But, why implicitly unwrapped optionals are not solution here? I.e.<br></p><p>To avoid the extra overhead. Also, they’re sorta going away in Swift 3: https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Eh, “going away” might be too strong… They’re changing a lot. There’s still the extra overhead though.<br>&gt; On Apr 28, 2016, at 7:49 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 28, 2016, at 11:50 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think I like this idea. It is clear that it is init() and &#39;defer&#39; says that it is called at the end of each init. IMO we need exactly some kind of &#39;init&#39; as only in init we can set un-initialized stored properties.<br>&gt;&gt; <br>&gt;&gt; But, why implicitly unwrapped optionals are not solution here? I.e.<br>&gt; <br>&gt; To avoid the extra overhead. Also, they’re sorta going away in Swift 3: https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 29, 2016 at 11:00:00am</p></header><div class="content"><p>Can&#39;t see any significant extra overhead because of implicity unwrapped <br>property for your code. Could you clarify?<br></p><p>As for &quot;going away&quot; - as I understand, just ImplicitlyUnwrappedOptional <br>type itself will be removed, but not the &quot;implicitly unwrapped&quot; feature:<br>&quot;Appending ! to the type of a Swift declaration will give it optional type <br>and annotate the declaration with an attribute stating that it may be <br>implicitly unwrapped when used.&quot;<br></p><p>So I still think right now the solution for your issue is implicitly <br>unwrapped optional. But again, I 100% support the idea of &quot;defer init&quot;, <br>more specifically the idea of explicitly called &quot;defer init&quot; in other <br>inits, if &quot;defer init()&quot; is defined.<br></p><p>On 29.04.2016 3:49, David Sweeris wrote:<br>&gt;<br>&gt;&gt; On Apr 28, 2016, at 11:50 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think I like this idea. It is clear that it is init() and &#39;defer&#39; says that it is called at the end of each init. IMO we need exactly some kind of &#39;init&#39; as only in init we can set un-initialized stored properties.<br>&gt;&gt;<br>&gt;&gt; But, why implicitly unwrapped optionals are not solution here? I.e.<br>&gt;<br>&gt; To avoid the extra overhead. Also, they’re sorta going away in Swift 3: https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br>&gt;<br>&gt; - Dave Sweeris.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May  1, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Apr 29, 2016, at 3:00 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Can&#39;t see any significant extra overhead because of implicity unwrapped property for your code. Could you clarify?<br></p><p>It&#39;s probably not significant in UI code, but if you’re writing something that’ll be accessed a 100k or a 1M times in what should be a tight loop, it all adds up.<br></p><p>- Dave Sweeris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 5:49 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 28, 2016, at 11:50 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think I like this idea. It is clear that it is init() and &#39;defer&#39; says that it is called at the end of each init. IMO we need exactly some kind of &#39;init&#39; as only in init we can set un-initialized stored properties.<br>&gt;&gt; <br>&gt;&gt; But, why implicitly unwrapped optionals are not solution here? I.e.<br>&gt; <br>&gt; To avoid the extra overhead. Also, they’re sorta going away in Swift 3: https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md<br></p><p>SE-0054 shouldn’t eliminate use of IUO’s for properties that are “delay initialized”.  The only effect it will have is that it will prevent downstream references to those properties from accidentally propagating the IUO’ness.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>I like the `defer init` idea but suggest you have to explicitly call it at<br>the end of all the other non-convenience `init`s. The advantage of an<br>explicit call are two fold:<br></p><p>  1. It is obvious what is happening<br>  2. You can pass arguments<br></p><p>On Friday, 29 April 2016, Basem Emara via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I see what you’re saying and the forced optionals is pretty inconvenient.<br>&gt;<br>&gt; As far as syntax, how about more of a “deferred” init that gets triggered<br>&gt; regardless like this:<br>&gt;<br>&gt; defer init() {<br>&gt;     // Always gets called no matter what designated init triggers<br>&gt; }<br>&gt;<br>&gt; &gt; On Apr 27, 2016, at 5:52 PM, Shannon Potter via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Consider a relatively-common init pattern:<br>&gt; &gt;<br>&gt; &gt; class SomeViewController: UIViewController {<br>&gt; &gt;<br>&gt; &gt;    // MARK: Properties<br>&gt; &gt;<br>&gt; &gt;    private var videoPlayer: AVPlayer<br>&gt; &gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt; &gt;<br>&gt; &gt;    // MARK: - Object Lifecycle<br>&gt; &gt;<br>&gt; &gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt; &gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt; &gt;<br>&gt; &gt;        commonInitialization()<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    required init?(coder decoder: NSCoder) {<br>&gt; &gt;        super.init(coder: decoder)<br>&gt; &gt;<br>&gt; &gt;        commonInitialization()<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt;    private func commonInitialization() {<br>&gt; &gt;        videoPlayer = AVPlayer(...)<br>&gt; &gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; This does not work. Both properties are non-optional, and the compiler<br>&gt; complains that they are not initialized in either init method. It seems<br>&gt; rather common to want a single point of contact regarding object<br>&gt; initialization, regardless of the path taken to initialize that object.<br>&gt; Ideally, objects could all be funneled to one designated initializer, but<br>&gt; this isn’t always the case.<br>&gt; &gt;<br>&gt; &gt; What are people’s thoughts about either a specialized function that is<br>&gt; always called at the very end of each object’s lifecycle OR some sort of<br>&gt; attribute for a function that hints that the compiler should follow it if<br>&gt; called in an init function to check for property initialization?<br>&gt; &gt;<br>&gt; &gt; func commonInit() {<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; or<br>&gt; &gt;<br>&gt; &gt; @extend_init private func commonInitialization() {<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/af325b50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 29, 2016 at 11:00:00am</p></header><div class="content"><p>On 29.04.2016 2:21, Howard Lovatt via swift-evolution wrote:<br>&gt; I like the `defer init` idea but suggest you have to explicitly call it at<br>&gt; the end of all the other non-convenience `init`s. The advantage of an<br>&gt; explicit call are two fold:<br>&gt;<br>&gt;   1. It is obvious what is happening<br>&gt;   2. You can pass arguments<br></p><p>Like this idea very much. IMO it is important to see that &quot;defer init&quot; will <br>be called at the end when we are looking at the code of init. Otherwise we <br>need to don&#39;t forget that &quot;defer init&quot; could be also defined and are called <br>at the end of this init.<br></p><p>P.S. Sorry for duplicate.<br></p><p>&gt;<br>&gt; On Friday, 29 April 2016, Basem Emara via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     I see what you’re saying and the forced optionals is pretty inconvenient.<br>&gt;<br>&gt;     As far as syntax, how about more of a “deferred” init that gets<br>&gt;     triggered regardless like this:<br>&gt;<br>&gt;     defer init() {<br>&gt;         // Always gets called no matter what designated init triggers<br>&gt;     }<br>&gt;<br>&gt;     &gt; On Apr 27, 2016, at 5:52 PM, Shannon Potter via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; Consider a relatively-common init pattern:<br>&gt;     &gt;<br>&gt;     &gt; class SomeViewController: UIViewController {<br>&gt;     &gt;<br>&gt;     &gt;    // MARK: Properties<br>&gt;     &gt;<br>&gt;     &gt;    private var videoPlayer: AVPlayer<br>&gt;     &gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt;     &gt;<br>&gt;     &gt;    // MARK: - Object Lifecycle<br>&gt;     &gt;<br>&gt;     &gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;     &gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt;     &gt;<br>&gt;     &gt;        commonInitialization()<br>&gt;     &gt;    }<br>&gt;     &gt;<br>&gt;     &gt;    required init?(coder decoder: NSCoder) {<br>&gt;     &gt;        super.init(coder: decoder)<br>&gt;     &gt;<br>&gt;     &gt;        commonInitialization()<br>&gt;     &gt;    }<br>&gt;     &gt;<br>&gt;     &gt;    private func commonInitialization() {<br>&gt;     &gt;        videoPlayer = AVPlayer(...)<br>&gt;     &gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;     &gt;    }<br>&gt;     &gt;<br>&gt;     &gt; }<br>&gt;     &gt;<br>&gt;     &gt; This does not work. Both properties are non-optional, and the<br>&gt;     compiler complains that they are not initialized in either init method.<br>&gt;     It seems rather common to want a single point of contact regarding<br>&gt;     object initialization, regardless of the path taken to initialize that<br>&gt;     object. Ideally, objects could all be funneled to one designated<br>&gt;     initializer, but this isn’t always the case.<br>&gt;     &gt;<br>&gt;     &gt; What are people’s thoughts about either a specialized function that<br>&gt;     is always called at the very end of each object’s lifecycle OR some<br>&gt;     sort of attribute for a function that hints that the compiler should<br>&gt;     follow it if called in an init function to check for property<br>&gt;     initialization?<br>&gt;     &gt;<br>&gt;     &gt; func commonInit() {<br>&gt;     &gt;<br>&gt;     &gt; }<br>&gt;     &gt;<br>&gt;     &gt; or<br>&gt;     &gt;<br>&gt;     &gt; @extend_init private func commonInitialization() {<br>&gt;     &gt;<br>&gt;     &gt; }<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Howard.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 28, 2016 at 12:00:00pm</p></header><div class="content"><p>You may wish to have a look at my proposal for partial initializers.  It went dormant as I think everyone was burned out on talking about initializers at the time.  <br></p><p>https://github.com/anandabits/swift-evolution/blob/partial-initializers/proposals/NNNN-partial-initializers.md<br></p><p>Sent from my iPad<br></p><p>&gt; On Apr 27, 2016, at 4:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Consider a relatively-common init pattern:<br>&gt; <br>&gt; class SomeViewController: UIViewController {<br>&gt; <br>&gt;   // MARK: Properties<br>&gt; <br>&gt;   private var videoPlayer: AVPlayer<br>&gt;   private var videoPlayerLayer: AVPlayerLayer<br>&gt; <br>&gt;   // MARK: - Object Lifecycle<br>&gt; <br>&gt;   override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;       super.init(nibName: nibName, bundle: nibBundle)<br>&gt; <br>&gt;       commonInitialization()<br>&gt;   }<br>&gt; <br>&gt;   required init?(coder decoder: NSCoder) {<br>&gt;       super.init(coder: decoder)<br>&gt; <br>&gt;       commonInitialization()<br>&gt;   }<br>&gt; <br>&gt;   private func commonInitialization() {<br>&gt;       videoPlayer = AVPlayer(...)<br>&gt;       videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;   }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt; <br>&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt; <br>&gt; func commonInit() {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt; @extend_init private func commonInitialization() {<br>&gt; <br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>April 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Why not use the Designated Initializers and Convenience Initializers<br>&lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html&gt;<br> ?<br></p><p>    private var videoPlayer: AVPlayer<br>    private var videoPlayerLayer: AVPlayerLayer<br></p><p>    required override init(){ // &lt;-- commonInitialization()<br>        videoPlayer = AVPlayer()<br>        videoPlayerLayer = AVPlayerLayer()<br>        super.init()<br>    }<br></p><p>    convenience init?(coder decoder: NSCoder) {<br>        self.init();<br>    }<br></p><p>Em qui, 28 de abr de 2016 às 12:36, Shannon Potter via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Consider a relatively-common init pattern:<br>&gt;<br>&gt; class SomeViewController: UIViewController {<br>&gt;<br>&gt;     // MARK: Properties<br>&gt;<br>&gt;     private var videoPlayer: AVPlayer<br>&gt;     private var videoPlayerLayer: AVPlayerLayer<br>&gt;<br>&gt;     // MARK: - Object Lifecycle<br>&gt;<br>&gt;     override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;         super.init(nibName: nibName, bundle: nibBundle)<br>&gt;<br>&gt;         commonInitialization()<br>&gt;     }<br>&gt;<br>&gt;     required init?(coder decoder: NSCoder) {<br>&gt;         super.init(coder: decoder)<br>&gt;<br>&gt;         commonInitialization()<br>&gt;     }<br>&gt;<br>&gt;     private func commonInitialization() {<br>&gt;         videoPlayer = AVPlayer(...)<br>&gt;         videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; This does not work. Both properties are non-optional, and the compiler<br>&gt; complains that they are not initialized in either init method. It seems<br>&gt; rather common to want a single point of contact regarding object<br>&gt; initialization, regardless of the path taken to initialize that object.<br>&gt; Ideally, objects could all be funneled to one designated initializer, but<br>&gt; this isn’t always the case.<br>&gt;<br>&gt; What are people’s thoughts about either a specialized function that is<br>&gt; always called at the very end of each object’s lifecycle OR some sort of<br>&gt; attribute for a function that hints that the compiler should follow it if<br>&gt; called in an init function to check for property initialization?<br>&gt;<br>&gt; func commonInit() {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; or<br>&gt;<br>&gt; @extend_init private func commonInitialization() {<br>&gt;<br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/053a2ac2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>April 30, 2016 at 11:00:00am</p></header><div class="content"><p>Besides the ages old designated initializer pattern that is already suggested (having a few designated initializers and a bunch of convenience initializers), this is how I have been dealing with this since Swift 1.0:<br></p><p>import UIKit<br>import AVFoundation<br></p><p>class SomeViewController: UIViewController {<br>    <br>    private typealias My = SomeViewController<br>    <br>    // MARK: Properties<br>    <br>    private var videoPlayer: AVPlayer<br>    private var videoPlayerLayer: AVPlayerLayer<br>    <br>    // MARK: - Object Lifecycle<br>    <br>    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br></p><p>        <br>        (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br></p><p>        super.init(nibName: nibName, bundle: nibBundle)<br>    }<br>    <br>    required init?(coder decoder: NSCoder) {<br>        <br>        (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br></p><p>        super.init(coder: decoder)<br>    }<br>    <br>    <br>    private static func commonInitialization() -&gt; (AVPlayer, AVPlayerLayer) {<br>        <br>        let player = AVPlayer(URL: NSURL(fileReferenceLiteral: &quot;movie.mov&quot;))<br>        let layer = AVPlayerLayer(player: player)<br>        <br>        return (player,layer)<br>    }<br>}<br></p><p>It is not perfect, but good enough for me.  I usually use this when I have more than one designated initializer and they share a significant amount of code. I usually also have input parameters for this commonInitialization static or class method. I make it a class method when I anticipate subclassing of the class.<br></p><p>Side Note: As you see, I typically define a couple of private type aliases (Usually `I` and/or `My`) to help with readability of code involving static members.<br></p><p>&gt; On Apr 27, 2016, at 2:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Consider a relatively-common init pattern:<br>&gt; <br>&gt; class SomeViewController: UIViewController {<br>&gt; <br>&gt;    // MARK: Properties<br>&gt; <br>&gt;    private var videoPlayer: AVPlayer<br>&gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt; <br>&gt;    // MARK: - Object Lifecycle<br>&gt; <br>&gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt; <br>&gt;        commonInitialization()<br>&gt;    }<br>&gt; <br>&gt;    required init?(coder decoder: NSCoder) {<br>&gt;        super.init(coder: decoder)<br>&gt; <br>&gt;        commonInitialization()<br>&gt;    }<br>&gt; <br>&gt;    private func commonInitialization() {<br>&gt;        videoPlayer = AVPlayer(...)<br>&gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt; <br>&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt; <br>&gt; func commonInit() {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt; @extend_init private func commonInitialization() {<br>&gt; <br>&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/c45b212c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8def0d36f56d3e6720a44e41bf6f9a71?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Basem Emara</string> &lt;contact at basememara.com&gt;<p>April 30, 2016 at 02:00:00pm</p></header><div class="content"><p>Hey Hooman, that’s very elegant. I didn’t think of it like that and will definitely use, thx!<br></p><p>Though wouldn’t “defer init()” take it a step further: 1) reduce redundant boilerplate 2) prevent forgetting/bugs and 3) smaller memory allocation footprint? It also fits well with the existing Swift 2 “defer” keyword used in functions. Here’s what your sample would look like:<br></p><p>import UIKit<br>import AVFoundation<br></p><p>class SomeViewController: UIViewController {<br>    <br>    // MARK: Properties<br>    <br>    private var videoPlayer: AVPlayer<br>    private var videoPlayerLayer: AVPlayerLayer<br>    <br>    // MARK: - Object Lifecycle<br>    <br>    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br></p><p>        super.init(nibName: nibName, bundle: nibBundle)<br>    }<br>    <br>    required init?(coder decoder: NSCoder) {<br>        <br>        super.init(coder: decoder)<br>    }<br>   <br>    defer init() {<br>        videoPlayer = AVPlayer(URL: NSURL(fileReferenceLiteral: &quot;movie.mov&quot;))<br>        videoPlayerLayer = AVPlayerLayer(player: player)<br>    }<br>}<br></p><p>&gt; On Apr 30, 2016, at 2:18 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Besides the ages old designated initializer pattern that is already suggested (having a few designated initializers and a bunch of convenience initializers), this is how I have been dealing with this since Swift 1.0:<br>&gt; <br>&gt; import UIKit<br>&gt; import AVFoundation<br>&gt; <br>&gt; class SomeViewController: UIViewController {<br>&gt;     <br>&gt;     private typealias My = SomeViewController<br>&gt;     <br>&gt;     // MARK: Properties<br>&gt;     <br>&gt;     private var videoPlayer: AVPlayer<br>&gt;     private var videoPlayerLayer: AVPlayerLayer<br>&gt;     <br>&gt;     // MARK: - Object Lifecycle<br>&gt;     <br>&gt;     override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt; <br>&gt;         <br>&gt;         (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br>&gt; <br>&gt;         super.init(nibName: nibName, bundle: nibBundle)<br>&gt;     }<br>&gt;     <br>&gt;     required init?(coder decoder: NSCoder) {<br>&gt;         <br>&gt;         (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br>&gt; <br>&gt;         super.init(coder: decoder)<br>&gt;     }<br>&gt;     <br>&gt;     <br>&gt;     private static func commonInitialization() -&gt; (AVPlayer, AVPlayerLayer) {<br>&gt;         <br>&gt;         let player = AVPlayer(URL: NSURL(fileReferenceLiteral: &quot;movie.mov&quot;))<br>&gt;         let layer = AVPlayerLayer(player: player)<br>&gt;         <br>&gt;         return (player,layer)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; It is not perfect, but good enough for me.  I usually use this when I have more than one designated initializer and they share a significant amount of code. I usually also have input parameters for this commonInitialization static or class method. I make it a class method when I anticipate subclassing of the class.<br>&gt; <br>&gt; Side Note: As you see, I typically define a couple of private type aliases (Usually `I` and/or `My`) to help with readability of code involving static members.<br>&gt; <br>&gt;&gt; On Apr 27, 2016, at 2:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Consider a relatively-common init pattern:<br>&gt;&gt; <br>&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt; <br>&gt;&gt;    // MARK: Properties<br>&gt;&gt; <br>&gt;&gt;    private var videoPlayer: AVPlayer<br>&gt;&gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt; <br>&gt;&gt;    // MARK: - Object Lifecycle<br>&gt;&gt; <br>&gt;&gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt; <br>&gt;&gt;        commonInitialization()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    required init?(coder decoder: NSCoder) {<br>&gt;&gt;        super.init(coder: decoder)<br>&gt;&gt; <br>&gt;&gt;        commonInitialization()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    private func commonInitialization() {<br>&gt;&gt;        videoPlayer = AVPlayer(...)<br>&gt;&gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt;&gt; <br>&gt;&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt;&gt; <br>&gt;&gt; func commonInit() {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; @extend_init private func commonInitialization() {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/8e10f418/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/84b4aed8b3080333730be6bef799c32e?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Shannon Potter</string> &lt;mspotter at icloud.com&gt;<p>April 30, 2016 at 11:00:00am</p></header><div class="content"><p>Agreed. The static option is definitely better. But I think a deferred option would be that much more elegant.<br></p><p>&gt; On Apr 30, 2016, at 11:30 AM, Basem Emara &lt;contact at basememara.com&gt; wrote:<br>&gt; <br>&gt; Hey Hooman, that’s very elegant. I didn’t think of it like that and will definitely use, thx!<br>&gt; <br>&gt; Though wouldn’t “defer init()” take it a step further: 1) reduce redundant boilerplate 2) prevent forgetting/bugs and 3) smaller memory allocation footprint? It also fits well with the existing Swift 2 “defer” keyword used in functions. Here’s what your sample would look like:<br>&gt; <br>&gt; import UIKit<br>&gt; import AVFoundation<br>&gt; <br>&gt; class SomeViewController: UIViewController {<br>&gt;     <br>&gt;     // MARK: Properties<br>&gt;     <br>&gt;     private var videoPlayer: AVPlayer<br>&gt;     private var videoPlayerLayer: AVPlayerLayer<br>&gt;     <br>&gt;     // MARK: - Object Lifecycle<br>&gt;     <br>&gt;     override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt; <br>&gt;         super.init(nibName: nibName, bundle: nibBundle)<br>&gt;     }<br>&gt;     <br>&gt;     required init?(coder decoder: NSCoder) {<br>&gt;         <br>&gt;         super.init(coder: decoder)<br>&gt;     }<br>&gt;    <br>&gt;     defer init() {<br>&gt;         videoPlayer = AVPlayer(URL: NSURL(fileReferenceLiteral: &quot;movie.mov&quot;))<br>&gt;         videoPlayerLayer = AVPlayerLayer(player: player)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt;&gt; On Apr 30, 2016, at 2:18 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Besides the ages old designated initializer pattern that is already suggested (having a few designated initializers and a bunch of convenience initializers), this is how I have been dealing with this since Swift 1.0:<br>&gt;&gt; <br>&gt;&gt; import UIKit<br>&gt;&gt; import AVFoundation<br>&gt;&gt; <br>&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt;     <br>&gt;&gt;     private typealias My = SomeViewController<br>&gt;&gt;     <br>&gt;&gt;     // MARK: Properties<br>&gt;&gt;     <br>&gt;&gt;     private var videoPlayer: AVPlayer<br>&gt;&gt;     private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt;     <br>&gt;&gt;     // MARK: - Object Lifecycle<br>&gt;&gt;     <br>&gt;&gt;     override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt; <br>&gt;&gt;         <br>&gt;&gt;         (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br>&gt;&gt; <br>&gt;&gt;         super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     required init?(coder decoder: NSCoder) {<br>&gt;&gt;         <br>&gt;&gt;         (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br>&gt;&gt; <br>&gt;&gt;         super.init(coder: decoder)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     <br>&gt;&gt;     private static func commonInitialization() -&gt; (AVPlayer, AVPlayerLayer) {<br>&gt;&gt;         <br>&gt;&gt;         let player = AVPlayer(URL: NSURL(fileReferenceLiteral: &quot;movie.mov&quot;))<br>&gt;&gt;         let layer = AVPlayerLayer(player: player)<br>&gt;&gt;         <br>&gt;&gt;         return (player,layer)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It is not perfect, but good enough for me.  I usually use this when I have more than one designated initializer and they share a significant amount of code. I usually also have input parameters for this commonInitialization static or class method. I make it a class method when I anticipate subclassing of the class.<br>&gt;&gt; <br>&gt;&gt; Side Note: As you see, I typically define a couple of private type aliases (Usually `I` and/or `My`) to help with readability of code involving static members.<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 27, 2016, at 2:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider a relatively-common init pattern:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // MARK: Properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    private var videoPlayer: AVPlayer<br>&gt;&gt;&gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // MARK: - Object Lifecycle<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt;&gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        commonInitialization()<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    required init?(coder decoder: NSCoder) {<br>&gt;&gt;&gt;        super.init(coder: decoder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        commonInitialization()<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    private func commonInitialization() {<br>&gt;&gt;&gt;        videoPlayer = AVPlayer(...)<br>&gt;&gt;&gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func commonInit() {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @extend_init private func commonInitialization() {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/6b837115/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>April 30, 2016 at 11:00:00am</p></header><div class="content"><p>&#39;defer&#39; in this example means something different than &#39;defer&#39; as used in Swift today. I would expect a &#39;defer init()&#39; to be called immediately before the main initializer goes out of scope, like how a defer block works today, but this defer init() must be called when the main initializer first comes into scope (before the super call).<br></p><p>I don&#39;t think there&#39;s a clarity gain here. If I retroactively add an initializer to a class I don&#39;t have access to via an extension, how do I know whether or not a defer initializer I can&#39;t see is being called, or what it&#39;s doing? What if I want common initializer code after the super.init call? For symmetry, do we need &#39;predefer&#39; and &#39;postdefer&#39;? How do defer init()s interact with access control - can I silently break my initializer just by changing its access control level?<br></p><p>A static function that initializers can call, however, has the notable benefit of behaving the exact same way as a static function anywhere else in code while still respecting the complex init member usage rules.<br></p><p>Austin<br></p><p>&gt; On Apr 30, 2016, at 11:30 AM, Basem Emara via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey Hooman, that’s very elegant. I didn’t think of it like that and will definitely use, thx!<br>&gt; <br>&gt; Though wouldn’t “defer init()” take it a step further: 1) reduce redundant boilerplate 2) prevent forgetting/bugs and 3) smaller memory allocation footprint? It also fits well with the existing Swift 2 “defer” keyword used in functions. Here’s what your sample would look like:<br>&gt; <br>&gt; import UIKit<br>&gt; import AVFoundation<br>&gt; <br>&gt; class SomeViewController: UIViewController {<br>&gt;     <br>&gt;     // MARK: Properties<br>&gt;     <br>&gt;     private var videoPlayer: AVPlayer<br>&gt;     private var videoPlayerLayer: AVPlayerLayer<br>&gt;     <br>&gt;     // MARK: - Object Lifecycle<br>&gt;     <br>&gt;     override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt; <br>&gt;         super.init(nibName: nibName, bundle: nibBundle)<br>&gt;     }<br>&gt;     <br>&gt;     required init?(coder decoder: NSCoder) {<br>&gt;         <br>&gt;         super.init(coder: decoder)<br>&gt;     }<br>&gt;    <br>&gt;     defer init() {<br>&gt;         videoPlayer = AVPlayer(URL: NSURL(fileReferenceLiteral: &quot;movie.mov&quot;))<br>&gt;         videoPlayerLayer = AVPlayerLayer(player: player)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt;&gt; On Apr 30, 2016, at 2:18 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Besides the ages old designated initializer pattern that is already suggested (having a few designated initializers and a bunch of convenience initializers), this is how I have been dealing with this since Swift 1.0:<br>&gt;&gt; <br>&gt;&gt; import UIKit<br>&gt;&gt; import AVFoundation<br>&gt;&gt; <br>&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt;     <br>&gt;&gt;     private typealias My = SomeViewController<br>&gt;&gt;     <br>&gt;&gt;     // MARK: Properties<br>&gt;&gt;     <br>&gt;&gt;     private var videoPlayer: AVPlayer<br>&gt;&gt;     private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt;     <br>&gt;&gt;     // MARK: - Object Lifecycle<br>&gt;&gt;     <br>&gt;&gt;     override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt; <br>&gt;&gt;         <br>&gt;&gt;         (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br>&gt;&gt; <br>&gt;&gt;         super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     required init?(coder decoder: NSCoder) {<br>&gt;&gt;         <br>&gt;&gt;         (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br>&gt;&gt; <br>&gt;&gt;         super.init(coder: decoder)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     <br>&gt;&gt;     private static func commonInitialization() -&gt; (AVPlayer, AVPlayerLayer) {<br>&gt;&gt;         <br>&gt;&gt;         let player = AVPlayer(URL: NSURL(fileReferenceLiteral: &quot;movie.mov&quot;))<br>&gt;&gt;         let layer = AVPlayerLayer(player: player)<br>&gt;&gt;         <br>&gt;&gt;         return (player,layer)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It is not perfect, but good enough for me.  I usually use this when I have more than one designated initializer and they share a significant amount of code. I usually also have input parameters for this commonInitialization static or class method. I make it a class method when I anticipate subclassing of the class.<br>&gt;&gt; <br>&gt;&gt; Side Note: As you see, I typically define a couple of private type aliases (Usually `I` and/or `My`) to help with readability of code involving static members.<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 27, 2016, at 2:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider a relatively-common init pattern:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // MARK: Properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    private var videoPlayer: AVPlayer<br>&gt;&gt;&gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // MARK: - Object Lifecycle<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt;&gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        commonInitialization()<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    required init?(coder decoder: NSCoder) {<br>&gt;&gt;&gt;        super.init(coder: decoder)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        commonInitialization()<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    private func commonInitialization() {<br>&gt;&gt;&gt;        videoPlayer = AVPlayer(...)<br>&gt;&gt;&gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func commonInit() {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @extend_init private func commonInitialization() {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/fa1e4b59/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Extending init checks for property initialization</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 30, 2016 at 09:00:00pm</p></header><div class="content"><p>This is probably the best pattern to deal with this, since there are a number of ugly problems to deal with if passing an incomplete object around. initializers exist with a lot of special case rules around self because they are reusing the term for something that is actually not yet self, but an incubating object.<br></p><p>There are challenges just in passing this incubating self into another function or static method, or (even worse) calling a method on that incomplete object which might be dynamically dispatched. For example, you may require synthesizing something self-like to pass around instead, and have to create new versions of the functions that can operate with the structure and honor rules about the behavior if say a read against an uninitialized videoPlayerLayer happens. Even solving the problems of making this work, you would need to deterministically know the values were set (including in the case where the method you called was actually redefined by a subclass in another module), and apply them back into the incubating self object.<br></p><p>tl;dr initializers are complex and the language has restrictions and requirements around initializers to hide complexity and enforce safety.<br></p><p>-DW<br></p><p><br>&gt; On Apr 30, 2016, at 12:18 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Besides the ages old designated initializer pattern that is already suggested (having a few designated initializers and a bunch of convenience initializers), this is how I have been dealing with this since Swift 1.0:<br>&gt; <br>&gt; import UIKit<br>&gt; import AVFoundation<br>&gt; <br>&gt; class SomeViewController: UIViewController {<br>&gt;     <br>&gt;     private typealias My = SomeViewController<br>&gt;     <br>&gt;     // MARK: Properties<br>&gt;     <br>&gt;     private var videoPlayer: AVPlayer<br>&gt;     private var videoPlayerLayer: AVPlayerLayer<br>&gt;     <br>&gt;     // MARK: - Object Lifecycle<br>&gt;     <br>&gt;     override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt; <br>&gt;         <br>&gt;         (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br>&gt; <br>&gt;         super.init(nibName: nibName, bundle: nibBundle)<br>&gt;     }<br>&gt;     <br>&gt;     required init?(coder decoder: NSCoder) {<br>&gt;         <br>&gt;         (videoPlayer, videoPlayerLayer) = My.commonInitialization()<br>&gt; <br>&gt;         super.init(coder: decoder)<br>&gt;     }<br>&gt;     <br>&gt;     <br>&gt;     private static func commonInitialization() -&gt; (AVPlayer, AVPlayerLayer) {<br>&gt;         <br>&gt;         let player = AVPlayer(URL: NSURL(fileReferenceLiteral: &quot;movie.mov&quot;))<br>&gt;         let layer = AVPlayerLayer(player: player)<br>&gt;         <br>&gt;         return (player,layer)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; It is not perfect, but good enough for me.  I usually use this when I have more than one designated initializer and they share a significant amount of code. I usually also have input parameters for this commonInitialization static or class method. I make it a class method when I anticipate subclassing of the class.<br>&gt; <br>&gt; Side Note: As you see, I typically define a couple of private type aliases (Usually `I` and/or `My`) to help with readability of code involving static members.<br>&gt; <br>&gt;&gt; On Apr 27, 2016, at 2:52 PM, Shannon Potter via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Consider a relatively-common init pattern:<br>&gt;&gt; <br>&gt;&gt; class SomeViewController: UIViewController {<br>&gt;&gt; <br>&gt;&gt;    // MARK: Properties<br>&gt;&gt; <br>&gt;&gt;    private var videoPlayer: AVPlayer<br>&gt;&gt;    private var videoPlayerLayer: AVPlayerLayer<br>&gt;&gt; <br>&gt;&gt;    // MARK: - Object Lifecycle<br>&gt;&gt; <br>&gt;&gt;    override init(nibName: String?, bundle nibBundle: NSBundle?) {<br>&gt;&gt;        super.init(nibName: nibName, bundle: nibBundle)<br>&gt;&gt; <br>&gt;&gt;        commonInitialization()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    required init?(coder decoder: NSCoder) {<br>&gt;&gt;        super.init(coder: decoder)<br>&gt;&gt; <br>&gt;&gt;        commonInitialization()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    private func commonInitialization() {<br>&gt;&gt;        videoPlayer = AVPlayer(...)<br>&gt;&gt;        videoPlayerLayer = AVPlayerLayer(player: videoPlayer)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This does not work. Both properties are non-optional, and the compiler complains that they are not initialized in either init method. It seems rather common to want a single point of contact regarding object initialization, regardless of the path taken to initialize that object. Ideally, objects could all be funneled to one designated initializer, but this isn’t always the case.<br>&gt;&gt; <br>&gt;&gt; What are people’s thoughts about either a specialized function that is always called at the very end of each object’s lifecycle OR some sort of attribute for a function that hints that the compiler should follow it if called in an init function to check for property initialization?<br>&gt;&gt; <br>&gt;&gt; func commonInit() {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; @extend_init private func commonInitialization() {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/69c7effe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
