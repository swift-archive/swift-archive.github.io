<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54f387ccfb4a55e7bfe3d8c80cb25afe?s=50"></div><header><strong>Adding an operator to return the &quot;lowest common type&quot; of two types?</strong> from <string>William Shipley</string> &lt;wjs at mac.com&gt;<p>December  7, 2015 at 01:00:00am</p></header><div class="content"><p>The problem I’m trying to solve is if I have<br></p><p>class LineSegmentObject {<br>...<br>}<br>class Wall : LineSegmentObject {<br>...<br>}<br>class Ray : LineSegmentObject {<br>…<br>}<br></p><p>And then in my code if I have<br></p><p>        let wallsInBounds: Set&lt;Wall&gt; = …<br>        let raysOffWalls: Set&lt;Ray&gt; = ...<br></p><p>        let unionOfAllTestedLineSegmentObjects = wallsInBounds.union(raysOffWalls)<br></p><p>it fails to compile. Instead I have to do the very ugly<br></p><p>        var unionOfAllTestedLineSegmentObjects: Set&lt;LineSegmentObject&gt; = (raysOffWalls as Set&lt;LineSegmentObject&gt;).union(wallsInBounds as Set&lt;LineSegmentObject&gt;)<br></p><p>As an aside, this also fails, surprisingly to me:<br></p><p>        var unionOfAllTestedLineSegmentObjects = Set&lt;LineSegmentObject&gt;()<br>        unionOfAllTestedLineSegmentObjects.unionInPlace(wallsInBounds)<br></p><p>—<br></p><p>So, what if we had an operator called, say, “commonType” that could take two types and return the closest type the both have in common?<br></p><p>Then the union operator for Set (and similar operators in Array and Dictionary) could look something like:<br></p><p>    public func union&lt;S : SequenceType&gt;(sequence: S) -&gt; Set&lt;commonType(Element, S.Generator.Element)&gt;<br></p><p>instead of:<br></p><p>    public func union&lt;S : SequenceType where S.Generator.Element == Element&gt;(sequence: S) -&gt; Set&lt;Element&gt;<br></p><p>[sorry if I got the syntax of defining a generic wrong up there, I’m still new to this)<br></p><p>So we’d automatically get an Set of LineSegments if we union a Set of Rays with a Set of Walls, which is what I’d expect.<br></p><p>—<br></p><p>If this type of thing doesn’t seem strict enough for you, then it could also just be a separate function, like “heterogenousUnion()” instead of “union()”.<br></p><p>Also, I believe this could make it a LOT easier to build heterogenous Dictionaries in code, which I actually can’t do at all in the current Swift. (Eg, creating dictionaries with arbitrary types of keys and values that you might feed to, say, SCNTechnique.) And it’d make dealing with mixed Arrays easier in a similar way.<br></p><p>--<br></p><p>On a scale from “Lattner&quot; to “Lohan,” how bad an idea is this?<br></p><p>-Wil<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/27ced39f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/661c58274e3f437234236553e2dc156f?s=50"></div><header><strong>Adding an operator to return the &quot;lowest common type&quot; of two types?</strong> from <string>Martin Kühl</string> &lt;martin.kuehl at gmail.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>On 7 December 2015 at 10:53, William Shipley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The problem I’m trying to solve is if I have<br>&gt;<br>&gt; class LineSegmentObject {<br>&gt; ...<br>&gt; }<br>&gt; class Wall : LineSegmentObject {<br>&gt; ...<br>&gt; }<br>&gt; class Ray : LineSegmentObject {<br>&gt; …<br>&gt; }<br>&gt;<br>&gt; And then in my code if I have<br>&gt;<br>&gt;         let wallsInBounds: Set&lt;Wall&gt; = …<br>&gt;         let raysOffWalls: Set&lt;Ray&gt; = ...<br>&gt;<br>&gt;         let unionOfAllTestedLineSegmentObjects =<br>&gt; wallsInBounds.union(raysOffWalls)<br>&gt;<br>&gt;<br>&gt; it fails to compile. Instead I have to do the very ugly<br>&gt;<br>&gt;         var unionOfAllTestedLineSegmentObjects: Set&lt;LineSegmentObject&gt; =<br>&gt; (raysOffWalls as Set&lt;LineSegmentObject&gt;).union(wallsInBounds as Set&lt;<br>&gt; LineSegmentObject&gt;)<br>&gt;<br>&gt; As an aside, this also fails, surprisingly to me:<br>&gt;<br>&gt;         var unionOfAllTestedLineSegmentObjects = Set&lt;LineSegmentObject&gt;()<br>&gt;         unionOfAllTestedLineSegmentObjects.unionInPlace(wallsInBounds)<br>&gt;<br>&gt; —<br>&gt;<br>&gt; So, what if we had an operator called, say, “commonType” that could take<br>&gt; two types and return the closest type the both have in common?<br>&gt;<br>&gt; Then the union operator for Set (and similar operators in Array and<br>&gt; Dictionary) could look something like:<br>&gt;<br>&gt;     public func union&lt;S : SequenceType&gt;(sequence: S) -&gt; Set&lt;commonType(Element,<br>&gt; S.Generator.Element)&gt;<br>&gt;<br>&gt; instead of:<br>&gt;<br>&gt;     public func union&lt;S : SequenceType where S.Generator.Element ==<br>&gt; Element&gt;(sequence: S) -&gt; Set&lt;Element&gt;<br>&gt;<br>&gt; [sorry if I got the syntax of defining a generic wrong up there, I’m still<br>&gt; new to this)<br>&gt;<br>&gt; So we’d automatically get an Set of LineSegments if we union a Set of Rays<br>&gt; with a Set of Walls, which is what I’d expect.<br>&gt;<br></p><p>I think I like the idea, but I don’t think we should need a dedicated<br>operator for this.<br>How do you feel about a declaration like this:<br></p><p>    func union&lt;S: SequenceType, E where Element: E, S.Generator.Element:<br>E&gt;(sequence: S) -&gt; Set&lt;E&gt;<br></p><p>Martin<br></p><p>—<br>&gt; If this type of thing doesn’t seem strict enough for you, then it could<br>&gt; also just be a separate function, like “heterogenousUnion()” instead of<br>&gt; “union()”.<br>&gt;<br>&gt; Also, I believe this could make it a LOT easier to build heterogenous<br>&gt; Dictionaries in code, which I actually can’t do at all in the current<br>&gt; Swift. (Eg, creating dictionaries with arbitrary types of keys and values<br>&gt; that you might feed to, say, SCNTechnique.) And it’d make dealing with<br>&gt; mixed Arrays easier in a similar way.<br>&gt;<br>&gt; --<br>&gt;<br>&gt; On a scale from “Lattner&quot; to “Lohan,” how bad an idea is this?<br>&gt;<br>&gt; -Wil<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/d34eac5e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Adding an operator to return the &quot;lowest common type&quot; of two types?</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>December  7, 2015 at 04:00:00am</p></header><div class="content"><p>I like it.<br></p><p>This was actually one of the first problems I ran into when I first tried swift.<br></p><p>I would really like to see syntax like ‘TypeA | TypeB’ meaning the type could be either ‘TypeA&#39; or ‘TypeB’.  You should be able to call any functions/methods which are common to both types without having to cast.<br></p><p>As you say, the result of union (or similar collection building methods) should be the intersection of the types together in the collection (and I believe the above idea would give the type system a concrete way to reason about that).  So in your case unionOfAllTestedLineSegmentObjects would have type Set&lt;Wall | Ray&gt;.  ‘Wall | Ray’ would essentially be the same as LineSegmentObject, but might also have extra methods available (e.g. say they both ended up conforming to a protocol which LineSegmentObject doesn’t).<br></p><p>	public func union&lt;S : SequenceType&gt;(sequence: S) -&gt; Set&lt;Element | S.Generator.Element&gt;<br></p><p>I could also explicitly build an array of type [String | Int] where in some cases I care about which one it is (and thus cast with is or as? to find out), and in other cases I don’t, and just call something they have in common (e.g. comparable)<br></p><p>The biggest win would be for things like JSON, where there are an exact number of very different types allowed.  Currently we have to use ‘Any’ to represent that mix of types, but with the above idea, we could represent that requirement exactly.<br></p><p>It allows us to have much more fluidity (something closer to duck-typing) while still keeping full type safety.<br></p><p>I do realize that is a large ask though, since it involves the type system...<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; On Dec 7, 2015, at 1:53 AM, William Shipley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The problem I’m trying to solve is if I have<br>&gt; <br>&gt; class LineSegmentObject {<br>&gt; ...<br>&gt; }<br>&gt; class Wall : LineSegmentObject {<br>&gt; ...<br>&gt; }<br>&gt; class Ray : LineSegmentObject {<br>&gt; …<br>&gt; }<br>&gt; <br>&gt; And then in my code if I have<br>&gt; <br>&gt;         let wallsInBounds: Set&lt;Wall&gt; = …<br>&gt;         let raysOffWalls: Set&lt;Ray&gt; = ...<br>&gt; <br>&gt;         let unionOfAllTestedLineSegmentObjects = wallsInBounds.union(raysOffWalls)<br>&gt; <br>&gt; it fails to compile. Instead I have to do the very ugly<br>&gt; <br>&gt;         var unionOfAllTestedLineSegmentObjects: Set&lt;LineSegmentObject&gt; = (raysOffWalls as Set&lt;LineSegmentObject&gt;).union(wallsInBounds as Set&lt;LineSegmentObject&gt;)<br>&gt; <br>&gt; As an aside, this also fails, surprisingly to me:<br>&gt; <br>&gt;         var unionOfAllTestedLineSegmentObjects = Set&lt;LineSegmentObject&gt;()<br>&gt;         unionOfAllTestedLineSegmentObjects.unionInPlace(wallsInBounds)<br>&gt; <br>&gt; —<br>&gt; <br>&gt; So, what if we had an operator called, say, “commonType” that could take two types and return the closest type the both have in common?<br>&gt; <br>&gt; Then the union operator for Set (and similar operators in Array and Dictionary) could look something like:<br>&gt; <br>&gt;     public func union&lt;S : SequenceType&gt;(sequence: S) -&gt; Set&lt;commonType(Element, S.Generator.Element)&gt;<br>&gt; <br>&gt; instead of:<br>&gt; <br>&gt;     public func union&lt;S : SequenceType where S.Generator.Element == Element&gt;(sequence: S) -&gt; Set&lt;Element&gt;<br>&gt; <br>&gt; [sorry if I got the syntax of defining a generic wrong up there, I’m still new to this)<br>&gt; <br>&gt; So we’d automatically get an Set of LineSegments if we union a Set of Rays with a Set of Walls, which is what I’d expect.<br>&gt; <br>&gt; —<br>&gt; <br>&gt; If this type of thing doesn’t seem strict enough for you, then it could also just be a separate function, like “heterogenousUnion()” instead of “union()”.<br>&gt; <br>&gt; Also, I believe this could make it a LOT easier to build heterogenous Dictionaries in code, which I actually can’t do at all in the current Swift. (Eg, creating dictionaries with arbitrary types of keys and values that you might feed to, say, SCNTechnique.) And it’d make dealing with mixed Arrays easier in a similar way.<br>&gt; <br>&gt; --<br>&gt; <br>&gt; On a scale from “Lattner&quot; to “Lohan,” how bad an idea is this?<br>&gt; <br>&gt; -Wil<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/5217a2da/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>Adding an operator to return the &quot;lowest common type&quot; of two types?</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>Seems like you want union types (like I do!). Ceylon has great support for union and intersection types and they really shine there!<br></p><p>See http://ceylon-lang.org/documentation/1.2/tour/types/<br>and the Talk by Gavin King http://ceylon-lang.org/community/presentations/eight-ceylon-idioms.pdf<br></p><p>I&#39;d love to see support for this in Swift. <br></p><p>-Thorsten<br></p><p>&gt; Am 07.12.2015 um 10:53 schrieb William Shipley via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The problem I’m trying to solve is if I have<br>&gt; <br>&gt; class LineSegmentObject {<br>&gt; ...<br>&gt; }<br>&gt; class Wall : LineSegmentObject {<br>&gt; ...<br>&gt; }<br>&gt; class Ray : LineSegmentObject {<br>&gt; …<br>&gt; }<br>&gt; <br>&gt; And then in my code if I have<br>&gt; <br>&gt;         let wallsInBounds: Set&lt;Wall&gt; = …<br>&gt;         let raysOffWalls: Set&lt;Ray&gt; = ...<br>&gt; <br>&gt;         let unionOfAllTestedLineSegmentObjects = wallsInBounds.union(raysOffWalls)<br>&gt; <br>&gt; it fails to compile. Instead I have to do the very ugly<br>&gt; <br>&gt;         var unionOfAllTestedLineSegmentObjects: Set&lt;LineSegmentObject&gt; = (raysOffWalls as Set&lt;LineSegmentObject&gt;).union(wallsInBounds as Set&lt;LineSegmentObject&gt;)<br>&gt; <br>&gt; As an aside, this also fails, surprisingly to me:<br>&gt; <br>&gt;         var unionOfAllTestedLineSegmentObjects = Set&lt;LineSegmentObject&gt;()<br>&gt;         unionOfAllTestedLineSegmentObjects.unionInPlace(wallsInBounds)<br>&gt; <br>&gt; —<br>&gt; <br>&gt; So, what if we had an operator called, say, “commonType” that could take two types and return the closest type the both have in common?<br>&gt; <br>&gt; Then the union operator for Set (and similar operators in Array and Dictionary) could look something like:<br>&gt; <br>&gt;     public func union&lt;S : SequenceType&gt;(sequence: S) -&gt; Set&lt;commonType(Element, S.Generator.Element)&gt;<br>&gt; <br>&gt; instead of:<br>&gt; <br>&gt;     public func union&lt;S : SequenceType where S.Generator.Element == Element&gt;(sequence: S) -&gt; Set&lt;Element&gt;<br>&gt; <br>&gt; [sorry if I got the syntax of defining a generic wrong up there, I’m still new to this)<br>&gt; <br>&gt; So we’d automatically get an Set of LineSegments if we union a Set of Rays with a Set of Walls, which is what I’d expect.<br>&gt; <br>&gt; —<br>&gt; <br>&gt; If this type of thing doesn’t seem strict enough for you, then it could also just be a separate function, like “heterogenousUnion()” instead of “union()”.<br>&gt; <br>&gt; Also, I believe this could make it a LOT easier to build heterogenous Dictionaries in code, which I actually can’t do at all in the current Swift. (Eg, creating dictionaries with arbitrary types of keys and values that you might feed to, say, SCNTechnique.) And it’d make dealing with mixed Arrays easier in a similar way.<br>&gt; <br>&gt; --<br>&gt; <br>&gt; On a scale from “Lattner&quot; to “Lohan,” how bad an idea is this?<br>&gt; <br>&gt; -Wil<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/47d20db6/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
