<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi swift-evolution,<br></p><p>For those who are interested I&#39;d like to present a pre-pre-proposal for<br>reflection upon a type&#39;s properties and solicit feedback.<br></p><p>First of all, some caveats: this is only a very small piece of what<br>reflection in Swift might look like one day, and it&#39;s certainly not the<br>only possible design for such a feature. Reflection comes in many different<br>forms, and &quot;no reflection&quot; is also an option. Deciding what sort of<br>reflection capabilities Swift should support is a prerequisite to<br>stabilizing the runtime API, which I imagine has resilience consequences.<br>I&#39;m not really interested in *defending* this specific proposal per se, as<br>I am looking for a jumping-off point to explore designs in this space.<br></p><p>Anyways, here is a gist outlining the public API to the feature:<br></p><p>https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br></p><p>A couple of notes regarding the proposal:<br></p><p>The API names need improvement. Suggestions welcome.<br></p><p>It&#39;s opt-in: types have to conform to a special protocol for the compiler<br>to generate whatever hooks, metadata, and support code is necessary. Once a<br>type conforms, the interface to the reflection features naturally present<br>themselves as protocol methods. It would be great to allow an extension to<br>retroactively enable reflection on a type vended by another module,<br>although I have no idea how feasible that is.<br></p><p>It uses &quot;views&quot;: there are four types of views, two of each in the<br>following categories: typed vs untyped, get-only versus get-set. A view is<br>a struct representing a property on an instance of a type (or maybe a<br>metatype, for type properties). It allows you to get information about that<br>property (like its name) and try getting and setting its values.<br></p><p>(You can get a get-only view to a property, and then try and upgrade it<br>later to a get-set view, if the underlying property is get-set. If you<br>don&#39;t care about setting, though, you can just work exclusively with<br>get-only views.)<br></p><p>It supports both typed and untyped access. You can ask for a property view<br>specifically for (e.g.) a `String` property, and if you get one you can be<br>assured that your getting and setting operations will be type safe. You can<br>also ask for an &quot;untyped&quot; property view that exposes the value as an Any,<br>and allows you to try (and possibly fail, with a thrown error) to set the<br>value.<br></p><p>The requirements part of it is composable. For example, you can imagine a<br>future &quot;FullyReflectable&quot; protocol that simply inherits from<br>&quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable<br>protocols. Or maybe a library requires reflection access to types that it<br>needs to work with, and it can create its own protocols that inherit from<br>&quot;PropertyReflectable&quot; and naturally enforce reflection support on the<br>necessary types.<br></p><p>It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t<br>necessarily see all the types, though, and the interface is pretty<br>straightforward:<br></p><p>```<br>myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br></p><p>try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>```<br></p><p>I&#39;m not yet sure how it should interact with access control (my inclination<br>is that it would only expose the properties you&#39;d be able to directly<br>access), or property behaviors (I think get-set behavior is fundamental to<br>properties, although &quot;behavior metadata&quot; on the views might be useful).<br></p><p>I&#39;d also have to figure out how it would operate with generic types or<br>existentials.<br></p><p>Anyways, thanks for reading all the way to the end, and any feedback,<br>criticism, or alternative proposals would be greatly appreciated.<br></p><p>Best,<br>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/60f51ebe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 26, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 26, 2016, at 8:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift-evolution,<br>&gt; <br>&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt; <br>&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt; <br>&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt; <br>&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt; <br>&gt; A couple of notes regarding the proposal:<br>&gt; <br>&gt; The API names need improvement. Suggestions welcome.<br></p><p>These names are a good place to start but I agree that it would be nice to improve them.  I will give it some thought.  One comment for now - you use both `get` / `set` and `read` / `write`.  It’s probably better to pick one.<br></p><p>&gt; <br>&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br></p><p>What do you think of using the `deriving` syntax for this (assuming we go in that direction for Equatable, Hashable, and other synthesized conformances).<br></p><p>&gt; <br>&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br></p><p>How did you arrive at `get` and `set` methods?<br></p><p>I am wondering how this might relate to lenses.  If we’re going to introduce those it feels like the property value should be introduced as a lens.  I’m unsure of exactly what that would look like but I it is definitely worth thinking about.<br></p><p>Another option if we don’t go with a lens is a simple property (`var value { get }` and `var value { get set }`).  IIRC we are going to have throwing computed properties eventually so you could still throw from the setter.<br></p><p>&gt; <br>&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt; <br>&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt; <br>&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt; <br>&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt; <br>&gt; ```<br>&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt; <br>&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt; ```<br>&gt; <br>&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access),<br></p><p>This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br></p><p>&gt; or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br></p><p>Not just behavior metadata.  Someday we might have user-defined attributes which we would also want to have available.  It’s probably better to make available anything that could be useful and isn’t too costly to provide.  It could all live behind a `metadata` property so we don’t clutter the interface of the views themselves.<br></p><p>&gt; <br>&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt; <br>&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/31b1b8a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>Thanks, as always, for the thoughtful feedback. (inline)<br></p><p>On Thu, May 26, 2016 at 7:20 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; These names are a good place to start but I agree that it would be nice to<br>&gt; improve them.  I will give it some thought.  One comment for now - you use<br>&gt; both `get` / `set` and `read` / `write`.  It’s probably better to pick one.<br>&gt;<br></p><p>Yes, that&#39;s a good start. I&#39;ll sleep on it.<br></p><p><br>&gt;<br>&gt;<br>&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler<br>&gt; to generate whatever hooks, metadata, and support code is necessary. Once a<br>&gt; type conforms, the interface to the reflection features naturally present<br>&gt; themselves as protocol methods. It would be great to allow an extension to<br>&gt; retroactively enable reflection on a type vended by another module,<br>&gt; although I have no idea how feasible that is.<br>&gt;<br>&gt;<br>&gt; What do you think of using the `deriving` syntax for this (assuming we go<br>&gt; in that direction for Equatable, Hashable, and other synthesized<br>&gt; conformances).<br>&gt;<br></p><p>&#39;deriving&#39; is pretty much what I had in mind. If Equatable gets a magical<br>attribute, keyword, or whatever, I&#39;d like to use it for this feature as<br>well.<br></p><p><br>&gt;<br>&gt;<br>&gt; It uses &quot;views&quot;: there are four types of views, two of each in the<br>&gt; following categories: typed vs untyped, get-only versus get-set. A view is<br>&gt; a struct representing a property on an instance of a type (or maybe a<br>&gt; metatype, for type properties). It allows you to get information about that<br>&gt; property (like its name) and try getting and setting its values.<br>&gt;<br>&gt;<br>&gt; How did you arrive at `get` and `set` methods?<br>&gt;<br></p><p>One big advantage methods have over properties is that you can (as of right<br>now) get a reference to a method as a value of function type, but not a<br>property.<br></p><p><br>&gt;<br>&gt; I am wondering how this might relate to lenses.  If we’re going to<br>&gt; introduce those it feels like the property value should be introduced as a<br>&gt; lens.  I’m unsure of exactly what that would look like but I it is<br>&gt; definitely worth thinking about.<br>&gt;<br></p><p>I think it&#39;s worth consideration. Maybe views into properties can<br>eventually conform to some sort of lens protocol or interface, allowing<br>them to be composed and used as such.<br></p><p><br>&gt;<br>&gt; Another option if we don’t go with a lens is a simple property (`var value<br>&gt; { get }` and `var value { get set }`).  IIRC we are going to have throwing<br>&gt; computed properties eventually so you could still throw from the setter.<br>&gt;<br>&gt; ```<br>&gt;<br>&gt; I&#39;m not yet sure how it should interact with access control (my<br>&gt; inclination is that it would only expose the properties you&#39;d be able to<br>&gt; directly access),<br>&gt;<br>&gt;<br>&gt; This one is tricky.  I am generally be opposed to any way to get around<br>&gt; access control.  But people are going to implement things like<br>&gt; serialization using this which may require access to private properties.  I<br>&gt; think we want to try to understand the consequences of different options<br>&gt; and when in doubt decide in favor caution.<br>&gt;<br></p><p>My personal preference would be to honor access control, and consider<br>ser/de separately (especially since there are so many other possible<br>considerations for that feature). Access control in Swift isn&#39;t just<br>another safety feature, it&#39;s also a boundary for things like the optimizer.<br></p><p>To be honest, I expect the first big use of a feature like this to be<br>turning JSON or XML received from a network call into model objects for an<br>app. There are quite a few Objective-C libraries that use KVC to implement<br>this functionality.<br></p><p><br>&gt;<br>&gt; or property behaviors (I think get-set behavior is fundamental to<br>&gt; properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;<br>&gt;<br>&gt; Not just behavior metadata.  Someday we might have user-defined attributes<br>&gt; which we would also want to have available.  It’s probably better to make<br>&gt; available anything that could be useful and isn’t too costly to provide.<br>&gt; It could all live behind a `metadata` property so we don’t clutter the<br>&gt; interface of the views themselves.<br>&gt;<br>&gt;<br>Absolutely. It&#39;s not clear right now what property behaviors will end up<br>looking like, but if possible I&#39;d definitely like to reify them and expose<br>them to the end user (like how the T.Type is exposed in the gist). At the<br>very least (and this is definitely insufficient), there should be a list of<br>strings describing the behaviors.<br></p><p>&gt;<br>&gt; I&#39;d also have to figure out how it would operate with generic types or<br>&gt; existentials.<br>&gt;<br>&gt; Anyways, thanks for reading all the way to the end, and any feedback,<br>&gt; criticism, or alternative proposals would be greatly appreciated.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/d358e7f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 27 May 2016, at 04:44, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My personal preference would be to honor access control, and consider ser/de separately (especially since there are so many other possible considerations for that feature). Access control in Swift isn&#39;t just another safety feature, it&#39;s also a boundary for things like the optimizer.<br>&gt; <br>&gt; To be honest, I expect the first big use of a feature like this to be turning JSON or XML received from a network call into model objects for an app. There are quite a few Objective-C libraries that use KVC to implement this functionality.<br></p><p>That&#39;s what I want to use it for and I&#39;m fairly sure we need access to private properties for that.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 12:00:00am</p></header><div class="content"><p>Would you be willing to elaborate? Are you thinking of model objects whose properties are all completely hidden using &#39;private&#39; and whose APIs are available only through methods? What if there existed something like &quot;private(reflectable)&quot;, for properties you really want to keep both private and exposed to the reflection machinery? Or maybe a property behavior to do the same thing once that feature becomes a reality...<br></p><p>Austin<br></p><p><br>&gt; On May 26, 2016, at 11:52 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 27 May 2016, at 04:44, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My personal preference would be to honor access control, and consider ser/de separately (especially since there are so many other possible considerations for that feature). Access control in Swift isn&#39;t just another safety feature, it&#39;s also a boundary for things like the optimizer.<br>&gt;&gt; <br>&gt;&gt; To be honest, I expect the first big use of a feature like this to be turning JSON or XML received from a network call into model objects for an app. There are quite a few Objective-C libraries that use KVC to implement this functionality.<br>&gt; <br>&gt; That&#39;s what I want to use it for and I&#39;m fairly sure we need access to private properties for that.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>The private(reflectable) sounds reasonable, however, what about internal? It&#39;s impossible to include it in an invocation from within the module, but not including it when invoked from outside.<br></p><p>Would the behavior on private vars be non-reflectable by default and internal vars would be reflectable by default?<br></p><p>Charlie<br></p><p><br>&gt; On May 27, 2016, at 9:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would you be willing to elaborate? Are you thinking of model objects whose properties are all completely hidden using &#39;private&#39; and whose APIs are available only through methods? What if there existed something like &quot;private(reflectable)&quot;, for properties you really want to keep both private and exposed to the reflection machinery? Or maybe a property behavior to do the same thing once that feature becomes a reality...<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 11:52 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 04:44, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My personal preference would be to honor access control, and consider ser/de separately (especially since there are so many other possible considerations for that feature). Access control in Swift isn&#39;t just another safety feature, it&#39;s also a boundary for things like the optimizer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To be honest, I expect the first big use of a feature like this to be turning JSON or XML received from a network call into model objects for an app. There are quite a few Objective-C libraries that use KVC to implement this functionality.<br>&gt;&gt; <br>&gt;&gt; That&#39;s what I want to use it for and I&#39;m fairly sure we need access to private properties for that.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m talking of model objects that serializes certain properties (not necessarily all) that should have their setter be private/hidden for encapsulation reasons:<br></p><p>struct Person {<br>    private(set) var birthdate: NSDate<br>}<br></p><p>I&#39;m not a fan of adding an attribute like private(reflectable). The proposal we are discussing is most probably coming post-Swift3 and we might as well wait until property behaviour a are brought in to the mix.<br></p><p>Sorry if my post feels negative, but I&#39;m a huge supporter of Reflection APIs and I just want us to get it right :)<br></p><p>&gt; On 27 May 2016, at 09:25, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would you be willing to elaborate? Are you thinking of model objects whose properties are all completely hidden using &#39;private&#39; and whose APIs are available only through methods? What if there existed something like &quot;private(reflectable)&quot;, for properties you really want to keep both private and exposed to the reflection machinery? Or maybe a property behavior to do the same thing once that feature becomes a reality...<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 11:52 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 04:44, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My personal preference would be to honor access control, and consider ser/de separately (especially since there are so many other possible considerations for that feature). Access control in Swift isn&#39;t just another safety feature, it&#39;s also a boundary for things like the optimizer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To be honest, I expect the first big use of a feature like this to be turning JSON or XML received from a network call into model objects for an app. There are quite a few Objective-C libraries that use KVC to implement this functionality.<br>&gt;&gt; <br>&gt;&gt; That&#39;s what I want to use it for and I&#39;m fairly sure we need access to private properties for that.<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 2:25 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would you be willing to elaborate? Are you thinking of model objects whose properties are all completely hidden using &#39;private&#39; and whose APIs are available only through methods? What if there existed something like &quot;private(reflectable)&quot;, for properties you really want to keep both private and exposed to the reflection machinery? Or maybe a property behavior to do the same thing once that feature becomes a reality...<br></p><p>&#39;private(reflectable)&#39; would mean private for the purpose of reflection if we follow the same interpretation as &#39;private(set)&#39;.  Maybe you meant &#39;private public(reflectable)&#39; - as in private, but public for the purpose of reflection only.<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 11:52 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 04:44, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My personal preference would be to honor access control, and consider ser/de separately (especially since there are so many other possible considerations for that feature). Access control in Swift isn&#39;t just another safety feature, it&#39;s also a boundary for things like the optimizer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To be honest, I expect the first big use of a feature like this to be turning JSON or XML received from a network call into model objects for an app. There are quite a few Objective-C libraries that use KVC to implement this functionality.<br>&gt;&gt; <br>&gt;&gt; That&#39;s what I want to use it for and I&#39;m fairly sure we need access to private properties for that.<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 26, 2016, at 9:44 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks, as always, for the thoughtful feedback. (inline)<br>&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 7:20 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; These names are a good place to start but I agree that it would be nice to improve them.  I will give it some thought.  One comment for now - you use both `get` / `set` and `read` / `write`.  It’s probably better to pick one.<br>&gt; <br>&gt; Yes, that&#39;s a good start. I&#39;ll sleep on it.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt; <br>&gt;&gt; What do you think of using the `deriving` syntax for this (assuming we go in that direction for Equatable, Hashable, and other synthesized conformances).<br>&gt; <br>&gt; &#39;deriving&#39; is pretty much what I had in mind. If Equatable gets a magical attribute, keyword, or whatever, I&#39;d like to use it for this feature as well.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt; <br>&gt;&gt; How did you arrive at `get` and `set` methods?<br>&gt; <br>&gt; One big advantage methods have over properties is that you can (as of right now) get a reference to a method as a value of function type, but not a property.<br></p><p>True, but as with &#39;throws&#39; this is a temporary limitation.  I don&#39;t think we should design our reflection API around a temporary limitation.  IIRC the intended plan for getting first class access to properties is a lens.  If we model it as a property we will eventually get first class access to it as a lens (which means we play nice with lenses even though we don&#39;t know what they will look like yet).<br></p><p>&gt;  <br>&gt;&gt; <br>&gt;&gt; I am wondering how this might relate to lenses.  If we’re going to introduce those it feels like the property value should be introduced as a lens.  I’m unsure of exactly what that would look like but I it is definitely worth thinking about.<br>&gt; <br>&gt; I think it&#39;s worth consideration. Maybe views into properties can eventually conform to some sort of lens protocol or interface, allowing them to be composed and used as such.<br></p><p>I think Joe Groff has talked about lenses more than anyone else.  Maybe he has some thoughts on this.  But as I noted above, maybe exposing access as a property is the best first step.  It&#39;s easy enough to wrap in a closure if you need to pass a function around before property references / lenses are introduced.<br></p><p>&gt;  <br>&gt;&gt; <br>&gt;&gt; Another option if we don’t go with a lens is a simple property (`var value { get }` and `var value { get set }`).  IIRC we are going to have throwing computed properties eventually so you could still throw from the setter.<br>&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access),<br>&gt;&gt; <br>&gt;&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br>&gt; <br>&gt; My personal preference would be to honor access control, and consider ser/de separately (especially since there are so many other possible considerations for that feature). Access control in Swift isn&#39;t just another safety feature, it&#39;s also a boundary for things like the optimizer.<br>&gt; <br>&gt; To be honest, I expect the first big use of a feature like this to be turning JSON or XML received from a network call into model objects for an app. There are quite a few Objective-C libraries that use KVC to implement this functionality.<br></p><p>As several have noted, this is what makes things tricky.  People will want to write a library packaged as a module that can serialize private properties from types in a different module.  We need to at least consider that use case.  Supporting reflection-specific visibility might be a reasonable way to strike a balance.  But I&#39;m sure it would also receive a lot of resistance on both sides (those who don&#39;t think it&#39;s necessary to make internals more visible and those who want them to be visible without extra boilerplate).<br></p><p>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt; <br>&gt;&gt; Not just behavior metadata.  Someday we might have user-defined attributes which we would also want to have available.  It’s probably better to make available anything that could be useful and isn’t too costly to provide.  It could all live behind a `metadata` property so we don’t clutter the interface of the views themselves.<br>&gt; <br>&gt; Absolutely. It&#39;s not clear right now what property behaviors will end up looking like, but if possible I&#39;d definitely like to reify them and expose them to the end user (like how the T.Type is exposed in the gist). At the very least (and this is definitely insufficient), there should be a list of strings describing the behaviors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/155b69df/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 4:05 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 26, 2016, at 9:44 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Thanks, as always, for the thoughtful feedback. (inline)<br>&gt;&gt; <br>&gt;&gt; On Thu, May 26, 2016 at 7:20 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; These names are a good place to start but I agree that it would be nice to improve them.  I will give it some thought.  One comment for now - you use both `get` / `set` and `read` / `write`.  It’s probably better to pick one.<br>&gt;&gt; <br>&gt;&gt; Yes, that&#39;s a good start. I&#39;ll sleep on it.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt; <br>&gt;&gt; What do you think of using the `deriving` syntax for this (assuming we go in that direction for Equatable, Hashable, and other synthesized conformances).<br>&gt;&gt; <br>&gt;&gt; &#39;deriving&#39; is pretty much what I had in mind. If Equatable gets a magical attribute, keyword, or whatever, I&#39;d like to use it for this feature as well.<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt; <br>&gt;&gt; How did you arrive at `get` and `set` methods?<br>&gt;&gt; <br>&gt;&gt; One big advantage methods have over properties is that you can (as of right now) get a reference to a method as a value of function type, but not a property.<br>&gt; <br>&gt; True, but as with &#39;throws&#39; this is a temporary limitation.  I don&#39;t think we should design our reflection API around a temporary limitation.  IIRC the intended plan for getting first class access to properties is a lens.  If we model it as a property we will eventually get first class access to it as a lens (which means we play nice with lenses even though we don&#39;t know what they will look like yet).<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; I am wondering how this might relate to lenses.  If we’re going to introduce those it feels like the property value should be introduced as a lens.  I’m unsure of exactly what that would look like but I it is definitely worth thinking about.<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s worth consideration. Maybe views into properties can eventually conform to some sort of lens protocol or interface, allowing them to be composed and used as such.<br>&gt; <br>&gt; I think Joe Groff has talked about lenses more than anyone else.  Maybe he has some thoughts on this.  But as I noted above, maybe exposing access as a property is the best first step.  It&#39;s easy enough to wrap in a closure if you need to pass a function around before property references / lenses are introduced.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; Another option if we don’t go with a lens is a simple property (`var value { get }` and `var value { get set }`).  IIRC we are going to have throwing computed properties eventually so you could still throw from the setter.<br>&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), <br>&gt;&gt; <br>&gt;&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br>&gt;&gt; <br>&gt;&gt; My personal preference would be to honor access control, and consider ser/de separately (especially since there are so many other possible considerations for that feature). Access control in Swift isn&#39;t just another safety feature, it&#39;s also a boundary for things like the optimizer.<br>&gt;&gt; <br>&gt;&gt; To be honest, I expect the first big use of a feature like this to be turning JSON or XML received from a network call into model objects for an app. There are quite a few Objective-C libraries that use KVC to implement this functionality.<br>&gt; <br>&gt; As several have noted, this is what makes things tricky.  People will want to write a library packaged as a module that can serialize private properties from types in a different module.  We need to at least consider that use case.  <br></p><p><br>or perhaps simply read what the people who have a lot of experience the topic have to say about it, and hopefully learn from the errors others have described. Serialization has long been a source of serious security issues in Java. Swift could do without these<br></p><p>-1 <br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/15d4a9e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 9:50 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 4:05 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 26, 2016, at 9:44 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Thanks, as always, for the thoughtful feedback. (inline)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 26, 2016 at 7:20 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These names are a good place to start but I agree that it would be nice to improve them.  I will give it some thought.  One comment for now - you use both `get` / `set` and `read` / `write`.  It’s probably better to pick one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, that&#39;s a good start. I&#39;ll sleep on it.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think of using the `deriving` syntax for this (assuming we go in that direction for Equatable, Hashable, and other synthesized conformances).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;deriving&#39; is pretty much what I had in mind. If Equatable gets a magical attribute, keyword, or whatever, I&#39;d like to use it for this feature as well.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How did you arrive at `get` and `set` methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One big advantage methods have over properties is that you can (as of right now) get a reference to a method as a value of function type, but not a property.<br>&gt;&gt; <br>&gt;&gt; True, but as with &#39;throws&#39; this is a temporary limitation.  I don&#39;t think we should design our reflection API around a temporary limitation.  IIRC the intended plan for getting first class access to properties is a lens.  If we model it as a property we will eventually get first class access to it as a lens (which means we play nice with lenses even though we don&#39;t know what they will look like yet).<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am wondering how this might relate to lenses.  If we’re going to introduce those it feels like the property value should be introduced as a lens.  I’m unsure of exactly what that would look like but I it is definitely worth thinking about.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it&#39;s worth consideration. Maybe views into properties can eventually conform to some sort of lens protocol or interface, allowing them to be composed and used as such.<br>&gt;&gt; <br>&gt;&gt; I think Joe Groff has talked about lenses more than anyone else.  Maybe he has some thoughts on this.  But as I noted above, maybe exposing access as a property is the best first step.  It&#39;s easy enough to wrap in a closure if you need to pass a function around before property references / lenses are introduced.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another option if we don’t go with a lens is a simple property (`var value { get }` and `var value { get set }`).  IIRC we are going to have throwing computed properties eventually so you could still throw from the setter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My personal preference would be to honor access control, and consider ser/de separately (especially since there are so many other possible considerations for that feature). Access control in Swift isn&#39;t just another safety feature, it&#39;s also a boundary for things like the optimizer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To be honest, I expect the first big use of a feature like this to be turning JSON or XML received from a network call into model objects for an app. There are quite a few Objective-C libraries that use KVC to implement this functionality.<br>&gt;&gt; <br>&gt;&gt; As several have noted, this is what makes things tricky.  People will want to write a library packaged as a module that can serialize private properties from types in a different module.  We need to at least consider that use case. <br>&gt; <br>&gt; <br>&gt; or perhaps simply read what the people who have a lot of experience the topic have to say about it, and hopefully learn from the errors others have described. Serialization has long been a source of serious security issues in Java. Swift could do without these<br>&gt; <br>&gt; -1 <br></p><p>That’s a good point.  Talking about the issues involved and stating the reasons for our decision is giving the use case consideration.  I’m not advocating either way.  I’m just saying that we need to make a conscious decision with a good and clearly stated rationale.<br></p><p>-Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/b3eaa3eb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 4:20 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 26, 2016, at 8:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt; <br>&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt; <br>&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt; <br>&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br>&gt;&gt; <br>&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt; <br>&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt; <br>&gt; These names are a good place to start but I agree that it would be nice to improve them.  I will give it some thought.  One comment for now - you use both `get` / `set` and `read` / `write`.  It’s probably better to pick one.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt; <br>&gt; What do you think of using the `deriving` syntax for this (assuming we go in that direction for Equatable, Hashable, and other synthesized conformances).<br>&gt; <br></p><p>I saw this syntax show up in the equatable/hashable context (could not convince myself of its value), are there other areas where it was put forward?<br></p><p><br></p><p>&gt;&gt; <br>&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt; <br>&gt; How did you arrive at `get` and `set` methods?<br>&gt; <br>&gt; I am wondering how this might relate to lenses.  If we’re going to introduce those it feels like the property value should be introduced as a lens.  I’m unsure of exactly what that would look like but I it is definitely worth thinking about.<br>&gt; <br>&gt; Another option if we don’t go with a lens is a simple property (`var value { get }` and `var value { get set }`).  IIRC we are going to have throwing computed properties eventually so you could still throw from the setter.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt; <br>&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt; <br>&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt; <br>&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt; <br>&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access),<br>&gt; <br>&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br>&gt; <br>&gt;&gt; or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt; <br>&gt; Not just behavior metadata.  Someday we might have user-defined attributes which we would also want to have available.  It’s probably better to make available anything that could be useful and isn’t too costly to provide.  It could all live behind a `metadata` property so we don’t clutter the interface of the views themselves.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt; <br>&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/23ee1fa1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 3:07 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 4:20 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 8:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt; <br>&gt;&gt; These names are a good place to start but I agree that it would be nice to improve them.  I will give it some thought.  One comment for now - you use both `get` / `set` and `read` / `write`.  It’s probably better to pick one.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt; <br>&gt;&gt; What do you think of using the `deriving` syntax for this (assuming we go in that direction for Equatable, Hashable, and other synthesized conformances).<br>&gt; <br>&gt; I saw this syntax show up in the equatable/hashable context (could not convince myself of its value), are there other areas where it was put forward?<br></p><p>Not yet, but when we have the ability to run code at compile time it is possible we could even have user-defined derivable protocols somehow.  I&#39;m sure we will have the ability to synthesize more than just these two eventually.<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt; <br>&gt;&gt; How did you arrive at `get` and `set` methods?<br>&gt;&gt; <br>&gt;&gt; I am wondering how this might relate to lenses.  If we’re going to introduce those it feels like the property value should be introduced as a lens.  I’m unsure of exactly what that would look like but I it is definitely worth thinking about.<br>&gt;&gt; <br>&gt;&gt; Another option if we don’t go with a lens is a simple property (`var value { get }` and `var value { get set }`).  IIRC we are going to have throwing computed properties eventually so you could still throw from the setter.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access),<br>&gt;&gt; <br>&gt;&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br>&gt;&gt; <br>&gt;&gt;&gt; or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt; <br>&gt;&gt; Not just behavior metadata.  Someday we might have user-defined attributes which we would also want to have available.  It’s probably better to make available anything that could be useful and isn’t too costly to provide.  It could all live behind a `metadata` property so we don’t clutter the interface of the views themselves.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/2ecc738c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 3:18 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 27, 2016, at 3:07 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 4:20 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 26, 2016, at 8:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These names are a good place to start but I agree that it would be nice to improve them.  I will give it some thought.  One comment for now - you use both `get` / `set` and `read` / `write`.  It’s probably better to pick one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think of using the `deriving` syntax for this (assuming we go in that direction for Equatable, Hashable, and other synthesized conformances).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I saw this syntax show up in the equatable/hashable context (could not convince myself of its value), are there other areas where it was put forward?<br>&gt; <br>&gt; Not yet, but when we have the ability to run code at compile time it is possible we could even have user-defined derivable protocols somehow.  I&#39;m sure we will have the ability to synthesize more than just these two eventually.<br>&gt; <br></p><p>so then IMHO the language as it exists today does not need ‘deriving’. I would even venture that the core team has a road-map for equatable/hashable. And if not, they do have some code in place that looks like it is very close to doing the trick today. So that leaves me thinking that it is either a bandwidth issue (not wanting to over commit and miss the deadline) and/or interaction with other decisions that might need to be made before (initializers being one - and that one seems to also have dependencies on 4+). Either way, I do not forsee a ‘deriving’. But I am truly nobody.<br></p><p><br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How did you arrive at `get` and `set` methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am wondering how this might relate to lenses.  If we’re going to introduce those it feels like the property value should be introduced as a lens.  I’m unsure of exactly what that would look like but I it is definitely worth thinking about.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another option if we don’t go with a lens is a simple property (`var value { get }` and `var value { get set }`).  IIRC we are going to have throwing computed properties eventually so you could still throw from the setter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not just behavior metadata.  Someday we might have user-defined attributes which we would also want to have available.  It’s probably better to make available anything that could be useful and isn’t too costly to provide.  It could all live behind a `metadata` property so we don’t clutter the interface of the views themselves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/65c36222/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br></p><p>I had some thoughts about an alternate design based partially on access control concerns. Sketching roughly, it looks like this:<br></p><p>* There is a pseudo-property called, say, `properties` on every type (and perhaps on every instance). (Alternate designs are available, like an `inout`-returning pseudo-function. It doesn&#39;t really matter.)<br></p><p>* `properties` is a dictionary, or at least something very like a dictionary: you can look something up by key or iterate over the available keys. Its keys are strings, and its values are lens functions. These lens functions return type Any; their setters throw if you assign an incompatible type.<br></p><p>* The contents of `properties` are the properties visible *at the site where it is called*. That means calling `properties` in different places will give you different results. If you import a type from another module and then add properties in an `internal` extension, you&#39;ll see the other module&#39;s `public` properties plus your `internal` ones.<br></p><p>* You can pass your `properties` dictionary to other code; that effectively delegates your access to that other code. Thus, if your main class body passes its `property` dictionary to a serialization library, that library can access your private properties. If you pass it `inout`, then the library can modify your private properties.<br></p><p>* There is no opting in, but I *think* the compiler has enough information to figure out what goes into `properties` at the sites where it is used, so you only have to pay for it if and when you use it. I could be wrong, though—there may be something there that I&#39;m missing.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>I&#39;m also not fond of allowing what could be called a backdoor to accessing privates and intervals too but has anyone thought of enhancing the Mirror class instead of having something totally new? I&#39;ve tried using it once but in the end it wasn&#39;t necessary for what I needed to do.<br></p><p>An opt-in into reflection would be interesting too as it could help remove the burden of the compiler to prepare each class and instance for reflection. Should a type be prepared for reflection one could add to it an attribute like @reflected. Then the compiler would add the necessary optimisations to it and its subclasses.<br></p><p>About serialisation, I still think the best way to deal with it is to use the Visitor pattern. Each class that needs serialisation implements the functions that say what exactly is needed to save and restore state. I don&#39;t see how anything automatic can be better than this.<br></p><p><br>-----Original Message-----<br>From: &quot;Brent Royal-Gordon via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎27/‎05/‎2016 07:25 AM<br>To: &quot;Matthew Johnson&quot; &lt;matthew at anandabits.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Pitch] Property reflection<br></p><p>&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br></p><p>I had some thoughts about an alternate design based partially on access control concerns. Sketching roughly, it looks like this:<br></p><p>* There is a pseudo-property called, say, `properties` on every type (and perhaps on every instance). (Alternate designs are available, like an `inout`-returning pseudo-function. It doesn&#39;t really matter.)<br></p><p>* `properties` is a dictionary, or at least something very like a dictionary: you can look something up by key or iterate over the available keys. Its keys are strings, and its values are lens functions. These lens functions return type Any; their setters throw if you assign an incompatible type.<br></p><p>* The contents of `properties` are the properties visible *at the site where it is called*. That means calling `properties` in different places will give you different results. If you import a type from another module and then add properties in an `internal` extension, you&#39;ll see the other module&#39;s `public` properties plus your `internal` ones.<br></p><p>* You can pass your `properties` dictionary to other code; that effectively delegates your access to that other code. Thus, if your main class body passes its `property` dictionary to a serialization library, that library can access your private properties. If you pass it `inout`, then the library can modify your private properties.<br></p><p>* There is no opting in, but I *think* the compiler has enough information to figure out what goes into `properties` at the sites where it is used, so you only have to pay for it if and when you use it. I could be wrong, though—there may be something there that I&#39;m missing.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/58bdcaa3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 6:15 AM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m also not fond of allowing what could be called a backdoor to accessing privates and intervals too but has anyone thought of enhancing the Mirror class instead of having something totally new? I&#39;ve tried using it once but in the end it wasn&#39;t necessary for what I needed to do.<br>&gt; <br>&gt; An opt-in into reflection would be interesting too as it could help remove the burden of the compiler to prepare each class and instance for reflection. Should a type be prepared for reflection one could add to it an attribute like @reflected. Then the compiler would add the necessary optimisations to it and its subclasses.<br>&gt; <br>&gt; About serialisation, I still think the best way to deal with it is to use the Visitor pattern. Each class that needs serialisation implements the functions that say what exactly is needed to save and restore state. I don&#39;t see how anything automatic can be better than this.<br></p><p>I brought up serialization because a lot of people *want* to do it using a dynamic API.  This is a part of the Objective-C vs Swift dynamism conversation that is happening right now.  That conversation inspired Austin&#39;s pitch and also my comment that people&#39;s desire for this makes access control a tricky issue.<br></p><p>Regardless of *you* want to do serialization, I think it&#39;s important to recognize that this is a hot topic and one of the frustrations some people currently have with Swift.  I think it&#39;s worth having the conversation about how we can better satisfy the use cases they have talked about and what role reflection might play in that.<br></p><p>I think most serialization use cases are probably better served by static rather than dynamic reflection.  But it isn&#39;t clear how long we&#39;ll have to wait until we can do that.<br></p><p>&gt; From: Brent Royal-Gordon via swift-evolution<br>&gt; Sent: ‎27/‎05/‎2016 07:25 AM<br>&gt; To: Matthew Johnson<br>&gt; Cc: swift-evolution<br>&gt; Subject: Re: [swift-evolution] [Pitch] Property reflection<br>&gt; <br>&gt; &gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br>&gt; <br>&gt; I had some thoughts about an alternate design based partially on access control concerns. Sketching roughly, it looks like this:<br>&gt; <br>&gt; * There is a pseudo-property called, say, `properties` on every type (and perhaps on every instance). (Alternate designs are available, like an `inout`-returning pseudo-function. It doesn&#39;t really matter.)<br>&gt; <br>&gt; * `properties` is a dictionary, or at least something very like a dictionary: you can look something up by key or iterate over the available keys. Its keys are strings, and its values are lens functions. These lens functions return type Any; their setters throw if you assign an incompatible type.<br>&gt; <br>&gt; * The contents of `properties` are the properties visible *at the site where it is called*. That means calling `properties` in different places will give you different results. If you import a type from another module and then add properties in an `internal` extension, you&#39;ll see the other module&#39;s `public` properties plus your `internal` ones.<br>&gt; <br>&gt; * You can pass your `properties` dictionary to other code; that effectively delegates your access to that other code. Thus, if your main class body passes its `property` dictionary to a serialization library, that library can access your private properties. If you pass it `inout`, then the library can modify your private properties.<br>&gt; <br>&gt; * There is no opting in, but I *think* the compiler has enough information to figure out what goes into `properties` at the sites where it is used, so you only have to pay for it if and when you use it. I could be wrong, though—there may be something there that I&#39;m missing.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/48868a2c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 27, 2016, at 5:25 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; This one is tricky.  I am generally be opposed to any way to get around access control.  But people are going to implement things like serialization using this which may require access to private properties.  I think we want to try to understand the consequences of different options and when in doubt decide in favor caution.<br>&gt; <br>&gt; I had some thoughts about an alternate design based partially on access control concerns.<br></p><p>The syntax in your design would be very convenient for sure.<br></p><p>I&#39;m not sure how this alternative is related to access control.  Austin&#39;s proposal could enforce access control in the same way and he mentioned he was inclined to enforce it the same way you are describing.<br></p><p>The reason I say it is tricky is because enforcing access control in this way would prevent things people want to do with reflection (things that have received a lot of discussion recently).  Allowing a distinct visibility to be specified for reflection might be a way to strike a reasonable balance.<br></p><p>Your suggested approach doesn&#39;t allow for access to property metadata.  Do you have any suggestions on how that would be exposed?  <br></p><p>What about casting the lens to a typed lens?  Would you envision that being supported?<br></p><p>I also think we would want a way to access a specific property by name if accessing the whole properties dictionary involved any non-trivial overhead (but maybe it wouldn&#39;t have to).<br></p><p>&gt; Sketching roughly, it looks like this:<br>&gt; <br>&gt; * There is a pseudo-property called, say, `properties` on every type (and perhaps on every instance). (Alternate designs are available, like an `inout`-returning pseudo-function. It doesn&#39;t really matter.)<br>&gt; <br>&gt; * `properties` is a dictionary, or at least something very like a dictionary: you can look something up by key or iterate over the available keys. Its keys are strings, and its values are lens functions. These lens functions return type Any; their setters throw if you assign an incompatible type.<br>&gt; <br>&gt; * The contents of `properties` are the properties visible *at the site where it is called*. That means calling `properties` in different places will give you different results. If you import a type from another module and then add properties in an `internal` extension, you&#39;ll see the other module&#39;s `public` properties plus your `internal` ones.<br>&gt; <br>&gt; * You can pass your `properties` dictionary to other code; that effectively delegates your access to that other code. Thus, if your main class body passes its `property` dictionary to a serialization library, that library can access your private properties. If you pass it `inout`, then the library can modify your private properties.<br>&gt; <br>&gt; * There is no opting in, but I *think* the compiler has enough information to figure out what goes into `properties` at the sites where it is used, so you only have to pay for it if and when you use it. I could be wrong, though—there may be something there that I&#39;m missing.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; I&#39;m not sure how this alternative is related to access control.  Austin&#39;s proposal could enforce access control in the same way and he mentioned he was inclined to enforce it the same way you are describing.<br>&gt; <br>&gt; The reason I say it is tricky is because enforcing access control in this way would prevent things people want to do with reflection (things that have received a lot of discussion recently).  Allowing a distinct visibility to be specified for reflection might be a way to strike a reasonable balance.<br></p><p>It&#39;s related to access control because it&#39;s specifically intended that you can pass your `properties` dictionary to other code to delegate your access. This works around the &quot;but other code needs to see your private stuff&quot; problem: it *can* see your private stuff, but only if you permit it.<br></p><p>I suppose we would want a `#properties` you could use in a protocol conformance which would mean &quot;the properties visible at the conformance site&quot;:<br></p><p>	protocol Serializable {<br>		var propertiesToSerialize: PropertyView&lt;Self&gt; { get set }<br>		init(forDeserialization: ())<br>	}<br>	extension Serializable {<br>		var propertiesToSerialize: PropertyView&lt;Self&gt; {<br>			get { return #properties }<br>			set { #properties = newValue }<br>		}<br></p><p>		func serializedData() -&gt; Data {<br>			return Serializer().serialize(self)<br>		}<br>		factory init(serializedData data: Data) {<br>			self = Serializer.deserialize(data, of: Self.self)<br>		}<br>	}<br></p><p>&gt; Your suggested approach doesn&#39;t allow for access to property metadata.  Do you have any suggestions on how that would be exposed?  <br></p><p>I&#39;m not sure how much metadata is necessary beyond name (in the key) and type (discussed soon).<br></p><p>&gt; What about casting the lens to a typed lens?  Would you envision that being supported?<br></p><p>Yes. I would hope that you could downcast a concrete lens:<br></p><p>	let lens: () -&gt; inout Int = &amp;array.count					// Assuming this is a &quot;get lens&quot; syntax<br>	let abstractLens = lens as () throws(set) -&gt; inout Any		// Upcasting an inout-returning function adds `throws(set)`<br></p><p>And that you could later open the abstracted lens to get its concrete type:<br></p><p>	if let concreteLens = abstractLens openas Lens {<br>		print(Lens.ReturnValue)<br>		…<br>	}<br></p><p>This is a slightly different form of existential opening, and `ReturnValue` doesn&#39;t currently exist on function types, but I hope these things would be possible.	<br></p><p>&gt; I also think we would want a way to access a specific property by name if accessing the whole properties dictionary involved any non-trivial overhead (but maybe it wouldn&#39;t have to).<br></p><p>That&#39;s why I said &quot;like a dictionary&quot;. :^) If there&#39;s a way to access individual keys without collecting them all ahead of time, or to generate lenses as needed, I&#39;m all for it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 2:57 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m not sure how this alternative is related to access control.  Austin&#39;s proposal could enforce access control in the same way and he mentioned he was inclined to enforce it the same way you are describing.<br>&gt;&gt; <br>&gt;&gt; The reason I say it is tricky is because enforcing access control in this way would prevent things people want to do with reflection (things that have received a lot of discussion recently).  Allowing a distinct visibility to be specified for reflection might be a way to strike a reasonable balance.<br>&gt; <br>&gt; It&#39;s related to access control because it&#39;s specifically intended that you can pass your `properties` dictionary to other code to delegate your access. This works around the &quot;but other code needs to see your private stuff&quot; problem: it *can* see your private stuff, but only if you permit it.<br>&gt; <br>&gt; I suppose we would want a `#properties` you could use in a protocol conformance which would mean &quot;the properties visible at the conformance site&quot;:<br>&gt; <br>&gt; 	protocol Serializable {<br>&gt; 		var propertiesToSerialize: PropertyView&lt;Self&gt; { get set }<br>&gt; 		init(forDeserialization: ())<br>&gt; 	}<br>&gt; 	extension Serializable {<br>&gt; 		var propertiesToSerialize: PropertyView&lt;Self&gt; {<br>&gt; 			get { return #properties }<br>&gt; 			set { #properties = newValue }<br>&gt; 		}<br>&gt; <br>&gt; 		func serializedData() -&gt; Data {<br>&gt; 			return Serializer().serialize(self)<br>&gt; 		}<br>&gt; 		factory init(serializedData data: Data) {<br>&gt; 			self = Serializer.deserialize(data, of: Self.self)<br>&gt; 		}<br>&gt; 	}<br></p><p>That’s an interesting approach.  That could also be a way to strike a reasonable balance.  Good to see different design possibilities explored here.  That’s what I was looking for.  <br></p><p>&gt; <br>&gt;&gt; Your suggested approach doesn&#39;t allow for access to property metadata.  Do you have any suggestions on how that would be exposed?  <br>&gt; <br>&gt; I&#39;m not sure how much metadata is necessary beyond name (in the key) and type (discussed soon).<br></p><p>In the future we may have user-defined attributes.  It could be very useful to expose that.<br></p><p>&gt; <br>&gt;&gt; What about casting the lens to a typed lens?  Would you envision that being supported?<br>&gt; <br>&gt; Yes. I would hope that you could downcast a concrete lens:<br>&gt; <br>&gt; 	let lens: () -&gt; inout Int = &amp;array.count					// Assuming this is a &quot;get lens” syntax<br></p><p>I think the syntax was actually a little bit different as the lens isn’t bound to the instance and a readonly lens wouldn’t return inout:<br></p><p>let lens: (Array&lt;MyType&gt;) -&gt; Int = &amp;array.count<br></p><p>&gt; 	let abstractLens = lens as () throws(set) -&gt; inout Any		// Upcasting an inout-returning function adds `throws(set)`<br></p><p>And I think this would be: `(inout Array&lt;MyType&gt;) -&gt; inout Any` (with some additional syntax for throwing on the writeback which would make sense to me alongside the `inout`, but I haven’t seen any specific examples proposed).<br></p><p>&gt; <br>&gt; And that you could later open the abstracted lens to get its concrete type:<br>&gt; <br>&gt; 	if let concreteLens = abstractLens openas Lens {<br>&gt; 		print(Lens.ReturnValue)<br>&gt; 		…<br>&gt; 	}<br></p><p>What about casting like this:<br></p><p>let typedLens = abstractLens as? (Array&lt;MyType&gt;) -&gt; Int<br></p><p>&gt; <br>&gt; This is a slightly different form of existential opening, and `ReturnValue` doesn&#39;t currently exist on function types, but I hope these things would be possible.	<br>&gt; <br>&gt;&gt; I also think we would want a way to access a specific property by name if accessing the whole properties dictionary involved any non-trivial overhead (but maybe it wouldn&#39;t have to).<br>&gt; <br>&gt; That&#39;s why I said &quot;like a dictionary&quot;. :^) If there&#39;s a way to access individual keys without collecting them all ahead of time, or to generate lenses as needed, I&#39;m all for it.<br></p><p>Right.  There has already been some talk of `Map` and `MutableMap` protocols.  `Map` would be useful here (as well as for supporting lazy dictionary operations among other things).<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt; I&#39;m not sure how much metadata is necessary beyond name (in the key) and type (discussed soon).<br>&gt; <br>&gt; In the future we may have user-defined attributes.  It could be very useful to expose that.<br></p><p><br>This is true.<br></p><p>Actually, I&#39;m wondering if property behaviors should be able to essentially declare alternate PropertyViews and add their properties to them. For instance:<br></p><p>	var behavior persistent&lt;Value: PersistentValue&gt;: Value where Self: ManagedObject {<br>		belongsto persistentProperties, static persistentInstanceProperties<br>		<br>		name: String<br>		var value: Value<br>		<br>		init() {<br>			value = entity.propertiesByName[name].defaultValue<br>		}<br>		<br>		get { return value }<br>		set { value = newValue }<br>	}<br>	<br>	protocol Managed {<br>		static var persistentProperties: InstancePropertyView&lt;Self&gt; { get }<br>		var persistentProperties: PropertyView&lt;Self&gt; { get set }<br>		...<br>	}<br>	<br>	class Person: Managed {<br>		@persistent var name: String<br>		@persistent var birthDate: Date<br>	}<br>	<br>	print(Person.persistentProperties.keys)		// =&gt; &quot;name&quot;, &quot;birthDate&quot;<br></p><p>I think it&#39;s probably more likely that you want to access the subset of properties with a particular attribute than that you want to look through all the properties and check whether each one has or doesn&#39;t have that attribute.<br></p><p>(Incidentally, this is beginning to look a little like one of the post- at memberwise proposals to have some sort of entity representing a group of properties—only more flexible and with a broader set of use cases. Still, there might be hope for a solution with a `@memberwise` behavior and a macro to look at the resulting property view and generate an initializer from it.)<br></p><p>&gt;&gt; Yes. I would hope that you could downcast a concrete lens:<br>&gt;&gt; <br>&gt;&gt; 	let lens: () -&gt; inout Int = &amp;array.count					// Assuming this is a &quot;get lens” syntax<br>&gt; <br>&gt; I think the syntax was actually a little bit different as the lens isn’t bound to the instance and a readonly lens wouldn’t return inout:<br>&gt; <br>&gt; let lens: (Array&lt;MyType&gt;) -&gt; Int = &amp;array.count<br></p><p>I envision there being both bound lenses (sorry, I forgot that `Array.count` isn&#39;t mutating):<br></p><p>	struct Person { var name: String }<br>	var joe = Person(name: &quot;Joe&quot;)<br>	<br>	let lens: () -&gt; inout String =  &amp;joe.name<br></p><p>And unbound ones:<br></p><p>	let unboundLens: (inout Person) -&gt; inout String = Person.name<br></p><p>`properties` on an instance would give you bound lenses; `properties` on a type would give you unbound ones. (Or maybe the latter would be something like `instanceProperties`, since type instances have properties too.)<br></p><p>On the other hand, the idea of bound lenses might not be coherent; the `inout` parameter of an unbound lens helps make sure that mutation affects value-typed instances, so bound lenses might not work. Perhaps `properties` on an instance should be more akin to a `[String: Any]` dictionary, so that `joe.properties[&quot;name&quot;] = &quot;Bob&quot;` naturally calls `joe`&#39;s `properties` setter. The problem I see there is that the `openas` might open things too far: If the property is declared to be of protocol type, `openas` would end up giving you the concrete type of its current value instead.<br></p><p>&gt;&gt; And that you could later open the abstracted lens to get its concrete type:<br>&gt;&gt; <br>&gt;&gt; 	if let concreteLens = abstractLens openas Lens {<br>&gt;&gt; 		print(Lens.ReturnValue)<br>&gt;&gt; 		…<br>&gt;&gt; 	}<br>&gt; <br>&gt; What about casting like this:<br>&gt; <br>&gt; let typedLens = abstractLens as? (Array&lt;MyType&gt;) -&gt; Int<br></p><p>If you&#39;re specifically expecting an `Int`, sure. But if you have no idea what the type is and want to find out, I think you&#39;d need to (somehow) open the Any lens and see the concrete return type inside.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/426fbd3d9b662663dc5647b08c4e3410?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Anders Ha</string> &lt;hello at andersio.co&gt;<p>May 28, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On 28 May 2016, at 6:00 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I&#39;m not sure how much metadata is necessary beyond name (in the key) and type (discussed soon).<br>&gt;&gt; <br>&gt;&gt; In the future we may have user-defined attributes.  It could be very useful to expose that.<br>&gt; <br>&gt; <br>&gt; This is true.<br>&gt; <br>&gt; Actually, I&#39;m wondering if property behaviors should be able to essentially declare alternate PropertyViews and add their properties to them. For instance:<br>&gt; <br>&gt; 	var behavior persistent&lt;Value: PersistentValue&gt;: Value where Self: ManagedObject {<br>&gt; 		belongsto persistentProperties, static persistentInstanceProperties<br>&gt; 		<br>&gt; 		name: String<br>&gt; 		var value: Value<br>&gt; 		<br>&gt; 		init() {<br>&gt; 			value = entity.propertiesByName[name].defaultValue<br>&gt; 		}<br>&gt; 		<br>&gt; 		get { return value }<br>&gt; 		set { value = newValue }<br>&gt; 	}<br>&gt; 	<br>&gt; 	protocol Managed {<br>&gt; 		static var persistentProperties: InstancePropertyView&lt;Self&gt; { get }<br>&gt; 		var persistentProperties: PropertyView&lt;Self&gt; { get set }<br>&gt; 		...<br>&gt; 	}<br>&gt; 	<br>&gt; 	class Person: Managed {<br>&gt; 		@persistent var name: String<br>&gt; 		@persistent var birthDate: Date<br>&gt; 	}<br>&gt; 	<br>&gt; 	print(Person.persistentProperties.keys)		// =&gt; &quot;name&quot;, &quot;birthDate&quot;<br>&gt; <br>&gt; I think it&#39;s probably more likely that you want to access the subset of properties with a particular attribute than that you want to look through all the properties and check whether each one has or doesn&#39;t have that attribute.<br>&gt; <br>&gt; (Incidentally, this is beginning to look a little like one of the post- at memberwise proposals to have some sort of entity representing a group of properties—only more flexible and with a broader set of use cases. Still, there might be hope for a solution with a `@memberwise` behavior and a macro to look at the resulting property view and generate an initializer from it.)<br>&gt; <br>&gt;&gt;&gt; Yes. I would hope that you could downcast a concrete lens:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let lens: () -&gt; inout Int = &amp;array.count					// Assuming this is a &quot;get lens” syntax<br>&gt;&gt; <br>&gt;&gt; I think the syntax was actually a little bit different as the lens isn’t bound to the instance and a readonly lens wouldn’t return inout:<br>&gt;&gt; <br>&gt;&gt; let lens: (Array&lt;MyType&gt;) -&gt; Int = &amp;array.count<br>&gt; <br>&gt; I envision there being both bound lenses (sorry, I forgot that `Array.count` isn&#39;t mutating):<br>&gt; <br>&gt; 	struct Person { var name: String }<br>&gt; 	var joe = Person(name: &quot;Joe&quot;)<br>&gt; 	<br>&gt; 	let lens: () -&gt; inout String =  &amp;joe.name<br>&gt; <br>&gt; And unbound ones:<br>&gt; <br>&gt; 	let unboundLens: (inout Person) -&gt; inout String = Person.name<br>&gt; <br>&gt; `properties` on an instance would give you bound lenses; `properties` on a type would give you unbound ones. (Or maybe the latter would be something like `instanceProperties`, since type instances have properties too.)<br>&gt; <br>&gt; On the other hand, the idea of bound lenses might not be coherent; the `inout` parameter of an unbound lens helps make sure that mutation affects value-typed instances, so bound lenses might not work. Perhaps `properties` on an instance should be more akin to a `[String: Any]` dictionary, so that `joe.properties[&quot;name&quot;] = &quot;Bob&quot;` naturally calls `joe`&#39;s `properties` setter. The problem I see there is that the `openas` might open things too far: If the property is declared to be of protocol type, `openas` would end up giving you the concrete type of its current value instead.<br></p><p>In this case, I wonder if it would be less confusing if bound lenses are available only on reference types, or existential with a class bound.<br></p><p>&gt; <br>&gt;&gt;&gt; And that you could later open the abstracted lens to get its concrete type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let concreteLens = abstractLens openas Lens {<br>&gt;&gt;&gt; 		print(Lens.ReturnValue)<br>&gt;&gt;&gt; 		…<br>&gt;&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; What about casting like this:<br>&gt;&gt; <br>&gt;&gt; let typedLens = abstractLens as? (Array&lt;MyType&gt;) -&gt; Int<br>&gt; <br>&gt; If you&#39;re specifically expecting an `Int`, sure. But if you have no idea what the type is and want to find out, I think you&#39;d need to (somehow) open the Any lens and see the concrete return type inside.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 5:37 PM, Anders Ha &lt;hello at andersio.co&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 28 May 2016, at 6:00 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure how much metadata is necessary beyond name (in the key) and type (discussed soon).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the future we may have user-defined attributes.  It could be very useful to expose that.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is true.<br>&gt;&gt; <br>&gt;&gt; Actually, I&#39;m wondering if property behaviors should be able to essentially declare alternate PropertyViews and add their properties to them. For instance:<br>&gt;&gt; <br>&gt;&gt; 	var behavior persistent&lt;Value: PersistentValue&gt;: Value where Self: ManagedObject {<br>&gt;&gt; 		belongsto persistentProperties, static persistentInstanceProperties<br>&gt;&gt; 		<br>&gt;&gt; 		name: String<br>&gt;&gt; 		var value: Value<br>&gt;&gt; 		<br>&gt;&gt; 		init() {<br>&gt;&gt; 			value = entity.propertiesByName[name].defaultValue<br>&gt;&gt; 		}<br>&gt;&gt; 		<br>&gt;&gt; 		get { return value }<br>&gt;&gt; 		set { value = newValue }<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	protocol Managed {<br>&gt;&gt; 		static var persistentProperties: InstancePropertyView&lt;Self&gt; { get }<br>&gt;&gt; 		var persistentProperties: PropertyView&lt;Self&gt; { get set }<br>&gt;&gt; 		...<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	class Person: Managed {<br>&gt;&gt; 		@persistent var name: String<br>&gt;&gt; 		@persistent var birthDate: Date<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	print(Person.persistentProperties.keys)		// =&gt; &quot;name&quot;, &quot;birthDate&quot;<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s probably more likely that you want to access the subset of properties with a particular attribute than that you want to look through all the properties and check whether each one has or doesn&#39;t have that attribute.<br>&gt;&gt; <br>&gt;&gt; (Incidentally, this is beginning to look a little like one of the post- at memberwise proposals to have some sort of entity representing a group of properties—only more flexible and with a broader set of use cases. Still, there might be hope for a solution with a `@memberwise` behavior and a macro to look at the resulting property view and generate an initializer from it.)<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. I would hope that you could downcast a concrete lens:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let lens: () -&gt; inout Int = &amp;array.count					// Assuming this is a &quot;get lens” syntax<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the syntax was actually a little bit different as the lens isn’t bound to the instance and a readonly lens wouldn’t return inout:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let lens: (Array&lt;MyType&gt;) -&gt; Int = &amp;array.count<br>&gt;&gt; <br>&gt;&gt; I envision there being both bound lenses (sorry, I forgot that `Array.count` isn&#39;t mutating):<br>&gt;&gt; <br>&gt;&gt; 	struct Person { var name: String }<br>&gt;&gt; 	var joe = Person(name: &quot;Joe&quot;)<br>&gt;&gt; 	<br>&gt;&gt; 	let lens: () -&gt; inout String =  &amp;joe.name<br>&gt;&gt; <br>&gt;&gt; And unbound ones:<br>&gt;&gt; <br>&gt;&gt; 	let unboundLens: (inout Person) -&gt; inout String = Person.name<br>&gt;&gt; <br>&gt;&gt; `properties` on an instance would give you bound lenses; `properties` on a type would give you unbound ones. (Or maybe the latter would be something like `instanceProperties`, since type instances have properties too.)<br>&gt;&gt; <br>&gt;&gt; On the other hand, the idea of bound lenses might not be coherent; the `inout` parameter of an unbound lens helps make sure that mutation affects value-typed instances, so bound lenses might not work. Perhaps `properties` on an instance should be more akin to a `[String: Any]` dictionary, so that `joe.properties[&quot;name&quot;] = &quot;Bob&quot;` naturally calls `joe`&#39;s `properties` setter. The problem I see there is that the `openas` might open things too far: If the property is declared to be of protocol type, `openas` would end up giving you the concrete type of its current value instead.<br>&gt; <br>&gt; In this case, I wonder if it would be less confusing if bound lenses are available only on reference types, or existential with a class bound.<br></p><p>It could be very useful be able to pass a lens bound to a value type as a nonescaping argument.  The implementation would have to guarantee the bound lens can’t escape the effective scope of the value.  I don’t know how practical the implementation of that would be though.  It might require linear types along the lines of Rust in which case they would have to wait at least until Swift has such a system.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; And that you could later open the abstracted lens to get its concrete type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let concreteLens = abstractLens openas Lens {<br>&gt;&gt;&gt;&gt; 		print(Lens.ReturnValue)<br>&gt;&gt;&gt;&gt; 		…<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about casting like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let typedLens = abstractLens as? (Array&lt;MyType&gt;) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; If you&#39;re specifically expecting an `Int`, sure. But if you have no idea what the type is and want to find out, I think you&#39;d need to (somehow) open the Any lens and see the concrete return type inside.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/d6d0b182/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 28, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 9:57 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;m not sure how this alternative is related to access control.  Austin&#39;s proposal could enforce access control in the same way and he mentioned he was inclined to enforce it the same way you are describing.<br>&gt;&gt; <br>&gt;&gt; The reason I say it is tricky is because enforcing access control in this way would prevent things people want to do with reflection (things that have received a lot of discussion recently).  Allowing a distinct visibility to be specified for reflection might be a way to strike a reasonable balance.<br>&gt; <br>&gt; It&#39;s related to access control because it&#39;s specifically intended that you can pass your `properties` dictionary to other code to delegate your access. This works around the &quot;but other code needs to see your private stuff&quot; problem: it *can* see your private stuff, but only if you permit it.<br>&gt; <br>&gt; I suppose we would want a `#properties` you could use in a protocol conformance which would mean &quot;the properties visible at the conformance site&quot;:<br>&gt; <br>&gt; 	protocol Serializable {<br>&gt; 		var propertiesToSerialize: PropertyView&lt;Self&gt; { get set }<br>&gt; 		init(forDeserialization: ())<br>&gt; 	}<br>&gt; 	extension Serializable {<br>&gt; 		var propertiesToSerialize: PropertyView&lt;Self&gt; {<br>&gt; 			get { return #properties }<br>&gt; 			set { #properties = newValue }<br>&gt; 		}<br>&gt; <br>&gt; 		func serializedData() -&gt; Data {<br>&gt; 			return Serializer().serialize(self)<br>&gt; 		}<br>&gt; 		factory init(serializedData data: Data) {<br>&gt; 			self = Serializer.deserialize(data, of: Self.self)<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt;&gt; Your suggested approach doesn&#39;t allow for access to property metadata.  Do you have any suggestions on how that would be exposed?  <br>&gt; <br>&gt; I&#39;m not sure how much metadata is necessary beyond name (in the key) and type (discussed soon).<br>&gt; <br>&gt;&gt; What about casting the lens to a typed lens?  Would you envision that being supported?<br>&gt; <br>&gt; Yes. I would hope that you could downcast a concrete lens:<br>&gt; <br>&gt; 	let lens: () -&gt; inout Int = &amp;array.count					// Assuming this is a &quot;get lens&quot; syntax<br>&gt; 	let abstractLens = lens as () throws(set) -&gt; inout Any		// Upcasting an inout-returning function adds `throws(set)`<br>&gt; <br>&gt; And that you could later open the abstracted lens to get its concrete type:<br>&gt; <br>&gt; 	if let concreteLens = abstractLens openas Lens {<br>&gt; 		print(Lens.ReturnValue)<br>&gt; 		…<br>&gt; 	}<br></p><p><br>wonder what that means... if I recall, the idea of openas is that one knows the &#39;contained type&#39;, not that it is some kind of reflection that lets you discover it at runtime, right?! <br></p><p><br>&gt; <br>&gt; This is a slightly different form of existential opening, and `ReturnValue` doesn&#39;t currently exist on function types, but I hope these things would be possible.	<br>&gt; <br>&gt;&gt; I also think we would want a way to access a specific property by name if accessing the whole properties dictionary involved any non-trivial overhead (but maybe it wouldn&#39;t have to).<br>&gt; <br>&gt; That&#39;s why I said &quot;like a dictionary&quot;. :^) If there&#39;s a way to access individual keys without collecting them all ahead of time, or to generate lenses as needed, I&#39;m all for it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 26, 2016 at 07:00:00pm</p></header><div class="content"><p>This is important and really useful. There&#39;s a lot to like here. I have<br>been thinking about property reflection recently too. Don&#39;t have time to<br>write too much on it now, but was wondering what was the thinking behind<br>suggesting an opt-in? For me, I would hope that getting access to a<br>single property object that holds the getter and setter functions would<br>be almost as simple as the way we obtain a function reference for a method<br>(by naming the item in code) and would hope that it would work for all<br>types.<br></p><p>-- Callionica<br></p><p>On Thursday, May 26, 2016, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi swift-evolution,<br>&gt;<br>&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for<br>&gt; reflection upon a type&#39;s properties and solicit feedback.<br>&gt;<br>&gt; First of all, some caveats: this is only a very small piece of what<br>&gt; reflection in Swift might look like one day, and it&#39;s certainly not the<br>&gt; only possible design for such a feature. Reflection comes in many different<br>&gt; forms, and &quot;no reflection&quot; is also an option. Deciding what sort of<br>&gt; reflection capabilities Swift should support is a prerequisite to<br>&gt; stabilizing the runtime API, which I imagine has resilience consequences.<br>&gt; I&#39;m not really interested in *defending* this specific proposal per se,<br>&gt; as I am looking for a jumping-off point to explore designs in this space.<br>&gt;<br>&gt; Anyways, here is a gist outlining the public API to the feature:<br>&gt;<br>&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br>&gt;<br>&gt; A couple of notes regarding the proposal:<br>&gt;<br>&gt; The API names need improvement. Suggestions welcome.<br>&gt;<br>&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler<br>&gt; to generate whatever hooks, metadata, and support code is necessary. Once a<br>&gt; type conforms, the interface to the reflection features naturally present<br>&gt; themselves as protocol methods. It would be great to allow an extension to<br>&gt; retroactively enable reflection on a type vended by another module,<br>&gt; although I have no idea how feasible that is.<br>&gt;<br>&gt; It uses &quot;views&quot;: there are four types of views, two of each in the<br>&gt; following categories: typed vs untyped, get-only versus get-set. A view is<br>&gt; a struct representing a property on an instance of a type (or maybe a<br>&gt; metatype, for type properties). It allows you to get information about that<br>&gt; property (like its name) and try getting and setting its values.<br>&gt;<br>&gt; (You can get a get-only view to a property, and then try and upgrade it<br>&gt; later to a get-set view, if the underlying property is get-set. If you<br>&gt; don&#39;t care about setting, though, you can just work exclusively with<br>&gt; get-only views.)<br>&gt;<br>&gt; It supports both typed and untyped access. You can ask for a property view<br>&gt; specifically for (e.g.) a `String` property, and if you get one you can be<br>&gt; assured that your getting and setting operations will be type safe. You can<br>&gt; also ask for an &quot;untyped&quot; property view that exposes the value as an Any,<br>&gt; and allows you to try (and possibly fail, with a thrown error) to set the<br>&gt; value.<br>&gt;<br>&gt; The requirements part of it is composable. For example, you can imagine a<br>&gt; future &quot;FullyReflectable&quot; protocol that simply inherits from<br>&gt; &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable<br>&gt; protocols. Or maybe a library requires reflection access to types that it<br>&gt; needs to work with, and it can create its own protocols that inherit from<br>&gt; &quot;PropertyReflectable&quot; and naturally enforce reflection support on the<br>&gt; necessary types.<br>&gt;<br>&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t<br>&gt; necessarily see all the types, though, and the interface is pretty<br>&gt; straightforward:<br>&gt;<br>&gt; ```<br>&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;<br>&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt; ```<br>&gt;<br>&gt; I&#39;m not yet sure how it should interact with access control (my<br>&gt; inclination is that it would only expose the properties you&#39;d be able to<br>&gt; directly access), or property behaviors (I think get-set behavior is<br>&gt; fundamental to properties, although &quot;behavior metadata&quot; on the views might<br>&gt; be useful).<br>&gt;<br>&gt; I&#39;d also have to figure out how it would operate with generic types or<br>&gt; existentials.<br>&gt;<br>&gt; Anyways, thanks for reading all the way to the end, and any feedback,<br>&gt; criticism, or alternative proposals would be greatly appreciated.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/507c142b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Thank you! If you have other ideas I&#39;d love to hear them, even if they&#39;re<br>completely different. I think this is a topic that deserves to &#39;simmer&#39; for<br>a while.<br></p><p>You bring up an important point: should reflection be opt-in or opt-out?<br>I&#39;ve seen arguments for both options, and I think it&#39;s definitely a point<br>that needs to be very carefully discussed. Importantly, opt-out makes this<br>a sort-of-zero cost abstraction; only types that need the functionality<br>take the performance and metadata size hit. This is something that the core<br>team seems to find important.<br></p><p>If it is opt-in, though, there are certainly a bunch of framework base<br>types that should be opted-in, so that all their subclasses can be<br>reflected upon, providing most of the practical benefits of default opt-in.<br>Giving UIView and NSView this functionality would be a starting point, and<br>*maybe* NSObject (although that would have effects upon all of Swift<br>Foundation).<br></p><p>Best,<br>Austin<br></p><p><br>On Thu, May 26, 2016 at 7:42 PM, Callionica (Swift) &lt;<br>swift-callionica at callionica.com&gt; wrote:<br></p><p>&gt; This is important and really useful. There&#39;s a lot to like here. I have<br>&gt; been thinking about property reflection recently too. Don&#39;t have time to<br>&gt; write too much on it now, but was wondering what was the thinking behind<br>&gt; suggesting an opt-in? For me, I would hope that getting access to a<br>&gt; single property object that holds the getter and setter functions would<br>&gt; be almost as simple as the way we obtain a function reference for a method<br>&gt; (by naming the item in code) and would hope that it would work for all<br>&gt; types.<br>&gt;<br>&gt; -- Callionica<br>&gt;<br>&gt; On Thursday, May 26, 2016, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt;<br>&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for<br>&gt;&gt; reflection upon a type&#39;s properties and solicit feedback.<br>&gt;&gt;<br>&gt;&gt; First of all, some caveats: this is only a very small piece of what<br>&gt;&gt; reflection in Swift might look like one day, and it&#39;s certainly not the<br>&gt;&gt; only possible design for such a feature. Reflection comes in many different<br>&gt;&gt; forms, and &quot;no reflection&quot; is also an option. Deciding what sort of<br>&gt;&gt; reflection capabilities Swift should support is a prerequisite to<br>&gt;&gt; stabilizing the runtime API, which I imagine has resilience consequences.<br>&gt;&gt; I&#39;m not really interested in *defending* this specific proposal per se,<br>&gt;&gt; as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;<br>&gt;&gt; Anyways, here is a gist outlining the public API to the feature:<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br>&gt;&gt;<br>&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;<br>&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;<br>&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler<br>&gt;&gt; to generate whatever hooks, metadata, and support code is necessary. Once a<br>&gt;&gt; type conforms, the interface to the reflection features naturally present<br>&gt;&gt; themselves as protocol methods. It would be great to allow an extension to<br>&gt;&gt; retroactively enable reflection on a type vended by another module,<br>&gt;&gt; although I have no idea how feasible that is.<br>&gt;&gt;<br>&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the<br>&gt;&gt; following categories: typed vs untyped, get-only versus get-set. A view is<br>&gt;&gt; a struct representing a property on an instance of a type (or maybe a<br>&gt;&gt; metatype, for type properties). It allows you to get information about that<br>&gt;&gt; property (like its name) and try getting and setting its values.<br>&gt;&gt;<br>&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it<br>&gt;&gt; later to a get-set view, if the underlying property is get-set. If you<br>&gt;&gt; don&#39;t care about setting, though, you can just work exclusively with<br>&gt;&gt; get-only views.)<br>&gt;&gt;<br>&gt;&gt; It supports both typed and untyped access. You can ask for a property<br>&gt;&gt; view specifically for (e.g.) a `String` property, and if you get one you<br>&gt;&gt; can be assured that your getting and setting operations will be type safe.<br>&gt;&gt; You can also ask for an &quot;untyped&quot; property view that exposes the value as<br>&gt;&gt; an Any, and allows you to try (and possibly fail, with a thrown error) to<br>&gt;&gt; set the value.<br>&gt;&gt;<br>&gt;&gt; The requirements part of it is composable. For example, you can imagine a<br>&gt;&gt; future &quot;FullyReflectable&quot; protocol that simply inherits from<br>&gt;&gt; &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable<br>&gt;&gt; protocols. Or maybe a library requires reflection access to types that it<br>&gt;&gt; needs to work with, and it can create its own protocols that inherit from<br>&gt;&gt; &quot;PropertyReflectable&quot; and naturally enforce reflection support on the<br>&gt;&gt; necessary types.<br>&gt;&gt;<br>&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t<br>&gt;&gt; necessarily see all the types, though, and the interface is pretty<br>&gt;&gt; straightforward:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;<br>&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; I&#39;m not yet sure how it should interact with access control (my<br>&gt;&gt; inclination is that it would only expose the properties you&#39;d be able to<br>&gt;&gt; directly access), or property behaviors (I think get-set behavior is<br>&gt;&gt; fundamental to properties, although &quot;behavior metadata&quot; on the views might<br>&gt;&gt; be useful).<br>&gt;&gt;<br>&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or<br>&gt;&gt; existentials.<br>&gt;&gt;<br>&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback,<br>&gt;&gt; criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/9e8f4775/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>It might be good to learn from the mistakes java made with its reflection API because it might help avoid facing the impedence mismatch java faced a couple years ago when they tried to model the language on top of reflection. <br>The point is I think that starting in a small corner and trying to walk your way up is like the quantum mechanical way of trying to capture a lion (put the cage on the table and wait for the lion to show up inside), which in this case means do something somewhere, repeat, and hope it collectively makes sense when it&#39;s all done.<br>IMO the design does not emerge spontaneously from the syntax, it is the syntax that is created because it serves some higher order principles.<br></p><p>&gt; On May 27, 2016, at 3:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift-evolution,<br>&gt; <br>&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt; <br>&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt; <br>&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt; <br>&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br>&gt; <br>&gt; A couple of notes regarding the proposal:<br>&gt; <br>&gt; The API names need improvement. Suggestions welcome.<br>&gt; <br>&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt; <br>&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt; <br>&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt; <br>&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt; <br>&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt; <br>&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt; <br>&gt; ```<br>&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt; <br>&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt; ```<br>&gt; <br>&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt; <br>&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt; <br>&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/e930da02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>You made me think about JNI and now I am sad... You monster :P.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 27 May 2016, at 08:54, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It might be good to learn from the mistakes java made with its reflection API because it might help avoid facing the impedence mismatch java faced a couple years ago when they tried to model the language on top of reflection. <br>&gt; The point is I think that starting in a small corner and trying to walk your way up is like the quantum mechanical way of trying to capture a lion (put the cage on the table and wait for the lion to show up inside), which in this case means do something somewhere, repeat, and hope it collectively makes sense when it&#39;s all done.<br>&gt; IMO the design does not emerge spontaneously from the syntax, it is the syntax that is created because it serves some higher order principles.<br>&gt; <br>&gt;&gt; On May 27, 2016, at 3:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt; <br>&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt; <br>&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt; <br>&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br>&gt;&gt; <br>&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt; <br>&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt; <br>&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt; <br>&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt; <br>&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt; <br>&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt; <br>&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt; <br>&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt; <br>&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt; <br>&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt; <br>&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/d5142aa5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 01:00:00am</p></header><div class="content"><p>(inline)<br></p><p>&gt; On May 27, 2016, at 12:54 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; It might be good to learn from the mistakes java made with its reflection API because it might help avoid facing the impedence mismatch java faced a couple years ago when they tried to model the language on top of reflection. <br></p><p>Of course. What might those mistakes be? It would be interesting to see how the relatively limited expressivity of Java informed the design of its reflection APIs (which are very different from those of Objective-C as far as I know).<br></p><p>&gt; The point is I think that starting in a small corner and trying to walk your way up is like the quantum mechanical way of trying to capture a lion (put the cage on the table and wait for the lion to show up inside), which in this case means do something somewhere, repeat, and hope it collectively makes sense when it&#39;s all done.<br></p><p>There is an overarching (albeit vague) design I have in mind, of which this is one piece. I wanted to gather some preliminary feedback to see whether or not this was something worth pursuing further. Should I share the overarching design instead?<br></p><p>&gt; IMO the design does not emerge spontaneously from the syntax, it is the syntax that is created because it serves some higher order principles.<br>&gt; <br>&gt; On May 27, 2016, at 3:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt; <br>&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt; <br>&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt; <br>&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt; <br>&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt; <br>&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt; <br>&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt; <br>&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt; <br>&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt; <br>&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt; <br>&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt; <br>&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt; <br>&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt; <br>&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt; <br>&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/53c57bea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>When compared to the java language itself, the reflection API was close-enough but lossy. So when it came time to implement javax.lang.model over reflection there were naturally gaps (similar notions were wrongly viewed as different problems). Narrowed down and translated back to swift, a lesson might be that any solution that does not present some clean symmetry in its treatment of nominal vs structural types might be a non-starter (you can read the compiler source code to see an example of how far they have been able to maintain some symmetry between them).<br></p><p>just a thought.<br></p><p>&gt; On May 27, 2016, at 10:31 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; (inline)<br>&gt; <br>&gt;&gt; On May 27, 2016, at 12:54 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It might be good to learn from the mistakes java made with its reflection API because it might help avoid facing the impedence mismatch java faced a couple years ago when they tried to model the language on top of reflection. <br>&gt; <br>&gt; Of course. What might those mistakes be? It would be interesting to see how the relatively limited expressivity of Java informed the design of its reflection APIs (which are very different from those of Objective-C as far as I know).<br>&gt; <br>&gt;&gt; The point is I think that starting in a small corner and trying to walk your way up is like the quantum mechanical way of trying to capture a lion (put the cage on the table and wait for the lion to show up inside), which in this case means do something somewhere, repeat, and hope it collectively makes sense when it&#39;s all done.<br>&gt; <br>&gt; There is an overarching (albeit vague) design I have in mind, of which this is one piece. I wanted to gather some preliminary feedback to see whether or not this was something worth pursuing further. Should I share the overarching design instead?<br>&gt; <br>&gt;&gt; IMO the design does not emerge spontaneously from the syntax, it is the syntax that is created because it serves some higher order principles.<br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 3:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/a190d346/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/426fbd3d9b662663dc5647b08c4e3410?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Anders Ha</string> &lt;hello at andersio.co&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>I wonder how the views would work with the value semantic of structs.<br></p><p>The view types proposed, if not being a compiler magic, would need to have a reference to the reflected instance. They are also escapable unless special rules for the view types are enforced. So… perhaps we would want less magic  and special rules?<br></p><p>IMO these views are not necessary, and can be consolidated into typed/untyped get/set calls on `Reflectable`. However, if the intention is to amortize the type metadata lookup, or not to introduce any kind of lookup caching in the runtime, perhaps we can introduce instead property descriptors.<br></p><p>(A quick dump of my idea: https://gist.github.com/andersio/9ff02257b5c89b35fd523dcd09e484e4)<br></p><p>Best Regards<br>Anders<br></p><p><br>&gt; On 27 May 2016, at 9:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift-evolution,<br>&gt; <br>&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt; <br>&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt; <br>&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt; <br>&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt; <br>&gt; A couple of notes regarding the proposal:<br>&gt; <br>&gt; The API names need improvement. Suggestions welcome.<br>&gt; <br>&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt; <br>&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt; <br>&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt; <br>&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt; <br>&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt; <br>&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt; <br>&gt; ```<br>&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt; <br>&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt; ```<br>&gt; <br>&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt; <br>&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt; <br>&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/0562dc9c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 5:45 AM, Anders Ha via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wonder how the views would work with the value semantic of structs.<br></p><p>Not all value types have value semantics.  It&#39;s important to not forget that.  I would like to see a way to make that distinction clear in our code but that is a conversation for another thread.<br></p><p>&gt; <br>&gt; The view types proposed, if not being a compiler magic, would need to have a reference to the reflected instance. They are also escapable unless special rules for the view types are enforced. So… perhaps we would want less magic  and special rules?<br>&gt; <br>&gt; IMO these views are not necessary, and can be consolidated into typed/untyped get/set calls on `Reflectable`. However, if the intention is to amortize the type metadata lookup, or not to introduce any kind of lookup caching in the runtime, perhaps we can introduce instead property descriptors.<br>&gt; <br>&gt; (A quick dump of my idea:<br>&gt; https://gist.github.com/andersio/9ff02257b5c89b35fd523dcd09e484e4)<br></p><p>Property descriptors could be useful in the sense that they wouldn&#39;t need to refer back to the instance.  But I would also like to see a way to get something like a lens into the property for a specific instance which is what the views allow for.  This design doesn&#39;t allow for that.  Maybe we want to allow you to query for property descriptors alone, lenses alone, or the combination in a view.<br></p><p>&gt; <br>&gt; <br>&gt; Best Regards<br>&gt; Anders<br>&gt; <br>&gt; <br>&gt;&gt; On 27 May 2016, at 9:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt; <br>&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt; <br>&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt; <br>&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br>&gt;&gt; <br>&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt; <br>&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt; <br>&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt; <br>&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt; <br>&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt; <br>&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt; <br>&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt; <br>&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt; <br>&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt; <br>&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt; <br>&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/898841e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 28, 2016 at 12:00:00am</p></header><div class="content"><p>Here’s an idea using enums. They work similar to a lens, where they are separate from the actual instance. So you can convert string keys or validate potential values without needing an instance.<br></p><p>The PropertyIdentifierProtocol is implemented by an string representable enum, piggy backing on its failable initializer for converting from strings.<br>The PropertyStateProtocol, implemented by an enum with associated values, encapsulates a property in a type-safe manner, allowing it to be extracted as an entity then applied to other instances. It has a failable initializer for validating a value.<br></p><p>https://gist.github.com/BurntCaramel/315ee4dfca0c240755b534e1a5ee183f<br></p><p><br>&gt; On 27 May 2016, at 11:30 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Property descriptors could be useful in the sense that they wouldn&#39;t need to refer back to the instance.  But I would also like to see a way to get something like a lens into the property for a specific instance which is what the views allow for.  This design doesn&#39;t allow for that.  Maybe we want to allow you to query for property descriptors alone, lenses alone, or the combination in a view.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/c215f357/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/426fbd3d9b662663dc5647b08c4e3410?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Anders Ha</string> &lt;hello at andersio.co&gt;<p>May 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 27 May 2016, at 9:30 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 27, 2016, at 5:45 AM, Anders Ha via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I wonder how the views would work with the value semantic of structs.<br>&gt; <br>&gt; Not all value types have value semantics.  It&#39;s important to not forget that.  I would like to see a way to make that distinction clear in our code but that is a conversation for another thread.<br></p><p>I meant value types. Thanks for pointing out that. :-)<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; The view types proposed, if not being a compiler magic, would need to have a reference to the reflected instance. They are also escapable unless special rules for the view types are enforced. So… perhaps we would want less magic  and special rules?<br>&gt;&gt; <br>&gt;&gt; IMO these views are not necessary, and can be consolidated into typed/untyped get/set calls on `Reflectable`. However, if the intention is to amortize the type metadata lookup, or not to introduce any kind of lookup caching in the runtime, perhaps we can introduce instead property descriptors.<br>&gt;&gt; <br>&gt;&gt; (A quick dump of my idea:<br>&gt;&gt; https://gist.github.com/andersio/9ff02257b5c89b35fd523dcd09e484e4 &lt;https://gist.github.com/andersio/9ff02257b5c89b35fd523dcd09e484e4&gt;)<br>&gt; <br>&gt; Property descriptors could be useful in the sense that they wouldn&#39;t need to refer back to the instance.  But I would also like to see a way to get something like a lens into the property for a specific instance which is what the views allow for.  This design doesn&#39;t allow for that.  Maybe we want to allow you to query for property descriptors alone, lenses alone, or the combination in a view.<br>&gt; <br></p><p>Just for the record, I was meaning that the user can request a typed descriptor of a particular named instance properties (and even class properties) at runtime from the metatype. Users may then use these typed descriptors to query or modify the value from a specific instance.<br></p><p>It is like KVC, but uses typed descriptors instead of string keypaths.<br></p><p>Anyway, the most important message I&#39;d like to raise is that the mutation should be acted upon the owner of the property, if the reflection is supposed to cover also value types.<br></p><p>Specifically using Zheng’s initial idea as an example, the setter in “GetSetPropertyView” of a property in a struct instance should not cause any change to the original instance by the established behaviour of value types in Swift.<br></p><p>Let’s say even If there are some kind of pointer magic bypassing the value type restrictions at runtime, GetSetPropertyView cannot be escaped but only useable in the local scope. Otherwise, we would have a view that can somehow point to nothing. This doesn’t sound great either way.<br></p><p><br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Best Regards<br>&gt;&gt; Anders<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 9:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/b30de06f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 9:22 AM, Anders Ha &lt;hello at andersio.co&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 27 May 2016, at 9:30 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 5:45 AM, Anders Ha via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I wonder how the views would work with the value semantic of structs.<br>&gt;&gt; <br>&gt;&gt; Not all value types have value semantics.  It&#39;s important to not forget that.  I would like to see a way to make that distinction clear in our code but that is a conversation for another thread.<br>&gt; <br>&gt; I meant value types. Thanks for pointing out that. :-)<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The view types proposed, if not being a compiler magic, would need to have a reference to the reflected instance. They are also escapable unless special rules for the view types are enforced. So… perhaps we would want less magic  and special rules?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO these views are not necessary, and can be consolidated into typed/untyped get/set calls on `Reflectable`. However, if the intention is to amortize the type metadata lookup, or not to introduce any kind of lookup caching in the runtime, perhaps we can introduce instead property descriptors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (A quick dump of my idea:<br>&gt;&gt;&gt; https://gist.github.com/andersio/9ff02257b5c89b35fd523dcd09e484e4 &lt;https://gist.github.com/andersio/9ff02257b5c89b35fd523dcd09e484e4&gt;)<br>&gt;&gt; <br>&gt;&gt; Property descriptors could be useful in the sense that they wouldn&#39;t need to refer back to the instance.  But I would also like to see a way to get something like a lens into the property for a specific instance which is what the views allow for.  This design doesn&#39;t allow for that.  Maybe we want to allow you to query for property descriptors alone, lenses alone, or the combination in a view.<br>&gt;&gt; <br>&gt; <br>&gt; Just for the record, I was meaning that the user can request a typed descriptor of a particular named instance properties (and even class properties) at runtime from the metatype. Users may then use these typed descriptors to query or modify the value from a specific instance.<br>&gt; <br>&gt; It is like KVC, but uses typed descriptors instead of string key paths.<br></p><p>I understand this.  But this is not like a lens.  It is much more awkward to use.<br></p><p>&gt; <br>&gt; Anyway, the most important message I&#39;d like to raise is that the mutation should be acted upon the owner of the property, if the reflection is supposed to cover also value types.<br>&gt; <br>&gt; Specifically using Zheng’s initial idea as an example, the setter in “GetSetPropertyView” of a property in a struct instance should not cause any change to the original instance by the established behaviour of value types in Swift.<br>&gt; <br>&gt; Let’s say even If there are some kind of pointer magic bypassing the value type restrictions at runtime, GetSetPropertyView cannot be escaped but only useable in the local scope. Otherwise, we would have a view that can somehow point to nothing. This doesn’t sound great either way.<br>&gt; <br></p><p>You raise good points here.  I am interested to hear what Joe Groff has to say about this.  I believe the issues involved are the same as those involved with lenses into value types.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best Regards<br>&gt;&gt;&gt; Anders<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 May 2016, at 9:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/5da7adba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/426fbd3d9b662663dc5647b08c4e3410?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Anders Ha</string> &lt;hello at andersio.co&gt;<p>May 27, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 27 May 2016, at 10:43 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 27, 2016, at 9:22 AM, Anders Ha &lt;hello at andersio.co &lt;mailto:hello at andersio.co&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 27 May 2016, at 9:30 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 5:45 AM, Anders Ha via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder how the views would work with the value semantic of structs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not all value types have value semantics.  It&#39;s important to not forget that.  I would like to see a way to make that distinction clear in our code but that is a conversation for another thread.<br>&gt;&gt; <br>&gt;&gt; I meant value types. Thanks for pointing out that. :-)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The view types proposed, if not being a compiler magic, would need to have a reference to the reflected instance. They are also escapable unless special rules for the view types are enforced. So… perhaps we would want less magic  and special rules?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO these views are not necessary, and can be consolidated into typed/untyped get/set calls on `Reflectable`. However, if the intention is to amortize the type metadata lookup, or not to introduce any kind of lookup caching in the runtime, perhaps we can introduce instead property descriptors.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (A quick dump of my idea:<br>&gt;&gt;&gt;&gt; https://gist.github.com/andersio/9ff02257b5c89b35fd523dcd09e484e4 &lt;https://gist.github.com/andersio/9ff02257b5c89b35fd523dcd09e484e4&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Property descriptors could be useful in the sense that they wouldn&#39;t need to refer back to the instance.  But I would also like to see a way to get something like a lens into the property for a specific instance which is what the views allow for.  This design doesn&#39;t allow for that.  Maybe we want to allow you to query for property descriptors alone, lenses alone, or the combination in a view.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Just for the record, I was meaning that the user can request a typed descriptor of a particular named instance properties (and even class properties) at runtime from the metatype. Users may then use these typed descriptors to query or modify the value from a specific instance.<br>&gt;&gt; <br>&gt;&gt; It is like KVC, but uses typed descriptors instead of string key paths.<br>&gt; <br>&gt; I understand this.  But this is not like a lens.  It is much more awkward to use.<br></p><p>I agree it is awkward. It is just a quick dump anyway. :)<br></p><p>Expanding on Groff’s idea of a `T -&gt; inout U`-ish lens, perhaps the reflection API can reside in the metatype, and create lenses (with runtime type checking) instead? It would end up similarly to Zheng’s initial idea. But unlike Zheng’s view types, lenses would not capture but expects an instance as its input.<br></p><p>By the way, a read-write lens should be conceptually `inout T -&gt; inout U` to cover also the value types. But then it would prevent it to be used with constant references (e.g. `self` in instance methods). New compiler magics can be engineered to tackle this though, or a distinction between a read-write lens for value type and reference type has to be made.<br></p><p><br>-<br>Note:<br>[swift-evolution] Proposal: Expose getter/setters in the same way	as regular methods<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; Anyway, the most important message I&#39;d like to raise is that the mutation should be acted upon the owner of the property, if the reflection is supposed to cover also value types.<br>&gt;&gt; <br>&gt;&gt; Specifically using Zheng’s initial idea as an example, the setter in “GetSetPropertyView” of a property in a struct instance should not cause any change to the original instance by the established behaviour of value types in Swift.<br>&gt;&gt; <br>&gt;&gt; Let’s say even If there are some kind of pointer magic bypassing the value type restrictions at runtime, GetSetPropertyView cannot be escaped but only useable in the local scope. Otherwise, we would have a view that can somehow point to nothing. This doesn’t sound great either way.<br>&gt;&gt; <br>&gt; <br>&gt; You raise good points here.  I am interested to hear what Joe Groff has to say about this.  I believe the issues involved are the same as those involved with lenses into value types.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best Regards<br>&gt;&gt;&gt;&gt; Anders<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 May 2016, at 9:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/9164a3fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>Oh, this is really interesting. The idea being that you get an object representing a property like &quot;age&quot; based on a metatype (like &quot;Person.type&quot;), and then you pass in instances of the type to methods on that object to manipulate that property. That is definitely less stateful and less prone to strange issues like mutating a value type beneath its view.<br></p><p>&gt; On May 27, 2016, at 8:53 AM, Anders Ha &lt;hello at andersio.co&gt; wrote:<br>&gt; <br>&gt; I agree it is awkward. It is just a quick dump anyway. :)<br>&gt; <br>&gt; Expanding on Groff’s idea of a `T -&gt; inout U`-ish lens, perhaps the reflection API can reside in the metatype, and create lenses (with runtime type checking) instead? It would end up similarly to Zheng’s initial idea. But unlike Zheng’s view types, lenses would not capture but expects an instance as its input.<br>&gt; <br>&gt; By the way, a read-write lens should be conceptually `inout T -&gt; inout U` to cover also the value types. But then it would prevent it to be used with constant references (e.g. `self` in instance methods). New compiler magics can be engineered to tackle this though, or a distinction between a read-write lens for value type and reference type has to be made.<br>&gt; <br>&gt; <br>&gt; -<br>&gt; Note:<br>&gt; [swift-evolution] Proposal: Expose getter/setters in the same way	as regular methods<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html&gt;<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, the most important message I&#39;d like to raise is that the mutation should be acted upon the owner of the property, if the reflection is supposed to cover also value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Specifically using Zheng’s initial idea as an example, the setter in “GetSetPropertyView” of a property in a struct instance should not cause any change to the original instance by the established behaviour of value types in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s say even If there are some kind of pointer magic bypassing the value type restrictions at runtime, GetSetPropertyView cannot be escaped but only useable in the local scope. Otherwise, we would have a view that can somehow point to nothing. This doesn’t sound great either way.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You raise good points here.  I am interested to hear what Joe Groff has to say about this.  I believe the issues involved are the same as those involved with lenses into value types.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Best Regards<br>&gt;&gt;&gt;&gt;&gt; Anders<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 27 May 2016, at 9:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/cd60785a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 27, 2016, at 11:26 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Oh, this is really interesting. The idea being that you get an object representing a property like &quot;age&quot; based on a metatype (like &quot;Person.type&quot;), and then you pass in instances of the type to methods on that object to manipulate that property. That is definitely less stateful and less prone to strange issues like mutating a value type beneath its view.<br></p><p>Yep, this is why I was suggesting we look at lenses as an important part of the design.  I couldn&#39;t remember the details but knew it would impact the design direction.  Now I remember why!  :-)<br></p><p>Thanks for digging up Joe&#39;s post Anders.<br></p><p>&gt; <br>&gt;&gt; On May 27, 2016, at 8:53 AM, Anders Ha &lt;hello at andersio.co&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree it is awkward. It is just a quick dump anyway. :)<br>&gt;&gt; <br>&gt;&gt; Expanding on Groff’s idea of a `T -&gt; inout U`-ish lens, perhaps the reflection API can reside in the metatype, and create lenses (with runtime type checking) instead? It would end up similarly to Zheng’s initial idea. But unlike Zheng’s view types, lenses would not capture but expects an instance as its input.<br>&gt;&gt; <br>&gt;&gt; By the way, a read-write lens should be conceptually `inout T -&gt; inout U` to cover also the value types. But then it would prevent it to be used with constant references (e.g. `self` in instance methods). New compiler magics can be engineered to tackle this though, or a distinction between a read-write lens for value type and reference type has to be made.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -<br>&gt;&gt; Note:<br>&gt;&gt; [swift-evolution] Proposal: Expose getter/setters in the same way	as regular methods<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003008.html<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyway, the most important message I&#39;d like to raise is that the mutation should be acted upon the owner of the property, if the reflection is supposed to cover also value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Specifically using Zheng’s initial idea as an example, the setter in “GetSetPropertyView” of a property in a struct instance should not cause any change to the original instance by the established behaviour of value types in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s say even If there are some kind of pointer magic bypassing the value type restrictions at runtime, GetSetPropertyView cannot be escaped but only useable in the local scope. Otherwise, we would have a view that can somehow point to nothing. This doesn’t sound great either way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You raise good points here.  I am interested to hear what Joe Groff has to say about this.  I believe the issues involved are the same as those involved with lenses into value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Best Regards<br>&gt;&gt;&gt;&gt;&gt;&gt; Anders<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 27 May 2016, at 9:25 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/eb94ada1/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>I think this proposal should “simmer&quot; until we know what property behaviors will look like (or find out they are never happening, etc.). <br></p><p>The interaction with “property behaviors” seems likely to be quite subtle, even for something simple like `lazy`.<br></p><p>For sake of argument, let’s say that a `lazy` declaration like so:<br></p><p>  class SomeClass { <br>    lazy var foo: Foo = Foo(bar: self.prepareBar())<br>  }<br></p><p>…gets implicitly-expanded into e.g. something like the below:<br></p><p>  class SomeClass {<br> <br>    var foo: Foo {<br>      guard let foo = _foo else {<br>        _foo = Foo(bar: self.prepareBar())<br>        return _foo<br>      }<br>      return foo<br>    }<br></p><p>    private var _foo: Foo? = nil<br></p><p>  }<br></p><p>…which immediately exposes a few lazy-specific questions:<br></p><p>- should `foo` be exposed via reflection? (IMHO: yes)<br>- should `_foo` be exposed via reflection? (IMHO: probably not, but not certain)<br>- should `foo`’s lazy-ness be exposable? (IMHO: yes, but how exactly?)<br></p><p>…as well as a few more-general questions:<br></p><p>- should computed properties, in general, be exposed to reflection? (IMHO: probably not, but there are some exceptions…)<br>- if user-specified property behaviors get special exposure, how should that work?<br>- how should reflection work for enums/enums-with-payloads? <br></p><p>Finally, I worry a lot less about the details of getter/setter pairs than I worry about being able to use reflection for construction/initialization.<br></p><p>I don’t have any actual proposal on that front, but it seems like it should be factored into any reflection design.<br></p><p>&gt; On May 26, 2016, at 8:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift-evolution,<br>&gt; <br>&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt; <br>&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt; <br>&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt; <br>&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt; <br>&gt; A couple of notes regarding the proposal:<br>&gt; <br>&gt; The API names need improvement. Suggestions welcome.<br>&gt; <br>&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt; <br>&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt; <br>&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt; <br>&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt; <br>&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt; <br>&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt; <br>&gt; ```<br>&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt; <br>&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt; ```<br>&gt; <br>&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt; <br>&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt; <br>&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/9ac82f99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>I think there is a consensus forming that we probably don&#39;t yet know enough about Swift&#39;s future capabilities to nail down specific designs yet. (Not that I want to stop people from talking about them if they wish.)<br></p><p>However, now that there is a conversation topic about reflection, I also wanted to ask the following questions:<br></p><p>1. What sorts of features are important, and what would you use them for?<br></p><p>For me, the list looks like the following:<br></p><p>- Describe the structure of a type. (We have that right now, with introspection using &quot;Mirror&quot;.)<br></p><p>- Find all the properties on a type. Get and set their values, and get information about them (like their dynamic type).<br>- Find all the methods on a type. Be able to get a reference to and invoke a method on an instance of a type.<br>- Find all the subscripts and initializers on a type?<br></p><p>- Get a list of all concrete types opting in to extended reflection.<br>- Get a list of all concrete types visible to the caller that conform to some protocol(s), possibly with additional requirements on associated types.<br>- Get a list of all protocols.<br></p><p>- Create a reference to a type using a string, and perform certain actions using that type. (It would be interesting if you could say &quot;try parsing this type into a concrete type that conforms to X, Y, and Z protocols&quot;, and if successful you get a metatype to use or something you can pass to a generic function.<br>- Create a reference to a method or property using a string, and use it as above.<br></p><p>- Reify methods and properties marked with the &#39;dynamic&#39; keyword in such a way that where they are dispatched to can be controlled at runtime. For example, maybe a dynamic method of a class might use some default implementation, or if some condition is met forward invocations of it to a dynamic method on another class instead.<br></p><p>2. What sorts of priorities should inform Swift&#39;s reflection capabilities?<br></p><p>For me, the option to perform both &quot;statically typed&quot; and runtime type checked operations, when feasible, is a big one. I think something like variadic generics could allow for typesafe reflection on methods and functions at runtime - rather than having to call a performSelector: like method, it would be possible to get a full-fledged value of function type and use it just like any other method. This is something few languages have AFAIK.<br></p><p>The reflection machinery should cooperate with the rest of the language. If there must be a way to, for example, access private members of an instance through reflection, it should not be unconditional and should be carefully considered such that there are certain invariants that are still honored. Like Laurent said earlier, bad things can happen if you use reflection to subvert access control.<br></p><p>I think reflection should be opt-in in most cases. Reflection opting-in should be composable, inheritable, and retroactive, which covers the most common cases in which reflection would be useful: working with Cocoa/Cocoa Touch, for example.<br></p><p>Best,<br>Austin<br></p><p><br></p><p>&gt; On May 27, 2016, at 7:37 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this proposal should “simmer&quot; until we know what property behaviors will look like (or find out they are never happening, etc.). <br>&gt; <br>&gt; The interaction with “property behaviors” seems likely to be quite subtle, even for something simple like `lazy`.<br>&gt; <br>&gt; For sake of argument, let’s say that a `lazy` declaration like so:<br>&gt; <br>&gt;   class SomeClass { <br>&gt;     lazy var foo: Foo = Foo(bar: self.prepareBar())<br>&gt;   }<br>&gt; <br>&gt; …gets implicitly-expanded into e.g. something like the below:<br>&gt; <br>&gt;   class SomeClass {<br>&gt;  <br>&gt;     var foo: Foo {<br>&gt;       guard let foo = _foo else {<br>&gt;         _foo = Foo(bar: self.prepareBar())<br>&gt;         return _foo<br>&gt;       }<br>&gt;       return foo<br>&gt;     }<br>&gt; <br>&gt;     private var _foo: Foo? = nil<br>&gt; <br>&gt;   }<br>&gt; <br>&gt; …which immediately exposes a few lazy-specific questions:<br>&gt; <br>&gt; - should `foo` be exposed via reflection? (IMHO: yes)<br>&gt; - should `_foo` be exposed via reflection? (IMHO: probably not, but not certain)<br>&gt; - should `foo`’s lazy-ness be exposable? (IMHO: yes, but how exactly?)<br>&gt; <br>&gt; …as well as a few more-general questions:<br>&gt; <br>&gt; - should computed properties, in general, be exposed to reflection? (IMHO: probably not, but there are some exceptions…)<br>&gt; - if user-specified property behaviors get special exposure, how should that work?<br>&gt; - how should reflection work for enums/enums-with-payloads? <br>&gt; <br>&gt; Finally, I worry a lot less about the details of getter/setter pairs than I worry about being able to use reflection for construction/initialization.<br>&gt; <br>&gt; I don’t have any actual proposal on that front, but it seems like it should be factored into any reflection design.<br>&gt; <br>&gt;&gt; On May 26, 2016, at 8:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt; <br>&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt; <br>&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt; <br>&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt; <br>&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt; <br>&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt; <br>&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt; <br>&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt; <br>&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt; <br>&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt; <br>&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt; <br>&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt; <br>&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt; <br>&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt; <br>&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/37b748af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 11:54 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think there is a consensus forming that we probably don&#39;t yet know enough about Swift&#39;s future capabilities to nail down specific designs yet. (Not that I want to stop people from talking about them if they wish.)<br>&gt; <br>&gt; However, now that there is a conversation topic about reflection, I also wanted to ask the following questions:<br>&gt; <br>&gt; 1. What sorts of features are important, and what would you use them for?<br>&gt; <br>&gt; For me, the list looks like the following:<br>&gt; <br>&gt; - Describe the structure of a type. (We have that right now, with introspection using &quot;Mirror&quot;.)<br>&gt; <br>&gt; - Find all the properties on a type. Get and set their values, and get information about them (like their dynamic type).<br>&gt; - Find all the methods on a type. Be able to get a reference to and invoke a method on an instance of a type.<br>&gt; - Find all the subscripts and initializers on a type?<br>&gt; <br>&gt; - Get a list of all concrete types opting in to extended reflection.<br>&gt; - Get a list of all concrete types visible to the caller that conform to some protocol(s), possibly with additional requirements on associated types.<br>&gt; - Get a list of all protocols.<br>&gt; <br>&gt; - Create a reference to a type using a string, and perform certain actions using that type. (It would be interesting if you could say &quot;try parsing this type into a concrete type that conforms to X, Y, and Z protocols&quot;, and if successful you get a metatype to use or something you can pass to a generic function.<br>&gt; - Create a reference to a method or property using a string, and use it as above.<br>&gt; <br>&gt; - Reify methods and properties marked with the &#39;dynamic&#39; keyword in such a way that where they are dispatched to can be controlled at runtime. For example, maybe a dynamic method of a class might use some default implementation, or if some condition is met forward invocations of it to a dynamic method on another class instead.<br>&gt; <br>&gt; 2. What sorts of priorities should inform Swift&#39;s reflection capabilities?<br>&gt; <br>&gt; For me, the option to perform both &quot;statically typed&quot; and runtime type checked operations, when feasible, is a big one. I think something like variadic generics could allow for typesafe reflection on methods and functions at runtime - rather than having to call a performSelector: like method, it would be possible to get a full-fledged value of function type and use it just like any other method. This is something few languages have AFAIK.<br>&gt; <br>&gt; The reflection machinery should cooperate with the rest of the language. If there must be a way to, for example, access private members of an instance through reflection, it should not be unconditional and should be carefully considered such that there are certain invariants that are still honored. Like Laurent said earlier, bad things can happen if you use reflection to subvert access control.<br>&gt; <br>&gt; I think reflection should be opt-in in most cases. Reflection opting-in should be composable, inheritable, and retroactive, which covers the most common cases in which reflection would be useful: working with Cocoa/Cocoa Touch, for example.<br></p><p>One priority you don’t mention here that I think is worthwhile to consider is static reflection.  Any features that make sense both statically and dynamically should have the same API statically and dynamically wherever possible.  <br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 7:37 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think this proposal should “simmer&quot; until we know what property behaviors will look like (or find out they are never happening, etc.). <br>&gt;&gt; <br>&gt;&gt; The interaction with “property behaviors” seems likely to be quite subtle, even for something simple like `lazy`.<br>&gt;&gt; <br>&gt;&gt; For sake of argument, let’s say that a `lazy` declaration like so:<br>&gt;&gt; <br>&gt;&gt;   class SomeClass { <br>&gt;&gt;     lazy var foo: Foo = Foo(bar: self.prepareBar())<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …gets implicitly-expanded into e.g. something like the below:<br>&gt;&gt; <br>&gt;&gt;   class SomeClass {<br>&gt;&gt;  <br>&gt;&gt;     var foo: Foo {<br>&gt;&gt;       guard let foo = _foo else {<br>&gt;&gt;         _foo = Foo(bar: self.prepareBar())<br>&gt;&gt;         return _foo<br>&gt;&gt;       }<br>&gt;&gt;       return foo<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     private var _foo: Foo? = nil<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …which immediately exposes a few lazy-specific questions:<br>&gt;&gt; <br>&gt;&gt; - should `foo` be exposed via reflection? (IMHO: yes)<br>&gt;&gt; - should `_foo` be exposed via reflection? (IMHO: probably not, but not certain)<br>&gt;&gt; - should `foo`’s lazy-ness be exposable? (IMHO: yes, but how exactly?)<br>&gt;&gt; <br>&gt;&gt; …as well as a few more-general questions:<br>&gt;&gt; <br>&gt;&gt; - should computed properties, in general, be exposed to reflection? (IMHO: probably not, but there are some exceptions…)<br>&gt;&gt; - if user-specified property behaviors get special exposure, how should that work?<br>&gt;&gt; - how should reflection work for enums/enums-with-payloads? <br>&gt;&gt; <br>&gt;&gt; Finally, I worry a lot less about the details of getter/setter pairs than I worry about being able to use reflection for construction/initialization.<br>&gt;&gt; <br>&gt;&gt; I don’t have any actual proposal on that front, but it seems like it should be factored into any reflection design.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 8:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/a73d1f67/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 29, 2016 at 11:00:00am</p></header><div class="content"><p>This is a good list of goals. A few quick comments:<br></p><p>I feel like a fundamental question that can be “added” to almost all of these is “how do modules appear for reflection?”<br></p><p>EG, for one such example, “Find all the methods on a type”:<br>- can you ask for only methods defined in its “home module” <br>- can you ask for only methods defined on it in some specific module<br>- if you ask for all of them, can you tell which methods come from which modules<br></p><p>…and relatedly you get into e.g. “if you do a method lookup by name, how do you disambiguate same-name methods defined in extensions from different modules”.<br></p><p>I don’t think it’s necessary to keep listing such possible questions, as the general thrust should be clear; any answer is probably going to be dependent on the final ABI/resiliency implementation and on how (if?) modules themselves become visible in the runtime (e.g. do they have a type/representation / etc., or not?).<br></p><p>I have a pretty specific motivating case that makes me concerned about these issues; I’ll detail it a bit in hopes it can get added to the “is this proposal reasonably feature-complete” consideration.<br></p><p>Something I would *like* to be able to do with the reflection system is do a reflection-based, fully-generic “custom-view configuration-experiment UI”; e.g. if you could write this:<br></p><p>  protocol ConfigurableUIComponent : AnyObject {  <br>    associatedtype Configuration // perhaps: `:MutableReflectable` or similar?<br>    init()<br>    var configuration: Configuration { get set }<br>  }<br></p><p>…and then be able to write something like this:<br></p><p>  class ConfigurationExperimentationViewController&lt;<br>    K<br>    where<br>    K:UIView, <br>    K:ConfigurableUIComponent&gt; : UIViewController {<br></p><p>  // sets up a K() and installs that view into `self.view`<br>  // sets up a reflection-derived UI for manipulating K’s `configuration`,<br>  // e.g. an embedded table view with controls for each appropriate field in `K.Configuration`<br></p><p>}<br></p><p>…reasonably-straightforwardly in Swift, ideally without needing to e.g. add custom annotations / additional conformances to get a reasonable outcome (at least for many cases).<br></p><p>Although I’m pretty sure any reasonable read/write reflection system will suffice for the &quot;easy scenarios”, there’s a lot of room for nuance / complication due to the presence of e.g. calculated properties, etc., and it’d be nice if the reflection system provided enough information to make reasonable decisions in such cases without requiring too much user support (from e.g. custom annotations, (etc.)). <br></p><p>Given the early state of the discussion hashing it out in detail now doesn’t seem necessary, but I hope concrete scenarios like the above can be kept under consideration as the design work continues.<br></p><p>&gt; On May 27, 2016, at 11:54 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think there is a consensus forming that we probably don&#39;t yet know enough about Swift&#39;s future capabilities to nail down specific designs yet. (Not that I want to stop people from talking about them if they wish.)<br>&gt; <br>&gt; However, now that there is a conversation topic about reflection, I also wanted to ask the following questions:<br>&gt; <br>&gt; 1. What sorts of features are important, and what would you use them for?<br>&gt; <br>&gt; For me, the list looks like the following:<br>&gt; <br>&gt; - Describe the structure of a type. (We have that right now, with introspection using &quot;Mirror&quot;.)<br>&gt; <br>&gt; - Find all the properties on a type. Get and set their values, and get information about them (like their dynamic type).<br>&gt; - Find all the methods on a type. Be able to get a reference to and invoke a method on an instance of a type.<br>&gt; - Find all the subscripts and initializers on a type?<br>&gt; <br>&gt; - Get a list of all concrete types opting in to extended reflection.<br>&gt; - Get a list of all concrete types visible to the caller that conform to some protocol(s), possibly with additional requirements on associated types.<br>&gt; - Get a list of all protocols.<br>&gt; <br>&gt; - Create a reference to a type using a string, and perform certain actions using that type. (It would be interesting if you could say &quot;try parsing this type into a concrete type that conforms to X, Y, and Z protocols&quot;, and if successful you get a metatype to use or something you can pass to a generic function.<br>&gt; - Create a reference to a method or property using a string, and use it as above.<br>&gt; <br>&gt; - Reify methods and properties marked with the &#39;dynamic&#39; keyword in such a way that where they are dispatched to can be controlled at runtime. For example, maybe a dynamic method of a class might use some default implementation, or if some condition is met forward invocations of it to a dynamic method on another class instead.<br>&gt; <br>&gt; 2. What sorts of priorities should inform Swift&#39;s reflection capabilities?<br>&gt; <br>&gt; For me, the option to perform both &quot;statically typed&quot; and runtime type checked operations, when feasible, is a big one. I think something like variadic generics could allow for typesafe reflection on methods and functions at runtime - rather than having to call a performSelector: like method, it would be possible to get a full-fledged value of function type and use it just like any other method. This is something few languages have AFAIK.<br>&gt; <br>&gt; The reflection machinery should cooperate with the rest of the language. If there must be a way to, for example, access private members of an instance through reflection, it should not be unconditional and should be carefully considered such that there are certain invariants that are still honored. Like Laurent said earlier, bad things can happen if you use reflection to subvert access control.<br>&gt; <br>&gt; I think reflection should be opt-in in most cases. Reflection opting-in should be composable, inheritable, and retroactive, which covers the most common cases in which reflection would be useful: working with Cocoa/Cocoa Touch, for example.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 7:37 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think this proposal should “simmer&quot; until we know what property behaviors will look like (or find out they are never happening, etc.). <br>&gt;&gt; <br>&gt;&gt; The interaction with “property behaviors” seems likely to be quite subtle, even for something simple like `lazy`.<br>&gt;&gt; <br>&gt;&gt; For sake of argument, let’s say that a `lazy` declaration like so:<br>&gt;&gt; <br>&gt;&gt;   class SomeClass { <br>&gt;&gt;     lazy var foo: Foo = Foo(bar: self.prepareBar())<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …gets implicitly-expanded into e.g. something like the below:<br>&gt;&gt; <br>&gt;&gt;   class SomeClass {<br>&gt;&gt;  <br>&gt;&gt;     var foo: Foo {<br>&gt;&gt;       guard let foo = _foo else {<br>&gt;&gt;         _foo = Foo(bar: self.prepareBar())<br>&gt;&gt;         return _foo<br>&gt;&gt;       }<br>&gt;&gt;       return foo<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     private var _foo: Foo? = nil<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …which immediately exposes a few lazy-specific questions:<br>&gt;&gt; <br>&gt;&gt; - should `foo` be exposed via reflection? (IMHO: yes)<br>&gt;&gt; - should `_foo` be exposed via reflection? (IMHO: probably not, but not certain)<br>&gt;&gt; - should `foo`’s lazy-ness be exposable? (IMHO: yes, but how exactly?)<br>&gt;&gt; <br>&gt;&gt; …as well as a few more-general questions:<br>&gt;&gt; <br>&gt;&gt; - should computed properties, in general, be exposed to reflection? (IMHO: probably not, but there are some exceptions…)<br>&gt;&gt; - if user-specified property behaviors get special exposure, how should that work?<br>&gt;&gt; - how should reflection work for enums/enums-with-payloads? <br>&gt;&gt; <br>&gt;&gt; Finally, I worry a lot less about the details of getter/setter pairs than I worry about being able to use reflection for construction/initialization.<br>&gt;&gt; <br>&gt;&gt; I don’t have any actual proposal on that front, but it seems like it should be factored into any reflection design.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 8:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For those who are interested I&#39;d like to present a pre-pre-proposal for reflection upon a type&#39;s properties and solicit feedback. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First of all, some caveats: this is only a very small piece of what reflection in Swift might look like one day, and it&#39;s certainly not the only possible design for such a feature. Reflection comes in many different forms, and &quot;no reflection&quot; is also an option. Deciding what sort of reflection capabilities Swift should support is a prerequisite to stabilizing the runtime API, which I imagine has resilience consequences. I&#39;m not really interested in defending this specific proposal per se, as I am looking for a jumping-off point to explore designs in this space.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, here is a gist outlining the public API to the feature: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a &lt;https://gist.github.com/austinzheng/699d47f50899b88645f56964c0b7109a&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A couple of notes regarding the proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The API names need improvement. Suggestions welcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s opt-in: types have to conform to a special protocol for the compiler to generate whatever hooks, metadata, and support code is necessary. Once a type conforms, the interface to the reflection features naturally present themselves as protocol methods. It would be great to allow an extension to retroactively enable reflection on a type vended by another module, although I have no idea how feasible that is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It uses &quot;views&quot;: there are four types of views, two of each in the following categories: typed vs untyped, get-only versus get-set. A view is a struct representing a property on an instance of a type (or maybe a metatype, for type properties). It allows you to get information about that property (like its name) and try getting and setting its values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (You can get a get-only view to a property, and then try and upgrade it later to a get-set view, if the underlying property is get-set. If you don&#39;t care about setting, though, you can just work exclusively with get-only views.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It supports both typed and untyped access. You can ask for a property view specifically for (e.g.) a `String` property, and if you get one you can be assured that your getting and setting operations will be type safe. You can also ask for an &quot;untyped&quot; property view that exposes the value as an Any, and allows you to try (and possibly fail, with a thrown error) to set the value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The requirements part of it is composable. For example, you can imagine a future &quot;FullyReflectable&quot; protocol that simply inherits from &quot;PropertyReflectable&quot;, &quot;MethodReflectable&quot;, and other reflectable protocols. Or maybe a library requires reflection access to types that it needs to work with, and it can create its own protocols that inherit from &quot;PropertyReflectable&quot; and naturally enforce reflection support on the necessary types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks a bit cumbersome, but there&#39;s room for refinement. Users won&#39;t necessarily see all the types, though, and the interface is pretty straightforward:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not yet sure how it should interact with access control (my inclination is that it would only expose the properties you&#39;d be able to directly access), or property behaviors (I think get-set behavior is fundamental to properties, although &quot;behavior metadata&quot; on the views might be useful).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also have to figure out how it would operate with generic types or existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyways, thanks for reading all the way to the end, and any feedback, criticism, or alternative proposals would be greatly appreciated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/f1a3b4ad/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 27, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 26, 2016, at 9:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ```<br>&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt; <br>&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt; ```<br>&gt; <br></p><p>Can you elaborate on what this API would be used for?  KVC? For instance, I played with Mirror the other day and my code to get a value given the property name looked more like this:<br></p><p>let age = myPerson.value(forKey:”age”) as! Int<br></p><p>And this is what I did:<br></p><p>// KVC stands for key-value-coding… but I only know how to get values.  I don’t know how to set values<br></p><p>protocol KVC {<br>   func value(forKey key: String) -&gt; Any!<br>}<br></p><p>// Default implementation<br>extension KVC {<br>   func value(forKey key: String) -&gt; Any! {<br>       let aMirror = Mirror(reflecting:self)<br>       for case let (label?, value) in aMirror.children {<br>           if label == key {<br>               return value<br>           }<br>       }<br>       return nil<br>   }<br>}<br></p><p>public struct Person : KVC {<br>   let firstName: String<br>   let lastName: String<br>   let age: Int<br></p><p>   func fullName() -&gt; String {<br>       return &quot;\(firstName) \(lastName)&quot;<br>   }<br>}<br></p><p>let aPerson = Person(firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:48)<br></p><p>// It works for stored properties<br>let lastName = aPerson.value(forKey:&quot;lastName&quot;) as! String<br>print(&quot;Last name is \(lastName)&quot;)<br></p><p>// It does not work for instance methods, i.e. fullName is not a stored property<br>let fullName = aPerson.value(forKey:&quot;fullName&quot;)<br>if fullName != nil {<br>   print(&quot;Full name is \(fullName)&quot;)<br>} else {<br>   print(&quot;Unable to get fullName via KVC&quot;)<br>}<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/6fdd9ed7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 27, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, it was pretty much meant as a KVC-like feature for Swift. Get a<br>reference to a property from a string which would allow you to get and set<br>its value.<br></p><p>On Fri, May 27, 2016 at 11:53 AM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br></p><p>&gt;<br>&gt; On May 26, 2016, at 9:25 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; ```<br>&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;<br>&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; Can you elaborate on what this API would be used for?  KVC? For instance,<br>&gt; I played with Mirror the other day and my code to get a value given the<br>&gt; property name looked more like this:<br>&gt;<br>&gt; let age = myPerson.value(forKey:”age”) as! Int<br>&gt;<br>&gt; And this is what I did:<br>&gt;<br>&gt; // KVC stands for key-value-coding… but I only know how to get values.  I<br>&gt; don’t know how to set values<br>&gt;<br>&gt; protocol KVC {<br>&gt;    func value(forKey key: String) -&gt; Any!<br>&gt; }<br>&gt;<br>&gt; // Default implementation<br>&gt; extension KVC {<br>&gt;    func value(forKey key: String) -&gt; Any! {<br>&gt;        let aMirror = Mirror(reflecting:self)<br>&gt;        for case let (label?, value) in aMirror.children {<br>&gt;            if label == key {<br>&gt;                return value<br>&gt;            }<br>&gt;        }<br>&gt;        return nil<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; public struct Person : KVC {<br>&gt;    let firstName: String<br>&gt;    let lastName: String<br>&gt;    let age: Int<br>&gt;<br>&gt;    func fullName() -&gt; String {<br>&gt;        return &quot;\(firstName) \(lastName)&quot;<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; let aPerson = Person(firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:48)<br>&gt;<br>&gt; // It works for stored properties<br>&gt; let lastName = aPerson.value(forKey:&quot;lastName&quot;) as! String<br>&gt; print(&quot;Last name is \(lastName)&quot;)<br>&gt;<br>&gt; // It does not work for instance methods, i.e. fullName is not a stored<br>&gt; property<br>&gt; let fullName = aPerson.value(forKey:&quot;fullName&quot;)<br>&gt; if fullName != nil {<br>&gt;    print(&quot;Full name is \(fullName)&quot;)<br>&gt; } else {<br>&gt;    print(&quot;Unable to get fullName via KVC&quot;)<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/74813347/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Pitch] Property reflection</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Would it let me get a property if it does not correspond to a property, or computed property? <br></p><p>For example, would I be able to get the value returned by a fullName() instance method that concatenates the firstName and lastName properties together and returns the result? Or would it only work if fullName were implemented as a computed property as opposed to an instance method? <br></p><p>Thanks<br></p><p><br></p><p>&gt; On May 27, 2016, at 2:59 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes, it was pretty much meant as a KVC-like feature for Swift. Get a reference to a property from a string which would allow you to get and set its value.<br>&gt; <br>&gt;&gt; On Fri, May 27, 2016 at 11:53 AM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 26, 2016, at 9:25 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; myPerson.typedReadWriteProperty&lt;Int&gt;(&quot;age&quot;)?.set(30)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try myPerson.allNamedProperties[&quot;age&quot;]?.set(30)<br>&gt;&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Can you elaborate on what this API would be used for?  KVC? For instance, I played with Mirror the other day and my code to get a value given the property name looked more like this:<br>&gt;&gt; <br>&gt;&gt; let age = myPerson.value(forKey:”age”) as! Int<br>&gt;&gt; <br>&gt;&gt; And this is what I did:<br>&gt;&gt; <br>&gt;&gt; // KVC stands for key-value-coding… but I only know how to get values.  I don’t know how to set values<br>&gt;&gt; <br>&gt;&gt; protocol KVC {<br>&gt;&gt;    func value(forKey key: String) -&gt; Any!<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Default implementation<br>&gt;&gt; extension KVC {<br>&gt;&gt;    func value(forKey key: String) -&gt; Any! {<br>&gt;&gt;        let aMirror = Mirror(reflecting:self)<br>&gt;&gt;        for case let (label?, value) in aMirror.children {<br>&gt;&gt;            if label == key {<br>&gt;&gt;                return value<br>&gt;&gt;            }<br>&gt;&gt;        }<br>&gt;&gt;        return nil<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct Person : KVC {<br>&gt;&gt;    let firstName: String<br>&gt;&gt;    let lastName: String<br>&gt;&gt;    let age: Int<br>&gt;&gt; <br>&gt;&gt;    func fullName() -&gt; String {<br>&gt;&gt;        return &quot;\(firstName) \(lastName)&quot;<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let aPerson = Person(firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:48)<br>&gt;&gt; <br>&gt;&gt; // It works for stored properties<br>&gt;&gt; let lastName = aPerson.value(forKey:&quot;lastName&quot;) as! String<br>&gt;&gt; print(&quot;Last name is \(lastName)&quot;)<br>&gt;&gt; <br>&gt;&gt; // It does not work for instance methods, i.e. fullName is not a stored property<br>&gt;&gt; let fullName = aPerson.value(forKey:&quot;fullName&quot;)<br>&gt;&gt; if fullName != nil {<br>&gt;&gt;    print(&quot;Full name is \(fullName)&quot;)<br>&gt;&gt; } else {<br>&gt;&gt;    print(&quot;Unable to get fullName via KVC&quot;)<br>&gt;&gt; }<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/11c118ef/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
