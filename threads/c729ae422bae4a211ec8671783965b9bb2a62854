<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 12:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of “ Tuple comparison operators” begins now and runs through Tuesday, December 22. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>	Cheers,<br>	Dave Abrahams<br>	Review Manager<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/c7292854/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>[Review] Add a Lazy flatMap for Sequences of Optionals</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>The title of this email seems a little off, it does not match the enclosed proposal, but responded to the proposal enclosed which is the Tuple comparison proposal. <br></p><p>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>It does seem like a good interim solution until a more general approach can be made that supports N-arity. <br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. It is not great that these are not easily compared. <br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. <br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Nothing that would influence this. <br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the proposal. <br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; 	Cheers,<br>&gt; 	Dave Abrahams<br>&gt; 	Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/e23bee0f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: open.gif<br>Type: image/gif<br>Size: 43 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/e23bee0f/attachment.gif&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0015 Tuple comparison operators (was Re: [Review] Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>This is the Swift-Evolution equivalent of &quot;The proposal was on display in the bottom of a locked filing cabinet stuck in a disused lavatory with a sign on the door saying ‘Beware of the Leopard.&#39;&quot;<br></p><p>-- Erica<br></p><p><br>&gt; On Dec 21, 2015, at 2:30 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The title of this email seems a little off, it does not match the enclosed proposal, but responded to the proposal enclosed which is the Tuple comparison proposal. <br>&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; It does seem like a good interim solution until a more general approach can be made that supports N-arity. <br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes. It is not great that these are not easily compared. <br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes. <br>&gt; <br>&gt;&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Nothing that would influence this. <br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I read the proposal. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; <br>&gt;&gt; 	Cheers,<br>&gt;&gt; 	Dave Abrahams<br>&gt;&gt; 	Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &lt;open.gif&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/efe5a55d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 1:30 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; The title of this email seems a little off, it does not match the enclosed proposal, but responded to the proposal enclosed which is the Tuple comparison proposal. <br></p><p>Yes, you&#39;re quite right, though &quot;a little&quot; is a very generous understatement.  My apologies to all.  Please fix the subject line in your replies if possible.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>Already replied directly with the wrong subject but to keep the vote tally straight: +1.<br></p><p>-- E<br></p><p>&gt; On Dec 22, 2015, at 12:12 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 1:30 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The title of this email seems a little off, it does not match the enclosed proposal, but responded to the proposal enclosed which is the Tuple comparison proposal. <br>&gt; <br>&gt; Yes, you&#39;re quite right, though &quot;a little&quot; is a very generous understatement.  My apologies to all.  Please fix the subject line in your replies if possible.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>I wholeheartedly support the Equatable (==) portion of this proposal.<br>I’m quite negative about the Comparable portion; it doesn’t really make sense.<br></p><p>The justification for making Tuples comparable pretty much consists of hand-waving.<br>Why should (0,3,4) be smaller than (0,5,0)? Beats me.<br>Why would it be the other way around? Also beats me.<br></p><p>I can vaguely see the utility of Comparable when I squint, but the actual behaviour would require extensive documentation with caveats about it not really making any sense. To overload an operator with a clear meaning with a behaviour with a wishy-washy definition is a bad idea.<br></p><p><br>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes for Equatable.<br>No for Comparable.<br></p><p><br>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes for Equatable.<br>No for Comparable.<br></p><p><br>* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have used Mathematics during an extensive education in Physics and Engineering, at the end of which I escaped with a Ph.D. from a major institution.<br></p><p>Making arbitrary Tuples Equatable when possible makes sense.<br>Making them Comparable absolutely does not.<br></p><p>Comparability is domain-specific. The standard library cannot know what an arbitrary Tuple means.<br></p><p><br>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I drew upon my experience. While I feel it’s on solid footing, I would hesitate to call it an in-depth study.<br></p><p><br>Finally, I would like to note that I would support a free-standing function with a clear name that does the same thing as the proposed overloads of the comparison operator.<br></p><p>Sincerely,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>On Tue, Dec 22, 2015, at 10:39 AM, Guillaume Lessard via swift-evolution wrote:<br>&gt; I wholeheartedly support the Equatable (==) portion of this proposal.<br>&gt; I’m quite negative about the Comparable portion; it doesn’t really make sense.<br>&gt; <br>&gt; The justification for making Tuples comparable pretty much consists of hand-waving.<br>&gt; Why should (0,3,4) be smaller than (0,5,0)? Beats me.<br>&gt; Why would it be the other way around? Also beats me.<br></p><p>You&#39;re proposing that there isn&#39;t a clear reason for it to behave the way it is, but you haven&#39;t given any justification for this claim. I say there is in fact a clear reason, and that reason is that lexicographical order is a pretty common assumption.<br></p><p>&gt; I can vaguely see the utility of Comparable when I squint, but the actual behaviour would require extensive documentation with caveats about it not really making any sense. To overload an operator with a clear meaning with a behaviour with a wishy-washy definition is a bad idea.<br></p><p>It makes sense in any situation where lexicographical comparisons is appropriate, which I would wager covers most of the times where tuple comparisons in general make sense. Not only that, but providing an easy way to invoke lexicographical comparison using tuples allows people to invoke this behavior easily on arbitrary data when they need it.<br></p><p>It was mentioned in the old proposal thread that providing an equality operator on tuples makes it easy to implement equality on structs by just comparing tuples constructed from the struct fields. Comparison operators have the same benefit. For example:<br></p><p>struct Version: Comparable {<br>    let major: Int<br>    let minor: Int<br>    let patch: Int<br>}<br></p><p>func ==(lhs: Version, rhs: Version) -&gt; Bool {<br>    return (lhs.major, lhs.minor, lhs.patch) == (rhs.major, rhs.minor, rhs.patch)<br>}<br></p><p>func &lt;(lhs: Version, rhs: Version) -&gt; Bool {<br>    return (lhs.major, lhs.minor, lhs.patch) &lt; (rhs.major, rhs.minor, rhs.patch)<br>}<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes for Equatable.<br>&gt; No for Comparable.<br>&gt; <br>&gt; <br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes for Equatable.<br>&gt; No for Comparable.<br>&gt; <br>&gt; <br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I have used Mathematics during an extensive education in Physics and Engineering, at the end of which I escaped with a Ph.D. from a major institution.<br>&gt; <br>&gt; Making arbitrary Tuples Equatable when possible makes sense.<br>&gt; Making them Comparable absolutely does not.<br>&gt; <br>&gt; Comparability is domain-specific. The standard library cannot know what an arbitrary Tuple means.<br></p><p>The standard library cannot know this for equality either. But you still think that makes sense. There&#39;s plenty of ways to construct tuples where the meaning of equality of the whole is different than the meaning of equality of parts. And if this distinction is important to capture, you&#39;re free to define a struct instead of using a tuple, as you can then provide whatever specific notion of equality (or comparability) you want.<br></p><p>I guess the overall question is, given that lexicographical ordering is a very common ordering, what harm is there in providing a lexicographical ordering operation on tuples? If it doesn&#39;t make sense for the tuple in question, then just don&#39;t try and compare it. Heck, we provide a comparison operator on strings even though the particular comparison it implements isn&#39;t always what you want (for example, it&#39;s case-sensitive and you may want case-insensitive comparison) but nobody is arguing that strings shouldn&#39;t be comparable.<br></p><p>-Kevin Ballard<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I drew upon my experience. While I feel it’s on solid footing, I would hesitate to call it an in-depth study.<br>&gt; <br>&gt; <br>&gt; Finally, I would like to note that I would support a free-standing function with a clear name that does the same thing as the proposed overloads of the comparison operator.<br>&gt; <br>&gt; Sincerely,<br>&gt; Guillaume Lessard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On 22 déc. 2015, at 14:03, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 22, 2015, at 10:39 AM, Guillaume Lessard via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; The justification for making Tuples comparable pretty much consists of hand-waving.<br>&gt;&gt; Why should (0,3,4) be smaller than (0,5,0)? Beats me.<br>&gt;&gt; Why would it be the other way around? Also beats me.<br>&gt; <br>&gt; You&#39;re proposing that there isn&#39;t a clear reason for it to behave the way it is, but you haven&#39;t given any justification for this claim.<br></p><p>My job here is to disprove, not to prove. I think that the proposed definition is lacking.<br></p><p><br>&gt; I say there is in fact a clear reason, and that reason is that lexicographical order is a pretty common assumption.<br></p><p>Is lexicographical order the same the world over? No! A “pretty common assumption” is a weak foundation.<br></p><p>As I said earlier: “Finally, I would like to note that I would support a free-standing function with a clear name that does the same thing as the proposed overloads of the comparison operator.”<br></p><p>In other words:<br>- Provide elementwiseComparison&lt;NTupleOfComparables&gt;(t1,t2).<br>- Don’t overload &lt;<br></p><p>The free-standing function provides all of the desired convenience, without messing with &lt;<br></p><p><br>&gt;&gt; Comparability is domain-specific. The standard library cannot know what an arbitrary Tuple means.<br>&gt; <br>&gt; The standard library cannot know this for equality either.<br></p><p>This proposal offers a simple *and strict* definition of Equality. (Is there a stricter definition that doesn’t devolve into identity?) Anyone who needs a looser definition can re-define it for their domain.<br></p><p>Comparability is a different beast. Comparability makes sense with scalars. With groups of values there is a required step to map the grouping onto a scalar score, be it magnitude (like vectors) or secret sauce (like Consumer Reports scores.)<br></p><p>(Note that I was quite deliberate in my choice of tuples (0,3,4) and (0,5,0). As vectors: same magnitude.)<br></p><p><br>&gt; Heck, we provide a comparison operator on strings even though the particular comparison it implements isn&#39;t always what you want (for example, it&#39;s case-sensitive and you may want case-insensitive comparison) but nobody is arguing that strings shouldn&#39;t be comparable.<br></p><p>I don&#39;t love using comparison operators on strings (gotchas abound), but at least the problem of alphabetizing words is taught in elementary schools. Not so for ordering arbitrary multidimensional data.<br></p><p>Sincerely,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 22, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 2:44 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 déc. 2015, at 14:03, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 22, 2015, at 10:39 AM, Guillaume Lessard via swift-evolution wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The justification for making Tuples comparable pretty much consists of hand-waving.<br>&gt;&gt;&gt; Why should (0,3,4) be smaller than (0,5,0)? Beats me.<br>&gt;&gt;&gt; Why would it be the other way around? Also beats me.<br>&gt;&gt; <br>&gt;&gt; You&#39;re proposing that there isn&#39;t a clear reason for it to behave the way it is, but you haven&#39;t given any justification for this claim.<br>&gt; <br>&gt; My job here is to disprove, not to prove. I think that the proposed definition is lacking.<br>&gt; <br>&gt; <br>&gt;&gt; I say there is in fact a clear reason, and that reason is that lexicographical order is a pretty common assumption.<br>&gt; <br>&gt; Is lexicographical order the same the world over? No!<br></p><p>Yes, the mathematical definition of lexicographical order (the only definition that can apply here) is the same everywhere.<br></p><p>&gt; A “pretty common assumption” is a weak foundation.<br>&gt; <br>&gt; As I said earlier: “Finally, I would like to note that I would support a free-standing function with a clear name that does the same thing as the proposed overloads of the comparison operator.”<br>&gt; <br>&gt; In other words:<br>&gt; - Provide elementwiseComparison&lt;NTupleOfComparables&gt;(t1,t2).<br>&gt; - Don’t overload &lt;<br>&gt; <br>&gt; The free-standing function provides all of the desired convenience, without messing with &lt;<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Comparability is domain-specific. The standard library cannot know what an arbitrary Tuple means.<br>&gt;&gt; <br>&gt;&gt; The standard library cannot know this for equality either.<br>&gt; <br>&gt; This proposal offers a simple *and strict* definition of Equality. (Is there a stricter definition that doesn’t devolve into identity?) Anyone who needs a looser definition can re-define it for their domain.<br>&gt; <br>&gt; Comparability is a different beast. Comparability makes sense with scalars. With groups of values there is a required step to map the grouping onto a scalar score, be it magnitude (like vectors) or secret sauce (like Consumer Reports scores.)<br>&gt; <br>&gt; (Note that I was quite deliberate in my choice of tuples (0,3,4) and (0,5,0). As vectors: same magnitude.)<br>&gt; <br>&gt; <br>&gt;&gt; Heck, we provide a comparison operator on strings even though the particular comparison it implements isn&#39;t always what you want (for example, it&#39;s case-sensitive and you may want case-insensitive comparison) but nobody is arguing that strings shouldn&#39;t be comparable.<br>&gt; <br>&gt; I don&#39;t love using comparison operators on strings (gotchas abound), but at least the problem of alphabetizing words is taught in elementary schools. Not so for ordering arbitrary multidimensional data.<br>&gt; <br>&gt; Sincerely,<br>&gt; Guillaume Lessard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On 22 déc. 2015, at 18:11, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; Yes, the mathematical definition of lexicographical order (the only definition that can apply here) is the same everywhere.<br></p><p>Okay. I got sidetracked by “lexicography”. I like to buy dictionaries.<br></p><p>This converges on the problem, though: this-precedes-that is *not* the same as this-is-less-than-that.<br>(Maybe we were talking about different things.)<br></p><p>Note the signature of sort:<br>func sort(isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T]<br></p><p>Not “lessThan”, but “isOrderedBefore”.<br></p><p>This proposal would redefine the less-than operator to mean “isOrderedBefore”.<br>It’s been done with String for the sake of convenience, but it should not be generalized.<br>(Again, a function isOrderedBefore&lt;NTupleOfComparables&gt;(t1,t2) would be useful.)<br></p><p>Note that there is a proper definition of less-than for vectors. (tuples being generalized vectors).<br>Under that definition, *every* element of vector 1 must be less-than the corresponding elements of vector 2 in order to establish that vector 1 is less-than vector 2.<br>Back to my example: ((0,3,4)&lt;(0,5,0)) is false and ((0,3,4)&gt;(0,5,0)) is false.<br>One may well be ordered before the other.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 6:28 PM, Guillaume Lessard &lt;glessard at tffenterprises.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 déc. 2015, at 18:11, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; Yes, the mathematical definition of lexicographical order (the only definition that can apply here) is the same everywhere.<br>&gt; <br>&gt; Okay. I got sidetracked by “lexicography”. I like to buy dictionaries.<br>&gt; <br>&gt; This converges on the problem, though: this-precedes-that is *not* the same as this-is-less-than-that.<br>&gt; (Maybe we were talking about different things.)<br>&gt; <br>&gt; Note the signature of sort:<br>&gt; func sort(isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T]<br>&gt; <br>&gt; Not “lessThan”, but “isOrderedBefore”.<br>&gt; <br>&gt; This proposal would redefine the less-than operator to mean “isOrderedBefore”.<br>&gt; It’s been done with String for the sake of convenience, but it should not be generalized.<br>&gt; (Again, a function isOrderedBefore&lt;NTupleOfComparables&gt;(t1,t2) would be useful.)<br></p><p>It’s very convenient for “&lt;“ to correspond to the standard strict-weak ordering for a type where possible.  <br></p><p>&gt; Note that there is a proper definition of less-than for vectors. (tuples being generalized vectors).<br>&gt; Under that definition, *every* element of vector 1 must be less-than the corresponding elements of vector 2 in order to establish that vector 1 is less-than vector 2.<br>&gt; Back to my example: ((0,3,4)&lt;(0,5,0)) is false and ((0,3,4)&gt;(0,5,0)) is false.<br></p><p>Tuples are not vectors.  If you want your vector type to have a different ordering semantics, just define a separate vector type.<br></p><p>&gt; One may well be ordered before the other.<br>&gt; <br>&gt; Cheers,<br>&gt; Guillaume Lessard<br>&gt; <br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On 22 déc. 2015, at 19:40, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; It’s very convenient for “&lt;“ to correspond to the standard strict-weak ordering for a type where possible.  <br></p><p>Convenient maybe. Is it advisable for a standard library feature? Doubtful.<br></p><p>This is about the definition of &lt;. It means “less than”.<br>This is why operator overloading has a bad reputation.<br></p><p>I don’t dispute the *usefulness* of the proposed feature; I dispute its proposed *name*.<br>Is ordering tuples needed so often that unclear nomenclature is advisable? No!<br></p><p>Back to fundamentals: (slightly paraphrased from api-design-guidelines)<br>- Clarity at the point of use is most important.<br>- Clarity is more important than brevity.<br>- Promote clear usage.<br></p><p>&lt; does *not* mean “is ordered before”.<br>&lt; does *not* have a clear meaning with composite data.<br></p><p>isOrderedBefore is a clear name.<br></p><p>I know that Comparable is documented with respect to sorting; it is unfortunate. Sortable would be a better name, given the way it is documented. Note that (apart from String) the concrete Comparables in the stdlib are numbers, stand-ins for numbers (index) or entities referenced by numbers (code points). String is the salient exception.<br></p><p>The proposed change would redefine &lt; and would be against convention.<br>Highly unclear.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>On Tue, Dec 22, 2015 at 8:13 PM, Guillaume Lessard via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On 22 déc. 2015, at 19:40, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It’s very convenient for “&lt;“ to correspond to the standard strict-weak ordering for a type where possible.<br>&gt;<br>&gt; Convenient maybe. Is it advisable for a standard library feature? Doubtful.<br>&gt;<br>&gt; This is about the definition of &lt;. It means “less than”.<br>&gt; This is why operator overloading has a bad reputation.<br>&gt;<br>&gt; I don’t dispute the *usefulness* of the proposed feature; I dispute its proposed *name*.<br>&gt; Is ordering tuples needed so often that unclear nomenclature is advisable? No!<br>&gt;<br>&gt; Back to fundamentals: (slightly paraphrased from api-design-guidelines)<br>&gt; - Clarity at the point of use is most important.<br>&gt; - Clarity is more important than brevity.<br>&gt; - Promote clear usage.<br>&gt;<br>&gt; &lt; does *not* mean “is ordered before”.<br></p><p>How is &quot;is ordered before&quot; different from &quot;less than&quot;?  Can x be &quot;less<br>than&quot; y and yet be ordered after it?  No.  Thus, there is no<br>possibility of confusion here.  Lexicographical order is the only<br>reasonable definition of comparison for tuples, one can&#39;t imagine a<br>different definition.<br></p><p>It is possible that a different type with the same shape as a tuple<br>(say, a Point3D composed of three floating point numbers) will choose<br>to use a different order, or not define one at all.  But that would be<br>a choice made by a type used for a specific domain, not a general<br>tuple type without any semantics attached.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>On Tue, Dec 22, 2015, at 08:13 PM, Guillaume Lessard via swift-evolution wrote:<br>&gt; <br>&gt; &gt; On 22 déc. 2015, at 19:40, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; It’s very convenient for “&lt;“ to correspond to the standard strict-weak ordering for a type where possible.  <br>&gt; <br>&gt; Convenient maybe. Is it advisable for a standard library feature? Doubtful.<br>&gt; <br>&gt; This is about the definition of &lt;. It means “less than”.<br>&gt; This is why operator overloading has a bad reputation.<br></p><p>Comparable (and therefore &lt;) in Swift is already defined as the strict total order (which is a strict-weak ordering). Granted, that&#39;s actually not true for the Comparable implementation of Float, Double, and CGFloat (NaN breaks this and turns it into a partial order), but it&#39;s a convenient fiction to ignore that (especially because NaN breaks so much of existing floating-point code that it doesn&#39;t really matter all that much that it breaks Comparable too).<br></p><p>Given that Comparable already must be a strict total order, it makes a lot of sense to provide Comparable for the standard strict-weak ordering (i.e. strict total order) for a type whenever we can.<br></p><p>I&#39;m still not sure what your actual fundamental objection here is, because the alternative is to not support Comparable at all for tuples, which doesn&#39;t help anybody.<br></p><p>&gt; I don’t dispute the *usefulness* of the proposed feature; I dispute its proposed *name*.<br>&gt; Is ordering tuples needed so often that unclear nomenclature is advisable? No!<br>&gt; <br>&gt; Back to fundamentals: (slightly paraphrased from api-design-guidelines)<br>&gt; - Clarity at the point of use is most important.<br>&gt; - Clarity is more important than brevity.<br>&gt; - Promote clear usage.<br>&gt; <br>&gt; &lt; does *not* mean “is ordered before”.<br></p><p>Well yeah, it does. That is its definition. It _also_ means &quot;is less than&quot; when used on real numbers, but the definition of &quot;is less than&quot; is equivalent to &quot;is ordered before&quot; given the standard ordering for real numbers. But for most things beyond real numbers, &quot;is less than&quot; is not necessarily well-defined, whereas &quot;is ordered before&quot; often is. For example, the string &quot;a&quot; is not considered to be &quot;less than&quot; the string &quot;b&quot;, but it is considered to be ordered before it.<br></p><p>&gt; &lt; does *not* have a clear meaning with composite data.<br>&gt; <br>&gt; isOrderedBefore is a clear name.<br></p><p>isOrderedBefore is exactly what the &lt; operator is.<br></p><p>&gt; I know that Comparable is documented with respect to sorting; it is unfortunate. Sortable would be a better name, given the way it is documented. Note that (apart from String) the concrete Comparables in the stdlib are numbers, stand-ins for numbers (index) or entities referenced by numbers (code points). String is the salient exception.<br></p><p>Comparable is not defined based on sorting, it&#39;s defined based on the notion of a strict total order, which is a pretty standard way to define it (the other standard way is to define it using a strict partial order, but that removes the ability to use it for sorting; for example, the Rust language actually has two traits Ord as a strict total order and PartialOrd as a strict partial order, where PartialOrd defines &lt; and Ord merely provides a bound for when strict total ordering is needed, such as in sorting which requires Ord instead of PartialOrd).<br></p><p>&gt; The proposed change would redefine &lt; and would be against convention.<br></p><p>Not only does it match the existing definition of &lt;, but it also matches the behavior of every language I know of off the top of my head that provides tuples. This includes Rust, Haskell, OCaml, Erlang, and C++.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 22, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 10:39 AM, Guillaume Lessard &lt;glessard at tffenterprises.com&gt; wrote:<br>&gt; <br>&gt; I wholeheartedly support the Equatable (==) portion of this proposal.<br>&gt; I’m quite negative about the Comparable portion; it doesn’t really make sense.<br>&gt; <br>&gt; The justification for making Tuples comparable pretty much consists of hand-waving.<br>&gt; Why should (0,3,4) be smaller than (0,5,0)? Beats me.<br>&gt; Why would it be the other way around? Also beats me.<br></p><p>So that there’s a default sort order, e.g. in case you want to unique them.  Lexicographical ordering by component is the natural choice, IMO.<br></p><p>&gt; I can vaguely see the utility of Comparable when I squint, but the actual behaviour would require extensive documentation with caveats about it not really making any sense. To overload an operator with a clear meaning with a behaviour with a wishy-washy definition is a bad idea.<br>&gt; <br>&gt; <br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes for Equatable.<br>&gt; No for Comparable.<br>&gt; <br>&gt; <br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes for Equatable.<br>&gt; No for Comparable.<br>&gt; <br>&gt; <br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I have used Mathematics during an extensive education in Physics and Engineering, at the end of which I escaped with a Ph.D. from a major institution.<br>&gt; <br>&gt; Making arbitrary Tuples Equatable when possible makes sense.<br>&gt; Making them Comparable absolutely does not.<br>&gt; <br>&gt; Comparability is domain-specific. The standard library cannot know what an arbitrary Tuple means.<br></p><p>That’s why we have versions of sort et. al. that take custom comparison closures.<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I drew upon my experience. While I feel it’s on solid footing, I would hesitate to call it an in-depth study.<br>&gt; <br>&gt; <br>&gt; Finally, I would like to note that I would support a free-standing function with a clear name that does the same thing as the proposed overloads of the comparison operator.<br>&gt; <br>&gt; Sincerely,<br>&gt; Guillaume Lessard<br>&gt; <br></p><p>-Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; The justification for making Tuples comparable pretty much consists of hand-waving.<br>&gt; Why should (0,3,4) be smaller than (0,5,0)? Beats me.<br>&gt; Why would it be the other way around? Also beats me.<br></p><p>I strongly agree that comparison for tuples makes little sense - but I&#39;d choose a different example:<br>(0, 1) &lt; (1, Any.self)<br>Both are tuples, they are not equal - but can you bring them into a natural order?<br>&quot;Yeah, but those aren&#39;t tuple of the same type, of course you have to have exact same types for comparison&quot;<br>Right, but when you want to use tuples of the same type in different places, wouldn&#39;t it be better to declare that type officially?<br></p><p>If tuple comparison comes for free: So be it — but I can&#39;t see any good use cases for this feature.<br>Of course, as Objective-C has no tuples, we don&#39;t have that much experience with them, but my expectation is that in most cases where order of tuples matters, it will depend on a single member — and there shouldn&#39;t be pressure to choose the order of the members just to get comparison for free.<br></p><p>Tino<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 22, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>This is a very useful addition to the standard library, implemented<br>given current limitations of the language (without variadic generics).<br></p><p>The only concern is code size, and it will be mitigated by choosing a<br>reasonable number of overloads to implement.<br></p><p>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.  It would be even better if we could make tuples conform to<br>Equatable, Hashable and Comparable, but we can&#39;t do that in the<br>current state of the language.<br></p><p>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Python.<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I followed all discussions around the proposal from the start.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review] Tuple comparison operators (was: Add a Lazy flatMap for Sequences of Optionals)</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>+1<br></p><p>** Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>** Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, very much so. <br></p><p>** If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Python’s tuples are equatable and comparable the same way. This feels natural and useful. Rust is another example, and so is Haskell. I’m also very used to lexical ordering of tuples from my studies of mathematics, especially in the computer science branch.<br></p><p>The proposal fails to implement full conformance to Equatable and Comparable (and Hashable), but it’s a nice short-term scratch for an annoying itch.<br></p><p>** How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I read the thread and deeply considered the objections for an hour or so while shopping for groceries. <br></p><p>** What is your evaluation of the proposal?<br></p><p>Equatable is a no-brainer. Even Wikipedia provides the definition of tuple equality, so that’s clearly OK, I think. <br></p><p>Tuples emphatically aren’t the same as vectors, so I think having them sortable with lexical ordering is fine, and it is very convenient. (I would go so far as to say the same of Arrays.)<br></p><p>Tuple is something of a glue type — I use it when defining a named type would feel too verbose. As such, it is very useful to provide tuples with sensible semantics that make them usable in more places. <br></p><p>I can also recall several instances where not having an ordering on tuples has inconvenienced me while writing Swift code. Having to spell out the comparator for the lexical order is a pain, and it is easy to get it wrong.<br></p><p>It is a shame we cannot yet go the full way and have tuples conform to Equatable, Comparable and Hashable when their components do. The proposal presents a weaker form of this that does not allow the use of tuples as e.g. keys in a Dictionary or an ordered map type, although I often want to use tuples in these places. But at least it allows for easy sorting of arrays containing tuples, which is a step in the right direction.<br></p><p>There is precedent in stdlib today in the form of Optional’s &lt; overload, which is arguably too surprising (especially with string searching APIs returning Optional&lt;Int&gt;s). However, I don’t see a case when the tuple variant could be confusing like that.<br></p><p>The proposal doesn’t mention the nullary tuple, but I think () should also be comparable with itself. (And Void should naturally conform to Comparable/Hashable when that becomes possible.)<br></p><p>-- <br>Károly<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>[Review] Tuple comparison operators</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 2:03 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>The proposal should be approved.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Although there&#39;s an increase in the runtime size, it&#39;s minor at the proposed arity. It will also be at least somewhat offset by individual apps, etc., no longer needing to define their own tuple operators.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>This feels like a reasonable first step towards Haskell&#39;s `deriving (Eq, Ord)`.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I did a quick re-read of the proposal and have read the thread leading up to it.<br></p><p>— Curt<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Accepted] SE-0015 Tuple Comparison Operators</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 23, 2015 at 05:00:00pm</p></header><div class="content"><p>The review of SE-0015 “Tuple Comparison Operators&quot; ran from December 21–22, 2015. The proposal has been accepted for Swift 2.2.<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;<br></p><p>Thank you to everyone who participated in the review process! A candidate implementation of this proposal, which may be merged pending evaluation, is at https://github.com/apple/swift/pull/408.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/7bab80f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Accepted] SE-0015 Tuple Comparison Operators</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>Congratulations Kevin! My tuples thank you from the bottom of their arity.<br></p><p>-- E<br></p><p>&gt; On Dec 23, 2015, at 6:01 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; The review of SE-0015 “Tuple Comparison Operators&quot; ran from December 21–22, 2015. The proposal has been accepted for Swift 2.2.<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;<br>&gt; <br>&gt; Thank you to everyone who participated in the review process! A candidate implementation of this proposal, which may be merged pending evaluation, is at https://github.com/apple/swift/pull/408 &lt;https://github.com/apple/swift/pull/408&gt;.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/31ebe79b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0015 Tuple Comparison Operators</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>And the implementation landed as well: https://github.com/apple/swift/pull/408<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 23, 2015, at 05:01 PM, Dave Abrahams via swift-evolution wrote:<br>&gt;<br>&gt; The review of SE-0015 “Tuple Comparison Operators&quot; ran from December<br>&gt; 21–22, 2015. The proposal has been *accepted* for Swift 2.2.<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md<br>&gt;<br>&gt; Thank you to everyone who participated in the review process! A<br>&gt; candidate implementation of this proposal, which may be merged pending<br>&gt; evaluation, is at https://github.com/apple/swift/pull/408.<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/606591ee/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
