<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18d5bcba200ada3ac6efb802e62ae01c?s=50"></div><header><strong>NSProxy dynamic casting to Swift or ObjC class behaves differently</strong> from <string>Yavuz Nuzumlalı</string> &lt;manuyavuz at gmail.com&gt;<p>June  8, 2016 at 07:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>swift_dynamicCastClassUnconditional<br>&lt;https://github.com/apple/swift/blob/3d2b5bcc5350e1dea2ed8a0a95cd12ff5c760f24/stdlib/public/runtime/Casting.cpp#L508&gt;<br>and<br>swift_dynamicCastObjCClassUnconditional<br>&lt;https://github.com/apple/swift/blob/2daa1400cf79a2965eb07034b48ef7fae02459fd/stdlib/public/runtime/SwiftObject.mm#L1155&gt;<br>methods<br>behave differently while verifying casting.<br></p><p>swift_dynamicCastObjCClassUnconditional<br>&lt;https://github.com/apple/swift/blob/2daa1400cf79a2965eb07034b48ef7fae02459fd/stdlib/public/runtime/SwiftObject.mm#L1155&gt;<br>method<br>calls *-isKindOfClass:* method before falling back to *object_getClass*<br> function.<br></p><p>swift_dynamicCastClassUnconditional<br>&lt;https://github.com/apple/swift/blob/3d2b5bcc5350e1dea2ed8a0a95cd12ff5c760f24/stdlib/public/runtime/Casting.cpp#L508&gt;<br>method<br>calls *swift_dynamicCastClass* method which calls *_swift_getClassOfAllocated<br>&lt;https://github.com/apple/swift/blob/82509cbd7451e72fb99d22556ad259ceb335cb1f/stdlib/public/runtime/Private.h#L80&gt;*<br>method<br>which calls directly *object_getClass* function.<br></p><p>This causes problems if underlying object is an NSProxy subclass.<br></p><p>NSProxy class does not implement *-isKindOfClass:* method, so calls to this<br>method are forwarded to the real object through *-forwardInvocation:*<br>method, which causes *-isKindOfClass:* method to return answer according to<br>the real object&#39;s class.<br></p><p>However, *object_getClass* function directly accesses to the metadata of<br>the given object, so it returns NSProxy subclass.<br></p><p>I think this is a conflicting behavior, and I think<br>swift_dynamicCastClassUnconditional<br>&lt;https://github.com/apple/swift/blob/3d2b5bcc5350e1dea2ed8a0a95cd12ff5c760f24/stdlib/public/runtime/Casting.cpp#L508&gt;<br>method<br>should also verify first using *-isKindOfClass:* method, in order to<br>provide consistency.<br></p><p>What do you think?<br></p><p>Best<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160608/6fa472be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>NSProxy dynamic casting to Swift or ObjC class behaves differently</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 12:44 AM, Yavuz Nuzumlalı via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; swift_dynamicCastClassUnconditional and swift_dynamicCastObjCClassUnconditional methods behave differently while verifying casting.<br>&gt; <br>&gt; swift_dynamicCastObjCClassUnconditional method calls -isKindOfClass: method before falling back to object_getClass function.<br>&gt; <br>&gt; swift_dynamicCastClassUnconditional method calls swift_dynamicCastClass method which calls _swift_getClassOfAllocated method which calls directly object_getClass function.<br>&gt; <br>&gt; This causes problems if underlying object is an NSProxy subclass.<br>&gt; <br>&gt; NSProxy class does not implement -isKindOfClass: method, so calls to this method are forwarded to the real object through -forwardInvocation: method, which causes -isKindOfClass: method to return answer according to the real object&#39;s class.<br>&gt; <br>&gt; However, object_getClass function directly accesses to the metadata of the given object, so it returns NSProxy subclass.<br>&gt; <br>&gt; I think this is a conflicting behavior, and I think swift_dynamicCastClassUnconditional method should also verify first using -isKindOfClass: method, in order to provide consistency.<br></p><p>This is intentional, since NSProxy instances are generally expected to be standins for the proxied object. Important Cocoa idioms break down if the &quot;real&quot; class is exposed instead of the class a proxy pretends to be.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSProxy dynamic casting to Swift or ObjC class behaves differently</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 10:52, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 8, 2016, at 12:44 AM, Yavuz Nuzumlalı via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; swift_dynamicCastClassUnconditional and swift_dynamicCastObjCClassUnconditional methods behave differently while verifying casting.<br>&gt;&gt; <br>&gt;&gt; swift_dynamicCastObjCClassUnconditional method calls -isKindOfClass: method before falling back to object_getClass function.<br>&gt;&gt; <br>&gt;&gt; swift_dynamicCastClassUnconditional method calls swift_dynamicCastClass method which calls _swift_getClassOfAllocated method which calls directly object_getClass function.<br>&gt;&gt; <br>&gt;&gt; This causes problems if underlying object is an NSProxy subclass.<br>&gt;&gt; <br>&gt;&gt; NSProxy class does not implement -isKindOfClass: method, so calls to this method are forwarded to the real object through -forwardInvocation: method, which causes -isKindOfClass: method to return answer according to the real object&#39;s class.<br>&gt;&gt; <br>&gt;&gt; However, object_getClass function directly accesses to the metadata of the given object, so it returns NSProxy subclass.<br>&gt;&gt; <br>&gt;&gt; I think this is a conflicting behavior, and I think swift_dynamicCastClassUnconditional method should also verify first using -isKindOfClass: method, in order to provide consistency.<br>&gt; <br>&gt; This is intentional, since NSProxy instances are generally expected to be standins for the proxied object. Important Cocoa idioms break down if the &quot;real&quot; class is exposed instead of the class a proxy pretends to be.<br></p><p>For a little more detail, Swift relies on a bit more information about layout of both instances and classes than Objective-C does, so an NSProxy stand-in wouldn&#39;t work for a Swift type. (And by &quot;wouldn&#39;t work&quot; I mean &quot;would crash your program&quot;.) However, for an Objective-C type, all accesses Swift does will always go through the Objective-C runtime, so it&#39;s safe to use an Objective-C-style proxy, and indeed some Cocoa APIs expect this.<br></p><p>This is probably something we could stand to document more explicitly, but I&#39;m not sure where.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160608/53a67d17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18d5bcba200ada3ac6efb802e62ae01c?s=50"></div><header><strong>NSProxy dynamic casting to Swift or ObjC class behaves differently</strong> from <string>Yavuz Nuzumlalı</string> &lt;manuyavuz at gmail.com&gt;<p>June  8, 2016 at 07:00:00pm</p></header><div class="content"><p>Hmm, interesting.<br></p><p>So, we can say that NSProxy class, which is the base structure for<br>implementing proxy pattern, will not work for a Swift type, right? And I<br>simply can&#39;t use proxy pattern if real object can be a Swift type.<br></p><p>In my use case, I have a framework, and I want to switch developer&#39;s some<br>delegate object with my NSProxy standin, listen delegate method myself,<br>then forward to the developer&#39;s original delegate object.<br></p><p>It was working without any issues for delegate objects which are<br>Objective-C classes. But, it fails for Swift types because dynamic casting<br>does not work anymore.<br></p><p>So, do you have any suggestions about how can I handle this interception<br>functionality without NSProxy?<br></p><p>I don&#39;t want to do swizzling :)<br></p><p>Thanks for the explanations!<br></p><p>On Wed, 8 Jun 2016 at 21:13, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 8, 2016, at 10:52, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jun 8, 2016, at 12:44 AM, Yavuz Nuzumlalı via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; swift_dynamicCastClassUnconditional and<br>&gt; swift_dynamicCastObjCClassUnconditional methods behave differently while<br>&gt; verifying casting.<br>&gt;<br>&gt; swift_dynamicCastObjCClassUnconditional method calls -isKindOfClass:<br>&gt; method before falling back to object_getClass function.<br>&gt;<br>&gt; swift_dynamicCastClassUnconditional method calls swift_dynamicCastClass<br>&gt; method which calls _swift_getClassOfAllocated method which calls directly<br>&gt; object_getClass function.<br>&gt;<br>&gt; This causes problems if underlying object is an NSProxy subclass.<br>&gt;<br>&gt; NSProxy class does not implement -isKindOfClass: method, so calls to this<br>&gt; method are forwarded to the real object through -forwardInvocation: method,<br>&gt; which causes -isKindOfClass: method to return answer according to the real<br>&gt; object&#39;s class.<br>&gt;<br>&gt; However, object_getClass function directly accesses to the metadata of the<br>&gt; given object, so it returns NSProxy subclass.<br>&gt;<br>&gt; I think this is a conflicting behavior, and I think<br>&gt; swift_dynamicCastClassUnconditional method should also verify first using<br>&gt; -isKindOfClass: method, in order to provide consistency.<br>&gt;<br>&gt;<br>&gt; This is intentional, since NSProxy instances are generally expected to be<br>&gt; standins for the proxied object. Important Cocoa idioms break down if the<br>&gt; &quot;real&quot; class is exposed instead of the class a proxy pretends to be.<br>&gt;<br>&gt;<br>&gt; For a little more detail, Swift relies on a bit more information about<br>&gt; layout of both instances and classes than Objective-C does, so an NSProxy<br>&gt; stand-in wouldn&#39;t work for a Swift type. (And by &quot;wouldn&#39;t work&quot; I mean<br>&gt; &quot;would crash your program&quot;.) However, for an Objective-C type, all accesses<br>&gt; Swift does will always go through the Objective-C runtime, so it&#39;s safe to<br>&gt; use an Objective-C-style proxy, and indeed some Cocoa APIs expect this.<br>&gt;<br>&gt; This is probably something we could stand to document more explicitly, but<br>&gt; I&#39;m not sure where.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160608/e06920b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18d5bcba200ada3ac6efb802e62ae01c?s=50"></div><header><strong>NSProxy dynamic casting to Swift or ObjC class behaves differently</strong> from <string>Yavuz Nuzumlalı</string> &lt;manuyavuz at gmail.com&gt;<p>June  8, 2016 at 07:00:00pm</p></header><div class="content"><p>And +1 for documentation. Do you have any guide about how dynamic casting<br>actually works? It would perfectly fit there.<br></p><p>And if there is no public guide, I think it would be great to have one<br>because as far as I see from the code, there are many different scenarios<br>and different behaviors for each scenario, and implementations are<br>implicitly affected by that.<br></p><p>I had to follow stack trace on crash, tried to find the method<br>corresponding to the ObjC type case, find them in source code and compare :)<br>On Wed, 8 Jun 2016 at 22:17, Yavuz Nuzumlalı &lt;manuyavuz at gmail.com&gt; wrote:<br></p><p>&gt; Hmm, interesting.<br>&gt;<br>&gt; So, we can say that NSProxy class, which is the base structure for<br>&gt; implementing proxy pattern, will not work for a Swift type, right? And I<br>&gt; simply can&#39;t use proxy pattern if real object can be a Swift type.<br>&gt;<br>&gt; In my use case, I have a framework, and I want to switch developer&#39;s some<br>&gt; delegate object with my NSProxy standin, listen delegate method myself,<br>&gt; then forward to the developer&#39;s original delegate object.<br>&gt;<br>&gt; It was working without any issues for delegate objects which are<br>&gt; Objective-C classes. But, it fails for Swift types because dynamic casting<br>&gt; does not work anymore.<br>&gt;<br>&gt; So, do you have any suggestions about how can I handle this interception<br>&gt; functionality without NSProxy?<br>&gt;<br>&gt; I don&#39;t want to do swizzling :)<br>&gt;<br>&gt; Thanks for the explanations!<br>&gt;<br>&gt; On Wed, 8 Jun 2016 at 21:13, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 8, 2016, at 10:52, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 8, 2016, at 12:44 AM, Yavuz Nuzumlalı via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; swift_dynamicCastClassUnconditional and<br>&gt;&gt; swift_dynamicCastObjCClassUnconditional methods behave differently while<br>&gt;&gt; verifying casting.<br>&gt;&gt;<br>&gt;&gt; swift_dynamicCastObjCClassUnconditional method calls -isKindOfClass:<br>&gt;&gt; method before falling back to object_getClass function.<br>&gt;&gt;<br>&gt;&gt; swift_dynamicCastClassUnconditional method calls swift_dynamicCastClass<br>&gt;&gt; method which calls _swift_getClassOfAllocated method which calls directly<br>&gt;&gt; object_getClass function.<br>&gt;&gt;<br>&gt;&gt; This causes problems if underlying object is an NSProxy subclass.<br>&gt;&gt;<br>&gt;&gt; NSProxy class does not implement -isKindOfClass: method, so calls to this<br>&gt;&gt; method are forwarded to the real object through -forwardInvocation: method,<br>&gt;&gt; which causes -isKindOfClass: method to return answer according to the real<br>&gt;&gt; object&#39;s class.<br>&gt;&gt;<br>&gt;&gt; However, object_getClass function directly accesses to the metadata of<br>&gt;&gt; the given object, so it returns NSProxy subclass.<br>&gt;&gt;<br>&gt;&gt; I think this is a conflicting behavior, and I think<br>&gt;&gt; swift_dynamicCastClassUnconditional method should also verify first using<br>&gt;&gt; -isKindOfClass: method, in order to provide consistency.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is intentional, since NSProxy instances are generally expected to be<br>&gt;&gt; standins for the proxied object. Important Cocoa idioms break down if the<br>&gt;&gt; &quot;real&quot; class is exposed instead of the class a proxy pretends to be.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; For a little more detail, Swift relies on a bit more information about<br>&gt;&gt; layout of both instances and classes than Objective-C does, so an NSProxy<br>&gt;&gt; stand-in wouldn&#39;t work for a Swift type. (And by &quot;wouldn&#39;t work&quot; I mean<br>&gt;&gt; &quot;would crash your program&quot;.) However, for an Objective-C type, all accesses<br>&gt;&gt; Swift does will always go through the Objective-C runtime, so it&#39;s safe to<br>&gt;&gt; use an Objective-C-style proxy, and indeed some Cocoa APIs expect this.<br>&gt;&gt;<br>&gt;&gt; This is probably something we could stand to document more explicitly,<br>&gt;&gt; but I&#39;m not sure where.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160608/8fa472e4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>NSProxy dynamic casting to Swift or ObjC class behaves differently</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; In my use case, I have a framework, and I want to switch developer&#39;s some delegate object with my NSProxy standin, listen delegate method myself, then forward to the developer&#39;s original delegate object.<br>&gt; <br>&gt; It was working without any issues for delegate objects which are Objective-C classes. But, it fails for Swift types because dynamic casting does not work anymore.<br>&gt; <br>&gt; So, do you have any suggestions about how can I handle this interception functionality without NSProxy? <br></p><p>Make your proxy object explicitly conform to the the delegate protocol you&#39;re trying to monitor, and have it call through to the original delegate. Boilerplate-y? Yeah, totally. But Swift simply isn&#39;t designed for what you&#39;re trying to do.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
