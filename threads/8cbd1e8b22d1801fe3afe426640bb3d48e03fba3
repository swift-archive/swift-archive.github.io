<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>December 15, 2015 at 11:00:00am</p></header><div class="content"><p>One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br></p><p>Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022<br></p><p>Example: <br>let metatype: SomeClass.Type = SomeClass.self<br></p><p>Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br></p><p>I propose changing the postfix self to something more obvious like &quot;type&quot;<br></p><p>Going back to the example:<br>let metatype: SomeClass.Type = SomeClass.type<br></p><p>Several reasons why I think this is better:<br>1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>2. &quot;self&quot; does not clearly explain that the type is being returned <br>3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br></p><p>Any other suggestions would be welcome. <br></p><p>Brandon <br></p><p>Sent from my iPad<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/8cbdfba3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 15, 2015 at 04:00:00pm</p></header><div class="content"><p>+1. Side effects can be eliminated through code migration if a suitable<br>property name is chosen. Perhaps `staticType` to continue in the vein of<br>`dynamicType`?<br></p><p>Main detractor is that creating more keywords isn&#39;t necessarily a good<br>thing.<br></p><p>On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One area of swift that is really not clear to me is when you want to use<br>&gt; the type of a class, struct, enum, etc as a value.<br>&gt;<br>&gt; Metatyping is explained here:<br>&gt; https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022<br>&gt;<br>&gt; Example:<br>&gt;<br>&gt;    1. let metatype: SomeClass.Type = SomeClass.self<br>&gt;<br>&gt;<br>&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the<br>&gt; document this is explained as returning the type yet it&#39;s using a postfix<br>&gt; self to access the type.<br>&gt;<br>&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;<br>&gt; Going back to the example:<br>&gt;<br>&gt;    1. let metatype: SomeClass.Type = SomeClass.type<br>&gt;<br>&gt;<br>&gt; Several reasons why I think this is better:<br>&gt; 1. Postfix self is not obvious as an option as you never see a postfix<br>&gt; self anywhere else<br>&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned<br>&gt; 3. ObjC programmers are familiar with accessing the class type by sending<br>&gt; the &quot;class&quot; method to the class type. In this case it needs to work on<br>&gt; structs and enums, so a &quot;type&quot; method would make more sense.<br>&gt; 4. Instances have a dynamicType method. For consistency, classes, structs,<br>&gt; etc., should have a type method<br>&gt;<br>&gt; Any other suggestions would be welcome.<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt; Sent from my iPad<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/381df94b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>December 15, 2015 at 11:00:00am</p></header><div class="content"><p>Doh! staticType is the obvious choice!<br></p><p>I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br></p><p>SomeType.staticType<br>SomeType.self <br></p><p>To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br></p><p>I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br></p><p>Brandon <br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt; <br>&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt; <br>&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt; <br>&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022<br>&gt;&gt; <br>&gt;&gt; Example: <br>&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt; <br>&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt; <br>&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt; <br>&gt;&gt; Going back to the example:<br>&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt; <br>&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt; <br>&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/21b8f28b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December 15, 2015 at 07:00:00pm</p></header><div class="content"><p>I also wholeheartedly agree. I&#39;ve always been a bit confused by that keyword in that context.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 15 Dec 2015, at 17:42, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Doh! staticType is the obvious choice!<br>&gt; <br>&gt; I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br>&gt; <br>&gt; SomeType.staticType<br>&gt; SomeType.self <br>&gt; <br>&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br>&gt; <br>&gt; I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br>&gt; <br>&gt; Brandon <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt;&gt; <br>&gt;&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example: <br>&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Going back to the example:<br>&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/10bf1236/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 15, 2015 at 10:00:00am</p></header><div class="content"><p>&quot;.self&quot; was chosen for a few reasons:<br></p><p>- The obvious choice was &quot;.class&quot;, given precedent in Objective-C and Java, but not all types are classes.<br>- &#39;type&#39; is a very common property name, so we have tried very hard to avoid taking it as a general keyword.<br>- &#39;type&#39; also always implies going up a level. &quot;obj.dynamicType&quot; gives you back the type of &#39;obj&#39;, so wouldn&#39;t &quot;SomeClass.type&quot; give you back the metaclass &lt;http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&gt;? (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br>- &#39;self&#39; is already a keyword.<br>- &quot;.self&quot; actually works in Objective-C as well.<br>- &quot;.self&quot; currently also applies to instances, doing exactly what you think it does. This is nearly useless. In theory you could use it to unwrap one level of optionality (&quot;doubleOpt?.self&quot;) but that doesn&#39;t actually work today.<br></p><p>I read &quot;SomeType.self&quot; as &quot;SomeType itself, rather than an instance of it (or associated type)&quot;.<br></p><p>(And before someone brings it up, we chose not to just allow &quot;SomeType&quot; on its own because &quot;let x = SomeType&quot; is a likely typo for &quot;let x: SomeType&quot;.)<br></p><p>I think coming up with a clearer name is possible here, but there&#39;s plenty to consider. Still, certainly a reasonable thing to bring up.<br></p><p>Best,<br>Jordan<br></p><p>&gt; On Dec 15, 2015, at 8:42 , Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Doh! staticType is the obvious choice!<br>&gt; <br>&gt; I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br>&gt; <br>&gt; SomeType.staticType<br>&gt; SomeType.self <br>&gt; <br>&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br>&gt; <br>&gt; I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br>&gt; <br>&gt; Brandon <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt;&gt; <br>&gt;&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt; <br>&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022&gt;<br>&gt;&gt; <br>&gt;&gt; Example: <br>&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt; <br>&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt; <br>&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt; <br>&gt;&gt; Going back to the example:<br>&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt; <br>&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt; <br>&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/aa411ed2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 12:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br></p><p>Why?<br></p><p>It is not strange to me at all that two different vars return two different things.  The names here seem especially clear--staticType being the type as inferred statically, while dynamicType being the runtime type.<br></p><p>+1 for staticType<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/11d31f58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 15, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 13:19 , Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 12:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br>&gt; <br>&gt; Why?<br>&gt; <br>&gt; It is not strange to me at all that two different vars return two different things.  The names here seem especially clear--staticType being the type as inferred statically, while dynamicType being the runtime type.<br>&gt; <br>&gt; +1 for staticType<br></p><p>Sorry, what I meant is not that they have different values, but that they have different levels of meta:<br></p><p>  1&gt; Int.self<br>$R0: Int.Type = Int<br>  2&gt; Int.self.dynamicType<br>$R1: Int.Type.Type = Int.Type<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/998ef661/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 15, 2015 at 10:00:00pm</p></header><div class="content"><p>The word &quot;Type&quot; is also blocked in most cases. So still being able to use<br>the word &quot;type&quot; is less valuable anyway because you cannot create a nested<br>type called &quot;Type&quot; and will most likely rename it to something like &quot;Kind&quot;.<br></p><p>This is actually very annoying:<br></p><p>struct Attachment {<br></p><p>let type: Type<br></p><p><br>enum Type {<br>case Image<br>case Video<br>}<br>}<br></p><p>let attachmentType = Attachment.Type // error: expected member name or<br>constructor call after type name<br></p><p><br></p><p><br>On Tue, Dec 15, 2015 at 7:24 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &quot;.self&quot; was chosen for a few reasons:<br>&gt;<br>&gt; - The obvious choice was &quot;.class&quot;, given precedent in Objective-C and<br>&gt; Java, but not all types are classes.<br>&gt; - &#39;type&#39; is a very common property name, so we have tried very hard to<br>&gt; avoid taking it as a general keyword.<br>&gt; - &#39;type&#39; also always implies going up a level. &quot;obj.dynamicType&quot; gives you<br>&gt; back the type of &#39;obj&#39;, so wouldn&#39;t &quot;SomeClass.type&quot; give you back the<br>&gt; metaclass<br>&gt; &lt;http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&gt;?<br>&gt; (Alternately, &quot;SomeType.staticType&#39; not being the same as<br>&gt; &#39;SomeType.dynamicType&quot; seems weird.)<br>&gt; - &#39;self&#39; is already a keyword.<br>&gt; - &quot;.self&quot; actually works in Objective-C as well.<br>&gt; - &quot;.self&quot; currently also applies to instances, doing exactly what you<br>&gt; think it does. This is *nearly* useless. In theory you could use it to<br>&gt; unwrap one level of optionality (&quot;doubleOpt?.self&quot;) but that doesn&#39;t<br>&gt; actually work today.<br>&gt;<br>&gt; I read &quot;SomeType.self&quot; as &quot;SomeType itself, rather than an instance of it<br>&gt; (or associated type)&quot;.<br>&gt;<br>&gt; (And before someone brings it up, we chose not to just allow &quot;SomeType&quot; on<br>&gt; its own because &quot;let x = SomeType&quot; is a likely typo for &quot;let x: SomeType&quot;.)<br>&gt;<br>&gt; I think coming up with a clearer name is possible here, but there&#39;s plenty<br>&gt; to consider. Still, certainly a reasonable thing to bring up.<br>&gt;<br>&gt; Best,<br>&gt; Jordan<br>&gt;<br>&gt; On Dec 15, 2015, at 8:42 , Brandon Knope via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Doh! staticType is the obvious choice!<br>&gt;<br>&gt; I agree that adding more keywords can be bad, but in this case I think the<br>&gt; clarity outweighs any downside:<br>&gt;<br>&gt; SomeType.staticType<br>&gt; SomeType.self<br>&gt;<br>&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to<br>&gt; understand.<br>&gt;<br>&gt; I still don&#39;t really understand what SomeType.self is trying to convey<br>&gt; upon first glance<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; +1. Side effects can be eliminated through code migration if a suitable<br>&gt; property name is chosen. Perhaps `staticType` to continue in the vein of<br>&gt; `dynamicType`?<br>&gt;<br>&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good<br>&gt; thing.<br>&gt;<br>&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; One area of swift that is really not clear to me is when you want to use<br>&gt;&gt; the type of a class, struct, enum, etc as a value.<br>&gt;&gt;<br>&gt;&gt; Metatyping is explained here:<br>&gt;&gt; https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022<br>&gt;&gt;<br>&gt;&gt; Example:<br>&gt;&gt;<br>&gt;&gt;    1. let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the<br>&gt;&gt; document this is explained as returning the type yet it&#39;s using a postfix<br>&gt;&gt; self to access the type.<br>&gt;&gt;<br>&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt;<br>&gt;&gt; Going back to the example:<br>&gt;&gt;<br>&gt;&gt;    1. let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix<br>&gt;&gt; self anywhere else<br>&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned<br>&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending<br>&gt;&gt; the &quot;class&quot; method to the class type. In this case it needs to work on<br>&gt;&gt; structs and enums, so a &quot;type&quot; method would make more sense.<br>&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes,<br>&gt;&gt; structs, etc., should have a type method<br>&gt;&gt;<br>&gt;&gt; Any other suggestions would be welcome.<br>&gt;&gt;<br>&gt;&gt; Brandon<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/72f4e460/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December 17, 2015 at 11:00:00am</p></header><div class="content"><p>I have two questions:<br></p><p>1. why do we need the postfix self?<br>2. why is the postfix self sometimes required, and sometimes not? (see sample code below):<br></p><p>	func f1&lt;T&gt;(type: T.Type) { print(type) }<br>	f1(Int)                     // Int<br></p><p>	func f2&lt;T&gt;(type: T.Type, extra: Bool) { print(type) }<br>	f2(Int, extra: true)        // Compiler error<br>	f2(Int.self, extra: true)   // Int<br></p><p>Gwendal Roué<br></p><p><br>&gt; Le 15 déc. 2015 à 22:29, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; The word &quot;Type&quot; is also blocked in most cases. So still being able to use the word &quot;type&quot; is less valuable anyway because you cannot create a nested type called &quot;Type&quot; and will most likely rename it to something like &quot;Kind&quot;.<br>&gt; <br>&gt; This is actually very annoying:<br>&gt; <br>&gt; struct Attachment {<br>&gt; <br>&gt; 	let type: Type<br>&gt; <br>&gt; <br>&gt; 	enum Type {<br>&gt; 		case Image<br>&gt; 		case Video<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; let attachmentType = Attachment.Type // error: expected member name or constructor call after type name<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Dec 15, 2015 at 7:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &quot;.self&quot; was chosen for a few reasons:<br>&gt; <br>&gt; - The obvious choice was &quot;.class&quot;, given precedent in Objective-C and Java, but not all types are classes.<br>&gt; - &#39;type&#39; is a very common property name, so we have tried very hard to avoid taking it as a general keyword.<br>&gt; - &#39;type&#39; also always implies going up a level. &quot;obj.dynamicType&quot; gives you back the type of &#39;obj&#39;, so wouldn&#39;t &quot;SomeClass.type&quot; give you back the metaclass &lt;http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&gt;? (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br>&gt; - &#39;self&#39; is already a keyword.<br>&gt; - &quot;.self&quot; actually works in Objective-C as well.<br>&gt; - &quot;.self&quot; currently also applies to instances, doing exactly what you think it does. This is nearly useless. In theory you could use it to unwrap one level of optionality (&quot;doubleOpt?.self&quot;) but that doesn&#39;t actually work today.<br>&gt; <br>&gt; I read &quot;SomeType.self&quot; as &quot;SomeType itself, rather than an instance of it (or associated type)&quot;.<br>&gt; <br>&gt; (And before someone brings it up, we chose not to just allow &quot;SomeType&quot; on its own because &quot;let x = SomeType&quot; is a likely typo for &quot;let x: SomeType&quot;.)<br>&gt; <br>&gt; I think coming up with a clearer name is possible here, but there&#39;s plenty to consider. Still, certainly a reasonable thing to bring up.<br>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 8:42 , Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Doh! staticType is the obvious choice!<br>&gt;&gt; <br>&gt;&gt; I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br>&gt;&gt; <br>&gt;&gt; SomeType.staticType<br>&gt;&gt; SomeType.self <br>&gt;&gt; <br>&gt;&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br>&gt;&gt; <br>&gt;&gt; I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example: <br>&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Going back to the example:<br>&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/22084f73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>I also find this aspect of Swift very confusing. I have worked a lot with metatypes (and metaprogramming in general) in Python and R, but I can’t really wrap my head around how this works in Swift. <br></p><p>&gt; On 17 Dec 2015, at 11:12, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have two questions:<br>&gt; <br>&gt; 1. why do we need the postfix self?<br>&gt; 2. why is the postfix self sometimes required, and sometimes not? (see sample code below):<br>&gt; <br>&gt; 	func f1&lt;T&gt;(type: T.Type) { print(type) }<br>&gt; 	f1(Int)                     // Int<br>&gt; <br>&gt; 	func f2&lt;T&gt;(type: T.Type, extra: Bool) { print(type) }<br>&gt; 	f2(Int, extra: true)        // Compiler error<br>&gt; 	f2(Int.self, extra: true)   // Int<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt; <br>&gt;&gt; Le 15 déc. 2015 à 22:29, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; The word &quot;Type&quot; is also blocked in most cases. So still being able to use the word &quot;type&quot; is less valuable anyway because you cannot create a nested type called &quot;Type&quot; and will most likely rename it to something like &quot;Kind&quot;.<br>&gt;&gt; <br>&gt;&gt; This is actually very annoying:<br>&gt;&gt; <br>&gt;&gt; struct Attachment {<br>&gt;&gt; <br>&gt;&gt; 	let type: Type<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	enum Type {<br>&gt;&gt; 		case Image<br>&gt;&gt; 		case Video<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let attachmentType = Attachment.Type // error: expected member name or constructor call after type name<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 15, 2015 at 7:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &quot;.self&quot; was chosen for a few reasons:<br>&gt;&gt; <br>&gt;&gt; - The obvious choice was &quot;.class&quot;, given precedent in Objective-C and Java, but not all types are classes.<br>&gt;&gt; - &#39;type&#39; is a very common property name, so we have tried very hard to avoid taking it as a general keyword.<br>&gt;&gt; - &#39;type&#39; also always implies going up a level. &quot;obj.dynamicType&quot; gives you back the type of &#39;obj&#39;, so wouldn&#39;t &quot;SomeClass.type&quot; give you back the metaclass &lt;http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&gt;? (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br>&gt;&gt; - &#39;self&#39; is already a keyword.<br>&gt;&gt; - &quot;.self&quot; actually works in Objective-C as well.<br>&gt;&gt; - &quot;.self&quot; currently also applies to instances, doing exactly what you think it does. This is nearly useless. In theory you could use it to unwrap one level of optionality (&quot;doubleOpt?.self&quot;) but that doesn&#39;t actually work today.<br>&gt;&gt; <br>&gt;&gt; I read &quot;SomeType.self&quot; as &quot;SomeType itself, rather than an instance of it (or associated type)&quot;.<br>&gt;&gt; <br>&gt;&gt; (And before someone brings it up, we chose not to just allow &quot;SomeType&quot; on its own because &quot;let x = SomeType&quot; is a likely typo for &quot;let x: SomeType&quot;.)<br>&gt;&gt; <br>&gt;&gt; I think coming up with a clearer name is possible here, but there&#39;s plenty to consider. Still, certainly a reasonable thing to bring up.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 8:42 , Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doh! staticType is the obvious choice!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SomeType.staticType<br>&gt;&gt;&gt; SomeType.self <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: <br>&gt;&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Going back to the example:<br>&gt;&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt;&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt;&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt;&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt;&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/8d64a52d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>(Sorry, I pressed the send button accidentally)<br></p><p>What I wanted to say is that maybe one can have a more transparent system, e.g. typeOf(x) that always returns type of x? For example, typeOf(3) can be Int, type of typeOf(Int) will be the metatype of Int, etc. Similarly, to refer to a type, one should just be able to use the type name. Does anyone know the reason why the system was set up like it is in the first place? <br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; On 17 Dec 2015, at 13:00, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; I also find this aspect of Swift very confusing. I have worked a lot with metatypes (and metaprogramming in general) in Python and R, but I can’t really wrap my head around how this works in Swift. <br>&gt; <br>&gt;&gt; On 17 Dec 2015, at 11:12, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have two questions:<br>&gt;&gt; <br>&gt;&gt; 1. why do we need the postfix self?<br>&gt;&gt; 2. why is the postfix self sometimes required, and sometimes not? (see sample code below):<br>&gt;&gt; <br>&gt;&gt; 	func f1&lt;T&gt;(type: T.Type) { print(type) }<br>&gt;&gt; 	f1(Int)                     // Int<br>&gt;&gt; <br>&gt;&gt; 	func f2&lt;T&gt;(type: T.Type, extra: Bool) { print(type) }<br>&gt;&gt; 	f2(Int, extra: true)        // Compiler error<br>&gt;&gt; 	f2(Int.self, extra: true)   // Int<br>&gt;&gt; <br>&gt;&gt; Gwendal Roué<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 15 déc. 2015 à 22:29, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The word &quot;Type&quot; is also blocked in most cases. So still being able to use the word &quot;type&quot; is less valuable anyway because you cannot create a nested type called &quot;Type&quot; and will most likely rename it to something like &quot;Kind&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is actually very annoying:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Attachment {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let type: Type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	enum Type {<br>&gt;&gt;&gt; 		case Image<br>&gt;&gt;&gt; 		case Video<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let attachmentType = Attachment.Type // error: expected member name or constructor call after type name<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 15, 2015 at 7:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &quot;.self&quot; was chosen for a few reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The obvious choice was &quot;.class&quot;, given precedent in Objective-C and Java, but not all types are classes.<br>&gt;&gt;&gt; - &#39;type&#39; is a very common property name, so we have tried very hard to avoid taking it as a general keyword.<br>&gt;&gt;&gt; - &#39;type&#39; also always implies going up a level. &quot;obj.dynamicType&quot; gives you back the type of &#39;obj&#39;, so wouldn&#39;t &quot;SomeClass.type&quot; give you back the metaclass &lt;http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&gt;? (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br>&gt;&gt;&gt; - &#39;self&#39; is already a keyword.<br>&gt;&gt;&gt; - &quot;.self&quot; actually works in Objective-C as well.<br>&gt;&gt;&gt; - &quot;.self&quot; currently also applies to instances, doing exactly what you think it does. This is nearly useless. In theory you could use it to unwrap one level of optionality (&quot;doubleOpt?.self&quot;) but that doesn&#39;t actually work today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I read &quot;SomeType.self&quot; as &quot;SomeType itself, rather than an instance of it (or associated type)&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (And before someone brings it up, we chose not to just allow &quot;SomeType&quot; on its own because &quot;let x = SomeType&quot; is a likely typo for &quot;let x: SomeType&quot;.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think coming up with a clearer name is possible here, but there&#39;s plenty to consider. Still, certainly a reasonable thing to bring up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 8:42 , Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doh! staticType is the obvious choice!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SomeType.staticType<br>&gt;&gt;&gt;&gt; SomeType.self <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example: <br>&gt;&gt;&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Going back to the example:<br>&gt;&gt;&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt;&gt;&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt;&gt;&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt;&gt;&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt;&gt;&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/7a1c096d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>We have that; it&#39;s &quot;.dynamicType&quot;. That&#39;s not really related to &quot;.self&quot;.<br></p><p>Swift&#39;s model is like Objective-C&#39;s: if you want to refer to a type as a value, you have to call it out specifically. Objective-C chose &quot;[SomeType class]&quot; for this, but &quot;[SomeType self]&quot; actually works as well.<br></p><p>Jordan<br></p><p>&gt; On Dec 17, 2015, at 4:03 , Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (Sorry, I pressed the send button accidentally)<br>&gt; <br>&gt; What I wanted to say is that maybe one can have a more transparent system, e.g. typeOf(x) that always returns type of x? For example, typeOf(3) can be Int, type of typeOf(Int) will be the metatype of Int, etc. Similarly, to refer to a type, one should just be able to use the type name. Does anyone know the reason why the system was set up like it is in the first place? <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt;&gt; On 17 Dec 2015, at 13:00, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also find this aspect of Swift very confusing. I have worked a lot with metatypes (and metaprogramming in general) in Python and R, but I can’t really wrap my head around how this works in Swift. <br>&gt;&gt; <br>&gt;&gt;&gt; On 17 Dec 2015, at 11:12, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have two questions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. why do we need the postfix self?<br>&gt;&gt;&gt; 2. why is the postfix self sometimes required, and sometimes not? (see sample code below):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func f1&lt;T&gt;(type: T.Type) { print(type) }<br>&gt;&gt;&gt; 	f1(Int)                     // Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func f2&lt;T&gt;(type: T.Type, extra: Bool) { print(type) }<br>&gt;&gt;&gt; 	f2(Int, extra: true)        // Compiler error<br>&gt;&gt;&gt; 	f2(Int.self, extra: true)   // Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gwendal Roué<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 15 déc. 2015 à 22:29, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The word &quot;Type&quot; is also blocked in most cases. So still being able to use the word &quot;type&quot; is less valuable anyway because you cannot create a nested type called &quot;Type&quot; and will most likely rename it to something like &quot;Kind&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is actually very annoying:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Attachment {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let type: Type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	enum Type {<br>&gt;&gt;&gt;&gt; 		case Image<br>&gt;&gt;&gt;&gt; 		case Video<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let attachmentType = Attachment.Type // error: expected member name or constructor call after type name<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 15, 2015 at 7:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &quot;.self&quot; was chosen for a few reasons:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - The obvious choice was &quot;.class&quot;, given precedent in Objective-C and Java, but not all types are classes.<br>&gt;&gt;&gt;&gt; - &#39;type&#39; is a very common property name, so we have tried very hard to avoid taking it as a general keyword.<br>&gt;&gt;&gt;&gt; - &#39;type&#39; also always implies going up a level. &quot;obj.dynamicType&quot; gives you back the type of &#39;obj&#39;, so wouldn&#39;t &quot;SomeClass.type&quot; give you back the metaclass &lt;http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&gt;? (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br>&gt;&gt;&gt;&gt; - &#39;self&#39; is already a keyword.<br>&gt;&gt;&gt;&gt; - &quot;.self&quot; actually works in Objective-C as well.<br>&gt;&gt;&gt;&gt; - &quot;.self&quot; currently also applies to instances, doing exactly what you think it does. This is nearly useless. In theory you could use it to unwrap one level of optionality (&quot;doubleOpt?.self&quot;) but that doesn&#39;t actually work today.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I read &quot;SomeType.self&quot; as &quot;SomeType itself, rather than an instance of it (or associated type)&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (And before someone brings it up, we chose not to just allow &quot;SomeType&quot; on its own because &quot;let x = SomeType&quot; is a likely typo for &quot;let x: SomeType&quot;.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think coming up with a clearer name is possible here, but there&#39;s plenty to consider. Still, certainly a reasonable thing to bring up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 8:42 , Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Doh! staticType is the obvious choice!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; SomeType.staticType<br>&gt;&gt;&gt;&gt;&gt; SomeType.self <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example: <br>&gt;&gt;&gt;&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Going back to the example:<br>&gt;&gt;&gt;&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt;&gt;&gt;&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/6a8445b4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 9:47 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We have that; it&#39;s &quot;.dynamicType&quot;. That&#39;s not really related to &quot;.self&quot;.<br>&gt; <br>&gt; Swift&#39;s model is like Objective-C&#39;s: if you want to refer to a type as a value, you have to call it out specifically. Objective-C chose &quot;[SomeType class]&quot; for this, but &quot;[SomeType self]&quot; actually works as well.<br></p><p>Objective-C&#39;s `[SomeClass class]` is wrong in a formal sense. `[object class]` returns the object&#39;s class, but `[SomeClass class]` does not return the class&#39;s class (i.e. its metaclass). `[SomeClass self]` is the formally more consistent one.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>It&#39;s intended to be required all the time; the cases where it&#39;s not required are a bug. (I think it&#39;s just single-argument function calls, but I could be wrong.)<br></p><p>Again, it&#39;s intended to allow the compiler to produce better diagnostics for &quot;let x = SomeType&quot; when you really meant &quot;let x: SomeType&quot;. I can&#39;t think of any other examples where the error messages wouldn&#39;t be obvious, but with a declaration the diagnostics may be somewhere unrelated to the issue. (Especially if it&#39;s a property.)<br></p><p>Jordan<br></p><p>&gt; On Dec 17, 2015, at 2:12 , Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have two questions:<br>&gt; <br>&gt; 1. why do we need the postfix self?<br>&gt; 2. why is the postfix self sometimes required, and sometimes not? (see sample code below):<br>&gt; <br>&gt; 	func f1&lt;T&gt;(type: T.Type) { print(type) }<br>&gt; 	f1(Int)                     // Int<br>&gt; <br>&gt; 	func f2&lt;T&gt;(type: T.Type, extra: Bool) { print(type) }<br>&gt; 	f2(Int, extra: true)        // Compiler error<br>&gt; 	f2(Int.self, extra: true)   // Int<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt; <br>&gt;&gt; Le 15 déc. 2015 à 22:29, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; The word &quot;Type&quot; is also blocked in most cases. So still being able to use the word &quot;type&quot; is less valuable anyway because you cannot create a nested type called &quot;Type&quot; and will most likely rename it to something like &quot;Kind&quot;.<br>&gt;&gt; <br>&gt;&gt; This is actually very annoying:<br>&gt;&gt; <br>&gt;&gt; struct Attachment {<br>&gt;&gt; <br>&gt;&gt; 	let type: Type<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 	enum Type {<br>&gt;&gt; 		case Image<br>&gt;&gt; 		case Video<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let attachmentType = Attachment.Type // error: expected member name or constructor call after type name<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 15, 2015 at 7:24 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &quot;.self&quot; was chosen for a few reasons:<br>&gt;&gt; <br>&gt;&gt; - The obvious choice was &quot;.class&quot;, given precedent in Objective-C and Java, but not all types are classes.<br>&gt;&gt; - &#39;type&#39; is a very common property name, so we have tried very hard to avoid taking it as a general keyword.<br>&gt;&gt; - &#39;type&#39; also always implies going up a level. &quot;obj.dynamicType&quot; gives you back the type of &#39;obj&#39;, so wouldn&#39;t &quot;SomeClass.type&quot; give you back the metaclass &lt;http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&gt;? (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br>&gt;&gt; - &#39;self&#39; is already a keyword.<br>&gt;&gt; - &quot;.self&quot; actually works in Objective-C as well.<br>&gt;&gt; - &quot;.self&quot; currently also applies to instances, doing exactly what you think it does. This is nearly useless. In theory you could use it to unwrap one level of optionality (&quot;doubleOpt?.self&quot;) but that doesn&#39;t actually work today.<br>&gt;&gt; <br>&gt;&gt; I read &quot;SomeType.self&quot; as &quot;SomeType itself, rather than an instance of it (or associated type)&quot;.<br>&gt;&gt; <br>&gt;&gt; (And before someone brings it up, we chose not to just allow &quot;SomeType&quot; on its own because &quot;let x = SomeType&quot; is a likely typo for &quot;let x: SomeType&quot;.)<br>&gt;&gt; <br>&gt;&gt; I think coming up with a clearer name is possible here, but there&#39;s plenty to consider. Still, certainly a reasonable thing to bring up.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 8:42 , Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doh! staticType is the obvious choice!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SomeType.staticType<br>&gt;&gt;&gt; SomeType.self <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example: <br>&gt;&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Going back to the example:<br>&gt;&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt;&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt;&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt;&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt;&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/a8a704ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 9:44 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s intended to be required all the time; the cases where it&#39;s not required are a bug. (I think it&#39;s just single-argument function calls, but I could be wrong.)<br>&gt; <br>&gt; Again, it&#39;s intended to allow the compiler to produce better diagnostics for &quot;let x = SomeType&quot; when you really meant &quot;let x: SomeType&quot;. I can&#39;t think of any other examples where the error messages wouldn&#39;t be obvious, but with a declaration the diagnostics may be somewhere unrelated to the issue. (Especially if it&#39;s a property.)<br></p><p>There&#39;s also a syntactic ambiguity with &lt; &gt; being both operators and generic parameter brackets that we resolve by requiring generic parameters in expression context to always be followed by a paren, as in a construction Foo&lt;Bar&gt;(), or by a dot, as in Foo&lt;Bar&gt;.member. C# does the same.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/5d6a900a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Changing postfix &quot;self&quot; to something clearer like &quot;type&quot;</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>January  5, 2016 at 12:00:00am</p></header><div class="content"><p>I have been sitting on a response to this for a while for a few reasons.<br>1. I didn’t see much interest generated in proceeding with a proposal<br>2. I have been trying very *hard* to get “SomeType.self” as “SomeType itself, rather than an instance of it” into my head.<br></p><p>My problem is it still does not seem 100% obvious and looks somewhat awkward at first glance.<br></p><p>I mean it’s obvious when the type name is SomeType so you *know* it’s a type. If the type is Mood and you see Mood.self this doesn’t seem as obvious to me.<br></p><p>There has to be a swifter way to do this, but I am not quite sure I’ve found it yet<br></p><p>Brandon<br></p><p>&gt; On Dec 15, 2015, at 1:24 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; &quot;.self&quot; was chosen for a few reasons:<br>&gt; <br>&gt; - The obvious choice was &quot;.class&quot;, given precedent in Objective-C and Java, but not all types are classes.<br>&gt; - &#39;type&#39; is a very common property name, so we have tried very hard to avoid taking it as a general keyword.<br>&gt; - &#39;type&#39; also always implies going up a level. &quot;obj.dynamicType&quot; gives you back the type of &#39;obj&#39;, so wouldn&#39;t &quot;SomeClass.type&quot; give you back the metaclass &lt;http://sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html&gt;? (Alternately, &quot;SomeType.staticType&#39; not being the same as &#39;SomeType.dynamicType&quot; seems weird.)<br>&gt; - &#39;self&#39; is already a keyword.<br>&gt; - &quot;.self&quot; actually works in Objective-C as well.<br>&gt; - &quot;.self&quot; currently also applies to instances, doing exactly what you think it does. This is nearly useless. In theory you could use it to unwrap one level of optionality (&quot;doubleOpt?.self&quot;) but that doesn&#39;t actually work today.<br>&gt; <br>&gt; I read &quot;SomeType.self&quot; as &quot;SomeType itself, rather than an instance of it (or associated type)&quot;.<br>&gt; <br>&gt; (And before someone brings it up, we chose not to just allow &quot;SomeType&quot; on its own because &quot;let x = SomeType&quot; is a likely typo for &quot;let x: SomeType&quot;.)<br>&gt; <br>&gt; I think coming up with a clearer name is possible here, but there&#39;s plenty to consider. Still, certainly a reasonable thing to bring up.<br>&gt; <br>&gt; Best,<br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 8:42 , Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Doh! staticType is the obvious choice!<br>&gt;&gt; <br>&gt;&gt; I agree that adding more keywords can be bad, but in this case I think the clarity outweighs any downside:<br>&gt;&gt; <br>&gt;&gt; SomeType.staticType<br>&gt;&gt; SomeType.self <br>&gt;&gt; <br>&gt;&gt; To me (and I&#39;m sure many others) one is vastly more obvious and easier to understand. <br>&gt;&gt; <br>&gt;&gt; I still don&#39;t really understand what SomeType.self is trying to convey upon first glance<br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Dec 15, 2015, at 11:34 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; +1. Side effects can be eliminated through code migration if a suitable property name is chosen. Perhaps `staticType` to continue in the vein of `dynamicType`? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Main detractor is that creating more keywords isn&#39;t necessarily a good thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 15, 2015 at 11:19 AM Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; One area of swift that is really not clear to me is when you want to use the type of a class, struct, enum, etc as a value. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Metatyping is explained here: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html#//apple_ref/doc/uid/TP40014097-CH31-XID_1022&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example: <br>&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a reason why this isn&#39;t SomeClass.type? Everywhere in the document this is explained as returning the type yet it&#39;s using a postfix self to access the type. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose changing the postfix self to something more obvious like &quot;type&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Going back to the example:<br>&gt;&gt;&gt; let metatype: SomeClass.Type = SomeClass.type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Several reasons why I think this is better:<br>&gt;&gt;&gt; 1. Postfix self is not obvious as an option as you never see a postfix self anywhere else <br>&gt;&gt;&gt; 2. &quot;self&quot; does not clearly explain that the type is being returned <br>&gt;&gt;&gt; 3. ObjC programmers are familiar with accessing the class type by sending the &quot;class&quot; method to the class type. In this case it needs to work on structs and enums, so a &quot;type&quot; method would make more sense. <br>&gt;&gt;&gt; 4. Instances have a dynamicType method. For consistency, classes, structs, etc., should have a type method<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any other suggestions would be welcome. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/4c90f9ec/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
