<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Here&#39;s a problem<br></p><p>* There are Swift attributes: @autoclosure, @available, @objc, @noescape, @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>* There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, @IBOutlet<br>* There may be user-definable attributes under SE-0030: for example @lazy, @delayed; these are certainly attribute-ish, and it makes sense to present these using attribute-syntax.<br>* The attribute syntax using `@` has had an intention &quot;to open the space up to user attributes at some point&quot;<br></p><p>&gt; Namespacing<br></p><p>If Swift were to start accepting user-defined attributes,  it would need some way to differentiate and namespace potential conflicts. The most obvious solution looks like this:<br></p><p>`@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`, `@Swift.noreturn`, `@Custom.lazy`, etc.<br></p><p>Cumbersome, ugly, problematic.<br></p><p>&gt; Modernization<br></p><p>In my initial discussion for modernizing Swift attributes (https://gist.github.com/erica/29c1a7fb7f49324d572f &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;), I wanted to eliminate snakecase from @warn-unused-result and `mutable_variant`. Of these, the second is a no-brainer. Instead of the non-standard argument label `mutable_variant`, use `mutableVariant`. Problem solved.<br></p><p>Converting `warn-unused-result` to the current standard of lowercase `warnunusedresult` produces a hard-to-read outcome. So in my write-up, I proposed the following amendments:<br></p><p>@Autoclosure // was @autoclosure<br>@Available // was @available<br>@ObjC // was @objc<br>@NoEscape // was @noescape<br>@NonObjC // was @nonobjc<br>@NoReturn // was @noreturn<br>@Testable // was @testable<br>@WarnUnusedResult // was @warn-unused-result<br>@Convention  // was @convention<br>@NoReturn // was @noreturn<br></p><p>This was greeted somewhere between warmly and Siberian Winter depending on respondent. <br></p><p>&gt; Possible Approaches<br></p><p>After reading through Joe Groff&#39;s update to SE-0030, I&#39;d like to push this again in a broader context (which is why I&#39;m starting a new email thread). <br></p><p>* Is traditional namespacing the way to go? <br>* Could a simpler solution to upper camel all system-supplied attributes and lower camel all custom attributes be sufficient?<br>* Could any other &quot;custom&quot; decoration differentiate the two with easy parsing: for example @@lazy, @@delayed for custom and single-@ tokens for system supplied?<br>* Should I simply back off on modernizing warn-unused-result until SE-0030 is resolved?<br></p><p>What are your thoughts?<br></p><p>Thanks, -- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/f45efe72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 12:17 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; &gt; Here&#39;s a problem<br>&gt; <br>&gt; * There are Swift attributes: @autoclosure, @available, @objc, @noescape, @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>&gt; * There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, @IBOutlet<br>&gt; * There may be user-definable attributes under SE-0030: for example @lazy, @delayed; these are certainly attribute-ish, and it makes sense to present these using attribute-syntax.<br>&gt; * The attribute syntax using `@` has had an intention &quot;to open the space up to user attributes at some point&quot;<br>&gt; <br>&gt; &gt; Namespacing<br>&gt; <br>&gt; If Swift were to start accepting user-defined attributes,  it would need some way to differentiate and namespace potential conflicts. The most obvious solution looks like this:<br>&gt; <br>&gt; `@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`, `@Swift.noreturn`, `@Custom.lazy`, etc.<br>&gt; <br>&gt; Cumbersome, ugly, problematic.<br>&gt; <br>&gt; &gt; Modernization<br>&gt; <br>&gt; In my initial discussion for modernizing Swift attributes (https://gist.github.com/erica/29c1a7fb7f49324d572f &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;), I wanted to eliminate snakecase from @warn-unused-result and `mutable_variant`. Of these, the second is a no-brainer. Instead of the non-standard argument label `mutable_variant`, use `mutableVariant`. Problem solved.<br>&gt; <br>&gt; Converting `warn-unused-result` to the current standard of lowercase `warnunusedresult` produces a hard-to-read outcome. So in my write-up, I proposed the following amendments:<br>&gt; <br>&gt; @Autoclosure // was @autoclosure<br>&gt; @Available // was @available<br>&gt; @ObjC // was @objc<br>&gt; @NoEscape // was @noescape<br>&gt; @NonObjC // was @nonobjc<br>&gt; @NoReturn // was @noreturn<br>&gt; @Testable // was @testable<br>&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt; @Convention  // was @convention<br>&gt; @NoReturn // was @noreturn<br>&gt; <br>&gt; This was greeted somewhere between warmly and Siberian Winter depending on respondent. <br>&gt; <br>&gt; &gt; Possible Approaches<br>&gt; <br>&gt; After reading through Joe Groff&#39;s update to SE-0030, I&#39;d like to push this again in a broader context (which is why I&#39;m starting a new email thread). <br>&gt; <br>&gt; * Is traditional namespacing the way to go? <br>&gt; * Could a simpler solution to upper camel all system-supplied attributes and lower camel all custom attributes be sufficient?<br>&gt; * Could any other &quot;custom&quot; decoration differentiate the two with easy parsing: for example @@lazy, @@delayed for custom and single-@ tokens for system supplied?<br>&gt; * Should I simply back off on modernizing warn-unused-result until SE-0030 is resolved?<br>&gt; <br>&gt; What are your thoughts?<br></p><p>Once we open the floodgates for user-defined attributes, I think traditional namespacing and name lookup makes a lot of sense. We could conceptually namespace the existing hardcoded attributes into appropriate modules (Swift for the platform-neutral stuff, Foundation/AppKit/UIKit as appropriate for Appley stuff); name collisions would hopefully be rare enough that &quot;@Swift.AutoClosure&quot; or whatever hopefully won&#39;t often be necessary.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/c7b93cac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 2:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 12:17 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Here&#39;s a problem<br>&gt;&gt; <br>&gt;&gt; * There are Swift attributes: @autoclosure, @available, @objc, @noescape, @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>&gt;&gt; * There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, @IBOutlet<br>&gt;&gt; * There may be user-definable attributes under SE-0030: for example @lazy, @delayed; these are certainly attribute-ish, and it makes sense to present these using attribute-syntax.<br>&gt;&gt; * The attribute syntax using `@` has had an intention &quot;to open the space up to user attributes at some point&quot;<br>&gt;&gt; <br>&gt;&gt; &gt; Namespacing<br>&gt;&gt; <br>&gt;&gt; If Swift were to start accepting user-defined attributes,  it would need some way to differentiate and namespace potential conflicts. The most obvious solution looks like this:<br>&gt;&gt; <br>&gt;&gt; `@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`, `@Swift.noreturn`, `@Custom.lazy`, etc.<br>&gt;&gt; <br>&gt;&gt; Cumbersome, ugly, problematic.<br>&gt;&gt; <br>&gt;&gt; &gt; Modernization<br>&gt;&gt; <br>&gt;&gt; In my initial discussion for modernizing Swift attributes (https://gist.github.com/erica/29c1a7fb7f49324d572f &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;), I wanted to eliminate snakecase from @warn-unused-result and `mutable_variant`. Of these, the second is a no-brainer. Instead of the non-standard argument label `mutable_variant`, use `mutableVariant`. Problem solved.<br>&gt;&gt; <br>&gt;&gt; Converting `warn-unused-result` to the current standard of lowercase `warnunusedresult` produces a hard-to-read outcome. So in my write-up, I proposed the following amendments:<br>&gt;&gt; <br>&gt;&gt; @Autoclosure // was @autoclosure<br>&gt;&gt; @Available // was @available<br>&gt;&gt; @ObjC // was @objc<br>&gt;&gt; @NoEscape // was @noescape<br>&gt;&gt; @NonObjC // was @nonobjc<br>&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt; @Testable // was @testable<br>&gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt;&gt; @Convention  // was @convention<br>&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt; <br>&gt;&gt; This was greeted somewhere between warmly and Siberian Winter depending on respondent. <br>&gt;&gt; <br>&gt;&gt; &gt; Possible Approaches<br>&gt;&gt; <br>&gt;&gt; After reading through Joe Groff&#39;s update to SE-0030, I&#39;d like to push this again in a broader context (which is why I&#39;m starting a new email thread). <br>&gt;&gt; <br>&gt;&gt; * Is traditional namespacing the way to go? <br>&gt;&gt; * Could a simpler solution to upper camel all system-supplied attributes and lower camel all custom attributes be sufficient?<br>&gt;&gt; * Could any other &quot;custom&quot; decoration differentiate the two with easy parsing: for example @@lazy, @@delayed for custom and single-@ tokens for system supplied?<br>&gt;&gt; * Should I simply back off on modernizing warn-unused-result until SE-0030 is resolved?<br>&gt;&gt; <br>&gt;&gt; What are your thoughts?<br>&gt; <br>&gt; Once we open the floodgates for user-defined attributes, I think traditional namespacing and name lookup makes a lot of sense. We could conceptually namespace the existing hardcoded attributes into appropriate modules (Swift for the platform-neutral stuff, Foundation/AppKit/UIKit as appropriate for Appley stuff); name collisions would hopefully be rare enough that &quot;@Swift.AutoClosure&quot; or whatever hopefully won&#39;t often be necessary.<br>&gt; <br>&gt; -Joe<br></p><p><br>That would solve stuff. <br></p><p>How do you feel about my upcasing the attributes for readability?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/df5b97b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 1:10 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 2:04 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 19, 2016, at 12:17 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Here&#39;s a problem<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * There are Swift attributes: @autoclosure, @available, @objc, @noescape, @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>&gt;&gt;&gt; * There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, @IBOutlet<br>&gt;&gt;&gt; * There may be user-definable attributes under SE-0030: for example @lazy, @delayed; these are certainly attribute-ish, and it makes sense to present these using attribute-syntax.<br>&gt;&gt;&gt; * The attribute syntax using `@` has had an intention &quot;to open the space up to user attributes at some point&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Namespacing<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If Swift were to start accepting user-defined attributes,  it would need some way to differentiate and namespace potential conflicts. The most obvious solution looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`, `@Swift.noreturn`, `@Custom.lazy`, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cumbersome, ugly, problematic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Modernization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my initial discussion for modernizing Swift attributes (https://gist.github.com/erica/29c1a7fb7f49324d572f &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;), I wanted to eliminate snakecase from @warn-unused-result and `mutable_variant`. Of these, the second is a no-brainer. Instead of the non-standard argument label `mutable_variant`, use `mutableVariant`. Problem solved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Converting `warn-unused-result` to the current standard of lowercase `warnunusedresult` produces a hard-to-read outcome. So in my write-up, I proposed the following amendments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @Autoclosure // was @autoclosure<br>&gt;&gt;&gt; @Available // was @available<br>&gt;&gt;&gt; @ObjC // was @objc<br>&gt;&gt;&gt; @NoEscape // was @noescape<br>&gt;&gt;&gt; @NonObjC // was @nonobjc<br>&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt; @Testable // was @testable<br>&gt;&gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt;&gt;&gt; @Convention  // was @convention<br>&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This was greeted somewhere between warmly and Siberian Winter depending on respondent. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Possible Approaches<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After reading through Joe Groff&#39;s update to SE-0030, I&#39;d like to push this again in a broader context (which is why I&#39;m starting a new email thread). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Is traditional namespacing the way to go? <br>&gt;&gt;&gt; * Could a simpler solution to upper camel all system-supplied attributes and lower camel all custom attributes be sufficient?<br>&gt;&gt;&gt; * Could any other &quot;custom&quot; decoration differentiate the two with easy parsing: for example @@lazy, @@delayed for custom and single-@ tokens for system supplied?<br>&gt;&gt;&gt; * Should I simply back off on modernizing warn-unused-result until SE-0030 is resolved?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are your thoughts?<br>&gt;&gt; <br>&gt;&gt; Once we open the floodgates for user-defined attributes, I think traditional namespacing and name lookup makes a lot of sense. We could conceptually namespace the existing hardcoded attributes into appropriate modules (Swift for the platform-neutral stuff, Foundation/AppKit/UIKit as appropriate for Appley stuff); name collisions would hopefully be rare enough that &quot;@Swift.AutoClosure&quot; or whatever hopefully won&#39;t often be necessary.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; <br>&gt; That would solve stuff. <br>&gt; <br>&gt; How do you feel about my upcasing the attributes for readability?<br></p><p>Uppercasing seems reasonable to me.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/b67e7920/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3f3cb1bca3feed6f54a74c095a8b24b?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>Eli Hini</string> &lt;ehini at venovis.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>Erica and Joe,<br>Upcasing would be fine but are we going to combine it with traditional namespacing ? <br></p><p>Eli <br></p><p>&gt; On Feb 19, 2016, at 13:17, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Feb 19, 2016, at 1:10 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 19, 2016, at 2:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 19, 2016, at 12:17 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Here&#39;s a problem<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * There are Swift attributes: @autoclosure, @available, @objc, @noescape, @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>&gt;&gt;&gt;&gt; * There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, @IBOutlet<br>&gt;&gt;&gt;&gt; * There may be user-definable attributes under SE-0030: for example @lazy, @delayed; these are certainly attribute-ish, and it makes sense to present these using attribute-syntax.<br>&gt;&gt;&gt;&gt; * The attribute syntax using `@` has had an intention &quot;to open the space up to user attributes at some point&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Namespacing<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If Swift were to start accepting user-defined attributes,  it would need some way to differentiate and namespace potential conflicts. The most obvious solution looks like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`, `@Swift.noreturn`, `@Custom.lazy`, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cumbersome, ugly, problematic.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Modernization<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my initial discussion for modernizing Swift attributes (https://gist.github.com/erica/29c1a7fb7f49324d572f), I wanted to eliminate snakecase from @warn-unused-result and `mutable_variant`. Of these, the second is a no-brainer. Instead of the non-standard argument label `mutable_variant`, use `mutableVariant`. Problem solved.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Converting `warn-unused-result` to the current standard of lowercase `warnunusedresult` produces a hard-to-read outcome. So in my write-up, I proposed the following amendments:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @Autoclosure // was @autoclosure<br>&gt;&gt;&gt;&gt; @Available // was @available<br>&gt;&gt;&gt;&gt; @ObjC // was @objc<br>&gt;&gt;&gt;&gt; @NoEscape // was @noescape<br>&gt;&gt;&gt;&gt; @NonObjC // was @nonobjc<br>&gt;&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt;&gt; @Testable // was @testable<br>&gt;&gt;&gt;&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt;&gt;&gt;&gt; @Convention  // was @convention<br>&gt;&gt;&gt;&gt; @NoReturn // was @noreturn<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This was greeted somewhere between warmly and Siberian Winter depending on respondent. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Possible Approaches<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After reading through Joe Groff&#39;s update to SE-0030, I&#39;d like to push this again in a broader context (which is why I&#39;m starting a new email thread). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Is traditional namespacing the way to go? <br>&gt;&gt;&gt;&gt; * Could a simpler solution to upper camel all system-supplied attributes and lower camel all custom attributes be sufficient?<br>&gt;&gt;&gt;&gt; * Could any other &quot;custom&quot; decoration differentiate the two with easy parsing: for example @@lazy, @@delayed for custom and single-@ tokens for system supplied?<br>&gt;&gt;&gt;&gt; * Should I simply back off on modernizing warn-unused-result until SE-0030 is resolved?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What are your thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Once we open the floodgates for user-defined attributes, I think traditional namespacing and name lookup makes a lot of sense. We could conceptually namespace the existing hardcoded attributes into appropriate modules (Swift for the platform-neutral stuff, Foundation/AppKit/UIKit as appropriate for Appley stuff); name collisions would hopefully be rare enough that &quot;@Swift.AutoClosure&quot; or whatever hopefully won&#39;t often be necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That would solve stuff. <br>&gt;&gt; <br>&gt;&gt; How do you feel about my upcasing the attributes for readability?<br>&gt; <br>&gt; Uppercasing seems reasonable to me.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/5a56d432/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 19, 2016 at 09:00:00pm</p></header><div class="content"><p>On Fri, Feb 19, 2016 at 1:05 PM Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 19, 2016, at 12:17 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt; *&gt; Here&#39;s a problem*<br>&gt;<br>&gt; * There are Swift attributes: @autoclosure, @available, @objc, @noescape,<br>&gt; @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>&gt; * There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged,<br>&gt; @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable,<br>&gt; @IBOutlet<br>&gt; * There may be user-definable attributes under SE-0030: for example @lazy,<br>&gt; @delayed; these are certainly attribute-ish, and it makes sense to present<br>&gt; these using attribute-syntax.<br>&gt; * The attribute syntax using `@` has had an intention &quot;to open the space<br>&gt; up to user attributes at some point&quot;<br>&gt;<br>&gt; *&gt; Namespacing*<br>&gt;<br>&gt; If Swift were to start accepting user-defined attributes,  it would need<br>&gt; some way to differentiate and namespace potential conflicts. The most<br>&gt; obvious solution looks like this:<br>&gt;<br>&gt; `@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`,<br>&gt; `@Swift.noreturn`, `@Custom.lazy`, etc.<br>&gt;<br>&gt; Cumbersome, ugly, problematic.<br>&gt;<br>&gt; Once we open the floodgates for user-defined attributes, I think<br>&gt; traditional namespacing and name lookup makes a lot of sense. We could<br>&gt; conceptually namespace the existing hardcoded attributes into appropriate<br>&gt; modules (Swift for the platform-neutral stuff, Foundation/AppKit/UIKit as<br>&gt; appropriate for Appley stuff); name collisions would hopefully be rare<br>&gt; enough that &quot;@Swift.AutoClosure&quot; or whatever hopefully won&#39;t often be<br>&gt; necessary.<br>&gt;<br></p><p> Yeah I agree but I personally struggling with how it will play out.<br></p><p>For example given attributes are often only valid in narrow semantic<br>contexts. The compiler will enforce the semantics as needed of course and a<br>human reading the code would likely understand the attribute in the context<br>as written.<br></p><p>A human however may not easily understand the context in which a given<br>attribute could be used especially if user defined ones start popping up.<br>...so is a naming methodology used to help, e.g.<br>@Swift.PropertyBehaviour.lazy? or @MyStuff.PropertyBehaviour.extraLazy? ...<br>however this quickly become overly verbose and likely ill-defined in<br>naming, etc. Also it can duplicate what already can be understood from the<br>usage context.<br></p><p>Sorry handing waving about this nothing clear to add on a way forward. It<br>could imply contraction of problem domain to a more solvable one for a<br>first iteration or two on this unless things are better understood in<br>actually usage.<br></p><p>-Shawn<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/106f0b3b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 21, 2016 at 05:00:00pm</p></header><div class="content"><p>There was discussion about having property behaviors be addressable via @ as well,<br></p><p>self.state at lazy.reset() or the like<br></p><p>I would imagine the ability to namespace attributes would impact this?<br></p><p>-DW<br></p><p>&gt; On Feb 19, 2016, at 2:04 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Once we open the floodgates for user-defined attributes, I think traditional namespacing and name lookup makes a lot of sense. We could conceptually namespace the existing hardcoded attributes into appropriate modules (Swift for the platform-neutral stuff, Foundation/AppKit/UIKit as appropriate for Appley stuff); name collisions would hopefully be rare enough that &quot;@Swift.AutoClosure&quot; or whatever hopefully won&#39;t often be necessary.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160221/c9a3fad3/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160221/c9a3fad3/attachment.p7s&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; * There are Swift attributes: @autoclosure, @available, @objc, @noescape, @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>&gt; * There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, @IBOutlet<br>&gt; * There may be user-definable attributes under SE-0030: for example @lazy, @delayed; these are certainly attribute-ish, and it makes sense to present these using attribute-syntax.<br>&gt; * The attribute syntax using `@` has had an intention &quot;to open the space up to user attributes at some point&quot;<br></p><p>I don&#39;t think this is a problem in and of itself. All the things that can come after an @ are attributes; behaviors allow you to declare your own attributes with a (small, but hopefully growing over time) subset of the full attribute semantics.<br></p><p>&gt; &gt; Namespacing<br>&gt; <br>&gt; If Swift were to start accepting user-defined attributes,  it would need some way to differentiate and namespace potential conflicts. The most obvious solution looks like this:<br>&gt; <br>&gt; `@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`, `@Swift.noreturn`, `@Custom.lazy`, etc.<br>&gt; <br>&gt; Cumbersome, ugly, problematic.<br></p><p>This *is* cumbersome and ugly, but so is `Foundation.NSArray`. You only fully qualify identifiers when the extra precision is necessary. Sure, it means you should try to give behaviors names that don&#39;t conflict with modules you&#39;re likely to work with (including the standard library), but this is already true of all Swift global symbols, including top-level type names. So I don&#39;t think this is problematic at all.<br></p><p>(Incidentally, I assume that `@Custom.lazy` comes from a module called &quot;Custom&quot;, not that &quot;Custom&quot; is a prefix for all behaviors.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 20, 2016 at 06:00:00pm</p></header><div class="content"><p>And revised with feedback:  Modernizing Attribute Cases and Argument Naming &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;<br></p><p>This discussion seems to be drawing to a natural close, so please let me know if there are any gaping issues that remain as well as any quibbles. Thank you, -- Erica<br></p><p>Modernizing Attribute Case and Attribute Argument Naming<br></p><p>Proposal: TBD<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br></p><p> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#introduction&gt;Introduction<br></p><p>Two isolated instances of snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; remain in the Swift attribute grammar. This proposal updates those elements to bring them into compliance with modern Swift language standards and applies a new consistent pattern to existing attributes.<br></p><p>The Swift-Evolution discussion of this topic took place in the [Discussion] Modernizing Attribute Case and Attribute Argument Naming &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7335&gt; thread. Hat tip to Michael Well, Dmitri Gribenko, Brent Royal-Gordon, Shawn Erickson, Dany St-Amant<br></p><p><br> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#motivation&gt;Motivation<br></p><p>Two elements of Swift attribute grammar retain lower_snake_case patterns: Swift&#39;s warn_unused_result attribute and its mutable_variant argument. This pattern is being actively eliminated from Swift in an effort to modernize the language and adopt common naming patterns. Renaming these elements fall into two separate problems: one trivial, one forward-looking.<br></p><p><br> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#detail-design-updating-the-mutable_variant-argument&gt;Detail Design: Updating the mutable_variant argument<br></p><p>The mutable_variant argument refactor is minimal. It should use the lower camel case Swift standard for arguments and be renamed mutableVariant. <br></p><p><br> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#detail-design-updating-the-warn_unused_result-attribute&gt;Detail Design: Updating the warn_unused_result attribute<br></p><p>In the current version of Swift, most native attributes use lowercase naming: for example @testable and noescape. The most natural approach is to mimic this with @warn-unused-result, namely @warnunusedresult.<br></p><p>While this lower case pattern matches other compound attribute examples: objc, noescape, nonobjc, and noreturn, the re-engineered version of warnunusedresult is hard to read. It looks like a continuous string of lowercase characters instead of punching clear, identifiable semantic elements. Using lowercase for complex attributes names, including future names yet to be introduced into the language, becomes confusing when used with longer compound examples.<br></p><p>For this reason, I recommend the Swift team adopt an upper camel case convention for attributes, matching the existing Cocoa participants: UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, and IBOutlet. This approach avoids the otherwise confusing long name issue.<br></p><p>The renamed elements look like this:<br></p><p>@Autoclosure // was @autoclosure<br>@Available // was @available<br>@ObjC // was @objc<br>@NoEscape // was @noescape<br>@NonObjC // was @nonobjc<br>@NoReturn // was @noreturn<br>@Testable // was @testable<br>@WarnUnusedResult // was @warn-unused-result<br>@Convention  // was @convention<br>@NoReturn // was @noreturn<br>Here is the public declaration of sort() in Swift 2.2:<br></p><p>@warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>public func sort() -&gt; [Self.Generator.Element]<br>This is the proposed public declaration of sort() in Swift 3.0:<br></p><p>@WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>public func sort() -&gt; [Self.Generator.Element]<br>This revised example uses an argument colon (as proposed in &quot;Replacing Equal Signs with Colons For Attribute Arguments&quot;) rather than the equal sign currently specified in Swift 2.2<br></p><p><br> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#se-0030-impact&gt;SE-0030 Impact<br></p><p>Joe Groff&#39;s Swift-Evolution SE-0030 Property Behaviors &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt; proposal introduces property implementation patterns using attributes to declare behavior function names, for example: @lazy and @deferred.<br></p><p>If Swift were to start accepting user-defined attributes, it needs a way to differentiate potential conflicts. The most obvious solution uses namespacing, for example @Swift.Autoclosure, @UIKit.UIApplicationMain, @UIKit.IBOutlet, @Swift.NoReturn, @StdLib.lazy, @Custom.deferred, etc. <br></p><p>@AttributeName // built-in, upper camel case<br>@attributename // or @attributeName, custom element that may not follow built-in patterns<br>@Module.AttributeName // case follows source convention<br>Name collisions should be limited enough that fully-qualified attributes would be rare, as they already are with top-level calls such as differentiating NSView&#39;s print function (print a view) from Swift&#39;s (output to the console or custom stream).<br></p><p>Joe Groff writes, &quot;Once we open the floodgates for user-defined attributes, I think traditional namespacing and name lookup makes a lot of sense. We could conceptually namespace the existing hardcoded attributes into appropriate modules (Swift for the platform-neutral stuff, Foundation/AppKit/UIKit as appropriate for Apple-y stuff).&quot;<br></p><p><br> &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#alternatives-considered&gt;Alternatives Considered<br></p><p>Reaction to upper-case naming has been mixed. I personally believe the redesign is more readable. Others object to using uppercase outside of types, even though Cocoa imports are already doing so. Although the Swift team might prefer using lower camel case @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn but this would be out of step with non-native Swift attributes, specifically UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, and IBOutlet<br></p><p>Dany St-Amant suggests that attributes be case-insensitive, enabling coders to choose their casing. &quot;[Maybe] cases could be ignored, making everybody writing code happy, and everyone reading code of others unhappy&quot;<br></p><p><br></p><p>&gt; On Feb 19, 2016, at 4:31 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; * There are Swift attributes: @autoclosure, @available, @objc, @noescape, @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>&gt;&gt; * There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, @IBOutlet<br>&gt;&gt; * There may be user-definable attributes under SE-0030: for example @lazy, @delayed; these are certainly attribute-ish, and it makes sense to present these using attribute-syntax.<br>&gt;&gt; * The attribute syntax using `@` has had an intention &quot;to open the space up to user attributes at some point&quot;<br>&gt; <br>&gt; I don&#39;t think this is a problem in and of itself. All the things that can come after an @ are attributes; behaviors allow you to declare your own attributes with a (small, but hopefully growing over time) subset of the full attribute semantics.<br>&gt; <br>&gt;&gt;&gt; Namespacing<br>&gt;&gt; <br>&gt;&gt; If Swift were to start accepting user-defined attributes,  it would need some way to differentiate and namespace potential conflicts. The most obvious solution looks like this:<br>&gt;&gt; <br>&gt;&gt; `@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`, `@Swift.noreturn`, `@Custom.lazy`, etc.<br>&gt;&gt; <br>&gt;&gt; Cumbersome, ugly, problematic.<br>&gt; <br>&gt; This *is* cumbersome and ugly, but so is `Foundation.NSArray`. You only fully qualify identifiers when the extra precision is necessary. Sure, it means you should try to give behaviors names that don&#39;t conflict with modules you&#39;re likely to work with (including the standard library), but this is already true of all Swift global symbols, including top-level type names. So I don&#39;t think this is problematic at all.<br>&gt; <br>&gt; (Incidentally, I assume that `@Custom.lazy` comes from a module called &quot;Custom&quot;, not that &quot;Custom&quot; is a prefix for all behaviors.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/20c7539a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Further Discussion] Naming Attributes</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February 25, 2016 at 08:00:00am</p></header><div class="content"><p>+1 as long as we keep user-defined attributes (SE0030) lowerCamelCase<br></p><p>&gt; On 21 Feb 2016, at 02:11, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And revised with feedback:  Modernizing Attribute Cases and Argument Naming &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f&gt;<br>&gt; <br>&gt; This discussion seems to be drawing to a natural close, so please let me know if there are any gaping issues that remain as well as any quibbles. Thank you, -- Erica<br>&gt; <br>&gt; Modernizing Attribute Case and Attribute Argument Naming<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#introduction&gt;Introduction<br>&gt; <br>&gt; Two isolated instances of snake case &lt;https://en.wikipedia.org/wiki/Snake_case&gt; remain in the Swift attribute grammar. This proposal updates those elements to bring them into compliance with modern Swift language standards and applies a new consistent pattern to existing attributes.<br>&gt; <br>&gt; The Swift-Evolution discussion of this topic took place in the [Discussion] Modernizing Attribute Case and Attribute Argument Naming &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/7335&gt; thread. Hat tip to Michael Well, Dmitri Gribenko, Brent Royal-Gordon, Shawn Erickson, Dany St-Amant<br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#motivation&gt;Motivation<br>&gt; <br>&gt; Two elements of Swift attribute grammar retain lower_snake_case patterns: Swift&#39;s warn_unused_result attribute and its mutable_variant argument. This pattern is being actively eliminated from Swift in an effort to modernize the language and adopt common naming patterns. Renaming these elements fall into two separate problems: one trivial, one forward-looking.<br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#detail-design-updating-the-mutable_variant-argument&gt;Detail Design: Updating the mutable_variant argument<br>&gt; <br>&gt; The mutable_variant argument refactor is minimal. It should use the lower camel case Swift standard for arguments and be renamed mutableVariant. <br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#detail-design-updating-the-warn_unused_result-attribute&gt;Detail Design: Updating the warn_unused_result attribute<br>&gt; <br>&gt; In the current version of Swift, most native attributes use lowercase naming: for example @testable and noescape. The most natural approach is to mimic this with @warn-unused-result, namely @warnunusedresult.<br>&gt; <br>&gt; While this lower case pattern matches other compound attribute examples: objc, noescape, nonobjc, and noreturn, the re-engineered version of warnunusedresult is hard to read. It looks like a continuous string of lowercase characters instead of punching clear, identifiable semantic elements. Using lowercase for complex attributes names, including future names yet to be introduced into the language, becomes confusing when used with longer compound examples.<br>&gt; <br>&gt; For this reason, I recommend the Swift team adopt an upper camel case convention for attributes, matching the existing Cocoa participants: UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, and IBOutlet. This approach avoids the otherwise confusing long name issue.<br>&gt; <br>&gt; The renamed elements look like this:<br>&gt; <br>&gt; @Autoclosure // was @autoclosure<br>&gt; @Available // was @available<br>&gt; @ObjC // was @objc<br>&gt; @NoEscape // was @noescape<br>&gt; @NonObjC // was @nonobjc<br>&gt; @NoReturn // was @noreturn<br>&gt; @Testable // was @testable<br>&gt; @WarnUnusedResult // was @warn-unused-result<br>&gt; @Convention  // was @convention<br>&gt; @NoReturn // was @noreturn<br>&gt; Here is the public declaration of sort() in Swift 2.2:<br>&gt; <br>&gt; @warn_unused_result(mutable_variant=&quot;sortInPlace&quot;)<br>&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; This is the proposed public declaration of sort() in Swift 3.0:<br>&gt; <br>&gt; @WarnUnusedResult(mutableVariant: &quot;sortInPlace&quot;)<br>&gt; public func sort() -&gt; [Self.Generator.Element]<br>&gt; This revised example uses an argument colon (as proposed in &quot;Replacing Equal Signs with Colons For Attribute Arguments&quot;) rather than the equal sign currently specified in Swift 2.2<br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#se-0030-impact&gt;SE-0030 Impact<br>&gt; <br>&gt; Joe Groff&#39;s Swift-Evolution SE-0030 Property Behaviors &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md&gt; proposal introduces property implementation patterns using attributes to declare behavior function names, for example: @lazy and @deferred.<br>&gt; <br>&gt; If Swift were to start accepting user-defined attributes, it needs a way to differentiate potential conflicts. The most obvious solution uses namespacing, for example @Swift.Autoclosure, @UIKit.UIApplicationMain, @UIKit.IBOutlet, @Swift.NoReturn, @StdLib.lazy, @Custom.deferred, etc. <br>&gt; <br>&gt; @AttributeName // built-in, upper camel case<br>&gt; @attributename // or @attributeName, custom element that may not follow built-in patterns<br>&gt; @Module.AttributeName // case follows source convention<br>&gt; Name collisions should be limited enough that fully-qualified attributes would be rare, as they already are with top-level calls such as differentiating NSView&#39;s print function (print a view) from Swift&#39;s (output to the console or custom stream).<br>&gt; <br>&gt; Joe Groff writes, &quot;Once we open the floodgates for user-defined attributes, I think traditional namespacing and name lookup makes a lot of sense. We could conceptually namespace the existing hardcoded attributes into appropriate modules (Swift for the platform-neutral stuff, Foundation/AppKit/UIKit as appropriate for Apple-y stuff).&quot;<br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/29c1a7fb7f49324d572f#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Reaction to upper-case naming has been mixed. I personally believe the redesign is more readable. Others object to using uppercase outside of types, even though Cocoa imports are already doing so. Although the Swift team might prefer using lower camel case @autoClosure, @available, @objC, @noEscape, @nonObjC, @noReturn, @testable, @warnUnusedResult, @convention, @noReturn but this would be out of step with non-native Swift attributes, specifically UIApplicationMain, NSManaged, NSCopying, NSApplicationMain, IBAction, IBDesignable, IBInspectable, and IBOutlet<br>&gt; <br>&gt; Dany St-Amant suggests that attributes be case-insensitive, enabling coders to choose their casing. &quot;[Maybe] cases could be ignored, making everybody writing code happy, and everyone reading code of others unhappy&quot;<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 4:31 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; * There are Swift attributes: @autoclosure, @available, @objc, @noescape, @nonobjc, @noreturn, @testable, @warn-unused-result, @convention, @noreturn.<br>&gt;&gt;&gt; * There are ObjC-ish/Xcode-ish attributes: @UIApplicationMain, @NSManaged, @NSCopying, @NSApplicationMain, @IBAction, @IBDesignable, @IBInspectable, @IBOutlet<br>&gt;&gt;&gt; * There may be user-definable attributes under SE-0030: for example @lazy, @delayed; these are certainly attribute-ish, and it makes sense to present these using attribute-syntax.<br>&gt;&gt;&gt; * The attribute syntax using `@` has had an intention &quot;to open the space up to user attributes at some point&quot;<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think this is a problem in and of itself. All the things that can come after an @ are attributes; behaviors allow you to declare your own attributes with a (small, but hopefully growing over time) subset of the full attribute semantics.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Namespacing<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If Swift were to start accepting user-defined attributes,  it would need some way to differentiate and namespace potential conflicts. The most obvious solution looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `@Swift.autoclosure`, `@UIKit.UIApplicationMain`, `@UIKit.IBOutlet`, `@Swift.noreturn`, `@Custom.lazy`, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cumbersome, ugly, problematic.<br>&gt;&gt; <br>&gt;&gt; This *is* cumbersome and ugly, but so is `Foundation.NSArray`. You only fully qualify identifiers when the extra precision is necessary. Sure, it means you should try to give behaviors names that don&#39;t conflict with modules you&#39;re likely to work with (including the standard library), but this is already true of all Swift global symbols, including top-level type names. So I don&#39;t think this is problematic at all.<br>&gt;&gt; <br>&gt;&gt; (Incidentally, I assume that `@Custom.lazy` comes from a module called &quot;Custom&quot;, not that &quot;Custom&quot; is a prefix for all behaviors.)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/3c209870/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
