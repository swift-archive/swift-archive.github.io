<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/33d319d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>January  6, 2016 at 04:00:00am</p></header><div class="content"><p>Yes, I see now your point about the protocol and extension being<br>third-party. That is a major problem indeed. I agree with you that<br>Greg Parker has suggested probably the most promising way forward on<br>this. Certainly not as easy as I&#39;d imagined it to be.<br></p><p><br>On Wed, Jan 6, 2016 at 4:02 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; I have nothing against small protocols with a defined purpose, on the<br>&gt; contrary I am accustomed to type classes in Haskell which are typically very<br>&gt; small.<br>&gt; The problem is that these &quot;default&quot; protocols do not serve a well defined<br>&gt; purpose - they only exist to work around a deficiency in expressibility.<br>&gt;<br>&gt; The point about the protocol not being under my control is the following<br>&gt; (actually it is more about the extension with the default implementation not<br>&gt; being under my control): imagine the protocol and especially the extension<br>&gt; with default implementations for methods of that protocol is a third party<br>&gt; protocol, i.e. protocol BooType and extension BooType are part of a third<br>&gt; party library. In that case I cannot split off the default implementations<br>&gt; into sub protocols.<br>&gt;<br>&gt; Maybe some concise syntax can be found to bind the existing implementation<br>&gt; to the protocol when conforming existing classes or structs to a protocol,<br>&gt; like Greg Parker suggested.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 06. Januar 2016 um 10:50 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt; You&#39;re quite right: in the worst case, the number of protocols you<br>&gt; would need would be linear to the number of methods. It&#39;s not the<br>&gt; best, I will concede. It does seem to be rather the &quot;Swifty&quot; way,<br>&gt; though. At least, if we follow the example of the Swift standard<br>&gt; library, it&#39;s not discouraged. Consider that the protocol hierarchy<br>&gt; for Int already has 26 protocols<br>&gt; (http://blog.krzyzanowskim.com/2015/03/01/swift_madness_of_generic_integer/).<br>&gt; What harm is there in another 3 or 4, or even 10--provided that each<br>&gt; is clearly named, serves a defined purpose, and is composed together<br>&gt; in something of a logical way?<br>&gt;<br>&gt; I don&#39;t understand your point about controlling the protocol. Perhaps<br>&gt; you could explain? As far as I can tell, in my example BooType doesn&#39;t<br>&gt; need to be under your control or modified. If you extend Bar with<br>&gt; DefaultBooType, then (Bar is BooType == true).<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 6, 2016 at 3:32 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt; That&#39;s a good argument, but I&#39;m not convinced: not only do I have to define<br>&gt;<br>&gt; additional protocols (&quot;DefaultXXX&quot;) but in the worst case I have to do this<br>&gt;<br>&gt; for each method declared in my protocol (which makes naming these default<br>&gt;<br>&gt; protocols even worse, because XXX now has to represent the method), i.e.<br>&gt;<br>&gt;<br>&gt; protocol BooType {<br>&gt;<br>&gt; func someBoo()<br>&gt;<br>&gt; func anotherBoo()<br>&gt;<br>&gt; func yetAnotherBoo()<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; when given:<br>&gt;<br>&gt;<br>&gt; struct Foo {<br>&gt;<br>&gt; func someBoo() { print(&quot;foo boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; struct Bar {<br>&gt;<br>&gt; func anotherBoo() { print(&quot;bar boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; struct Baz {<br>&gt;<br>&gt; func anotherBoo() { print(&quot;baz boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I would have to define all of the following:<br>&gt;<br>&gt;<br>&gt; protocol DefaultBooTypeSomeBoo : BooType { }<br>&gt;<br>&gt; extension DefaultBooTypeSomeBoo {<br>&gt;<br>&gt; func someBoo() { print(&quot;some boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; protocol DefaultBooTypeAnotherBoo : BooType { }<br>&gt;<br>&gt; extension DefaultBooTypeAnotherBoo {<br>&gt;<br>&gt; func anotherBoo() { print(&quot;another boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; protocol DefaultBooTypeYetAnotherBoo : BooType { }<br>&gt;<br>&gt; extension DefaultBooTypeYetAnotherBoo {<br>&gt;<br>&gt; func yetAnotherBoo() { print(&quot;yet another boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Even worse: if the protocol itself is not under my control I cannot even do<br>&gt;<br>&gt; this (not even for the simple case you demonstrated)!<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Am 06. Januar 2016 um 09:36 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt;<br>&gt; The pattern might exist for some existing classes or structs but it might<br>&gt;<br>&gt; still be useful for new classes or even for some existing ones to provide a<br>&gt;<br>&gt; default implementation.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I agree. It could be very useful in certain circumstances, and I agree<br>&gt;<br>&gt; that any proposal that made this no longer possible would be a<br>&gt;<br>&gt; non-starter. I had to think about this point for a bit; I hope I can<br>&gt;<br>&gt; convince you that it would remain possible if overriding methods had<br>&gt;<br>&gt; to use a keyword. The way it would be done would be valid code today,<br>&gt;<br>&gt; and I think after some reflection that it&#39;s a superior way of doing<br>&gt;<br>&gt; things even in today&#39;s Swift syntax because it&#39;s more explicit about<br>&gt;<br>&gt; what&#39;s going on.<br>&gt;<br>&gt;<br>&gt; Example:<br>&gt;<br>&gt; Given three existing struct types--<br>&gt;<br>&gt;<br>&gt; struct Foo {<br>&gt;<br>&gt; func boo() { print(&quot;foo boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; struct Bar { }<br>&gt;<br>&gt; struct Baz { }<br>&gt;<br>&gt;<br>&gt; We wish to formalize after the fact, giving each type a method boo()<br>&gt;<br>&gt; with a default implementation. Currently, this is valid Swift code--<br>&gt;<br>&gt;<br>&gt; protocol BooType {<br>&gt;<br>&gt; func boo()<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension BooType {<br>&gt;<br>&gt; func boo() { print(&quot;default boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension Foo: BooType { }<br>&gt;<br>&gt; extension Bar: BooType { }<br>&gt;<br>&gt; extension Baz: BooType { }<br>&gt;<br>&gt;<br>&gt; As you point out rightly, this would be invalid if we had to write<br>&gt;<br>&gt; &quot;override func boo()&quot; in the body of struct Foo. However, this is<br>&gt;<br>&gt; valid Swift code both in today&#39;s syntax and if my proposal were to be<br>&gt;<br>&gt; implemented, and it is only one line longer--<br>&gt;<br>&gt;<br>&gt; protocol BooType {<br>&gt;<br>&gt; func boo()<br>&gt;<br>&gt; }<br>&gt;<br>&gt; protocol DefaultBooType: BooType { }<br>&gt;<br>&gt; extension DefaultBooType {<br>&gt;<br>&gt; func boo() { print(&quot;default boo&quot;) }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension Foo: BooType { }<br>&gt;<br>&gt; extension Bar: DefaultBooType { }<br>&gt;<br>&gt; extension Baz: DefaultBooType { }<br>&gt;<br>&gt;<br>&gt; I&#39;d like to promote the second option as being superior even in<br>&gt;<br>&gt; today&#39;s syntax. It is immediately clear to the reader that Foo().boo()<br>&gt;<br>&gt; invokes a different method than Bar().boo(), even if the reader does<br>&gt;<br>&gt; not have access to the original code for structs Foo, Bar, and Baz.<br>&gt;<br>&gt; Suppose those structs were supplied in a third-party library that&#39;s<br>&gt;<br>&gt; not well documented. It&#39;s plausible that a non-expert coder could try<br>&gt;<br>&gt; to formalize after the fact and write an extension BooType<br>&gt;<br>&gt; implementing boo() unaware that there is an overriding method in Foo.<br>&gt;<br>&gt; In today&#39;s Swift syntax, the code would compile and behave subtly<br>&gt;<br>&gt; differently from the author&#39;s expectations; as proposed, that code<br>&gt;<br>&gt; would lead to a compile-time error. However, an expert coder who<br>&gt;<br>&gt; intended to supply a default function but invoke any overriding<br>&gt;<br>&gt; methods could write code that is almost as succinct but also<br>&gt;<br>&gt; self-documenting, and in fact could do so today.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 6, 2016 at 12:45 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Am 06.01.2016 um 06:23 schrieb Xiaodi Wu via swift-evolution<br>&gt;<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; It would remain very much possible to formalize an existing pattern<br>&gt;<br>&gt; because, in the case of your example (unless I&#39;m misunderstanding?), you are<br>&gt;<br>&gt; not also providing a default implementation of the &quot;min&quot; and &quot;max&quot; getters,<br>&gt;<br>&gt; and the IntXX structs would have nothing to override. Indeed, you&#39;d hardly<br>&gt;<br>&gt; be formalizing an existing pattern if you had to supply de novo<br>&gt;<br>&gt; implementations!<br>&gt;<br>&gt;<br>&gt;<br>&gt; The pattern might exist for some existing classes or structs but it might<br>&gt;<br>&gt; still be useful for new classes or even for some existing ones to provide a<br>&gt;<br>&gt; default implementation.<br>&gt;<br>&gt;<br>&gt;<br>&gt; -Thorsten<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
