<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  7, 2016 at 10:00:00pm</p></header><div class="content"><p>Posted a new proposal, feedback appreciated:<br></p><p>https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md<br></p><p>One talking point raised already is the correct location for the attribute (parameter or type); I&#39;m undecided personally as there are arguments for both, probably not an important detail though (core team can make a decision on that I think), since the guidelines on attributes have been debated a few times already.<br></p><p>Also, no matter how much I use it I seem to be the worst at using the Github website, so apologies for my many mistakes on that side of things ;)<br></p><p>Variadics as Attribute<br></p><p>Proposal: SE-NNNN &lt;https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md&gt;<br>Author: Haravikk &lt;https://github.com/haravikk&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md#introduction&gt;Introduction<br></p><p>This proposal is for a redesign of the variadic function parameter syntax as an attribute for greater flexibility.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md#motivation&gt;Motivation<br></p><p>Currently Swift variadic functions cannot be called with an array of values, potentially requiring two declarations like so:<br></p><p>func someMethod&lt;C:Collection where C.Iterator.Element == Int&gt;(_ values:C) { … } // Regular method<br>func someMethod(_ values:Int...) { someMethod(values) } // Variadic method<br>In some cases this leads to only one being defined, forcing developers to use that particular style. When this is the variadic option this means the method is restricted in how it can be used, and parameters constructed.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md#proposed-solution&gt;Proposed solution<br></p><p>This proposal is to replace the current form of variadic declaration syntax (trailing elipsis) with a new attribute @variadicthat enables any suitable iterable parameter to be called in variadic form if desired.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md#detailed-design&gt;Detailed design<br></p><p>Quite simply, instead of a trailing elipsis, a variadic parameter will instead be defined via a new @variadic attribute which can be placed upon any function parameter with a type conforming to ArrayLiteralConvertible, or which is a generic constraint against IteratorProtocol, Sequence or Collection such that a default (such as Array) can be used to fulfil the variadic call. Otherwise variadic parameters can be specified with the same restrictions they have now (must not be ambiguous).<br></p><p>For example, consider the following variadic function:<br></p><p>func someMethod(_ values:Int...) { … }<br>Under this proposal the above can be rewritten as one of the following:<br></p><p>func someMethod(@variadic _ values:[Int]) { … } // Basic Array solution<br>func someMethod(@variadic _ values:Foo) { … }   // Foo is a custom ArrayLiteralConvertible type<br>func someMethod&lt;I:IteratorProtocol where I.Element == Int&gt;(@variadic _ values:I) { … } // Flexible, single-pass, generic solution<br>func someMethod&lt;S:Sequence where S.Iterator.Element == Int&gt;(@variadic _ values:S) { … } // Flexible, (probably) multi-pass, generic solution<br>func someMethod&lt;C:Collection where C.Iterator.Element == Int&gt;(@variadic _ values:C) { … } // Flexible, definitely multi-pass, indexed, generic solution<br>In this case the Iterator variation is preferred for greatest flexibility, but it will depend upon the actual requirements of the method. Any of these can be called as follows:<br></p><p>someMethod([1, 2, 3, 4, 5, 6])  // normal array-literal call for any of the above<br>someMethod(1, 2, 3, 4, 5, 6)    // variadic call, synonymous with array-literal call<br>someMethod(foo)                 // foo is an existing Array, Foo, Iterator, Sequence or Collection variable as appropriate<br>This altered declaration syntax has a number of advantages over existing variadics:<br></p><p>No requirement for a custom syntax (see alternatives however)<br>A single declaration can handle variadic and collection/sequence/iterator invocation (no need for some other workaround such as reflection).<br>Greater flexibility over the actual type of the variadic collection/sequence/iterator, not restricted to Array or array-like.<br>Developers are free to choose the syntax used at the call-site based upon preference (or pass a variable instead).<br>Declaration is more discoverable (option-click the @variadic attribute to view documenation).<br> &lt;https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This proposal as given would remove the existing variadic syntax (trailing elipsis), but a fix-it should enable easy conversion between the following:<br></p><p>func someMethod(_ values:Int...) { … } // Old style<br>func someMethod(@variadic _ values:[Int]) { … } // New style<br>However there is an alternative to consider below that will affect this.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md#alternatives-considered&gt;Alternatives considered<br></p><p>One alternative is to simply have the existing variadic syntax produce a method taking an array of the same type, that is implicitly capable of being used in variadic style (but also used directly with Array values). However this has less flexibility than the above, which permits non-Array types. A compromise could be to allow the existing style to remain as a shorthand, though this may discourage consideration of the most appropriate type (in general developers should be encouraged to accept generic types for greatest utility wherever possible, but if trailing elipsis is easy we may just end up with Array being used most often).<br></p><p>The other main alternative considered was removing variadics completely; while this is actually the preference of some (myself included), it seems a lot developers do not wish this. This proposal is intended as a compromise that coallesces variadics with regular functions, without eliminating the possibility to use either style at the call site as developers prefer.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/41ef08a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  7, 2016 at 06:00:00pm</p></header><div class="content"><p>I believe the alternative can be even simpler if you consider the type<br>of the variadic argument is in fact an array. The different syntax<br>tell the compiler it can relax on demanding an array for that argument<br>and allow multiple comma-separated values of the same declared type.<br>Nothing but the compiler complains if you try and pass an array there,<br>so the compiler could simply be updated to allow a list of arguments<br>or an array. Also, the compiler knows the type of the variadic<br>argument and the argument(s) you&#39;re passing so if you have &#39;Int...&#39; it<br>should be able to recognise a [Int] as a valid (ans single) value.<br></p><p>One other alternative (or complement) is to use ar simple syntax to<br>tell the compiler you want to use the values of an array. In Ruby the<br>equivalent of our &quot;args : String...&quot; is simply &quot;*args&quot; (no types in<br>Ruby) and I can use the array or pass it as a variadic argument to<br>another function by passing &quot;*args&quot; instead of simply &quot;args&quot;. It may<br>not be much nice visually but one could be able to use something like<br>&quot;args...&quot; here (I&#39;m open to other suggestions, of course) just to<br>explicit/ensure that is what you want to do.<br></p><p>IMHO there is nothing that could be gained here with the change in<br>syntax (perhaps only a clarification that a variadic argument is an<br>array of that type for someone new to the language, but that&#39;s still<br>more verbose). Even if we were to change the syntax it would still<br>require changes on how the compiler perceives the arguments passed to<br>a function and I think we&#39;d have less effort (and less breaking more<br>backward compatibility) if we just allow variadic arguments to receive<br>arrays of its type directly.<br></p><p>L<br></p><p><br>On 7 July 2016 at 18:15, Haravikk via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Posted a new proposal, feedback appreciated:<br>&gt;<br>&gt; https://github.com/Haravikk/swift-evolution/blob/2743411af02e3ac6761fbdd780ede1af4cc34ee7/proposals/0000-variadics-as-attribute.md<br>&gt;<br>&gt; One talking point raised already is the correct location for the attribute<br>&gt; (parameter or type); I&#39;m undecided personally as there are arguments for<br>&gt; both, probably not an important detail though (core team can make a decision<br>&gt; on that I think), since the guidelines on attributes have been debated a few<br>&gt; times already.<br>&gt;<br>&gt; Also, no matter how much I use it I seem to be the worst at using the Github<br>&gt; website, so apologies for my many mistakes on that side of things ;)<br>&gt;<br>&gt; Variadics as Attribute<br>&gt;<br>&gt; Proposal: SE-NNNN<br>&gt; Author: Haravikk<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal is for a redesign of the variadic function parameter syntax as<br>&gt; an attribute for greater flexibility.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Currently Swift variadic functions cannot be called with an array of values,<br>&gt; potentially requiring two declarations like so:<br>&gt;<br>&gt; func someMethod&lt;C:Collection where C.Iterator.Element == Int&gt;(_ values:C) {<br>&gt; … } // Regular method<br>&gt; func someMethod(_ values:Int...) { someMethod(values) } // Variadic method<br>&gt;<br>&gt; In some cases this leads to only one being defined, forcing developers to<br>&gt; use that particular style. When this is the variadic option this means the<br>&gt; method is restricted in how it can be used, and parameters constructed.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; This proposal is to replace the current form of variadic declaration syntax<br>&gt; (trailing elipsis) with a new attribute @variadicthat enables any suitable<br>&gt; iterable parameter to be called in variadic form if desired.<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; Quite simply, instead of a trailing elipsis, a variadic parameter will<br>&gt; instead be defined via a new @variadic attribute which can be placed upon<br>&gt; any function parameter with a type conforming to ArrayLiteralConvertible, or<br>&gt; which is a generic constraint against IteratorProtocol, Sequence or<br>&gt; Collection such that a default (such as Array) can be used to fulfil the<br>&gt; variadic call. Otherwise variadic parameters can be specified with the same<br>&gt; restrictions they have now (must not be ambiguous).<br>&gt;<br>&gt; For example, consider the following variadic function:<br>&gt;<br>&gt; func someMethod(_ values:Int...) { … }<br>&gt;<br>&gt; Under this proposal the above can be rewritten as one of the following:<br>&gt;<br>&gt; func someMethod(@variadic _ values:[Int]) { … } // Basic Array solution<br>&gt; func someMethod(@variadic _ values:Foo) { … }   // Foo is a custom<br>&gt; ArrayLiteralConvertible type<br>&gt; func someMethod&lt;I:IteratorProtocol where I.Element == Int&gt;(@variadic _<br>&gt; values:I) { … } // Flexible, single-pass, generic solution<br>&gt; func someMethod&lt;S:Sequence where S.Iterator.Element == Int&gt;(@variadic _<br>&gt; values:S) { … } // Flexible, (probably) multi-pass, generic solution<br>&gt; func someMethod&lt;C:Collection where C.Iterator.Element == Int&gt;(@variadic _<br>&gt; values:C) { … } // Flexible, definitely multi-pass, indexed, generic<br>&gt; solution<br>&gt;<br>&gt; In this case the Iterator variation is preferred for greatest flexibility,<br>&gt; but it will depend upon the actual requirements of the method. Any of these<br>&gt; can be called as follows:<br>&gt;<br>&gt; someMethod([1, 2, 3, 4, 5, 6])  // normal array-literal call for any of the<br>&gt; above<br>&gt; someMethod(1, 2, 3, 4, 5, 6)    // variadic call, synonymous with<br>&gt; array-literal call<br>&gt; someMethod(foo)                 // foo is an existing Array, Foo, Iterator,<br>&gt; Sequence or Collection variable as appropriate<br>&gt;<br>&gt; This altered declaration syntax has a number of advantages over existing<br>&gt; variadics:<br>&gt;<br>&gt; No requirement for a custom syntax (see alternatives however)<br>&gt; A single declaration can handle variadic and collection/sequence/iterator<br>&gt; invocation (no need for some other workaround such as reflection).<br>&gt; Greater flexibility over the actual type of the variadic<br>&gt; collection/sequence/iterator, not restricted to Array or array-like.<br>&gt; Developers are free to choose the syntax used at the call-site based upon<br>&gt; preference (or pass a variable instead).<br>&gt; Declaration is more discoverable (option-click the @variadic attribute to<br>&gt; view documenation).<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; This proposal as given would remove the existing variadic syntax (trailing<br>&gt; elipsis), but a fix-it should enable easy conversion between the following:<br>&gt;<br>&gt; func someMethod(_ values:Int...) { … } // Old style<br>&gt; func someMethod(@variadic _ values:[Int]) { … } // New style<br>&gt;<br>&gt; However there is an alternative to consider below that will affect this.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; One alternative is to simply have the existing variadic syntax produce a<br>&gt; method taking an array of the same type, that is implicitly capable of being<br>&gt; used in variadic style (but also used directly with Array values). However<br>&gt; this has less flexibility than the above, which permits non-Array types. A<br>&gt; compromise could be to allow the existing style to remain as a shorthand,<br>&gt; though this may discourage consideration of the most appropriate type (in<br>&gt; general developers should be encouraged to accept generic types for greatest<br>&gt; utility wherever possible, but if trailing elipsis is easy we may just end<br>&gt; up with Array being used most often).<br>&gt;<br>&gt; The other main alternative considered was removing variadics completely;<br>&gt; while this is actually the preference of some (myself included), it seems a<br>&gt; lot developers do not wish this. This proposal is intended as a compromise<br>&gt; that coallesces variadics with regular functions, without eliminating the<br>&gt; possibility to use either style at the call site as developers prefer.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 22:39, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; I think we&#39;d have less effort (and less breaking more<br>&gt; backward compatibility) if we just allow variadic arguments to receive<br>&gt; arrays of its type directly.<br></p><p>This proposal doesn&#39;t just handle the issue of passing an array however, it also allows variadics of any type of your choice (so long as it conforms to ArrayLiteralConvertible) rather than it always being an Array. Likewise it would also support any generic iterator, sequence or collection; while calling the function in variadic style would just result in some default type behind the scenes, you can also pass in anything you like using a variable (just like you can to a regular method).<br></p><p>Also one other advantage I didn&#39;t list is that an attribute could support future extensions, for example the ability to set something like @variadic(minimum: 1), causing the compiler to produce an error if a variadic call is empty. Beyond the scope of this initial proposal, but basically this seems a much more flexible way to do things than trying to layer support onto the existing syntax, though it could be retained as a shorthand.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July  8, 2016 at 08:00:00am</p></header><div class="content"><p>I like this proposal. I was a bit against when the discussion around the removal of variadics arose, but I fee that this proposal takes a good whack at the problem. <br></p><p>I have struggled with array vs. variadic arguments for several methods, ending up implementing both overloads and the variadic method only passed the arguments to the overload that took an array as an argument. This would nicely eliminate the need for such &quot;hacks&quot;.<br></p><p>&gt; On Jul 8, 2016, at 12:03 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Jul 2016, at 22:39, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think we&#39;d have less effort (and less breaking more<br>&gt;&gt; backward compatibility) if we just allow variadic arguments to receive<br>&gt;&gt; arrays of its type directly.<br>&gt; <br>&gt; This proposal doesn&#39;t just handle the issue of passing an array however, it also allows variadics of any type of your choice (so long as it conforms to ArrayLiteralConvertible) rather than it always being an Array. Likewise it would also support any generic iterator, sequence or collection; while calling the function in variadic style would just result in some default type behind the scenes, you can also pass in anything you like using a variable (just like you can to a regular method).<br>&gt; <br>&gt; Also one other advantage I didn&#39;t list is that an attribute could support future extensions, for example the ability to set something like @variadic(minimum: 1), causing the compiler to produce an error if a variadic call is empty. Beyond the scope of this initial proposal, but basically this seems a much more flexible way to do things than trying to layer support onto the existing syntax, though it could be retained as a shorthand.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July  8, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree that we should have a way to call a variadic function with an Array at hand, without needing to take its elements apart (`foo(x[0], x[1], x[2])`) — which indeed is only practical when we statically know its length.<br></p><p>But I fear there&#39;s a shortcoming in this proposal that hasn&#39;t been addressed: How would the compiler clear the ambiguity in single-argument calls between existentials such as `Any` or `CustomStringConvertible` and sequences thereof (e.g. `[Any]` or `[CustomStringConvertible]`, which both can be treated as `Any` and `CustomStringConvertible` as well?<br></p><p>If you take this function for example,<br></p><p>    func printThem(@variadic _ values: [Any])<br></p><p>then what would `values` be in the following calls, and why?<br></p><p>    printThem() // clearly []<br>    printThem(1) // clearly [1]<br>    printThem(1, 2) // clearly [1, 2]<br>    printThem([1], [2]) // clearly [[1], [2]]<br>    printThem([]) // [] or [[]], which one?<br>    printThem([1]) // [1] or [[1]]?<br>    printThem([1, 2]) // [1, 2] or [[1, 2]]?<br></p><p>I think it would be less painful a change (i.e. can be delayed past Swift 3) if we just augment what we have (the `...` argument declaration syntax) with a way to expand an Array in place of a variadic argument:<br></p><p>    func printThem(_ values: Any...)<br></p><p>    printThem(1) // values == [1]<br>    printThem([1]) // values == [[1]]<br>    // Possible expansion postfix syntax:<br>    printThem([1]...) // values == [1]<br>    // Expanding a non-array sequence:<br>    let things: Set&lt;Int&gt; = [1, 2, 3]<br>    printThem(Array(things)...)<br></p><p>I think variadic functions are intended for human convenience and rarely used in performance-critical code, and it&#39;s probably more convenient that they&#39;re always passed as an Array, and not as a generic sequence.<br></p><p>— Pyry<br></p><p>Haravikk wrote:<br></p><p>&gt; For example, consider the following variadic function:<br>&gt; <br>&gt; func someMethod(_ values:Int...) { … }<br>&gt; Under this proposal the above can be rewritten as one of the following:<br>&gt; <br>&gt; func someMethod(@variadic _ values:[Int]) { … } // Basic Array solution<br>&gt; func someMethod(@variadic _ values:Foo) { … }   // Foo is a custom ArrayLiteralConvertible type<br>&gt; func someMethod&lt;I:IteratorProtocol where I.Element == Int&gt;(@variadic _ values:I) { … } // Flexible, single-pass, generic solution<br>&gt; func someMethod&lt;S:Sequence where S.Iterator.Element == Int&gt;(@variadic _ values:S) { … } // Flexible, (probably) multi-pass, generic solution<br>&gt; func someMethod&lt;C:Collection where C.Iterator.Element == Int&gt;(@variadic _ values:C) { … } // Flexible, definitely multi-pass, indexed, generic solution<br>&gt; In this case the Iterator variation is preferred for greatest flexibility, but it will depend upon the actual requirements of the method. Any of these can be called as follows:<br>&gt; <br>&gt; someMethod([1, 2, 3, 4, 5, 6])  // normal array-literal call for any of the above<br>&gt; someMethod(1, 2, 3, 4, 5, 6)    // variadic call, synonymous with array-literal call<br>&gt; someMethod(foo)                 // foo is an existing Array, Foo, Iterator, Sequence or Collection variable as appropriate<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/9cf83076/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 8 Jul 2016, at 10:31, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt; If you take this function for example,<br>&gt; <br>&gt;     func printThem(@variadic _ values: [Any])<br>&gt; <br>&gt; then what would `values` be in the following calls, and why?<br>&gt; <br>&gt;     printThem() // clearly []<br>&gt;     printThem(1) // clearly [1]<br>&gt;     printThem(1, 2) // clearly [1, 2]<br>&gt;     printThem([1], [2]) // clearly [[1], [2]]<br>&gt;     printThem([]) // [] or [[]], which one?<br>&gt;     printThem([1]) // [1] or [[1]]?<br>&gt;     printThem([1, 2]) // [1, 2] or [[1, 2]]?<br>&gt; <br>&gt; I think it would be less painful a change (i.e. can be delayed past Swift 3) if we just augment what we have (the `...` argument declaration syntax) with a way to expand an Array in place of a variadic argument:<br>&gt; <br>&gt;     func printThem(_ values: Any...)<br>&gt; <br>&gt;     printThem(1) // values == [1]<br>&gt;     printThem([1]) // values == [[1]]<br>&gt;     // Possible expansion postfix syntax:<br>&gt;     printThem([1]...) // values == [1]<br>&gt;     // Expanding a non-array sequence:<br>&gt;     let things: Set&lt;Int&gt; = [1, 2, 3]<br>&gt;     printThem(Array(things)...)<br></p><p>Good point, but actually these don&#39;t seem mutually exclusive; the three problem examples you gave could be resolved either by requiring the extra set of square brackets for clarity, and/or some kind of expansion like you suggest, either an operator or even possibly repurposing the attribute at the call-site for consistency. For example:<br></p><p>	printThem([1])	// warning, ambiguous<br>	printThem([[1]])// non-variadic<br>	printThem(@variadic [1]) // absolutely definitely 100% a variadic call<br>	printThem([1],) // alternative to an operator/attribute for variadic disambiguation?<br></p><p>Thoughts?<br></p><p><br>&gt; On 8 Jul 2016, at 10:42, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; I&#39;m not sure if the timing of this proposal is coincidence (I recently revived a discussion to remove variadics)<br></p><p>It is definitely not a coincidence ;)<br>I participated in the discussion on removal in the past and actually posted a preliminary version of this there, so the recent posts reminded me to put it into a proper proposal. Personally like some I&#39;d just remove the feature completely, but it seems enough people want to keep it that it&#39;s worth exploring alternatives as there seems a fairly even mix of those for and against the feature.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/76f7cc8d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July  8, 2016 at 08:00:00am</p></header><div class="content"><p>It is definitely not hard to solve any issues here (if you consider only<br>the basic variadics). Int... is nothing more than [Int], so essentially<br></p><p>   func doSomething(args : Int...)<br></p><p>is also just<br></p><p>   func doSomething(args : [Int])<br></p><p>We just have to think of it like some form of function overloading and the<br>compiler can automatically handle that.<br></p><p>As for enabling usage of other types as the result of variadics, I don&#39;t<br>see how that can be a benefit (unless you&#39;re just trying to write little<br>bit less on your own code). You would have to add some extra code on the<br>compiler to check whether you can use that type for your variadics argument<br>and may incur in more changes to enable handling different classes<br>possible. I would also expect to be able to use dictionaries as variadics<br>with this syntax, and that would be confusing too.<br></p><p>Should this pass like it is, it would not surprise me if my apps take more<br>time to compile. Now, if the problem is just being able to pass an array to<br>a variadics argument, my solution is cleaner, incur in less changes to the<br>language and is backwards compatible.<br></p><p>L<br></p><p>On Friday, 8 July 2016, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 8 Jul 2016, at 10:31, Pyry Jahkola &lt;pyry.jahkola at iki.fi<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;pyry.jahkola at iki.fi&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; If you take this function for example,<br>&gt;<br>&gt;     func printThem(@variadic _ values: [Any])<br>&gt;<br>&gt; then what would `values` be in the following calls, and why?<br>&gt;<br>&gt;     printThem() // clearly []<br>&gt;     printThem(1) // clearly [1]<br>&gt;     printThem(1, 2) // clearly [1, 2]<br>&gt;     printThem([1], [2]) // clearly [[1], [2]]<br>&gt;     printThem([]) // [] or [[]], which one?<br>&gt;     printThem([1]) // [1] or [[1]]?<br>&gt;     printThem([1, 2]) // [1, 2] or [[1, 2]]?<br>&gt;<br>&gt;<br>&gt; I think it would be less painful a change (i.e. can be delayed past Swift<br>&gt; 3) if we just augment what we have (the `...` argument declaration syntax)<br>&gt; with a way to expand an Array in place of a variadic argument:<br>&gt;<br>&gt;     func printThem(_ values: Any...)<br>&gt;<br>&gt;     printThem(1) // values == [1]<br>&gt;     printThem([1]) // values == [[1]]<br>&gt;     // Possible expansion postfix syntax:<br>&gt;     printThem([1]...) // values == [1]<br>&gt;     // Expanding a non-array sequence:<br>&gt;     let things: Set&lt;Int&gt; = [1, 2, 3]<br>&gt;     printThem(Array(things)...)<br>&gt;<br>&gt;<br>&gt; Good point, but actually these don&#39;t seem mutually exclusive; the three<br>&gt; problem examples you gave could be resolved either by requiring the extra<br>&gt; set of square brackets for clarity, and/or some kind of expansion like you<br>&gt; suggest, either an operator or even possibly repurposing the attribute at<br>&gt; the call-site for consistency. For example:<br>&gt;<br>&gt; printThem([1]) // warning, ambiguous<br>&gt; printThem([[1]])// non-variadic<br>&gt; printThem(@variadic [1]) // absolutely definitely 100% a variadic call<br>&gt; printThem([1],) // alternative to an operator/attribute for<br>&gt; variadic disambiguation?<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt;<br>&gt; On 8 Jul 2016, at 10:42, Tino Heth &lt;2th at gmx.de<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;2th at gmx.de&#39;);&gt;&gt; wrote:<br>&gt; I&#39;m not sure if the timing of this proposal is coincidence (I recently<br>&gt; revived a discussion to remove variadics)<br>&gt;<br>&gt;<br>&gt; It is definitely not a coincidence ;)<br>&gt; I participated in the discussion on removal in the past and actually<br>&gt; posted a preliminary version of this there, so the recent posts reminded me<br>&gt; to put it into a proper proposal. Personally like some I&#39;d just remove the<br>&gt; feature completely, but it seems enough people want to keep it that it&#39;s<br>&gt; worth exploring alternatives as there seems a fairly even mix of those for<br>&gt; and against the feature.<br>&gt;<br></p><p><br>-- <br>L<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/88407053/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 8 Jul 2016, at 12:03, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; You would have to add some extra code on the compiler to check whether you can use that type for your variadics argument and may incur in more changes to enable handling different classes possible.<br></p><p>Not really; the variadic call just needs to be treated as if it is an array literal, at which point the compiler will either match a method or it won&#39;t. The only real difference is that when called as a variadic the compiler will only match functions with the @variadic attribute. In other words the following resolve in much the same way:<br></p><p>	someMethod([1, 2, 3, 4, 5, 6])	// Looks for a declaration of someMethod() that can take an array literal<br>	someMethod(1, 2, 3, 4, 5, 6)	// Looks for a declaration of someMethod() that can take an array literal, and has a @variadic parameter<br></p><p>Treating the trailing ellipsis as a shorthand for [Foo] is no different in that respect, it&#39;s just limited to Array only. In other words, if an array literal cannot be accepted by the parameter, then it cannot have the @variadic attribute, we&#39;d need a compiler expert to comment but I don&#39;t think that should be that hard to check (concrete types will be checked for conformance to ArrayLiteralConvertible, and generics will be checked to see if they can be fulfilled by an Array or some kind of ArrayLiteral type).<br></p><p> Really what it comes down to is a choice between two methods of solving the array passing problem:<br></p><p>Variadic function treated as regular function with array parameter.<br>Regular function gains ability to be called (optionally) in variadic style at call site.<br></p><p>But my preference is for the latter as it eliminates the variadic function declarations as being some kind of special case, and moves it into a feature of regular function declarations.<br></p><p>&gt; I would also expect to be able to use dictionaries as variadics with this syntax, and that would be confusing too.<br></p><p>This should only be the case I think if you&#39;ve extended Dictionary with an ArrayLiteralConvertible initialiser, or you declared your function to take a generic iterator/sequence/collection with elements of type (Key, Value) in which case, yes, a Dictionary could fulfil the requirements.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/5ca5ac7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/48c07815c569b4c035e813e2f7247c37?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Kristóf Liliom</string> &lt;kristof.liliom at mattakis.com&gt;<p>July  8, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi!<br></p><p>I read through this proposal, and I have the feeling that we are trying to solve an issue with Swift from the wrong angle. IMHO Swift has one of the best implementations of variadics which has only one major downfall: passing an array as a variadic argument is not possible. Maybe it would be a better idea to leave method declarations as is and only change the call-site as something like this:<br></p><p>func someMethod(_ values:Int...) { /* values: 1, 2, 3, 4 */ }<br></p><p>func someMethod2(_ values:Int...) {<br>    someMethod(#unpack(values)) // Or #variadic<br>}<br></p><p>someMethod2(1, 2, 3, 4)<br></p><p>This would tell the compiler to pass the array&#39;s values. Maybe in a more advanced scenario, even this could be supported:<br></p><p>func someMethod(_ values:Int...) { /* values: -1, -2, 1, 2, 3, 4, -3, -4 */ }<br></p><p>func someMethod2(_ values:Int...) {<br>    someMethod(-1, -2, #unpack(values), -3, -4) // Or #variadic<br>}<br></p><p>someMethod2(1, 2, 3, 4)<br></p><p>I know this is not a well defined idea, but please give it a thought, could it be a feasible solution to this problem?<br></p><p>Best,<br>Kristóf<br></p><p>&gt; On 08 Jul 2016, at 13:43, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 8 Jul 2016, at 12:03, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt; You would have to add some extra code on the compiler to check whether you can use that type for your variadics argument and may incur in more changes to enable handling different classes possible.<br>&gt; <br>&gt; Not really; the variadic call just needs to be treated as if it is an array literal, at which point the compiler will either match a method or it won&#39;t. The only real difference is that when called as a variadic the compiler will only match functions with the @variadic attribute. In other words the following resolve in much the same way:<br>&gt; <br>&gt; 	someMethod([1, 2, 3, 4, 5, 6])	// Looks for a declaration of someMethod() that can take an array literal<br>&gt; 	someMethod(1, 2, 3, 4, 5, 6)	// Looks for a declaration of someMethod() that can take an array literal, and has a @variadic parameter<br>&gt; <br>&gt; Treating the trailing ellipsis as a shorthand for [Foo] is no different in that respect, it&#39;s just limited to Array only. In other words, if an array literal cannot be accepted by the parameter, then it cannot have the @variadic attribute, we&#39;d need a compiler expert to comment but I don&#39;t think that should be that hard to check (concrete types will be checked for conformance to ArrayLiteralConvertible, and generics will be checked to see if they can be fulfilled by an Array or some kind of ArrayLiteral type).<br>&gt; <br>&gt;  Really what it comes down to is a choice between two methods of solving the array passing problem:<br>&gt; <br>&gt; Variadic function treated as regular function with array parameter.<br>&gt; Regular function gains ability to be called (optionally) in variadic style at call site.<br>&gt; <br>&gt; But my preference is for the latter as it eliminates the variadic function declarations as being some kind of special case, and moves it into a feature of regular function declarations.<br>&gt; <br>&gt;&gt; I would also expect to be able to use dictionaries as variadics with this syntax, and that would be confusing too.<br>&gt; <br>&gt; This should only be the case I think if you&#39;ve extended Dictionary with an ArrayLiteralConvertible initialiser, or you declared your function to take a generic iterator/sequence/collection with elements of type (Key, Value) in which case, yes, a Dictionary could fulfil the requirements.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/fa810207/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 8 Jul 2016, at 21:18, Kristóf Liliom &lt;kristof.liliom at mattakis.com&gt; wrote:<br>&gt; <br>&gt; I read through this proposal, and I have the feeling that we are trying to solve an issue with Swift from the wrong angle. IMHO Swift has one of the best implementations of variadics which has only one major downfall: passing an array as a variadic argument is not possible. Maybe it would be a better idea to leave method declarations as is and only change the call-site as something like this:<br>&gt; <br>&gt; func someMethod(_ values:Int...) { /* values: 1, 2, 3, 4 */ }<br>&gt; <br>&gt; func someMethod2(_ values:Int...) {<br>&gt;     someMethod(#unpack(values)) // Or #variadic<br>&gt; }<br>&gt; <br>&gt; someMethod2(1, 2, 3, 4)<br>&gt; <br>&gt; This would tell the compiler to pass the array&#39;s values. Maybe in a more advanced scenario, even this could be supported:<br>&gt; <br>&gt; func someMethod(_ values:Int...) { /* values: -1, -2, 1, 2, 3, 4, -3, -4 */ }<br>&gt; <br>&gt; func someMethod2(_ values:Int...) {<br>&gt;     someMethod(-1, -2, #unpack(values), -3, -4) // Or #variadic<br>&gt; }<br>&gt; <br>&gt; someMethod2(1, 2, 3, 4)<br>&gt; <br>&gt; I know this is not a well defined idea, but please give it a thought, could it be a feasible solution to this problem?<br></p><p>These are a possible compromise certainly, but it&#39;s not exactly pretty, as I&#39;m not sure it would eliminate the desire to define collection-based methods anyway, as it&#39;ll still be neater to just define both so you can do someMethod(values) directly (when it&#39;s not ambiguous), in which case this capability only really benefits us when only the variadic option is defined and we have no choice but to use it which feels a little like solving the wrong problem (we&#39;d be working around a developer&#39;s unwillingness to define flexible options).<br></p><p>Part of my aim with this proposal is to remove variadic function declarations as being this weird kind of special function type, so we can just use a standard function declaration and enable the part that actually makes them different; the way they&#39;re called.<br></p><p>While the issue of ambiguity is a real one, it seems to me that the problem is specific to Any…, or any other type that can represent both a collection and the elements it can contain. Another possible solution could just be a parameter on this proposal&#39;s attribute so we can solve the issue as we do now, for example:<br></p><p>	func print(@variadic(only) _ values:[Any]) { print(contentsOf: values) } // Can only be called variadically<br>	func print(contentsOf:[Any]) { … } // Can only be called with an array<br></p><p>Here we resolve the ambiguity exactly as we do right now; with one variadic-only declaration, and one array-only declaration. However, for cases where the type isn&#39;t Any (and thus should be unambiguous) we will only need a single function to handle both cases.<br></p><p>I know that Any… is necessary for print-style methods like the above example, but other than that how common is it?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/ea075483/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  8, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m not sure if the timing of this proposal is coincidence (I recently revived a discussion to remove variadics), but although I stated variadics are not that important, I like this idea much better than the &quot;…&quot;-syntax which looks like a carryover from C…<br></p><p>&quot;@variadic&quot; is not only more explicit, but the proposal also enhances variadics:<br>I don&#39;t remember the details, but there has been a discussion about variadic functions that may alternatively called with an array; afaics, this capability is even extended by allowing other containers as well.<br></p><p>Sadly, I doubt it will be possible to incorporate this change into Swift 3, so I have to propose something I just mildly criticized:<br>Deprecate variadics now, but add them again later as outlined here.<br></p><p>Tino<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 15, 2016 at 09:00:00pm</p></header><div class="content"><p>The last post in this thread is nearly a week ago... did you already apply for review?<br>It would be a pity if this topic isn&#39;t finished, and I think a reduced variant that merely replaces &quot;values: Int…&quot; with &quot;@variadic _ values: [Int]&quot; shouldn&#39;t be a problem for Swift 3, leaving the possibility of adding all other features later.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 17, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 15 Jul 2016, at 20:14, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; The last post in this thread is nearly a week ago... did you already apply for review?<br>&gt; It would be a pity if this topic isn&#39;t finished, and I think a reduced variant that merely replaces &quot;values: Int…&quot; with &quot;@variadic _ values: [Int]&quot; shouldn&#39;t be a problem for Swift 3, leaving the possibility of adding all other features later.<br></p><p>I&#39;m hoping to update the proposal and submit it in the next few days. I don&#39;t think there should be any need to restrict it to Int… to [Int]; unless there are technical challenges I don&#39;t believe there should be any reason that arbitrary iterator/sequence/collection types can&#39;t be supported as proposed, the main issues seem to be around how to resolve ambiguity when the type is Any, and whether the ability to call with an array should just be bolted onto the existing syntax (not my preference). I may move discussion of other collection types to its own section though, to make the core proposal as simple as possible, and leave it up to the core team whether to do that part.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 17.07.2016 um 18:31 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt; <br>&gt; I may move discussion of other collection types to its own section though, to make the core proposal as simple as possible, and leave it up to the core team whether to do that part.<br>imho this is a good idea: Its increased power is a major argument for the proposal, but the schedule seems to be very tight already… and I guess the discussion about possible problems caused by variadic functions which can be called with an explicit collection could be a real distraction, whereas the basic idea is so clear that there shouldn&#39;t be any valid reasons to not accept it.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 20, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 20 Jul 2016, at 14:55, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 17.07.2016 um 18:31 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt; <br>&gt;&gt; I may move discussion of other collection types to its own section though, to make the core proposal as simple as possible, and leave it up to the core team whether to do that part.<br>&gt; imho this is a good idea: Its increased power is a major argument for the proposal, but the schedule seems to be very tight already… and I guess the discussion about possible problems caused by variadic functions which can be called with an explicit collection could be a real distraction, whereas the basic idea is so clear that there shouldn&#39;t be any valid reasons to not accept it.<br></p><p>I&#39;ve created a new pull request for this, you can view the updated file here:<br>https://github.com/Haravikk/swift-evolution/blob/a13dc03d6a8c76b25a30710d70cbadc1eb31b3cd/proposals/nnnn-variadics-as-attribute.md<br></p><p>Hopefully it&#39;s still clear; I know I have a nasty tendency to be overly verbose with wording and stuff, though the first example should keep the meat of the proposal straightforward =)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 11:37 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 20 Jul 2016, at 14:55, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 17.07.2016 um 18:31 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I may move discussion of other collection types to its own section though, to make the core proposal as simple as possible, and leave it up to the core team whether to do that part.<br>&gt;&gt; imho this is a good idea: Its increased power is a major argument for the proposal, but the schedule seems to be very tight already… and I guess the discussion about possible problems caused by variadic functions which can be called with an explicit collection could be a real distraction, whereas the basic idea is so clear that there shouldn&#39;t be any valid reasons to not accept it.<br>&gt; <br>&gt; I&#39;ve created a new pull request for this, you can view the updated file here:<br>&gt; https://github.com/Haravikk/swift-evolution/blob/a13dc03d6a8c76b25a30710d70cbadc1eb31b3cd/proposals/nnnn-variadics-as-attribute.md<br>&gt; <br>&gt; Hopefully it&#39;s still clear; I know I have a nasty tendency to be overly verbose with wording and stuff, though the first example should keep the meat of the proposal straightforward =)<br></p><p>I’m sorry I’m late to this thread, but I’m personally strongly opposed to this.  The problem being solved here is so minor that I don’t see a reason to make a change.  Further, the proposed syntax is so heavy weight that it will adversely affect readability of the API.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;m strongly opposed to this too. I&#39;m not only not fond of the<br>proposed syntax but I also don&#39;t really see how allowing other types<br>in variadics will help anything. Also, there may be necessary more<br>complex code to support all the extra (or even previously unknown)<br>types that could be used with this syntax, making the language much<br>more complex.<br></p><p>L<br></p><p><br>On 20 July 2016 at 16:54, Chris Lattner via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 20, 2016, at 11:37 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 20 Jul 2016, at 14:55, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Am 17.07.2016 um 18:31 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I may move discussion of other collection types to its own section though, to make the core proposal as simple as possible, and leave it up to the core team whether to do that part.<br>&gt;&gt;&gt; imho this is a good idea: Its increased power is a major argument for the proposal, but the schedule seems to be very tight already… and I guess the discussion about possible problems caused by variadic functions which can be called with an explicit collection could be a real distraction, whereas the basic idea is so clear that there shouldn&#39;t be any valid reasons to not accept it.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve created a new pull request for this, you can view the updated file here:<br>&gt;&gt; https://github.com/Haravikk/swift-evolution/blob/a13dc03d6a8c76b25a30710d70cbadc1eb31b3cd/proposals/nnnn-variadics-as-attribute.md<br>&gt;&gt;<br>&gt;&gt; Hopefully it&#39;s still clear; I know I have a nasty tendency to be overly verbose with wording and stuff, though the first example should keep the meat of the proposal straightforward =)<br>&gt;<br>&gt; I’m sorry I’m late to this thread, but I’m personally strongly opposed to this.  The problem being solved here is so minor that I don’t see a reason to make a change.  Further, the proposed syntax is so heavy weight that it will adversely affect readability of the API.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July 20, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;m also having trouble getting behind this proposal.<br></p><p>IMO, variadics as implemented today in Swift (and in Java) are a subset of<br>the problems that can be solved with variadic generics. They&#39;re more<br>limited because you can&#39;t today support heterogeneous argument lists<br>without losing static type information by forcing all values to be a<br>less-specific type (like Any, in the worst case).<br></p><p>Given that Swift will (hopefully) support variadic generics in the future,<br>I&#39;d love to see the current variadic syntax/implementation go away entirely<br>and be reïmplemented using variadic generics instead. The solution proposed<br>here is too specific given that possible future and I think it&#39;s more of a<br>lateral move with few benefits rather than an incremental move that gets<br>the language toward a greater goal.<br></p><p>Considering the set of problems where one would like to support both an<br>inline variadic homogeneous argument list syntax *or* splatting in a<br>collection, I think that set is small enough that a special syntax isn&#39;t<br>necessary. I would consider an API that *only* supports homogeneous<br>variadic arguments a poorly designed API, and we shouldn&#39;t add complexity<br>to the language to support that; we should encourage API authors to write<br>versions that take collections instead, and if they really want to support<br>variadics, implement it in terms of the collection-taking method.<br></p><p>I&#39;m also of the opinion that for most use cases involving homogeneous<br>argument lists, having to add the two characters &quot;[&quot; and &quot;]&quot; around the<br>arguments is not a significant burden to end users.<br></p><p><br>On Wed, Jul 20, 2016 at 1:25 PM Leonardo Pessoa via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m strongly opposed to this too. I&#39;m not only not fond of the<br>&gt; proposed syntax but I also don&#39;t really see how allowing other types<br>&gt; in variadics will help anything. Also, there may be necessary more<br>&gt; complex code to support all the extra (or even previously unknown)<br>&gt; types that could be used with this syntax, making the language much<br>&gt; more complex.<br>&gt;<br>&gt; L<br>&gt;<br>&gt;<br>&gt; On 20 July 2016 at 16:54, Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 20, 2016, at 11:37 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 20 Jul 2016, at 14:55, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Am 17.07.2016 um 18:31 schrieb Haravikk &lt;swift-evolution at haravikk.me<br>&gt; &gt;:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I may move discussion of other collection types to its own section<br>&gt; though, to make the core proposal as simple as possible, and leave it up to<br>&gt; the core team whether to do that part.<br>&gt; &gt;&gt;&gt; imho this is a good idea: Its increased power is a major argument for<br>&gt; the proposal, but the schedule seems to be very tight already… and I guess<br>&gt; the discussion about possible problems caused by variadic functions which<br>&gt; can be called with an explicit collection could be a real distraction,<br>&gt; whereas the basic idea is so clear that there shouldn&#39;t be any valid<br>&gt; reasons to not accept it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;ve created a new pull request for this, you can view the updated file<br>&gt; here:<br>&gt; &gt;&gt;<br>&gt; https://github.com/Haravikk/swift-evolution/blob/a13dc03d6a8c76b25a30710d70cbadc1eb31b3cd/proposals/nnnn-variadics-as-attribute.md<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hopefully it&#39;s still clear; I know I have a nasty tendency to be overly<br>&gt; verbose with wording and stuff, though the first example should keep the<br>&gt; meat of the proposal straightforward =)<br>&gt; &gt;<br>&gt; &gt; I’m sorry I’m late to this thread, but I’m personally strongly opposed<br>&gt; to this.  The problem being solved here is so minor that I don’t see a<br>&gt; reason to make a change.  Further, the proposed syntax is so heavy weight<br>&gt; that it will adversely affect readability of the API.<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/81486614/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 21, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 20 Jul 2016, at 21:25, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m strongly opposed to this too. I&#39;m not only not fond of the<br>&gt; proposed syntax but I also don&#39;t really see how allowing other types<br>&gt; in variadics will help anything. Also, there may be necessary more<br>&gt; complex code to support all the extra (or even previously unknown)<br>&gt; types that could be used with this syntax, making the language much<br>&gt; more complex.<br></p><p><br>First; the proposal isn&#39;t specifically about enabling other types, I put it in its own section as it&#39;s not the primary goal, just a potential bonus now or in future. The main goal is having one function declaration syntax, rather than a feature-specific syntax that creates a need for a type of secondary function, it&#39;s about merging the two; so hopefully actually simplifying things in reality by turning variadics into a feature of any function, rather than its own sort of separate thing.<br></p><p>Second, I don&#39;t believe it should be overly complex at all; remember all a variadic function really is is a function taking an array, except you don&#39;t need to add square brackets. That&#39;s basically what it boils down to; it&#39;s a way of calling a function such that you can pretend the values you are passing in are arguments, when really they&#39;re not. Extending with more types shouldn&#39;t really add complexity as they already work with regular functions right now, and I think I&#39;ve covered the requirements already (a fixed type needs to conform to ArrayLiteralConvertible, while a generic must be able to match an Array).<br></p><p>&gt; On 20 Jul 2016, at 21:40, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m also having trouble getting behind this proposal.<br>&gt; <br>&gt; IMO, variadics as implemented today in Swift (and in Java) are a subset of the problems that can be solved with variadic generics. They&#39;re more limited because you can&#39;t today support heterogeneous argument lists without losing static type information by forcing all values to be a less-specific type (like Any, in the worst case).<br>&gt; <br>&gt; Given that Swift will (hopefully) support variadic generics in the future, I&#39;d love to see the current variadic syntax/implementation go away entirely and be reïmplemented using variadic generics instead. The solution proposed here is too specific given that possible future and I think it&#39;s more of a lateral move with few benefits rather than an incremental move that gets the language toward a greater goal.<br></p><p>Can you be more specific about what you mean by variadic generics? Why do you feel these are incompatible with this proposal? The proposal&#39;s core after all is about using a single style of function declaration then turning on the ability to call in the variadic style via an attribute, so it seems like it&#39;d be a first step towards most other alternatives anyway IMO as either you use a different attribute to enable the feature, or some kind of generic type to match what you want it to accept.<br></p><p>&gt; Considering the set of problems where one would like to support both an inline variadic homogeneous argument list syntax *or* splatting in a collection, I think that set is small enough that a special syntax isn&#39;t necessary. I would consider an API that *only* supports homogeneous variadic arguments a poorly designed API, and we shouldn&#39;t add complexity to the language to support that; we should encourage API authors to write versions that take collections instead, and if they really want to support variadics, implement it in terms of the collection-taking method.<br>&gt; <br>&gt; I&#39;m also of the opinion that for most use cases involving homogeneous argument lists, having to add the two characters &quot;[&quot; and &quot;]&quot; around the arguments is not a significant burden to end users.<br></p><p>As I briefly mention at the end of the proposal I&#39;m originally in the ditch variadics entirely camp, as like you I don&#39;t see the big deal with just adding square brackets and being explicit about the type. This proposal is intended in part as a compromise, since a lot of people seem to like them.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 21, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Am 20.07.2016 um 21:54 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; <br>&gt; I’m sorry I’m late to this thread, but I’m personally strongly opposed to this.<br>May I ask a general question:<br>What implications does this statement have? Is it &quot;spare yourself from unnecessary work, this will never be accepted&quot;, or &quot;prepare yourself for a hard review&quot;?<br></p><p>&gt; The problem being solved here is so minor that I don’t see a reason to make a change.<br>There has been a discussion about having something like variadics-splat before (which could be solved with Haravikks idea in an elegant way), and don&#39;t you think it is strange to have a third(!) way to declare an array that merely looks like a carryover from C?<br>I&#39;ve been quite surprised by the negative reaction, as I think &quot;…&quot; is very similar to the old for-loops and increment/decrement operators which have been phased out already...<br></p><p>&gt; Further, the proposed syntax is so heavy weight that it will adversely affect readability of the API.<br>My impression is that variadics aren&#39;t that common in real-world code (at least creating custom variadic functions; and the way they are called wouldn&#39;t change), but if you consider them to be such a vital element of Swift:<br>Afaics, there is no fundamental drawback* if array-arguments could be delivered with variadics-syntax in general — this should make those happy who really like variadics, and would remove an odd special case from method signatures as well.<br></p><p>Best regards,<br>Tino<br></p><p>* well, there might be the obstacle of &quot;when the hell do you loonies think we shall actually implement all those changes you ask for? There is a deadline for Swift 3, and we already had to drop ABI compatibility, so let us do our job!&quot; ;-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 21, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 3:13 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 20.07.2016 um 21:54 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; I’m sorry I’m late to this thread, but I’m personally strongly opposed to this.<br>&gt; May I ask a general question:<br>&gt; What implications does this statement have? Is it &quot;spare yourself from unnecessary work, this will never be accepted&quot;, or &quot;prepare yourself for a hard review”?<br></p><p>It is hard to say, but it could definitely be either of those.  In any case, we’re moving more to a model that proposals need to have fairly strong community support before merging them.  This is because we’ve had a number of proposals getting rejected recently, ones that were “obviously” not going to happen.<br></p><p>That said, I specifically worded it that way so that you know it was my person feeling, not the measured opinion of the core team or anyone else.  My opinion is shaped by many things, including a significant amount of thinking about the shape of Swift as it is today, along with the tradeoffs involved in adding and removing things.  That said, the community sentiment and other core team member opinions frequently change my position on things, so it’s not some invariant - a well developed and very compelling argument is always important for a successful proposal.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 20 Jul 2016, at 20:54, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 11:37 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 20 Jul 2016, at 14:55, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 17.07.2016 um 18:31 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I may move discussion of other collection types to its own section though, to make the core proposal as simple as possible, and leave it up to the core team whether to do that part.<br>&gt;&gt;&gt; imho this is a good idea: Its increased power is a major argument for the proposal, but the schedule seems to be very tight already… and I guess the discussion about possible problems caused by variadic functions which can be called with an explicit collection could be a real distraction, whereas the basic idea is so clear that there shouldn&#39;t be any valid reasons to not accept it.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve created a new pull request for this, you can view the updated file here:<br>&gt;&gt; https://github.com/Haravikk/swift-evolution/blob/a13dc03d6a8c76b25a30710d70cbadc1eb31b3cd/proposals/nnnn-variadics-as-attribute.md<br>&gt;&gt; <br>&gt;&gt; Hopefully it&#39;s still clear; I know I have a nasty tendency to be overly verbose with wording and stuff, though the first example should keep the meat of the proposal straightforward =)<br>&gt; <br>&gt; I’m sorry I’m late to this thread, but I’m personally strongly opposed to this.<br></p><p>I&#39;m similarly late to your reply since somehow I missed it ;)<br></p><p>&gt; The problem being solved here is so minor that I don’t see a reason to make a change.<br></p><p>Which problem are you referring to exactly? The core issue of the proposal is to eliminate an unnecessary custom syntax and use regular function declarations, but the proposal also extends further than that as detailed in the advantages section; firstly it also opens passing of arrays to variadic functions, which seems to be fairly desired despite no proposal that I could find, but this proposal does so using a regular function definition rather than bolting on more custom behaviour to variadics. The proposal also details how the use of an attribute allows selection of any suitable type for handling the variadics, either to be introduced now or as a future feature, allowing any ArrayLiteralConvertible or any generic that can be satisfied by an Array to be used in an implementation, rather than requiring:<br></p><p>	func someFunc&lt;I:IteratorProtocol where I.Element == Int&gt;(contentsOf:I) { … }<br>	func someFucn(_ values:Int…) { someFunc(contentsOf: values) }<br></p><p>You would just pop the @variadic attribute on the first version.<br></p><p>Again on the future feature front, if we were to get any new variadic features the use of an attribute should make them easier to add since they could be added as an attribute parameter. Not that I can think of any, but in future it would be easy to add say @variadic(min: 1) to set a minimum number of variadic parameters; not that I want this, it&#39;s just the only thing I can think of, but highlights that an attribute is more extensible.<br></p><p>So while the problem inspiring the proposal is relatively minor, the solution aims to solve the array passing issue too, while opening up other possibilities now or in future.<br></p><p>&gt; Further, the proposed syntax is so heavy weight that it will adversely affect readability of the API<br></p><p>Is it really so heavy-weight? Obviously it&#39;s a bit more effort than three dots, but it&#39;s also declaring an explicit type for your function, which it can also handle directly in addition to variadic calling.<br></p><p>In my experience the use of @noescape closures is much, much more common than variadics, yet no-one seems that desperate to introduce a custom syntax just to make them more lightweight to declare. In fact I could probably count the number of variadic functions I&#39;ve seen or used in Swift on one hand, but I use and benefit from @noescape daily without ever feeling the attribute has been a burden to declare. This is after all a declaration-site change, anyone actually using variadics shouldn&#39;t notice much of a difference except where the ambiguity issue strikes, but then that&#39;s a problem for any array-passing extension to variadics I think.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/a2facc6d/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 22, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Am 21.07.2016 um 22:11 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt; <br>&gt; it also opens passing of arrays to variadic functions, which seems to be fairly desired despite no proposal that I could find<br>I haven&#39;t seen a complete proposal, but I managed to remember a link to the last(?) discussion about it:<br>[Idea] Passing an Array to Variadic Functions &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/14951&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/0f791881/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 22, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 21 Jul 2016, at 23:05, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; Am 21.07.2016 um 22:11 schrieb Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt;&gt; it also opens passing of arrays to variadic functions, which seems to be fairly desired despite no proposal that I could find<br>&gt; I haven&#39;t seen a complete proposal, but I managed to remember a link to the last(?) discussion about it:<br>&gt; [Idea] Passing an Array to Variadic Functions &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/14951&gt;<br>Oh yeah, in fact the post you linked to was in reply to one of mine arguing that variadics just be removed entirely =)<br>The full thread and first post are here (if I got the link right): http://thread.gmane.org/gmane.comp.lang.swift.evolution/14807/focus=14951<br></p><p>But no proposal ever came from it, other than this one. I was going to propose removing variadics, but too many people seemed to be against that idea, even though it&#39;s by far the cleanest solution, none of the other ideas for array passing seem to have emerged though.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/a1fa3464/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Variadics as Attribute</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 26, 2016 at 02:00:00pm</p></header><div class="content"><p>Hate to have to bump this myself, but I&#39;m still hoping to get more detailed feedback from those that have made negative comments to clarify or clear up any misunderstandings.<br></p><p>So far the main argument made against the change is that it&#39;s more complex than the problem being solved, however this seems to be levelled at a single problem when really this proposal is intended to solve two things; to unify the declaration of regular and variadic functions, and to enable a single function in variadic or array style at the call-site. In essence the latter is a side-effect of the former, as the variadic declaration would no longer be different from any other function. The (relative) complexity is also one of my favourite things as it actually opens up future possibilities too, which I&#39;ve covered in the proposal.<br></p><p>Otherwise Chris mentioned it being heavyweight, but I&#39;m unclear on whether this was a reference to complexity or just that&#39;s more to type in a declaration than three dots. However it&#39;s no more heavyweight than say @noescape or @autoclosure, both of which (in my experience at least) are a lot more common than variadics, yet they don&#39;t have a custom declaration syntax, but are both features with custom call-site behaviour, so similar to variadics.<br></p><p>I guess I&#39;m resigned to the fact that this isn&#39;t likely to make Swift 3 now, but it can still be delivered as an additive change (by leaving the current syntax as a shorthand and deprecating it later) so I&#39;d like to get more feedback before I make any updates to the proposal. It&#39;s not easy to gauge from the feedback so far how much of it was read, as I thought the advantages section made a good case, but then I&#39;m not much for proposal writing so fully expect to be responsible for any misunderstandings ;)<br></p><p>&gt; On 22 Jul 2016, at 12:43, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt; On 21 Jul 2016, at 23:05, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt;&gt; Am 21.07.2016 um 22:11 schrieb Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt;&gt;&gt; it also opens passing of arrays to variadic functions, which seems to be fairly desired despite no proposal that I could find<br>&gt;&gt; I haven&#39;t seen a complete proposal, but I managed to remember a link to the last(?) discussion about it:<br>&gt;&gt; [Idea] Passing an Array to Variadic Functions &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/14951&gt;<br>&gt; Oh yeah, in fact the post you linked to was in reply to one of mine arguing that variadics just be removed entirely =)<br>&gt; The full thread and first post are here (if I got the link right): http://thread.gmane.org/gmane.comp.lang.swift.evolution/14807/focus=14951 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14807/focus=14951&gt;<br>&gt; <br>&gt; But no proposal ever came from it, other than this one. I was going to propose removing variadics, but too many people seemed to be against that idea, even though it&#39;s by far the cleanest solution, none of the other ideas for array passing seem to have emerged though.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/e7f7377e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Getting rid of &quot;...&quot; in variadic functions</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 25, 2016 at 05:00:00pm</p></header><div class="content"><p>Just wanted to ask about the current status — but then saw that there has been a PR already…<br>It&#39;s a pity that there hasn&#39;t been the time for a detailed answer, as I still think this is one of the best non-trivial proposals so far.<br></p><p>So, I guess you&#39;re discouraged by the backfire, but afaics, there haven&#39;t been many people opposing the idea, but rather a lack of interest.<br>Maybe it&#39;s just not the right time, and I hope there are no serious plans to make Swift 3 the last release with breaking changes, so that there will be another possibility to discuss the topic when there is less stress.<br></p><p>What&#39;s your opinion on simply allowing variadic-syntax at call site wherever an array is expected? For me, the only real counter-argument has been that &quot;@variadic&quot; is more heavy-weight than three dots, and although I don&#39;t agree that this is an issue, &quot;nothing&quot; is obviously as lightweight as possible.<br></p><p>- Tino<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
