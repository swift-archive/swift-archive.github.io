<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal: Automatic initializer generation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 23, 2016 at 04:00:00pm</p></header><div class="content"><p>A lot of initializers tediously assign values to variables which results in a lot of code such as self.variable = arg1 (or even worse variable = variable), mostly for classes that are meant to just encapsulate several values.<br></p><p>I propose adding auto keyword (to be discussed - anyone has a better name in mind?), which would automatically assign same-named variables. Example:<br></p><p>class User {<br>	var name: String<br>	var password: String<br>	<br>	init(auto name: String, auto password: String) {<br>		// No assignment required, the variables will be automatically assigned.<br>		// Perform additional init stuff here.<br>	}<br>}<br></p><p>This would, of course, work only if the argument has the same name as a stored variable on the class.<br></p><p>Additionally, if the class is root, or the superclass has an initializer that takes no arguments, I propose adding @auto_init annotation, which would generate a default initializer, similar to what is done for structs:<br></p><p>@auto_init<br>class User {<br>	var name: String<br>	var password: String<br>}<br></p><p>Normally, such class would be illegal since it would have no accessible initializers. The annotation could specify the access control as well: @auto_init(private), @auto_init(internal), @auto_init(public).<br></p><p>If the class isn&#39;t root, but inherits from an object that has an initializer that takes no arguments (e.g. NSObject), this would be allowed as well and the initializer with no arguments would be called on super.<br></p><p>Any thoughts on this? Sorry, if this has been already discussed.<br></p><p>Charlie<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>Proposal: Automatic initializer generation</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>May 23, 2016 at 08:00:00am</p></header><div class="content"><p>Discussed last month https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014890.html<br>And (linked from that thread) last year http://article.gmane.org/gmane.comp.lang.swift.evolution/727<br></p><p>I think it’s a good idea, but discussion seems to have just petered out without a formal proposal both times. <br></p><p>How about we just apply the struct auto-init behavior to classes? It’s nice and simple, and already in the language.<br></p><p>&gt; On May 23, 2016, at 7:29 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A lot of initializers tediously assign values to variables which results in a lot of code such as self.variable = arg1 (or even worse variable = variable), mostly for classes that are meant to just encapsulate several values.<br>&gt; <br>&gt; I propose adding auto keyword (to be discussed - anyone has a better name in mind?), which would automatically assign same-named variables. Example:<br>&gt; <br>&gt; class User {<br>&gt; 	var name: String<br>&gt; 	var password: String<br>&gt; 	<br>&gt; 	init(auto name: String, auto password: String) {<br>&gt; 		// No assignment required, the variables will be automatically assigned.<br>&gt; 		// Perform additional init stuff here.<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; This would, of course, work only if the argument has the same name as a stored variable on the class.<br>&gt; <br>&gt; Additionally, if the class is root, or the superclass has an initializer that takes no arguments, I propose adding @auto_init annotation, which would generate a default initializer, similar to what is done for structs:<br>&gt; <br>&gt; @auto_init<br>&gt; class User {<br>&gt; 	var name: String<br>&gt; 	var password: String<br>&gt; }<br>&gt; <br>&gt; Normally, such class would be illegal since it would have no accessible initializers. The annotation could specify the access control as well: @auto_init(private), @auto_init(internal), @auto_init(public).<br>&gt; <br>&gt; If the class isn&#39;t root, but inherits from an object that has an initializer that takes no arguments (e.g. NSObject), this would be allowed as well and the initializer with no arguments would be called on super.<br>&gt; <br>&gt; Any thoughts on this? Sorry, if this has been already discussed.<br>&gt; <br>&gt; Charlie<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal: Automatic initializer generation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 23, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks for the links.<br></p><p>You can&#39;t apply auto-init behavior to all classes since it gets a bit more complicated once the only initializers available take some arguments - the compiler can&#39;t know what to pass where to super, so it would need to chain the arguments, which would lead to initializers with dozens of arguments. So in such case the auto-init is IMHO out of question.<br></p><p>The variant that I&#39;m suggesting is simplified and restricted only to classes that either do not inherit from anything, or have an initializer that takes no arguments - which makes the issue much simpler than previously suggested.<br></p><p>I dislike the syntax of the previous proposal<br></p><p>init (self.a: Int, self.b: String) {<br>   //...<br>}<br></p><p>where you specify self.a: Int - IMHO this should be done using a keyword that automates it and I&#39;d allow it only for arguments that match a variable on the instance. Or perhaps allowing something like auto(xyz) to specify the variable? Or #auto(xyz)?<br></p><p>This seems a bit more readable to me:<br></p><p>init (auto a: Int, auto b: String) {<br>   //...<br>}<br></p><p>If there is still some interest in making this a proposal, I can write it up.<br></p><p>Charlie<br></p><p><br>&gt; On May 23, 2016, at 5:52 PM, Kevin Nattinger &lt;swift at nattinger.net&gt; wrote:<br>&gt; <br>&gt; Discussed last month https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014890.html<br>&gt; And (linked from that thread) last year http://article.gmane.org/gmane.comp.lang.swift.evolution/727<br>&gt; <br>&gt; I think it’s a good idea, but discussion seems to have just petered out without a formal proposal both times. <br>&gt; <br>&gt; How about we just apply the struct auto-init behavior to classes? It’s nice and simple, and already in the language.<br>&gt; <br>&gt;&gt; On May 23, 2016, at 7:29 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A lot of initializers tediously assign values to variables which results in a lot of code such as self.variable = arg1 (or even worse variable = variable), mostly for classes that are meant to just encapsulate several values.<br>&gt;&gt; <br>&gt;&gt; I propose adding auto keyword (to be discussed - anyone has a better name in mind?), which would automatically assign same-named variables. Example:<br>&gt;&gt; <br>&gt;&gt; class User {<br>&gt;&gt; 	var name: String<br>&gt;&gt; 	var password: String<br>&gt;&gt; 	<br>&gt;&gt; 	init(auto name: String, auto password: String) {<br>&gt;&gt; 		// No assignment required, the variables will be automatically assigned.<br>&gt;&gt; 		// Perform additional init stuff here.<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would, of course, work only if the argument has the same name as a stored variable on the class.<br>&gt;&gt; <br>&gt;&gt; Additionally, if the class is root, or the superclass has an initializer that takes no arguments, I propose adding @auto_init annotation, which would generate a default initializer, similar to what is done for structs:<br>&gt;&gt; <br>&gt;&gt; @auto_init<br>&gt;&gt; class User {<br>&gt;&gt; 	var name: String<br>&gt;&gt; 	var password: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Normally, such class would be illegal since it would have no accessible initializers. The annotation could specify the access control as well: @auto_init(private), @auto_init(internal), @auto_init(public).<br>&gt;&gt; <br>&gt;&gt; If the class isn&#39;t root, but inherits from an object that has an initializer that takes no arguments (e.g. NSObject), this would be allowed as well and the initializer with no arguments would be called on super.<br>&gt;&gt; <br>&gt;&gt; Any thoughts on this? Sorry, if this has been already discussed.<br>&gt;&gt; <br>&gt;&gt; Charlie<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal: Automatic initializer generation</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 23, 2016 at 06:00:00pm</p></header><div class="content"><p>From what I have read of the proposals, they were IMO premature considering some questions not yet tabled (on the 4.0 train if i recall). Might be part of the reason for the core teams not pressing this agenda forward today.<br></p><p>&gt; On May 23, 2016, at 5:52 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Discussed last month https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014890.html<br>&gt; And (linked from that thread) last year http://article.gmane.org/gmane.comp.lang.swift.evolution/727<br>&gt; <br>&gt; I think it’s a good idea, but discussion seems to have just petered out without a formal proposal both times. <br>&gt; <br>&gt; How about we just apply the struct auto-init behavior to classes? It’s nice and simple, and already in the language.<br>&gt; <br>&gt;&gt; On May 23, 2016, at 7:29 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A lot of initializers tediously assign values to variables which results in a lot of code such as self.variable = arg1 (or even worse variable = variable), mostly for classes that are meant to just encapsulate several values.<br>&gt;&gt; <br>&gt;&gt; I propose adding auto keyword (to be discussed - anyone has a better name in mind?), which would automatically assign same-named variables. Example:<br>&gt;&gt; <br>&gt;&gt; class User {<br>&gt;&gt;    var name: String<br>&gt;&gt;    var password: String<br>&gt;&gt;    <br>&gt;&gt;    init(auto name: String, auto password: String) {<br>&gt;&gt;        // No assignment required, the variables will be automatically assigned.<br>&gt;&gt;        // Perform additional init stuff here.<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would, of course, work only if the argument has the same name as a stored variable on the class.<br>&gt;&gt; <br>&gt;&gt; Additionally, if the class is root, or the superclass has an initializer that takes no arguments, I propose adding @auto_init annotation, which would generate a default initializer, similar to what is done for structs:<br>&gt;&gt; <br>&gt;&gt; @auto_init<br>&gt;&gt; class User {<br>&gt;&gt;    var name: String<br>&gt;&gt;    var password: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Normally, such class would be illegal since it would have no accessible initializers. The annotation could specify the access control as well: @auto_init(private), @auto_init(internal), @auto_init(public).<br>&gt;&gt; <br>&gt;&gt; If the class isn&#39;t root, but inherits from an object that has an initializer that takes no arguments (e.g. NSObject), this would be allowed as well and the initializer with no arguments would be called on super.<br>&gt;&gt; <br>&gt;&gt; Any thoughts on this? Sorry, if this has been already discussed.<br>&gt;&gt; <br>&gt;&gt; Charlie<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Automatic initializer generation</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 10:52 AM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Discussed last month https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014890.html<br>&gt; And (linked from that thread) last year http://article.gmane.org/gmane.comp.lang.swift.evolution/727<br>&gt; <br>&gt; I think it’s a good idea, but discussion seems to have just petered out without a formal proposal both times. <br></p><p>This didn’t peter out.  My opinion on this topic evolved throughout the review.  The perspective I came to is that the best approach may require changes that are outside the scope of Swift 3.  I expect this to come up again during the Swift 4 conversation.<br></p><p>&gt; <br>&gt; How about we just apply the struct auto-init behavior to classes? It’s nice and simple, and already in the language.<br>&gt; <br>&gt;&gt; On May 23, 2016, at 7:29 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A lot of initializers tediously assign values to variables which results in a lot of code such as self.variable = arg1 (or even worse variable = variable), mostly for classes that are meant to just encapsulate several values.<br>&gt;&gt; <br>&gt;&gt; I propose adding auto keyword (to be discussed - anyone has a better name in mind?), which would automatically assign same-named variables. Example:<br>&gt;&gt; <br>&gt;&gt; class User {<br>&gt;&gt; 	var name: String<br>&gt;&gt; 	var password: String<br>&gt;&gt; 	<br>&gt;&gt; 	init(auto name: String, auto password: String) {<br>&gt;&gt; 		// No assignment required, the variables will be automatically assigned.<br>&gt;&gt; 		// Perform additional init stuff here.<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would, of course, work only if the argument has the same name as a stored variable on the class.<br>&gt;&gt; <br>&gt;&gt; Additionally, if the class is root, or the superclass has an initializer that takes no arguments, I propose adding @auto_init annotation, which would generate a default initializer, similar to what is done for structs:<br>&gt;&gt; <br>&gt;&gt; @auto_init<br>&gt;&gt; class User {<br>&gt;&gt; 	var name: String<br>&gt;&gt; 	var password: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Normally, such class would be illegal since it would have no accessible initializers. The annotation could specify the access control as well: @auto_init(private), @auto_init(internal), @auto_init(public).<br>&gt;&gt; <br>&gt;&gt; If the class isn&#39;t root, but inherits from an object that has an initializer that takes no arguments (e.g. NSObject), this would be allowed as well and the initializer with no arguments would be called on super.<br>&gt;&gt; <br>&gt;&gt; Any thoughts on this? Sorry, if this has been already discussed.<br>&gt;&gt; <br>&gt;&gt; Charlie<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Proposal: Automatic initializer generation</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 23, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 7:24 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 23, 2016, at 10:52 AM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Discussed last month https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014890.html<br>&gt;&gt; And (linked from that thread) last year http://article.gmane.org/gmane.comp.lang.swift.evolution/727<br>&gt;&gt; <br>&gt;&gt; I think it’s a good idea, but discussion seems to have just petered out without a formal proposal both times. <br></p><p>IMHO the proposals were on a collision course with yet untouched parts of the language. <br></p><p>&gt; <br>&gt; This didn’t peter out.  My opinion on this topic evolved throughout the review.  The perspective I came to is that the best approach may require changes that are outside the scope of Swift 3.  I expect this to come up again during the Swift 4 conversation.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; How about we just apply the struct auto-init behavior to classes? It’s nice and simple, and already in the language.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 7:29 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A lot of initializers tediously assign values to variables which results in a lot of code such as self.variable = arg1 (or even worse variable = variable), mostly for classes that are meant to just encapsulate several values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose adding auto keyword (to be discussed - anyone has a better name in mind?), which would automatically assign same-named variables. Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class User {<br>&gt;&gt;&gt;    var name: String<br>&gt;&gt;&gt;    var password: String<br>&gt;&gt;&gt;    <br>&gt;&gt;&gt;    init(auto name: String, auto password: String) {<br>&gt;&gt;&gt;        // No assignment required, the variables will be automatically assigned.<br>&gt;&gt;&gt;        // Perform additional init stuff here.<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would, of course, work only if the argument has the same name as a stored variable on the class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Additionally, if the class is root, or the superclass has an initializer that takes no arguments, I propose adding @auto_init annotation, which would generate a default initializer, similar to what is done for structs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @auto_init<br>&gt;&gt;&gt; class User {<br>&gt;&gt;&gt;    var name: String<br>&gt;&gt;&gt;    var password: String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Normally, such class would be illegal since it would have no accessible initializers. The annotation could specify the access control as well: @auto_init(private), @auto_init(internal), @auto_init(public).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the class isn&#39;t root, but inherits from an object that has an initializer that takes no arguments (e.g. NSObject), this would be allowed as well and the initializer with no arguments would be called on super.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any thoughts on this? Sorry, if this has been already discussed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
