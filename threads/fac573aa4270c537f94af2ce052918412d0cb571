<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>January  2, 2016 at 09:00:00am</p></header><div class="content"><p>Happy 2016!<br></p><p>I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>  https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md<br></p><p>Some TL;DR:<br> - The proposal defines a basic convention for pure C language targets (no Swift/C mix and match, but other Swift targets can use the C targets).<br> - This is just intended to be the minimal initial feature, there will be a lot of add on work which I expect should be tackled in follow on PRs/proposals.<br> - The proposal doesn&#39;t try and outline every single nitty detail (e.g., exactly what C++ standard we will compile with). My intention is to pick a sensible default at implementation time and refine incrementally.<br></p><p>Unless there are serious objections, I am hoping to hope to land this proposal soon and start work on the feature shortly after.<br></p><p>Cheers,<br> - Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/720d2d10d5e7eab5437af61350df0a81?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Andrew Madsen</string> &lt;lists at openreelsoftware.com&gt;<p>January  2, 2016 at 10:00:00am</p></header><div class="content"><p>Daniel Dunbar via swift-build-dev wrote:<br> &gt; Happy 2016!<br> &gt;<br> &gt; I am working on an initial proposal for adding support for C language <br>targets to the Swift package manager, and am interested in feedback:<br> &gt;    <br>https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md <br></p><p> &gt;<br> &gt; Unless there are serious objections, I am hoping to hope to land this <br>proposal soon and start work on the feature shortly after.<br></p><p>I&#39;m happy to see this, Daniel. Best I can tell, it will provide exactly <br>the feature set I need right now, where I&#39;m writing a Swift library <br>package that requires a little bit of C (ie. two or three 1-line <br>functions) due to Swift&#39;s inability to call C variadic functions.<br></p><p>I do think the ability to declare that a certain target&#39;s API should not <br>be exposed to downstream packages is important, and hope that too can be <br>addressed relatively soon.<br></p><p>-Andrew<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a28b53f05e7f3067fb104cb78fbb585?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Kostiantyn Koval</string> &lt;konstantin.koval1 at gmail.com&gt;<p>January  2, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi, Happy 2016. <br></p><p>The proposal looks great as for me. Very nice starting point to add C family support<br></p><p>Best Regards,<br>Kostiantyn<br></p><p>&gt; On 02 Jan 2016, at 18:00, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Happy 2016!<br>&gt; <br>&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>&gt;  https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md<br>&gt; <br>&gt; Some TL;DR:<br>&gt; - The proposal defines a basic convention for pure C language targets (no Swift/C mix and match, but other Swift targets can use the C targets).<br>&gt; - This is just intended to be the minimal initial feature, there will be a lot of add on work which I expect should be tackled in follow on PRs/proposals.<br>&gt; - The proposal doesn&#39;t try and outline every single nitty detail (e.g., exactly what C++ standard we will compile with). My intention is to pick a sensible default at implementation time and refine incrementally.<br>&gt; <br>&gt; Unless there are serious objections, I am hoping to hope to land this proposal soon and start work on the feature shortly after.<br>&gt; <br>&gt; Cheers,<br>&gt; - Daniel<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[swift-build-dev] [swiftpm] Add proposal for C language support</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  2, 2016 at 02:00:00pm</p></header><div class="content"><p>This sounds interesting. I don&#39;t have time to read it right now but I like the idea and I&#39;ll give better feedback later.<br></p><p>Félix<br></p><p>&gt; Le 2 janv. 2016 à 12:28:10, Kostiantyn Koval via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi, Happy 2016. <br>&gt; <br>&gt; The proposal looks great as for me. Very nice starting point to add C family support<br>&gt; <br>&gt; Best Regards,<br>&gt; Kostiantyn<br>&gt; <br>&gt;&gt; On 02 Jan 2016, at 18:00, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Happy 2016!<br>&gt;&gt; <br>&gt;&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>&gt;&gt; https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md<br>&gt;&gt; <br>&gt;&gt; Some TL;DR:<br>&gt;&gt; - The proposal defines a basic convention for pure C language targets (no Swift/C mix and match, but other Swift targets can use the C targets).<br>&gt;&gt; - This is just intended to be the minimal initial feature, there will be a lot of add on work which I expect should be tackled in follow on PRs/proposals.<br>&gt;&gt; - The proposal doesn&#39;t try and outline every single nitty detail (e.g., exactly what C++ standard we will compile with). My intention is to pick a sensible default at implementation time and refine incrementally.<br>&gt;&gt; <br>&gt;&gt; Unless there are serious objections, I am hoping to hope to land this proposal soon and start work on the feature shortly after.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; - Daniel<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Thanks for directing me to this, I missed it.<br></p><p>&gt; Most projects will not conform to these conventions.<br></p><p>Giggle.  Kind of an understatement, no?<br></p><p>Like, okay.  Here is a project I&#39;d like to package.  (Read: I do package it, with features not in mainline swiftPM.)  https://github.com/jedisct1/libsodium &lt;https://github.com/jedisct1/libsodium&gt;<br></p><p>Let&#39;s take a look at how this package realistically builds:<br></p><p>* It has tests (&quot;make check&quot;)<br>* It has various --enable-foo flags<br>* It swaps in special implementations depending on if you have AMD64 &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L162&gt; or AVX instructions &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L145&gt; or SSE2 &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L229&gt; etc.<br>* The optimization level is tuned on a per-architecture basis &lt;https://github.com/jedisct1/libsodium/blob/master/dist-build/android-armv7-a.sh#L3&gt;<br>* They build (also) on Windows.  They&#39;re not changing how they&#39;re packaged for &quot;SwiftPM, the Mac/Linux build system&quot;.<br>* Oh and this is cryptography code.  Do you *really* want to touch it?<br></p><p>I think an important feature of any C target proposal is that there will actually exist C targets which can be built under the proposal.  Until there are C people coming out of the woodwork saying &quot;sure, I will repackage my software this way&quot; I think the entire value is debatable.<br></p><p>Getting signoff from libdispatch/CoreFoundation is necessary but not sufficient to clear that hurdle.  I would think getting the other C deps in our own project family to repackage would be &quot;table stakes&quot; for any new C build system.  The real test are projects that are third-party and less friendly.<br></p><p>And I do not see realistically how we are ever going to support a project like libsodium, except calling out to automake.  An automake solution coincidentally supports both libdispatch and CoreFoundation right now.  IMO something like that is a much, much better direction in the short-term, and once we have done the first step of &quot;packaging&quot; those software via automake we will have &quot;real&quot; C projects in our package manager and we can design our C support around the concerns of real projects instead of imaginary ones.<br></p><p>&gt; On Jan 2, 2016, at 11:00 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Happy 2016!<br>&gt; <br>&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>&gt;  https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md<br>&gt; <br>&gt; Some TL;DR:<br>&gt; - The proposal defines a basic convention for pure C language targets (no Swift/C mix and match, but other Swift targets can use the C targets).<br>&gt; - This is just intended to be the minimal initial feature, there will be a lot of add on work which I expect should be tackled in follow on PRs/proposals.<br>&gt; - The proposal doesn&#39;t try and outline every single nitty detail (e.g., exactly what C++ standard we will compile with). My intention is to pick a sensible default at implementation time and refine incrementally.<br>&gt; <br>&gt; Unless there are serious objections, I am hoping to hope to land this proposal soon and start work on the feature shortly after.<br>&gt; <br>&gt; Cheers,<br>&gt; - Daniel<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160102/58766af5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; *I think an important feature of any C target proposal is that there<br>&gt; will actually exist C targets which can be built under the proposal*.<br>&gt; Until there are C people coming out of the woodwork saying &quot;sure, I<br>&gt; will repackage my software this way&quot; I think the entire value is<br>&gt; debatable.<br></p><p>I almost couldn&#39;t disagree more. No Swift project could be built with<br>swiftpm when it was introduced without repackaging. I don&#39;t see why C<br>support should be held to a different standard.<br></p><p>&gt; And I do not see realistically how we are ever going to support a<br>&gt; project like libsodium, except calling out to automake.<br></p><p>A potential solution (one of many possible) would look a lot like how<br>people generate Xcode projects for C build systems today; hand-tuning<br>config.h headers and such. I know many people who will go to ungodly<br>lengths to avoid the inevitable nightmare automake causes in a source-<br>distributed dependency.<br></p><p>&gt; IMO something like that is a much, much better direction in the short-<br>&gt; term, and once we have done the first step of &quot;packaging&quot; those<br>&gt; software via automake we will have &quot;real&quot; C projects in our package<br>&gt; manager and we can design our C support around the concerns of real<br>&gt; projects instead of imaginary ones.<br></p><p>There are C projects that would benefit from modularization, header<br>auditing, and cleanups that Swift and swiftpm would bring to it. C<br>projects are massively disorganized because build systems are a<br>ridiculous hodgepodge; we didn&#39;t be subject to that long tail of good<br>and bad decisions.<br></p><p>I don&#39;t think automake support would be a silver bullet at all, and<br>contradict with many goals of swiftpm and llbuild to boot. Even<br>targeting a really small subset of automake projects what liberties<br>would unnecessarily complicate the project, and then there&#39;d be the<br>projects it doesn&#39;t support.  (Oh? Wait? What version of the tools? Oh,<br>from trunk? Oh, does the project take any liberties with its own<br>organization? God help us when we start talking about C++…)<br></p><p>&quot;imaginary&quot; is a reductive way of phrasing the problem space. You keep<br>referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual project you<br>want support for; while there&#39;s a lot to be said for real-world use<br>cases, I don&#39;t think this proposal&#39;s direction should be dictated by<br>just libsodium.<br></p><p>Zachary<br></p><p>On Sat, Jan 2, 2016, at 04:57 PM, Drew Crawford via swift-build-dev wrote:<br>&gt; Thanks for directing me to this, I missed it.<br>&gt;<br>&gt;&gt; Most projects will not conform to these conventions.<br>&gt;<br>&gt; Giggle.  Kind of an understatement, no?<br>&gt;<br>&gt; Like, okay.  Here is a project I&#39;d like to package.  (Read: I do<br>&gt; package it, with features not in mainline swiftPM.)<br>&gt; https://github.com/jedisct1/libsodium<br>&gt;<br>&gt; Let&#39;s take a look at how this package realistically builds:<br>&gt;<br>&gt; * It has tests (&quot;make check&quot;)<br>&gt; * It has various --enable-foo flags<br>&gt; * It swaps in special implementations depending on if you have<br>&gt;   AMD64[1] or AVX instructions[2] or SSE2[3] etc.<br>&gt; * The optimization level is tuned on a per-architecture basis[4]<br>&gt; * They build (also) on Windows.  They&#39;re not changing how they&#39;re<br>&gt;   packaged for &quot;SwiftPM, the Mac/Linux build system&quot;.<br>&gt; * Oh and this is cryptography code.  Do you *really* want to touch it?<br>&gt;<br>&gt; *I think an important feature of any C target proposal is that there<br>&gt; will actually exist C targets which can be built under the proposal*.<br>&gt; Until there are C people coming out of the woodwork saying &quot;sure, I<br>&gt; will repackage my software this way&quot; I think the entire value is<br>&gt; debatable.<br>&gt;<br>&gt; Getting signoff from libdispatch/CoreFoundation is necessary but not<br>&gt; sufficient to clear that hurdle.  I would think getting the other C<br>&gt; deps in our own project family to repackage would be &quot;table stakes&quot;<br>&gt; for any new C build system.  The real test are projects that are third-<br>&gt; party and less friendly.<br>&gt;<br>&gt; And I do not see realistically how we are ever going to support a<br>&gt; project like libsodium, except calling out to automake.  An automake<br>&gt; solution coincidentally supports both libdispatch and CoreFoundation<br>&gt; right now.  IMO something like that is a much, much better direction<br>&gt; in the short-term, and once we have done the first step of &quot;packaging&quot;<br>&gt; those software via automake we will have &quot;real&quot; C projects in our<br>&gt; package manager and we can design our C support around the concerns of<br>&gt; real projects instead of imaginary ones.<br>&gt;<br>&gt;&gt; On Jan 2, 2016, at 11:00 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-<br>&gt;&gt; dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Happy 2016!<br>&gt;&gt;<br>&gt;&gt; I am working on an initial proposal for adding support for C language<br>&gt;&gt; targets to the Swift package manager, and am interested in feedback:<br>&gt;&gt; https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md<br>&gt;&gt;<br>&gt;&gt; Some TL;DR:<br>&gt;&gt;  - The proposal defines a basic convention for pure C language<br>&gt;&gt;    targets (no Swift/C mix and match, but other Swift targets can use<br>&gt;&gt;    the C targets).<br>&gt;&gt;  - This is just intended to be the minimal initial feature, there<br>&gt;&gt;    will be a lot of add on work which I expect should be tackled in<br>&gt;&gt;    follow on PRs/proposals.<br>&gt;&gt;  - The proposal doesn&#39;t try and outline every single nitty detail<br>&gt;&gt;    (e.g., exactly what C++ standard we will compile with). My<br>&gt;&gt;    intention is to pick a sensible default at implementation time and<br>&gt;&gt;    refine incrementally.<br>&gt;&gt;<br>&gt;&gt; Unless there are serious objections, I am hoping to hope to land this<br>&gt;&gt; proposal soon and start work on the feature shortly after.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;  - Daniel<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-build-dev mailing list swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p><br></p><p>Links:<br></p><p>  1. https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L162<br>  2. https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L145<br>  3. https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L229<br>  4. https://github.com/jedisct1/libsodium/blob/master/dist-build/android-armv7-a.sh#L3<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160102/c58037e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  3, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; You keep referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual project you want support for; while there&#39;s a lot to be said for real-world use cases, I don&#39;t think this proposal&#39;s direction should be dictated by just libsodium.<br></p><p>Nothing about this is reductive or specific to libsodium.<br></p><p>* libdispatch has a build manual &lt;https://github.com/apple/swift-corelibs-libdispatch/blob/master/INSTALL&gt; that runs over 100 lines and involves checking out *7* other repos.<br>* Foundation (incl CoreFoundation) has a python-based build &lt;https://github.com/apple/swift-corelibs-foundation/tree/master/lib&gt; system that runs to 1900 lines<br>* libjpeg is &quot;the&quot; example of a C dependency in our documentation, and its build system includes such goodies as choosing a memory manager &lt;http://libjpeg.cvs.sourceforge.net/viewvc/libjpeg/libjpeg/configure.ac?view=markup&gt; or configuring libpng.<br></p><p>And these are just the projects that *we* are associated with!<br></p><p>&gt; There are C projects that would benefit from modularization, header auditing, and cleanups that Swift and swiftpm would bring to it. <br></p><p>Swift and swiftpm don&#39;t do anything of the kind.  C developers do.  All we can do is try to impose new requirements on C developers.  And who is volunteering to implement those requirements?<br></p><p>It seems to me that if our new requirements are so amazing, it should be easy to convince a few projects to sign on to repackage.  libdispatch and Foundation are *our* projects; the bar is so low we&#39;re practically cheating.  Are they going to switch to this as their build system?  I don&#39;t know who makes this decision, but it seems like an important question to ask.<br></p><p>&gt; No Swift project could be built with swiftpm when it was introduced without repackaging. I don&#39;t see why C support should be held to a different standard.<br></p><p>Because we&#39;re designing a package manager for the Swift language, not the C language.  C has had build systems for decades.  We&#39;re not going to just waltz in with a new standard for a 44-year-old language and everybody switches the next day.  This is https://xkcd.com/927/ &lt;https://xkcd.com/927/&gt;.<br></p><p><br>&gt; On Jan 2, 2016, at 8:11 PM, Zach Waldowski via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I think an important feature of any C target proposal is that there will actually exist C targets which can be built under the proposal.  Until there are C people coming out of the woodwork saying &quot;sure, I will repackage my software this way&quot; I think the entire value is debatable.<br>&gt; <br>&gt;  <br>&gt; I almost couldn&#39;t disagree more. No Swift project could be built with swiftpm when it was introduced without repackaging. I don&#39;t see why C support should be held to a different standard.<br>&gt;  <br>&gt;&gt; And I do not see realistically how we are ever going to support a project like libsodium, except calling out to automake.<br>&gt;  <br>&gt; A potential solution (one of many possible) would look a lot like how people generate Xcode projects for C build systems today; hand-tuning config.h headers and such. I know many people who will go to ungodly lengths to avoid the inevitable nightmare automake causes in a source-distributed dependency.<br>&gt;  <br>&gt;&gt; IMO something like that is a much, much better direction in the short-term, and once we have done the first step of &quot;packaging&quot; those software via automake we will have &quot;real&quot; C projects in our package manager and we can design our C support around the concerns of real projects instead of imaginary ones.<br>&gt;  <br>&gt; There are C projects that would benefit from modularization, header auditing, and cleanups that Swift and swiftpm would bring to it. C projects are massively disorganized because build systems are a ridiculous hodgepodge; we didn&#39;t be subject to that long tail of good and bad decisions.<br>&gt;  <br>&gt; I don&#39;t think automake support would be a silver bullet at all, and contradict with many goals of swiftpm and llbuild to boot. Even targeting a really small subset of automake projects what liberties would unnecessarily complicate the project, and then there&#39;d be the projects it doesn&#39;t support.  (Oh? Wait? What version of the tools? Oh, from trunk? Oh, does the project take any liberties with its own organization? God help us when we start talking about C++…) <br>&gt;  <br>&gt; &quot;imaginary&quot; is a reductive way of phrasing the problem space. You keep referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual project you want support for; while there&#39;s a lot to be said for real-world use cases, I don&#39;t think this proposal&#39;s direction should be dictated by just libsodium.<br>&gt;  <br>&gt; Zachary<br>&gt;  <br>&gt; On Sat, Jan 2, 2016, at 04:57 PM, Drew Crawford via swift-build-dev wrote:<br>&gt;&gt; Thanks for directing me to this, I missed it.<br>&gt;&gt;  <br>&gt;&gt;&gt; Most projects will not conform to these conventions.<br>&gt;&gt;  <br>&gt;&gt; Giggle.  Kind of an understatement, no?<br>&gt;&gt;  <br>&gt;&gt; Like, okay.  Here is a project I&#39;d like to package.  (Read: I do package it, with features not in mainline swiftPM.)  https://github.com/jedisct1/libsodium &lt;https://github.com/jedisct1/libsodium&gt;<br>&gt;&gt;  <br>&gt;&gt; Let&#39;s take a look at how this package realistically builds:<br>&gt;&gt;  <br>&gt;&gt; * It has tests (&quot;make check&quot;)<br>&gt;&gt; * It has various --enable-foo flags<br>&gt;&gt; * It swaps in special implementations depending on if you have AMD64 &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L162&gt; or AVX instructions &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L145&gt; or SSE2 &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L229&gt; etc.<br>&gt;&gt; * The optimization level is tuned on a per-architecture basis &lt;https://github.com/jedisct1/libsodium/blob/master/dist-build/android-armv7-a.sh#L3&gt;<br>&gt;&gt; * They build (also) on Windows.  They&#39;re not changing how they&#39;re packaged for &quot;SwiftPM, the Mac/Linux build system&quot;.<br>&gt;&gt; * Oh and this is cryptography code.  Do you *really* want to touch it?<br>&gt;&gt;  <br>&gt;&gt; I think an important feature of any C target proposal is that there will actually exist C targets which can be built under the proposal.  Until there are C people coming out of the woodwork saying &quot;sure, I will repackage my software this way&quot; I think the entire value is debatable.<br>&gt;&gt;  <br>&gt;&gt; Getting signoff from libdispatch/CoreFoundation is necessary but not sufficient to clear that hurdle.  I would think getting the other C deps in our own project family to repackage would be &quot;table stakes&quot; for any new C build system.  The real test are projects that are third-party and less friendly.<br>&gt;&gt;  <br>&gt;&gt; And I do not see realistically how we are ever going to support a project like libsodium, except calling out to automake.  An automake solution coincidentally supports both libdispatch and CoreFoundation right now.  IMO something like that is a much, much better direction in the short-term, and once we have done the first step of &quot;packaging&quot; those software via automake we will have &quot;real&quot; C projects in our package manager and we can design our C support around the concerns of real projects instead of imaginary ones.<br>&gt;&gt;  <br>&gt;&gt;&gt; On Jan 2, 2016, at 11:00 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Happy 2016!<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>&gt;&gt;&gt; https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md &lt;https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Some TL;DR:<br>&gt;&gt;&gt; - The proposal defines a basic convention for pure C language targets (no Swift/C mix and match, but other Swift targets can use the C targets).<br>&gt;&gt;&gt; - This is just intended to be the minimal initial feature, there will be a lot of add on work which I expect should be tackled in follow on PRs/proposals.<br>&gt;&gt;&gt; - The proposal doesn&#39;t try and outline every single nitty detail (e.g., exactly what C++ standard we will compile with). My intention is to pick a sensible default at implementation time and refine incrementally.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Unless there are serious objections, I am hoping to hope to land this proposal soon and start work on the feature shortly after.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160103/09167323/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>January  4, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Drew,<br></p><p>First off, I believe that the right way to handle something like libsodium is to have support for building targets using an external build system. I see that as a separate and independent feature from this proposal though. If you are interested in working on that feature I would love to discuss it more on a separate thread (I already mentioned it explicitly on another thread I am unable to find right now) -- it is a feature I would really like to see us have but don&#39;t have the bandwidth to tackle at the moment.<br></p><p>This proposal is very specifically targeting the desire to be able to write and build new C code as part of Swift packages, it is not designed to support importing large existing projects. While I do hope that it will feature creep over time to allow more and more C projects to fit within the supported conventions, I also expect that to be a long incremental process.<br></p><p>At this stage of the project, I would encourage looking at new proposals and features from a perspective of &quot;does this add a useful new capability&quot; and &quot;is this in line with our goals&quot; rather than &quot;does this solve my immediate need X&quot;. <br></p><p>More comments in line...<br></p><p>&gt; On Jan 3, 2016, at 12:17 AM, Drew Crawford via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; You keep referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual project you want support for; while there&#39;s a lot to be said for real-world use cases, I don&#39;t think this proposal&#39;s direction should be dictated by just libsodium.<br>&gt; <br>&gt; Nothing about this is reductive or specific to libsodium.<br>&gt; <br>&gt; * libdispatch has a build manual &lt;https://github.com/apple/swift-corelibs-libdispatch/blob/master/INSTALL&gt; that runs over 100 lines and involves checking out *7* other repos.<br>&gt; * Foundation (incl CoreFoundation) has a python-based build &lt;https://github.com/apple/swift-corelibs-foundation/tree/master/lib&gt; system that runs to 1900 lines<br>&gt; * libjpeg is &quot;the&quot; example of a C dependency in our documentation, and its build system includes such goodies as choosing a memory manager &lt;http://libjpeg.cvs.sourceforge.net/viewvc/libjpeg/libjpeg/configure.ac?view=markup&gt; or configuring libpng.<br>&gt; <br>&gt; And these are just the projects that *we* are associated with!<br></p><p>These are projects I would expect to be tackled with an &quot;external build system&quot; feature, not this proposal.<br></p><p>&gt;&gt; There are C projects that would benefit from modularization, header auditing, and cleanups that Swift and swiftpm would bring to it. <br>&gt; <br>&gt; Swift and swiftpm don&#39;t do anything of the kind.  C developers do.  All we can do is try to impose new requirements on C developers.  And who is volunteering to implement those requirements?<br>&gt; <br>&gt; It seems to me that if our new requirements are so amazing, it should be easy to convince a few projects to sign on to repackage.  libdispatch and Foundation are *our* projects; the bar is so low we&#39;re practically cheating.  Are they going to switch to this as their build system?  I don&#39;t know who makes this decision, but it seems like an important question to ask.<br></p><p>While I think that &quot;support libdispatch and Foundation&quot; are good long term goals and useful reference points for what features are still needed to get there, it isn&#39;t the immediate goal here.<br></p><p>&gt;&gt; No Swift project could be built with swiftpm when it was introduced without repackaging. I don&#39;t see why C support should be held to a different standard.<br>&gt; <br>&gt; Because we&#39;re designing a package manager for the Swift language, not the C language.  C has had build systems for decades.  We&#39;re not going to just waltz in with a new standard for a 44-year-old language and everybody switches the next day.  This is https://xkcd.com/927/ &lt;https://xkcd.com/927/&gt;.<br></p><p>We can all dream, right? :)<br></p><p>&gt;&gt; On Jan 2, 2016, at 8:11 PM, Zach Waldowski via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I think an important feature of any C target proposal is that there will actually exist C targets which can be built under the proposal.  Until there are C people coming out of the woodwork saying &quot;sure, I will repackage my software this way&quot; I think the entire value is debatable.<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; I almost couldn&#39;t disagree more. No Swift project could be built with swiftpm when it was introduced without repackaging. I don&#39;t see why C support should be held to a different standard.<br></p><p>I agree with Zach here. The purpose of the proposal is to add support for new code written in C designed to integrate with other Swift code. The merits of the conventions should be weighed about how easy it is to write that code, and what the implications for maintenance (on both the package manager and the code itself) are.<br> <br>&gt;&gt;&gt; And I do not see realistically how we are ever going to support a project like libsodium, except calling out to automake.<br>&gt;&gt;  <br>&gt;&gt; A potential solution (one of many possible) would look a lot like how people generate Xcode projects for C build systems today; hand-tuning config.h headers and such. I know many people who will go to ungodly lengths to avoid the inevitable nightmare automake causes in a source-distributed dependency.<br>&gt;&gt;  <br>&gt;&gt;&gt; IMO something like that is a much, much better direction in the short-term, and once we have done the first step of &quot;packaging&quot; those software via automake we will have &quot;real&quot; C projects in our package manager and we can design our C support around the concerns of real projects instead of imaginary ones.<br>&gt;&gt;  <br>&gt;&gt; There are C projects that would benefit from modularization, header auditing, and cleanups that Swift and swiftpm would bring to it. C projects are massively disorganized because build systems are a ridiculous hodgepodge; we didn&#39;t be subject to that long tail of good and bad decisions.<br>&gt;&gt;  <br>&gt;&gt; I don&#39;t think automake support would be a silver bullet at all, and contradict with many goals of swiftpm and llbuild to boot. Even targeting a really small subset of automake projects what liberties would unnecessarily complicate the project, and then there&#39;d be the projects it doesn&#39;t support.  (Oh? Wait? What version of the tools? Oh, from trunk? Oh, does the project take any liberties with its own organization? God help us when we start talking about C++…) <br>&gt;&gt;  <br>&gt;&gt; &quot;imaginary&quot; is a reductive way of phrasing the problem space. You keep referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual project you want support for; while there&#39;s a lot to be said for real-world use cases, I don&#39;t think this proposal&#39;s direction should be dictated by just libsodium.<br>&gt;&gt;  <br>&gt;&gt; Zachary<br>&gt;&gt;  <br>&gt;&gt; On Sat, Jan 2, 2016, at 04:57 PM, Drew Crawford via swift-build-dev wrote:<br>&gt;&gt;&gt; Thanks for directing me to this, I missed it.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Most projects will not conform to these conventions.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Giggle.  Kind of an understatement, no?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Like, okay.  Here is a project I&#39;d like to package.  (Read: I do package it, with features not in mainline swiftPM.)  https://github.com/jedisct1/libsodium &lt;https://github.com/jedisct1/libsodium&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Let&#39;s take a look at how this package realistically builds:<br></p><p>Here is how I would expect these things to be tackled:<br> <br>&gt;&gt;&gt; * It has tests (&quot;make check&quot;)<br></p><p>I don&#39;t have any particular plan for this one.<br></p><p>&gt;&gt;&gt; * It has various --enable-foo flags<br></p><p>I expect that eventually the package manager will grow some level of support for this kind of thing (similar to Cargo&#39;s &quot;features&quot; -- http://doc.crates.io/manifest.html#the-[features]-section).<br></p><p>&gt;&gt;&gt; * It swaps in special implementations depending on if you have AMD64 &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L162&gt; or AVX instructions &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L145&gt; or SSE2 &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L229&gt; etc.<br>&gt;&gt;&gt; * The optimization level is tuned on a per-architecture basis &lt;https://github.com/jedisct1/libsodium/blob/master/dist-build/android-armv7-a.sh#L3&gt;<br></p><p>I expect that both of these would become possible with small enhancements to allow customization via the manifest file. Again, this is just the initial feature.<br></p><p>&gt;&gt;&gt; * They build (also) on Windows.  They&#39;re not changing how they&#39;re packaged for &quot;SwiftPM, the Mac/Linux build system&quot;.<br></p><p>I anticipate that we will eventually support alternative source layouts via customization in the manifest file (mostly to change where the sources are found, and the way headers are located and treated).<br></p><p>&gt;&gt;&gt; * Oh and this is cryptography code.  Do you *really* want to touch it?<br></p><p>It is a non-goal of this proposal to support projects which &quot;I don&#39;t want to touch&quot;.<br> <br>&gt;&gt;&gt; I think an important feature of any C target proposal is that there will actually exist C targets which can be built under the proposal.  Until there are C people coming out of the woodwork saying &quot;sure, I will repackage my software this way&quot; I think the entire value is debatable.<br></p><p>I think your language is more polarizing than is due here, and I would encourage focusing on a technical argument rather than a judgement like &quot;the entire value is debatable&quot;. This proposal will clearly allow packages to add small bits of C code which are used by other targets. Unless you believe that is incorrect (and if so, please present a technical argument for it), then to me that is a valuable capability (and if you disagree, then please present a technical argument for it).<br></p><p> - Daniel<br></p><p>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Getting signoff from libdispatch/CoreFoundation is necessary but not sufficient to clear that hurdle.  I would think getting the other C deps in our own project family to repackage would be &quot;table stakes&quot; for any new C build system.  The real test are projects that are third-party and less friendly.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; And I do not see realistically how we are ever going to support a project like libsodium, except calling out to automake.  An automake solution coincidentally supports both libdispatch and CoreFoundation right now.  IMO something like that is a much, much better direction in the short-term, and once we have done the first step of &quot;packaging&quot; those software via automake we will have &quot;real&quot; C projects in our package manager and we can design our C support around the concerns of real projects instead of imaginary ones.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Jan 2, 2016, at 11:00 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Happy 2016!<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>&gt;&gt;&gt;&gt; https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md &lt;https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Some TL;DR:<br>&gt;&gt;&gt;&gt; - The proposal defines a basic convention for pure C language targets (no Swift/C mix and match, but other Swift targets can use the C targets).<br>&gt;&gt;&gt;&gt; - This is just intended to be the minimal initial feature, there will be a lot of add on work which I expect should be tackled in follow on PRs/proposals.<br>&gt;&gt;&gt;&gt; - The proposal doesn&#39;t try and outline every single nitty detail (e.g., exactly what C++ standard we will compile with). My intention is to pick a sensible default at implementation time and refine incrementally.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Unless there are serious objections, I am hoping to hope to land this proposal soon and start work on the feature shortly after.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160104/a39e8f74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  5, 2016 at 04:00:00am</p></header><div class="content"><p>I think I understand better what you are trying to accomplish.  It is not a bad way to go about it, and I think my comments were not as constructive as they should have been.<br></p><p>I sent a PR that may clarify your motivation so as to head off objections like mine.  I think my reaction to the document was largely based around a misunderstanding about the motivation.  The title is &quot;Package Manager C Language Target Support&quot;, and so that sounds like it is a proposal about C language support as a whole, which immediately raises questions about whether Foundation et al can be someday made to fit in its box (e.g. via extending it etc.)  Whereas if we are clearer that this is merely one path to C language support, and this is the first one on the whiteboard then I think it is a lot stronger.  It does solve a problem, I have a better idea of what that problem is, and the fact that it doesn&#39;t map well onto my problems is no longer troubling.<br></p><p>&gt; I think your language is more polarizing than is due here, and I would encourage focusing on a technical argument rather than a judgement like &quot;the entire value is debatable&quot;.<br></p><p>I apologize for that.<br></p><p>For background, when the topic of native C support vs external build systems has come up in the past, there&#39;s been an implicit value judgment that building C with swiftPM is the &quot;preferred&quot; way, and using an external build system is the &quot;compromise&quot; way, and when we set up that value hierarchy it is necessarily the case that the two ideas are in conflict.<br></p><p>I&#39;m coming around to the idea that actually these are totally unrelated problems, they only looked similar at first glance, that neither is any better or worse than the other, that we need to support both, and so we should just give both of them permission to be excellent in their own way, and that we should not try to shoehorn one of them into the problems that the other one is better at.<br></p><p>Your proposal is clearly going to be better at the &quot;few files of C code&quot; problem, it was a bad idea for me to overcomplicate it with the problems of established C projects when they can be better served by handling them with an entirely separate solution.<br></p><p>&gt; On Jan 4, 2016, at 6:48 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Drew,<br>&gt; <br>&gt; First off, I believe that the right way to handle something like libsodium is to have support for building targets using an external build system. I see that as a separate and independent feature from this proposal though. If you are interested in working on that feature I would love to discuss it more on a separate thread (I already mentioned it explicitly on another thread I am unable to find right now) -- it is a feature I would really like to see us have but don&#39;t have the bandwidth to tackle at the moment.<br>&gt; <br>&gt; This proposal is very specifically targeting the desire to be able to write and build new C code as part of Swift packages, it is not designed to support importing large existing projects. While I do hope that it will feature creep over time to allow more and more C projects to fit within the supported conventions, I also expect that to be a long incremental process.<br>&gt; <br>&gt; At this stage of the project, I would encourage looking at new proposals and features from a perspective of &quot;does this add a useful new capability&quot; and &quot;is this in line with our goals&quot; rather than &quot;does this solve my immediate need X&quot;. <br>&gt; <br>&gt; More comments in line...<br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 12:17 AM, Drew Crawford via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; You keep referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual project you want support for; while there&#39;s a lot to be said for real-world use cases, I don&#39;t think this proposal&#39;s direction should be dictated by just libsodium.<br>&gt;&gt; <br>&gt;&gt; Nothing about this is reductive or specific to libsodium.<br>&gt;&gt; <br>&gt;&gt; * libdispatch has a build manual &lt;https://github.com/apple/swift-corelibs-libdispatch/blob/master/INSTALL&gt; that runs over 100 lines and involves checking out *7* other repos.<br>&gt;&gt; * Foundation (incl CoreFoundation) has a python-based build &lt;https://github.com/apple/swift-corelibs-foundation/tree/master/lib&gt; system that runs to 1900 lines<br>&gt;&gt; * libjpeg is &quot;the&quot; example of a C dependency in our documentation, and its build system includes such goodies as choosing a memory manager &lt;http://libjpeg.cvs.sourceforge.net/viewvc/libjpeg/libjpeg/configure.ac?view=markup&gt; or configuring libpng.<br>&gt;&gt; <br>&gt;&gt; And these are just the projects that *we* are associated with!<br>&gt; <br>&gt; These are projects I would expect to be tackled with an &quot;external build system&quot; feature, not this proposal.<br>&gt; <br>&gt;&gt;&gt; There are C projects that would benefit from modularization, header auditing, and cleanups that Swift and swiftpm would bring to it. <br>&gt;&gt; <br>&gt;&gt; Swift and swiftpm don&#39;t do anything of the kind.  C developers do.  All we can do is try to impose new requirements on C developers.  And who is volunteering to implement those requirements?<br>&gt;&gt; <br>&gt;&gt; It seems to me that if our new requirements are so amazing, it should be easy to convince a few projects to sign on to repackage.  libdispatch and Foundation are *our* projects; the bar is so low we&#39;re practically cheating.  Are they going to switch to this as their build system?  I don&#39;t know who makes this decision, but it seems like an important question to ask.<br>&gt; <br>&gt; While I think that &quot;support libdispatch and Foundation&quot; are good long term goals and useful reference points for what features are still needed to get there, it isn&#39;t the immediate goal here.<br>&gt; <br>&gt;&gt;&gt; No Swift project could be built with swiftpm when it was introduced without repackaging. I don&#39;t see why C support should be held to a different standard.<br>&gt;&gt; <br>&gt;&gt; Because we&#39;re designing a package manager for the Swift language, not the C language.  C has had build systems for decades.  We&#39;re not going to just waltz in with a new standard for a 44-year-old language and everybody switches the next day.  This is https://xkcd.com/927/ &lt;https://xkcd.com/927/&gt;.<br>&gt; <br>&gt; We can all dream, right? :)<br>&gt; <br>&gt;&gt;&gt; On Jan 2, 2016, at 8:11 PM, Zach Waldowski via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think an important feature of any C target proposal is that there will actually exist C targets which can be built under the proposal.  Until there are C people coming out of the woodwork saying &quot;sure, I will repackage my software this way&quot; I think the entire value is debatable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I almost couldn&#39;t disagree more. No Swift project could be built with swiftpm when it was introduced without repackaging. I don&#39;t see why C support should be held to a different standard.<br>&gt; <br>&gt; I agree with Zach here. The purpose of the proposal is to add support for new code written in C designed to integrate with other Swift code. The merits of the conventions should be weighed about how easy it is to write that code, and what the implications for maintenance (on both the package manager and the code itself) are.<br>&gt;  <br>&gt;&gt;&gt;&gt; And I do not see realistically how we are ever going to support a project like libsodium, except calling out to automake.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; A potential solution (one of many possible) would look a lot like how people generate Xcode projects for C build systems today; hand-tuning config.h headers and such. I know many people who will go to ungodly lengths to avoid the inevitable nightmare automake causes in a source-distributed dependency.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; IMO something like that is a much, much better direction in the short-term, and once we have done the first step of &quot;packaging&quot; those software via automake we will have &quot;real&quot; C projects in our package manager and we can design our C support around the concerns of real projects instead of imaginary ones.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; There are C projects that would benefit from modularization, header auditing, and cleanups that Swift and swiftpm would bring to it. C projects are massively disorganized because build systems are a ridiculous hodgepodge; we didn&#39;t be subject to that long tail of good and bad decisions.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I don&#39;t think automake support would be a silver bullet at all, and contradict with many goals of swiftpm and llbuild to boot. Even targeting a really small subset of automake projects what liberties would unnecessarily complicate the project, and then there&#39;d be the projects it doesn&#39;t support.  (Oh? Wait? What version of the tools? Oh, from trunk? Oh, does the project take any liberties with its own organization? God help us when we start talking about C++…) <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; &quot;imaginary&quot; is a reductive way of phrasing the problem space. You keep referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual project you want support for; while there&#39;s a lot to be said for real-world use cases, I don&#39;t think this proposal&#39;s direction should be dictated by just libsodium.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Zachary<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Sat, Jan 2, 2016, at 04:57 PM, Drew Crawford via swift-build-dev wrote:<br>&gt;&gt;&gt;&gt; Thanks for directing me to this, I missed it.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Most projects will not conform to these conventions.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Giggle.  Kind of an understatement, no?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Like, okay.  Here is a project I&#39;d like to package.  (Read: I do package it, with features not in mainline swiftPM.)  https://github.com/jedisct1/libsodium &lt;https://github.com/jedisct1/libsodium&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Let&#39;s take a look at how this package realistically builds:<br>&gt; <br>&gt; Here is how I would expect these things to be tackled:<br>&gt;  <br>&gt;&gt;&gt;&gt; * It has tests (&quot;make check&quot;)<br>&gt; <br>&gt; I don&#39;t have any particular plan for this one.<br>&gt; <br>&gt;&gt;&gt;&gt; * It has various --enable-foo flags<br>&gt; <br>&gt; I expect that eventually the package manager will grow some level of support for this kind of thing (similar to Cargo&#39;s &quot;features&quot; -- http://doc.crates.io/manifest.html#the-[features]-section &lt;http://doc.crates.io/manifest.html#the-[features]-section&gt;).<br>&gt; <br>&gt;&gt;&gt;&gt; * It swaps in special implementations depending on if you have AMD64 &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L162&gt; or AVX instructions &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L145&gt; or SSE2 &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L229&gt; etc.<br>&gt;&gt;&gt;&gt; * The optimization level is tuned on a per-architecture basis &lt;https://github.com/jedisct1/libsodium/blob/master/dist-build/android-armv7-a.sh#L3&gt;<br>&gt; <br>&gt; I expect that both of these would become possible with small enhancements to allow customization via the manifest file. Again, this is just the initial feature.<br>&gt; <br>&gt;&gt;&gt;&gt; * They build (also) on Windows.  They&#39;re not changing how they&#39;re packaged for &quot;SwiftPM, the Mac/Linux build system&quot;.<br>&gt; <br>&gt; I anticipate that we will eventually support alternative source layouts via customization in the manifest file (mostly to change where the sources are found, and the way headers are located and treated).<br>&gt; <br>&gt;&gt;&gt;&gt; * Oh and this is cryptography code.  Do you *really* want to touch it?<br>&gt; <br>&gt; It is a non-goal of this proposal to support projects which &quot;I don&#39;t want to touch&quot;.<br>&gt;  <br>&gt;&gt;&gt;&gt; I think an important feature of any C target proposal is that there will actually exist C targets which can be built under the proposal.  Until there are C people coming out of the woodwork saying &quot;sure, I will repackage my software this way&quot; I think the entire value is debatable.<br>&gt; <br>&gt; I think your language is more polarizing than is due here, and I would encourage focusing on a technical argument rather than a judgement like &quot;the entire value is debatable&quot;. This proposal will clearly allow packages to add small bits of C code which are used by other targets. Unless you believe that is incorrect (and if so, please present a technical argument for it), then to me that is a valuable capability (and if you disagree, then please present a technical argument for it).<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Getting signoff from libdispatch/CoreFoundation is necessary but not sufficient to clear that hurdle.  I would think getting the other C deps in our own project family to repackage would be &quot;table stakes&quot; for any new C build system.  The real test are projects that are third-party and less friendly.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; And I do not see realistically how we are ever going to support a project like libsodium, except calling out to automake.  An automake solution coincidentally supports both libdispatch and CoreFoundation right now.  IMO something like that is a much, much better direction in the short-term, and once we have done the first step of &quot;packaging&quot; those software via automake we will have &quot;real&quot; C projects in our package manager and we can design our C support around the concerns of real projects instead of imaginary ones.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Jan 2, 2016, at 11:00 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Happy 2016!<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md &lt;https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md&gt;<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Some TL;DR:<br>&gt;&gt;&gt;&gt;&gt; - The proposal defines a basic convention for pure C language targets (no Swift/C mix and match, but other Swift targets can use the C targets).<br>&gt;&gt;&gt;&gt;&gt; - This is just intended to be the minimal initial feature, there will be a lot of add on work which I expect should be tackled in follow on PRs/proposals.<br>&gt;&gt;&gt;&gt;&gt; - The proposal doesn&#39;t try and outline every single nitty detail (e.g., exactly what C++ standard we will compile with). My intention is to pick a sensible default at implementation time and refine incrementally.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Unless there are serious objections, I am hoping to hope to land this proposal soon and start work on the feature shortly after.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160105/ec0e3025/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17301ad52a677b00a621c39ab052e16d?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>Daniel Dunbar</string> &lt;daniel at zuster.org&gt;<p>January  5, 2016 at 10:00:00am</p></header><div class="content"><p>Great, glad we could all get on the same page!<br></p><p>I agree these are essentially two unrelated problems and we will end up<br>with two features to support them. Both will have pros and cons and we<br>should definitely shoot for both being &quot;excellent&quot;!<br></p><p>Thanks for the PR I&#39;ll take a look when I am back at a computer.<br></p><p> - Daniel<br></p><p>On Tuesday, January 5, 2016, Drew Crawford via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; I think I understand better what you are trying to accomplish.  It is not<br>&gt; a bad way to go about it, and I think my comments were not as constructive<br>&gt; as they should have been.<br>&gt;<br>&gt; I sent a PR that may clarify your motivation so as to head off objections<br>&gt; like mine.  I think my reaction to the document was largely based around a<br>&gt; misunderstanding about the motivation.  The title is &quot;Package Manager C<br>&gt; Language Target Support&quot;, and so that *sounds* like it is a proposal<br>&gt; about C language support as a whole, which immediately raises questions<br>&gt; about whether Foundation et al can be someday made to fit in its box (e.g.<br>&gt; via extending it etc.)  Whereas if we are clearer that this is *merely<br>&gt; one path to C language support, and this is the first one on the whiteboard* then<br>&gt; I think it is a lot stronger.  It does solve a problem, I have a better<br>&gt; idea of what that problem is, and the fact that it doesn&#39;t map well onto my<br>&gt; problems is no longer troubling.<br>&gt;<br>&gt; I think your language is more polarizing than is due here, and I would<br>&gt; encourage focusing on a technical argument rather than a judgement like<br>&gt; &quot;the entire value is debatable&quot;.<br>&gt;<br>&gt;<br>&gt; I apologize for that.<br>&gt;<br>&gt; For background, when the topic of native C support vs external build<br>&gt; systems has come up in the past, there&#39;s been an implicit value judgment<br>&gt; that building C with swiftPM is the &quot;preferred&quot; way, and using an external<br>&gt; build system is the &quot;compromise&quot; way, and when we set up that value<br>&gt; hierarchy it is necessarily the case that the two ideas are in conflict.<br>&gt;<br>&gt; I&#39;m coming around to the idea that actually these are totally unrelated<br>&gt; problems, they only looked similar at first glance, that neither is any<br>&gt; better or worse than the other, that we need to support both, and so we<br>&gt; should just give both of them permission to be excellent in their own way,<br>&gt; and that we should not try to shoehorn one of them into the problems that<br>&gt; the other one is better at.<br>&gt;<br>&gt; Your proposal is clearly going to be better at the &quot;few files of C code&quot;<br>&gt; problem, it was a bad idea for me to overcomplicate it with the problems of<br>&gt; established C projects when they can be better served by handling them with<br>&gt; an entirely separate solution.<br>&gt;<br>&gt; On Jan 4, 2016, at 6:48 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;daniel_dunbar at apple.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Hi Drew,<br>&gt;<br>&gt; First off, I believe that the right way to handle something like libsodium<br>&gt; is to have support for building targets using an external build system. I<br>&gt; see that as a separate and independent feature from this proposal though.<br>&gt; If you are interested in working on that feature I would love to discuss it<br>&gt; more on a separate thread (I already mentioned it explicitly on another<br>&gt; thread I am unable to find right now) -- it is a feature I would really<br>&gt; like to see us have but don&#39;t have the bandwidth to tackle at the moment.<br>&gt;<br>&gt; This proposal is very specifically targeting the desire to be able to<br>&gt; write and build new C code as part of Swift packages, it is not designed to<br>&gt; support importing large existing projects. While I do hope that it will<br>&gt; feature creep over time to allow more and more C projects to fit within the<br>&gt; supported conventions, I also expect that to be a long incremental process.<br>&gt;<br>&gt; At this stage of the project, I would encourage looking at new proposals<br>&gt; and features from a perspective of &quot;does this add a useful new capability&quot;<br>&gt; and &quot;is this in line with our goals&quot; rather than &quot;does this solve my<br>&gt; immediate need X&quot;.<br>&gt;<br>&gt; More comments in line...<br>&gt;<br>&gt; On Jan 3, 2016, at 12:17 AM, Drew Crawford via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-build-dev at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; You keep referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual<br>&gt; project you want support for; while there&#39;s a lot to be said for real-world<br>&gt; use cases, I don&#39;t think this proposal&#39;s direction should be dictated by<br>&gt; just libsodium.<br>&gt;<br>&gt;<br>&gt; Nothing about this is reductive or specific to libsodium.<br>&gt;<br>&gt; * libdispatch has a build manual<br>&gt; &lt;https://github.com/apple/swift-corelibs-libdispatch/blob/master/INSTALL&gt; that<br>&gt; runs over 100 lines and involves checking out *7* other repos.<br>&gt; * Foundation (incl CoreFoundation) has a python-based build<br>&gt; &lt;https://github.com/apple/swift-corelibs-foundation/tree/master/lib&gt; system<br>&gt; that runs to 1900 lines<br>&gt; * libjpeg is &quot;the&quot; example of a C dependency in our documentation, and its<br>&gt; build system includes such goodies as choosing a memory manager<br>&gt; &lt;http://libjpeg.cvs.sourceforge.net/viewvc/libjpeg/libjpeg/configure.ac?view=markup&gt; or<br>&gt; configuring libpng.<br>&gt;<br>&gt; And these are just the projects that *we* are associated with!<br>&gt;<br>&gt;<br>&gt; These are projects I would expect to be tackled with an &quot;external build<br>&gt; system&quot; feature, not this proposal.<br>&gt;<br>&gt; There are C projects that would benefit from modularization, header<br>&gt; auditing, and cleanups that Swift and swiftpm would bring to it.<br>&gt;<br>&gt;<br>&gt; Swift and swiftpm don&#39;t do anything of the kind.  C developers do.  All we<br>&gt; can do is try to impose new requirements on C developers.  And who is<br>&gt; volunteering to implement those requirements?<br>&gt;<br>&gt; It seems to me that if our new requirements are so amazing, it should be<br>&gt; easy to convince a few projects to sign on to repackage.  libdispatch and<br>&gt; Foundation are *our* projects; the bar is so low we&#39;re practically<br>&gt; cheating.  Are they going to switch to this as their build system?  I don&#39;t<br>&gt; know who makes this decision, but it seems like an important question to<br>&gt; ask.<br>&gt;<br>&gt;<br>&gt; While I think that &quot;support libdispatch and Foundation&quot; are good long term<br>&gt; goals and useful reference points for what features are still needed to get<br>&gt; there, it isn&#39;t the immediate goal here.<br>&gt;<br>&gt; No Swift project could be built with swiftpm when it was introduced<br>&gt; without repackaging. I don&#39;t see why C support should be held to a<br>&gt; different standard.<br>&gt;<br>&gt;<br>&gt; Because we&#39;re designing a package manager for the Swift language, not the<br>&gt; C language.  C has had build systems for decades.  We&#39;re not going to just<br>&gt; waltz in with a new standard for a 44-year-old language and everybody<br>&gt; switches the next day.  This is https://xkcd.com/927/.<br>&gt;<br>&gt;<br>&gt; We can all dream, right? :)<br>&gt;<br>&gt; On Jan 2, 2016, at 8:11 PM, Zach Waldowski via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-build-dev at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; *I think an important feature of any C target proposal is that there will<br>&gt; actually exist C targets which can be built under the proposal*.  Until<br>&gt; there are C people coming out of the woodwork saying &quot;sure, I will<br>&gt; repackage my software this way&quot; I think the entire value is debatable.<br>&gt;<br>&gt;<br>&gt; I almost couldn&#39;t disagree more. No Swift project could be built with<br>&gt; swiftpm when it was introduced without repackaging. I don&#39;t see why C<br>&gt; support should be held to a different standard.<br>&gt;<br>&gt;<br>&gt; I agree with Zach here. The purpose of the proposal is to add support for<br>&gt; new code written in C designed to integrate with other Swift code. The<br>&gt; merits of the conventions should be weighed about how easy it is to write<br>&gt; that code, and what the implications for maintenance (on both the package<br>&gt; manager and the code itself) are.<br>&gt;<br>&gt;<br>&gt; And I do not see realistically how we are ever going to support a project<br>&gt; like libsodium, except calling out to automake.<br>&gt;<br>&gt;<br>&gt; A potential solution (one of many possible) would look a lot like how<br>&gt; people generate Xcode projects for C build systems today; hand-tuning<br>&gt; config.h headers and such. I know many people who will go to ungodly<br>&gt; lengths to avoid the inevitable nightmare automake causes in a<br>&gt; source-distributed dependency.<br>&gt;<br>&gt;<br>&gt; IMO something like that is a much, much better direction in the<br>&gt; short-term, and once we have done the first step of &quot;packaging&quot; those<br>&gt; software via automake we will have &quot;real&quot; C projects in our package manager<br>&gt; and we can design our C support around the concerns of real projects<br>&gt; instead of imaginary ones.<br>&gt;<br>&gt;<br>&gt; There are C projects that would benefit from modularization, header<br>&gt; auditing, and cleanups that Swift and swiftpm would bring to it. C projects<br>&gt; are massively disorganized because build systems are a ridiculous<br>&gt; hodgepodge; we didn&#39;t be subject to that long tail of good and bad<br>&gt; decisions.<br>&gt;<br>&gt; I don&#39;t think automake support would be a silver bullet at all, and<br>&gt; contradict with many goals of swiftpm and llbuild to boot. Even targeting a<br>&gt; really small subset of automake projects what liberties would unnecessarily<br>&gt; complicate the project, and then there&#39;d be the projects it doesn&#39;t<br>&gt; support.  (Oh? Wait? What version of the tools? Oh, from trunk? Oh, does<br>&gt; the project take any liberties with its own organization? God help us when<br>&gt; we start talking about C++…)<br>&gt;<br>&gt; &quot;imaginary&quot; is a reductive way of phrasing the problem space. You keep<br>&gt; referring to &quot;&#39;real&#39; projects&quot; as a proxy for the individual project you<br>&gt; want support for; while there&#39;s a lot to be said for real-world use cases,<br>&gt; I don&#39;t think this proposal&#39;s direction should be dictated by just<br>&gt; libsodium.<br>&gt;<br>&gt; Zachary<br>&gt;<br>&gt; On Sat, Jan 2, 2016, at 04:57 PM, Drew Crawford via swift-build-dev wrote:<br>&gt;<br>&gt; Thanks for directing me to this, I missed it.<br>&gt;<br>&gt;<br>&gt; Most projects will not conform to these conventions.<br>&gt;<br>&gt;<br>&gt; Giggle.  Kind of an understatement, no?<br>&gt;<br>&gt; Like, okay.  Here is a project I&#39;d like to package.  (Read: I do package<br>&gt; it, with features not in mainline swiftPM.)<br>&gt; https://github.com/jedisct1/libsodium<br>&gt;<br>&gt; Let&#39;s take a look at how this package realistically builds:<br>&gt;<br>&gt;<br>&gt; Here is how I would expect these things to be tackled:<br>&gt;<br>&gt;<br>&gt; * It has tests (&quot;make check&quot;)<br>&gt;<br>&gt;<br>&gt; I don&#39;t have any particular plan for this one.<br>&gt;<br>&gt; * It has various --enable-foo flags<br>&gt;<br>&gt;<br>&gt; I expect that eventually the package manager will grow some level of<br>&gt; support for this kind of thing (similar to Cargo&#39;s &quot;features&quot; --<br>&gt; http://doc.crates.io/manifest.html#the-[features]-section).<br>&gt;<br>&gt; * It swaps in special implementations depending on if you have AMD64<br>&gt; &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L162&gt;<br>&gt;  or AVX instructions<br>&gt; &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L145&gt;<br>&gt;  or SSE2<br>&gt; &lt;https://github.com/jedisct1/libsodium/blob/master/src/libsodium/Makefile.am#L229&gt;<br>&gt;  etc.<br>&gt; * The optimization level is tuned on a per-architecture basis<br>&gt; &lt;https://github.com/jedisct1/libsodium/blob/master/dist-build/android-armv7-a.sh#L3&gt;<br>&gt;<br>&gt;<br>&gt; I expect that both of these would become possible with small enhancements<br>&gt; to allow customization via the manifest file. Again, this is just the<br>&gt; initial feature.<br>&gt;<br>&gt; * They build (also) on Windows.  They&#39;re not changing how they&#39;re packaged<br>&gt; for &quot;SwiftPM, the Mac/Linux build system&quot;.<br>&gt;<br>&gt;<br>&gt; I anticipate that we will eventually support alternative source layouts<br>&gt; via customization in the manifest file (mostly to change where the sources<br>&gt; are found, and the way headers are located and treated).<br>&gt;<br>&gt; * Oh and this is cryptography code.  Do you *really* want to touch it?<br>&gt;<br>&gt;<br>&gt; It is a non-goal of this proposal to support projects which &quot;I don&#39;t want<br>&gt; to touch&quot;.<br>&gt;<br>&gt;<br>&gt; *I think an important feature of any C target proposal is that there will<br>&gt; actually exist C targets which can be built under the proposal*.  Until<br>&gt; there are C people coming out of the woodwork saying &quot;sure, I will<br>&gt; repackage my software this way&quot; I think the entire value is debatable.<br>&gt;<br>&gt;<br>&gt; I think your language is more polarizing than is due here, and I would<br>&gt; encourage focusing on a technical argument rather than a judgement like<br>&gt; &quot;the entire value is debatable&quot;. This proposal will clearly allow packages<br>&gt; to add small bits of C code which are used by other targets. Unless you<br>&gt; believe that is incorrect (and if so, please present a technical argument<br>&gt; for it), then to me that is a valuable capability (and if you disagree,<br>&gt; then please present a technical argument for it).<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt;<br>&gt; Getting signoff from libdispatch/CoreFoundation is necessary but not<br>&gt; sufficient to clear that hurdle.  I would think getting the other C deps in<br>&gt; our own project family to repackage would be &quot;table stakes&quot; for any new C<br>&gt; build system.  The real test are projects that are third-party and less<br>&gt; friendly.<br>&gt;<br>&gt; And I do not see realistically how we are ever going to support a project<br>&gt; like libsodium, except calling out to automake.  An automake solution<br>&gt; coincidentally supports both libdispatch and CoreFoundation right now.  IMO<br>&gt; something like that is a much, much better direction in the short-term, and<br>&gt; once we have done the first step of &quot;packaging&quot; those software via automake<br>&gt; we will have &quot;real&quot; C projects in our package manager and we can design our<br>&gt; C support around the concerns of real projects instead of imaginary ones.<br>&gt;<br>&gt;<br>&gt; On Jan 2, 2016, at 11:00 AM, Daniel Dunbar via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-build-dev at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Happy 2016!<br>&gt;<br>&gt; I am working on an initial proposal for adding support for C language<br>&gt; targets to the Swift package manager, and am interested in feedback:<br>&gt;<br>&gt; https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md<br>&gt;<br>&gt; Some TL;DR:<br>&gt; - The proposal defines a basic convention for pure C language targets (no<br>&gt; Swift/C mix and match, but other Swift targets can use the C targets).<br>&gt; - This is just intended to be the minimal initial feature, there will be a<br>&gt; lot of add on work which I expect should be tackled in follow on<br>&gt; PRs/proposals.<br>&gt; - The proposal doesn&#39;t try and outline every single nitty detail (e.g.,<br>&gt; exactly what C++ standard we will compile with). My intention is to pick a<br>&gt; sensible default at implementation time and refine incrementally.<br>&gt;<br>&gt; Unless there are serious objections, I am hoping to hope to land this<br>&gt; proposal soon and start work on the feature shortly after.<br>&gt;<br>&gt; Cheers,<br>&gt; - Daniel<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-build-dev at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-build-dev at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-build-dev at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-build-dev at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160105/6b78ab1c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swiftpm] Add proposal for C language support</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January  2, 2016 at 07:00:00pm</p></header><div class="content"><p>Seems like a good start for Swift developers that need to write some C code for their project. <br></p><p>-David<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 2, 2016, at 9:00 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Happy 2016!<br>&gt; <br>&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>&gt;  https://github.com/ddunbar/swift-evolution/blob/master/proposals/NNNN-swiftpm-c-language-targets.md<br>&gt; <br>&gt; Some TL;DR:<br>&gt; - The proposal defines a basic convention for pure C language targets (no Swift/C mix and match, but other Swift targets can use the C targets).<br>&gt; - This is just intended to be the minimal initial feature, there will be a lot of add on work which I expect should be tackled in follow on PRs/proposals.<br>&gt; - The proposal doesn&#39;t try and outline every single nitty detail (e.g., exactly what C++ standard we will compile with). My intention is to pick a sensible default at implementation time and refine incrementally.<br>&gt; <br>&gt; Unless there are serious objections, I am hoping to hope to land this proposal soon and start work on the feature shortly after.<br>&gt; <br>&gt; Cheers,<br>&gt; - Daniel<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>[swift-build-dev] [swiftpm] Add proposal for C language support</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>January  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 9:00 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Happy 2016!<br>&gt; <br>&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br></p><p>The idea of including C libraries/code in Swift projects *without* having to use Xcode strikes me as *very* valuable. Two questions:<br></p><p>a) for item (2) in &quot;solution&quot; I see the advantages of placing the bridging in a separate directory, but I want to point out that this may make the interactions between various devenvs and things like GitHub more annoying. Xcode&#39;s Bridging-Header solution has it&#39;s own problems, but may be easier to work with in complex projects. Generally I think more flexibility here might be valuable, even going so far as a &quot;.bh&quot; for the bridging files, allowing them to be placed anywhere.<br></p><p>b) for (3), I&#39;m facing this problem right now porting some very old C that has a main.c that includes main() as well as other more general code that the rest of the system uses. I solved this by changing main(), but that&#39;s not ideal, I would greatly prefer to use the original code verbatim. So for the 10% of cases where this is a problem, perhaps a compiler directive would be useful?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-build-dev] [swiftpm] Add proposal for C language support</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>January  4, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 6:34 AM, Maury Markowitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 2, 2016, at 9:00 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Happy 2016!<br>&gt;&gt; <br>&gt;&gt; I am working on an initial proposal for adding support for C language targets to the Swift package manager, and am interested in feedback:<br>&gt; <br>&gt; The idea of including C libraries/code in Swift projects *without* having to use Xcode strikes me as *very* valuable. Two questions:<br>&gt; <br>&gt; a) for item (2) in &quot;solution&quot; I see the advantages of placing the bridging in a separate directory, but I want to point out that this may make the interactions between various devenvs and things like GitHub more annoying. Xcode&#39;s Bridging-Header solution has it&#39;s own problems, but may be easier to work with in complex projects. Generally I think more flexibility here might be valuable, even going so far as a &quot;.bh&quot; for the bridging files, allowing them to be placed anywhere.<br></p><p>We anticipate directly adding support for targets with both C and Swift code, at some point (which is where the bridging header comes in), but that is more involved and something I wanted to explicitly tackle separately. This proposal is very focused at adding support for building C source code that is a part of the project, and exposing the headers that declare the interfaces to that code. It is not really intended to tackle the problem of using C headers to expose *other* code.<br></p><p>&gt; b) for (3), I&#39;m facing this problem right now porting some very old C that has a main.c that includes main() as well as other more general code that the rest of the system uses. I solved this by changing main(), but that&#39;s not ideal, I would greatly prefer to use the original code verbatim. So for the 10% of cases where this is a problem, perhaps a compiler directive would be useful?<br></p><p>If you are integrating the code directly into your project I feel like it makes more sense to require some adaption in order to keep the conventions simple. There are likely a large number of adaptions necessary to integrate existing C projects into these conventions, over time I expect we will allow customization for common problems (and ones that are easy to define a syntax for customizing), but I&#39;m not sure if this one would bubble up to that level of importance.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
