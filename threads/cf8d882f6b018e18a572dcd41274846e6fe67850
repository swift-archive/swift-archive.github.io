<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I&#39;ve got a new proposal as an alternative to the one discussed in this thread: Simplified notation for avoiding the [weak self]/strongSelf dance with closures &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html&gt;.<br></p><p>There seems to be almost universal opinion that the pain point described in that proposal proposal is real, however the community seems split on possible solutions.<br></p><p>I&#39;m proposing this new alternative in the hopes that it will garner more support than a new guard capture type.<br></p><p>Link here:<br></p><p>https://gist.github.com/emaloney/4bfcb21aaced15af8884 &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884&gt;<br></p><p>The text of the proposal follows below.<br></p><p>Evan<br></p><p>---<br></p><p>Allow upgrading weak self to strong self by assignment<br></p><p>Proposal: TBD<br>Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>Status: Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#introduction&gt;Introduction<br></p><p>When working with escaping Swift closures, it is a common pattern to capture self weakly to avoid an object reference cycle.<br></p><p>For example, let&#39;s say you have a view controller that displays the result of a network operation. When the view controller is placed onscreen, it executes the operation and provides a closure to be executed when the operation completes.<br></p><p>The fact that a network operation may be in-flight should not prevent user from navigating away from that view controller. Similarly, we don&#39;t want a pending network operation to prevent our view controller from being deallocated once it goes offscreen. In other words, we only care about the network operation while the view controller is alive; once the view controller has been deallocated, we can safely ignore the result of any network request it initiated.<br></p><p>To achieve this, your networking code might look something like:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    guard let strongSelf = self else { return }<br></p><p>    switch result {<br>    case .Succeeded(let data):<br>        strongSelf.processData(data)<br></p><p>    case .Failed(let err):<br>        strongSelf.handleError(err)<br>    }<br>}<br>When it comes time to execute this closure, the guard statement effectively asks the question, &quot;Is the view controller represented by self still alive?&quot; If the answer is no, the guard forces a return and the rest of the closure does not execute.<br></p><p>If self is still alive, then the weakly-captured self will be non-nil and it will be converted into a strong reference held by strongSelf for the duration of the closure&#39;s execution.<br></p><p>When the closure is done executing, strongSelf goes away, once again making the view controller represented by selfeligible for deallocation if no other references are held.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#the-problem&gt;The Problem<br></p><p>The [weak self]/strongSelf dance requires common boilerplate wherever it is used, and the fact that a self-like variable with an arbitrary name adds noise within the closure. The more strongSelf is needed within the closure, the more noise there is. Further, using a consistent name like strongSelf is by convention only; it can&#39;t be enforced by the compiler.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#proposed-solution&gt;Proposed Solution<br></p><p>The proposed solution entails allowing self to be upgraded from a weak reference to a strong reference using assignment.<br></p><p>In any scope where self is a weak reference, the compiler will accept an assignment that upgrades self to a strong reference.<br></p><p>This would allow self to keep its meaningful name instead of being renamed to something arbitrary like strongSelf.<br></p><p>With this feature, the code above could be rewritten as:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    guard let self = self else { return }<br></p><p>    switch result {<br>    case .Succeeded(let data):<br>        self.processData(data)<br></p><p>    case .Failed(let err):<br>        self.handleError(err)<br>    }<br>}<br>The following would also be legal:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    if let self = self {<br>        switch result {<br>        case .Succeeded(let data):<br>            self.processData(data)<br></p><p>        case .Failed(let err):<br>            self.handleError(err)<br>        }<br>    }<br>}<br>As would this:<br></p><p>networkRequest.fetchData() { [weak self] result in<br>    guard self != nil else { return }<br></p><p>    let self = self!<br></p><p>    switch result {<br>    case .Succeeded(let data):<br>        self.processData(data)<br></p><p>    case .Failed(let err):<br>        self.handleError(err)<br>    }<br>}<br> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#behavior&gt;Behavior<br></p><p>Regardless of which notation is used for this feature, the behavior is the same:<br></p><p>The assignment of the strong self follows the same scoping rules as any other variable.<br></p><p>While the strong self is in scope, it masks the weak self variable. If the strong reference to self goes out of scope before the weak self reference does, the weak self will once again be visible to code.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#restrictions&gt;Restrictions<br></p><p>To ensure safety, the compiler will enforce certain restrictions on the use of this feature:<br></p><p>Attempting to use this feature in a context where self is not a weak reference to an object will cause a compiler error. <br></p><p>Assignment of self may only be used with let; assigning self to a var is an error. (Because this feature only works with object references and not value types, this restriction does not affect the mutability of self.)<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#alternatives-considered&gt;Alternatives Considered<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#status-quo&gt;Status Quo<br></p><p>The primary alternative is to do nothing, requiring developers to add boilerplate guard code and handle upgrading the weak-to-strong references manually.<br></p><p>As stated above, this leads to needless boilerplate that can easily be factored out by the compiler. Also, the use of a self-like variable with an arbitrary name makes it more difficult to exhaustively find such uses in large projects.<br></p><p>Finally, the need to declare and use alternate names to capture values that already have existing names adds visual clutter to code and serves to obscure the code&#39;s original intent, making it harder to reason about.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#adding-a-new-guard-capture-type&gt;Adding a new guard capture type<br></p><p>An alternate to this proposal involves adding a new capture type, called guard &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;, which would automatically handle upgrading self (and other references) from weak to strong.<br></p><p>Although the alternate proposal received a favorable response from the Swift Evolution mailing list, the community seemed split between the approach outlined in that proposal, and the one outlined here.<br></p><p> &lt;https://gist.github.com/emaloney/4bfcb21aaced15af8884#citations&gt;Citations<br></p><p>Variations on this proposal were discussed earlier in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; threads:<br></p><p>Wanted: syntactic sugar for [weak self] callbacks &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/008713.html&gt;<br>Allowing guard let self = self else { … } for weakly captured self in a closure. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009023.html&gt;<br>[Draft Proposal] A simplified notation for avoiding the weak/strong dance with closure capture lists &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/009241.html&gt;<br>[Proposal Update 1] A simplified notation for avoiding the weak/strong dance with closure capture lists &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009972.html&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/cf8d7850/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>Really quickly:<br></p><p>&gt; The following would also be legal:<br>&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;     if let self = self {<br>&gt;         switch result {<br>&gt;         case .Succeeded(let data):<br>&gt;             self.processData(data)<br>&gt; <br>&gt;         case .Failed(let err):<br>&gt;             self.handleError(err)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; As would this:<br>&gt; <br>&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;     guard self != nil else { return }<br>&gt; <br>&gt;     let self = self!<br>…isn’t there a race condition in this example (admittedly an *unlikely* one in most settings, but still…)?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/5b25bce4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 2:30 PM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;&gt;     guard self != nil else { return }<br>&gt;&gt; <br>&gt;&gt;     let self = self!<br>&gt; …isn’t there a race condition in this example (admittedly an *unlikely* one in most settings, but still…)?<br></p><p>Yes, that&#39;s a good point.<br></p><p>Now that I think about it, allowing a standalone `let self =` could never be implemented in a way *guaranteed* to avoid a race condition, so perhaps I should remove it from the proposal altogether.<br></p><p>When I incorporate the next round of feedback, I&#39;ll rework the proposal to indicate that it can only be used with `if let` or `guard let`.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/1cc3a858/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>Notwithstanding the third example, I think this is the cleanest way yet presented to do this. No new syntax, no loss of flexibility.<br></p><p>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 19, 2016 at 09:00:00pm</p></header><div class="content"><p>Very much in favor of this solution (removing the standalone let self = self!). Its does not introduce any new syntax, its semantics is very obvious, its explicit, and its also much more flexible than the alternative guard capture list proposal while keeping magic to the necessary minimum. <br></p><p>— Taras<br></p><p>&gt; On 19 Feb 2016, at 20:40, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 2:30 PM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;&gt;&gt;     guard self != nil else { return }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let self = self!<br>&gt;&gt; …isn’t there a race condition in this example (admittedly an *unlikely* one in most settings, but still…)?<br>&gt; <br>&gt; Yes, that&#39;s a good point.<br>&gt; <br>&gt; Now that I think about it, allowing a standalone `let self =` could never be implemented in a way *guaranteed* to avoid a race condition, so perhaps I should remove it from the proposal altogether.<br>&gt; <br>&gt; When I incorporate the next round of feedback, I&#39;ll rework the proposal to indicate that it can only be used with `if let` or `guard let`.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/2e9a6897/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 19, 2016 at 09:00:00pm</p></header><div class="content"><p>I also like this proposal. I wish we could go further in removing the<br>boilerplate but then you have to start to consider usage scenarios that you<br>would lose in the process.<br></p><p>For example [guard self] capture option supports one specific situation<br>without the ability of the block to take alternate actions in the situation<br>of weak self being nil and also requiring no return blocks. This is great<br>obviously for that particular situation however it doesn&#39;t really help with<br>the other situations.<br></p><p>This proposal allows for a wide range of possibilities in a language<br>natural way while reducing the code gyrations we currently do.<br></p><p><br>On Fri, Feb 19, 2016 at 12:21 PM Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Very much in favor of this solution (removing the standalone let self =<br>&gt; self!). Its does not introduce any new syntax, its semantics is very<br>&gt; obvious, its explicit, and its also much more flexible than the alternative<br>&gt; guard capture list proposal while keeping magic to the necessary minimum.<br>&gt;<br>&gt; — Taras<br>&gt;<br>&gt;<br>&gt; On 19 Feb 2016, at 20:40, Evan Maloney via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Feb 19, 2016, at 2:30 PM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;     guard self != nil else { return }<br>&gt;<br>&gt;     let self = self!<br>&gt;<br>&gt; …isn’t there a race condition in this example (admittedly an *unlikely*<br>&gt; one in most settings, but still…)?<br>&gt;<br>&gt;<br>&gt; Yes, that&#39;s a good point.<br>&gt;<br>&gt; Now that I think about it, allowing a standalone `let self =` could never<br>&gt; be implemented in a way *guaranteed* to avoid a race condition, so perhaps<br>&gt; I should remove it from the proposal altogether.<br>&gt;<br>&gt; When I incorporate the next round of feedback, I&#39;ll rework the proposal to<br>&gt; indicate that it can only be used with `if let` or `guard let`.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/cad60e76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 19, 2016 at 09:00:00pm</p></header><div class="content"><p>Oops clicked send by mistake...<br></p><p>I wanted to ponder going one step farther (of course it means modifying the<br>language a little).<br></p><p>networkRequest.fetchData() { [weak self, weak foo] result in<br>    guard strong self else { ..., return }<br>    guard strong foo else { ..., return }<br>    ...<br>}<br></p><p>networkRequest.fetchData() { [weak self, weak foo] result in<br>    if strong self {... if strong foo {...} else {...} ...} else {...}<br>}<br></p><p>... using strong as an attempt to imply that after the guard I want self<br>(or foo, etc.) to be a strong reference or in the first part of the if I<br>want self to be strong.<br></p><p><br>On Fri, Feb 19, 2016 at 1:39 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; I also like this proposal. I wish we could go further in removing the<br>&gt; boilerplate but then you have to start to consider usage scenarios that you<br>&gt; would lose in the process.<br>&gt;<br>&gt; For example [guard self] capture option supports one specific situation<br>&gt; without the ability of the block to take alternate actions in the situation<br>&gt; of weak self being nil and also requiring no return blocks. This is great<br>&gt; obviously for that particular situation however it doesn&#39;t really help with<br>&gt; the other situations.<br>&gt;<br>&gt; This proposal allows for a wide range of possibilities in a language<br>&gt; natural way while reducing the code gyrations we currently do.<br>&gt;<br>&gt;<br>&gt; On Fri, Feb 19, 2016 at 12:21 PM Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Very much in favor of this solution (removing the standalone let self =<br>&gt;&gt; self!). Its does not introduce any new syntax, its semantics is very<br>&gt;&gt; obvious, its explicit, and its also much more flexible than the alternative<br>&gt;&gt; guard capture list proposal while keeping magic to the necessary minimum.<br>&gt;&gt;<br>&gt;&gt; — Taras<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 19 Feb 2016, at 20:40, Evan Maloney via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Feb 19, 2016, at 2:30 PM, plx via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; networkRequest.fetchData() { [weak self] result in<br>&gt;&gt;     guard self != nil else { return }<br>&gt;&gt;<br>&gt;&gt;     let self = self!<br>&gt;&gt;<br>&gt;&gt; …isn’t there a race condition in this example (admittedly an *unlikely*<br>&gt;&gt; one in most settings, but still…)?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, that&#39;s a good point.<br>&gt;&gt;<br>&gt;&gt; Now that I think about it, allowing a standalone `let self =` could never<br>&gt;&gt; be implemented in a way *guaranteed* to avoid a race condition, so perhaps<br>&gt;&gt; I should remove it from the proposal altogether.<br>&gt;&gt;<br>&gt;&gt; When I incorporate the next round of feedback, I&#39;ll rework the proposal<br>&gt;&gt; to indicate that it can only be used with `if let` or `guard let`.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/9cfd6e64/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>February 19, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Feb 19, 2016 at 1:39 PM, Shawn Erickson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; For example [guard self] capture option supports one specific situation<br>&gt; without the ability of the block to take alternate actions in the situation<br>&gt; of weak self being nil and also requiring no return blocks. This is great<br>&gt; obviously for that particular situation however it doesn&#39;t really help with<br>&gt; the other situations.<br>&gt;<br></p><p>That&#39;s the beauty of it.  If you want to do something else, this isn&#39;t what<br>you want.  This is just a simple bit of sugar to get rid of the very common<br>use case where you have a nilable/void callback that you only want executed<br>if self is not nil.<br></p><p>If you want/need to do something more complicated, then<br>{ [unowned self] in<br>  guard self != nil else {<br>    Do the other thing<br>  }<br>}<br>is great.  It&#39;s not boilerplate because you&#39;re doing something useful in<br>the else case.<br></p><p>I do still prefer the [unowned self]? syntax, though.  It feels so similar<br>to object?.doSomething().  If the lvalue is nil, you get nothing!<br></p><p>Kurt<br>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/ff3204c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 19, 2016 at 10:00:00pm</p></header><div class="content"><p>I get that :) but I think it would be helpful to go beyond the no-op case<br>and help solve the &quot;strongify&quot; situation that exists in the larger problem<br>domain.<br></p><p>The &quot;strongify&quot; issue – to me – is mostly about avoiding the need to rename<br>the captured var in the block to allow for the reference to become a strong<br>reference. I feel it would be great to tackle that for more then the no-op<br>case.<br></p><p>In my experience I have had what once was &quot;a simple no-op on nil case&quot; turn<br>into &quot;if nil do some book keeping and no-op the rest&quot; often enough to<br>desire a broader solution.<br></p><p>On Fri, Feb 19, 2016 at 2:03 PM Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br></p><p>&gt; On Fri, Feb 19, 2016 at 1:39 PM, Shawn Erickson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; For example [guard self] capture option supports one specific situation<br>&gt;&gt; without the ability of the block to take alternate actions in the situation<br>&gt;&gt; of weak self being nil and also requiring no return blocks. This is great<br>&gt;&gt; obviously for that particular situation however it doesn&#39;t really help with<br>&gt;&gt; the other situations.<br>&gt;&gt;<br>&gt;<br>&gt; That&#39;s the beauty of it.  If you want to do something else, this isn&#39;t<br>&gt; what you want.  This is just a simple bit of sugar to get rid of the very<br>&gt; common use case where you have a nilable/void callback that you only want<br>&gt; executed if self is not nil.<br>&gt;<br>&gt; If you want/need to do something more complicated, then<br>&gt; { [unowned self] in<br>&gt;   guard self != nil else {<br>&gt;     Do the other thing<br>&gt;   }<br>&gt; }<br>&gt; is great.  It&#39;s not boilerplate because you&#39;re doing something useful in<br>&gt; the else case.<br>&gt;<br>&gt; I do still prefer the [unowned self]? syntax, though.  It feels so similar<br>&gt; to object?.doSomething().  If the lvalue is nil, you get nothing!<br>&gt;<br>&gt; Kurt<br>&gt; --<br>&gt; kurt at CircleW.org<br>&gt; http://www.CircleW.org/kurt/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/dcda8eb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>February 19, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Feb 19, 2016 at 2:30 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; I get that :) but I think it would be helpful to go beyond the no-op case<br>&gt; and help solve the &quot;strongify&quot; situation that exists in the larger problem<br>&gt; domain.<br>&gt;<br>&gt;&gt;<br>OK - so what&#39;s wrong with:<br></p><p><br>&gt; { [unowned self] in<br>&gt;&gt;   guard self != nil else {<br>&gt;&gt;     Do the other thing<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;<br>It&#39;s basically what you&#39;re asking for - an unowned implicitly unwrapped<br>variable followed by an else statement that takes care of the nil case.<br>Right?<br></p><p>Kurt<br>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/d8ffcc24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>February 19, 2016 at 02:00:00pm</p></header><div class="content"><p>And to follow up on my own email, isn&#39;t that exactly the flow you want?<br></p><p>First you do<br>{ [unowned self]? in<br>  ...<br>}<br></p><p>Then you realize that you need to deal with the else case.  You nuke the ?<br>and add a guard.<br>{ [unowned self] in<br>  guard if unowned self != nil self {<br>    ...<br></p><p>I mean -- I look at that and it seems clear and easy.  You have the ? to<br>deal with the nil case.  You remove it and add the block to deal with the<br>special nil case.  The intention of both seems clear.  You added the guard<br>code when you needed it.<br></p><p>Sign me up!<br>Kurt<br></p><p>On Fri, Feb 19, 2016 at 2:39 PM, Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Fri, Feb 19, 2016 at 2:30 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I get that :) but I think it would be helpful to go beyond the no-op case<br>&gt;&gt; and help solve the &quot;strongify&quot; situation that exists in the larger problem<br>&gt;&gt; domain.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt; OK - so what&#39;s wrong with:<br>&gt;<br>&gt;<br>&gt;&gt; { [unowned self] in<br>&gt;&gt;&gt;   guard self != nil else {<br>&gt;&gt;&gt;     Do the other thing<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; It&#39;s basically what you&#39;re asking for - an unowned implicitly unwrapped<br>&gt; variable followed by an else statement that takes care of the nil case.<br>&gt; Right?<br>&gt;<br>&gt; Kurt<br>&gt; --<br>&gt; kurt at CircleW.org<br>&gt; http://www.CircleW.org/kurt/<br>&gt;<br></p><p><br></p><p>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/2ead2dff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 19, 2016 at 11:00:00pm</p></header><div class="content"><p>I am talking about when capturing weak. The unowned capture situation is<br>the simpler variant of weak, one that doesn&#39;t happen to exhibit the<br>gyration of strongifying a weak capture.<br></p><p>In the weak situation you most often want to promote the captured weak<br>reference to a strong reference for some scope of code. You have to do this<br>currently by assigning the one or more captured weak references you have to<br>a differently named strong reference.<br></p><p>Additionally it isn&#39;t clear to me how a block with multiple captures would<br>play in what you are proposing.<br></p><p>If the strongify situation could be improved by allowing a captured weak<br>reference to be made strong while avoiding the renaming gyration then I<br>could see that being coupled with the &quot;[weak/unowned foo]? in&quot; no-op case<br>(assuming folks see enough reason for the no-op case).<br></p><p>-Shawn<br></p><p>On Fri, Feb 19, 2016 at 2:47 PM Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br></p><p>&gt; And to follow up on my own email, isn&#39;t that exactly the flow you want?<br>&gt;<br>&gt; First you do<br>&gt; { [unowned self]? in<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; Then you realize that you need to deal with the else case.  You nuke the ?<br>&gt; and add a guard.<br>&gt; { [unowned self] in<br>&gt;   guard if unowned self != nil self {<br>&gt;     ...<br>&gt;<br>&gt; I mean -- I look at that and it seems clear and easy.  You have the ? to<br>&gt; deal with the nil case.  You remove it and add the block to deal with the<br>&gt; special nil case.  The intention of both seems clear.  You added the guard<br>&gt; code when you needed it.<br>&gt;<br>&gt; Sign me up!<br>&gt; Kurt<br>&gt;<br>&gt; On Fri, Feb 19, 2016 at 2:39 PM, Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Feb 19, 2016 at 2:30 PM, Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I get that :) but I think it would be helpful to go beyond the no-op<br>&gt;&gt;&gt; case and help solve the &quot;strongify&quot; situation that exists in the larger<br>&gt;&gt;&gt; problem domain.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt; OK - so what&#39;s wrong with:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; { [unowned self] in<br>&gt;&gt;&gt;&gt;   guard self != nil else {<br>&gt;&gt;&gt;&gt;     Do the other thing<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; It&#39;s basically what you&#39;re asking for - an unowned implicitly unwrapped<br>&gt;&gt; variable followed by an else statement that takes care of the nil case.<br>&gt;&gt; Right?<br>&gt;&gt;<br>&gt;&gt; Kurt<br>&gt;&gt; --<br>&gt;&gt; kurt at CircleW.org<br>&gt;&gt; http://www.CircleW.org/kurt/<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; kurt at CircleW.org<br>&gt; http://www.CircleW.org/kurt/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/9a0a0f2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 19, 2016 at 11:00:00pm</p></header><div class="content"><p>Kurt curious... the &quot;[unowed self]? in&quot; style... is that part of another<br>proposal? The one I hit on is talking about using &quot;[guard self] in&quot;.<br></p><p>On Fri, Feb 19, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; I am talking about when capturing weak. The unowned capture situation is<br>&gt; the simpler variant of weak, one that doesn&#39;t happen to exhibit the<br>&gt; gyration of strongifying a weak capture.<br>&gt;<br>&gt; In the weak situation you most often want to promote the captured weak<br>&gt; reference to a strong reference for some scope of code. You have to do this<br>&gt; currently by assigning the one or more captured weak references you have to<br>&gt; a differently named strong reference.<br>&gt;<br>&gt; Additionally it isn&#39;t clear to me how a block with multiple captures would<br>&gt; play in what you are proposing.<br>&gt;<br>&gt; If the strongify situation could be improved by allowing a captured weak<br>&gt; reference to be made strong while avoiding the renaming gyration then I<br>&gt; could see that being coupled with the &quot;[weak/unowned foo]? in&quot; no-op case<br>&gt; (assuming folks see enough reason for the no-op case).<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt; On Fri, Feb 19, 2016 at 2:47 PM Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br>&gt;<br>&gt;&gt; And to follow up on my own email, isn&#39;t that exactly the flow you want?<br>&gt;&gt;<br>&gt;&gt; First you do<br>&gt;&gt; { [unowned self]? in<br>&gt;&gt;   ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Then you realize that you need to deal with the else case.  You nuke the<br>&gt;&gt; ? and add a guard.<br>&gt;&gt; { [unowned self] in<br>&gt;&gt;   guard if unowned self != nil self {<br>&gt;&gt;     ...<br>&gt;&gt;<br>&gt;&gt; I mean -- I look at that and it seems clear and easy.  You have the ? to<br>&gt;&gt; deal with the nil case.  You remove it and add the block to deal with the<br>&gt;&gt; special nil case.  The intention of both seems clear.  You added the guard<br>&gt;&gt; code when you needed it.<br>&gt;&gt;<br>&gt;&gt; Sign me up!<br>&gt;&gt; Kurt<br>&gt;&gt;<br>&gt;&gt; On Fri, Feb 19, 2016 at 2:39 PM, Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Feb 19, 2016 at 2:30 PM, Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I get that :) but I think it would be helpful to go beyond the no-op<br>&gt;&gt;&gt;&gt; case and help solve the &quot;strongify&quot; situation that exists in the larger<br>&gt;&gt;&gt;&gt; problem domain.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; OK - so what&#39;s wrong with:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; { [unowned self] in<br>&gt;&gt;&gt;&gt;&gt;   guard self != nil else {<br>&gt;&gt;&gt;&gt;&gt;     Do the other thing<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s basically what you&#39;re asking for - an unowned implicitly unwrapped<br>&gt;&gt;&gt; variable followed by an else statement that takes care of the nil case.<br>&gt;&gt;&gt; Right?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Kurt<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; kurt at CircleW.org<br>&gt;&gt;&gt; http://www.CircleW.org/kurt/<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; kurt at CircleW.org<br>&gt;&gt; http://www.CircleW.org/kurt/<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/7a75c631/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>February 19, 2016 at 03:00:00pm</p></header><div class="content"><p>On Fri, Feb 19, 2016 at 3:12 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br></p><p>&gt; Kurt curious... the &quot;[unowed self]? in&quot; style... is that part of another<br>&gt; proposal? The one I hit on is talking about using &quot;[guard self] in&quot;.<br>&gt;<br></p><p>Kenny Leung originally suggested instead of [guard self] (or my earlier<br>notion of [firm self]) that it be [unowned/weak self]? - which more closely<br>resembles the intent of object?.method() in that it does exactly the same<br>kind of thing - whereas [guard self] implies guard, which implies an else<br>statement and more complexity.<br></p><p>The drawback - as you have pointed out - is what to do with multiple<br>parameters<br>[unowned self, some, others]?<br>What does that do?  My (Kenny&#39;s) notion is that it implicitly does<br>if let self = self, some = some, others = others {<br>  ...<br>}<br></p><p>What if you want some tricky combination of strong/weak references in that<br>block that you want to handle, where some may be nil and others not?  Yeah,<br>this would not work for that.  But I can count the number of times where I<br>wanted complex references in a [parameter block] where I did not have to<br>handle them with various guards/if let&#39;s using no hands.  Which is to say,<br>this proposal is specifically for the very common boiler plate where you<br>want everything not to be nil, you don&#39;t want to explicitly unwrap it with<br>boiler plate code, and you want nothing to happen if something is nil.<br></p><p>While I like the look of [unowned self]? better than [guard self], I&#39;d be<br>happy enough with either.<br></p><p>Kurt<br></p><p><br>On Fri, Feb 19, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I am talking about when capturing weak. The unowned capture situation is<br>&gt;&gt; the simpler variant of weak, one that doesn&#39;t happen to exhibit the<br>&gt;&gt; gyration of strongifying a weak capture.<br>&gt;&gt;<br>&gt;&gt; In the weak situation you most often want to promote the captured weak<br>&gt;&gt; reference to a strong reference for some scope of code. You have to do this<br>&gt;&gt; currently by assigning the one or more captured weak references you have to<br>&gt;&gt; a differently named strong reference.<br>&gt;&gt;<br>&gt;&gt; Additionally it isn&#39;t clear to me how a block with multiple captures<br>&gt;&gt; would play in what you are proposing.<br>&gt;&gt;<br>&gt;&gt; If the strongify situation could be improved by allowing a captured weak<br>&gt;&gt; reference to be made strong while avoiding the renaming gyration then I<br>&gt;&gt; could see that being coupled with the &quot;[weak/unowned foo]? in&quot; no-op case<br>&gt;&gt; (assuming folks see enough reason for the no-op case).<br>&gt;&gt;<br>&gt;&gt; -Shawn<br>&gt;&gt;<br>&gt;&gt; On Fri, Feb 19, 2016 at 2:47 PM Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; And to follow up on my own email, isn&#39;t that exactly the flow you want?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; First you do<br>&gt;&gt;&gt; { [unowned self]? in<br>&gt;&gt;&gt;   ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Then you realize that you need to deal with the else case.  You nuke the<br>&gt;&gt;&gt; ? and add a guard.<br>&gt;&gt;&gt; { [unowned self] in<br>&gt;&gt;&gt;   guard if unowned self != nil self {<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I mean -- I look at that and it seems clear and easy.  You have the ? to<br>&gt;&gt;&gt; deal with the nil case.  You remove it and add the block to deal with the<br>&gt;&gt;&gt; special nil case.  The intention of both seems clear.  You added the guard<br>&gt;&gt;&gt; code when you needed it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sign me up!<br>&gt;&gt;&gt; Kurt<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Feb 19, 2016 at 2:39 PM, Kurt Werle &lt;kurt at circlew.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Fri, Feb 19, 2016 at 2:30 PM, Shawn Erickson &lt;shawnce at gmail.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I get that :) but I think it would be helpful to go beyond the no-op<br>&gt;&gt;&gt;&gt;&gt; case and help solve the &quot;strongify&quot; situation that exists in the larger<br>&gt;&gt;&gt;&gt;&gt; problem domain.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; OK - so what&#39;s wrong with:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; { [unowned self] in<br>&gt;&gt;&gt;&gt;&gt;&gt;   guard self != nil else {<br>&gt;&gt;&gt;&gt;&gt;&gt;     Do the other thing<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It&#39;s basically what you&#39;re asking for - an unowned implicitly unwrapped<br>&gt;&gt;&gt;&gt; variable followed by an else statement that takes care of the nil case.<br>&gt;&gt;&gt;&gt; Right?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Kurt<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; kurt at CircleW.org<br>&gt;&gt;&gt;&gt; http://www.CircleW.org/kurt/<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; kurt at CircleW.org<br>&gt;&gt;&gt; http://www.CircleW.org/kurt/<br>&gt;&gt;&gt;<br>&gt;&gt;<br></p><p><br>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/e0f0128b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 20, 2016 at 10:00:00am</p></header><div class="content"><p>A quick note, I&#39;m not sure if it&#39;s a hack but you can probably still do<br>this:<br></p><p>   guard let `self` = self else { return }<br></p><p>It would be good to support this without backticks, I suppose it would be<br>very special case though. I wonder if you could reassign self as a<br>different type...<br></p><p><br>Andrew Bennett<br></p><p>On Saturday, 20 February 2016, Kurt Werle via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Fri, Feb 19, 2016 at 3:12 PM, Shawn Erickson &lt;shawnce at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;shawnce at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Kurt curious... the &quot;[unowed self]? in&quot; style... is that part of another<br>&gt;&gt; proposal? The one I hit on is talking about using &quot;[guard self] in&quot;.<br>&gt;&gt;<br>&gt;<br>&gt; Kenny Leung originally suggested instead of [guard self] (or my earlier<br>&gt; notion of [firm self]) that it be [unowned/weak self]? - which more closely<br>&gt; resembles the intent of object?.method() in that it does exactly the same<br>&gt; kind of thing - whereas [guard self] implies guard, which implies an else<br>&gt; statement and more complexity.<br>&gt;<br>&gt; The drawback - as you have pointed out - is what to do with multiple<br>&gt; parameters<br>&gt; [unowned self, some, others]?<br>&gt; What does that do?  My (Kenny&#39;s) notion is that it implicitly does<br>&gt; if let self = self, some = some, others = others {<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; What if you want some tricky combination of strong/weak references in that<br>&gt; block that you want to handle, where some may be nil and others not?  Yeah,<br>&gt; this would not work for that.  But I can count the number of times where I<br>&gt; wanted complex references in a [parameter block] where I did not have to<br>&gt; handle them with various guards/if let&#39;s using no hands.  Which is to say,<br>&gt; this proposal is specifically for the very common boiler plate where you<br>&gt; want everything not to be nil, you don&#39;t want to explicitly unwrap it with<br>&gt; boiler plate code, and you want nothing to happen if something is nil.<br>&gt;<br>&gt; While I like the look of [unowned self]? better than [guard self], I&#39;d be<br>&gt; happy enough with either.<br>&gt;<br>&gt; Kurt<br>&gt;<br>&gt;<br>&gt; On Fri, Feb 19, 2016 at 3:08 PM Shawn Erickson &lt;shawnce at gmail.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;shawnce at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I am talking about when capturing weak. The unowned capture situation is<br>&gt;&gt;&gt; the simpler variant of weak, one that doesn&#39;t happen to exhibit the<br>&gt;&gt;&gt; gyration of strongifying a weak capture.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the weak situation you most often want to promote the captured weak<br>&gt;&gt;&gt; reference to a strong reference for some scope of code. You have to do this<br>&gt;&gt;&gt; currently by assigning the one or more captured weak references you have to<br>&gt;&gt;&gt; a differently named strong reference.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Additionally it isn&#39;t clear to me how a block with multiple captures<br>&gt;&gt;&gt; would play in what you are proposing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the strongify situation could be improved by allowing a captured weak<br>&gt;&gt;&gt; reference to be made strong while avoiding the renaming gyration then I<br>&gt;&gt;&gt; could see that being coupled with the &quot;[weak/unowned foo]? in&quot; no-op case<br>&gt;&gt;&gt; (assuming folks see enough reason for the no-op case).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Feb 19, 2016 at 2:47 PM Kurt Werle &lt;kurt at circlew.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;kurt at circlew.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And to follow up on my own email, isn&#39;t that exactly the flow you want?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; First you do<br>&gt;&gt;&gt;&gt; { [unowned self]? in<br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Then you realize that you need to deal with the else case.  You nuke<br>&gt;&gt;&gt;&gt; the ? and add a guard.<br>&gt;&gt;&gt;&gt; { [unowned self] in<br>&gt;&gt;&gt;&gt;   guard if unowned self != nil self {<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I mean -- I look at that and it seems clear and easy.  You have the ?<br>&gt;&gt;&gt;&gt; to deal with the nil case.  You remove it and add the block to deal with<br>&gt;&gt;&gt;&gt; the special nil case.  The intention of both seems clear.  You added the<br>&gt;&gt;&gt;&gt; guard code when you needed it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sign me up!<br>&gt;&gt;&gt;&gt; Kurt<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Fri, Feb 19, 2016 at 2:39 PM, Kurt Werle &lt;kurt at circlew.org<br>&gt;&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;kurt at circlew.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Fri, Feb 19, 2016 at 2:30 PM, Shawn Erickson &lt;shawnce at gmail.com<br>&gt;&gt;&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;shawnce at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I get that :) but I think it would be helpful to go beyond the no-op<br>&gt;&gt;&gt;&gt;&gt;&gt; case and help solve the &quot;strongify&quot; situation that exists in the larger<br>&gt;&gt;&gt;&gt;&gt;&gt; problem domain.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; OK - so what&#39;s wrong with:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; { [unowned self] in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   guard self != nil else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     Do the other thing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It&#39;s basically what you&#39;re asking for - an unowned implicitly<br>&gt;&gt;&gt;&gt;&gt; unwrapped variable followed by an else statement that takes care of the nil<br>&gt;&gt;&gt;&gt;&gt; case.  Right?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Kurt<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; kurt at CircleW.org<br>&gt;&gt;&gt;&gt;&gt; http://www.CircleW.org/kurt/<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; kurt at CircleW.org<br>&gt;&gt;&gt;&gt; http://www.CircleW.org/kurt/<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; kurt at CircleW.org<br>&gt; http://www.CircleW.org/kurt/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/6e9e425d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 19, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 8:40 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A quick note, I&#39;m not sure if it&#39;s a hack but you can probably still do this:<br>&gt; <br>&gt;    guard let `self` = self else { return }<br></p><p>IIRC, the fact that this works is accidental and Chris Lattner mentioned that it should be considered a bug.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 20, 2016 at 05:00:00pm</p></header><div class="content"><p>Yes, I only learnt about it from Chris Lattner&#39;s comment. Great idea to do<br>it right :)<br></p><p>If I remember correctly I think he said not to rely on it because it wasn&#39;t<br>intentional. I&#39;m not sure if he said it was undesirable. I thought it may<br>be worth mentioning in case you didn&#39;t know, and because it may help the<br>proposal if it had:<br></p><p>   - you can already do `self` = self, but it&#39;s not officially supported<br>   - this formalises that ability, and removes the need for backticks<br></p><p>Also, you may want to mention that this **only** works between `self`<br>and `[weak<br>self]`, ie. you cannot do:<br></p><p><br>guard self = Optional.Some(123) else { ... }<br></p><p><br></p><p>On Sat, Feb 20, 2016 at 1:18 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br></p><p>&gt; &gt; On Feb 19, 2016, at 8:40 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; A quick note, I&#39;m not sure if it&#39;s a hack but you can probably still do<br>&gt; this:<br>&gt; &gt;<br>&gt; &gt;    guard let `self` = self else { return }<br>&gt;<br>&gt; IIRC, the fact that this works is accidental and Chris Lattner mentioned<br>&gt; that it should be considered a bug.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/e425da04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for the feedback, Andrew. I will incorporate it in the next draft, to be sent shortly.<br></p><p>Incidentally, I found Chris Lattner&#39;s response about assigning `self`, specifically his statement that &quot;this is a compiler bug&quot;:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007425.html<br></p><p><br></p><p><br>&gt; On Feb 20, 2016, at 3:55 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes, I only learnt about it from Chris Lattner&#39;s comment. Great idea to do it right :)<br>&gt; <br>&gt; If I remember correctly I think he said not to rely on it because it wasn&#39;t intentional. I&#39;m not sure if he said it was undesirable. I thought it may be worth mentioning in case you didn&#39;t know, and because it may help the proposal if it had:<br>&gt; you can already do `self` = self, but it&#39;s not officially supported<br>&gt; this formalises that ability, and removes the need for backticks<br>&gt; Also, you may want to mention that this *only* works between `self` and `[weak self]`, ie. you cannot do:<br>&gt; <br>&gt; guard self = Optional.Some(123) else { ... }<br>&gt; <br>&gt; <br>&gt; On Sat, Feb 20, 2016 at 1:18 PM, Evan Maloney &lt;emaloney at gilt.com &lt;mailto:emaloney at gilt.com&gt;&gt; wrote:<br>&gt; &gt; On Feb 19, 2016, at 8:40 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; A quick note, I&#39;m not sure if it&#39;s a hack but you can probably still do this:<br>&gt; &gt;<br>&gt; &gt;    guard let `self` = self else { return }<br>&gt; <br>&gt; IIRC, the fact that this works is accidental and Chris Lattner mentioned that it should be considered a bug.<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/1608e22d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Proposal] Allow upgrading weak self to strong self by assignment</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 23, 2016 at 07:00:00am</p></header><div class="content"><p>I like the proposal also.<br></p><p>-- <br>Pierre<br></p><p><br></p><p>&gt; Le 22 févr. 2016 à 20:16, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Thanks for the feedback, Andrew. I will incorporate it in the next draft, to be sent shortly.<br>&gt; <br>&gt; Incidentally, I found Chris Lattner&#39;s response about assigning `self`, specifically his statement that &quot;this is a compiler bug&quot;:<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007425.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007425.html&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 20, 2016, at 3:55 AM, Andrew Bennett &lt;cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, I only learnt about it from Chris Lattner&#39;s comment. Great idea to do it right :)<br>&gt;&gt; <br>&gt;&gt; If I remember correctly I think he said not to rely on it because it wasn&#39;t intentional. I&#39;m not sure if he said it was undesirable. I thought it may be worth mentioning in case you didn&#39;t know, and because it may help the proposal if it had:<br>&gt;&gt; you can already do `self` = self, but it&#39;s not officially supported<br>&gt;&gt; this formalises that ability, and removes the need for backticks<br>&gt;&gt; Also, you may want to mention that this *only* works between `self` and `[weak self]`, ie. you cannot do:<br>&gt;&gt; <br>&gt;&gt; guard self = Optional.Some(123) else { ... }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Feb 20, 2016 at 1:18 PM, Evan Maloney &lt;emaloney at gilt.com &lt;mailto:emaloney at gilt.com&gt;&gt; wrote:<br>&gt;&gt; &gt; On Feb 19, 2016, at 8:40 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A quick note, I&#39;m not sure if it&#39;s a hack but you can probably still do this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    guard let `self` = self else { return }<br>&gt;&gt; <br>&gt;&gt; IIRC, the fact that this works is accidental and Chris Lattner mentioned that it should be considered a bug.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/9e8c28e3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
