<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>February 19, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;d like to see #if support os(Darwin) as shorthand for any Apple platform. This is a lot shorter to type, and it&#39;s also future-compatible if Apple ever releases another Darwin-based platform. If os(Darwin) evaluates to true, then `import Darwin` should always work, and presumably `import Foundation` as well.<br></p><p>Without this, I think people are going to be tempted to write `if !os(Linux)` instead of writing out all 4 Apple platforms, and this is unfortunate because it makes the assumption that Linux is the only non-Apple platform, and that&#39;s simply not true.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>February 19, 2016 at 12:00:00pm</p></header><div class="content"><p>Agreed. I’ve used #if _runtime(_ObjC) for this, and it’s just not the right thing to do…<br></p><p>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 19, 2016 at 11:00:00am</p></header><div class="content"><p>I agree that we need something here, but I really like the property we have today that all of the &quot;os&quot; options are mutually exclusive. (Compare: TARGET_OS_IPHONE and TARGET_OS_IOS in &lt;TargetConditionals.h&gt;.) I&#39;d be happy to invent a new predicate for this, though.<br></p><p>Other considerations:<br>- Different Linux distros?<br>- Common ground across BSDs?<br>- Unixy? (vs. Windows)<br></p><p>And for other platform conditions:<br>- Architecture subtypes?<br>- Architecture families? (&quot;32-bit&quot; is a good one.)<br></p><p>Jordan<br></p><p><br>&gt; On Feb 19, 2016, at 11:19, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to see #if support os(Darwin) as shorthand for any Apple platform. This is a lot shorter to type, and it&#39;s also future-compatible if Apple ever releases another Darwin-based platform. If os(Darwin) evaluates to true, then `import Darwin` should always work, and presumably `import Foundation` as well.<br>&gt; <br>&gt; Without this, I think people are going to be tempted to write `if !os(Linux)` instead of writing out all 4 Apple platforms, and this is unfortunate because it makes the assumption that Linux is the only non-Apple platform, and that&#39;s simply not true.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;ve had to reverse all my `#if os`&#39;s because nearly all the code on iOS/watchOS/tvOS is shared, so all my code that *used* to be `#if os(iOS)` is now based on OS X because of that.<br></p><p>I&#39;d very much welcome a larger vocabulary, not to mention picking up debug/release (pretty please)<br></p><p>-- E<br></p><p><br>&gt; On Feb 19, 2016, at 12:53 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that we need something here, but I really like the property we have today that all of the &quot;os&quot; options are mutually exclusive. (Compare: TARGET_OS_IPHONE and TARGET_OS_IOS in &lt;TargetConditionals.h&gt;.) I&#39;d be happy to invent a new predicate for this, though.<br>&gt; <br>&gt; Other considerations:<br>&gt; - Different Linux distros?<br>&gt; - Common ground across BSDs?<br>&gt; - Unixy? (vs. Windows)<br>&gt; <br>&gt; And for other platform conditions:<br>&gt; - Architecture subtypes?<br>&gt; - Architecture families? (&quot;32-bit&quot; is a good one.)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 11:19, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to see #if support os(Darwin) as shorthand for any Apple platform. This is a lot shorter to type, and it&#39;s also future-compatible if Apple ever releases another Darwin-based platform. If os(Darwin) evaluates to true, then `import Darwin` should always work, and presumably `import Foundation` as well.<br>&gt;&gt; <br>&gt;&gt; Without this, I think people are going to be tempted to write `if !os(Linux)` instead of writing out all 4 Apple platforms, and this is unfortunate because it makes the assumption that Linux is the only non-Apple platform, and that&#39;s simply not true.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>February 19, 2016 at 04:00:00pm</p></header><div class="content"><p>SwiftPM passes DEBUG and NDEBUG. Ugly, but the standard.<br></p><p>&gt; On Feb 19, 2016, at 12:41 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve had to reverse all my `#if os`&#39;s because nearly all the code on iOS/watchOS/tvOS is shared, so all my code that *used* to be `#if os(iOS)` is now based on OS X because of that.<br>&gt; <br>&gt; I&#39;d very much welcome a larger vocabulary, not to mention picking up debug/release (pretty please)<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 12:53 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that we need something here, but I really like the property we have today that all of the &quot;os&quot; options are mutually exclusive. (Compare: TARGET_OS_IPHONE and TARGET_OS_IOS in &lt;TargetConditionals.h&gt;.) I&#39;d be happy to invent a new predicate for this, though.<br>&gt;&gt; <br>&gt;&gt; Other considerations:<br>&gt;&gt; - Different Linux distros?<br>&gt;&gt; - Common ground across BSDs?<br>&gt;&gt; - Unixy? (vs. Windows)<br>&gt;&gt; <br>&gt;&gt; And for other platform conditions:<br>&gt;&gt; - Architecture subtypes?<br>&gt;&gt; - Architecture families? (&quot;32-bit&quot; is a good one.)<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 19, 2016, at 11:19, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to see #if support os(Darwin) as shorthand for any Apple platform. This is a lot shorter to type, and it&#39;s also future-compatible if Apple ever releases another Darwin-based platform. If os(Darwin) evaluates to true, then `import Darwin` should always work, and presumably `import Foundation` as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Without this, I think people are going to be tempted to write `if !os(Linux)` instead of writing out all 4 Apple platforms, and this is unfortunate because it makes the assumption that Linux is the only non-Apple platform, and that&#39;s simply not true.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 4:50 PM, Max Howell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; SwiftPM passes DEBUG and NDEBUG. Ugly, but the standard.<br></p><p>I don&#39;t think it&#39;s the package manager&#39;s place to do that, since the compiler&#39;s already aware of the current build mode. IMO all the standard #if flags should ideally be centralized in the language so there isn&#39;t a forever-creeping set of conventional -D flags like there are in C land. (Tradition or not, negative flags like NDEBUG should be put out to pasture—we&#39;ve let go of other, less terrible C traditions.)<br></p><p>We specifically avoided making debug/release an #if condition because we considered #if to be the wrong point at which to start conditionalizing code generation for assertions. Though the final executable image&#39;s behavior is unavoidably dependent on whether asserts are enabled, we didn&#39;t want the SIL for inlineable code to be, since that would mean libraries with inlineable code would need to ship three times the amount of serialized SIL to support the right behavior in -Onone, -O, and -Ounchecked builds. Instead, the standard library has some hidden helper functions, `_isDebugAssertConfiguration`, `_isReleaseAssertConfiguration`, and `_isFastAssertConfiguration`, which are guaranteed to be constant-folded away before final code generation. This means we can compile a function like this down to SIL once:<br></p><p>func assert(@autoclosure _ condition: () -&gt; Bool) {<br>  if _isDebugAssertConfiguration() &amp;&amp; !condition() {<br>    fatalError()<br>  }<br>}<br></p><p>for all of the possible assert behaviors.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; On Feb 19, 2016, at 12:41 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve had to reverse all my `#if os`&#39;s because nearly all the code on iOS/watchOS/tvOS is shared, so all my code that *used* to be `#if os(iOS)` is now based on OS X because of that.<br>&gt;&gt; <br>&gt;&gt; I&#39;d very much welcome a larger vocabulary, not to mention picking up debug/release (pretty please)<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 19, 2016, at 12:53 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that we need something here, but I really like the property we have today that all of the &quot;os&quot; options are mutually exclusive. (Compare: TARGET_OS_IPHONE and TARGET_OS_IOS in &lt;TargetConditionals.h&gt;.) I&#39;d be happy to invent a new predicate for this, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other considerations:<br>&gt;&gt;&gt; - Different Linux distros?<br>&gt;&gt;&gt; - Common ground across BSDs?<br>&gt;&gt;&gt; - Unixy? (vs. Windows)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And for other platform conditions:<br>&gt;&gt;&gt; - Architecture subtypes?<br>&gt;&gt;&gt; - Architecture families? (&quot;32-bit&quot; is a good one.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 19, 2016, at 11:19, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to see #if support os(Darwin) as shorthand for any Apple platform. This is a lot shorter to type, and it&#39;s also future-compatible if Apple ever releases another Darwin-based platform. If os(Darwin) evaluates to true, then `import Darwin` should always work, and presumably `import Foundation` as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Without this, I think people are going to be tempted to write `if !os(Linux)` instead of writing out all 4 Apple platforms, and this is unfortunate because it makes the assumption that Linux is the only non-Apple platform, and that&#39;s simply not true.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/83f5de67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>February 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 20, 2016, at 5:39 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 19, 2016, at 4:50 PM, Max Howell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; SwiftPM passes DEBUG and NDEBUG. Ugly, but the standard.<br>&gt; <br>&gt; I don&#39;t think it&#39;s the package manager&#39;s place to do that, since the compiler&#39;s already aware of the current build mode.<br></p><p>It can be reverted.<br></p><p>&gt; IMO all the standard #if flags should ideally be centralized in the language so there isn&#39;t a forever-creeping set of conventional -D flags like there are in C land. (Tradition or not, negative flags like NDEBUG should be put out to pasture—we&#39;ve let go of other, less terrible C traditions.)<br></p><p>This one seemed different, since SwiftPM has explicit debug and release modes for compilation.<br></p><p>&gt; We specifically avoided making debug/release an #if condition because we considered #if to be the wrong point at which to start conditionalizing code generation for assertions. Though the final executable image&#39;s behavior is unavoidably dependent on whether asserts are enabled, we didn&#39;t want the SIL for inlineable code to be, since that would mean libraries with inlineable code would need to ship three times the amount of serialized SIL to support the right behavior in -Onone, -O, and -Ounchecked builds. Instead, the standard library has some hidden helper functions, `_isDebugAssertConfiguration`, `_isReleaseAssertConfiguration`, and `_isFastAssertConfiguration`, which are guaranteed to be constant-folded away before final code generation. This means we can compile a function like this down to SIL once:<br>&gt; <br>&gt; func assert(@autoclosure _ condition: () -&gt; Bool) {<br>&gt;   if _isDebugAssertConfiguration() &amp;&amp; !condition() {<br>&gt;     fatalError()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; for all of the possible assert behaviors.<br></p><p>Makes sense, I can revert it. But this is something people will be asking for pretty regularly, so I’ll forward their requests to your email ;)<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/54cedcaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 20, 2016, at 6:05 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 20, 2016, at 5:39 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 19, 2016, at 4:50 PM, Max Howell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SwiftPM passes DEBUG and NDEBUG. Ugly, but the standard.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think it&#39;s the package manager&#39;s place to do that, since the compiler&#39;s already aware of the current build mode.<br>&gt; <br>&gt; It can be reverted.<br>&gt; <br>&gt;&gt; IMO all the standard #if flags should ideally be centralized in the language so there isn&#39;t a forever-creeping set of conventional -D flags like there are in C land. (Tradition or not, negative flags like NDEBUG should be put out to pasture—we&#39;ve let go of other, less terrible C traditions.)<br>&gt; <br>&gt; This one seemed different, since SwiftPM has explicit debug and release modes for compilation.<br>&gt; <br>&gt;&gt; We specifically avoided making debug/release an #if condition because we considered #if to be the wrong point at which to start conditionalizing code generation for assertions. Though the final executable image&#39;s behavior is unavoidably dependent on whether asserts are enabled, we didn&#39;t want the SIL for inlineable code to be, since that would mean libraries with inlineable code would need to ship three times the amount of serialized SIL to support the right behavior in -Onone, -O, and -Ounchecked builds. Instead, the standard library has some hidden helper functions, `_isDebugAssertConfiguration`, `_isReleaseAssertConfiguration`, and `_isFastAssertConfiguration`, which are guaranteed to be constant-folded away before final code generation. This means we can compile a function like this down to SIL once:<br>&gt;&gt; <br>&gt;&gt; func assert(@autoclosure _ condition: () -&gt; Bool) {<br>&gt;&gt;   if _isDebugAssertConfiguration() &amp;&amp; !condition() {<br>&gt;&gt;     fatalError()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; for all of the possible assert behaviors.<br>&gt; <br>&gt; Makes sense, I can revert it. But this is something people will be asking for pretty regularly, so I’ll forward their requests to your email ;)<br></p><p>They&#39;re welcome to start evolution threads! I&#39;ll add that, in our original grand vision for compiler flags before the reality of shipping got in the way, it would have been possible to use flags both to conditionalize compilation, similar to #if in C-family languages, but also as expressions, for conditionalization during code generation, which would allow for either:<br></p><p>#if config(Debug)<br>func debugTrap() { fatalError() }<br>#else<br>func debugTrap() { /*do nothing*/ }<br>#endif<br></p><p>or:<br></p><p>func assert(...) {<br>  if #config(Debug) {<br>    fatalError()<br>  }<br>}<br></p><p>and we would have encouraged the latter where possible, since it would allow for more sharing of build products across build configurations. #if-style conditionalization is unavoidable if you need to conditionally import frameworks that are only available on specific platforms, but the &#39;if #&#39; approach allows for more efficient cross-platform, cross-configuration builds and lets the compiler more eagerly check semantics without fully depending on execution tests on every target platform.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/a04df90d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt;&gt; SwiftPM passes DEBUG and NDEBUG. Ugly, but the standard.<br>&gt; <br>&gt; I don&#39;t think it&#39;s the package manager&#39;s place to do that, since the compiler&#39;s already aware of the current build mode. IMO all the standard #if flags should ideally be centralized in the language so there isn&#39;t a forever-creeping set of conventional -D flags like there are in C land. (Tradition or not, negative flags like NDEBUG should be put out to pasture—we&#39;ve let go of other, less terrible C traditions.)<br></p><p>Agreed!<br></p><p>&gt; We specifically avoided making debug/release an #if condition because we considered #if to be the wrong point at which to start conditionalizing code generation for assertions.<br></p><p>There are many reasons besides assertions where one might want to know if code is running in release mode or debug mode.<br></p><p>For example, we use CleanroomLogger &lt;https://github.com/emaloney/CleanroomLogger&gt; as our in-app logging API, and we configure the logger differently in debug mode:<br></p><p>- We perform more verbose logging in debug mode; we don&#39;t want to ship with this since verbose logging can affect the performance of the app.<br></p><p>- We configure the logger to run synchronously, so that when we hit a breakpoint, the console output is up-to-date. In production code, we set up CleanroomLogger to log asynchronously, which is another way to optimize performance.<br></p><p>Currently, the concept of debug mode only lives at the application level, and we pass the -DDEBUG flag to indicate a debug build. Since the compiler knows whether we&#39;re building for debug or not, it would be great to not have to pass this in.<br></p><p>I can understand this would be tricky for binary-only frameworks, but in our case, everything we touch is open-source; we integrate as git submodules with embedded Xcode projects &amp; compile everything ourselves. I suspect this is pretty common with pure-Swift projects. Since there isn&#39;t ABI compatibility yet, people probably aren&#39;t releasing binary-only packages with Swift.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/75146694/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 19, 2016, at 11:53 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that we need something here, but I really like the property we have today that all of the &quot;os&quot; options are mutually exclusive. (Compare: TARGET_OS_IPHONE and TARGET_OS_IOS in &lt;TargetConditionals.h&gt;.) I&#39;d be happy to invent a new predicate for this, though.<br></p><p>Yeah, I agree this should be a distinct predicate.<br>&gt; <br>&gt; Other considerations:<br>&gt; - Different Linux distros?<br>&gt; - Common ground across BSDs?<br>&gt; - Unixy? (vs. Windows)<br>&gt; <br>&gt; And for other platform conditions:<br>&gt; - Architecture subtypes?<br>&gt; - Architecture families? (&quot;32-bit&quot; is a good one.)<br></p><p>For appley platforms, &quot;Mac&quot; vs &quot;simulator&quot; vs &quot;device&quot; also comes up as a common categorization.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 19, 2016 at 04:00:00pm</p></header><div class="content"><p>Adding in the different forms of compile-time conditionals our code uses in Objective-C, the following tests would be useful:<br></p><p>• Is the target an Apple platform (iOS, OS X, tvOS, watchOS) or not? (Answers the question &quot;can I import Foundation&quot;?)<br></p><p>• Is the target a &quot;common UIKit platform&quot; (compiles on both iOS and tvOS) or not? (Answers the question &quot;can I import UIKit&quot;?)<br></p><p>• Is the target a specific platform (iOS, OS X, tvOS, watchOS, Linux, etc.)?<br></p><p>• Is the target in Debug or Release mode?<br></p><p>• Is the target a simulator environment or a physical device?<br></p><p>• Is the target built for running tests?<br></p><p>All of our cases are covered by the questions above, but as Jordan indicates, other people may also need to know more about the processor architecture.<br></p><p><br></p><p>&gt; On Feb 19, 2016, at 2:53 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that we need something here, but I really like the property we have today that all of the &quot;os&quot; options are mutually exclusive. (Compare: TARGET_OS_IPHONE and TARGET_OS_IOS in &lt;TargetConditionals.h&gt;.) I&#39;d be happy to invent a new predicate for this, though.<br>&gt; <br>&gt; Other considerations:<br>&gt; - Different Linux distros?<br>&gt; - Common ground across BSDs?<br>&gt; - Unixy? (vs. Windows)<br>&gt; <br>&gt; And for other platform conditions:<br>&gt; - Architecture subtypes?<br>&gt; - Architecture families? (&quot;32-bit&quot; is a good one.)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 11:19, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to see #if support os(Darwin) as shorthand for any Apple platform. This is a lot shorter to type, and it&#39;s also future-compatible if Apple ever releases another Darwin-based platform. If os(Darwin) evaluates to true, then `import Darwin` should always work, and presumably `import Foundation` as well.<br>&gt;&gt; <br>&gt;&gt; Without this, I think people are going to be tempted to write `if !os(Linux)` instead of writing out all 4 Apple platforms, and this is unfortunate because it makes the assumption that Linux is the only non-Apple platform, and that&#39;s simply not true.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; • Is the target an Apple platform (iOS, OS X, tvOS, watchOS) or not? (Answers the question &quot;can I import Foundation&quot;?)<br></p><p>Well, Corelibs Foundation will muddy those waters.<br></p><p>&gt; • Is the target a &quot;common UIKit platform&quot; (compiles on both iOS and tvOS) or not? (Answers the question &quot;can I import UIKit&quot;?)<br></p><p>Maybe test for the presence of a particular module?<br></p><p>	#if supports(Foundation)<br>	#if supports(UIKit)<br></p><p>Or allow conditional importing of a module?<br></p><p>	#if import UIKit<br>		// Only compiled if UIKit imported; all UIKit APIs usable here<br>	#elseif import AppKit<br>		// Only compiled if AppKit imported; all AppKit APIs usable here<br>	#endif<br>	// No AppKit or UIKit APIs usable here<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>February 20, 2016 at 11:00:00am</p></header><div class="content"><p>I’ve mentioned this before, but often checking for simulator is really a just a way of dealing with an include that won’t work in the simulator. The ability to exclude code based on the presence of a module in the SDK would be most welcome. Metal is my current sticky point with Swift. It’s in the device SDK but not the sim.<br></p><p>&gt; On Feb 19, 2016, at 8:01 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; • Is the target an Apple platform (iOS, OS X, tvOS, watchOS) or not? (Answers the question &quot;can I import Foundation&quot;?)<br>&gt; <br>&gt; Well, Corelibs Foundation will muddy those waters.<br>&gt; <br>&gt;&gt; • Is the target a &quot;common UIKit platform&quot; (compiles on both iOS and tvOS) or not? (Answers the question &quot;can I import UIKit&quot;?)<br>&gt; <br>&gt; Maybe test for the presence of a particular module?<br>&gt; <br>&gt; 	#if supports(Foundation)<br>&gt; 	#if supports(UIKit)<br>&gt; <br>&gt; Or allow conditional importing of a module?<br>&gt; <br>&gt; 	#if import UIKit<br>&gt; 		// Only compiled if UIKit imported; all UIKit APIs usable here<br>&gt; 	#elseif import AppKit<br>&gt; 		// Only compiled if AppKit imported; all AppKit APIs usable here<br>&gt; 	#endif<br>&gt; 	// No AppKit or UIKit APIs usable here<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; • Is the target a &quot;common UIKit platform&quot; (compiles on both iOS and tvOS) or not? (Answers the question &quot;can I import UIKit&quot;?)<br>&gt; <br>&gt; Maybe test for the presence of a particular module?<br>&gt; <br>&gt; 	#if supports(Foundation)<br>&gt; 	#if supports(UIKit)<br>&gt; <br>&gt; Or allow conditional importing of a module?<br>&gt; <br>&gt; 	#if import UIKit<br>&gt; 		// Only compiled if UIKit imported; all UIKit APIs usable here<br>&gt; 	#elseif import AppKit<br>&gt; 		// Only compiled if AppKit imported; all AppKit APIs usable here<br>&gt; 	#endif<br>&gt; 	// No AppKit or UIKit APIs usable here<br></p><p>Being able to test for the importability of a given module/framework at runtime would be extremely helpful.<br></p><p>We use several frameworks that are only available in a subset of the platforms we support, and on only certain OS versions. <br></p><p>To work around this problem now, we dynamically load frameworks from Obj-C only when we&#39;re running on an OS version we know is supported by the framework(s) in question.<br></p><p>We can&#39;t dynamically load them from Swift because if they&#39;re included in an import, the runtime tries to load it right away, leading to a crash on any unsupported platform.<br></p><p>The only way to selectively load dynamic frameworks at runtime is to do it via Obj-C. Some sort of check like the ones you propose should let us avoid this.<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Idea: Support #if os(Darwin) as shorthand for os(iOS) || os(OSX) || os(watchOS) || os(tvOS)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 20, 2016 at 09:00:00am</p></header><div class="content"><p>Offhand it seems a decent solution would be to have some way for users to define e.g. an “os group” <br></p><p>#define_os_group(uikit) iOS tvOS<br>#define_os_group(apple) iOS tvOS watchOS OSX<br></p><p>…(but with a better name).<br></p><p>It’s not clear offhand where such `#define*` statements would naturally reside.<br></p><p>As a bit of bike-shedding, perhaps `platform` instead of `os`, too.<br></p><p>&gt; On Feb 19, 2016, at 1:19 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to see #if support os(Darwin) as shorthand for any Apple platform. This is a lot shorter to type, and it&#39;s also future-compatible if Apple ever releases another Darwin-based platform. If os(Darwin) evaluates to true, then `import Darwin` should always work, and presumably `import Foundation` as well.<br>&gt; <br>&gt; Without this, I think people are going to be tempted to write `if !os(Linux)` instead of writing out all 4 Apple platforms, and this is unfortunate because it makes the assumption that Linux is the only non-Apple platform, and that&#39;s simply not true.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
