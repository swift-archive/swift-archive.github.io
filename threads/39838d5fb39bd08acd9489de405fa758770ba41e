<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 13, 2016 at 10:00:00am</p></header><div class="content"><p>on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt; that I’m not sure if they have been considered:<br>&gt;<br>&gt; ALTERNATIVE 1<br>&gt;<br>&gt; Non-mutable (noun-based)<br>&gt;<br>&gt; -  func union(other: Self) -&gt; Self<br>&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;<br>&gt; -  func intersect(other: Self) -&gt; Self<br>&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func subtract(other: Self) -&gt; Self<br>&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;<br>&gt; Mutable (verb-based)<br>&gt;<br>&gt; -  mutating func unionInPlace(other: Self)<br>&gt; +  mutating func unite(other: Self)<br>&gt;<br>&gt; -  mutating func intersectInPlace(other: Self)<br>&gt; +  mutating func intersect(other: Self)<br>&gt;<br>&gt; -  mutating func subtractInPlace(other: Self)<br>&gt; +  mutating func subtract(other: Self)<br>&gt;<br>&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;<br>&gt; Comments: <br>&gt;<br>&gt; With this alternative we keep the union name which I assume is<br>&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt; version) as I wanted all the mutable methods use verbs for<br>&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt; the dictionary and it is a verb.<br>&gt;<br>&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;<br>&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt; quickly / easily.<br>&gt;<br>&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;<br>&gt; ALTERNATIVE 2<br>&gt;<br>&gt; Non-mutable<br>&gt;<br>&gt; -  func union(other: Self) -&gt; Self<br>&gt; +  func adding(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func intersect(other: Self) -&gt; Self<br>&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func subtract(other: Self) -&gt; Self<br>&gt; +  func removing(other: Self) -&gt; Self<br>&gt;<br>&gt; Mutable<br>&gt;<br>&gt; -  mutating func unionInPlace(other: Self)<br>&gt; +  mutating func add(other: Self)<br>&gt;<br>&gt; -  mutating func intersectInPlace(other: Self)<br>&gt; +  mutating func intersect(other: Self)<br>&gt;<br>&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;<br>&gt; -  mutating func subtractInPlace(other: Self)<br>&gt; +  mutating func remove(other: Self)<br>&gt;<br>&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt; may not like this, that is why I have it as the second alternative.<br>&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br></p><p>If we are going to force Set fit the naming guidelines, I would prefer<br>to stay away from the mathematical terms altogether.<br></p><p>   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>   mutating func insertContentsOf(other)<br></p><p>   func members(in other: Self) -&gt; Self                           // intersection<br>   mutating func removeMembers(notIn: other)<br></p><p>   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>   mutating func removeMembersAndAddingNonMembers(in other: Self)<br></p><p>   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>   mutating func removeMembers(in other: Self)<br></p><p>If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>above.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 14, 2016 at 01:00:00am</p></header><div class="content"><p>Is there a reason why the same data structures are supporting both mutable and non-mutable operations?  <br></p><p>I would think you would have a mutable set, and a non-mutable set and they would not intersect :p<br></p><p>If you have a mutable set and you don’t want to affect the original - you would copy or clone it.<br></p><p><br>&gt; On 2016-02-14, at 1:16:26, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVE 1<br>&gt;&gt; <br>&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt; <br>&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt; <br>&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; Mutable (verb-based)<br>&gt;&gt; <br>&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt; <br>&gt;&gt; Comments: <br>&gt;&gt; <br>&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt; <br>&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt; <br>&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt; quickly / easily.<br>&gt;&gt; <br>&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVE 2<br>&gt;&gt; <br>&gt;&gt; Non-mutable<br>&gt;&gt; <br>&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; Mutable<br>&gt;&gt; <br>&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt; <br>&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt; <br>&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt; to stay away from the mathematical terms altogether.<br>&gt; <br>&gt;   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;   mutating func insertContentsOf(other)<br>&gt; <br>&gt;   func members(in other: Self) -&gt; Self                           // intersection<br>&gt;   mutating func removeMembers(notIn: other)<br>&gt; <br>&gt;   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;   mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt; <br>&gt;   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;   mutating func removeMembers(in other: Self)<br>&gt; <br>&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt; above.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/f8a81d7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Is there a reason why the same data structures are supporting both mutable and non-mutable operations?  <br></p><p>Because Set is a Swift value type and you can control its mutability by assigning it to a constant or variable, just like an Array.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 14, 2016 at 03:00:00am</p></header><div class="content"><p>OK, I understand but it seems a little messy - basically overloading with two copies of every function on the “same” data structure.  <br></p><p>With many collections it would lead to the underlying data structures within the collections would either end up being optimized for mutable or immutable.<br>In many cases the way you store the data internal to the collection would be more efficient if focused on one or the other — but not both.<br>I just view a mutable collection of the same “type” as fundamentally different than the immutable version of it.<br>There are probably of course tradeoffs - either way.  <br></p><p>I would thought that if you want it “invisible” to the user which data structure you are selecting you would have a mutable implementation of `Set`, and an immutable<br>version of `Set` and if you used let it would be one implementation, and if var the other implementation — and not the enabling or disabling of certain functions on<br>the data type.<br></p><p><br>&gt; On 2016-02-14, at 3:11:54, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Is there a reason why the same data structures are supporting both mutable and non-mutable operations?  <br>&gt; <br>&gt; Because Set is a Swift value type and you can control its mutability by assigning it to a constant or variable, just like an Array.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt; to stay away from the mathematical terms altogether.<br>&gt; <br>&gt;   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;   mutating func insertContentsOf(other)<br>&gt; <br>&gt;   func members(in other: Self) -&gt; Self                           // intersection<br>&gt;   mutating func removeMembers(notIn: other)<br>&gt; <br>&gt;   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;   mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt; <br>&gt;   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;   mutating func removeMembers(in other: Self)<br></p><p>If we&#39;re abandoning conventional names, I notice that intersect, subtract, and xor can be expressed fairly clearly as:<br></p><p>	intersect	keep{ing}MembersInCommon(with:)<br>	xor		keep{ing}MembersNotInCommon(with:)<br>	subtract	keep{ing}Members(notIn:)<br></p><p>But union is harder. It could be constructed parallel to subtract, but it might sound like intersect this way.<br></p><p>	union 	keep{ing}Members(in:)<br></p><p>On the other hand, you could style union and subtract as insert and remove operations, and use keep operations for intersect and xor.<br></p><p>I notice, though, that one big problem with using methods is that these operations (well, except subtract) are symmetric. Having one set be the target and another be the parameter implies that the parameter is subordinate, but in reality the two are peers. That creates false impressions which are hard to overcome through naming.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>February 13, 2016 at 03:00:00pm</p></header><div class="content"><p>On Feb 13, 2016, at 15:34, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt; <br>&gt;&gt;  func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;  mutating func insertContentsOf(other)<br>&gt;&gt; <br>&gt;&gt;  func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;  mutating func removeMembers(notIn: other)<br>&gt;&gt; <br>&gt;&gt;  func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;  mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt; <br>&gt;&gt;  func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;  mutating func removeMembers(in other: Self)<br>&gt; <br>&gt; If we&#39;re abandoning conventional names, I notice that intersect, subtract, and xor can be expressed fairly clearly as:<br>&gt; <br>&gt;    intersect    keep{ing}MembersInCommon(with:)<br>&gt;    xor        keep{ing}MembersNotInCommon(with:)<br>&gt;    subtract    keep{ing}Members(notIn:)<br>&gt; <br></p><p>Not sure your xor replacement works as written... It doesn&#39;t imply that you need to keep all the members of the argument that aren&#39;t common as well... <br></p><p>&gt; But union is harder. It could be constructed parallel to subtract, but it might sound like intersect this way.<br>&gt; <br>&gt;    union    keep{ing}Members(in:)<br>&gt; <br>&gt; On the other hand, you could style union and subtract as insert and remove operations, and use keep operations for intersect and xor.<br>&gt; <br>&gt; I notice, though, that one big problem with using methods is that these operations (well, except subtract) are symmetric. Having one set be the target and another be the parameter implies that the parameter is subordinate, but in reality the two are peers. That creates false impressions which are hard to overcome through naming.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 13, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sat Feb 13 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt; <br>&gt;&gt;   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;   mutating func insertContentsOf(other)<br>&gt;&gt; <br>&gt;&gt;   func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;   mutating func removeMembers(notIn: other)<br>&gt;&gt; <br>&gt;&gt;   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;   mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt; <br>&gt;&gt;   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;   mutating func removeMembers(in other: Self)<br>&gt;<br>&gt; If we&#39;re abandoning conventional names, I notice that intersect,<br>&gt; subtract, and xor can be expressed fairly clearly as:<br>&gt;<br>&gt; 	intersect	keep{ing}MembersInCommon(with:)<br>&gt; 	xor		keep{ing}MembersNotInCommon(with:)<br>&gt; 	subtract	keep{ing}Members(notIn:)<br></p><p>The latter two names mean the same thing to my eye.<br></p><p>&gt; But union is harder. It could be constructed parallel to subtract, but<br>&gt; it might sound like intersect this way.<br>&gt;<br>&gt; 	union 	keep{ing}Members(in:)<br>&gt;<br>&gt; On the other hand, you could style union and subtract as insert and<br>&gt; remove operations, and use keep operations for intersect and xor.<br></p><p>I don&#39;t think there&#39;s any advantage in trying to make all these<br>(different) operations look the same.<br></p><p>&gt; I notice, though, that one big problem with using methods is that<br>&gt; these operations (well, except subtract) are symmetric. Having one set<br>&gt; be the target and another be the parameter implies that the parameter<br>&gt; is subordinate, but in reality the two are peers. That creates false<br>&gt; impressions which are hard to overcome through naming.<br></p><p>I think that issue pales in importance when compared with expressing the<br>right semantics.  If you get that right, whether or not the operation is<br>in fact symmetric becomes academic.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 14, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Dave,<br></p><p>I would be okay with staying away from the mathematical terms similar to what you are suggesting except that the union can still be made more concise if you use merged / merge for the base name and shorten the labels to a bare minimum without loosing clarity.  In addition, the merge can have a second parameter with a default to false in order to implement the symmetric difference (a.k.a. exclusive or).  Recall that symmetric difference is the union of two sets and then removing the intersection (or members in common).  I think it looks perfect (concise and clear).  What does everybody else think?<br></p><p>Non-mutable<br></p><p>let union = 			a.merged(with: b)<br>let intersection = 		a.members(in: b)<br>let difference = 		a.removingMembers(in: b)<br>let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br></p><p>Mutable (In-Place)<br></p><p>a.merge(with: b)		// union in-place<br>a.removeMembers(notIn: b)	// intersect in-place<br>a.removeMembers(in: b)		// difference in-place<br>a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br></p><p>Ricardo Parada<br></p><p><br>&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVE 1<br>&gt;&gt; <br>&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt; <br>&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt; <br>&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; Mutable (verb-based)<br>&gt;&gt; <br>&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt; <br>&gt;&gt; Comments: <br>&gt;&gt; <br>&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt; <br>&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt; <br>&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt; quickly / easily.<br>&gt;&gt; <br>&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVE 2<br>&gt;&gt; <br>&gt;&gt; Non-mutable<br>&gt;&gt; <br>&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; Mutable<br>&gt;&gt; <br>&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt; <br>&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt; <br>&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt; <br>&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt; to stay away from the mathematical terms altogether.<br>&gt; <br>&gt;   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;   mutating func insertContentsOf(other)<br>&gt; <br>&gt;   func members(in other: Self) -&gt; Self                           // intersection<br>&gt;   mutating func removeMembers(notIn: other)<br>&gt; <br>&gt;   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;   mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt; <br>&gt;   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;   mutating func removeMembers(in other: Self)<br>&gt; <br>&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt; above.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/86d3aa1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>February 13, 2016 at 11:00:00pm</p></header><div class="content"><p>I would, personally, be very careful about discarding the mathematical terms since they are so widely used and understood.<br></p><p>One issue is that it’s going to be hard to search for the operation I want considering I won’t be looking for &quot;func invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned people are going to have to do mental gymnastics to build the map from math term to Swift function every time they want to look for a set operation method. “func invertingMembershipOfContentsOf(other: Self) -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram mental model of set operations. You could always have a documentation comment that specifies the mathematical term so that people didn’t have to double check themselves every time.<br></p><p>That being said, if the autocomplete issue is not a concern, I’m of the opinion that the names Ricardo proposed are short, clear, and are not so hard to fit to my Venn diagram mental model.<br></p><p>However, I tend to think that if there has to be this much dancing to name a set of fundamental operations, the guidelines aren’t accomplishing their goal. It’s going to make it that much harder for people do design their own APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to the guidelines.<br></p><p>Tyler<br></p><p><br>&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Dave,<br>&gt; <br>&gt; I would be okay with staying away from the mathematical terms similar to what you are suggesting except that the union can still be made more concise if you use merged / merge for the base name and shorten the labels to a bare minimum without loosing clarity.  In addition, the merge can have a second parameter with a default to false in order to implement the symmetric difference (a.k.a. exclusive or).  Recall that symmetric difference is the union of two sets and then removing the intersection (or members in common).  I think it looks perfect (concise and clear).  What does everybody else think?<br>&gt; <br>&gt; Non-mutable<br>&gt; <br>&gt; let union = 			a.merged(with: b)<br>&gt; let intersection = 		a.members(in: b)<br>&gt; let difference = 		a.removingMembers(in: b)<br>&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt; <br>&gt; Mutable (In-Place)<br>&gt; <br>&gt; a.merge(with: b)		// union in-place<br>&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt; a.removeMembers(in: b)		// difference in-place<br>&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt; <br>&gt; Ricardo Parada<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt; <br>&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt; <br>&gt;&gt;   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;   mutating func insertContentsOf(other)<br>&gt;&gt; <br>&gt;&gt;   func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;   mutating func removeMembers(notIn: other)<br>&gt;&gt; <br>&gt;&gt;   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;   mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt; <br>&gt;&gt;   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;   mutating func removeMembers(in other: Self)<br>&gt;&gt; <br>&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt; above.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/f3a7fe70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 14, 2016 at 08:00:00am</p></header><div class="content"><p>on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt; I would, personally, be very careful about discarding the mathematical<br>&gt; terms since they are so widely used and understood.<br></p><p>IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>that might be misleading.<br></p><p>&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt; want considering I won’t be looking for &quot;func<br>&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt; people are going to have to do mental gymnastics to build the map from<br>&gt; math term to Swift function every time they want to look for a set<br>&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt; mental model of set operations. You could always have a documentation<br>&gt; comment that specifies the mathematical term so that people didn’t<br>&gt; have to double check themselves every time.<br>&gt;<br>&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt; not so hard to fit to my Venn diagram mental model.<br></p><p>+1<br></p><p>&gt; However, I tend to think that if there has to be this much dancing to<br>&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt; accomplishing their goal. <br></p><p>I can&#39;t disagree.<br></p><p>&gt; It’s going to make it that much harder for people do design their own<br>&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt; the guidelines.<br></p><p>Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>with the guidelines.<br></p><p>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dave,<br>&gt;&gt; <br>&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt; everybody else think?<br>&gt;&gt; <br>&gt;&gt; Non-mutable<br>&gt;&gt; <br>&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt; <br>&gt;&gt; Mutable (In-Place)<br>&gt;&gt; <br>&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt; <br>&gt;&gt; Ricardo Parada<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;   mutating func insertContentsOf(other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;   mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;   mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;   mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt; above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>February 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt; <br>&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt; terms since they are so widely used and understood.<br>&gt; <br>&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt; that might be misleading.<br>&gt; <br></p><p>Agreed. I’m all for that.<br></p><p>&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt; have to double check themselves every time.<br>&gt;&gt; <br>&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt; <br>&gt; +1<br>&gt; <br>&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt; accomplishing their goal. <br>&gt; <br>&gt; I can&#39;t disagree.<br>&gt; <br>&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt; the guidelines.<br>&gt; <br>&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt; with the guidelines.<br></p><p>Ah, I apologize. I’ve gone into detail about this API on the list before, but I should have included the details here.<br></p><p>Here are my previous posts: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;<br></p><p>Basically the issues come down to the following. The Accelerate framework typical operates in a non-mutating way. This means that my API only has non mutating member functions and I should use the ed/ing rule according to the guidelines to name my methods.<br></p><p>This is very difficult for some methods. I’m able to frequently get around the problem for things like “sin” or “arctan” by keeping them as global functions, but I can’t do that for a number of methods. Consider:<br></p><p>remainder<br>dot (returns a scalar, thus there can’t be a mutating version, so should I just call it dot? Guidelines don’t really comment on this)<br>mean (same as above)<br>cross<br>reciprocal<br>threshold<br>copysign<br>fastFourierTransform<br>pow (arguably the method version should be called raisedTo)<br></p><p>I could force all these to be global functions only, but these are not as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my API up into two parts just based on the fact that it’s difficult to use the ed/ing rule. That makes it very difficult for users to find certain functions in my API.<br></p><p>In this case there are no corresponding mutating operations because of the way Accelerate works, but one could certainly imagine an API with mutating counterparts. The way I read the guidelines, they seem to imply I should use ed/ing regardless of whether there is a mutating counterpart. I’d love to hear your thoughts on this.<br></p><p>Thanks,<br></p><p>Tyler<br></p><p><br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;  mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;  mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;  mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;  mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/2045662f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 14, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br></p><p>&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt; <br>&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt; that might be misleading.<br>&gt;&gt; <br>&gt;<br>&gt; Agreed. I’m all for that.<br>&gt;<br>&gt;&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt;&gt; have to double check themselves every time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt;&gt; accomplishing their goal. <br>&gt;&gt; <br>&gt;&gt; I can&#39;t disagree.<br>&gt;&gt; <br>&gt;&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt;&gt; the guidelines.<br>&gt;&gt; <br>&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt; with the guidelines.<br>&gt;<br>&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt; before, but I should have included the details here.<br>&gt;<br>&gt; Here are my previous posts:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;<br>&gt;<br>&gt; Basically the issues come down to the following. The Accelerate<br>&gt; framework typical operates in a non-mutating way. This means that my<br>&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt; rule according to the guidelines to name my methods.<br>&gt;<br>&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt; as global functions, but I can’t do that for a number of<br>&gt; methods. Consider:<br>&gt;<br>&gt; remainder<br>&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt; mean (same as above)<br>&gt; cross<br>&gt; reciprocal<br>&gt; threshold<br>&gt; copysign<br>&gt; fastFourierTransform<br>&gt; pow (arguably the method version should be called raisedTo)<br>&gt;<br>&gt; I could force all these to be global functions only, but these are not<br>&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt; certain functions in my API.<br>&gt;<br>&gt; In this case there are no corresponding mutating operations because of<br>&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt; counterpart. I’d love to hear your thoughts on this.<br></p><p>As long as the ones without side effects read as noun phrases and the<br>ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>needed.<br></p><p><br>&gt;<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt;  mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt;  mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt;  mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt;  mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>February 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt;&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt;&gt; that might be misleading.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Agreed. I’m all for that.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt;&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt;&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt;&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt;&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt;&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt;&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt;&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt;&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt;&gt;&gt; have to double check themselves every time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt;&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt;&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt;&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt;&gt;&gt; accomplishing their goal. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t disagree.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt;&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt;&gt;&gt; the guidelines.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt;&gt; with the guidelines.<br>&gt;&gt; <br>&gt;&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt;&gt; before, but I should have included the details here.<br>&gt;&gt; <br>&gt;&gt; Here are my previous posts:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; Basically the issues come down to the following. The Accelerate<br>&gt;&gt; framework typical operates in a non-mutating way. This means that my<br>&gt;&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt;&gt; rule according to the guidelines to name my methods.<br>&gt;&gt; <br>&gt;&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt;&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt;&gt; as global functions, but I can’t do that for a number of<br>&gt;&gt; methods. Consider:<br>&gt;&gt; <br>&gt;&gt; remainder<br>&gt;&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt;&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt;&gt; mean (same as above)<br>&gt;&gt; cross<br>&gt;&gt; reciprocal<br>&gt;&gt; threshold<br>&gt;&gt; copysign<br>&gt;&gt; fastFourierTransform<br>&gt;&gt; pow (arguably the method version should be called raisedTo)<br>&gt;&gt; <br>&gt;&gt; I could force all these to be global functions only, but these are not<br>&gt;&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt;&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt;&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt;&gt; certain functions in my API.<br>&gt;&gt; <br>&gt;&gt; In this case there are no corresponding mutating operations because of<br>&gt;&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt;&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt;&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt;&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt; <br>&gt; As long as the ones without side effects read as noun phrases and the<br>&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt; needed.<br>&gt; <br></p><p>Ah yes, you are very right. Still what would the mutating versions of remainder, fastFourierTransform, or reciprocal be? getRemainder? applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br></p><p>I also suppose cross could become x.crossProduct(with: y) and copysign, x.copyingSign(of: y). Seems a little verbose, but it does the job.<br></p><p>Thanks,<br></p><p>Tyler<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/4c0741bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 14, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;From a 10,000-ft view, I&#39;d suggest that the noun/verb rule consistently<br>runs into a problem with mathematical terms.<br></p><p>In general, mathematical functions don&#39;t have verb forms. You &#39;compute&#39; the<br>reciprocal, or &#39;find&#39; the reciprocal, or &#39;take&#39; the reciprocal, you don&#39;t<br>&#39;reciprocate&#39; or &#39;reciprocalize&#39;. Likewise for trigonometric functions,<br>etc. Nor can you really &#39;cross produce&#39;...<br></p><p>So consistent is this trend that where two words might be noun/verb<br>counterparts, like intersect/intersection and transform/transformation,<br>common math usage treats both as acceptable nouns.<br></p><p>In colloquial usage, you might verb the noun, but then by definition the<br>verb and noun become the same. Then, to generate a noun<br>phrase/participle/etc. that looks different from the verb, you have to<br>noun-ify the verbed noun.<br></p><p>Without an exception for mathematical function names, the only solution to<br>fulfill these new Swift rules are clobbering the well-known math name or<br>not using the math name at all. Indeed all proposed solutions so far come<br>down to one of four options, either applied globally or only to sets for<br>now, punting the rest down the road:<br></p><p>(1) Abandon the rule, making a new one (e.g.: .=)<br>(2) Make an exception to the rule for math function names<br>(3) Generate the least offensive noun-ified verbed nouns based on math<br>function names<br>(4) Don&#39;t use math function names<br></p><p>(1) is off the table, according to the core team. My vote at this point is<br>for (2), and I see that a few others have voiced that opinion. It&#39;d be nice<br>to get a sense from the core team if that is even a possibility. (3) has<br>elicited a lot of discussion and visceral reactions. (4) might be workable<br>for sets alone but surely can&#39;t be a generalized solution for all<br>mathematical concepts to be encountered in Swift.<br>On Sun, Feb 14, 2016 at 3:14 PM Tyler Fleming Cloutier via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com<br>&gt; &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;<br>&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com<br>&gt; &lt;http://cloutiertyler-at-aol.com&gt;&gt; wrote:<br>&gt;<br>&gt; I would, personally, be very careful about discarding the mathematical<br>&gt; terms since they are so widely used and understood.<br>&gt;<br>&gt;<br>&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt; that might be misleading.<br>&gt;<br>&gt;<br>&gt; Agreed. I’m all for that.<br>&gt;<br>&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt; want considering I won’t be looking for &quot;func<br>&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt; people are going to have to do mental gymnastics to build the map from<br>&gt; math term to Swift function every time they want to look for a set<br>&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt; mental model of set operations. You could always have a documentation<br>&gt; comment that specifies the mathematical term so that people didn’t<br>&gt; have to double check themselves every time.<br>&gt;<br>&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;<br>&gt;<br>&gt; +1<br>&gt;<br>&gt; However, I tend to think that if there has to be this much dancing to<br>&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt; accomplishing their goal.<br>&gt;<br>&gt;<br>&gt; I can&#39;t disagree.<br>&gt;<br>&gt; It’s going to make it that much harder for people do design their own<br>&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt; the guidelines.<br>&gt;<br>&gt;<br>&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt; with the guidelines.<br>&gt;<br>&gt;<br>&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt; before, but I should have included the details here.<br>&gt;<br>&gt; Here are my previous posts:<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt; &lt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt; &gt;<br>&gt;<br>&gt; Basically the issues come down to the following. The Accelerate<br>&gt; framework typical operates in a non-mutating way. This means that my<br>&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt; rule according to the guidelines to name my methods.<br>&gt;<br>&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt; as global functions, but I can’t do that for a number of<br>&gt; methods. Consider:<br>&gt;<br>&gt; remainder<br>&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt; mean (same as above)<br>&gt; cross<br>&gt; reciprocal<br>&gt; threshold<br>&gt; copysign<br>&gt; fastFourierTransform<br>&gt; pow (arguably the method version should be called raisedTo)<br>&gt;<br>&gt; I could force all these to be global functions only, but these are not<br>&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt; certain functions in my API.<br>&gt;<br>&gt; In this case there are no corresponding mutating operations because of<br>&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt;<br>&gt;<br>&gt; As long as the ones without side effects read as noun phrases and the<br>&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt; needed.<br>&gt;<br>&gt;<br>&gt; Ah yes, you are very right. Still what would the mutating versions of<br>&gt; remainder, fastFourierTransform, or reciprocal be? getRemainder?<br>&gt; applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br>&gt;<br>&gt; I also suppose cross could become x.crossProduct(with: y) and copysign,<br>&gt; x.copyingSign(of: y). Seems a little verbose, but it does the job.<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi Dave,<br>&gt;<br>&gt; I would be okay with staying away from the mathematical terms<br>&gt; similar to what you are suggesting except that the union can still<br>&gt; be made more concise if you use merged / merge for the base name and<br>&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt; addition, the merge can have a second parameter with a default to<br>&gt; false in order to implement the symmetric difference<br>&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt; union of two sets and then removing the intersection (or members in<br>&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt; everybody else think?<br>&gt;<br>&gt; Non-mutable<br>&gt;<br>&gt; let union =  a.merged(with: b)<br>&gt; let intersection =  a.members(in: b)<br>&gt; let difference =  a.removingMembers(in: b)<br>&gt; let symmetricDifference =  a.merged(with: b, removingMembersInCommon:<br>&gt; true)<br>&gt;<br>&gt; Mutable (In-Place)<br>&gt;<br>&gt; a.merge(with: b) // union in-place<br>&gt; a.removeMembers(notIn: b) // intersect in-place<br>&gt; a.removeMembers(in: b) // difference in-place<br>&gt; a.merge(with: b, removeMembersInCommon: true) // symmetric difference<br>&gt; in-place<br>&gt;<br>&gt; Ricardo Parada<br>&gt;<br>&gt;<br>&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt; that I’m not sure if they have been considered:<br>&gt;<br>&gt; ALTERNATIVE 1<br>&gt;<br>&gt; Non-mutable (noun-based)<br>&gt;<br>&gt; -  func union(other: Self) -&gt; Self<br>&gt; +  func union(other: Self) -&gt; Self Assumes union is a noun, i.e. not a<br>&gt; verb<br>&gt;<br>&gt; -  func intersect(other: Self) -&gt; Self<br>&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func subtract(other: Self) -&gt; Self<br>&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;<br>&gt; Mutable (verb-based)<br>&gt;<br>&gt; -  mutating func unionInPlace(other: Self)<br>&gt; +  mutating func unite(other: Self)<br>&gt;<br>&gt; -  mutating func intersectInPlace(other: Self)<br>&gt; +  mutating func intersect(other: Self)<br>&gt;<br>&gt; -  mutating func subtractInPlace(other: Self)<br>&gt; +  mutating func subtract(other: Self)<br>&gt;<br>&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;<br>&gt; Comments:<br>&gt;<br>&gt; With this alternative we keep the union name which I assume is<br>&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt; version) as I wanted all the mutable methods use verbs for<br>&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt; the dictionary and it is a verb.<br>&gt;<br>&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;<br>&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt; quickly / easily.<br>&gt;<br>&gt; The mutable methods all use verbs:  unite, intersect, subtract and<br>&gt; symmetricSubtract.<br>&gt;<br>&gt; ALTERNATIVE 2<br>&gt;<br>&gt; Non-mutable<br>&gt;<br>&gt; -  func union(other: Self) -&gt; Self<br>&gt; +  func adding(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func intersect(other: Self) -&gt; Self<br>&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;<br>&gt; -  func subtract(other: Self) -&gt; Self<br>&gt; +  func removing(other: Self) -&gt; Self<br>&gt;<br>&gt; Mutable<br>&gt;<br>&gt; -  mutating func unionInPlace(other: Self)<br>&gt; +  mutating func add(other: Self)<br>&gt;<br>&gt; -  mutating func intersectInPlace(other: Self)<br>&gt; +  mutating func intersect(other: Self)<br>&gt;<br>&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;<br>&gt; -  mutating func subtractInPlace(other: Self)<br>&gt; +  mutating func remove(other: Self)<br>&gt;<br>&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt; may not like this, that is why I have it as the second alternative.<br>&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;<br>&gt;<br>&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt; to stay away from the mathematical terms altogether.<br>&gt;<br>&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt; mutating func insertContentsOf(other)<br>&gt;<br>&gt; func members(in other: Self) -&gt; Self                           //<br>&gt; intersection<br>&gt; mutating func removeMembers(notIn: other)<br>&gt;<br>&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self //<br>&gt; symmetric difference<br>&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;<br>&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt; mutating func removeMembers(in other: Self)<br>&gt;<br>&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt; above.<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/8924069c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 15, 2016 at 11:00:00am</p></header><div class="content"><p>I think the reason why the mathematical names look strange is that in<br>mathematics they are used differently; either they are functions instead of<br>methods or they are operators, e.g.:<br></p><p>    sin(x)<br></p><p>not:<br></p><p>    x.sin()<br></p><p>Similarly:<br></p><p>    both = first ∪ second<br></p><p>Not:<br></p><p>    both = first.union(second)<br></p><p>Therefore I think mathematical names require either special treatment or<br>just getting used to a different convention. I would suggest getting use to<br>a different convention; i.e.using the same naming convention as sort etc.,<br>e.g.:<br></p><p>    first.union(second) // In place replacement of first with the union of<br>first and second<br>    both = first.unioned(second) // both = the union of first and second<br></p><p>  -- Howard.<br></p><p>On 15 February 2016 at 08:37, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; From a 10,000-ft view, I&#39;d suggest that the noun/verb rule consistently<br>&gt; runs into a problem with mathematical terms.<br>&gt;<br>&gt; In general, mathematical functions don&#39;t have verb forms. You &#39;compute&#39;<br>&gt; the reciprocal, or &#39;find&#39; the reciprocal, or &#39;take&#39; the reciprocal, you<br>&gt; don&#39;t &#39;reciprocate&#39; or &#39;reciprocalize&#39;. Likewise for trigonometric<br>&gt; functions, etc. Nor can you really &#39;cross produce&#39;...<br>&gt;<br>&gt; So consistent is this trend that where two words might be noun/verb<br>&gt; counterparts, like intersect/intersection and transform/transformation,<br>&gt; common math usage treats both as acceptable nouns.<br>&gt;<br>&gt; In colloquial usage, you might verb the noun, but then by definition the<br>&gt; verb and noun become the same. Then, to generate a noun<br>&gt; phrase/participle/etc. that looks different from the verb, you have to<br>&gt; noun-ify the verbed noun.<br>&gt;<br>&gt; Without an exception for mathematical function names, the only solution to<br>&gt; fulfill these new Swift rules are clobbering the well-known math name or<br>&gt; not using the math name at all. Indeed all proposed solutions so far come<br>&gt; down to one of four options, either applied globally or only to sets for<br>&gt; now, punting the rest down the road:<br>&gt;<br>&gt; (1) Abandon the rule, making a new one (e.g.: .=)<br>&gt; (2) Make an exception to the rule for math function names<br>&gt; (3) Generate the least offensive noun-ified verbed nouns based on math<br>&gt; function names<br>&gt; (4) Don&#39;t use math function names<br>&gt;<br>&gt; (1) is off the table, according to the core team. My vote at this point is<br>&gt; for (2), and I see that a few others have voiced that opinion. It&#39;d be nice<br>&gt; to get a sense from the core team if that is even a possibility. (3) has<br>&gt; elicited a lot of discussion and visceral reactions. (4) might be workable<br>&gt; for sets alone but surely can&#39;t be a generalized solution for all<br>&gt; mathematical concepts to be encountered in Swift.<br>&gt;<br>&gt; On Sun, Feb 14, 2016 at 3:14 PM Tyler Fleming Cloutier via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com<br>&gt;&gt; &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com<br>&gt;&gt; &lt;http://cloutiertyler-at-aol.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt; that might be misleading.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Agreed. I’m all for that.<br>&gt;&gt;<br>&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt; have to double check themselves every time.<br>&gt;&gt;<br>&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; +1<br>&gt;&gt;<br>&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt; accomplishing their goal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I can&#39;t disagree.<br>&gt;&gt;<br>&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt; the guidelines.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt; with the guidelines.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt;&gt; before, but I should have included the details here.<br>&gt;&gt;<br>&gt;&gt; Here are my previous posts:<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt;&gt; &lt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; Basically the issues come down to the following. The Accelerate<br>&gt;&gt; framework typical operates in a non-mutating way. This means that my<br>&gt;&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt;&gt; rule according to the guidelines to name my methods.<br>&gt;&gt;<br>&gt;&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt;&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt;&gt; as global functions, but I can’t do that for a number of<br>&gt;&gt; methods. Consider:<br>&gt;&gt;<br>&gt;&gt; remainder<br>&gt;&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt;&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt;&gt; mean (same as above)<br>&gt;&gt; cross<br>&gt;&gt; reciprocal<br>&gt;&gt; threshold<br>&gt;&gt; copysign<br>&gt;&gt; fastFourierTransform<br>&gt;&gt; pow (arguably the method version should be called raisedTo)<br>&gt;&gt;<br>&gt;&gt; I could force all these to be global functions only, but these are not<br>&gt;&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt;&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt;&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt;&gt; certain functions in my API.<br>&gt;&gt;<br>&gt;&gt; In this case there are no corresponding mutating operations because of<br>&gt;&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt;&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt;&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt;&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; As long as the ones without side effects read as noun phrases and the<br>&gt;&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt;&gt; needed.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Ah yes, you are very right. Still what would the mutating versions of<br>&gt;&gt; remainder, fastFourierTransform, or reciprocal be? getRemainder?<br>&gt;&gt; applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br>&gt;&gt;<br>&gt;&gt; I also suppose cross could become x.crossProduct(with: y) and copysign,<br>&gt;&gt; x.copyingSign(of: y). Seems a little verbose, but it does the job.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt; Tyler<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt; Tyler<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Tyler<br>&gt;&gt;<br>&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Dave,<br>&gt;&gt;<br>&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt; everybody else think?<br>&gt;&gt;<br>&gt;&gt; Non-mutable<br>&gt;&gt;<br>&gt;&gt; let union =  a.merged(with: b)<br>&gt;&gt; let intersection =  a.members(in: b)<br>&gt;&gt; let difference =  a.removingMembers(in: b)<br>&gt;&gt; let symmetricDifference =  a.merged(with: b, removingMembersInCommon:<br>&gt;&gt; true)<br>&gt;&gt;<br>&gt;&gt; Mutable (In-Place)<br>&gt;&gt;<br>&gt;&gt; a.merge(with: b) // union in-place<br>&gt;&gt; a.removeMembers(notIn: b) // intersect in-place<br>&gt;&gt; a.removeMembers(in: b) // difference in-place<br>&gt;&gt; a.merge(with: b, removeMembersInCommon: true) // symmetric difference<br>&gt;&gt; in-place<br>&gt;&gt;<br>&gt;&gt; Ricardo Parada<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;<br>&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;<br>&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;<br>&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt; +  func union(other: Self) -&gt; Self Assumes union is a noun, i.e. not a<br>&gt;&gt; verb<br>&gt;&gt;<br>&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; Mutable (verb-based)<br>&gt;&gt;<br>&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;<br>&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;<br>&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;<br>&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;<br>&gt;&gt; Comments:<br>&gt;&gt;<br>&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;<br>&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;<br>&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt; quickly / easily.<br>&gt;&gt;<br>&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and<br>&gt;&gt; symmetricSubtract.<br>&gt;&gt;<br>&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;<br>&gt;&gt; Non-mutable<br>&gt;&gt;<br>&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; Mutable<br>&gt;&gt;<br>&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;<br>&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;<br>&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;<br>&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;<br>&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;<br>&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;<br>&gt;&gt; func members(in other: Self) -&gt; Self                           //<br>&gt;&gt; intersection<br>&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;<br>&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self //<br>&gt;&gt; symmetric difference<br>&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;<br>&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    //<br>&gt;&gt; subtract<br>&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;<br>&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt; above.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/4843fc64/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 15, 2016 at 01:00:00am</p></header><div class="content"><p>I largely agree with you. One other option I&#39;ve been thinking is to instead<br>keep these mathematical functions as the nouns they are. To make a verb<br>phrase, insert an unambiguous verb, for example:<br></p><p>x.union(with: y)<br>// not mutating, because union really is a noun<br>// (the &#39;with&#39; label is negotiable)<br></p><p>x.assignUnion(with: y)<br>// mutating; or, for brevity but not clarity:<br>x.doUnion(with: y)<br></p><p><br></p><p>On Sun, Feb 14, 2016 at 6:53 PM Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>wrote:<br></p><p>&gt; I think the reason why the mathematical names look strange is that in<br>&gt; mathematics they are used differently; either they are functions instead of<br>&gt; methods or they are operators, e.g.:<br>&gt;<br>&gt;     sin(x)<br>&gt;<br>&gt; not:<br>&gt;<br>&gt;     x.sin()<br>&gt;<br>&gt; Similarly:<br>&gt;<br>&gt;     both = first ∪ second<br>&gt;<br>&gt; Not:<br>&gt;<br>&gt;     both = first.union(second)<br>&gt;<br>&gt; Therefore I think mathematical names require either special treatment or<br>&gt; just getting used to a different convention. I would suggest getting use to<br>&gt; a different convention; i.e.using the same naming convention as sort etc.,<br>&gt; e.g.:<br>&gt;<br>&gt;     first.union(second) // In place replacement of first with the union of<br>&gt; first and second<br>&gt;     both = first.unioned(second) // both = the union of first and second<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 15 February 2016 at 08:37, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; From a 10,000-ft view, I&#39;d suggest that the noun/verb rule consistently<br>&gt;&gt; runs into a problem with mathematical terms.<br>&gt;&gt;<br>&gt;&gt; In general, mathematical functions don&#39;t have verb forms. You &#39;compute&#39;<br>&gt;&gt; the reciprocal, or &#39;find&#39; the reciprocal, or &#39;take&#39; the reciprocal, you<br>&gt;&gt; don&#39;t &#39;reciprocate&#39; or &#39;reciprocalize&#39;. Likewise for trigonometric<br>&gt;&gt; functions, etc. Nor can you really &#39;cross produce&#39;...<br>&gt;&gt;<br>&gt;&gt; So consistent is this trend that where two words might be noun/verb<br>&gt;&gt; counterparts, like intersect/intersection and transform/transformation,<br>&gt;&gt; common math usage treats both as acceptable nouns.<br>&gt;&gt;<br>&gt;&gt; In colloquial usage, you might verb the noun, but then by definition the<br>&gt;&gt; verb and noun become the same. Then, to generate a noun<br>&gt;&gt; phrase/participle/etc. that looks different from the verb, you have to<br>&gt;&gt; noun-ify the verbed noun.<br>&gt;&gt;<br>&gt;&gt; Without an exception for mathematical function names, the only solution<br>&gt;&gt; to fulfill these new Swift rules are clobbering the well-known math name or<br>&gt;&gt; not using the math name at all. Indeed all proposed solutions so far come<br>&gt;&gt; down to one of four options, either applied globally or only to sets for<br>&gt;&gt; now, punting the rest down the road:<br>&gt;&gt;<br>&gt;&gt; (1) Abandon the rule, making a new one (e.g.: .=)<br>&gt;&gt; (2) Make an exception to the rule for math function names<br>&gt;&gt; (3) Generate the least offensive noun-ified verbed nouns based on math<br>&gt;&gt; function names<br>&gt;&gt; (4) Don&#39;t use math function names<br>&gt;&gt;<br>&gt;&gt; (1) is off the table, according to the core team. My vote at this point<br>&gt;&gt; is for (2), and I see that a few others have voiced that opinion. It&#39;d be<br>&gt;&gt; nice to get a sense from the core team if that is even a possibility. (3)<br>&gt;&gt; has elicited a lot of discussion and visceral reactions. (4) might be<br>&gt;&gt; workable for sets alone but surely can&#39;t be a generalized solution for all<br>&gt;&gt; mathematical concepts to be encountered in Swift.<br>&gt;&gt;<br>&gt;&gt; On Sun, Feb 14, 2016 at 3:14 PM Tyler Fleming Cloutier via<br>&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com<br>&gt;&gt;&gt; &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com<br>&gt;&gt;&gt; &lt;http://cloutiertyler-at-aol.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt;&gt; that might be misleading.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Agreed. I’m all for that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt;&gt; have to double check themselves every time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt;&gt; accomplishing their goal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can&#39;t disagree.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt;&gt; the guidelines.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt;&gt; with the guidelines.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt;&gt;&gt; before, but I should have included the details here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here are my previous posts:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt;&gt;&gt; &lt;<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Basically the issues come down to the following. The Accelerate<br>&gt;&gt;&gt; framework typical operates in a non-mutating way. This means that my<br>&gt;&gt;&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt;&gt;&gt; rule according to the guidelines to name my methods.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt;&gt;&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt;&gt;&gt; as global functions, but I can’t do that for a number of<br>&gt;&gt;&gt; methods. Consider:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; remainder<br>&gt;&gt;&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt;&gt;&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt;&gt;&gt; mean (same as above)<br>&gt;&gt;&gt; cross<br>&gt;&gt;&gt; reciprocal<br>&gt;&gt;&gt; threshold<br>&gt;&gt;&gt; copysign<br>&gt;&gt;&gt; fastFourierTransform<br>&gt;&gt;&gt; pow (arguably the method version should be called raisedTo)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I could force all these to be global functions only, but these are not<br>&gt;&gt;&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt;&gt;&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt;&gt;&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt;&gt;&gt; certain functions in my API.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case there are no corresponding mutating operations because of<br>&gt;&gt;&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt;&gt;&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt;&gt;&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt;&gt;&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As long as the ones without side effects read as noun phrases and the<br>&gt;&gt;&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt;&gt;&gt; needed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ah yes, you are very right. Still what would the mutating versions of<br>&gt;&gt;&gt; remainder, fastFourierTransform, or reciprocal be? getRemainder?<br>&gt;&gt;&gt; applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I also suppose cross could become x.crossProduct(with: y) and copysign,<br>&gt;&gt;&gt; x.copyingSign(of: y). Seems a little verbose, but it does the job.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let union =  a.merged(with: b)<br>&gt;&gt;&gt; let intersection =  a.members(in: b)<br>&gt;&gt;&gt; let difference =  a.removingMembers(in: b)<br>&gt;&gt;&gt; let symmetricDifference =  a.merged(with: b, removingMembersInCommon:<br>&gt;&gt;&gt; true)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; a.merge(with: b) // union in-place<br>&gt;&gt;&gt; a.removeMembers(notIn: b) // intersect in-place<br>&gt;&gt;&gt; a.removeMembers(in: b) // difference in-place<br>&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true) // symmetric difference<br>&gt;&gt;&gt; in-place<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func union(other: Self) -&gt; Self Assumes union is a noun, i.e. not a<br>&gt;&gt;&gt; verb<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Comments:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and<br>&gt;&gt;&gt; symmetricSubtract.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           //<br>&gt;&gt;&gt; intersection<br>&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self //<br>&gt;&gt;&gt; symmetric difference<br>&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    //<br>&gt;&gt;&gt; subtract<br>&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt; above.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/556f0d2e/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 15, 2016 at 05:00:00pm</p></header><div class="content"><p>We might also have just mutating versions as methods and nonmutating versions as global functions, i.e.<br></p><p>a.union(b) // mutating<br>let c = union(a, b) // non-mutating<br></p><p>-Thorsten <br></p><p>&gt; Am 15.02.2016 um 01:53 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I think the reason why the mathematical names look strange is that in mathematics they are used differently; either they are functions instead of methods or they are operators, e.g.:<br>&gt; <br>&gt;     sin(x)<br>&gt; <br>&gt; not:<br>&gt; <br>&gt;     x.sin()<br>&gt; <br>&gt; Similarly:<br>&gt; <br>&gt;     both = first ∪ second<br>&gt; <br>&gt; Not:<br>&gt; <br>&gt;     both = first.union(second)<br>&gt; <br>&gt; Therefore I think mathematical names require either special treatment or just getting used to a different convention. I would suggest getting use to a different convention; i.e.using the same naming convention as sort etc., e.g.:<br>&gt; <br>&gt;     first.union(second) // In place replacement of first with the union of first and second<br>&gt;     both = first.unioned(second) // both = the union of first and second<br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt;&gt; On 15 February 2016 at 08:37, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; From a 10,000-ft view, I&#39;d suggest that the noun/verb rule consistently runs into a problem with mathematical terms.<br>&gt;&gt; <br>&gt;&gt; In general, mathematical functions don&#39;t have verb forms. You &#39;compute&#39; the reciprocal, or &#39;find&#39; the reciprocal, or &#39;take&#39; the reciprocal, you don&#39;t &#39;reciprocate&#39; or &#39;reciprocalize&#39;. Likewise for trigonometric functions, etc. Nor can you really &#39;cross produce&#39;...<br>&gt;&gt; <br>&gt;&gt; So consistent is this trend that where two words might be noun/verb counterparts, like intersect/intersection and transform/transformation, common math usage treats both as acceptable nouns.<br>&gt;&gt; <br>&gt;&gt; In colloquial usage, you might verb the noun, but then by definition the verb and noun become the same. Then, to generate a noun phrase/participle/etc. that looks different from the verb, you have to noun-ify the verbed noun.<br>&gt;&gt; <br>&gt;&gt; Without an exception for mathematical function names, the only solution to fulfill these new Swift rules are clobbering the well-known math name or not using the math name at all. Indeed all proposed solutions so far come down to one of four options, either applied globally or only to sets for now, punting the rest down the road:<br>&gt;&gt; <br>&gt;&gt; (1) Abandon the rule, making a new one (e.g.: .=)<br>&gt;&gt; (2) Make an exception to the rule for math function names<br>&gt;&gt; (3) Generate the least offensive noun-ified verbed nouns based on math function names<br>&gt;&gt; (4) Don&#39;t use math function names<br>&gt;&gt; <br>&gt;&gt; (1) is off the table, according to the core team. My vote at this point is for (2), and I see that a few others have voiced that opinion. It&#39;d be nice to get a sense from the core team if that is even a possibility. (3) has elicited a lot of discussion and visceral reactions. (4) might be workable for sets alone but surely can&#39;t be a generalized solution for all mathematical concepts to be encountered in Swift.<br>&gt;&gt; <br>&gt;&gt; On Sun, Feb 14, 2016 at 3:14 PM Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt;&gt;&gt;&gt;&gt; that might be misleading.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Agreed. I’m all for that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; have to double check themselves every time.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; accomplishing their goal. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can&#39;t disagree.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the guidelines.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt;&gt;&gt;&gt;&gt; with the guidelines.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt;&gt;&gt;&gt;&gt; before, but I should have included the details here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here are my previous posts:<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Basically the issues come down to the following. The Accelerate<br>&gt;&gt;&gt;&gt;&gt; framework typical operates in a non-mutating way. This means that my<br>&gt;&gt;&gt;&gt;&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt;&gt;&gt;&gt;&gt; rule according to the guidelines to name my methods.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt;&gt;&gt;&gt;&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt;&gt;&gt;&gt;&gt; as global functions, but I can’t do that for a number of<br>&gt;&gt;&gt;&gt;&gt; methods. Consider:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; remainder<br>&gt;&gt;&gt;&gt;&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt;&gt;&gt;&gt;&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt;&gt;&gt;&gt;&gt; mean (same as above)<br>&gt;&gt;&gt;&gt;&gt; cross<br>&gt;&gt;&gt;&gt;&gt; reciprocal<br>&gt;&gt;&gt;&gt;&gt; threshold<br>&gt;&gt;&gt;&gt;&gt; copysign<br>&gt;&gt;&gt;&gt;&gt; fastFourierTransform<br>&gt;&gt;&gt;&gt;&gt; pow (arguably the method version should be called raisedTo)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I could force all these to be global functions only, but these are not<br>&gt;&gt;&gt;&gt;&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt;&gt;&gt;&gt;&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt;&gt;&gt;&gt;&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt;&gt;&gt;&gt;&gt; certain functions in my API.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this case there are no corresponding mutating operations because of<br>&gt;&gt;&gt;&gt;&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt;&gt;&gt;&gt;&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt;&gt;&gt;&gt;&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt;&gt;&gt;&gt;&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As long as the ones without side effects read as noun phrases and the<br>&gt;&gt;&gt;&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt;&gt;&gt;&gt; needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah yes, you are very right. Still what would the mutating versions of remainder, fastFourierTransform, or reciprocal be? getRemainder? applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also suppose cross could become x.crossProduct(with: y) and copysign, x.copyingSign(of: y). Seems a little verbose, but it does the job.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/f91a6148/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 15, 2016 at 12:00:00pm</p></header><div class="content"><p>I also prefer (2). Isn&#39;t &quot;union&quot;, &quot;intersection&quot;, ... a &quot;Term of Art&quot;? See the guidelines under &quot;Stick to the established meaning&quot;.<br></p><p>So we should stick to the mathematical naming.<br></p><p>Since these terms almost always return a new instance we should have an obvious mutating version with an &quot;inPlace&quot; suffix.<br></p><p>- Maximilian<br></p><p>&gt; Am 14.02.2016 um 22:37 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; From a 10,000-ft view, I&#39;d suggest that the noun/verb rule consistently runs into a problem with mathematical terms.<br>&gt; <br>&gt; In general, mathematical functions don&#39;t have verb forms. You &#39;compute&#39; the reciprocal, or &#39;find&#39; the reciprocal, or &#39;take&#39; the reciprocal, you don&#39;t &#39;reciprocate&#39; or &#39;reciprocalize&#39;. Likewise for trigonometric functions, etc. Nor can you really &#39;cross produce&#39;...<br>&gt; <br>&gt; So consistent is this trend that where two words might be noun/verb counterparts, like intersect/intersection and transform/transformation, common math usage treats both as acceptable nouns.<br>&gt; <br>&gt; In colloquial usage, you might verb the noun, but then by definition the verb and noun become the same. Then, to generate a noun phrase/participle/etc. that looks different from the verb, you have to noun-ify the verbed noun.<br>&gt; <br>&gt; Without an exception for mathematical function names, the only solution to fulfill these new Swift rules are clobbering the well-known math name or not using the math name at all. Indeed all proposed solutions so far come down to one of four options, either applied globally or only to sets for now, punting the rest down the road:<br>&gt; <br>&gt; (1) Abandon the rule, making a new one (e.g.: .=)<br>&gt; (2) Make an exception to the rule for math function names<br>&gt; (3) Generate the least offensive noun-ified verbed nouns based on math function names<br>&gt; (4) Don&#39;t use math function names<br>&gt; <br>&gt; (1) is off the table, according to the core team. My vote at this point is for (2), and I see that a few others have voiced that opinion. It&#39;d be nice to get a sense from the core team if that is even a possibility. (3) has elicited a lot of discussion and visceral reactions. (4) might be workable for sets alone but surely can&#39;t be a generalized solution for all mathematical concepts to be encountered in Swift.<br>&gt; On Sun, Feb 14, 2016 at 3:14 PM Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt;&gt;&gt;&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt;&gt;&gt;&gt; that might be misleading.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed. I’m all for that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt;&gt;&gt;&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt;&gt;&gt;&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt;&gt;&gt;&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt;&gt;&gt;&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt;&gt;&gt;&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt;&gt;&gt;&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt;&gt;&gt;&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt;&gt;&gt;&gt;&gt; have to double check themselves every time.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt;&gt;&gt;&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt;&gt;&gt;&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt;&gt;&gt;&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt; accomplishing their goal. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can&#39;t disagree.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt;&gt;&gt;&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt;&gt;&gt;&gt;&gt; the guidelines.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt;&gt;&gt;&gt; with the guidelines.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt;&gt;&gt;&gt; before, but I should have included the details here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are my previous posts:<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Basically the issues come down to the following. The Accelerate<br>&gt;&gt;&gt;&gt; framework typical operates in a non-mutating way. This means that my<br>&gt;&gt;&gt;&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt;&gt;&gt;&gt; rule according to the guidelines to name my methods.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt;&gt;&gt;&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt;&gt;&gt;&gt; as global functions, but I can’t do that for a number of<br>&gt;&gt;&gt;&gt; methods. Consider:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; remainder<br>&gt;&gt;&gt;&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt;&gt;&gt;&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt;&gt;&gt;&gt; mean (same as above)<br>&gt;&gt;&gt;&gt; cross<br>&gt;&gt;&gt;&gt; reciprocal<br>&gt;&gt;&gt;&gt; threshold<br>&gt;&gt;&gt;&gt; copysign<br>&gt;&gt;&gt;&gt; fastFourierTransform<br>&gt;&gt;&gt;&gt; pow (arguably the method version should be called raisedTo)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could force all these to be global functions only, but these are not<br>&gt;&gt;&gt;&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt;&gt;&gt;&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt;&gt;&gt;&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt;&gt;&gt;&gt; certain functions in my API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case there are no corresponding mutating operations because of<br>&gt;&gt;&gt;&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt;&gt;&gt;&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt;&gt;&gt;&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt;&gt;&gt;&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as the ones without side effects read as noun phrases and the<br>&gt;&gt;&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt;&gt;&gt; needed.<br>&gt;&gt; <br>&gt;&gt; Ah yes, you are very right. Still what would the mutating versions of remainder, fastFourierTransform, or reciprocal be? getRemainder? applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br>&gt;&gt; <br>&gt;&gt; I also suppose cross could become x.crossProduct(with: y) and copysign, x.copyingSign(of: y). Seems a little verbose, but it does the job.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/79f33ff0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 15, 2016 at 10:00:00am</p></header><div class="content"><p>I agree. I&#39;d much prefer to retain set terminology including &quot;union&quot;, &quot;intersection&quot;, etc.<br></p><p>-- E<br></p><p>&gt; On Feb 15, 2016, at 4:20 AM, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I also prefer (2). Isn&#39;t &quot;union&quot;, &quot;intersection&quot;, ... a &quot;Term of Art&quot;? See the guidelines under &quot;Stick to the established meaning&quot;.<br>&gt; <br>&gt; So we should stick to the mathematical naming.<br>&gt; <br>&gt; Since these terms almost always return a new instance we should have an obvious mutating version with an &quot;inPlace&quot; suffix.<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt; Am 14.02.2016 um 22:37 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; From a 10,000-ft view, I&#39;d suggest that the noun/verb rule consistently runs into a problem with mathematical terms.<br>&gt;&gt; <br>&gt;&gt; In general, mathematical functions don&#39;t have verb forms. You &#39;compute&#39; the reciprocal, or &#39;find&#39; the reciprocal, or &#39;take&#39; the reciprocal, you don&#39;t &#39;reciprocate&#39; or &#39;reciprocalize&#39;. Likewise for trigonometric functions, etc. Nor can you really &#39;cross produce&#39;...<br>&gt;&gt; <br>&gt;&gt; So consistent is this trend that where two words might be noun/verb counterparts, like intersect/intersection and transform/transformation, common math usage treats both as acceptable nouns.<br>&gt;&gt; <br>&gt;&gt; In colloquial usage, you might verb the noun, but then by definition the verb and noun become the same. Then, to generate a noun phrase/participle/etc. that looks different from the verb, you have to noun-ify the verbed noun.<br>&gt;&gt; <br>&gt;&gt; Without an exception for mathematical function names, the only solution to fulfill these new Swift rules are clobbering the well-known math name or not using the math name at all. Indeed all proposed solutions so far come down to one of four options, either applied globally or only to sets for now, punting the rest down the road:<br>&gt;&gt; <br>&gt;&gt; (1) Abandon the rule, making a new one (e.g.: .=)<br>&gt;&gt; (2) Make an exception to the rule for math function names<br>&gt;&gt; (3) Generate the least offensive noun-ified verbed nouns based on math function names<br>&gt;&gt; (4) Don&#39;t use math function names<br>&gt;&gt; <br>&gt;&gt; (1) is off the table, according to the core team. My vote at this point is for (2), and I see that a few others have voiced that opinion. It&#39;d be nice to get a sense from the core team if that is even a possibility. (3) has elicited a lot of discussion and visceral reactions. (4) might be workable for sets alone but surely can&#39;t be a generalized solution for all mathematical concepts to be encountered in Swift.<br>&gt;&gt; On Sun, Feb 14, 2016 at 3:14 PM Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt;&gt;&gt;&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt;&gt;&gt;&gt; that might be misleading.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed. I’m all for that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt;&gt;&gt;&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt;&gt;&gt;&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt;&gt;&gt;&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt;&gt;&gt;&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt;&gt;&gt;&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt;&gt;&gt;&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt;&gt;&gt;&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt;&gt;&gt;&gt;&gt; have to double check themselves every time.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt;&gt;&gt;&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt;&gt;&gt;&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt;&gt;&gt;&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt; accomplishing their goal. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can&#39;t disagree.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt;&gt;&gt;&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt;&gt;&gt;&gt;&gt; the guidelines.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt;&gt;&gt;&gt; with the guidelines.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt;&gt;&gt;&gt; before, but I should have included the details here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are my previous posts:<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Basically the issues come down to the following. The Accelerate<br>&gt;&gt;&gt;&gt; framework typical operates in a non-mutating way. This means that my<br>&gt;&gt;&gt;&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt;&gt;&gt;&gt; rule according to the guidelines to name my methods.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt;&gt;&gt;&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt;&gt;&gt;&gt; as global functions, but I can’t do that for a number of<br>&gt;&gt;&gt;&gt; methods. Consider:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; remainder<br>&gt;&gt;&gt;&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt;&gt;&gt;&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt;&gt;&gt;&gt; mean (same as above)<br>&gt;&gt;&gt;&gt; cross<br>&gt;&gt;&gt;&gt; reciprocal<br>&gt;&gt;&gt;&gt; threshold<br>&gt;&gt;&gt;&gt; copysign<br>&gt;&gt;&gt;&gt; fastFourierTransform<br>&gt;&gt;&gt;&gt; pow (arguably the method version should be called raisedTo)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could force all these to be global functions only, but these are not<br>&gt;&gt;&gt;&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt;&gt;&gt;&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt;&gt;&gt;&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt;&gt;&gt;&gt; certain functions in my API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case there are no corresponding mutating operations because of<br>&gt;&gt;&gt;&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt;&gt;&gt;&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt;&gt;&gt;&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt;&gt;&gt;&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as the ones without side effects read as noun phrases and the<br>&gt;&gt;&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt;&gt;&gt; needed.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Ah yes, you are very right. Still what would the mutating versions of remainder, fastFourierTransform, or reciprocal be? getRemainder? applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br>&gt;&gt; <br>&gt;&gt; I also suppose cross could become x.crossProduct(with: y) and copysign, x.copyingSign(of: y). Seems a little verbose, but it does the job.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/91af3e70/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 15, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Maximilian,<br></p><p>I think using Term of Art for Sets is fine for the non-mutable methods.  They map well to the operators:  ∪ (union), ∩ (intersection), ∖ (difference), △ (symmetric difference), c (complement).<br></p><p>When it comes to mutating the set it is all about merging or removing members.  The english language works just fine for the mutable methods.  There is no need for using a Term of Art for these.<br></p><p>Non-mutable<br></p><p>let union = 			a.union(b)			// a ∪ b <br>let intersection = 		a.intersection(b)		// a ∩ b<br>let difference = 		a.difference(b)			// a \ b<br></p><p>let symmetricDifference = 	a.symmetricDifference(b)	// a △ b<br>let symmetricDifference =	a.intersectionComplement(b)	// (a ∩ b)c  == a △ b<br>let symmetricDifference = 	a.unionWithoutIntersection(b)	// (a ∪ b) \ (a ∩ b) == a △ b<br>let symmetricDifference = 	a.unionMinusIntersection(b)	// (a ∪ b) \ (a ∩ b) == a △ b<br></p><p>For the four &quot;symmetric difference&quot; alternatives listed above I am not sure I like intersectionComplement because there is a relative complement and an absolute complement.  It is not clear which complement I am referring to.  If it was up to me I would pick symmetricDifference or unionWithoutIntersection. I am used to both of these but think unionWithoutIntersection gives a better visual of what it is.  Everybody understands union, intersection and difference.<br></p><p>Mutable (verb-based)<br></p><p>I like the verb merge better than add because it conveys the idea that two members that are equal become one, i.e. there are no duplicate members.  But add could work equally well.<br></p><p>If a is a mutable set then you may add:<br></p><p>a.merge(membersIn: b)			// union in-place<br>a.remove(membersNotIn: b)		// intersection in-place<br>a.remove(membersIn: b)			// difference in-place<br>a.merge(membersRemovingIntersection: b)	// symmetric difference in-place<br></p><p><br></p><p><br>&gt; On Feb 15, 2016, at 6:20 AM, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I also prefer (2). Isn&#39;t &quot;union&quot;, &quot;intersection&quot;, ... a &quot;Term of Art&quot;? See the guidelines under &quot;Stick to the established meaning&quot;.<br>&gt; <br>&gt; So we should stick to the mathematical naming.<br>&gt; <br>&gt; Since these terms almost always return a new instance we should have an obvious mutating version with an &quot;inPlace&quot; suffix.<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt; Am 14.02.2016 um 22:37 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; From a 10,000-ft view, I&#39;d suggest that the noun/verb rule consistently runs into a problem with mathematical terms.<br>&gt;&gt; <br>&gt;&gt; In general, mathematical functions don&#39;t have verb forms. You &#39;compute&#39; the reciprocal, or &#39;find&#39; the reciprocal, or &#39;take&#39; the reciprocal, you don&#39;t &#39;reciprocate&#39; or &#39;reciprocalize&#39;. Likewise for trigonometric functions, etc. Nor can you really &#39;cross produce&#39;...<br>&gt;&gt; <br>&gt;&gt; So consistent is this trend that where two words might be noun/verb counterparts, like intersect/intersection and transform/transformation, common math usage treats both as acceptable nouns.<br>&gt;&gt; <br>&gt;&gt; In colloquial usage, you might verb the noun, but then by definition the verb and noun become the same. Then, to generate a noun phrase/participle/etc. that looks different from the verb, you have to noun-ify the verbed noun.<br>&gt;&gt; <br>&gt;&gt; Without an exception for mathematical function names, the only solution to fulfill these new Swift rules are clobbering the well-known math name or not using the math name at all. Indeed all proposed solutions so far come down to one of four options, either applied globally or only to sets for now, punting the rest down the road:<br>&gt;&gt; <br>&gt;&gt; (1) Abandon the rule, making a new one (e.g.: .=)<br>&gt;&gt; (2) Make an exception to the rule for math function names<br>&gt;&gt; (3) Generate the least offensive noun-ified verbed nouns based on math function names<br>&gt;&gt; (4) Don&#39;t use math function names<br>&gt;&gt; <br>&gt;&gt; (1) is off the table, according to the core team. My vote at this point is for (2), and I see that a few others have voiced that opinion. It&#39;d be nice to get a sense from the core team if that is even a possibility. (3) has elicited a lot of discussion and visceral reactions. (4) might be workable for sets alone but surely can&#39;t be a generalized solution for all mathematical concepts to be encountered in Swift.<br>&gt;&gt; On Sun, Feb 14, 2016 at 3:14 PM Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com &lt;http://cloutiertyler-at-aol.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt;&gt;&gt;&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt;&gt;&gt;&gt; that might be misleading.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed. I’m all for that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt;&gt;&gt;&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt;&gt;&gt;&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt;&gt;&gt;&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt;&gt;&gt;&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt;&gt;&gt;&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt;&gt;&gt;&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt;&gt;&gt;&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt;&gt;&gt;&gt;&gt; have to double check themselves every time.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt;&gt;&gt;&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt;&gt;&gt;&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt;&gt;&gt;&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt; accomplishing their goal. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can&#39;t disagree.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt;&gt;&gt;&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt;&gt;&gt;&gt;&gt; the guidelines.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt;&gt;&gt;&gt; with the guidelines.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt;&gt;&gt;&gt; before, but I should have included the details here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are my previous posts:<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Basically the issues come down to the following. The Accelerate<br>&gt;&gt;&gt;&gt; framework typical operates in a non-mutating way. This means that my<br>&gt;&gt;&gt;&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt;&gt;&gt;&gt; rule according to the guidelines to name my methods.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt;&gt;&gt;&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt;&gt;&gt;&gt; as global functions, but I can’t do that for a number of<br>&gt;&gt;&gt;&gt; methods. Consider:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; remainder<br>&gt;&gt;&gt;&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt;&gt;&gt;&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt;&gt;&gt;&gt; mean (same as above)<br>&gt;&gt;&gt;&gt; cross<br>&gt;&gt;&gt;&gt; reciprocal<br>&gt;&gt;&gt;&gt; threshold<br>&gt;&gt;&gt;&gt; copysign<br>&gt;&gt;&gt;&gt; fastFourierTransform<br>&gt;&gt;&gt;&gt; pow (arguably the method version should be called raisedTo)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could force all these to be global functions only, but these are not<br>&gt;&gt;&gt;&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt;&gt;&gt;&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt;&gt;&gt;&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt;&gt;&gt;&gt; certain functions in my API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case there are no corresponding mutating operations because of<br>&gt;&gt;&gt;&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt;&gt;&gt;&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt;&gt;&gt;&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt;&gt;&gt;&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As long as the ones without side effects read as noun phrases and the<br>&gt;&gt;&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt;&gt;&gt; needed.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Ah yes, you are very right. Still what would the mutating versions of remainder, fastFourierTransform, or reciprocal be? getRemainder? applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br>&gt;&gt; <br>&gt;&gt; I also suppose cross could become x.crossProduct(with: y) and copysign, x.copyingSign(of: y). Seems a little verbose, but it does the job.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/cce7d751/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 19, 2016 at 05:00:00pm</p></header><div class="content"><p>I think those mutating functions below are fine. However the non mutating ones feel a bit awkward since they don&#39;t read well and are less clear than just &quot;union&quot; and &quot;unionInPlace&quot;.<br>But there is also a consistency argument (about Collection methods). Though &quot;Set&quot; is &quot;more mathematical&quot; than other data structures like Array or Dictionary.<br></p><p>For reference the &quot;current&quot; implementation:<br></p><p>&gt; Hi everyone,<br>&gt; <br>&gt; First - I want to thank all of the contributors on this discussion for helping us with this obviously tricky naming problem.<br>&gt; <br>&gt; Dave has already described some of the thinking that has gone into the iterations of the API for Set. You’ve seen stages of that evolution here.<br>&gt; <br>&gt; We’re at the point where we need to make a decision and move on. Not because it’s impossible to come up with better ideas, but because we want to continue to work on the remaining aspects of the naming proposals that we’ve put forth on this list. <br>&gt; <br>&gt; In the future, there is always the opportunity for members of the community and members of the core team to propose ideas like newly discovered names, improvements to the language like keywords for mutation-in-place or special operators, or whatever great thing comes next. If we decide to do those, then we will be sure to consider the impact on the APIs we choose today. There are many tools in our toolbox for rolling out those improvements (deprecation and replacement being the one we’ve used countless times for framework and library API).<br>&gt; <br>&gt; So: by incorporating your ideas in this thread, along with those from other members of the API naming working group, and by adhering to the proposed guidelines as closely as possible, we’re going to go with the following API changes for SetAlgebra for Swift 3:<br>&gt; <br>&gt;     /// Returns the set of elements contained in `self`, in `other`, or in both `self` and `other`.<br>&gt;     /// EXISTING: union<br>&gt;     @warn_unused_result<br>&gt;     func insertingContentsOf(other: Self) -&gt; Self<br>&gt;     <br>&gt;     /// Insert all elements of `other` into `self`.<br>&gt;     /// EXISTING: unionInPlace<br>&gt;     mutating funcinsertContentsOf(other: Self)<br>&gt;     <br>&gt;     /// Returns the set of elements contained in both `self` and `other`.<br>&gt;     /// EXISTING: intersect<br>&gt;     @warn_unused_result<br>&gt;     func intersection(other: Self) -&gt; Self<br>&gt; <br>&gt;     /// Removes all elements of `self` that are not also present in `other`.<br>&gt;     /// EXISTING: intersectInPlace<br>&gt;     mutating func intersect(other: Self)<br>&gt; <br>&gt;     /// Returns the set of elements contained in `self` or in `other`, but not in both `self` and `other`.<br>&gt;     /// EXISTING: exclusiveOr<br>&gt;     @warn_unused_result<br>&gt;     func invertingIntersection(other: Self) -&gt; Self<br>&gt;     <br>&gt;     /// Replaces `self` with a set containing all elements contained in either `self` or `other`, but not both.<br>&gt;     /// EXISTING: exclusiveOrInPlace<br>&gt;     mutating funcinvertIntersection(other: Self)<br>&gt;     <br>&gt;     /// Returns the set of elements contained in `self` but not in `other`.<br>&gt;     /// EXISTING: subtract<br>&gt;     @warn_unused_result<br>&gt;     func removingContentsOf(other: Self) -&gt; Self<br>&gt;     <br>&gt;     /// Removes all elements of `other` from `self`.<br>&gt;     /// EXISTING: subtractInPlace<br>&gt;     mutating funcremoveContentsOf(other: Self)<br>&gt; <br>&gt; Here is a summary of the reasons behind the decision:<br>&gt; <br>&gt; 1. As Dave said, it is important that we are able to apply our guidelines without an exception to such a core type. It’s not just about one particular Set type either, as these methods appear on many places in API (for example — all options are now Sets as well), thanks to Swift support for protocol-oriented-programming.<br>&gt; <br>&gt; 2. Using ‘insert’ instead of ‘union’ makes the method part of a family with the existing API on SetAlgebra: mutating funcinsert(member:). Indeed - the language of ‘insert’ has been in the markdown comment since the beginning. The same justification applies to using ‘remove’ instead of ‘subtract’.<br>&gt; <br>&gt; 3. The ContentsOf suffix is precedented by RangeReplaceableCollection, as a way to disambiguate inserting the contents of some collection vs the collection itself. It makes sense to reuse it here instead of using new terminology.<br>&gt; <br>&gt; 4. With the decision to use ‘insert’ and ‘remove’, we have built a very succinct vocabulary of operations on set: <br>&gt; 	operations which add content (insert)<br>&gt; 	operations which remove content (remove). <br>&gt; <br>&gt; That leaves us with operations which both add and remove content. Intersect is straightforward enough and does not have significant naming challenges, so we keep it and apply the noun-phrase rule to the non-mutating function to distinguish it from the mutating function. exclusiveOr is trickier. However, I believe the suggestion made here of using invert leads us to a succinct name that conveys the right meaning, without putting two verbs in the base name.<br>&gt; <br>&gt; We will also add additional documentation to each of these methods to describe their mathematical underpinnings. I hope that will aid developers in finding the right method, if they are not already familiar with the terminology we choose.<br>&gt; <br>&gt; Again, sincere thanks for all of your input here.<br>&gt; <br>&gt; - Tony<br></p><p><br>===============================<br></p><p>- Maximilian<br></p><p>&gt; Am 16.02.2016 um 04:28 schrieb Ricardo Parada &lt;rparada at mac.com&gt;:<br>&gt; <br>&gt; Hi Maximilian,<br>&gt; <br>&gt; I think using Term of Art for Sets is fine for the non-mutable methods.  They map well to the operators:  ∪ (union), ∩ (intersection), ∖ (difference), △ (symmetric difference), c (complement).<br>&gt; <br>&gt; When it comes to mutating the set it is all about merging or removing members.  The english language works just fine for the mutable methods.  There is no need for using a Term of Art for these.<br>&gt; <br>&gt; Non-mutable<br>&gt; <br>&gt; let union = 			a.union(b)			// a ∪ b <br>&gt; let intersection = 		a.intersection(b)		// a ∩ b<br>&gt; let difference = 		a.difference(b)			// a \ b<br>&gt; <br>&gt; let symmetricDifference = 	a.symmetricDifference(b)	// a △ b<br>&gt; let symmetricDifference =	a.intersectionComplement(b)	// (a ∩ b)c  == a △ b<br>&gt; let symmetricDifference = 	a.unionWithoutIntersection(b)	// (a ∪ b) \ (a ∩ b) == a △ b<br>&gt; let symmetricDifference = 	a.unionMinusIntersection(b)	// (a ∪ b) \ (a ∩ b) == a △ b<br>&gt; <br>&gt; For the four &quot;symmetric difference&quot; alternatives listed above I am not sure I like intersectionComplement because there is a relative complement and an absolute complement.  It is not clear which complement I am referring to.  If it was up to me I would pick symmetricDifference or unionWithoutIntersection. I am used to both of these but think unionWithoutIntersection gives a better visual of what it is.  Everybody understands union, intersection and difference.<br>&gt; <br>&gt; Mutable (verb-based)<br>&gt; <br>&gt; I like the verb merge better than add because it conveys the idea that two members that are equal become one, i.e. there are no duplicate members.  But add could work equally well.<br>&gt; <br>&gt; If a is a mutable set then you may add:<br>&gt; <br>&gt; a.merge(membersIn: b)			// union in-place<br>&gt; a.remove(membersNotIn: b)		// intersection in-place<br>&gt; a.remove(membersIn: b)			// difference in-place<br>&gt; a.merge(membersRemovingIntersection: b)	// symmetric difference in-place<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 15, 2016, at 6:20 AM, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I also prefer (2). Isn&#39;t &quot;union&quot;, &quot;intersection&quot;, ... a &quot;Term of Art&quot;? See the guidelines under &quot;Stick to the established meaning&quot;.<br>&gt;&gt; <br>&gt;&gt; So we should stick to the mathematical naming.<br>&gt;&gt; <br>&gt;&gt; Since these terms almost always return a new instance we should have an obvious mutating version with an &quot;inPlace&quot; suffix.<br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 14.02.2016 um 22:37 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From a 10,000-ft view, I&#39;d suggest that the noun/verb rule consistently runs into a problem with mathematical terms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In general, mathematical functions don&#39;t have verb forms. You &#39;compute&#39; the reciprocal, or &#39;find&#39; the reciprocal, or &#39;take&#39; the reciprocal, you don&#39;t &#39;reciprocate&#39; or &#39;reciprocalize&#39;. Likewise for trigonometric functions, etc. Nor can you really &#39;cross produce&#39;...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So consistent is this trend that where two words might be noun/verb counterparts, like intersect/intersection and transform/transformation, common math usage treats both as acceptable nouns.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In colloquial usage, you might verb the noun, but then by definition the verb and noun become the same. Then, to generate a noun phrase/participle/etc. that looks different from the verb, you have to noun-ify the verbed noun.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Without an exception for mathematical function names, the only solution to fulfill these new Swift rules are clobbering the well-known math name or not using the math name at all. Indeed all proposed solutions so far come down to one of four options, either applied globally or only to sets for now, punting the rest down the road:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (1) Abandon the rule, making a new one (e.g.: .=)<br>&gt;&gt;&gt; (2) Make an exception to the rule for math function names<br>&gt;&gt;&gt; (3) Generate the least offensive noun-ified verbed nouns based on math function names<br>&gt;&gt;&gt; (4) Don&#39;t use math function names<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (1) is off the table, according to the core team. My vote at this point is for (2), and I see that a few others have voiced that opinion. It&#39;d be nice to get a sense from the core team if that is even a possibility. (3) has elicited a lot of discussion and visceral reactions. (4) might be workable for sets alone but surely can&#39;t be a generalized solution for all mathematical concepts to be encountered in Swift.<br>&gt;&gt;&gt; On Sun, Feb 14, 2016 at 3:14 PM Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Feb 14, 2016, at 12:48 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sun Feb 14 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 14, 2016, at 8:27 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Sat Feb 13 2016, Tyler Fleming Cloutier &lt;cloutiertyler-AT-aol.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would, personally, be very careful about discarding the mathematical<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; terms since they are so widely used and understood.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO it&#39;s better to leave them aside than to use them in “creative” ways<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that might be misleading.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Agreed. I’m all for that.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One issue is that it’s going to be hard to search for the operation I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; want considering I won’t be looking for &quot;func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; invertingMembershipOfContentsOf(other: Self) -&gt; Self”. I’m concerned<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; people are going to have to do mental gymnastics to build the map from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; math term to Swift function every time they want to look for a set<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; operation method. “func invertingMembershipOfContentsOf(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -&gt; Self” doesn’t exactly seem to fit in the commonly held Venn diagram<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mental model of set operations. You could always have a documentation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; comment that specifies the mathematical term so that people didn’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have to double check themselves every time.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That being said, if the autocomplete issue is not a concern, I’m of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the opinion that the names Ricardo proposed are short, clear, and are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not so hard to fit to my Venn diagram mental model.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, I tend to think that if there has to be this much dancing to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; name a set of fundamental operations, the guidelines aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; accomplishing their goal. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can&#39;t disagree.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s going to make it that much harder for people do design their own<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; APIs. I&#39;m having quite a time trying to conform Mattt’s Surge API to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the guidelines.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Please explain in detail.  Without details we don&#39;t know what&#39;s wrong<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the guidelines.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ah, I apologize. I’ve gone into detail about this API on the list<br>&gt;&gt;&gt;&gt;&gt;&gt; before, but I should have included the details here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here are my previous posts:<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160118/007560.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Basically the issues come down to the following. The Accelerate<br>&gt;&gt;&gt;&gt;&gt;&gt; framework typical operates in a non-mutating way. This means that my<br>&gt;&gt;&gt;&gt;&gt;&gt; API only has non mutating member functions and I should use the ed/ing<br>&gt;&gt;&gt;&gt;&gt;&gt; rule according to the guidelines to name my methods.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is very difficult for some methods. I’m able to frequently get<br>&gt;&gt;&gt;&gt;&gt;&gt; around the problem for things like “sin” or “arctan” by keeping them<br>&gt;&gt;&gt;&gt;&gt;&gt; as global functions, but I can’t do that for a number of<br>&gt;&gt;&gt;&gt;&gt;&gt; methods. Consider:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; remainder<br>&gt;&gt;&gt;&gt;&gt;&gt; dot (returns a scalar, thus there can’t be a mutating version, so<br>&gt;&gt;&gt;&gt;&gt;&gt; should I just call it dot? Guidelines don’t really comment on this)<br>&gt;&gt;&gt;&gt;&gt;&gt; mean (same as above)<br>&gt;&gt;&gt;&gt;&gt;&gt; cross<br>&gt;&gt;&gt;&gt;&gt;&gt; reciprocal<br>&gt;&gt;&gt;&gt;&gt;&gt; threshold<br>&gt;&gt;&gt;&gt;&gt;&gt; copysign<br>&gt;&gt;&gt;&gt;&gt;&gt; fastFourierTransform<br>&gt;&gt;&gt;&gt;&gt;&gt; pow (arguably the method version should be called raisedTo)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I could force all these to be global functions only, but these are not<br>&gt;&gt;&gt;&gt;&gt;&gt; as cut and dry as “sin” or “arctan”. I feel like I’d be splitting my<br>&gt;&gt;&gt;&gt;&gt;&gt; API up into two parts just based on the fact that it’s difficult to<br>&gt;&gt;&gt;&gt;&gt;&gt; use the ed/ing rule. That makes it very difficult for users to find<br>&gt;&gt;&gt;&gt;&gt;&gt; certain functions in my API.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this case there are no corresponding mutating operations because of<br>&gt;&gt;&gt;&gt;&gt;&gt; the way Accelerate works, but one could certainly imagine an API with<br>&gt;&gt;&gt;&gt;&gt;&gt; mutating counterparts. The way I read the guidelines, they seem to<br>&gt;&gt;&gt;&gt;&gt;&gt; imply I should use ed/ing regardless of whether there is a mutating<br>&gt;&gt;&gt;&gt;&gt;&gt; counterpart. I’d love to hear your thoughts on this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As long as the ones without side effects read as noun phrases and the<br>&gt;&gt;&gt;&gt;&gt; ones with side-effects read as verb phrases, you&#39;re good.  No ed/ing<br>&gt;&gt;&gt;&gt;&gt; needed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah yes, you are very right. Still what would the mutating versions of remainder, fastFourierTransform, or reciprocal be? getRemainder? applyFastFourierTransform? reciprocate? I suppose those aren’t so bad.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also suppose cross could become x.crossProduct(with: y) and copysign, x.copyingSign(of: y). Seems a little verbose, but it does the job.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 9:09 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would be okay with staying away from the mathematical terms<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; similar to what you are suggesting except that the union can still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be made more concise if you use merged / merge for the base name and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shorten the labels to a bare minimum without loosing clarity.  In<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addition, the merge can have a second parameter with a default to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; false in order to implement the symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (a.k.a. exclusive or).  Recall that symmetric difference is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; union of two sets and then removing the intersection (or members in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; common).  I think it looks perfect (concise and clear).  What does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everybody else think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (In-Place)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func insertContentsOf(other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/63b1bb8d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 14, 2016 at 08:00:00am</p></header><div class="content"><p>I could see myself supporting this naming strategy. It is semantically transparent while following the guidelines (even though I am still very sceptical about the practicability of the “be grammatical rule”). Functions like union, intersect etc. can be implemented as global generics that operate on suitable protocols. <br></p><p>Best, <br></p><p> Taras <br></p><p>&gt; On 14 Feb 2016, at 06:09, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Dave,<br>&gt; <br>&gt; I would be okay with staying away from the mathematical terms similar to what you are suggesting except that the union can still be made more concise if you use merged / merge for the base name and shorten the labels to a bare minimum without loosing clarity.  In addition, the merge can have a second parameter with a default to false in order to implement the symmetric difference (a.k.a. exclusive or).  Recall that symmetric difference is the union of two sets and then removing the intersection (or members in common).  I think it looks perfect (concise and clear).  What does everybody else think?<br>&gt; <br>&gt; Non-mutable<br>&gt; <br>&gt; let union = 			a.merged(with: b)<br>&gt; let intersection = 		a.members(in: b)<br>&gt; let difference = 		a.removingMembers(in: b)<br>&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt; <br>&gt; Mutable (In-Place)<br>&gt; <br>&gt; a.merge(with: b)		// union in-place<br>&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt; a.removeMembers(in: b)		// difference in-place<br>&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt; <br>&gt; Ricardo Parada<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt; <br>&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt; <br>&gt;&gt;   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;   mutating func insertContentsOf(other)<br>&gt;&gt; <br>&gt;&gt;   func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;   mutating func removeMembers(notIn: other)<br>&gt;&gt; <br>&gt;&gt;   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;   mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt; <br>&gt;&gt;   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;   mutating func removeMembers(in other: Self)<br>&gt;&gt; <br>&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt; above.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/0328026b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 14, 2016 at 08:00:00am</p></header><div class="content"><p>on Sat Feb 13 2016, Ricardo Parada &lt;rparada-AT-mac.com&gt; wrote:<br></p><p>&gt; Hi Dave,<br>&gt;<br>&gt; I would be okay with staying away from the mathematical terms similar<br>&gt; to what you are suggesting except that the union can still be made<br>&gt; more concise if you use merged / merge for the base name and shorten<br>&gt; the labels to a bare minimum without loosing clarity.  In addition,<br>&gt; the merge can have a second parameter with a default to false in order<br>&gt; to implement the symmetric difference (a.k.a. exclusive or).  Recall<br>&gt; that symmetric difference is the union of two sets and then removing<br>&gt; the intersection (or members in common).  I think it looks perfect<br>&gt; (concise and clear).  What does everybody else think?<br>&gt;<br>&gt; Non-mutable<br>&gt;<br>&gt; let union = 			a.merged(with: b)<br>&gt; let intersection = 		a.members(in: b)<br>&gt; let difference = 		a.removingMembers(in: b)<br>&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;<br>&gt; Mutable (In-Place)<br>&gt;<br>&gt; a.merge(with: b)		// union in-place<br>&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt; a.removeMembers(in: b)		// difference in-place<br>&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br></p><p>I love your changes to my suggestion, Ricardo!  The minor alterations I<br>would make are:<br></p><p>1. In both cases the Bool parameter ought to be called<br>   “removingMembersInCommon”<br></p><p>2. I would remove “with” from the in-place merge operation.  We&#39;re<br>   really asking the receiver to merge b into itself.  “With” gives it<br>   the sense that it might almost be mutating b.<br></p><p>&gt; Ricardo Parada<br>&gt;<br>&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt; <br>&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt; <br>&gt;&gt;   func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;   mutating func insertContentsOf(other)<br>&gt;&gt; <br>&gt;&gt;   func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;   mutating func removeMembers(notIn: other)<br>&gt;&gt; <br>&gt;&gt;   func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;   mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt; <br>&gt;&gt;   func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;   mutating func removeMembers(in other: Self)<br>&gt;&gt; <br>&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt; above.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February 14, 2016 at 05:00:00pm</p></header><div class="content"><p>I don’t really agree with Dave’s comments about removing ‘with&#39;, but here’s one of mine – making the non-mutating difference an override of intersection because it sounds clearer to me and is consistent with the mutable versions being overrides:<br></p><p>Non-mutable<br></p><p>let union = a.merged(with: b)<br>let intersection = a.members(in: b)<br>let difference = a.members(notIn: b)<br>let symmetricDifference = a.merged(with: b, removingMembersInCommon: true)<br></p><p>Mutable (In-Place)<br></p><p>a.merge(with: b) // union in-place<br>a.removeMembers(notIn: b) // intersect in-place<br>a.removeMembers(in: b)	// difference in-place<br>a.merge(with: b, removingMembersInCommon: true) // symmetric difference in-place<br></p><p>&gt; On 14 Feb 2016, at 17:10, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Feb 13 2016, Ricardo Parada &lt;rparada-AT-mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; Hi Dave,<br>&gt;&gt; <br>&gt;&gt; I would be okay with staying away from the mathematical terms similar<br>&gt;&gt; to what you are suggesting except that the union can still be made<br>&gt;&gt; more concise if you use merged / merge for the base name and shorten<br>&gt;&gt; the labels to a bare minimum without loosing clarity.  In addition,<br>&gt;&gt; the merge can have a second parameter with a default to false in order<br>&gt;&gt; to implement the symmetric difference (a.k.a. exclusive or).  Recall<br>&gt;&gt; that symmetric difference is the union of two sets and then removing<br>&gt;&gt; the intersection (or members in common).  I think it looks perfect<br>&gt;&gt; (concise and clear).  What does everybody else think?<br>&gt;&gt; <br>&gt;&gt; Non-mutable<br>&gt;&gt; <br>&gt;&gt; let union = 			a.merged(with: b)<br>&gt;&gt; let intersection = 		a.members(in: b)<br>&gt;&gt; let difference = 		a.removingMembers(in: b)<br>&gt;&gt; let symmetricDifference = 	a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt; <br>&gt;&gt; Mutable (In-Place)<br>&gt;&gt; <br>&gt;&gt; a.merge(with: b)		// union in-place<br>&gt;&gt; a.removeMembers(notIn: b)	// intersect in-place<br>&gt;&gt; a.removeMembers(in: b)		// difference in-place<br>&gt;&gt; a.merge(with: b, removeMembersInCommon: true)	// symmetric difference in-place<br>&gt; <br>&gt; I love your changes to my suggestion, Ricardo!  The minor alterations I<br>&gt; would make are:<br>&gt; <br>&gt; 1. In both cases the Bool parameter ought to be called<br>&gt;   “removingMembersInCommon”<br>&gt; <br>&gt; 2. I would remove “with” from the in-place merge operation.  We&#39;re<br>&gt;   really asking the receiver to merge b into itself.  “With” gives it<br>&gt;   the sense that it might almost be mutating b.<br>&gt; <br>&gt;&gt; Ricardo Parada<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;  mutating func insertContentsOf(other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;  mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;  mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;  mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt; above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/5425507e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 14, 2016 at 04:00:00pm</p></header><div class="content"><p>You are right. I agree with your feedback. <br></p><p>Ricardo Parada<br></p><p>&gt; On Feb 14, 2016, at 11:10 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Sat Feb 13 2016, Ricardo Parada &lt;rparada-AT-mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dave,<br>&gt;&gt; <br>&gt;&gt; I would be okay with staying away from the mathematical terms similar<br>&gt;&gt; to what you are suggesting except that the union can still be made<br>&gt;&gt; more concise if you use merged / merge for the base name and shorten<br>&gt;&gt; the labels to a bare minimum without loosing clarity.  In addition,<br>&gt;&gt; the merge can have a second parameter with a default to false in order<br>&gt;&gt; to implement the symmetric difference (a.k.a. exclusive or).  Recall<br>&gt;&gt; that symmetric difference is the union of two sets and then removing<br>&gt;&gt; the intersection (or members in common).  I think it looks perfect<br>&gt;&gt; (concise and clear).  What does everybody else think?<br>&gt;&gt; <br>&gt;&gt; Non-mutable<br>&gt;&gt; <br>&gt;&gt; let union =            a.merged(with: b)<br>&gt;&gt; let intersection =        a.members(in: b)<br>&gt;&gt; let difference =        a.removingMembers(in: b)<br>&gt;&gt; let symmetricDifference =    a.merged(with: b, removingMembersInCommon: true)<br>&gt;&gt; <br>&gt;&gt; Mutable (In-Place)<br>&gt;&gt; <br>&gt;&gt; a.merge(with: b)        // union in-place<br>&gt;&gt; a.removeMembers(notIn: b)    // intersect in-place<br>&gt;&gt; a.removeMembers(in: b)        // difference in-place<br>&gt;&gt; a.merge(with: b, removeMembersInCommon: true)    // symmetric difference in-place<br>&gt; <br>&gt; I love your changes to my suggestion, Ricardo!  The minor alterations I<br>&gt; would make are:<br>&gt; <br>&gt; 1. In both cases the Bool parameter ought to be called<br>&gt;   “removingMembersInCommon”<br>&gt; <br>&gt; 2. I would remove “with” from the in-place merge operation.  We&#39;re<br>&gt;   really asking the receiver to merge b into itself.  “With” gives it<br>&gt;   the sense that it might almost be mutating b.<br>&gt; <br>&gt;&gt; Ricardo Parada<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 1:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Feb 12 2016, Ricardo Parada &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can’t make up my mind.  Let me propose two different alternatives<br>&gt;&gt;&gt;&gt; that I’m not sure if they have been considered:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVE 1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable (noun-based)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func union(other: Self) -&gt; Self        Assumes union is a noun, i.e. not a verb<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func intersection(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func subtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func symmetricSubtraction(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable (verb-based)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func unite(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func subtract(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func symmetricSubtract(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this alternative we keep the union name which I assume is<br>&gt;&gt;&gt;&gt; popular.  However, one has to accept unite as a verb (for the mutable<br>&gt;&gt;&gt;&gt; version) as I wanted all the mutable methods use verbs for<br>&gt;&gt;&gt;&gt; consistency.  I think unite is acceptable because it can be found in<br>&gt;&gt;&gt;&gt; the dictionary and it is a verb.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Notice that all the non-mutable methods use nouns: union,<br>&gt;&gt;&gt;&gt; intersection, subtraction and symmetricSubtraction.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand some may oppose to symmetricSubtraction saying that<br>&gt;&gt;&gt;&gt; symmetricSubraction is not as common as &quot;exclusive or&quot;.  However,<br>&gt;&gt;&gt;&gt; using symmetricSubtraction is consistent with subtraction and it hints<br>&gt;&gt;&gt;&gt; to a variation of the “subtraction&quot; operation.  We will get used to it<br>&gt;&gt;&gt;&gt; quickly / easily.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVE 2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Non-mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func union(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func adding(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func intersect(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func intersecting(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func exclusiveOr(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func exclusiveOring(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  func subtract(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; +  func removing(other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mutable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func unionInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func add(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func intersectInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func intersect(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func exclusiveOrInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func exclusiveOr(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -  mutating func subtractInPlace(other: Self)<br>&gt;&gt;&gt;&gt; +  mutating func remove(other: Self)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments: This alternative gives up on union in favor or add.  Many<br>&gt;&gt;&gt;&gt; may not like this, that is why I have it as the second alternative.<br>&gt;&gt;&gt;&gt; It brings back exclusiveOr and treats it as a verb.  Some may argue<br>&gt;&gt;&gt;&gt; that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we are going to force Set fit the naming guidelines, I would prefer<br>&gt;&gt;&gt; to stay away from the mathematical terms altogether.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func insertingContentsOf(other: Self) -&gt; Self                 // union<br>&gt;&gt;&gt;  mutating func insertContentsOf(other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func members(in other: Self) -&gt; Self                           // intersection<br>&gt;&gt;&gt;  mutating func removeMembers(notIn: other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func removingMembersAndAddingNonMembers(in other: Self) -&gt; Self // symmetric difference<br>&gt;&gt;&gt;  mutating func removeMembersAndAddingNonMembers(in other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func removingMembers(in other: Self) -&gt; Self                    // subtract<br>&gt;&gt;&gt;  mutating func removeMembers(in other: Self)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it would help with clarity, we could replace &quot;in&quot; with &quot;foundIn&quot;<br>&gt;&gt;&gt; above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
