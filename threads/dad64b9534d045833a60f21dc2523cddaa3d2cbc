<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23bb59b802aac41afdf8ffffae1040d5?s=50"></div><header><strong>Notes from Swift core team 2016-03-23 design discussion</strong> from <string>Alex Martini</string> &lt;amartini at apple.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>To help keep proposals moving forward, the Swift core team has set aside some time specifically for design discussions of upcoming proposals.  Below are some rough notes from the yesterday&#39;s discussion.<br></p><p>(This week, I want to point out that my notes for PR 219, the first discussion topic, are especially rough.)<br></p><p>These are informal comments, intended to guide the proposals in directions that draw constructive feedback. You are welcome to ignore the feedback, agree with it, or disagree with it.  As always, the formal decision doesn&#39;t happen until after the review period ends.<br></p><p><br></p><p><br>Make pointer nullability explicit using Optional &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-03-23.html#make-pointer-nullability-explicit-using-optional&gt;<br>https://github.com/apple/swift-evolution/pull/219 &lt;https://github.com/apple/swift-evolution/pull/219&gt;<br>Biggest open issue is what to do with UnsafeBufferPointer which has a base address and a count of the number of elements at that address. The most common use is to do fast things with an array. The problem is when you have an empty array.<br></p><p>We have a statically initialized empty array, so this doesn’t apply to array. But slices and Cocoa arrays can do it.<br></p><p>Half of the use cases are subscripting off of the buffer, so they don’t actually use the base address. They can’t actually subscript an empty array, but it’s not a syntax error — the loop is run zero times, so it doesn’t matter. The other half pass the pointers down to a C API that takes an address and count.<br></p><p>Someone might expect that the base address doesn’t change when something is initialized.<br></p><p>We can’t easily use the zero pointer because SIL already uses it for nil. But there are issues with using the same representation as C to avoid bridging costs.<br></p><p>We’re mapping two things in C onto one thing in Swift. In C, the buffer pointer would be __nullable long * and the length is ulong.<br></p><p>Given everything else in the system, it’s more like pointer. We didn’t call it a buffer because that tends to imply ownership.<br></p><p>Sketching out the state space:<br></p><p>Pointer	Length	Static type<br>null	0	UBP?	 <br>valid	&gt;= 0	UBP	 <br>valid	&lt; 0	X	 <br>vull	!= 0	???	 <br>This issue would go away if we got rid of the base address on UnsafeBufferPointer, but that would get rid of a number of valid C operations like calling memcopy.<br></p><p>It seems like withUnsafeBufferPointer should never produce nil. With that in mind, why should UnsafeBufferPointer need to?<br></p><p>We do need a properly-aligned “valid” invalid pointer. LLVM makes assumptions about things being aligned.<br></p><p>Dominant feedback on the list has been for people want something that round trips cleanly. Making the base address non-optional adds overhead and removes the ability to round trip.<br></p><p>It’s unfortunate that we don’t have a way to represent in the type system a buffer pointer that isn’t nullable, from within withUnsafeBufferPointer which wouldn’t even call its closure if the buffer has a null base address.<br></p><p>Allow Swift types to provide custom Objective-C representations &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-03-23.html#allow-swift-types-to-provide-custom-objective-c-representations&gt;<br>https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br>The associated type could be AnyObject rather than NSObject. The use case for a non-subclass of NSObject is very narrow, but it’s not a needed restriction.<br></p><p>The unconditionalyBridgeFromObjectiveC function can probably go away. Calling initializers from the downcasting infrastructure is horrible. If we need a function, they<br></p><p>This doesn’t break the ability of the optimizer to reason about what a dynamic cast can do. We require that the bridgeable conformance must be in the same module as where the type is defined, and we have a white list of things that don’t follow that. Ok... but do we want people to expand casting this way? If we say no, we should take it away from array and string and dictionary too.<br></p><p>You shouldn’t need implicit conversions — the use case is very narrow, and we would rather have things use explicit conversions. The APIs come in with the right type; the implementation of the bridged type has to do conversion, but its clients don’t have to see that. From the Swift point of view, there won’t be any APIs that take the reference type.<br></p><p>Implicit conversions. In this proposals, you don’t get implicit conversions. Have a separate discussion about whether we can get rid of the four types that have implicit conversion. We see the existing ones as deeply problematic.<br></p><p>Dynamic casts. For example, AnyObject to a bridged value type. The whole reason for the dynamic cast infrastructure is to make the reference types irrelevant. Should this be using cast syntax or should we have a different type of function? It’s hard to describe what as does. It’s magic because you are casting AnyObject to a struct — calling it AnyObject doesn’t make a lot of sense.<br></p><p>If we have reference counted existentials, we could merge Any and AnyObject.<br></p><p>Resilience concern: you can not add this protocol after the type has been published.<br></p><p>SE-0054: Abolish ImplicitlyUnwrappedOptional type &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-03-23.html#se-0054-abolish-implicitlyunwrappedoptional-type&gt;<br>https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md&gt;<br>IUO as a type is bad; it should become conceptually a decl attribute instead. If we import things that can be nil, their formal type is Optional but we can add an attribute that says when you form a rvalue to that thing, you get implicit unwrapping. The typechecker inserts a diamond that lets you convert it to T? or T. Meaning T! never enters the type system — although it does still appear in user-facing decl descriptions.<br></p><p>For example:<br></p><p>let y = P       // y is of type T?<br>let y: T! = P   // y is of type T!<br>let x = [P]     // x is of type [T?]<br>One issue is that we don’t have a good way to mark a function that takes a block pointer, when that block has not been audited.<br></p><p>void foo(C *(*fp)(C* x)) {}<br>func foo (fp: ((C?) -&gt; C?)!) {}<br>func foo (@IUO fp: (C?) -&gt; C?) {}<br>That is a regression from our current behavior. It would have to be a type attribute because they can chain. This will show up in places where you return (and then call) a block.<br></p><p>For example, you can no longer express the type let y: (T?, U!).<br></p><p>We don’t need to have a diamond for currying, only for rvalue access and application.<br></p><p>x.foo()         // T!<br>Type.foo(x)()   // T? return type<br>A source breaking change here is that if extract something into an intermediate variable could change type in a very important way. That’s already somewhat true because of overload resolution, but this makes it much more visible.<br></p><p>Does this gloss over the audit problem? We’ve gotten most of the really important stuff audited, but there are lots of unaudited things such as most of the SDK on Linux. This means we don’t propagate the IUO stuff up, meaning we end up with more explicit forces in code when you are using unaudited API.<br></p><p>Deferred initialization is still a good argument for why we need the feature. This approach locks down propagation and makes IUO more predictable: if the expression can typecheck as optional it will, otherwise it will force.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/dad62cbc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Notes from Swift core team 2016-03-23 design discussion</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 10:26 AM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote<br>&gt; Allow Swift types to provide custom Objective-C representations &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-03-23.html#allow-swift-types-to-provide-custom-objective-c-representations&gt;<br>&gt; https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br>&gt; The associated type could be AnyObject rather than NSObject. The use case for a non-subclass of NSObject is very narrow, but it’s not a needed restriction.<br>&gt; <br>&gt; The unconditionalyBridgeFromObjectiveC function can probably go away. Calling initializers from the downcasting infrastructure is horrible. If we need a function, they<br>&gt; <br>Was there more to this line of thought? It looks like it got cut off.<br></p><p>I would like to unify this to either have the initializers or have the static functions but not both, but I don’t know which is preferred from an implementation perspective. The initializers feel more “Swifty” but moving back to static functions is perfectly workable.<br></p><p>&gt; This doesn’t break the ability of the optimizer to reason about what a dynamic cast can do. We require that the bridgeable conformance must be in the same module as where the type is defined, and we have a white list of things that don’t follow that. Ok... but do we want people to expand casting this way? If we say no, we should take it away from array and string and dictionary too.<br>&gt; <br>&gt; You shouldn’t need implicit conversions — the use case is very narrow, and we would rather have things use explicit conversions. The APIs come in with the right type; the implementation of the bridged type has to do conversion, but its clients don’t have to see that. From the Swift point of view, there won’t be any APIs that take the reference type.<br>&gt; <br>&gt; Implicit conversions. In this proposals, you don’t get implicit conversions. Have a separate discussion about whether we can get rid of the four types that have implicit conversion. We see the existing ones as deeply problematic.<br>&gt; <br>The casting was a late addition to allow the user to work around situations where the ObjC API is deficient and to keep the behavior consistent with how other types are bridged. It could be removed if desired but I agree that it should probably be removed from the existing types as well in that case.<br></p><p>Removing it would unify behavior: conversion happens through initializers, casting through as. That means the example would be more like “let x = SwiftType(SomeObjCType)”. Strings become “let x = String(anNSString)&quot;<br></p><p><br>What is the team’s general approach to a situation like this? I feel like the casting discussion is a separate one but it does have an impact on the static function vs initializer discussion. <br></p><p>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/e676eac8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Notes from Swift core team 2016-03-23 design discussion</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 11:57 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 10:26 AM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote<br>&gt;&gt; Allow Swift types to provide custom Objective-C representations &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-03-23.html#allow-swift-types-to-provide-custom-objective-c-representations&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br>&gt;&gt; The associated type could be AnyObject rather than NSObject. The use case for a non-subclass of NSObject is very narrow, but it’s not a needed restriction.<br>&gt;&gt; <br>&gt;&gt; The unconditionalyBridgeFromObjectiveC function can probably go away. Calling initializers from the downcasting infrastructure is horrible. If we need a function, they<br>&gt;&gt; <br>&gt; Was there more to this line of thought? It looks like it got cut off.<br>&gt; <br>&gt; I would like to unify this to either have the initializers or have the static functions but not both, but I don’t know which is preferred from an implementation perspective. The initializers feel more “Swifty” but moving back to static functions is perfectly workable.<br></p><p>The preference was to just have the initializers, since that is the preferred way to express conversions.<br></p><p>&gt;&gt; Implicit conversions. In this proposals, you don’t get implicit conversions. Have a separate discussion about whether we can get rid of the four types that have implicit conversion. We see the existing ones as deeply problematic.<br>&gt;&gt; <br>&gt; The casting was a late addition to allow the user to work around situations where the ObjC API is deficient and to keep the behavior consistent with how other types are bridged. It could be removed if desired but I agree that it should probably be removed from the existing types as well in that case.<br>&gt; <br>&gt; Removing it would unify behavior: conversion happens through initializers, casting through as. That means the example would be more like “let x = SwiftType(SomeObjCType)”. Strings become “let x = String(anNSString)”<br></p><p>Many of us would prefer to reduce the implicit conversions we have today in various ways (e.g. I’m a fan of disabling T -&gt; T? promotion in operator argument contexts, which would solve a number of weird ?? issues).  The existing implicit bridging conversions fall into the same category: it isn’t clear if we can eliminate them, but if we could, that would be great for predictability and for type checker performance.<br></p><p>Upshot of this is that there doesn’t seem to be a reason for this new feature to add new implicit conversions: doing an explicit conversion with “as” seems fine.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/a9a06c33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Notes from Swift core team 2016-03-23 design discussion</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 1:26 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 11:57 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 24, 2016, at 10:26 AM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote<br>&gt;&gt;&gt; Allow Swift types to provide custom Objective-C representations &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-03-23.html#allow-swift-types-to-provide-custom-objective-c-representations&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br>&gt;&gt;&gt; The associated type could be AnyObject rather than NSObject. The use case for a non-subclass of NSObject is very narrow, but it’s not a needed restriction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The unconditionalyBridgeFromObjectiveC function can probably go away. Calling initializers from the downcasting infrastructure is horrible. If we need a function, they<br>&gt;&gt;&gt; <br>&gt;&gt; Was there more to this line of thought? It looks like it got cut off.<br>&gt;&gt; <br>&gt;&gt; I would like to unify this to either have the initializers or have the static functions but not both, but I don’t know which is preferred from an implementation perspective. The initializers feel more “Swifty” but moving back to static functions is perfectly workable.<br>&gt; <br>&gt; The preference was to just have the initializers, since that is the preferred way to express conversions.<br></p><p><br>Sounds good to me; I updated the proposal to use initializers.<br></p><p><br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/d8311db6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23bb59b802aac41afdf8ffffae1040d5?s=50"></div><header><strong>Notes from Swift core team 2016-03-23 design discussion</strong> from <string>Alex Martini</string> &lt;amartini at apple.com&gt;<p>March 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 11:57 AM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 10:26 AM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote<br>&gt;&gt; Allow Swift types to provide custom Objective-C representations &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/2016-03-23.html#allow-swift-types-to-provide-custom-objective-c-representations&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br>&gt;&gt; The associated type could be AnyObject rather than NSObject. The use case for a non-subclass of NSObject is very narrow, but it’s not a needed restriction.<br>&gt;&gt; <br>&gt;&gt; The unconditionalyBridgeFromObjectiveC function can probably go away. Calling initializers from the downcasting infrastructure is horrible. If we need a function, they<br>&gt;&gt; <br>&gt; Was there more to this line of thought? It looks like it got cut off.<br></p><p>Sorry, I didn&#39;t have anything else here.  It looks like I didn&#39;t finish the sentence while typing during the meeting.<br></p><p>If I remember right, the thought was that we can make a function (or maybe a closure) that calls the initializer if the surrounding code needs a function.<br></p><p>— Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/26d88ce5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>Notes from Swift core team 2016-03-23 design discussion</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>March 24, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Alex (and all other note-takers),<br></p><p>these notes are helpful and really appreciated. Thanks for making them available. :)<br></p><p><br>	Daniel.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
