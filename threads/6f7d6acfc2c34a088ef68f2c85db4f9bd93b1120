<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2773fb278535f8d2f0c193800a3b8e09?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>jalkut at red-sweater.com</string> &lt;jalkut at red-sweater.com&gt;<p>December  4, 2015 at 05:00:00pm</p></header><div class="content"><p>In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br></p><p>My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br></p><p>The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br></p><p>&quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br></p><p>To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br></p><p>I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br></p><p>In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br></p><p>Thoughts?<br></p><p>Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br></p><p>True fact: On all of gist.github.com, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>case .Enum1, .Enum2:<br>expressed as <br>case .Enum1: fallthrough<br>case .Enum2:<br></p><p>And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br></p><p><br></p><p><br>&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:<br>&gt; <br>&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt; <br>&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt; <br>&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt; <br>&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt; <br>&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt; <br>&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt; <br>&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Daniel<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/588f3fe1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br></p><p>&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt; <br>&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt; case .Enum1, .Enum2:<br>&gt; expressed as <br>&gt; case .Enum1: fallthrough<br>&gt; case .Enum2:<br>&gt; <br>&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt; <br>&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt; <br>&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt; <br>&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt; <br>&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt; <br>&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt; <br>&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; Daniel<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/554bca66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2af8daf170a3ed693e577a9471ea1f10?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Ray Fix</string> &lt;rayfix at gmail.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 2:16 PM, Greg Titus &lt;greg at omnigroup.com&gt; wrote:<br>&gt; <br>&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br></p><p>Yes.  You beat me to it but I agree.  I think having fallthrough could be an important performance optimization as refactoring would either result in the overhead of a function call or replicated code.   I would also prefer to keep it in the toolbox.<br></p><p>Ray Fix<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/6cef076a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2af8daf170a3ed693e577a9471ea1f10?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Ray Fix</string> &lt;rayfix at gmail.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 2:20 PM, Ray Fix &lt;rayfix at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 2:16 PM, Greg Titus &lt;greg at omnigroup.com &lt;mailto:greg at omnigroup.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt; <br>&gt; Yes.  You beat me to it but I agree.  I think having fallthrough could be an important performance optimization as refactoring would either result in the overhead of a function call or replicated code.   I would also prefer to keep it in the toolbox.<br>&gt; <br></p><p>I should have mentioned that 99% of the time the overhead of a function call doesn’t matter, but when it does… it is great to have.<br></p><p>Ray Fix<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8a4fcf9f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>I courteously remove my objections.<br></p><p>-- E<br></p><p><br>&gt; On Dec 4, 2015, at 3:25 PM, Ray Fix &lt;rayfix at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 2:20 PM, Ray Fix &lt;rayfix at gmail.com &lt;mailto:rayfix at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 2:16 PM, Greg Titus &lt;greg at omnigroup.com &lt;mailto:greg at omnigroup.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt; <br>&gt;&gt; Yes.  You beat me to it but I agree.  I think having fallthrough could be an important performance optimization as refactoring would either result in the overhead of a function call or replicated code.   I would also prefer to keep it in the toolbox.<br>&gt;&gt; <br>&gt; <br>&gt; I should have mentioned that 99% of the time the overhead of a function call doesn’t matter, but when it does… it is great to have.<br>&gt; <br>&gt; Ray Fix<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/5929967c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>It&#39;s  not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that<br>C switch statements don&#39;t actually introduce a new scope, and so it<br>overlaps a switch with a do-while loop. This lets it only test the<br>number of bytes once, to jump into the middle of the loop, and then it<br>switches over to a while loop that decrements a counter every 8<br>instructions. Basically, it&#39;s a trick for manual loop unrolling that<br>deals with non-multiple-of-8 counts efficiently.<br></p><p>Steve&#39;s code is also an example of manual loop unrolling that deals with<br>non-multiple-of-8 counts, but it has calculate the number of bytes on<br>every iteration instead of once. It&#39;s a good example of one of the uses<br>of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use<br>Duff&#39;s Device in Swift.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt; Streza’s source code is an example of Duff’s Device, which is a big<br>&gt; place where switch fallthrough is arguably the cleanest way to do<br>&gt; things and the reason why I’d personally prefer to keep it as part of<br>&gt; the language.<br>&gt;<br>&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself<br>&gt;&gt; re-factoring to stop using it.<br>&gt;&gt;<br>&gt;&gt; *True fact*: On all of gist.github.com[1], there are only 22 gist<br>&gt;&gt; results for &quot;fallthrough language:swift&quot;. Half of those are people<br>&gt;&gt; just testing out the feature. Most of the remaining ones are just<br>&gt;&gt; complex cases: *case .Enum1, .Enum2:* expressed as *case .Enum1:<br>&gt;&gt; fallthrough* *case .Enum2:*<br>&gt;&gt;<br>&gt;&gt; And then there&#39;s streza:<br>&gt;&gt; https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I&#39;m pretty<br>&gt;&gt; sure that ponies were harmed in the production of whatever that last<br>&gt;&gt; bit is.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style<br>&gt;&gt;&gt; artifacts, what do folks think about the possibility of removing the<br>&gt;&gt;&gt; &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My understanding is this keyword is only used for the archaic<br>&gt;&gt;&gt; seeming purpose of perpetuating C-style fallthrough from one switch<br>&gt;&gt;&gt; statement to the subsequent one. The documentation hedges the use of<br>&gt;&gt;&gt; this keyword in forbidding terms that make it clear its use is not<br>&gt;&gt;&gt; encouraged. The presence of the keyword, while an improvement over<br>&gt;&gt;&gt; C’s implicit fallthrough, is a mark of inelegance on an otherwise<br>&gt;&gt;&gt; well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat<br>&gt;&gt;&gt; in the documentation:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the<br>&gt;&gt;&gt; switch case that it causes execution to fall into. The fallthrough<br>&gt;&gt;&gt; keyword simply causes code execution to move directly to the<br>&gt;&gt;&gt; statements inside the next case (or default case) block, as in C’s<br>&gt;&gt;&gt; standard switch statement behavior.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough,<br>&gt;&gt;&gt; both in C or Swift: coded that is clearly labeled with deliberate<br>&gt;&gt;&gt; conditions can nonetheless be reached.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got<br>&gt;&gt;&gt; seemed to be from people who either did not know about Swift’s<br>&gt;&gt;&gt; support for comma-separated case statements, or harbored an<br>&gt;&gt;&gt; aesthetic preference for clustering such cases together with<br>&gt;&gt;&gt; fallthrough statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for<br>&gt;&gt;&gt; supporting intentional fallthrough in Swift, removing the keyword<br>&gt;&gt;&gt; would be a move in the direction of minimizing the language’s<br>&gt;&gt;&gt; complexity while also discouraging poor coding style in switch<br>&gt;&gt;&gt; statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. http://gist.github.com/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/b34cc62d/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br></p><p>To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br></p><p>But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br></p><p>John.<br></p><p>&gt;  <br>&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/8ccfb740/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015, at 02:42 PM, John McCall wrote:<br>&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote: It&#39;s<br>&gt;&gt; not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C<br>&gt;&gt; switch statements don&#39;t actually introduce a new scope, and so it<br>&gt;&gt; overlaps a switch with a do-while loop. This lets it only test the<br>&gt;&gt; number of bytes once, to jump into the middle of the loop, and then<br>&gt;&gt; it switches over to a while loop that decrements a counter every 8<br>&gt;&gt; instructions. Basically, it&#39;s a trick for manual loop unrolling that<br>&gt;&gt; deals with non-multiple-of-8 counts efficiently.<br>&gt;<br>&gt; To be pedantic, C switch statements do introduce a new scope.  What<br>&gt; Duff’s Device exploits is that switch is allowed to jump into<br>&gt; (almost) arbitrary scopes, and cases can appear anywhere recursively<br>&gt; inside a switch.<br></p><p>Oh you&#39;re right, what I meant to say was that case statements don&#39;t<br>introduce a new scope. The do-while loop is contained entirely within<br>the scope of the switch itself, and the case statements act like goto<br>labels so it can jump into the scope of the do-while.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/b0d796bb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9c72f152ed52fbbdb5f174ad2e1e7b0a?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>John Calsbeek</string> &lt;john.calsbeek+lists at gmail.com&gt;<p>December  4, 2015 at 11:00:00pm</p></header><div class="content"><p>`fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br></p><p>It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br></p><p>One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br></p><p>switch op {<br>case LOAD_INDIRECT:<br>   in0 = memory[in1]<br>   fallthrough<br>case LOAD:<br>   out0 = memory[in0]<br>//...<br>}<br></p><p>I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br></p><p>Cheers,<br>John<br></p><p>&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt; <br>&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt; <br>&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/f96726e9/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt; <br>&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br></p><p>Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br></p><p>On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br></p><p>John.<br></p><p>&gt; <br>&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt; <br>&gt; switch op {<br>&gt; case LOAD_INDIRECT:<br>&gt;    in0 = memory[in1]<br>&gt;    fallthrough<br>&gt; case LOAD:<br>&gt;    out0 = memory[in0]<br>&gt; //...<br>&gt; }<br>&gt; <br>&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt; <br>&gt; Cheers,<br>&gt; John<br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt; <br>&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt; <br>&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/969f0364/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt; <br>&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt; <br>&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt; <br>&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br></p><p>Oh, I see that Joe already brought this up, spelled “reswitch”.<br></p><p>John.<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt; <br>&gt;&gt; switch op {<br>&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;    fallthrough<br>&gt;&gt; case LOAD:<br>&gt;&gt;    out0 = memory[in0]<br>&gt;&gt; //...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; John<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/d6649022/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December  5, 2015 at 06:00:00pm</p></header><div class="content"><p>Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br></p><p>I very much like specifying what case to fall through into, no matter how we spell it.<br></p><p>- Steve<br></p><p>&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt; <br>&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt; <br>&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt; <br>&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; John<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/9f7f5c97/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>December  6, 2015 at 10:00:00am</p></header><div class="content"><p>+1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br></p><p>If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br></p><p>Sent from my iPad<br></p><p>&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt; <br>&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt; <br>&gt; - Steve<br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt; <br>&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/e23f6cd5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December  6, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt;<br>&gt; <br>&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br></p><p>Detecting this in general is solving the halting problem, so such a check isn&#39;t actually feasible.  One could warn when termination can&#39;t be proved, but making it a hard error would remove much of the usefulness for implementing interpreters.<br></p><p>- Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>December  6, 2015 at 06:00:00pm</p></header><div class="content"><p>Well, you caught me, I was thinking of a static analyzer check but for whatever reason my hands typed compiler check. Go figure.<br></p><p>In the static analyzer this check can be feasible? I know is not a memory leak, but at least he can see if the code flow inside a switch with reswitch statements will continue to go around on the same cases.<br>But this is only my wild guess, without a clue on what a static analyzer can do :)<br></p><p>- Jacopo<br></p><p>&gt; On 06 Dec 2015, at 18:16, Steve Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt;<br>&gt;&gt; <br>&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt; <br>&gt; Detecting this in general is solving the halting problem, so such a check isn&#39;t actually feasible.  One could warn when termination can&#39;t be proved, but making it a hard error would remove much of the usefulness for implementing interpreters.<br>&gt; <br>&gt; - Steve<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br></p><p>Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br></p><p>I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br></p><p>Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br></p><p>https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br></p><p>This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br></p><p>Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br></p><p>Thanks,<br>-Colin<br></p><p>&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt; <br>&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt; <br>&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt; <br>&gt;&gt; - Steve<br>&gt;&gt; <br>&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c64c1b4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>December  6, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi Colin,<br></p><p>the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br></p><p>The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>So something like this:<br></p><p>switch (enum) {<br>	case .One:<br>		// do something<br>		reswitch .Two<br>	case .Two:<br>		// do something else<br>	default:<br>		// and so one<br>}<br></p><p>This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br></p><p>switch (enum) {<br>	case .One:<br>		// do something<br>		reswitch .Two<br>	case .OneAndAHalf<br>		// maybe this change is not made by you but by a messed up merge<br>	case .Two:<br>		// do something else<br>	default:<br>		// and so one<br>}<br></p><p>In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br></p><p>Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br></p><p>switch (enum) {<br>	case .One:<br>		// do something<br>		reswitch .Two<br>	case .OneAndAHalf<br>		// so something that you don’t want to do for .One<br>		reswitch .Two<br>	case .Two:<br>		// do something else that you may want to do for .One and .Two<br>	default:<br>		// and so one<br>}<br></p><p>I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br></p><p>The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br></p><p>switch (enum) {<br>	case .One:<br>		// do something<br>		x = 0;<br>		reswitch .Two<br>	case .OneAndAHalf<br>		// so something that you don’t want to do for .One<br>		reswitch .Two<br>	case .Two where x &gt; 0:<br>		// do something else that you may want to do for .One and .Two<br>		element = array[x]<br>	default:<br>		// and so one<br>}<br>(I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br></p><p>In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br></p><p>Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br></p><p>I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br></p><p>- Jacopo<br>Sent from my iPad<br></p><p>On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt; <br>&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt; <br>&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt; <br>&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt; <br>&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt; <br>&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt; <br>&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt; <br>&gt; Thanks,<br>&gt; -Colin<br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt; <br>&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8883dc87/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>To cope with the pattern matching cases, I would say that reswitch either has to:<br>1. Be limited specifically to a switch without pattern matching or enum values with associated data (such as Optional.Some). This would likely need to go beyond the limitations on fall through, which only limit value-binding patterns<br>2. Use instead of trying to treat the value of a reswitch as a label, treat it as a expression to re-execute the switch statement over:<br></p><p>switch(optionalThing) {<br>case .None:<br>	print(“assuming default value”)	<br>	reswitch “default”<br>case .Some(let str):<br>	print(“processing value \(str)”);<br>}<br></p><p>This does however have non-intuitive behavior - when the second case statement is hit, “str&quot; is no longer equal to &quot;optionalThing!”. For that reason, one might find it clearer to require an explicit reassignment, effectively treating the switch as a loop: <br></p><p>switch(optionalThing) {<br>case .None:<br>	print(“assuming default value”)	<br>	optionalThing = “default”<br>	reswitch<br>case .Some(let str):<br>	print(“processing value \(str)”);<br>}<br></p><p>The existing “continue” keyword seems a poor choice to recycle for this purpose; “repeat” or “retry” might be more appropriate than “reswitch&quot;<br></p><p>-DW<br></p><p>&gt; On Dec 6, 2015, at 1:06 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;  Hi Colin,<br>&gt; <br>&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt; <br>&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt; So something like this:<br>&gt; <br>&gt; switch (enum) {<br>&gt; 	case .One:<br>&gt; 		// do something<br>&gt; 		reswitch .Two<br>&gt; 	case .Two:<br>&gt; 		// do something else<br>&gt; 	default:<br>&gt; 		// and so one<br>&gt; }<br>&gt; <br>&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt; <br>&gt; switch (enum) {<br>&gt; 	case .One:<br>&gt; 		// do something<br>&gt; 		reswitch .Two<br>&gt; 	case .OneAndAHalf<br>&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt; 	case .Two:<br>&gt; 		// do something else<br>&gt; 	default:<br>&gt; 		// and so one<br>&gt; }<br>&gt; <br>&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt; <br>&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt; <br>&gt; switch (enum) {<br>&gt; 	case .One:<br>&gt; 		// do something<br>&gt; 		reswitch .Two<br>&gt; 	case .OneAndAHalf<br>&gt; 		// so something that you don’t want to do for .One<br>&gt; 		reswitch .Two<br>&gt; 	case .Two:<br>&gt; 		// do something else that you may want to do for .One and .Two<br>&gt; 	default:<br>&gt; 		// and so one<br>&gt; }<br>&gt; <br>&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt; <br>&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt; <br>&gt; switch (enum) {<br>&gt; 	case .One:<br>&gt; 		// do something<br>&gt; 		x = 0;<br>&gt; 		reswitch .Two<br>&gt; 	case .OneAndAHalf<br>&gt; 		// so something that you don’t want to do for .One<br>&gt; 		reswitch .Two<br>&gt; 	case .Two where x &gt; 0:<br>&gt; 		// do something else that you may want to do for .One and .Two<br>&gt; 		element = array[x]<br>&gt; 	default:<br>&gt; 		// and so one<br>&gt; }<br>&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt; <br>&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt; <br>&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt; <br>&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt; <br>&gt; - Jacopo<br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt; <br>&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt; <br>&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt; <br>&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt; <br>&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt; <br>&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; -Colin<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/862072e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>December  6, 2015 at 10:00:00pm</p></header><div class="content"><p>Hi David,<br></p><p>sorry but I don’t understand what do you mean in your first point can you elaborate further?<br></p><p>2. your reswitch will throw a compile error, because you are try to call the switch with a different type, I imagine that to reswitch you can only pass a valid match to optionalThins so you have to pass a `String?` and yes, the proposal is to re execute the switch on the new value.<br></p><p>3. Your second example can’t be always valid because optionalThing can be a constant, I’m imagining that in the new switch execution optionalThing is being shadowed by the new value, but at the end of the execution optionalThing is the old value again.<br></p><p><br>&gt; On 06 Dec 2015, at 21:48, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; To cope with the pattern matching cases, I would say that reswitch either has to:<br>&gt; 1. Be limited specifically to a switch without pattern matching or enum values with associated data (such as Optional.Some). This would likely need to go beyond the limitations on fall through, which only limit value-binding patterns<br>&gt; 2. Use instead of trying to treat the value of a reswitch as a label, treat it as a expression to re-execute the switch statement over:<br>&gt; <br>&gt; switch(optionalThing) {<br>&gt; case .None:<br>&gt; 	print(“assuming default value”)	<br>&gt; 	reswitch “default”<br>&gt; case .Some(let str):<br>&gt; 	print(“processing value \(str)”);<br>&gt; }<br>&gt; <br>&gt; This does however have non-intuitive behavior - when the second case statement is hit, “str&quot; is no longer equal to &quot;optionalThing!”. For that reason, one might find it clearer to require an explicit reassignment, effectively treating the switch as a loop: <br>&gt; <br>&gt; switch(optionalThing) {<br>&gt; case .None:<br>&gt; 	print(“assuming default value”)	<br>&gt; 	optionalThing = “default”<br>&gt; 	reswitch<br>&gt; case .Some(let str):<br>&gt; 	print(“processing value \(str)”);<br>&gt; }<br>&gt; <br>&gt; The existing “continue” keyword seems a poor choice to recycle for this purpose; “repeat” or “retry” might be more appropriate than “reswitch&quot;<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 1:06 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;  Hi Colin,<br>&gt;&gt; <br>&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt; <br>&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt; So something like this:<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt; <br>&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt; <br>&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		x = 0;<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two where x &gt; 0:<br>&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt; 		element = array[x]<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt; <br>&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt; <br>&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt; <br>&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt; <br>&gt;&gt; - Jacopo<br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/ff2c188d/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 12:48 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To cope with the pattern matching cases, I would say that reswitch either has to:<br>&gt; 1. Be limited specifically to a switch without pattern matching or enum values with associated data (such as Optional.Some). This would likely need to go beyond the limitations on fall through, which only limit value-binding patterns<br>&gt; 2. Use instead of trying to treat the value of a reswitch as a label, treat it as a expression to re-execute the switch statement over:<br>&gt; <br>&gt; switch(optionalThing) {<br>&gt; case .None:<br>&gt; 	print(“assuming default value”)	<br>&gt; 	reswitch “default”<br>&gt; case .Some(let str):<br>&gt; 	print(“processing value \(str)”);<br>&gt; }<br>&gt; <br>&gt; This does however have non-intuitive behavior - when the second case statement is hit, “str&quot; is no longer equal to &quot;optionalThing!”. For that reason, one might find it clearer to require an explicit reassignment, effectively treating the switch as a loop: <br>&gt; <br>&gt; switch(optionalThing) {<br>&gt; case .None:<br>&gt; 	print(“assuming default value”)	<br>&gt; 	optionalThing = “default”<br>&gt; 	reswitch<br>&gt; case .Some(let str):<br>&gt; 	print(“processing value \(str)”);<br>&gt; }<br></p><p>Maybe it&#39;s just me, but this is the behavior I&#39;d expect.<br></p><p>&gt; The existing “continue” keyword seems a poor choice to recycle for this purpose; “repeat” or “retry” might be more appropriate than “reswitch&quot;<br></p><p>Agreed that this ought to be a distinct keyword.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 1:06 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;  Hi Colin,<br>&gt;&gt; <br>&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt; <br>&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt; So something like this:<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt; <br>&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt; <br>&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		x = 0;<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two where x &gt; 0:<br>&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt; 		element = array[x]<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt; <br>&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt; <br>&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt; <br>&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt; <br>&gt;&gt; - Jacopo<br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/48c6a843/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>December  6, 2015 at 03:00:00pm</p></header><div class="content"><p>Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br></p><p>I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br></p><p>I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br></p><p>I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br></p><p>Thanks,<br>-Colin<br></p><p>&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt; <br>&gt;  Hi Colin,<br>&gt; <br>&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt; <br>&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt; So something like this:<br>&gt; <br>&gt; switch (enum) {<br>&gt; 	case .One:<br>&gt; 		// do something<br>&gt; 		reswitch .Two<br>&gt; 	case .Two:<br>&gt; 		// do something else<br>&gt; 	default:<br>&gt; 		// and so one<br>&gt; }<br>&gt; <br>&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt; <br>&gt; switch (enum) {<br>&gt; 	case .One:<br>&gt; 		// do something<br>&gt; 		reswitch .Two<br>&gt; 	case .OneAndAHalf<br>&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt; 	case .Two:<br>&gt; 		// do something else<br>&gt; 	default:<br>&gt; 		// and so one<br>&gt; }<br>&gt; <br>&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt; <br>&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt; <br>&gt; switch (enum) {<br>&gt; 	case .One:<br>&gt; 		// do something<br>&gt; 		reswitch .Two<br>&gt; 	case .OneAndAHalf<br>&gt; 		// so something that you don’t want to do for .One<br>&gt; 		reswitch .Two<br>&gt; 	case .Two:<br>&gt; 		// do something else that you may want to do for .One and .Two<br>&gt; 	default:<br>&gt; 		// and so one<br>&gt; }<br>&gt; <br>&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt; <br>&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt; <br>&gt; switch (enum) {<br>&gt; 	case .One:<br>&gt; 		// do something<br>&gt; 		x = 0;<br>&gt; 		reswitch .Two<br>&gt; 	case .OneAndAHalf<br>&gt; 		// so something that you don’t want to do for .One<br>&gt; 		reswitch .Two<br>&gt; 	case .Two where x &gt; 0:<br>&gt; 		// do something else that you may want to do for .One and .Two<br>&gt; 		element = array[x]<br>&gt; 	default:<br>&gt; 		// and so one<br>&gt; }<br>&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt; <br>&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt; <br>&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt; <br>&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt; <br>&gt; - Jacopo<br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt; <br>&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt; <br>&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt; <br>&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt; <br>&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt; <br>&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; -Colin<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/892e7f01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>December  6, 2015 at 10:00:00pm</p></header><div class="content"><p>Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br></p><p>Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br></p><p>I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 &lt;https://gist.github.com/JGiola/f735212789bf2f697847&gt;<br>If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br></p><p>And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br></p><p>- Jacopo<br></p><p>&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt; <br>&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt; <br>&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt; <br>&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt; <br>&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt; <br>&gt; Thanks,<br>&gt; -Colin<br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org &lt;mailto:swift-evolution at jacopo.giola.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;  Hi Colin,<br>&gt;&gt; <br>&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt; <br>&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt; So something like this:<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt; <br>&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two:<br>&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt; <br>&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt; <br>&gt;&gt; switch (enum) {<br>&gt;&gt; 	case .One:<br>&gt;&gt; 		// do something<br>&gt;&gt; 		x = 0;<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt; 		reswitch .Two<br>&gt;&gt; 	case .Two where x &gt; 0:<br>&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt; 		element = array[x]<br>&gt;&gt; 	default:<br>&gt;&gt; 		// and so one<br>&gt;&gt; }<br>&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt; <br>&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt; <br>&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt; <br>&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt; <br>&gt;&gt; - Jacopo<br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/1b433a50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>December  6, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt; <br>&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br></p><p>I’m curious, how do you propose to do this?<br></p><p>&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br></p><p>In your document you give the example:<br></p><p>&gt; case .Three where x &gt; 0:<br></p><p>Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:<br></p><p>&gt; case .Four(x) where x &gt; 0:<br></p><p>In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.<br></p><p>In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.<br></p><p>-Colin<br></p><p>&gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt; <br>&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt; <br>&gt; - Jacopo<br>&gt; <br>&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt;&gt; <br>&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt;&gt; <br>&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt;&gt; <br>&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; -Colin<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt; 		x = 0;<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .Two where x &gt; 0:<br>&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt; 		element = array[x]<br>&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>December  6, 2015 at 09:00:00pm</p></header><div class="content"><p>For better or worse, I would like to note that `reswitch` is essentially a<br>safer `goto`, so keep in mind all the bad things that can be done with it.<br></p><p>On Sun, Dec 6, 2015 at 1:23 PM Colin Barrett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola &lt;<br>&gt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yes, I’m aware that at this time the reswitch can be abused and maybe<br>&gt; can be better refined to disallow such cases.<br>&gt;<br>&gt; I’m curious, how do you propose to do this?<br>&gt;<br>&gt; &gt; Checking the case statement is not a problem by itself, but can be a<br>&gt; problem if is coupled with a where clause that is not true when you<br>&gt; fallthrought.<br>&gt;<br>&gt; In your document you give the example:<br>&gt;<br>&gt; &gt; case .Three where x &gt; 0:<br>&gt;<br>&gt; Now I may be wrong but I feel as though most of the uses of where clauses<br>&gt; are also ones that reference variables bound in a `case let`. For instance:<br>&gt;<br>&gt; &gt; case .Four(x) where x &gt; 0:<br>&gt;<br>&gt; In that case, fallthrough would required to evaluating the case part<br>&gt; anyway, as per my postulated rules below.<br>&gt;<br>&gt; In any case, I appreciate you taking the time to discuss your proposal,<br>&gt; even if I didn’t end up convinced. Thanks.<br>&gt;<br>&gt; -Colin<br>&gt;<br>&gt; &gt; I’ve written a really bad draft here<br>&gt; https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt; &gt; If anyone wants to jump in and elaborate further is welcome. I will try<br>&gt; to stay on par with this thread but I’m really bad at writing so every help<br>&gt; is welcome.<br>&gt; &gt;<br>&gt; &gt; And if I remember correctly Daniel Jakult was the first one to made this<br>&gt; proposal so if he wants to take on and then made the official proposal has<br>&gt; every right to do so and I will be very glad if my gist can be a first<br>&gt; reference :)<br>&gt; &gt;<br>&gt; &gt; - Jacopo<br>&gt; &gt;<br>&gt; &gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for<br>&gt; your patience in summarizing it again.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’ve only glanced through it but my concern here is that it introduces<br>&gt; a whole class of new and creative “foot-guns&quot; :) In particular, it allows<br>&gt; this construction to loop arbitrarily and creatively, particularly in the<br>&gt; case of associated values.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m not sure why not checking the case statement is considered a<br>&gt; problem for the fallthrough keyword. Assuming it’s impossible to<br>&gt; fallthrough to a case that introduces binders (what would they be bound<br>&gt; to?), and that this is statically checked (both of which seem reasonable<br>&gt; assumptions to me, although if I’m wrong feel free to correct me), isn’t it<br>&gt; the entire point of the fallthrough keyword that it skips checking the case<br>&gt; statement? I can understand how that might be somewhat confusing (and<br>&gt; perhaps it should be documented less prominently) but I’m not sure how it’s<br>&gt; a *problem*, exactly...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the<br>&gt; downside of doing nothing? For instance in the case of ++ and -- those<br>&gt; features complicate the design of a numerics library.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thanks,<br>&gt; &gt;&gt; -Colin<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;<br>&gt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  Hi Colin,<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough`<br>&gt; keyword but many people expressed your similar concern and from that point<br>&gt; the discussion was steered through an &quot;enhancement&quot; and better refinement<br>&gt; of the keyword.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing<br>&gt; the desired new value on which the switch is applied.<br>&gt; &gt;&gt;&gt; So something like this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;     case .One:<br>&gt; &gt;&gt;&gt;             // do something<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .Two:<br>&gt; &gt;&gt;&gt;             // do something else<br>&gt; &gt;&gt;&gt;     default:<br>&gt; &gt;&gt;&gt;             // and so one<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more<br>&gt; declarative of the developer intent and doesn&#39;t carry over unintentional<br>&gt; misbehaviour.<br>&gt; &gt;&gt;&gt; Is more declarative because you are forced to state in which case you<br>&gt; want to go, and even if the order of the switch’ cases will change in the<br>&gt; future, you don&#39;t fall in the wrong case by mistake.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;     case .One:<br>&gt; &gt;&gt;&gt;             // do something<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .OneAndAHalf<br>&gt; &gt;&gt;&gt;             // maybe this change is not made by you but by a messed up<br>&gt; merge<br>&gt; &gt;&gt;&gt;     case .Two:<br>&gt; &gt;&gt;&gt;             // do something else<br>&gt; &gt;&gt;&gt;     default:<br>&gt; &gt;&gt;&gt;             // and so one<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is<br>&gt; now broken by accident, and depending on what are you trying to do inside<br>&gt; the cases you can have a hidden bug that your tests are not seeing right<br>&gt; away.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Another advantage is that in this way you can made more cases<br>&gt; fallthrough in the same one even if they are not one over each other<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;     case .One:<br>&gt; &gt;&gt;&gt;             // do something<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .OneAndAHalf<br>&gt; &gt;&gt;&gt;             // so something that you don’t want to do for .One<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .Two:<br>&gt; &gt;&gt;&gt;             // do something else that you may want to do for .One and<br>&gt; .Two<br>&gt; &gt;&gt;&gt;     default:<br>&gt; &gt;&gt;&gt;             // and so one<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I must say that this is a side effect that can be used to messed up<br>&gt; the code flow in a way that is not intended, but is a new behaviour that<br>&gt; gives more power to the switch statement.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new<br>&gt; case without doing the optional checking attached to it, but is intended to<br>&gt; be a new call and all the check are executed.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;     case .One:<br>&gt; &gt;&gt;&gt;             // do something<br>&gt; &gt;&gt;&gt;             x = 0;<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .OneAndAHalf<br>&gt; &gt;&gt;&gt;             // so something that you don’t want to do for .One<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .Two where x &gt; 0:<br>&gt; &gt;&gt;&gt;             // do something else that you may want to do for .One and<br>&gt; .Two<br>&gt; &gt;&gt;&gt;             element = array[x]<br>&gt; &gt;&gt;&gt;     default:<br>&gt; &gt;&gt;&gt;             // and so one<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app<br>&gt; directly, so the code must be incorrect in the syntax and for this I’m<br>&gt; sorry).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In this case if enum is .One the only case that is executed is case<br>&gt; .One and the code doesn’t fallthrough in the .Two case because we are made<br>&gt; the where invalid by changing the x to a value less than 1.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and<br>&gt; I don’t know if he is working on a first draft to lay down the things<br>&gt; better, but for me this can be a nice improvement and a neat break with the<br>&gt; C-switch behaviour that Swift has trying to change from the very first beta<br>&gt; disallowing the implicit fallthrough.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a<br>&gt; “temporary” implementation for ease the transition from Obj-C to Swift and<br>&gt; is time to improve it and made the switch statement even more powerful.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; - Jacopo<br>&gt; &gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us<br>&gt; anything; and has at least minimal utility, as I try to demonstrate.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve<br>&gt; only just now subscribed to this list.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances.<br>&gt; I’ve also yet to see an example of where it creates a negative impact,<br>&gt; either in code, optimization, or what have you. Other than “It’s like<br>&gt; something in C, and C is old and busted” I’m unsure of the rationale for<br>&gt; removing it. (Feel free to point me in the right direction.)<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest<br>&gt; way to define the number of a planet (i.e. its 1-based index in the<br>&gt; ordering of planets wrt. distance from the sun) is using a switch and<br>&gt; fall-through:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing<br>&gt; the force induced by the gravity of the other planets on a particular<br>&gt; planet. All that would need to change is the case statements.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and<br>&gt; mapping or folding (or looping) over that, but unless the compiler can<br>&gt; “unroll” that construct, you’re paying for an allocation simply bc of your<br>&gt; choice of control flow. But in fact, you could imagine generalizing this<br>&gt; construct into the implementation of fold for the Planet type —<br>&gt; low-overhead folds for monomorphic types seems like a pretty compelling an<br>&gt; natural use case for fallthrough to me.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Thanks,<br>&gt; &gt;&gt;&gt;&gt; -Colin<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of<br>&gt; overloading continue with a new syntax.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler<br>&gt; check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot;<br>&gt; loop.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I<br>&gt; wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no<br>&gt; matter how we spell it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;<br>&gt; john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both<br>&gt; allow natural expression of concepts that exist at the instruction level<br>&gt; but are otherwise difficult to express with nested control structures.<br>&gt; `fallthrough` is perhaps slightly less objectionable because control flow<br>&gt; remains local, but it has a similar role.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with<br>&gt; `fallthrough` in the reverse order that can be seen in Duff’s Device and<br>&gt; similar constructs (case 7 falls through to 6 which falls through to 5,<br>&gt; etc.). It’s just because you know for certain that all the code in case 6<br>&gt; would be duplicated in case 7, so 7 can transfer into 6 without a jump<br>&gt; instruction. Communicating that to the compiler without `fallthrough`<br>&gt; requires deeply nested `if`s.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that<br>&gt; we might parameterize it in the future; parameterized it would mean “repeat<br>&gt; the switch with this new value”, so that unparameterized fallthrough would<br>&gt; mean “repeat the switch with a notional value that ends up in the next<br>&gt; case”.  There’s a very common pattern in switches of deferring to another<br>&gt; case that I’ve always found very awkward to write in C, and while sometimes<br>&gt; there’s no choice but to extract a helper function, there’s a<br>&gt; still-fairly-structural code pattern here that I think we can sensibly<br>&gt; support.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an<br>&gt; inappropriate extension for “fallthrough” specifically, which is one reason<br>&gt; we’ve never pursued it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at<br>&gt; systems programming. Is writing a threaded interpreter loop within the<br>&gt; potential scope of Swift? That’s a use case that could make use of both<br>&gt; `fallthrough` and `goto` (computed goto, really).<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that<br>&gt; can scale up to high-level concepts and down to “portable assembler,” but I<br>&gt; don’t know if that is the right direction for Swift’s evolution.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the<br>&gt; fact that C switch statements don&#39;t actually introduce a new scope, and so<br>&gt; it overlaps a switch with a do-while loop. This lets it only test the<br>&gt; number of bytes once, to jump into the middle of the loop, and then it<br>&gt; switches over to a while loop that decrements a counter every 8<br>&gt; instructions. Basically, it&#39;s a trick for manual loop unrolling that deals<br>&gt; with non-multiple-of-8 counts efficiently.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.<br>&gt; What Duff’s Device exploits is that switch is allowed to jump into (almost)<br>&gt; arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the<br>&gt; top level within a switch and thus prevents the use of Duff’s Device is<br>&gt; 100% correct.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that<br>&gt; deals with non-multiple-of-8 counts, but it has calculate the number of<br>&gt; bytes on every iteration instead of once. It&#39;s a good example of one of the<br>&gt; uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use<br>&gt; Duff&#39;s Device in Swift.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is<br>&gt; a big place where switch fallthrough is arguably the cleanest way to do<br>&gt; things and the reason why I’d personally prefer to keep it as part of the<br>&gt; language.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;<br>&gt; erica at ericasadun.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find<br>&gt; myself re-factoring to stop using it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com, there are only 22<br>&gt; gist results for &quot;fallthrough language:swift&quot;.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most<br>&gt; of the remaining ones are just complex cases:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:<br>&gt; https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I&#39;m pretty<br>&gt; sure that ponies were harmed in the production of whatever that last bit is.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++<br>&gt; style artifacts, what do folks think about the possibility of removing the<br>&gt; &quot;fallthrough&quot; keyword from the language?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the<br>&gt; archaic seeming purpose of perpetuating C-style fallthrough from one switch<br>&gt; statement to the subsequent one. The documentation hedges the use of this<br>&gt; keyword in forbidding terms that make it clear its use is not encouraged.<br>&gt; The presence of the keyword, while an improvement over C’s implicit<br>&gt; fallthrough, is a mark of inelegance on an otherwise well-designed,<br>&gt; opinionated implementation of swtich statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands<br>&gt; a caveat in the documentation:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions<br>&gt; for the switch case that it causes execution to fall into. The fallthrough<br>&gt; keyword simply causes code execution to move directly to the statements<br>&gt; inside the next case (or default case) block, as in C’s standard switch<br>&gt; statement behavior.&quot;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with<br>&gt; fallthrough, both in C or Swift: coded that is clearly labeled with<br>&gt; deliberate conditions can nonetheless be reached.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common<br>&gt; pushback I got seemed to be from people who either did not know about<br>&gt; Swift’s support for comma-separated case statements, or harbored an<br>&gt; aesthetic preference for clustering such cases together with fallthrough<br>&gt; statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong<br>&gt; defense for supporting intentional fallthrough in Swift, removing the<br>&gt; keyword would be a move in the direction of minimizing the language’s<br>&gt; complexity while also discouraging poor coding style in switch statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/c4c125eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>December  6, 2015 at 10:00:00pm</p></header><div class="content"><p>Dan, you are using the word “safer” so at least is an improvement :)<br>but I don’t see it as a goto. goto is used with arbitrary label that move your code flow around without been bound in some limited construct. reswitch is limited in scope inside a switch, can be called only on typed value of the main switch, and will retain the constraint of been called at the end of the case as fallthrought so it will not mess up the case execution but will only try to execute the switch again on another case.<br></p><p>&gt; On 06 Dec 2015, at 22:26, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt; <br>&gt; For better or worse, I would like to note that `reswitch` is essentially a safer `goto`, so keep in mind all the bad things that can be done with it.<br>&gt; <br>&gt; On Sun, Dec 6, 2015 at 1:23 PM Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org &lt;mailto:swift-evolution at jacopo.giola.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt; <br>&gt; I’m curious, how do you propose to do this?<br>&gt; <br>&gt; &gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt; <br>&gt; In your document you give the example:<br>&gt; <br>&gt; &gt; case .Three where x &gt; 0:<br>&gt; <br>&gt; Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:<br>&gt; <br>&gt; &gt; case .Four(x) where x &gt; 0:<br>&gt; <br>&gt; In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.<br>&gt; <br>&gt; In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.<br>&gt; <br>&gt; -Colin<br>&gt; <br>&gt; &gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 &lt;https://gist.github.com/JGiola/f735212789bf2f697847&gt;<br>&gt; &gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt; &gt;<br>&gt; &gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt; &gt;<br>&gt; &gt; - Jacopo<br>&gt; &gt;<br>&gt; &gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com &lt;mailto:colin at springsandstruts.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thanks,<br>&gt; &gt;&gt; -Colin<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org &lt;mailto:swift-evolution at jacopo.giola.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  Hi Colin,<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt; &gt;&gt;&gt; So something like this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;     case .One:<br>&gt; &gt;&gt;&gt;             // do something<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .Two:<br>&gt; &gt;&gt;&gt;             // do something else<br>&gt; &gt;&gt;&gt;     default:<br>&gt; &gt;&gt;&gt;             // and so one<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt; &gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;     case .One:<br>&gt; &gt;&gt;&gt;             // do something<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .OneAndAHalf<br>&gt; &gt;&gt;&gt;             // maybe this change is not made by you but by a messed up merge<br>&gt; &gt;&gt;&gt;     case .Two:<br>&gt; &gt;&gt;&gt;             // do something else<br>&gt; &gt;&gt;&gt;     default:<br>&gt; &gt;&gt;&gt;             // and so one<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;     case .One:<br>&gt; &gt;&gt;&gt;             // do something<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .OneAndAHalf<br>&gt; &gt;&gt;&gt;             // so something that you don’t want to do for .One<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .Two:<br>&gt; &gt;&gt;&gt;             // do something else that you may want to do for .One and .Two<br>&gt; &gt;&gt;&gt;     default:<br>&gt; &gt;&gt;&gt;             // and so one<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;     case .One:<br>&gt; &gt;&gt;&gt;             // do something<br>&gt; &gt;&gt;&gt;             x = 0;<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .OneAndAHalf<br>&gt; &gt;&gt;&gt;             // so something that you don’t want to do for .One<br>&gt; &gt;&gt;&gt;             reswitch .Two<br>&gt; &gt;&gt;&gt;     case .Two where x &gt; 0:<br>&gt; &gt;&gt;&gt;             // do something else that you may want to do for .One and .Two<br>&gt; &gt;&gt;&gt;             element = array[x]<br>&gt; &gt;&gt;&gt;     default:<br>&gt; &gt;&gt;&gt;             // and so one<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; - Jacopo<br>&gt; &gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Thanks,<br>&gt; &gt;&gt;&gt;&gt; -Colin<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek%2Blists at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Dan Appel<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8512a8fe/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>December  6, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On 06 Dec 2015, at 22:23, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt; <br>&gt; I’m curious, how do you propose to do this?<br></p><p>I really don’t know right now, I hope we can find a way.<br></p><p>&gt; <br>&gt;&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt; <br>&gt; In your document you give the example:<br>&gt; <br>&gt;&gt; case .Three where x &gt; 0:<br>&gt; <br>&gt; Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:<br>&gt; <br>&gt;&gt; case .Four(x) where x &gt; 0:<br>&gt; <br>&gt; In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.<br></p><p>Yes, maybe my example is not the most correct one, I’ve tried to come up with something obvious and easy to read/write, but the problem will remain for falltrhought as for the Swift iBook:<br></p><p>NOTE<br>The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behaviour.<br></p><p>For me this behaviour is not something that marry together with the where clause that we can add to the switch&#39;s cases.<br></p><p>&gt; <br>&gt; In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.<br>&gt; <br>&gt; -Colin<br></p><p>Well technically I wasn’t the original proposal, I’ve only appreciate the direction it took and now I’m here to try to spark more discussion to see if is a valid direction and if we can improve it :)<br></p><p>&gt; <br>&gt;&gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt;&gt; <br>&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt;&gt; <br>&gt;&gt; - Jacopo<br>&gt;&gt; <br>&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Colin,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt; 		x = 0;<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .Two where x &gt; 0:<br>&gt;&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt; 		element = array[x]<br>&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  6, 2015 at 02:00:00pm</p></header><div class="content"><p>reswitch looks really confusing. Certainly significantly more confusing<br>than fallthrough.<br></p><p>I notice that all the examples here are using relatively trivial cases,<br>like `case .LOAD`. Sure it doesn&#39;t look confusing there. But it will <br>get confusing with complicated cases:<br></p><p>switch value {<br>case .Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Garply)):<br>    // do some stuff<br>    reswitch(.Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Waldo)))<br>case .Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Waldo)):<br>    // do some more stuff<br>    // ...<br>}<br></p><p>It also fails to account for those cases where you explicitly cannot<br>re-evaluate against the start of the case list because that won&#39;t match<br>the right case. Trivial example:<br></p><p>switch value {<br>case .Foo(let s) where seen[s] == nil:<br>    seen[s] = true<br>    fallthrough<br>case .Foo:<br>    // ...<br>}<br></p><p>There&#39;s no way to use reswitch here to bypass that first case (any value<br>you might come up with may still pass that where clause and execute the<br>first case).<br></p><p>-Kevin Ballard<br></p><p>On Sun, Dec 6, 2015, at 02:09 PM, Jacopo Andrea Giola via<br>swift-evolution wrote:<br>&gt; <br>&gt; &gt; On 06 Dec 2015, at 22:23, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt; &gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt; &gt; <br>&gt; &gt; I’m curious, how do you propose to do this?<br>&gt; <br>&gt; I really don’t know right now, I hope we can find a way.<br>&gt; <br>&gt; &gt; <br>&gt; &gt;&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt; &gt; <br>&gt; &gt; In your document you give the example:<br>&gt; &gt; <br>&gt; &gt;&gt; case .Three where x &gt; 0:<br>&gt; &gt; <br>&gt; &gt; Now I may be wrong but I feel as though most of the uses of where clauses are also ones that reference variables bound in a `case let`. For instance:<br>&gt; &gt; <br>&gt; &gt;&gt; case .Four(x) where x &gt; 0:<br>&gt; &gt; <br>&gt; &gt; In that case, fallthrough would required to evaluating the case part anyway, as per my postulated rules below.<br>&gt; <br>&gt; Yes, maybe my example is not the most correct one, I’ve tried to come up<br>&gt; with something obvious and easy to read/write, but the problem will<br>&gt; remain for falltrhought as for the Swift iBook:<br>&gt; <br>&gt; NOTE<br>&gt; The fallthrough keyword does not check the case conditions for the switch<br>&gt; case that it causes execution to fall into. The fallthrough keyword<br>&gt; simply causes code execution to move directly to the statements inside<br>&gt; the next case (or default case) block, as in C’s standard switch<br>&gt; statement behaviour.<br>&gt; <br>&gt; For me this behaviour is not something that marry together with the where<br>&gt; clause that we can add to the switch&#39;s cases.<br>&gt; <br>&gt; &gt; <br>&gt; &gt; In any case, I appreciate you taking the time to discuss your proposal, even if I didn’t end up convinced. Thanks.<br>&gt; &gt; <br>&gt; &gt; -Colin<br>&gt; <br>&gt; Well technically I wasn’t the original proposal, I’ve only appreciate the<br>&gt; direction it took and now I’m here to try to spark more discussion to see<br>&gt; if is a valid direction and if we can improve it :)<br>&gt; <br>&gt; &gt; <br>&gt; &gt;&gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt; &gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; - Jacopo<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Thanks,<br>&gt; &gt;&gt;&gt; -Colin<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Hi Colin,<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt; &gt;&gt;&gt;&gt; So something like this:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;&gt; 	case .One:<br>&gt; &gt;&gt;&gt;&gt; 		// do something<br>&gt; &gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt; &gt;&gt;&gt;&gt; 	case .Two:<br>&gt; &gt;&gt;&gt;&gt; 		// do something else<br>&gt; &gt;&gt;&gt;&gt; 	default:<br>&gt; &gt;&gt;&gt;&gt; 		// and so one<br>&gt; &gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt; &gt;&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;&gt; 	case .One:<br>&gt; &gt;&gt;&gt;&gt; 		// do something<br>&gt; &gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt; &gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt; &gt;&gt;&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt; &gt;&gt;&gt;&gt; 	case .Two:<br>&gt; &gt;&gt;&gt;&gt; 		// do something else<br>&gt; &gt;&gt;&gt;&gt; 	default:<br>&gt; &gt;&gt;&gt;&gt; 		// and so one<br>&gt; &gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;&gt; 	case .One:<br>&gt; &gt;&gt;&gt;&gt; 		// do something<br>&gt; &gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt; &gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt; &gt;&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt; &gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt; &gt;&gt;&gt;&gt; 	case .Two:<br>&gt; &gt;&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt; &gt;&gt;&gt;&gt; 	default:<br>&gt; &gt;&gt;&gt;&gt; 		// and so one<br>&gt; &gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; switch (enum) {<br>&gt; &gt;&gt;&gt;&gt; 	case .One:<br>&gt; &gt;&gt;&gt;&gt; 		// do something<br>&gt; &gt;&gt;&gt;&gt; 		x = 0;<br>&gt; &gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt; &gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt; &gt;&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt; &gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt; &gt;&gt;&gt;&gt; 	case .Two where x &gt; 0:<br>&gt; &gt;&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt; &gt;&gt;&gt;&gt; 		element = array[x]<br>&gt; &gt;&gt;&gt;&gt; 	default:<br>&gt; &gt;&gt;&gt;&gt; 		// and so one<br>&gt; &gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; - Jacopo<br>&gt; &gt;&gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt; &gt;&gt;&gt;&gt;&gt; -Colin<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   in0 = memory[in1]<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   fallthrough<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   out0 = memory[in0]<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 2:48 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; reswitch looks really confusing. Certainly significantly more confusing<br>&gt; than fallthrough.<br>&gt; <br>&gt; I notice that all the examples here are using relatively trivial cases,<br>&gt; like `case .LOAD`. Sure it doesn&#39;t look confusing there. But it will <br>&gt; get confusing with complicated cases:<br>&gt; <br>&gt; switch value {<br>&gt; case .Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Garply)):<br>&gt;    // do some stuff<br>&gt;    reswitch(.Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Waldo)))<br>&gt; case .Foo(bar, .Baz(.Qux(quux), .Corge), .Grault(.Waldo)):<br>&gt;    // do some more stuff<br>&gt;    // ...<br>&gt; }<br>&gt; <br>&gt; It also fails to account for those cases where you explicitly cannot<br>&gt; re-evaluate against the start of the case list because that won&#39;t match<br>&gt; the right case. Trivial example:<br>&gt; <br>&gt; switch value {<br>&gt; case .Foo(let s) where seen[s] == nil:<br>&gt;    seen[s] = true<br>&gt;    fallthrough<br>&gt; case .Foo:<br>&gt;    // ...<br>&gt; }<br>&gt; <br>&gt; There&#39;s no way to use reswitch here to bypass that first case (any value<br>&gt; you might come up with may still pass that where clause and execute the<br>&gt; first case).<br></p><p>This could also be handled by introducing another state into the &#39;switch&#39; that shares the destination branch with .Foo.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  6, 2015 at 04:00:00pm</p></header><div class="content"><p>It seems reswitch *should* be useable even in cases that aren&#39;t a simple<br>&quot;goto&quot;. Or am I missing something?<br></p><p>For instance, rewriting the example from earlier:<br></p><p>switch op {<br>case let .LOAD_INDIRECT(out, in):<br>    reswitch(.LOAD(out, memory[in]))<br>case let .LOAD(out, in):<br>    setReg(out, in)<br>// ...<br>}<br></p><p>or, a switch that calculates whether some number n is in a Lisp-style list<br>of numbers<br></p><p>switch lst {<br>case .Cons(let m, _) where m == n:<br>     return true<br>case .Cons(_, let rest):<br>    reswitch(rest)<br>case .Empty:<br>     return false<br>}<br></p><p>I like reswitch: in some cases, the compiler could optimize to a<br>fallthrough, and in others, you could actually re-switch. But maybe I&#39;m<br>missing something.<br></p><p>On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can<br>&gt; be better refined to disallow such cases.<br>&gt;<br>&gt; Checking the case statement is not a problem by itself, but can be a<br>&gt; problem if is coupled with a where clause that is not true when you<br>&gt; fallthrought.<br>&gt;<br>&gt; I’ve written a really bad draft here<br>&gt; https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt; If anyone wants to jump in and elaborate further is welcome. I will try to<br>&gt; stay on par with this thread but I’m really bad at writing so every help is<br>&gt; welcome.<br>&gt;<br>&gt; And if I remember correctly Daniel Jakult was the first one to made this<br>&gt; proposal so if he wants to take on and then made the official proposal has<br>&gt; every right to do so and I will be very glad if my gist can be a first<br>&gt; reference :)<br>&gt;<br>&gt; - Jacopo<br>&gt;<br>&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt; colin at springsandstruts.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for<br>&gt; your patience in summarizing it again.<br>&gt;<br>&gt; I’ve only glanced through it but my concern here is that it introduces a<br>&gt; whole class of new and creative “foot-guns&quot; :) In particular, it allows<br>&gt; this construction to loop arbitrarily and creatively, particularly in the<br>&gt; case of associated values.<br>&gt;<br>&gt; I’m not sure why not checking the case statement is considered a problem<br>&gt; for the fallthrough keyword. Assuming it’s impossible to fallthrough to a<br>&gt; case that introduces binders (what would they be bound to?), and that this<br>&gt; is statically checked (both of which seem reasonable assumptions to me,<br>&gt; although if I’m wrong feel free to correct me), isn’t it the entire point<br>&gt; of the fallthrough keyword that it skips checking the case statement? I can<br>&gt; understand how that might be somewhat confusing (and perhaps it should be<br>&gt; documented less prominently) but I’m not sure how it’s a *problem*,<br>&gt; exactly...<br>&gt;<br>&gt; I think I’m still on the side of keeping fallthrough. What’s the downside<br>&gt; of doing nothing? For instance in the case of ++ and -- those features<br>&gt; complicate the design of a numerics library.<br>&gt;<br>&gt; Thanks,<br>&gt; -Colin<br>&gt;<br>&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;<br>&gt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;<br>&gt;  Hi Colin,<br>&gt;<br>&gt; the initial proposal was indeed to remove entirely the `fallthrough`<br>&gt; keyword but many people expressed your similar concern and from that point<br>&gt; the discussion was steered through an &quot;enhancement&quot; and better refinement<br>&gt; of the keyword.<br>&gt;<br>&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the<br>&gt; desired new value on which the switch is applied.<br>&gt; So something like this:<br>&gt;<br>&gt; switch (enum) {<br>&gt; case .One:<br>&gt; // do something<br>&gt; reswitch .Two<br>&gt; case .Two:<br>&gt; // do something else<br>&gt; default:<br>&gt; // and so one<br>&gt; }<br>&gt;<br>&gt; This new behaviour, IMO, is better suited for Swift because is more<br>&gt; declarative of the developer intent and doesn&#39;t carry over unintentional<br>&gt; misbehaviour.<br>&gt; Is more declarative because you are forced to state in which case you want<br>&gt; to go, and even if the order of the switch’ cases will change in the<br>&gt; future, you don&#39;t fall in the wrong case by mistake.<br>&gt;<br>&gt; switch (enum) {<br>&gt; case .One:<br>&gt; // do something<br>&gt; reswitch .Two<br>&gt; case .OneAndAHalf<br>&gt; // maybe this change is not made by you but by a messed up merge<br>&gt; case .Two:<br>&gt; // do something else<br>&gt; default:<br>&gt; // and so one<br>&gt; }<br>&gt;<br>&gt; In this case if you are using the fallthrough keyboard your code is now<br>&gt; broken by accident, and depending on what are you trying to do inside the<br>&gt; cases you can have a hidden bug that your tests are not seeing right away.<br>&gt;<br>&gt; Another advantage is that in this way you can made more cases fallthrough<br>&gt; in the same one even if they are not one over each other<br>&gt;<br>&gt; switch (enum) {<br>&gt; case .One:<br>&gt; // do something<br>&gt; reswitch .Two<br>&gt; case .OneAndAHalf<br>&gt; // so something that you don’t want to do for .One<br>&gt; reswitch .Two<br>&gt; case .Two:<br>&gt; // do something else that you may want to do for .One and .Two<br>&gt; default:<br>&gt; // and so one<br>&gt; }<br>&gt;<br>&gt; I must say that this is a side effect that can be used to messed up the<br>&gt; code flow in a way that is not intended, but is a new behaviour that gives<br>&gt; more power to the switch statement.<br>&gt;<br>&gt; The reswitch keyword in addition is not a mere fallthrough on the new case<br>&gt; without doing the optional checking attached to it, but is intended to be a<br>&gt; new call and all the check are executed.<br>&gt;<br>&gt; switch (enum) {<br>&gt; case .One:<br>&gt; // do something<br>&gt; x = 0;<br>&gt; reswitch .Two<br>&gt; case .OneAndAHalf<br>&gt; // so something that you don’t want to do for .One<br>&gt; reswitch .Two<br>&gt; case .Two where x &gt; 0:<br>&gt; // do something else that you may want to do for .One and .Two<br>&gt; element = array[x]<br>&gt; default:<br>&gt; // and so one<br>&gt; }<br>&gt; (I’m going by memory and by writing this snippets in the mail app<br>&gt; directly, so the code must be incorrect in the syntax and for this I’m<br>&gt; sorry).<br>&gt;<br>&gt; In this case if enum is .One the only case that is executed is case .One<br>&gt; and the code doesn’t fallthrough in the .Two case because we are made the<br>&gt; where invalid by changing the x to a value less than 1.<br>&gt;<br>&gt; Now I don’t remember who was the first one who mede this proposal, and I<br>&gt; don’t know if he is working on a first draft to lay down the things better,<br>&gt; but for me this can be a nice improvement and a neat break with the<br>&gt; C-switch behaviour that Swift has trying to change from the very first beta<br>&gt; disallowing the implicit fallthrough.<br>&gt;<br>&gt; I can be completely wrong but I see the `fallthrough`keyword as a<br>&gt; “temporary” implementation for ease the transition from Obj-C to Swift and<br>&gt; is time to improve it and made the switch statement even more powerful.<br>&gt;<br>&gt; - Jacopo<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us<br>&gt; anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;<br>&gt; Apologies for jumping into this thread at an awkward point, but I’ve only<br>&gt; just now subscribed to this list.<br>&gt;<br>&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve<br>&gt; also yet to see an example of where it creates a negative impact, either in<br>&gt; code, optimization, or what have you. Other than “It’s like something in C,<br>&gt; and C is old and busted” I’m unsure of the rationale for removing it. (Feel<br>&gt; free to point me in the right direction.)<br>&gt;<br>&gt; Consider the Planet enum from the documentation. One of the simplest way<br>&gt; to define the number of a planet (i.e. its 1-based index in the ordering of<br>&gt; planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;<br>&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;<br>&gt; This technique is very extensible — for instance imagine computing the<br>&gt; force induced by the gravity of the other planets on a particular planet.<br>&gt; All that would need to change is the case statements.<br>&gt;<br>&gt; Yes, you could write this by putting the planets into a list and mapping<br>&gt; or folding (or looping) over that, but unless the compiler can “unroll”<br>&gt; that construct, you’re paying for an allocation simply bc of your choice of<br>&gt; control flow. But in fact, you could imagine generalizing this construct<br>&gt; into the implementation of fold for the Planet type — low-overhead folds<br>&gt; for monomorphic types seems like a pretty compelling an natural use case<br>&gt; for fallthrough to me.<br>&gt;<br>&gt; Thanks,<br>&gt; -Colin<br>&gt;<br>&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 for this idea, but I will prefer the reswitch keyword instead of<br>&gt; overloading continue with a new syntax.<br>&gt;<br>&gt; If this proposal is accepted, it must be coupled with a compiler check<br>&gt; that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Very much thinking out loud and not really the implications, I wonder if<br>&gt; we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;<br>&gt; I very much like specifying what case to fall through into, no matter how<br>&gt; we spell it.<br>&gt;<br>&gt; - Steve<br>&gt;<br>&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt; john.calsbeek+lists at gmail.com&gt;<br>&gt; wrote:<br>&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural<br>&gt; expression of concepts that exist at the instruction level but are<br>&gt; otherwise difficult to express with nested control structures.<br>&gt; `fallthrough` is perhaps slightly less objectionable because control flow<br>&gt; remains local, but it has a similar role.<br>&gt;<br>&gt; It is not particularly natural to write `switch` statements with<br>&gt; `fallthrough` in the reverse order that can be seen in Duff’s Device and<br>&gt; similar constructs (case 7 falls through to 6 which falls through to 5,<br>&gt; etc.). It’s just because you know for certain that all the code in case 6<br>&gt; would be duplicated in case 7, so 7 can transfer into 6 without a jump<br>&gt; instruction. Communicating that to the compiler without `fallthrough`<br>&gt; requires deeply nested `if`s.<br>&gt;<br>&gt;<br>&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might<br>&gt; parameterize it in the future; parameterized it would mean “repeat the<br>&gt; switch with this new value”, so that unparameterized fallthrough would mean<br>&gt; “repeat the switch with a notional value that ends up in the next case”.<br>&gt; There’s a very common pattern in switches of deferring to another case that<br>&gt; I’ve always found very awkward to write in C, and while sometimes there’s<br>&gt; no choice but to extract a helper function, there’s a<br>&gt; still-fairly-structural code pattern here that I think we can sensibly<br>&gt; support.<br>&gt;<br>&gt; On the other hand, there’s an argument that this is an inappropriate<br>&gt; extension for “fallthrough” specifically, which is one reason we’ve never<br>&gt; pursued it.<br>&gt;<br>&gt;<br>&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; One defense comes to mind: there is talk of Swift aiming at systems<br>&gt; programming. Is writing a threaded interpreter loop within the potential<br>&gt; scope of Swift? That’s a use case that could make use of both `fallthrough`<br>&gt; and `goto` (computed goto, really).<br>&gt;<br>&gt; switch op {<br>&gt; case LOAD_INDIRECT:<br>&gt;    in0 = memory[in1]<br>&gt;    fallthrough<br>&gt; case LOAD:<br>&gt;    out0 = memory[in0]<br>&gt; //...<br>&gt; }<br>&gt;<br>&gt; I am personally interested in the prospect of a language that can scale up<br>&gt; to high-level concepts and down to “portable assembler,” but I don’t know<br>&gt; if that is the right direction for Swift’s evolution.<br>&gt;<br>&gt; Cheers,<br>&gt; John<br>&gt;<br>&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt; rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt; kevin at sb.org&gt; wrote:<br>&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C<br>&gt; switch statements don&#39;t actually introduce a new scope, and so it overlaps<br>&gt; a switch with a do-while loop. This lets it only test the number of bytes<br>&gt; once, to jump into the middle of the loop, and then it switches over to a<br>&gt; while loop that decrements a counter every 8 instructions. Basically, it&#39;s<br>&gt; a trick for manual loop unrolling that deals with non-multiple-of-8 counts<br>&gt; efficiently.<br>&gt;<br>&gt;<br>&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s<br>&gt; Device exploits is that switch is allowed to jump into (almost) arbitrary<br>&gt; scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;<br>&gt; But your point that Swift’s switch requires cases to be at the top level<br>&gt; within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with<br>&gt; non-multiple-of-8 counts, but it has calculate the number of bytes on every<br>&gt; iteration instead of once. It&#39;s a good example of one of the uses of<br>&gt; `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s<br>&gt; Device in Swift.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;<br>&gt; Streza’s source code is an example of Duff’s Device, which is a big place<br>&gt; where switch fallthrough is arguably the cleanest way to do things and the<br>&gt; reason why I’d personally prefer to keep it as part of the language.<br>&gt;<br>&gt;<br>&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt; erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt; Oh let it die, let it die. Any time I use fallthrough I find myself<br>&gt; re-factoring to stop using it.<br>&gt;<br>&gt; *True fact*: On all of   gist.github.com, there are only 22 gist results<br>&gt; for &quot;fallthrough language:swift&quot;.<br>&gt; Half of those are people just testing out the feature. Most of the<br>&gt; remaining ones are just complex cases:<br>&gt; *case .Enum1, .Enum2:*<br>&gt; expressed as<br>&gt; *case .Enum1: fallthrough*<br>&gt; *case .Enum2:*<br>&gt;<br>&gt; And then there&#39;s streza:<br>&gt; https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I&#39;m pretty<br>&gt; sure that ponies were harmed in the production of whatever that last bit<br>&gt; is.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:<br>&gt;<br>&gt; In the spirit of some other proposals that remove C or C++ style<br>&gt; artifacts, what do folks think about the possibility of removing the<br>&gt; &quot;fallthrough&quot; keyword from the language?<br>&gt;<br>&gt; My understanding is this keyword is only used for the archaic seeming<br>&gt; purpose of perpetuating C-style fallthrough from one switch statement to<br>&gt; the subsequent one. The documentation hedges the use of this keyword in<br>&gt; forbidding terms that make it clear its use is not encouraged. The presence<br>&gt; of the keyword, while an improvement over C’s implicit fallthrough, is a<br>&gt; mark of inelegance on an otherwise well-designed, opinionated<br>&gt; implementation of swtich statements.<br>&gt;<br>&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in<br>&gt; the documentation:<br>&gt;<br>&gt; &quot;The fallthrough keyword does not check the case conditions for the switch<br>&gt; case that it causes execution to fall into. The fallthrough keyword simply<br>&gt; causes code execution to move directly to the statements inside the next<br>&gt; case (or default case) block, as in C’s standard switch statement<br>&gt; behavior.&quot;<br>&gt;<br>&gt; To my mind, the caveat explains just what is wrong with fallthrough, both<br>&gt; in C or Swift: coded that is clearly labeled with deliberate conditions can<br>&gt; nonetheless be reached.<br>&gt;<br>&gt; I quipped about this on Twitter, and the most common pushback I got seemed<br>&gt; to be from people who either did not know about Swift’s support for<br>&gt; comma-separated case statements, or harbored an aesthetic preference for<br>&gt; clustering such cases together with fallthrough statements.<br>&gt;<br>&gt; In my opinion, unless somebody can think of a strong defense for<br>&gt; supporting intentional fallthrough in Swift, removing the keyword would be<br>&gt; a move in the direction of minimizing the language’s complexity while also<br>&gt; discouraging poor coding style in switch statements.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Daniel<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/01225289/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  6, 2015 at 04:00:00pm</p></header><div class="content"><p>One question: what is the result of this code?<br></p><p>let x = .One<br></p><p>switch x {<br>case .One:<br>   reswitch(.Two)<br>case .Two:<br>   return x<br>}<br></p><p>.One or .Two? In other words, is x rebound inside the switch when we<br>reswitch?<br></p><p>On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br></p><p>&gt; It seems reswitch *should* be useable even in cases that aren&#39;t a simple<br>&gt; &quot;goto&quot;. Or am I missing something?<br>&gt;<br>&gt; For instance, rewriting the example from earlier:<br>&gt;<br>&gt; switch op {<br>&gt; case let .LOAD_INDIRECT(out, in):<br>&gt;     reswitch(.LOAD(out, memory[in]))<br>&gt; case let .LOAD(out, in):<br>&gt;     setReg(out, in)<br>&gt; // ...<br>&gt; }<br>&gt;<br>&gt; or, a switch that calculates whether some number n is in a Lisp-style list<br>&gt; of numbers<br>&gt;<br>&gt; switch lst {<br>&gt; case .Cons(let m, _) where m == n:<br>&gt;      return true<br>&gt; case .Cons(_, let rest):<br>&gt;     reswitch(rest)<br>&gt; case .Empty:<br>&gt;      return false<br>&gt; }<br>&gt;<br>&gt; I like reswitch: in some cases, the compiler could optimize to a<br>&gt; fallthrough, and in others, you could actually re-switch. But maybe I&#39;m<br>&gt; missing something.<br>&gt;<br>&gt; On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can<br>&gt;&gt; be better refined to disallow such cases.<br>&gt;&gt;<br>&gt;&gt; Checking the case statement is not a problem by itself, but can be a<br>&gt;&gt; problem if is coupled with a where clause that is not true when you<br>&gt;&gt; fallthrought.<br>&gt;&gt;<br>&gt;&gt; I’ve written a really bad draft here<br>&gt;&gt; https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try<br>&gt;&gt; to stay on par with this thread but I’m really bad at writing so every help<br>&gt;&gt; is welcome.<br>&gt;&gt;<br>&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this<br>&gt;&gt; proposal so if he wants to take on and then made the official proposal has<br>&gt;&gt; every right to do so and I will be very glad if my gist can be a first<br>&gt;&gt; reference :)<br>&gt;&gt;<br>&gt;&gt; - Jacopo<br>&gt;&gt;<br>&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt; colin at springsandstruts.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for<br>&gt;&gt; your patience in summarizing it again.<br>&gt;&gt;<br>&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a<br>&gt;&gt; whole class of new and creative “foot-guns&quot; :) In particular, it allows<br>&gt;&gt; this construction to loop arbitrarily and creatively, particularly in the<br>&gt;&gt; case of associated values.<br>&gt;&gt;<br>&gt;&gt; I’m not sure why not checking the case statement is considered a problem<br>&gt;&gt; for the fallthrough keyword. Assuming it’s impossible to fallthrough to a<br>&gt;&gt; case that introduces binders (what would they be bound to?), and that this<br>&gt;&gt; is statically checked (both of which seem reasonable assumptions to me,<br>&gt;&gt; although if I’m wrong feel free to correct me), isn’t it the entire point<br>&gt;&gt; of the fallthrough keyword that it skips checking the case statement? I can<br>&gt;&gt; understand how that might be somewhat confusing (and perhaps it should be<br>&gt;&gt; documented less prominently) but I’m not sure how it’s a *problem*,<br>&gt;&gt; exactly...<br>&gt;&gt;<br>&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside<br>&gt;&gt; of doing nothing? For instance in the case of ++ and -- those features<br>&gt;&gt; complicate the design of a numerics library.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; -Colin<br>&gt;&gt;<br>&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;<br>&gt;&gt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;  Hi Colin,<br>&gt;&gt;<br>&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough`<br>&gt;&gt; keyword but many people expressed your similar concern and from that point<br>&gt;&gt; the discussion was steered through an &quot;enhancement&quot; and better refinement<br>&gt;&gt; of the keyword.<br>&gt;&gt;<br>&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the<br>&gt;&gt; desired new value on which the switch is applied.<br>&gt;&gt; So something like this:<br>&gt;&gt;<br>&gt;&gt; switch (enum) {<br>&gt;&gt; case .One:<br>&gt;&gt; // do something<br>&gt;&gt; reswitch .Two<br>&gt;&gt; case .Two:<br>&gt;&gt; // do something else<br>&gt;&gt; default:<br>&gt;&gt; // and so one<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more<br>&gt;&gt; declarative of the developer intent and doesn&#39;t carry over unintentional<br>&gt;&gt; misbehaviour.<br>&gt;&gt; Is more declarative because you are forced to state in which case you<br>&gt;&gt; want to go, and even if the order of the switch’ cases will change in the<br>&gt;&gt; future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;<br>&gt;&gt; switch (enum) {<br>&gt;&gt; case .One:<br>&gt;&gt; // do something<br>&gt;&gt; reswitch .Two<br>&gt;&gt; case .OneAndAHalf<br>&gt;&gt; // maybe this change is not made by you but by a messed up merge<br>&gt;&gt; case .Two:<br>&gt;&gt; // do something else<br>&gt;&gt; default:<br>&gt;&gt; // and so one<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; In this case if you are using the fallthrough keyboard your code is now<br>&gt;&gt; broken by accident, and depending on what are you trying to do inside the<br>&gt;&gt; cases you can have a hidden bug that your tests are not seeing right away.<br>&gt;&gt;<br>&gt;&gt; Another advantage is that in this way you can made more cases fallthrough<br>&gt;&gt; in the same one even if they are not one over each other<br>&gt;&gt;<br>&gt;&gt; switch (enum) {<br>&gt;&gt; case .One:<br>&gt;&gt; // do something<br>&gt;&gt; reswitch .Two<br>&gt;&gt; case .OneAndAHalf<br>&gt;&gt; // so something that you don’t want to do for .One<br>&gt;&gt; reswitch .Two<br>&gt;&gt; case .Two:<br>&gt;&gt; // do something else that you may want to do for .One and .Two<br>&gt;&gt; default:<br>&gt;&gt; // and so one<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I must say that this is a side effect that can be used to messed up the<br>&gt;&gt; code flow in a way that is not intended, but is a new behaviour that gives<br>&gt;&gt; more power to the switch statement.<br>&gt;&gt;<br>&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new<br>&gt;&gt; case without doing the optional checking attached to it, but is intended to<br>&gt;&gt; be a new call and all the check are executed.<br>&gt;&gt;<br>&gt;&gt; switch (enum) {<br>&gt;&gt; case .One:<br>&gt;&gt; // do something<br>&gt;&gt; x = 0;<br>&gt;&gt; reswitch .Two<br>&gt;&gt; case .OneAndAHalf<br>&gt;&gt; // so something that you don’t want to do for .One<br>&gt;&gt; reswitch .Two<br>&gt;&gt; case .Two where x &gt; 0:<br>&gt;&gt; // do something else that you may want to do for .One and .Two<br>&gt;&gt; element = array[x]<br>&gt;&gt; default:<br>&gt;&gt; // and so one<br>&gt;&gt; }<br>&gt;&gt; (I’m going by memory and by writing this snippets in the mail app<br>&gt;&gt; directly, so the code must be incorrect in the syntax and for this I’m<br>&gt;&gt; sorry).<br>&gt;&gt;<br>&gt;&gt; In this case if enum is .One the only case that is executed is case .One<br>&gt;&gt; and the code doesn’t fallthrough in the .Two case because we are made the<br>&gt;&gt; where invalid by changing the x to a value less than 1.<br>&gt;&gt;<br>&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I<br>&gt;&gt; don’t know if he is working on a first draft to lay down the things better,<br>&gt;&gt; but for me this can be a nice improvement and a neat break with the<br>&gt;&gt; C-switch behaviour that Swift has trying to change from the very first beta<br>&gt;&gt; disallowing the implicit fallthrough.<br>&gt;&gt;<br>&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a<br>&gt;&gt; “temporary” implementation for ease the transition from Obj-C to Swift and<br>&gt;&gt; is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;<br>&gt;&gt; - Jacopo<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us<br>&gt;&gt; anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;<br>&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only<br>&gt;&gt; just now subscribed to this list.<br>&gt;&gt;<br>&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve<br>&gt;&gt; also yet to see an example of where it creates a negative impact, either in<br>&gt;&gt; code, optimization, or what have you. Other than “It’s like something in C,<br>&gt;&gt; and C is old and busted” I’m unsure of the rationale for removing it. (Feel<br>&gt;&gt; free to point me in the right direction.)<br>&gt;&gt;<br>&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way<br>&gt;&gt; to define the number of a planet (i.e. its 1-based index in the ordering of<br>&gt;&gt; planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;<br>&gt;&gt; This technique is very extensible — for instance imagine computing the<br>&gt;&gt; force induced by the gravity of the other planets on a particular planet.<br>&gt;&gt; All that would need to change is the case statements.<br>&gt;&gt;<br>&gt;&gt; Yes, you could write this by putting the planets into a list and mapping<br>&gt;&gt; or folding (or looping) over that, but unless the compiler can “unroll”<br>&gt;&gt; that construct, you’re paying for an allocation simply bc of your choice of<br>&gt;&gt; control flow. But in fact, you could imagine generalizing this construct<br>&gt;&gt; into the implementation of fold for the Planet type — low-overhead folds<br>&gt;&gt; for monomorphic types seems like a pretty compelling an natural use case<br>&gt;&gt; for fallthrough to me.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; -Colin<br>&gt;&gt;<br>&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of<br>&gt;&gt; overloading continue with a new syntax.<br>&gt;&gt;<br>&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check<br>&gt;&gt; that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Very much thinking out loud and not really the implications, I wonder if<br>&gt;&gt; we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;<br>&gt;&gt; I very much like specifying what case to fall through into, no matter how<br>&gt;&gt; we spell it.<br>&gt;&gt;<br>&gt;&gt; - Steve<br>&gt;&gt;<br>&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;<br>&gt;&gt; john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow<br>&gt;&gt; natural expression of concepts that exist at the instruction level but are<br>&gt;&gt; otherwise difficult to express with nested control structures.<br>&gt;&gt; `fallthrough` is perhaps slightly less objectionable because control flow<br>&gt;&gt; remains local, but it has a similar role.<br>&gt;&gt;<br>&gt;&gt; It is not particularly natural to write `switch` statements with<br>&gt;&gt; `fallthrough` in the reverse order that can be seen in Duff’s Device and<br>&gt;&gt; similar constructs (case 7 falls through to 6 which falls through to 5,<br>&gt;&gt; etc.). It’s just because you know for certain that all the code in case 6<br>&gt;&gt; would be duplicated in case 7, so 7 can transfer into 6 without a jump<br>&gt;&gt; instruction. Communicating that to the compiler without `fallthrough`<br>&gt;&gt; requires deeply nested `if`s.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might<br>&gt;&gt; parameterize it in the future; parameterized it would mean “repeat the<br>&gt;&gt; switch with this new value”, so that unparameterized fallthrough would mean<br>&gt;&gt; “repeat the switch with a notional value that ends up in the next case”.<br>&gt;&gt; There’s a very common pattern in switches of deferring to another case that<br>&gt;&gt; I’ve always found very awkward to write in C, and while sometimes there’s<br>&gt;&gt; no choice but to extract a helper function, there’s a<br>&gt;&gt; still-fairly-structural code pattern here that I think we can sensibly<br>&gt;&gt; support.<br>&gt;&gt;<br>&gt;&gt; On the other hand, there’s an argument that this is an inappropriate<br>&gt;&gt; extension for “fallthrough” specifically, which is one reason we’ve never<br>&gt;&gt; pursued it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems<br>&gt;&gt; programming. Is writing a threaded interpreter loop within the potential<br>&gt;&gt; scope of Swift? That’s a use case that could make use of both `fallthrough`<br>&gt;&gt; and `goto` (computed goto, really).<br>&gt;&gt;<br>&gt;&gt; switch op {<br>&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;    fallthrough<br>&gt;&gt; case LOAD:<br>&gt;&gt;    out0 = memory[in0]<br>&gt;&gt; //...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I am personally interested in the prospect of a language that can scale<br>&gt;&gt; up to high-level concepts and down to “portable assembler,” but I don’t<br>&gt;&gt; know if that is the right direction for Swift’s evolution.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; John<br>&gt;&gt;<br>&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt; rjmccall at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt; kevin at sb.org&gt; wrote:<br>&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C<br>&gt;&gt; switch statements don&#39;t actually introduce a new scope, and so it overlaps<br>&gt;&gt; a switch with a do-while loop. This lets it only test the number of bytes<br>&gt;&gt; once, to jump into the middle of the loop, and then it switches over to a<br>&gt;&gt; while loop that decrements a counter every 8 instructions. Basically, it&#39;s<br>&gt;&gt; a trick for manual loop unrolling that deals with non-multiple-of-8 counts<br>&gt;&gt; efficiently.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What<br>&gt;&gt; Duff’s Device exploits is that switch is allowed to jump into (almost)<br>&gt;&gt; arbitrary scopes, and cases can appear anywhere recursively inside a<br>&gt;&gt; switch.<br>&gt;&gt;<br>&gt;&gt; But your point that Swift’s switch requires cases to be at the top level<br>&gt;&gt; within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with<br>&gt;&gt; non-multiple-of-8 counts, but it has calculate the number of bytes on every<br>&gt;&gt; iteration instead of once. It&#39;s a good example of one of the uses of<br>&gt;&gt; `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s<br>&gt;&gt; Device in Swift.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;<br>&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place<br>&gt;&gt; where switch fallthrough is arguably the cleanest way to do things and the<br>&gt;&gt; reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt; erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself<br>&gt;&gt; re-factoring to stop using it.<br>&gt;&gt;<br>&gt;&gt; *True fact*: On all of   gist.github.com, there are only 22 gist results<br>&gt;&gt; for &quot;fallthrough language:swift&quot;.<br>&gt;&gt; Half of those are people just testing out the feature. Most of the<br>&gt;&gt; remaining ones are just complex cases:<br>&gt;&gt; *case .Enum1, .Enum2:*<br>&gt;&gt; expressed as<br>&gt;&gt; *case .Enum1: fallthrough*<br>&gt;&gt; *case .Enum2:*<br>&gt;&gt;<br>&gt;&gt; And then there&#39;s streza:<br>&gt;&gt; https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I&#39;m pretty<br>&gt;&gt; sure that ponies were harmed in the production of whatever that last bit<br>&gt;&gt; is.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:<br>&gt;&gt;<br>&gt;&gt; In the spirit of some other proposals that remove C or C++ style<br>&gt;&gt; artifacts, what do folks think about the possibility of removing the<br>&gt;&gt; &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;<br>&gt;&gt; My understanding is this keyword is only used for the archaic seeming<br>&gt;&gt; purpose of perpetuating C-style fallthrough from one switch statement to<br>&gt;&gt; the subsequent one. The documentation hedges the use of this keyword in<br>&gt;&gt; forbidding terms that make it clear its use is not encouraged. The presence<br>&gt;&gt; of the keyword, while an improvement over C’s implicit fallthrough, is a<br>&gt;&gt; mark of inelegance on an otherwise well-designed, opinionated<br>&gt;&gt; implementation of swtich statements.<br>&gt;&gt;<br>&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in<br>&gt;&gt; the documentation:<br>&gt;&gt;<br>&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the<br>&gt;&gt; switch case that it causes execution to fall into. The fallthrough keyword<br>&gt;&gt; simply causes code execution to move directly to the statements inside the<br>&gt;&gt; next case (or default case) block, as in C’s standard switch statement<br>&gt;&gt; behavior.&quot;<br>&gt;&gt;<br>&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both<br>&gt;&gt; in C or Swift: coded that is clearly labeled with deliberate conditions can<br>&gt;&gt; nonetheless be reached.<br>&gt;&gt;<br>&gt;&gt; I quipped about this on Twitter, and the most common pushback I got<br>&gt;&gt; seemed to be from people who either did not know about Swift’s support for<br>&gt;&gt; comma-separated case statements, or harbored an aesthetic preference for<br>&gt;&gt; clustering such cases together with fallthrough statements.<br>&gt;&gt;<br>&gt;&gt; In my opinion, unless somebody can think of a strong defense for<br>&gt;&gt; supporting intentional fallthrough in Swift, removing the keyword would be<br>&gt;&gt; a move in the direction of minimizing the language’s complexity while also<br>&gt;&gt; discouraging poor coding style in switch statements.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; Daniel<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *_______________________________________________*<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/aa1365c7/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ab8ff5d36ad4f40d7905509956e5c706?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Jacopo Andrea Giola</string> &lt;swift-evolution at jacopo.giola.org&gt;<p>December  6, 2015 at 10:00:00pm</p></header><div class="content"><p>The result is .Two, because you are returning from the reswitch and in that case the original x is shadowed by the new execution.<br></p><p>- Jacopo<br></p><p>&gt; On 06 Dec 2015, at 22:36, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; One question: what is the result of this code?<br>&gt; <br>&gt; let x = .One<br>&gt; <br>&gt; switch x {<br>&gt; case .One:<br>&gt;    reswitch(.Two)<br>&gt; case .Two:<br>&gt;    return x<br>&gt; }<br>&gt; <br>&gt; .One or .Two? In other words, is x rebound inside the switch when we reswitch?<br>&gt; <br>&gt; On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew &lt;alexl.mail+swift at gmail.com &lt;mailto:alexl.mail+swift at gmail.com&gt;&gt; wrote:<br>&gt; It seems reswitch should be useable even in cases that aren&#39;t a simple &quot;goto&quot;. Or am I missing something?<br>&gt; <br>&gt; For instance, rewriting the example from earlier:<br>&gt; <br>&gt; switch op {<br>&gt; case let .LOAD_INDIRECT(out, in):<br>&gt;     reswitch(.LOAD(out, memory[in]))<br>&gt; case let .LOAD(out, in):<br>&gt;     setReg(out, in)<br>&gt; // ...<br>&gt; }<br>&gt; <br>&gt; or, a switch that calculates whether some number n is in a Lisp-style list of numbers<br>&gt; <br>&gt; switch lst {<br>&gt; case .Cons(let m, _) where m == n:<br>&gt;      return true<br>&gt; case .Cons(_, let rest):<br>&gt;     reswitch(rest)<br>&gt; case .Empty:<br>&gt;      return false<br>&gt; }<br>&gt; <br>&gt; I like reswitch: in some cases, the compiler could optimize to a fallthrough, and in others, you could actually re-switch. But maybe I&#39;m missing something.<br>&gt; <br>&gt; On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt; <br>&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt; <br>&gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 &lt;https://gist.github.com/JGiola/f735212789bf2f697847&gt;<br>&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt; <br>&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt; <br>&gt; - Jacopo<br>&gt; <br>&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt; colin at springsandstruts.com &lt;mailto:colin at springsandstruts.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt;&gt; <br>&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt;&gt; <br>&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt;&gt; <br>&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; -Colin<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt; swift-evolution at jacopo.giola.org &lt;mailto:swift-evolution at jacopo.giola.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;  // do something else<br>&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;  // maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;  // do something else<br>&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;  // so something that you don’t want to do for .One<br>&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;  // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;  x = 0;<br>&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;  // so something that you don’t want to do for .One<br>&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;  case .Two where x &gt; 0:<br>&gt;&gt;&gt;  // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;  element = array[x]<br>&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Jacopo <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt; john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt; rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt; kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt; erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of   gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:   https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;    I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt;  wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language? <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts? <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt; <br>&gt; <br>&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/51bacbae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  6, 2015 at 04:00:00pm</p></header><div class="content"><p>Makes sense! So what about this case?<br></p><p>var x = 1<br>switch x {<br>case 1:<br>     reswitch(2)<br>default:<br>     x += 1<br>}<br>print(x)<br></p><p>Does that print 1?<br></p><p>On Sun, Dec 6, 2015 at 4:49 PM, Jacopo Andrea Giola &lt;<br>swift-evolution at jacopo.giola.org&gt; wrote:<br></p><p>&gt; The result is .Two, because you are returning from the reswitch and in<br>&gt; that case the original x is shadowed by the new execution.<br>&gt;<br>&gt; - Jacopo<br>&gt;<br>&gt; On 06 Dec 2015, at 22:36, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt;<br>&gt; One question: what is the result of this code?<br>&gt;<br>&gt; let x = .One<br>&gt;<br>&gt; switch x {<br>&gt; case .One:<br>&gt;    reswitch(.Two)<br>&gt; case .Two:<br>&gt;    return x<br>&gt; }<br>&gt;<br>&gt; .One or .Two? In other words, is x rebound inside the switch when we<br>&gt; reswitch?<br>&gt;<br>&gt; On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew &lt;alexl.mail+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; It seems reswitch *should* be useable even in cases that aren&#39;t a simple<br>&gt;&gt; &quot;goto&quot;. Or am I missing something?<br>&gt;&gt;<br>&gt;&gt; For instance, rewriting the example from earlier:<br>&gt;&gt;<br>&gt;&gt; switch op {<br>&gt;&gt; case let .LOAD_INDIRECT(out, in):<br>&gt;&gt;     reswitch(.LOAD(out, memory[in]))<br>&gt;&gt; case let .LOAD(out, in):<br>&gt;&gt;     setReg(out, in)<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; or, a switch that calculates whether some number n is in a Lisp-style<br>&gt;&gt; list of numbers<br>&gt;&gt;<br>&gt;&gt; switch lst {<br>&gt;&gt; case .Cons(let m, _) where m == n:<br>&gt;&gt;      return true<br>&gt;&gt; case .Cons(_, let rest):<br>&gt;&gt;     reswitch(rest)<br>&gt;&gt; case .Empty:<br>&gt;&gt;      return false<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I like reswitch: in some cases, the compiler could optimize to a<br>&gt;&gt; fallthrough, and in others, you could actually re-switch. But maybe I&#39;m<br>&gt;&gt; missing something.<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe<br>&gt;&gt;&gt; can be better refined to disallow such cases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Checking the case statement is not a problem by itself, but can be a<br>&gt;&gt;&gt; problem if is coupled with a where clause that is not true when you<br>&gt;&gt;&gt; fallthrought.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve written a really bad draft here<br>&gt;&gt;&gt; https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try<br>&gt;&gt;&gt; to stay on par with this thread but I’m really bad at writing so every help<br>&gt;&gt;&gt; is welcome.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this<br>&gt;&gt;&gt; proposal so if he wants to take on and then made the official proposal has<br>&gt;&gt;&gt; every right to do so and I will be very glad if my gist can be a first<br>&gt;&gt;&gt; reference :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt; colin at springsandstruts.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for<br>&gt;&gt;&gt; your patience in summarizing it again.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a<br>&gt;&gt;&gt; whole class of new and creative “foot-guns&quot; :) In particular, it allows<br>&gt;&gt;&gt; this construction to loop arbitrarily and creatively, particularly in the<br>&gt;&gt;&gt; case of associated values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a problem<br>&gt;&gt;&gt; for the fallthrough keyword. Assuming it’s impossible to fallthrough to a<br>&gt;&gt;&gt; case that introduces binders (what would they be bound to?), and that this<br>&gt;&gt;&gt; is statically checked (both of which seem reasonable assumptions to me,<br>&gt;&gt;&gt; although if I’m wrong feel free to correct me), isn’t it the entire point<br>&gt;&gt;&gt; of the fallthrough keyword that it skips checking the case statement? I can<br>&gt;&gt;&gt; understand how that might be somewhat confusing (and perhaps it should be<br>&gt;&gt;&gt; documented less prominently) but I’m not sure how it’s a *problem*,<br>&gt;&gt;&gt; exactly...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the<br>&gt;&gt;&gt; downside of doing nothing? For instance in the case of ++ and -- those<br>&gt;&gt;&gt; features complicate the design of a numerics library.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;<br>&gt;&gt;&gt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough`<br>&gt;&gt;&gt; keyword but many people expressed your similar concern and from that point<br>&gt;&gt;&gt; the discussion was steered through an &quot;enhancement&quot; and better refinement<br>&gt;&gt;&gt; of the keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing<br>&gt;&gt;&gt; the desired new value on which the switch is applied.<br>&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; case .One:<br>&gt;&gt;&gt; // do something<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .Two:<br>&gt;&gt;&gt; // do something else<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more<br>&gt;&gt;&gt; declarative of the developer intent and doesn&#39;t carry over unintentional<br>&gt;&gt;&gt; misbehaviour.<br>&gt;&gt;&gt; Is more declarative because you are forced to state in which case you<br>&gt;&gt;&gt; want to go, and even if the order of the switch’ cases will change in the<br>&gt;&gt;&gt; future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; case .One:<br>&gt;&gt;&gt; // do something<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .OneAndAHalf<br>&gt;&gt;&gt; // maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt; case .Two:<br>&gt;&gt;&gt; // do something else<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now<br>&gt;&gt;&gt; broken by accident, and depending on what are you trying to do inside the<br>&gt;&gt;&gt; cases you can have a hidden bug that your tests are not seeing right away.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another advantage is that in this way you can made more<br>&gt;&gt;&gt; cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; case .One:<br>&gt;&gt;&gt; // do something<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .OneAndAHalf<br>&gt;&gt;&gt; // so something that you don’t want to do for .One<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .Two:<br>&gt;&gt;&gt; // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the<br>&gt;&gt;&gt; code flow in a way that is not intended, but is a new behaviour that gives<br>&gt;&gt;&gt; more power to the switch statement.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new<br>&gt;&gt;&gt; case without doing the optional checking attached to it, but is intended to<br>&gt;&gt;&gt; be a new call and all the check are executed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; case .One:<br>&gt;&gt;&gt; // do something<br>&gt;&gt;&gt; x = 0;<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .OneAndAHalf<br>&gt;&gt;&gt; // so something that you don’t want to do for .One<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .Two where x &gt; 0:<br>&gt;&gt;&gt; // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt; element = array[x]<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app<br>&gt;&gt;&gt; directly, so the code must be incorrect in the syntax and for this I’m<br>&gt;&gt;&gt; sorry).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One<br>&gt;&gt;&gt; and the code doesn’t fallthrough in the .Two case because we are made the<br>&gt;&gt;&gt; where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I<br>&gt;&gt;&gt; don’t know if he is working on a first draft to lay down the things better,<br>&gt;&gt;&gt; but for me this can be a nice improvement and a neat break with the<br>&gt;&gt;&gt; C-switch behaviour that Swift has trying to change from the very first beta<br>&gt;&gt;&gt; disallowing the implicit fallthrough.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a<br>&gt;&gt;&gt; “temporary” implementation for ease the transition from Obj-C to Swift and<br>&gt;&gt;&gt; is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us<br>&gt;&gt;&gt; anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve<br>&gt;&gt;&gt; only just now subscribed to this list.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve<br>&gt;&gt;&gt; also yet to see an example of where it creates a negative impact, either in<br>&gt;&gt;&gt; code, optimization, or what have you. Other than “It’s like something in C,<br>&gt;&gt;&gt; and C is old and busted” I’m unsure of the rationale for removing it. (Feel<br>&gt;&gt;&gt; free to point me in the right direction.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way<br>&gt;&gt;&gt; to define the number of a planet (i.e. its 1-based index in the ordering of<br>&gt;&gt;&gt; planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the<br>&gt;&gt;&gt; force induced by the gravity of the other planets on a particular planet.<br>&gt;&gt;&gt; All that would need to change is the case statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping<br>&gt;&gt;&gt; or folding (or looping) over that, but unless the compiler can “unroll”<br>&gt;&gt;&gt; that construct, you’re paying for an allocation simply bc of your choice of<br>&gt;&gt;&gt; control flow. But in fact, you could imagine generalizing this construct<br>&gt;&gt;&gt; into the implementation of fold for the Planet type — low-overhead folds<br>&gt;&gt;&gt; for monomorphic types seems like a pretty compelling an natural use case<br>&gt;&gt;&gt; for fallthrough to me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of<br>&gt;&gt;&gt; overloading continue with a new syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check<br>&gt;&gt;&gt; that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if<br>&gt;&gt;&gt; we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter<br>&gt;&gt;&gt; how we spell it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;<br>&gt;&gt;&gt; john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow<br>&gt;&gt;&gt; natural expression of concepts that exist at the instruction level but are<br>&gt;&gt;&gt; otherwise difficult to express with nested control structures.<br>&gt;&gt;&gt; `fallthrough` is perhaps slightly less objectionable because control flow<br>&gt;&gt;&gt; remains local, but it has a similar role.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is not particularly natural to write `switch` statements with<br>&gt;&gt;&gt; `fallthrough` in the reverse order that can be seen in Duff’s Device and<br>&gt;&gt;&gt; similar constructs (case 7 falls through to 6 which falls through to 5,<br>&gt;&gt;&gt; etc.). It’s just because you know for certain that all the code in case 6<br>&gt;&gt;&gt; would be duplicated in case 7, so 7 can transfer into 6 without a jump<br>&gt;&gt;&gt; instruction. Communicating that to the compiler without `fallthrough`<br>&gt;&gt;&gt; requires deeply nested `if`s.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might<br>&gt;&gt;&gt; parameterize it in the future; parameterized it would mean “repeat the<br>&gt;&gt;&gt; switch with this new value”, so that unparameterized fallthrough would mean<br>&gt;&gt;&gt; “repeat the switch with a notional value that ends up in the next case”.<br>&gt;&gt;&gt; There’s a very common pattern in switches of deferring to another case that<br>&gt;&gt;&gt; I’ve always found very awkward to write in C, and while sometimes there’s<br>&gt;&gt;&gt; no choice but to extract a helper function, there’s a<br>&gt;&gt;&gt; still-fairly-structural code pattern here that I think we can sensibly<br>&gt;&gt;&gt; support.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate<br>&gt;&gt;&gt; extension for “fallthrough” specifically, which is one reason we’ve never<br>&gt;&gt;&gt; pursued it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems<br>&gt;&gt;&gt; programming. Is writing a threaded interpreter loop within the potential<br>&gt;&gt;&gt; scope of Swift? That’s a use case that could make use of both `fallthrough`<br>&gt;&gt;&gt; and `goto` (computed goto, really).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale<br>&gt;&gt;&gt; up to high-level concepts and down to “portable assembler,” but I don’t<br>&gt;&gt;&gt; know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; John<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt; rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt; kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C<br>&gt;&gt;&gt; switch statements don&#39;t actually introduce a new scope, and so it overlaps<br>&gt;&gt;&gt; a switch with a do-while loop. This lets it only test the number of bytes<br>&gt;&gt;&gt; once, to jump into the middle of the loop, and then it switches over to a<br>&gt;&gt;&gt; while loop that decrements a counter every 8 instructions. Basically, it&#39;s<br>&gt;&gt;&gt; a trick for manual loop unrolling that deals with non-multiple-of-8 counts<br>&gt;&gt;&gt; efficiently.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What<br>&gt;&gt;&gt; Duff’s Device exploits is that switch is allowed to jump into (almost)<br>&gt;&gt;&gt; arbitrary scopes, and cases can appear anywhere recursively inside a<br>&gt;&gt;&gt; switch.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level<br>&gt;&gt;&gt; within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with<br>&gt;&gt;&gt; non-multiple-of-8 counts, but it has calculate the number of bytes on every<br>&gt;&gt;&gt; iteration instead of once. It&#39;s a good example of one of the uses of<br>&gt;&gt;&gt; `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s<br>&gt;&gt;&gt; Device in Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big<br>&gt;&gt;&gt; place where switch fallthrough is arguably the cleanest way to do things<br>&gt;&gt;&gt; and the reason why I’d personally prefer to keep it as part of the<br>&gt;&gt;&gt; language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt; erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself<br>&gt;&gt;&gt; re-factoring to stop using it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *True fact*: On all of   gist.github.com, there are only 22 gist<br>&gt;&gt;&gt; results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the<br>&gt;&gt;&gt; remaining ones are just complex cases:<br>&gt;&gt;&gt; *case .Enum1, .Enum2:*<br>&gt;&gt;&gt; expressed as<br>&gt;&gt;&gt; *case .Enum1: fallthrough*<br>&gt;&gt;&gt; *case .Enum2:*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And then there&#39;s streza:<br>&gt;&gt;&gt; https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I&#39;m pretty<br>&gt;&gt;&gt; sure that ponies were harmed in the production of whatever that last bit<br>&gt;&gt;&gt; is.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style<br>&gt;&gt;&gt; artifacts, what do folks think about the possibility of removing the<br>&gt;&gt;&gt; &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming<br>&gt;&gt;&gt; purpose of perpetuating C-style fallthrough from one switch statement to<br>&gt;&gt;&gt; the subsequent one. The documentation hedges the use of this keyword in<br>&gt;&gt;&gt; forbidding terms that make it clear its use is not encouraged. The presence<br>&gt;&gt;&gt; of the keyword, while an improvement over C’s implicit fallthrough, is a<br>&gt;&gt;&gt; mark of inelegance on an otherwise well-designed, opinionated<br>&gt;&gt;&gt; implementation of swtich statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in<br>&gt;&gt;&gt; the documentation:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the<br>&gt;&gt;&gt; switch case that it causes execution to fall into. The fallthrough keyword<br>&gt;&gt;&gt; simply causes code execution to move directly to the statements inside the<br>&gt;&gt;&gt; next case (or default case) block, as in C’s standard switch statement<br>&gt;&gt;&gt; behavior.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough,<br>&gt;&gt;&gt; both in C or Swift: coded that is clearly labeled with deliberate<br>&gt;&gt;&gt; conditions can nonetheless be reached.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got<br>&gt;&gt;&gt; seemed to be from people who either did not know about Swift’s support for<br>&gt;&gt;&gt; comma-separated case statements, or harbored an aesthetic preference for<br>&gt;&gt;&gt; clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for<br>&gt;&gt;&gt; supporting intentional fallthrough in Swift, removing the keyword would be<br>&gt;&gt;&gt; a move in the direction of minimizing the language’s complexity while also<br>&gt;&gt;&gt; discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *_______________________________________________*<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/39d591f4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>December  6, 2015 at 04:00:00pm</p></header><div class="content"><p>If you need control flow this complex, why not just use recursion? reswitch is, near as I can tell, a recursive call to an implicitly defined function (closing over the switch).<br></p><p>-Colin <br></p><p>&gt; On Dec 6, 2015, at 4:49 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt; <br>&gt; The result is .Two, because you are returning from the reswitch and in that case the original x is shadowed by the new execution.<br>&gt; <br>&gt; - Jacopo<br>&gt; <br>&gt;&gt; On 06 Dec 2015, at 22:36, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One question: what is the result of this code?<br>&gt;&gt; <br>&gt;&gt; let x = .One<br>&gt;&gt; <br>&gt;&gt; switch x {<br>&gt;&gt; case .One:<br>&gt;&gt;    reswitch(.Two)<br>&gt;&gt; case .Two:<br>&gt;&gt;    return x<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; .One or .Two? In other words, is x rebound inside the switch when we reswitch?<br>&gt;&gt; <br>&gt;&gt;&gt; On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt;&gt;&gt; It seems reswitch should be useable even in cases that aren&#39;t a simple &quot;goto&quot;. Or am I missing something?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For instance, rewriting the example from earlier:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt; case let .LOAD_INDIRECT(out, in):<br>&gt;&gt;&gt;     reswitch(.LOAD(out, memory[in]))<br>&gt;&gt;&gt; case let .LOAD(out, in):<br>&gt;&gt;&gt;     setReg(out, in)<br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, a switch that calculates whether some number n is in a Lisp-style list of numbers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch lst {<br>&gt;&gt;&gt; case .Cons(let m, _) where m == n:<br>&gt;&gt;&gt;      return true<br>&gt;&gt;&gt; case .Cons(_, let rest):<br>&gt;&gt;&gt;     reswitch(rest)<br>&gt;&gt;&gt; case .Empty:<br>&gt;&gt;&gt;      return false<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like reswitch: in some cases, the compiler could optimize to a fallthrough, and in others, you could actually re-switch. But maybe I&#39;m missing something.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;&gt;&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt; colin at springsandstruts.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt;&gt;&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something else<br>&gt;&gt;&gt;&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt;&gt;&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt;&gt;  // maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something else<br>&gt;&gt;&gt;&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt;&gt;  // so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.           <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;&gt;&gt;&gt;  x = 0;<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt;&gt;  // so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .Two where x &gt; 0:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  element = array[x]<br>&gt;&gt;&gt;&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Jacopo <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt; swift-evolution at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This technique is very extensible ― for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type ― low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt; swift-evolution at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt; swift-evolution at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt; john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt; rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt; kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt; erica at ericasadun.com&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of   gist.github.com, there are only 22 gist results for &quot;fallthrough language:swift&quot;. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:   https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?                                               <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts? <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Untracked with Trackbuster<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4300b382/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  6, 2015 at 05:00:00pm</p></header><div class="content"><p>Yes, thanks, Colin -- semantically, I think it&#39;s exactly equivalent to a<br>recursive call to an implicitly defined function closing over the switch.<br>In practice, the compiler may be able to translate it to a true fallthrough<br>in many cases.<br></p><p>In any case, I am not arguing for or against reswitch -- I kind of like it,<br>but also would be fine with keeping fallthrough as is. I just wanted to<br>better understand what the proposed semantics of reswitch actually were<br>(hence the var x question, which I guess would be similar to having your<br>recursive function declare a mutable parameter).<br></p><p>On Sun, Dec 6, 2015 at 4:57 PM, Colin Barrett &lt;colin at springsandstruts.com&gt;<br>wrote:<br></p><p>&gt; If you need control flow this complex, why not just use recursion?<br>&gt; reswitch is, near as I can tell, a recursive call to an implicitly defined<br>&gt; function (closing over the switch).<br>&gt;<br>&gt; -Colin<br>&gt;<br>&gt; On Dec 6, 2015, at 4:49 PM, Jacopo Andrea Giola &lt;<br>&gt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;<br>&gt; The result is .Two, because you are returning from the reswitch and in<br>&gt; that case the original x is shadowed by the new execution.<br>&gt;<br>&gt; - Jacopo<br>&gt;<br>&gt; On 06 Dec 2015, at 22:36, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt;<br>&gt; One question: what is the result of this code?<br>&gt;<br>&gt; let x = .One<br>&gt;<br>&gt; switch x {<br>&gt; case .One:<br>&gt;    reswitch(.Two)<br>&gt; case .Two:<br>&gt;    return x<br>&gt; }<br>&gt;<br>&gt; .One or .Two? In other words, is x rebound inside the switch when we<br>&gt; reswitch?<br>&gt;<br>&gt; On Sun, Dec 6, 2015 at 4:28 PM, Alex Lew &lt;alexl.mail+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; It seems reswitch *should* be useable even in cases that aren&#39;t a simple<br>&gt;&gt; &quot;goto&quot;. Or am I missing something?<br>&gt;&gt;<br>&gt;&gt; For instance, rewriting the example from earlier:<br>&gt;&gt;<br>&gt;&gt; switch op {<br>&gt;&gt; case let .LOAD_INDIRECT(out, in):<br>&gt;&gt;     reswitch(.LOAD(out, memory[in]))<br>&gt;&gt; case let .LOAD(out, in):<br>&gt;&gt;     setReg(out, in)<br>&gt;&gt; // ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; or, a switch that calculates whether some number n is in a Lisp-style<br>&gt;&gt; list of numbers<br>&gt;&gt;<br>&gt;&gt; switch lst {<br>&gt;&gt; case .Cons(let m, _) where m == n:<br>&gt;&gt;      return true<br>&gt;&gt; case .Cons(_, let rest):<br>&gt;&gt;     reswitch(rest)<br>&gt;&gt; case .Empty:<br>&gt;&gt;      return false<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I like reswitch: in some cases, the compiler could optimize to a<br>&gt;&gt; fallthrough, and in others, you could actually re-switch. But maybe I&#39;m<br>&gt;&gt; missing something.<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 6, 2015 at 4:14 PM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe<br>&gt;&gt;&gt; can be better refined to disallow such cases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Checking the case statement is not a problem by itself, but can be a<br>&gt;&gt;&gt; problem if is coupled with a where clause that is not true when you<br>&gt;&gt;&gt; fallthrought.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve written a really bad draft here<br>&gt;&gt;&gt; https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try<br>&gt;&gt;&gt; to stay on par with this thread but I’m really bad at writing so every help<br>&gt;&gt;&gt; is welcome.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this<br>&gt;&gt;&gt; proposal so if he wants to take on and then made the official proposal has<br>&gt;&gt;&gt; every right to do so and I will be very glad if my gist can be a first<br>&gt;&gt;&gt; reference :)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt; colin at springsandstruts.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for<br>&gt;&gt;&gt; your patience in summarizing it again.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a<br>&gt;&gt;&gt; whole class of new and creative “foot-guns&quot; :) In particular, it allows<br>&gt;&gt;&gt; this construction to loop arbitrarily and creatively, particularly in the<br>&gt;&gt;&gt; case of associated values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a problem<br>&gt;&gt;&gt; for the fallthrough keyword. Assuming it’s impossible to fallthrough to a<br>&gt;&gt;&gt; case that introduces binders (what would they be bound to?), and that this<br>&gt;&gt;&gt; is statically checked (both of which seem reasonable assumptions to me,<br>&gt;&gt;&gt; although if I’m wrong feel free to correct me), isn’t it the entire point<br>&gt;&gt;&gt; of the fallthrough keyword that it skips checking the case statement? I can<br>&gt;&gt;&gt; understand how that might be somewhat confusing (and perhaps it should be<br>&gt;&gt;&gt; documented less prominently) but I’m not sure how it’s a *problem*,<br>&gt;&gt;&gt; exactly...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the<br>&gt;&gt;&gt; downside of doing nothing? For instance in the case of ++ and -- those<br>&gt;&gt;&gt; features complicate the design of a numerics library.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;<br>&gt;&gt;&gt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough`<br>&gt;&gt;&gt; keyword but many people expressed your similar concern and from that point<br>&gt;&gt;&gt; the discussion was steered through an &quot;enhancement&quot; and better refinement<br>&gt;&gt;&gt; of the keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing<br>&gt;&gt;&gt; the desired new value on which the switch is applied.<br>&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; case .One:<br>&gt;&gt;&gt; // do something<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .Two:<br>&gt;&gt;&gt; // do something else<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more<br>&gt;&gt;&gt; declarative of the developer intent and doesn&#39;t carry over unintentional<br>&gt;&gt;&gt; misbehaviour.<br>&gt;&gt;&gt; Is more declarative because you are forced to state in which case you<br>&gt;&gt;&gt; want to go, and even if the order of the switch’ cases will change in the<br>&gt;&gt;&gt; future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; case .One:<br>&gt;&gt;&gt; // do something<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .OneAndAHalf<br>&gt;&gt;&gt; // maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt; case .Two:<br>&gt;&gt;&gt; // do something else<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now<br>&gt;&gt;&gt; broken by accident, and depending on what are you trying to do inside the<br>&gt;&gt;&gt; cases you can have a hidden bug that your tests are not seeing right away.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another advantage is that in this way you can made more<br>&gt;&gt;&gt; cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; case .One:<br>&gt;&gt;&gt; // do something<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .OneAndAHalf<br>&gt;&gt;&gt; // so something that you don’t want to do for .One<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .Two:<br>&gt;&gt;&gt; // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the<br>&gt;&gt;&gt; code flow in a way that is not intended, but is a new behaviour that gives<br>&gt;&gt;&gt; more power to the switch statement.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new<br>&gt;&gt;&gt; case without doing the optional checking attached to it, but is intended to<br>&gt;&gt;&gt; be a new call and all the check are executed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; case .One:<br>&gt;&gt;&gt; // do something<br>&gt;&gt;&gt; x = 0;<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .OneAndAHalf<br>&gt;&gt;&gt; // so something that you don’t want to do for .One<br>&gt;&gt;&gt; reswitch .Two<br>&gt;&gt;&gt; case .Two where x &gt; 0:<br>&gt;&gt;&gt; // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt; element = array[x]<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; // and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app<br>&gt;&gt;&gt; directly, so the code must be incorrect in the syntax and for this I’m<br>&gt;&gt;&gt; sorry).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One<br>&gt;&gt;&gt; and the code doesn’t fallthrough in the .Two case because we are made the<br>&gt;&gt;&gt; where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I<br>&gt;&gt;&gt; don’t know if he is working on a first draft to lay down the things better,<br>&gt;&gt;&gt; but for me this can be a nice improvement and a neat break with the<br>&gt;&gt;&gt; C-switch behaviour that Swift has trying to change from the very first beta<br>&gt;&gt;&gt; disallowing the implicit fallthrough.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a<br>&gt;&gt;&gt; “temporary” implementation for ease the transition from Obj-C to Swift and<br>&gt;&gt;&gt; is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us<br>&gt;&gt;&gt; anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve<br>&gt;&gt;&gt; only just now subscribed to this list.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve<br>&gt;&gt;&gt; also yet to see an example of where it creates a negative impact, either in<br>&gt;&gt;&gt; code, optimization, or what have you. Other than “It’s like something in C,<br>&gt;&gt;&gt; and C is old and busted” I’m unsure of the rationale for removing it. (Feel<br>&gt;&gt;&gt; free to point me in the right direction.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way<br>&gt;&gt;&gt; to define the number of a planet (i.e. its 1-based index in the ordering of<br>&gt;&gt;&gt; planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the<br>&gt;&gt;&gt; force induced by the gravity of the other planets on a particular planet.<br>&gt;&gt;&gt; All that would need to change is the case statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping<br>&gt;&gt;&gt; or folding (or looping) over that, but unless the compiler can “unroll”<br>&gt;&gt;&gt; that construct, you’re paying for an allocation simply bc of your choice of<br>&gt;&gt;&gt; control flow. But in fact, you could imagine generalizing this construct<br>&gt;&gt;&gt; into the implementation of fold for the Planet type — low-overhead folds<br>&gt;&gt;&gt; for monomorphic types seems like a pretty compelling an natural use case<br>&gt;&gt;&gt; for fallthrough to me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of<br>&gt;&gt;&gt; overloading continue with a new syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check<br>&gt;&gt;&gt; that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if<br>&gt;&gt;&gt; we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter<br>&gt;&gt;&gt; how we spell it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;<br>&gt;&gt;&gt; john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow<br>&gt;&gt;&gt; natural expression of concepts that exist at the instruction level but are<br>&gt;&gt;&gt; otherwise difficult to express with nested control structures.<br>&gt;&gt;&gt; `fallthrough` is perhaps slightly less objectionable because control flow<br>&gt;&gt;&gt; remains local, but it has a similar role.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is not particularly natural to write `switch` statements with<br>&gt;&gt;&gt; `fallthrough` in the reverse order that can be seen in Duff’s Device and<br>&gt;&gt;&gt; similar constructs (case 7 falls through to 6 which falls through to 5,<br>&gt;&gt;&gt; etc.). It’s just because you know for certain that all the code in case 6<br>&gt;&gt;&gt; would be duplicated in case 7, so 7 can transfer into 6 without a jump<br>&gt;&gt;&gt; instruction. Communicating that to the compiler without `fallthrough`<br>&gt;&gt;&gt; requires deeply nested `if`s.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might<br>&gt;&gt;&gt; parameterize it in the future; parameterized it would mean “repeat the<br>&gt;&gt;&gt; switch with this new value”, so that unparameterized fallthrough would mean<br>&gt;&gt;&gt; “repeat the switch with a notional value that ends up in the next case”.<br>&gt;&gt;&gt; There’s a very common pattern in switches of deferring to another case that<br>&gt;&gt;&gt; I’ve always found very awkward to write in C, and while sometimes there’s<br>&gt;&gt;&gt; no choice but to extract a helper function, there’s a<br>&gt;&gt;&gt; still-fairly-structural code pattern here that I think we can sensibly<br>&gt;&gt;&gt; support.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate<br>&gt;&gt;&gt; extension for “fallthrough” specifically, which is one reason we’ve never<br>&gt;&gt;&gt; pursued it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems<br>&gt;&gt;&gt; programming. Is writing a threaded interpreter loop within the potential<br>&gt;&gt;&gt; scope of Swift? That’s a use case that could make use of both `fallthrough`<br>&gt;&gt;&gt; and `goto` (computed goto, really).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale<br>&gt;&gt;&gt; up to high-level concepts and down to “portable assembler,” but I don’t<br>&gt;&gt;&gt; know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; John<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt; rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt; kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C<br>&gt;&gt;&gt; switch statements don&#39;t actually introduce a new scope, and so it overlaps<br>&gt;&gt;&gt; a switch with a do-while loop. This lets it only test the number of bytes<br>&gt;&gt;&gt; once, to jump into the middle of the loop, and then it switches over to a<br>&gt;&gt;&gt; while loop that decrements a counter every 8 instructions. Basically, it&#39;s<br>&gt;&gt;&gt; a trick for manual loop unrolling that deals with non-multiple-of-8 counts<br>&gt;&gt;&gt; efficiently.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What<br>&gt;&gt;&gt; Duff’s Device exploits is that switch is allowed to jump into (almost)<br>&gt;&gt;&gt; arbitrary scopes, and cases can appear anywhere recursively inside a<br>&gt;&gt;&gt; switch.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level<br>&gt;&gt;&gt; within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with<br>&gt;&gt;&gt; non-multiple-of-8 counts, but it has calculate the number of bytes on every<br>&gt;&gt;&gt; iteration instead of once. It&#39;s a good example of one of the uses of<br>&gt;&gt;&gt; `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s<br>&gt;&gt;&gt; Device in Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big<br>&gt;&gt;&gt; place where switch fallthrough is arguably the cleanest way to do things<br>&gt;&gt;&gt; and the reason why I’d personally prefer to keep it as part of the<br>&gt;&gt;&gt; language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt; erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself<br>&gt;&gt;&gt; re-factoring to stop using it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *True fact*: On all of   gist.github.com, there are only 22 gist<br>&gt;&gt;&gt; results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the<br>&gt;&gt;&gt; remaining ones are just complex cases:<br>&gt;&gt;&gt; *case .Enum1, .Enum2:*<br>&gt;&gt;&gt; expressed as<br>&gt;&gt;&gt; *case .Enum1: fallthrough*<br>&gt;&gt;&gt; *case .Enum2:*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And then there&#39;s streza:<br>&gt;&gt;&gt; https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I&#39;m pretty<br>&gt;&gt;&gt; sure that ponies were harmed in the production of whatever that last bit<br>&gt;&gt;&gt; is.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style<br>&gt;&gt;&gt; artifacts, what do folks think about the possibility of removing the<br>&gt;&gt;&gt; &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming<br>&gt;&gt;&gt; purpose of perpetuating C-style fallthrough from one switch statement to<br>&gt;&gt;&gt; the subsequent one. The documentation hedges the use of this keyword in<br>&gt;&gt;&gt; forbidding terms that make it clear its use is not encouraged. The presence<br>&gt;&gt;&gt; of the keyword, while an improvement over C’s implicit fallthrough, is a<br>&gt;&gt;&gt; mark of inelegance on an otherwise well-designed, opinionated<br>&gt;&gt;&gt; implementation of swtich statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in<br>&gt;&gt;&gt; the documentation:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the<br>&gt;&gt;&gt; switch case that it causes execution to fall into. The fallthrough keyword<br>&gt;&gt;&gt; simply causes code execution to move directly to the statements inside the<br>&gt;&gt;&gt; next case (or default case) block, as in C’s standard switch statement<br>&gt;&gt;&gt; behavior.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough,<br>&gt;&gt;&gt; both in C or Swift: coded that is clearly labeled with deliberate<br>&gt;&gt;&gt; conditions can nonetheless be reached.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got<br>&gt;&gt;&gt; seemed to be from people who either did not know about Swift’s support for<br>&gt;&gt;&gt; comma-separated case statements, or harbored an aesthetic preference for<br>&gt;&gt;&gt; clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for<br>&gt;&gt;&gt; supporting intentional fallthrough in Swift, removing the keyword would be<br>&gt;&gt;&gt; a move in the direction of minimizing the language’s complexity while also<br>&gt;&gt;&gt; discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *_______________________________________________*<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/9d92b0c2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December  6, 2015 at 11:00:00pm</p></header><div class="content"><p>Initially I thought that reswitch (apart from the name :-) looked nice the example of Alex  seems to mix two parts of a recursive algorithm into one statement: pattern matching the head of a list and recursing.<br></p><p>Then I realized that instead of introducing reswitch you can simply extract the switch into a method and call that recursively. This would have the added benefit that instead of &quot;reswitch&quot; the (hopefully) expressive name of the function would be used, making the intent clearer:<br></p><p>func find(n: T, in list: List&lt;T&gt;) -&gt; Bool {<br>    switch list {<br>    case .Cons(let m, _) where m == n:<br>        return true<br>    case .Cons(_, let rest):<br>        return find(n, in: rest)<br>    case .Empty:<br>        return false<br>    }<br>}<br></p><p>-Thorsten <br></p><p>&gt; Am 06.12.2015 um 22:28 schrieb Alex Lew via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; switch lst {<br>&gt; case .Cons(let m, _) where m == n:<br>&gt;      return true<br>&gt; case .Cons(_, let rest):<br>&gt;     reswitch(rest)<br>&gt; case .Empty:<br>&gt;      return false<br>&gt; }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/28e4cb62/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2773fb278535f8d2f0c193800a3b8e09?s=50"></div><header><strong>(5.391):Re: Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>jalkut at red-sweater.com</string> &lt;jalkut at red-sweater.com&gt;<p>December  6, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 4:14 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt; <br></p><p>Hi Jacopo - I have been interested to read the counter-arguments to my proposal to remove the keyword.<br></p><p>I’m also glad it helped to spark a proposal to try to refine the behavior with some kind of &quot;reswitch&quot; mechanism, but I don’t have any passion for pushing that particular proposal along.<br></p><p>My motivation in proposing to remove the fallthrough keyword was that it makes sense to be judicious about language features and keywords especially while the language is young. The feature still seems questionable to me, but if the prevailing opinion is that &quot;fallthrough&quot; or a similar case-jumping mechanism is worth keeping, then I respect that and will not be pushing my original proposal any further.<br></p><p>Daniel<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br></p><p>Infinite reswitch loops seem useful. I&#39;m thinking in particular of interpreter loops, where it&#39;s common to use GCC&#39;s computed goto extension when written in C.<br></p><p>-Joe<br></p><p>&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt; <br>&gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 &lt;https://gist.github.com/JGiola/f735212789bf2f697847&gt;<br>&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt; <br>&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt; <br>&gt; - Jacopo<br>&gt; <br>&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com &lt;mailto:colin at springsandstruts.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt;&gt; <br>&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt;&gt; <br>&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt;&gt; <br>&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; -Colin<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org &lt;mailto:swift-evolution at jacopo.giola.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt; 		x = 0;<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt; 	case .Two where x &gt; 0:<br>&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt; 		element = array[x]<br>&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/275ad0c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 8:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt; <br>&gt; Infinite reswitch loops seem useful. I&#39;m thinking in particular of interpreter loops, where it&#39;s common to use GCC&#39;s computed goto extension when written in C.<br></p><p>I agree that they have useful semantics; I just wonder if it’s more clear to have explicit recursion (with TCO ;) rather than to add a looping construct that effectively does the same thing...<br></p><p>Can’t lie though, given the lack of TCO in Swift, a keyword like this would probably mean fewer stack frames in code I’ve written myself (for instance, a parser combinator library).<br></p><p>-Colin<br></p><p>&gt;&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt;&gt; <br>&gt;&gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 &lt;https://gist.github.com/JGiola/f735212789bf2f697847&gt;<br>&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt;&gt; <br>&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt;&gt; <br>&gt;&gt; - Jacopo<br>&gt;&gt; <br>&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com &lt;mailto:colin at springsandstruts.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org &lt;mailto:swift-evolution at jacopo.giola.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt; 		x = 0;<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt; 	case .Two where x &gt; 0:<br>&gt;&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt; 		element = array[x]<br>&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/337ae86c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/773219eb9674f945300bcd367db477e3?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Breckin Loggins</string> &lt;breckin at apple.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 12:38 PM, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 8:55 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt;&gt; <br>&gt;&gt; Infinite reswitch loops seem useful. I&#39;m thinking in particular of interpreter loops, where it&#39;s common to use GCC&#39;s computed goto extension when written in C.<br>&gt; <br>&gt; I agree that they have useful semantics; I just wonder if it’s more clear to have explicit recursion (with TCO ;) rather than to add a looping construct that effectively does the same thing…<br></p><p>I rather like Clojure’s “recur” construct. It started to get around the JVM’s lack of TCO, but I think it’s turned out to be a nice explicit way to do things like this.<br></p><p>&gt; <br>&gt; Can’t lie though, given the lack of TCO in Swift, a keyword like this would probably mean fewer stack frames in code I’ve written myself (for instance, a parser combinator library).<br>&gt; <br>&gt; -Colin<br>&gt; <br>&gt;&gt;&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve written a really bad draft here https://gist.github.com/JGiola/f735212789bf2f697847 &lt;https://gist.github.com/JGiola/f735212789bf2f697847&gt;<br>&gt;&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;colin at springsandstruts.com &lt;mailto:colin at springsandstruts.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;swift-evolution at jacopo.giola.org &lt;mailto:swift-evolution at jacopo.giola.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt;&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt;&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt; 		// maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt;&gt; 		// do something else<br>&gt;&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt;&gt; 	case .Two:<br>&gt;&gt;&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt; 	case .One:<br>&gt;&gt;&gt;&gt;&gt; 		// do something<br>&gt;&gt;&gt;&gt;&gt; 		x = 0;<br>&gt;&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt;&gt; 	case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt; 		// so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt;&gt; 		reswitch .Two<br>&gt;&gt;&gt;&gt;&gt; 	case .Two where x &gt; 0:<br>&gt;&gt;&gt;&gt;&gt; 		// do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt;&gt; 		element = array[x]<br>&gt;&gt;&gt;&gt;&gt; 	default:<br>&gt;&gt;&gt;&gt;&gt; 		// and so one<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df &lt;https://gist.github.com/cbarrett/23b24a9fe76efdf006df&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type — low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;john.calsbeek+lists at gmail.com &lt;mailto:john.calsbeek+lists at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of gist.github.com &lt;http://gist.github.com/&gt;, there are only 22 gist results for &quot;fallthrough language:swift&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:  https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea &lt;https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea&gt;   I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/f122a73e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>I like the idea of a mechanism for tail-call recursion, but agree with<br>Colin that it&#39;s a little strange to hide it behind keywords like &quot;switch&quot;<br>and &quot;reswtich&quot; -- it makes it less discoverable.<br></p><p>For example, it seems like reswitch, if implemented, would become the only<br>way to do &quot;recursive&quot; anonymous functions (closures):<br></p><p>// calculate the factorial of each item in the list<br>[5, 7, 6].map {<br>      switch ($0, 1) {<br>      case (0, let n):<br>          return n<br>      case let (n, m):<br>          reswitch (n-1, m * n);<br>      }<br>}<br></p><p>(Or am I missing something?) I don&#39;t feel strongly either way about this<br>feature -- I do think it&#39;d be neat to have -- but it would not be entirely<br>obvious to someone wondering &quot;how would I create a &#39;recursive&#39; closure for<br>factorial&quot; that they should turn to switch statements.<br></p><p>On Mon, Dec 7, 2015 at 3:38 PM, Colin Barrett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 7, 2015, at 8:55 AM, Joe Groff &lt; jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can<br>&gt; be better refined to disallow such cases.<br>&gt;<br>&gt;<br>&gt; Infinite reswitch loops seem useful. I&#39;m thinking in particular of<br>&gt; interpreter loops, where it&#39;s common to use GCC&#39;s computed goto extension<br>&gt; when written in C.<br>&gt;<br>&gt;<br>&gt; I agree that they have useful semantics; I just wonder if it’s more clear<br>&gt; to have explicit recursion (with TCO ;) rather than to add a looping<br>&gt; construct that effectively does the same thing...<br>&gt;<br>&gt; Can’t lie though, given the lack of TCO in Swift, a keyword like this<br>&gt; would probably mean fewer stack frames in code I’ve written myself (for<br>&gt; instance, a parser combinator library).<br>&gt;<br>&gt; -Colin<br>&gt;<br>&gt; Checking the case statement is not a problem by itself, but can be a<br>&gt; problem if is coupled with a where clause that is not true when you<br>&gt; fallthrought.<br>&gt;<br>&gt; I’ve written a really bad draft here<br>&gt; https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt; If anyone wants to jump in and elaborate further is welcome. I will try to<br>&gt; stay on par with this thread but I’m really bad at writing so every help is<br>&gt; welcome.<br>&gt;<br>&gt; And if I remember correctly Daniel Jakult was the first one to made this<br>&gt; proposal so if he wants to take on and then made the official proposal has<br>&gt; every right to do so and I will be very glad if my gist can be a first<br>&gt; reference :)<br>&gt;<br>&gt; - Jacopo<br>&gt;<br>&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt; colin at springsandstruts.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for<br>&gt; your patience in summarizing it again.<br>&gt;<br>&gt; I’ve only glanced through it but my concern here is that it introduces a<br>&gt; whole class of new and creative “foot-guns&quot; :) In particular, it allows<br>&gt; this construction to loop arbitrarily and creatively, particularly in the<br>&gt; case of associated values.<br>&gt;<br>&gt; I’m not sure why not checking the case statement is considered a problem<br>&gt; for the fallthrough keyword. Assuming it’s impossible to fallthrough to a<br>&gt; case that introduces binders (what would they be bound to?), and that this<br>&gt; is statically checked (both of which seem reasonable assumptions to me,<br>&gt; although if I’m wrong feel free to correct me), isn’t it the entire point<br>&gt; of the fallthrough keyword that it skips checking the case statement? I can<br>&gt; understand how that might be somewhat confusing (and perhaps it should be<br>&gt; documented less prominently) but I’m not sure how it’s a *problem*,<br>&gt; exactly...<br>&gt;<br>&gt; I think I’m still on the side of keeping fallthrough. What’s the downside<br>&gt; of doing nothing? For instance in the case of ++ and -- those features<br>&gt; complicate the design of a numerics library.<br>&gt;<br>&gt; Thanks,<br>&gt; -Colin<br>&gt;<br>&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;<br>&gt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;<br>&gt;  Hi Colin,<br>&gt;<br>&gt; the initial proposal was indeed to remove entirely the `fallthrough`<br>&gt; keyword but many people expressed your similar concern and from that point<br>&gt; the discussion was steered through an &quot;enhancement&quot; and better refinement<br>&gt; of the keyword.<br>&gt;<br>&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the<br>&gt; desired new value on which the switch is applied.<br>&gt; So something like this:<br>&gt;<br>&gt; switch (enum) {<br>&gt; case .One:<br>&gt; // do something<br>&gt; reswitch .Two<br>&gt; case .Two:<br>&gt; // do something else<br>&gt; default:<br>&gt; // and so one<br>&gt; }<br>&gt;<br>&gt; This new behaviour, IMO, is better suited for Swift because is more<br>&gt; declarative of the developer intent and doesn&#39;t carry over unintentional<br>&gt; misbehaviour.<br>&gt; Is more declarative because you are forced to state in which case you want<br>&gt; to go, and even if the order of the switch’ cases will change in the<br>&gt; future, you don&#39;t fall in the wrong case by mistake.<br>&gt;<br>&gt; switch (enum) {<br>&gt; case .One:<br>&gt; // do something<br>&gt; reswitch .Two<br>&gt; case .OneAndAHalf<br>&gt; // maybe this change is not made by you but by a messed up merge<br>&gt; case .Two:<br>&gt; // do something else<br>&gt; default:<br>&gt; // and so one<br>&gt; }<br>&gt;<br>&gt; In this case if you are using the fallthrough keyboard your code is now<br>&gt; broken by accident, and depending on what are you trying to do inside the<br>&gt; cases you can have a hidden bug that your tests are not seeing right away.<br>&gt;<br>&gt; Another advantage is that in this way you can made more cases fallthrough<br>&gt; in the same one even if they are not one over each other<br>&gt;<br>&gt; switch (enum) {<br>&gt; case .One:<br>&gt; // do something<br>&gt; reswitch .Two<br>&gt; case .OneAndAHalf<br>&gt; // so something that you don’t want to do for .One<br>&gt; reswitch .Two<br>&gt; case .Two:<br>&gt; // do something else that you may want to do for .One and .Two<br>&gt; default:<br>&gt; // and so one<br>&gt; }<br>&gt;<br>&gt; I must say that this is a side effect that can be used to messed up the<br>&gt; code flow in a way that is not intended, but is a new behaviour that gives<br>&gt; more power to the switch statement.<br>&gt;<br>&gt; The reswitch keyword in addition is not a mere fallthrough on the new case<br>&gt; without doing the optional checking attached to it, but is intended to be a<br>&gt; new call and all the check are executed.<br>&gt;<br>&gt; switch (enum) {<br>&gt; case .One:<br>&gt; // do something<br>&gt; x = 0;<br>&gt; reswitch .Two<br>&gt; case .OneAndAHalf<br>&gt; // so something that you don’t want to do for .One<br>&gt; reswitch .Two<br>&gt; case .Two where x &gt; 0:<br>&gt; // do something else that you may want to do for .One and .Two<br>&gt; element = array[x]<br>&gt; default:<br>&gt; // and so one<br>&gt; }<br>&gt; (I’m going by memory and by writing this snippets in the mail app<br>&gt; directly, so the code must be incorrect in the syntax and for this I’m<br>&gt; sorry).<br>&gt;<br>&gt; In this case if enum is .One the only case that is executed is case .One<br>&gt; and the code doesn’t fallthrough in the .Two case because we are made the<br>&gt; where invalid by changing the x to a value less than 1.<br>&gt;<br>&gt; Now I don’t remember who was the first one who mede this proposal, and I<br>&gt; don’t know if he is working on a first draft to lay down the things better,<br>&gt; but for me this can be a nice improvement and a neat break with the<br>&gt; C-switch behaviour that Swift has trying to change from the very first beta<br>&gt; disallowing the implicit fallthrough.<br>&gt;<br>&gt; I can be completely wrong but I see the `fallthrough`keyword as a<br>&gt; “temporary” implementation for ease the transition from Obj-C to Swift and<br>&gt; is time to improve it and made the switch statement even more powerful.<br>&gt;<br>&gt; - Jacopo<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us<br>&gt; anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;<br>&gt; Apologies for jumping into this thread at an awkward point, but I’ve only<br>&gt; just now subscribed to this list.<br>&gt;<br>&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve<br>&gt; also yet to see an example of where it creates a negative impact, either in<br>&gt; code, optimization, or what have you. Other than “It’s like something in C,<br>&gt; and C is old and busted” I’m unsure of the rationale for removing it. (Feel<br>&gt; free to point me in the right direction.)<br>&gt;<br>&gt; Consider the Planet enum from the documentation. One of the simplest way<br>&gt; to define the number of a planet (i.e. its 1-based index in the ordering of<br>&gt; planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;<br>&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;<br>&gt; This technique is very extensible — for instance imagine computing the<br>&gt; force induced by the gravity of the other planets on a particular planet.<br>&gt; All that would need to change is the case statements.<br>&gt;<br>&gt; Yes, you could write this by putting the planets into a list and mapping<br>&gt; or folding (or looping) over that, but unless the compiler can “unroll”<br>&gt; that construct, you’re paying for an allocation simply bc of your choice of<br>&gt; control flow. But in fact, you could imagine generalizing this construct<br>&gt; into the implementation of fold for the Planet type — low-overhead folds<br>&gt; for monomorphic types seems like a pretty compelling an natural use case<br>&gt; for fallthrough to me.<br>&gt;<br>&gt; Thanks,<br>&gt; -Colin<br>&gt;<br>&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 for this idea, but I will prefer the reswitch keyword instead of<br>&gt; overloading continue with a new syntax.<br>&gt;<br>&gt; If this proposal is accepted, it must be coupled with a compiler check<br>&gt; that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Very much thinking out loud and not really the implications, I wonder if<br>&gt; we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;<br>&gt; I very much like specifying what case to fall through into, no matter how<br>&gt; we spell it.<br>&gt;<br>&gt; - Steve<br>&gt;<br>&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt; john.calsbeek+lists at gmail.com&gt;<br>&gt; wrote:<br>&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural<br>&gt; expression of concepts that exist at the instruction level but are<br>&gt; otherwise difficult to express with nested control structures.<br>&gt; `fallthrough` is perhaps slightly less objectionable because control flow<br>&gt; remains local, but it has a similar role.<br>&gt;<br>&gt; It is not particularly natural to write `switch` statements with<br>&gt; `fallthrough` in the reverse order that can be seen in Duff’s Device and<br>&gt; similar constructs (case 7 falls through to 6 which falls through to 5,<br>&gt; etc.). It’s just because you know for certain that all the code in case 6<br>&gt; would be duplicated in case 7, so 7 can transfer into 6 without a jump<br>&gt; instruction. Communicating that to the compiler without `fallthrough`<br>&gt; requires deeply nested `if`s.<br>&gt;<br>&gt;<br>&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might<br>&gt; parameterize it in the future; parameterized it would mean “repeat the<br>&gt; switch with this new value”, so that unparameterized fallthrough would mean<br>&gt; “repeat the switch with a notional value that ends up in the next case”.<br>&gt; There’s a very common pattern in switches of deferring to another case that<br>&gt; I’ve always found very awkward to write in C, and while sometimes there’s<br>&gt; no choice but to extract a helper function, there’s a<br>&gt; still-fairly-structural code pattern here that I think we can sensibly<br>&gt; support.<br>&gt;<br>&gt; On the other hand, there’s an argument that this is an inappropriate<br>&gt; extension for “fallthrough” specifically, which is one reason we’ve never<br>&gt; pursued it.<br>&gt;<br>&gt;<br>&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; One defense comes to mind: there is talk of Swift aiming at systems<br>&gt; programming. Is writing a threaded interpreter loop within the potential<br>&gt; scope of Swift? That’s a use case that could make use of both `fallthrough`<br>&gt; and `goto` (computed goto, really).<br>&gt;<br>&gt; switch op {<br>&gt; case LOAD_INDIRECT:<br>&gt;    in0 = memory[in1]<br>&gt;    fallthrough<br>&gt; case LOAD:<br>&gt;    out0 = memory[in0]<br>&gt; //...<br>&gt; }<br>&gt;<br>&gt; I am personally interested in the prospect of a language that can scale up<br>&gt; to high-level concepts and down to “portable assembler,” but I don’t know<br>&gt; if that is the right direction for Swift’s evolution.<br>&gt;<br>&gt; Cheers,<br>&gt; John<br>&gt;<br>&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt; rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt; kevin at sb.org&gt; wrote:<br>&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C<br>&gt; switch statements don&#39;t actually introduce a new scope, and so it overlaps<br>&gt; a switch with a do-while loop. This lets it only test the number of bytes<br>&gt; once, to jump into the middle of the loop, and then it switches over to a<br>&gt; while loop that decrements a counter every 8 instructions. Basically, it&#39;s<br>&gt; a trick for manual loop unrolling that deals with non-multiple-of-8 counts<br>&gt; efficiently.<br>&gt;<br>&gt;<br>&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s<br>&gt; Device exploits is that switch is allowed to jump into (almost) arbitrary<br>&gt; scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;<br>&gt; But your point that Swift’s switch requires cases to be at the top level<br>&gt; within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with<br>&gt; non-multiple-of-8 counts, but it has calculate the number of bytes on every<br>&gt; iteration instead of once. It&#39;s a good example of one of the uses of<br>&gt; `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s<br>&gt; Device in Swift.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br>&gt;<br>&gt; Streza’s source code is an example of Duff’s Device, which is a big place<br>&gt; where switch fallthrough is arguably the cleanest way to do things and the<br>&gt; reason why I’d personally prefer to keep it as part of the language.<br>&gt;<br>&gt;<br>&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt; erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt; Oh let it die, let it die. Any time I use fallthrough I find myself<br>&gt; re-factoring to stop using it.<br>&gt;<br>&gt; *True fact*: On all of   gist.github.com, there are only 22 gist results<br>&gt; for &quot;fallthrough language:swift&quot;.<br>&gt; Half of those are people just testing out the feature. Most of the<br>&gt; remaining ones are just complex cases:<br>&gt; *case .Enum1, .Enum2:*<br>&gt; expressed as<br>&gt; *case .Enum1: fallthrough*<br>&gt; *case .Enum2:*<br>&gt;<br>&gt; And then there&#39;s streza:<br>&gt; https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I&#39;m pretty<br>&gt; sure that ponies were harmed in the production of whatever that last bit<br>&gt; is.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote:<br>&gt;<br>&gt; In the spirit of some other proposals that remove C or C++ style<br>&gt; artifacts, what do folks think about the possibility of removing the<br>&gt; &quot;fallthrough&quot; keyword from the language?<br>&gt;<br>&gt; My understanding is this keyword is only used for the archaic seeming<br>&gt; purpose of perpetuating C-style fallthrough from one switch statement to<br>&gt; the subsequent one. The documentation hedges the use of this keyword in<br>&gt; forbidding terms that make it clear its use is not encouraged. The presence<br>&gt; of the keyword, while an improvement over C’s implicit fallthrough, is a<br>&gt; mark of inelegance on an otherwise well-designed, opinionated<br>&gt; implementation of swtich statements.<br>&gt;<br>&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in<br>&gt; the documentation:<br>&gt;<br>&gt; &quot;The fallthrough keyword does not check the case conditions for the switch<br>&gt; case that it causes execution to fall into. The fallthrough keyword simply<br>&gt; causes code execution to move directly to the statements inside the next<br>&gt; case (or default case) block, as in C’s standard switch statement<br>&gt; behavior.&quot;<br>&gt;<br>&gt; To my mind, the caveat explains just what is wrong with fallthrough, both<br>&gt; in C or Swift: coded that is clearly labeled with deliberate conditions can<br>&gt; nonetheless be reached.<br>&gt;<br>&gt; I quipped about this on Twitter, and the most common pushback I got seemed<br>&gt; to be from people who either did not know about Swift’s support for<br>&gt; comma-separated case statements, or harbored an aesthetic preference for<br>&gt; clustering such cases together with fallthrough statements.<br>&gt;<br>&gt; In my opinion, unless somebody can think of a strong defense for<br>&gt; supporting intentional fallthrough in Swift, removing the keyword would be<br>&gt; a move in the direction of minimizing the language’s complexity while also<br>&gt; discouraging poor coding style in switch statements.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Daniel<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;   _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/a5d7c553/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>The other way to do recursive anonymous functions is by taking the least fixed point, as in here: https://github.com/robrix/Prelude/blob/master/Prelude/Fix.swift<br></p><p>Using it is something like:<br></p><p>.map { arg in fix { recur in<br>  if &lt;some condition&gt; {<br>    return recur(&lt;intermediate value&gt;)<br>  } else {<br>    return &lt;final result&gt;<br>  }<br>}}<br></p><p>Calling recur will invoke the original closure again (as you can see if you examine the definition of fix closely). <br></p><p>(This is a fundamental result in computer science as it allows the lambda calculus (which has only anonymous functions) to execute recursive computations. :D)<br></p><p>-Colin (via thumbs)<br></p><p>&gt; On Dec 7, 2015, at 12:59 PM, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like the idea of a mechanism for tail-call recursion, but agree with Colin that it&#39;s a little strange to hide it behind keywords like &quot;switch&quot; and &quot;reswtich&quot; -- it makes it less discoverable.<br>&gt; <br>&gt; For example, it seems like reswitch, if implemented, would become the only way to do &quot;recursive&quot; anonymous functions (closures):<br>&gt; <br>&gt; // calculate the factorial of each item in the list<br>&gt; [5, 7, 6].map { <br>&gt;       switch ($0, 1) {<br>&gt;       case (0, let n):<br>&gt;           return n<br>&gt;       case let (n, m):<br>&gt;           reswitch (n-1, m * n);<br>&gt;       }<br>&gt; }<br>&gt; <br>&gt; (Or am I missing something?) I don&#39;t feel strongly either way about this feature -- I do think it&#39;d be neat to have -- but it would not be entirely obvious to someone wondering &quot;how would I create a &#39;recursive&#39; closure for factorial&quot; that they should turn to switch statements.<br>&gt; <br>&gt;&gt; On Mon, Dec 7, 2015 at 3:38 PM, Colin Barrett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 8:55 AM, Joe Groff &lt; jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-evolution &lt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Infinite reswitch loops seem useful. I&#39;m thinking in particular of interpreter loops, where it&#39;s common to use GCC&#39;s computed goto extension when written in C.<br>&gt;&gt; <br>&gt;&gt; I agree that they have useful semantics; I just wonder if it’s more clear to have explicit recursion (with TCO ;) rather than to add a looping construct that effectively does the same thing...<br>&gt;&gt; <br>&gt;&gt; Can’t lie though, given the lack of TCO in Swift, a keyword like this would probably mean fewer stack frames in code I’ve written myself (for instance, a parser combinator library).<br>&gt;&gt; <br>&gt;&gt; -Colin <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Checking the case statement is not a problem by itself, but can be a problem if is coupled with a where clause that is not true when you fallthrought.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve written a really bad draft here   https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;&gt;&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will try to stay on par with this thread but I’m really bad at writing so every help is welcome.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made this proposal so if he wants to take on and then made the official proposal has every right to do so and I will be very glad if my gist can be a first reference :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt; colin at springsandstruts.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you for your patience in summarizing it again.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it introduces a whole class of new and creative “foot-guns&quot; :) In particular, it allows this construction to loop arbitrarily and creatively, particularly in the case of associated values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a problem for the fallthrough keyword. Assuming it’s impossible to fallthrough to a case that introduces binders (what would they be bound to?), and that this is statically checked (both of which seem reasonable assumptions to me, although if I’m wrong feel free to correct me), isn’t it the entire point of the fallthrough keyword that it skips checking the case statement? I can understand how that might be somewhat confusing (and perhaps it should be documented less prominently) but I’m not sure how it’s a *problem*, exactly...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the downside of doing nothing? For instance in the case of ++ and -- those features complicate the design of a numerics library.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt; swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  Hi Colin,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; the initial proposal was indeed to remove entirely the `fallthrough` keyword but many people expressed your similar concern and from that point the discussion was steered through an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot; passing the desired new value on which the switch is applied.<br>&gt;&gt;&gt;&gt;&gt;&gt; So something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something else<br>&gt;&gt;&gt;&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is more declarative of the developer intent and doesn&#39;t carry over unintentional misbehaviour.<br>&gt;&gt;&gt;&gt;&gt;&gt; Is more declarative because you are forced to state in which case you want to go, and even if the order of the switch’ cases will change in the future, you don&#39;t fall in the wrong case by mistake.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt;&gt;  // maybe this change is not made by you but by a messed up merge<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something else<br>&gt;&gt;&gt;&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code is now broken by accident, and depending on what are you trying to do inside the cases you can have a hidden bug that your tests are not seeing right away. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another advantage is that in this way you can made more cases fallthrough in the same one even if they are not one over each other<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt;&gt;  // so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .Two:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I must say that this is a side effect that can be used to messed up the code flow in a way that is not intended, but is a new behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the new case without doing the optional checking attached to it, but is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .One:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something<br>&gt;&gt;&gt;&gt;&gt;&gt;  x = 0;<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .OneAndAHalf<br>&gt;&gt;&gt;&gt;&gt;&gt;  // so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt;&gt;&gt;  reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  case .Two where x &gt; 0:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do something else that you may want to do for .One and .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;  element = array[x]<br>&gt;&gt;&gt;&gt;&gt;&gt;  default:<br>&gt;&gt;&gt;&gt;&gt;&gt;  // and so one<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; (I’m going by memory and by writing this snippets in the mail app directly, so the code must be incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In this case if enum is .One the only case that is executed is case .One and the code doesn’t fallthrough in the .Two case because we are made the where invalid by changing the x to a value less than 1.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now I don’t remember who was the first one who mede this proposal, and I don’t know if he is working on a first draft to lay down the things better, but for me this can be a nice improvement and a neat break with the C-switch behaviour that Swift has trying to change from the very first beta disallowing the implicit fallthrough.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a “temporary” implementation for ease the transition from Obj-C to Swift and is time to improve it and made the switch statement even more powerful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Jacopo <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt; swift-evolution at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t costing us anything; and has at least minimal utility, as I try to demonstrate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain circumstances. I’ve also yet to see an example of where it creates a negative impact, either in code, optimization, or what have you. Other than “It’s like something in C, and C is old and busted” I’m unsure of the rationale for removing it. (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the simplest way to define the number of a planet (i.e. its 1-based index in the ordering of planets wrt. distance from the sun) is using a switch and fall-through:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This technique is very extensible ― for instance imagine computing the force induced by the gravity of the other planets on a particular planet. All that would need to change is the case statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and mapping or folding (or looping) over that, but unless the compiler can “unroll” that construct, you’re paying for an allocation simply bc of your choice of control flow. But in fact, you could imagine generalizing this construct into the implementation of fold for the Planet type ― low-overhead folds for monomorphic types seems like a pretty compelling an natural use case for fallthrough to me.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-evolution &lt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a compiler check that the reswitch statements don&#39;t introduce an infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt; swift-evolution at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no matter how we spell it. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt; swift-evolution at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution &lt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt; john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that both allow natural expression of concepts that exist at the instruction level but are otherwise difficult to express with nested control structures. `fallthrough` is perhaps slightly less objectionable because control flow remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements with `fallthrough` in the reverse order that can be seen in Duff’s Device and similar constructs (case 7 falls through to 6 which falls through to 5, etc.). It’s just because you know for certain that all the code in case 6 would be duplicated in case 7, so 7 can transfer into 6 without a jump instruction. Communicating that to the compiler without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is that we might parameterize it in the future; parameterized it would mean “repeat the switch with this new value”, so that unparameterized fallthrough would mean “repeat the switch with a notional value that ends up in the next case”.  There’s a very common pattern in switches of deferring to another case that I’ve always found very awkward to write in C, and while sometimes there’s no choice but to extract a helper function, there’s a still-fairly-structural code pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an inappropriate extension for “fallthrough” specifically, which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at systems programming. Is writing a threaded interpreter loop within the potential scope of Swift? That’s a use case that could make use of both `fallthrough` and `goto` (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD_INDIRECT:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case LOAD:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    out0 = memory[in0]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language that can scale up to high-level concepts and down to “portable assembler,” but I don’t know if that is the right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt; rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt; kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on the fact that C switch statements don&#39;t actually introduce a new scope, and so it overlaps a switch with a do-while loop. This lets it only test the number of bytes once, to jump into the middle of the loop, and then it switches over to a while loop that decrements a counter every 8 instructions. Basically, it&#39;s a trick for manual loop unrolling that deals with non-multiple-of-8 counts efficiently. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new scope.  What Duff’s Device exploits is that switch is allowed to jump into (almost) arbitrary scopes, and cases can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at the top level within a switch and thus prevents the use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling that deals with non-multiple-of-8 counts, but it has calculate the number of bytes on every iteration instead of once. It&#39;s a good example of one of the uses of `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s impossible to use Duff&#39;s Device in Swift. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device, which is a big place where switch fallthrough is arguably the cleanest way to do things and the reason why I’d personally prefer to keep it as part of the language. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt; erica at ericasadun.com&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I find myself re-factoring to stop using it.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; True fact: On all of   gist.github.com, there are only 22 gist results for &quot;fallthrough language:swift&quot;. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature. Most of the remaining ones are just complex cases: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1, .Enum2: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expressed as  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum1: fallthrough <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .Enum2: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:   https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea    I&#39;m pretty sure that ponies were harmed in the production of whatever that last bit is. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM,   jalkut at red-sweater.com  wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?                                                    <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts? <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution                                  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   _______________________________________________ <br>&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt; swift-evolution at swift.org <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; Untracked with Trackbuster<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/572fdc78/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>FWIW, reswitch looks to me like it&#39;s really just sugar around a while loop. For example, your factorial example can be rewritten as:<br></p><p>[5, 7, 6].map {    var value = ($0, 1)    repeat {        switch value<br>{        case (0, let n):            return n        case let (n, m):<br>value = (n-1, m * n)            break // or continue        }    }<br>while true }<br></p><p>And breaking out of the loop can be done by attaching a label to<br>the repeat:<br></p><p>loop: repeat {    switch value {    case .Foo:        break loop    //<br>...    } }<br></p><p>All that said, I think that a proposal to add `reswitch` is actually<br>orthogonal to whether we should remove `fallthrough`, since as I<br>mentioned before `reswitch` doesn&#39;t actually replace some of the<br>behavior that `fallthrough` provides. I&#39;m strongly against removing<br>`fallthrough`, but I&#39;m somewhat ambivalent on `reswitch` and I&#39;d rather<br>it be considered separately.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 7, 2015, at 12:59 PM, Alex Lew via swift-evolution wrote:<br>&gt; I like the idea of a mechanism for tail-call recursion, but agree with<br>&gt; Colin that it&#39;s a little strange to hide it behind keywords like<br>&gt; &quot;switch&quot; and &quot;reswtich&quot; -- it makes it less discoverable.<br>&gt;<br>&gt; For example, it seems like reswitch, if implemented, would become the<br>&gt; only way to do &quot;recursive&quot; anonymous functions (closures):<br>&gt;<br>&gt; // calculate the factorial of each item in the list [5, 7, 6].map {<br>&gt; switch ($0, 1) {      case (0, let n):          return n      case let<br>&gt; (n, m):          reswitch (n-1, m * n);      } }<br>&gt;<br>&gt; (Or am I missing something?) I don&#39;t feel strongly either way about<br>&gt; this feature -- I do think it&#39;d be neat to have -- but it would not be<br>&gt; entirely obvious to someone wondering &quot;how would I create a<br>&gt; &#39;recursive&#39; closure for factorial&quot; that they should turn to switch<br>&gt; statements.<br>&gt;<br>&gt; On Mon, Dec 7, 2015 at 3:38 PM, Colin Barrett via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>   On Dec 7, 2015, at 8:55 AM, Joe Groff &lt; jgroff at apple.com&gt; wrote:<br></p><p>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-<br>&gt;&gt;&gt;&gt; evolution &lt;<br>     swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>      Yes, I’m aware that at this time the reswitch can be abused and<br>      maybe can be better refined to disallow such cases.<br></p><p>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>    Infinite reswitch loops seem useful. I&#39;m thinking in particular of<br>    interpreter loops, where it&#39;s common to use GCC&#39;s computed goto<br>    extension when written in C.<br></p><p>&gt;&gt;<br>&gt;&gt; I agree that they have useful semantics; I just wonder if it’s more<br>&gt;&gt; clear to have explicit recursion (with TCO ;) rather than to add a<br>&gt;&gt; looping construct that effectively does the same thing...<br>&gt;&gt;<br>&gt;&gt; Can’t lie though, given the lack of TCO in Swift, a keyword like this<br>&gt;&gt; would probably mean fewer stack frames in code I’ve written myself<br>&gt;&gt; (for instance, a parser combinator library).<br>&gt;&gt;<br>&gt;&gt; -Colin<br></p><p>&gt;&gt;<br>&gt;&gt;&gt;&gt; Checking the case statement is not a problem by itself, but can be<br>&gt;&gt;&gt;&gt; a problem if is coupled with a where clause that is not true when<br>&gt;&gt;&gt;&gt; you fallthrought.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’ve written a really bad draft here<br>       https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;&gt;&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I will<br>&gt;&gt;&gt;&gt; try to stay on par with this thread but I’m really bad at writing<br>&gt;&gt;&gt;&gt; so every help is welcome.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And if I remember correctly Daniel Jakult was the first one to made<br>&gt;&gt;&gt;&gt; this proposal so if he wants to take on and then made the official<br>&gt;&gt;&gt;&gt; proposal has every right to do so and I will be very glad if my<br>&gt;&gt;&gt;&gt; gist can be a first reference :)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;<br>        colin at springsandstruts.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank you<br>&gt;&gt;&gt;&gt;&gt; for your patience in summarizing it again.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it<br>&gt;&gt;&gt;&gt;&gt; introduces a whole class of new and creative “foot-guns&quot; :) In<br>&gt;&gt;&gt;&gt;&gt; particular, it allows this construction to loop arbitrarily and<br>&gt;&gt;&gt;&gt;&gt; creatively, particularly in the case of associated values.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a<br>&gt;&gt;&gt;&gt;&gt; problem for the fallthrough keyword. Assuming it’s impossible to<br>&gt;&gt;&gt;&gt;&gt; fallthrough to a case that introduces binders (what would they be<br>&gt;&gt;&gt;&gt;&gt; bound to?), and that this is statically checked (both of which<br>&gt;&gt;&gt;&gt;&gt; seem reasonable assumptions to me, although if I’m wrong feel free<br>&gt;&gt;&gt;&gt;&gt; to correct me), isn’t it the entire point of the fallthrough<br>&gt;&gt;&gt;&gt;&gt; keyword that it skips checking the case statement? I can<br>&gt;&gt;&gt;&gt;&gt; understand how that might be somewhat confusing (and perhaps it<br>&gt;&gt;&gt;&gt;&gt; should be documented less prominently) but I’m not sure how it’s a<br>&gt;&gt;&gt;&gt;&gt; *problem*, exactly...<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the<br>&gt;&gt;&gt;&gt;&gt; downside of doing nothing? For instance in the case of ++ and --<br>&gt;&gt;&gt;&gt;&gt; those features complicate the design of a numerics library.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Thanks, -Colin<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;<br>              swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Colin,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; the initial proposal was indeed to remove entirely the<br>&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` keyword but many people expressed your similar<br>&gt;&gt;&gt;&gt;&gt;&gt; concern and from that point the discussion was steered through an<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; passing the desired new value on which the switch is applied. So<br>&gt;&gt;&gt;&gt;&gt;&gt; something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) { case .One: // do something reswitch .Two case<br>&gt;&gt;&gt;&gt;&gt;&gt; .Two: // do something else default: // and so one }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is<br>&gt;&gt;&gt;&gt;&gt;&gt; more declarative of the developer intent and doesn&#39;t carry over<br>&gt;&gt;&gt;&gt;&gt;&gt; unintentional misbehaviour. Is more declarative because you are<br>&gt;&gt;&gt;&gt;&gt;&gt; forced to state in which case you want to go, and even if the<br>&gt;&gt;&gt;&gt;&gt;&gt; order of the switch’ cases will change in the future, you don&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; fall in the wrong case by mistake.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) { case .One: // do something reswitch .Two case<br>&gt;&gt;&gt;&gt;&gt;&gt; .OneAndAHalf // maybe this change is not made by you but by a<br>&gt;&gt;&gt;&gt;&gt;&gt; messed up merge case .Two: // do something else default: // and<br>&gt;&gt;&gt;&gt;&gt;&gt; so one }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code<br>&gt;&gt;&gt;&gt;&gt;&gt; is now broken by accident, and depending on what are you trying<br>&gt;&gt;&gt;&gt;&gt;&gt; to do inside the cases you can have a hidden bug that your tests<br>&gt;&gt;&gt;&gt;&gt;&gt; are not seeing right away.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Another advantage is that in this way you can made more cases<br>&gt;&gt;&gt;&gt;&gt;&gt; fallthrough in the same one even if they are not one over each<br>&gt;&gt;&gt;&gt;&gt;&gt; other<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) { case .One: // do something reswitch .Two case<br>&gt;&gt;&gt;&gt;&gt;&gt; .OneAndAHalf // so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt;&gt;&gt; reswitch .Two case .Two: // do something else that you may want<br>&gt;&gt;&gt;&gt;&gt;&gt; to do for .One and .Two default: // and so one }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I must say that this is a side effect that can be used to messed<br>&gt;&gt;&gt;&gt;&gt;&gt; up the code flow in a way that is not intended, but is a new<br>&gt;&gt;&gt;&gt;&gt;&gt; behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on the<br>&gt;&gt;&gt;&gt;&gt;&gt; new case without doing the optional checking attached to it, but<br>&gt;&gt;&gt;&gt;&gt;&gt; is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) { case .One: // do something x = 0; reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt; case .OneAndAHalf // so something that you don’t want to do for<br>&gt;&gt;&gt;&gt;&gt;&gt; .One reswitch .Two case .Two where x &gt; 0: // do something else<br>&gt;&gt;&gt;&gt;&gt;&gt; that you may want to do for .One and .Two element = array[x]<br>&gt;&gt;&gt;&gt;&gt;&gt; default: // and so one } (I’m going by memory and by writing this<br>&gt;&gt;&gt;&gt;&gt;&gt; snippets in the mail app directly, so the code must be incorrect<br>&gt;&gt;&gt;&gt;&gt;&gt; in the syntax and for this I’m sorry).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; In this case if enum is .One the only case that is executed is<br>&gt;&gt;&gt;&gt;&gt;&gt; case .One and the code doesn’t fallthrough in the .Two case<br>&gt;&gt;&gt;&gt;&gt;&gt; because we are made the where invalid by changing the x to a<br>&gt;&gt;&gt;&gt;&gt;&gt; value less than 1.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Now I don’t remember who was the first one who mede this<br>&gt;&gt;&gt;&gt;&gt;&gt; proposal, and I don’t know if he is working on a first draft to<br>&gt;&gt;&gt;&gt;&gt;&gt; lay down the things better, but for me this can be a nice<br>&gt;&gt;&gt;&gt;&gt;&gt; improvement and a neat break with the C-switch behaviour that<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift has trying to change from the very first beta disallowing<br>&gt;&gt;&gt;&gt;&gt;&gt; the implicit fallthrough.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as a<br>&gt;&gt;&gt;&gt;&gt;&gt; “temporary” implementation for ease the transition from Obj-C to<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift and is time to improve it and made the switch statement<br>&gt;&gt;&gt;&gt;&gt;&gt; even more powerful.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Jacopo<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;<br>                swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; costing us anything; and has at least minimal utility, as I try<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to demonstrate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; circumstances. I’ve also yet to see an example of where it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; creates a negative impact, either in code, optimization, or what<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; have you. Other than “It’s like something in C, and C is old and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; busted” I’m unsure of the rationale for removing it. (Feel free<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to point me in the right direction.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; simplest way to define the number of a planet (i.e. its 1-based<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; index in the ordering of planets wrt. distance from the sun) is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; using a switch and fall-through:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; computing the force induced by the gravity of the other planets<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on a particular planet. All that would need to change is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mapping or folding (or looping) over that, but unless the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; compiler can “unroll” that construct, you’re paying for an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; allocation simply bc of your choice of control flow. But in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fact, you could imagine generalizing this construct into the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of fold for the Planet type — low-overhead folds<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for monomorphic types seems like a pretty compelling an natural<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; use case for fallthrough to me.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks, -Colin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution &lt;<br>                     swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; compiler check that the reswitch statements don&#39;t introduce an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;<br>                       swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wonder if we might just use &quot;continue&quot; instead of &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into, no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; matter how we spell it.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;<br>                         swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;<br>                             swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;<br>                                 john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; both allow natural expression of concepts that exist at the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instruction level but are otherwise difficult to express<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with nested control structures. `fallthrough` is perhaps<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; slightly less objectionable because control flow remains<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch` statements<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with `fallthrough` in the reverse order that can be seen in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Duff’s Device and similar constructs (case 7 falls through<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to 6 which falls through to 5, etc.). It’s just because you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; know for certain that all the code in case 6 would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; duplicated in case 7, so 7 can transfer into 6 without a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; jump instruction. Communicating that to the compiler<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without `fallthrough` requires deeply nested `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that we might parameterize it in the future; parameterized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it would mean “repeat the switch with this new value”, so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that unparameterized fallthrough would mean “repeat the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch with a notional value that ends up in the next case”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There’s a very common pattern in switches of deferring to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; another case that I’ve always found very awkward to write in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; C, and while sometimes there’s no choice but to extract a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; helper function, there’s a still-fairly-structural code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pattern here that I think we can sensibly support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inappropriate extension for “fallthrough” specifically,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; systems programming. Is writing a threaded interpreter loop<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; within the potential scope of Swift? That’s a use case that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could make use of both `fallthrough` and `goto` (computed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op { case LOAD_INDIRECT:   in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fallthrough case LOAD:   out0 = memory[in0] //... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that can scale up to high-level concepts and down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “portable assembler,” but I don’t know if that is the right<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers, John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;<br>                                     rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;<br>                                        kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the fact that C switch statements don&#39;t actually<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; introduce a new scope, and so it overlaps a switch with a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do-while loop. This lets it only test the number of bytes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; once, to jump into the middle of the loop, and then it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switches over to a while loop that decrements a counter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; every 8 instructions. Basically, it&#39;s a trick for manual<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; loop unrolling that deals with non-multiple-of-8 counts<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; efficiently.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; scope.  What Duff’s Device exploits is that switch is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; allowed to jump into (almost) arbitrary scopes, and cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the top level within a switch and thus prevents the use of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that deals with non-multiple-of-8 counts, but it has<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; calculate the number of bytes on every iteration instead<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of once. It&#39;s a good example of one of the uses of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; impossible to use Duff&#39;s Device in Swift.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is a big place where switch fallthrough is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arguably the cleanest way to do things and the reason<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; why I’d personally prefer to keep it as part of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; language.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;<br>                                             erica at ericasadun.com&gt;<br>                                             wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; find myself re-factoring to stop using it.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *True fact*: On all of<br>                                                gist.github.com[1],<br>                                                there are only 22 gist<br>                                                results for &quot;fallthrough<br>                                                language:swift&quot;.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Most of the remaining ones are just complex cases:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *case .Enum1, .Enum2:* expressed as<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *case .Enum1: fallthrough* *case .Enum2:*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:<br>                                               https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea<br>                                               I&#39;m pretty sure that<br>                                               ponies were harmed in the<br>                                               production of whatever<br>                                               that last bit is.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM,<br>                                                  jalkut at red-<br>                                                  sweater.com wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; C++ style artifacts, what do folks think about the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; possibility of removing the &quot;fallthrough&quot; keyword from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the language?<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; archaic seeming purpose of perpetuating C-style<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fallthrough from one switch statement to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subsequent one. The documentation hedges the use of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this keyword in forbidding terms that make it clear<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; its use is not encouraged. The presence of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; keyword, while an improvement over C’s implicit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fallthrough, is a mark of inelegance on an otherwise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; well-designed, opinionated implementation of swtich<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statements.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; demands a caveat in the documentation:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conditions for the switch case that it causes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; execution to fall into. The fallthrough keyword simply<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; causes code execution to move directly to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statements inside the next case (or default case)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; block, as in C’s standard switch statement behavior.&quot;<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with fallthrough, both in C or Swift: coded that is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; clearly labeled with deliberate conditions can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nonetheless be reached.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pushback I got seemed to be from people who either did<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not know about Swift’s support for comma-separated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case statements, or harbored an aesthetic preference<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for clustering such cases together with fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statements.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; defense for supporting intentional fallthrough in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift, removing the keyword would be a move in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; direction of minimizing the language’s complexity<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while also discouraging poor coding style in switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statements.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; Untracked with<br> Trackbuster[2]<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. http://gist.github.com/<br>  2. https://trackbuster.com/?sig<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/86155fe5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>Or alternatively, if you want to preserve `break` in the switch, you can write it so `continue` is required to repeat:<br></p><p>var value = ... repeat {    switch value {    case ...:        ...<br>// reswitch        value = ...        continue    case ...:        break<br>}    break } while true<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 7, 2015, at 01:39 PM, Kevin Ballard wrote:<br>&gt; FWIW, reswitch looks to me like it&#39;s really just sugar around a while<br>&gt; loop. For example, your factorial example can be rewritten as:<br>&gt;<br>&gt; [5, 7, 6].map {    var value = ($0, 1)    repeat {        switch value<br>&gt; {        case (0, let n):            return n        case let (n, m):<br>&gt; value = (n-1, m * n)            break // or continue        }    }<br>&gt; while true }<br>&gt;<br>&gt; And breaking out of the loop can be done by attaching a label to<br>&gt; the repeat:<br>&gt;<br>&gt; loop: repeat {    switch value {    case .Foo:        break loop    //<br>&gt; ...    } }<br>&gt;<br>&gt; All that said, I think that a proposal to add `reswitch` is actually<br>&gt; orthogonal to whether we should remove `fallthrough`, since as I<br>&gt; mentioned before `reswitch` doesn&#39;t actually replace some of the<br>&gt; behavior that `fallthrough` provides. I&#39;m strongly against removing<br>&gt; `fallthrough`, but I&#39;m somewhat ambivalent on `reswitch` and I&#39;d<br>&gt; rather it be considered separately.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Mon, Dec 7, 2015, at 12:59 PM, Alex Lew via swift-evolution wrote:<br>&gt;&gt; I like the idea of a mechanism for tail-call recursion, but agree<br>&gt;&gt; with Colin that it&#39;s a little strange to hide it behind keywords like<br>&gt;&gt; &quot;switch&quot; and &quot;reswtich&quot; -- it makes it less discoverable.<br>&gt;&gt;<br>&gt;&gt; For example, it seems like reswitch, if implemented, would become the<br>&gt;&gt; only way to do &quot;recursive&quot; anonymous functions (closures):<br>&gt;&gt;<br>&gt;&gt; // calculate the factorial of each item in the list [5, 7, 6].map {<br>&gt;&gt; switch ($0, 1) {      case (0, let n):          return n      case<br>&gt;&gt; let (n, m):          reswitch (n-1, m * n);      } }<br>&gt;&gt;<br>&gt;&gt; (Or am I missing something?) I don&#39;t feel strongly either way about<br>&gt;&gt; this feature -- I do think it&#39;d be neat to have -- but it would not<br>&gt;&gt; be entirely obvious to someone wondering &quot;how would I create a<br>&gt;&gt; &#39;recursive&#39; closure for factorial&quot; that they should turn to switch<br>&gt;&gt; statements.<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 7, 2015 at 3:38 PM, Colin Barrett via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>   On Dec 7, 2015, at 8:55 AM, Joe Groff &lt; jgroff at apple.com&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-<br>&gt;&gt;&gt;&gt;&gt; evolution &lt;<br>     swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>      Yes, I’m aware that at this time the reswitch can be abused and<br>      maybe can be better refined to disallow such cases.<br></p><p>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>    Infinite reswitch loops seem useful. I&#39;m thinking in particular of<br>    interpreter loops, where it&#39;s common to use GCC&#39;s computed goto<br>    extension when written in C.<br></p><p>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that they have useful semantics; I just wonder if it’s more<br>&gt;&gt;&gt; clear to have explicit recursion (with TCO ;) rather than to add a<br>&gt;&gt;&gt; looping construct that effectively does the same thing...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Can’t lie though, given the lack of TCO in Swift, a keyword like<br>&gt;&gt;&gt; this would probably mean fewer stack frames in code I’ve written<br>&gt;&gt;&gt; myself (for instance, a parser combinator library).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Colin<br></p><p>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Checking the case statement is not a problem by itself, but can be<br>&gt;&gt;&gt;&gt;&gt; a problem if is coupled with a where clause that is not true when<br>&gt;&gt;&gt;&gt;&gt; you fallthrought.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I’ve written a really bad draft here<br>       https://gist.github.com/JGiola/f735212789bf2f697847<br>&gt;&gt;&gt;&gt;&gt; If anyone wants to jump in and elaborate further is welcome. I<br>&gt;&gt;&gt;&gt;&gt; will try to stay on par with this thread but I’m really bad at<br>&gt;&gt;&gt;&gt;&gt; writing so every help is welcome.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; And if I remember correctly Daniel Jakult was the first one to<br>&gt;&gt;&gt;&gt;&gt; made this proposal so if he wants to take on and then made the<br>&gt;&gt;&gt;&gt;&gt; official proposal has every right to do so and I will be very glad<br>&gt;&gt;&gt;&gt;&gt; if my gist can be a first reference :)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Jacopo<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 21:52, Colin Barrett &lt;<br>        colin at springsandstruts.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Apologies, Jacopo, for missing the updated proposal, and thank<br>&gt;&gt;&gt;&gt;&gt;&gt; you for your patience in summarizing it again.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I’ve only glanced through it but my concern here is that it<br>&gt;&gt;&gt;&gt;&gt;&gt; introduces a whole class of new and creative “foot-guns&quot; :) In<br>&gt;&gt;&gt;&gt;&gt;&gt; particular, it allows this construction to loop arbitrarily and<br>&gt;&gt;&gt;&gt;&gt;&gt; creatively, particularly in the case of associated values.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure why not checking the case statement is considered a<br>&gt;&gt;&gt;&gt;&gt;&gt; problem for the fallthrough keyword. Assuming it’s impossible to<br>&gt;&gt;&gt;&gt;&gt;&gt; fallthrough to a case that introduces binders (what would they be<br>&gt;&gt;&gt;&gt;&gt;&gt; bound to?), and that this is statically checked (both of which<br>&gt;&gt;&gt;&gt;&gt;&gt; seem reasonable assumptions to me, although if I’m wrong feel<br>&gt;&gt;&gt;&gt;&gt;&gt; free to correct me), isn’t it the entire point of the fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt; keyword that it skips checking the case statement? I can<br>&gt;&gt;&gt;&gt;&gt;&gt; understand how that might be somewhat confusing (and perhaps it<br>&gt;&gt;&gt;&gt;&gt;&gt; should be documented less prominently) but I’m not sure how it’s<br>&gt;&gt;&gt;&gt;&gt;&gt; a *problem*, exactly...<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I think I’m still on the side of keeping fallthrough. What’s the<br>&gt;&gt;&gt;&gt;&gt;&gt; downside of doing nothing? For instance in the case of ++ and --<br>&gt;&gt;&gt;&gt;&gt;&gt; those features complicate the design of a numerics library.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks, -Colin<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 3:06 PM, Jacopo Andrea Giola &lt;<br>              swift-evolution at jacopo.giola.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Colin,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the initial proposal was indeed to remove entirely the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` keyword but many people expressed your similar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; concern and from that point the discussion was steered through<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an &quot;enhancement&quot; and better refinement of the keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The new idea is to substitute the old keyword with &quot;reswitch&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; passing the desired new value on which the switch is applied. So<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) { case .One: // do something reswitch .Two case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .Two: // do something else default: // and so one }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This new behaviour, IMO, is better suited for Swift because is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; more declarative of the developer intent and doesn&#39;t carry over<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unintentional misbehaviour. Is more declarative because you are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; forced to state in which case you want to go, and even if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; order of the switch’ cases will change in the future, you don&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fall in the wrong case by mistake.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) { case .One: // do something reswitch .Two case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .OneAndAHalf // maybe this change is not made by you but by a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; messed up merge case .Two: // do something else default: // and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; so one }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In this case if you are using the fallthrough keyboard your code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is now broken by accident, and depending on what are you trying<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to do inside the cases you can have a hidden bug that your tests<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are not seeing right away.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another advantage is that in this way you can made more cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fallthrough in the same one even if they are not one over each<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) { case .One: // do something reswitch .Two case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .OneAndAHalf // so something that you don’t want to do for .One<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reswitch .Two case .Two: // do something else that you may want<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to do for .One and .Two default: // and so one }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I must say that this is a side effect that can be used to messed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; up the code flow in a way that is not intended, but is a new<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; behaviour that gives more power to the switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The reswitch keyword in addition is not a mere fallthrough on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the new case without doing the optional checking attached to it,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but is intended to be a new call and all the check are executed.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch (enum) { case .One: // do something x = 0; reswitch .Two<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .OneAndAHalf // so something that you don’t want to do for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .One reswitch .Two case .Two where x &gt; 0: // do something else<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that you may want to do for .One and .Two element = array[x]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; default: // and so one } (I’m going by memory and by writing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this snippets in the mail app directly, so the code must be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; incorrect in the syntax and for this I’m sorry).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In this case if enum is .One the only case that is executed is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case .One and the code doesn’t fallthrough in the .Two case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; because we are made the where invalid by changing the x to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; value less than 1.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now I don’t remember who was the first one who mede this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal, and I don’t know if he is working on a first draft to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; lay down the things better, but for me this can be a nice<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; improvement and a neat break with the C-switch behaviour that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift has trying to change from the very first beta disallowing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the implicit fallthrough.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can be completely wrong but I see the `fallthrough`keyword as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a “temporary” implementation for ease the transition from Obj-C<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to Swift and is time to improve it and made the switch statement<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; even more powerful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Jacopo<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 19:57, Colin Barrett via swift-evolution &lt;<br>                swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; tl;dr The fallthrough keyword, as far as I am aware, isn’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; costing us anything; and has at least minimal utility, as I try<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to demonstrate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apologies for jumping into this thread at an awkward point, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve only just now subscribed to this list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the fallthrough keyword is useful in certain<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; circumstances. I’ve also yet to see an example of where it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; creates a negative impact, either in code, optimization, or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; what have you. Other than “It’s like something in C, and C is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; old and busted” I’m unsure of the rationale for removing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (Feel free to point me in the right direction.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Consider the Planet enum from the documentation. One of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; simplest way to define the number of a planet (i.e. its 1-based<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; index in the ordering of planets wrt. distance from the sun) is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using a switch and fall-through:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/cbarrett/23b24a9fe76efdf006df<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This technique is very extensible — for instance imagine<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; computing the force induced by the gravity of the other planets<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on a particular planet. All that would need to change is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, you could write this by putting the planets into a list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and mapping or folding (or looping) over that, but unless the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; compiler can “unroll” that construct, you’re paying for an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; allocation simply bc of your choice of control flow. But in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fact, you could imagine generalizing this construct into the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation of fold for the Planet type — low-overhead folds<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for monomorphic types seems like a pretty compelling an natural<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; use case for fallthrough to me.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks, -Colin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 4:52 AM, Jacopo Andrea Giola via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution &lt;<br>                     swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for this idea, but I will prefer the reswitch keyword<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of overloading continue with a new syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If this proposal is accepted, it must be coupled with a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; compiler check that the reswitch statements don&#39;t introduce an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; infinite &quot;switch&quot; loop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 06 Dec 2015, at 00:23, Steve Canon via swift-evolution &lt;<br>                       swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much thinking out loud and not really the implications,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wonder if we might just use &quot;continue&quot; instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;reswitch&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I very much like specifying what case to fall through into,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; no matter how we spell it.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Steve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 4:45 PM, John McCall via swift-evolution &lt;<br>                         swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 5, 2015, at 1:31 PM, John McCall via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;<br>                             swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 11:37 PM, John Calsbeek &lt;<br>                                 john.calsbeek+lists at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough` is conceptually similar to `goto` in that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; both allow natural expression of concepts that exist at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the instruction level but are otherwise difficult to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; express with nested control structures. `fallthrough` is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; perhaps slightly less objectionable because control flow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; remains local, but it has a similar role.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not particularly natural to write `switch`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statements with `fallthrough` in the reverse order that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be seen in Duff’s Device and similar constructs (case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 7 falls through to 6 which falls through to 5, etc.). It’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; just because you know for certain that all the code in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case 6 would be duplicated in case 7, so 7 can transfer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; into 6 without a jump instruction. Communicating that to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the compiler without `fallthrough` requires deeply nested<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `if`s.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right.  One idea that I’ve always had for “fallthrough” is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that we might parameterize it in the future; parameterized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it would mean “repeat the switch with this new value”, so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that unparameterized fallthrough would mean “repeat the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch with a notional value that ends up in the next<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case”.  There’s a very common pattern in switches of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; deferring to another case that I’ve always found very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; awkward to write in C, and while sometimes there’s no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; choice but to extract a helper function, there’s a still-fairly-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; structural code pattern here that I think we can sensibly<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; support.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On the other hand, there’s an argument that this is an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inappropriate extension for “fallthrough” specifically,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is one reason we’ve never pursued it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh, I see that Joe already brought this up, spelled<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “reswitch”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One defense comes to mind: there is talk of Swift aiming<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; at systems programming. Is writing a threaded interpreter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; loop within the potential scope of Swift? That’s a use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case that could make use of both `fallthrough` and `goto`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (computed goto, really).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch op { case LOAD_INDIRECT:   in0 = memory[in1]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fallthrough case LOAD:   out0 = memory[in0] //... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am personally interested in the prospect of a language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that can scale up to high-level concepts and down to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; “portable assembler,” but I don’t know if that is the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right direction for Swift’s evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers, John<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:42 PM, John McCall &lt;<br>                                     rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:33 PM, Kevin Ballard &lt;<br>                                        kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s not actually Duff&#39;s Device. Duff&#39;s Device relies on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the fact that C switch statements don&#39;t actually<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; introduce a new scope, and so it overlaps a switch with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a do-while loop. This lets it only test the number of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bytes once, to jump into the middle of the loop, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; then it switches over to a while loop that decrements a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; counter every 8 instructions. Basically, it&#39;s a trick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for manual loop unrolling that deals with non-multiple-of-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8 counts efficiently.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To be pedantic, C switch statements do introduce a new<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; scope.  What Duff’s Device exploits is that switch is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; allowed to jump into (almost) arbitrary scopes, and cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can appear anywhere recursively inside a switch.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But your point that Swift’s switch requires cases to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; at the top level within a switch and thus prevents the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; use of Duff’s Device is 100% correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Steve&#39;s code is also an example of manual loop unrolling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that deals with non-multiple-of-8 counts, but it has<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; calculate the number of bytes on every iteration instead<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of once. It&#39;s a good example of one of the uses of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `fallthrough`, it&#39;s just not Duff&#39;s Device. It&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; impossible to use Duff&#39;s Device in Swift.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 4, 2015, at 02:16 PM, Greg Titus wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Streza’s source code is an example of Duff’s Device,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is a big place where switch fallthrough is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arguably the cleanest way to do things and the reason<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; why I’d personally prefer to keep it as part of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; language.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:12 PM, Erica Sadun &lt;<br>                                             erica at ericasadun.com&gt;<br>                                             wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Oh let it die, let it die. Any time I use fallthrough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I find myself re-factoring to stop using it.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *True fact*: On all of<br>                                                gist.github.com[1],<br>                                                there are only 22 gist<br>                                                results for &quot;fallthrough<br>                                                language:swift&quot;.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Half of those are people just testing out the feature.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Most of the remaining ones are just complex cases:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *case .Enum1, .Enum2:* expressed as<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *case .Enum1: fallthrough* *case .Enum2:*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And then there&#39;s streza:<br>                                               https://gist.github.com/stevestreza/2557dc5ec9e7c694d7ea<br>                                               I&#39;m pretty sure that<br>                                               ponies were harmed in the<br>                                               production of whatever<br>                                               that last bit is.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 4, 2015, at 3:05 PM,<br>                                                  jalkut at red-<br>                                                  sweater.com wrote:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or C++ style artifacts, what do folks think about the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; possibility of removing the &quot;fallthrough&quot; keyword<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from the language?<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My understanding is this keyword is only used for the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; archaic seeming purpose of perpetuating C-style<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fallthrough from one switch statement to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subsequent one. The documentation hedges the use of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this keyword in forbidding terms that make it clear<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; its use is not encouraged. The presence of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; keyword, while an improvement over C’s implicit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fallthrough, is a mark of inelegance on an otherwise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; well-designed, opinionated implementation of swtich<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statements.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The ugliness of fallthrough’s C-style behavior even<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; demands a caveat in the documentation:<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;The fallthrough keyword does not check the case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conditions for the switch case that it causes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; execution to fall into. The fallthrough keyword<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; simply causes code execution to move directly to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statements inside the next case (or default case)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; block, as in C’s standard switch statement behavior.&quot;<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To my mind, the caveat explains just what is wrong<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with fallthrough, both in C or Swift: coded that is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; clearly labeled with deliberate conditions can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nonetheless be reached.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I quipped about this on Twitter, and the most common<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pushback I got seemed to be from people who either<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; did not know about Swift’s support for comma-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; separated case statements, or harbored an aesthetic<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; preference for clustering such cases together with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fallthrough statements.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In my opinion, unless somebody can think of a strong<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; defense for supporting intentional fallthrough in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift, removing the keyword would be a move in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; direction of minimizing the language’s complexity<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while also discouraging poor coding style in switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; statements.<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Daniel<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br></p><p>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Untracked with<br> Trackbuster[2]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _________________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>Links:<br></p><p>  1. http://gist.github.com/<br>  2. https://trackbuster.com/?sig<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/2920025b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 1:42 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Or alternatively, if you want to preserve `break` in the switch, you can write it so `continue` is required to repeat:<br>&gt;  <br>&gt; var value = ...<br>&gt; repeat {<br>&gt;     switch value {<br>&gt;     case ...:<br>&gt;         ...<br>&gt;         // reswitch<br>&gt;         value = ...<br>&gt;         continue<br>&gt;     case ...:<br>&gt;         break<br>&gt;     }<br>&gt;     break<br>&gt; } while true<br>&gt;  <br></p><p>We support labeled break out of switches and if statements.  While we intentionally do not support labeled continue on these constructs, that would be another way to express this sort of construct, without adding another level of indentation.  We don’t support labeled continue on them because we expressly did not want to turn “if” into a loop :-), but also out of conservatism.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/ee8023b8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 12:38 PM, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 8:55 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt;&gt; <br>&gt;&gt; Infinite reswitch loops seem useful. I&#39;m thinking in particular of interpreter loops, where it&#39;s common to use GCC&#39;s computed goto extension when written in C.<br>&gt; <br>&gt; I agree that they have useful semantics; I just wonder if it’s more clear to have explicit recursion (with TCO ;) rather than to add a looping construct that effectively does the same thing...<br>&gt; <br>&gt; Can’t lie though, given the lack of TCO in Swift, a keyword like this would probably mean fewer stack frames in code I’ve written myself (for instance, a parser combinator library).<br></p><p>Semantically they&#39;re equivalent, but you&#39;re putting more into the optimizer&#39;s hands than many would feel comfortable with. TCO notwithstanding, the naive CFG that results from a self-recursive call still funnels the switch dispatch jump into the top of the loop, which means you&#39;re sharing one branch predictor slot for every &quot;reswitch&quot;. This is one of the main reasons computed goto exists in GCC instead of letting people just use &#39;switch x { }; unreachable()&#39;. An explicit &quot;reswitch&quot; could emit the rebranch in-line at the reswitch point. <br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/08778d21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 1:43 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 12:38 PM, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 8:55 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 1:14 PM, Jacopo Andrea Giola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, I’m aware that at this time the reswitch can be abused and maybe can be better refined to disallow such cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Infinite reswitch loops seem useful. I&#39;m thinking in particular of interpreter loops, where it&#39;s common to use GCC&#39;s computed goto extension when written in C.<br>&gt;&gt; <br>&gt;&gt; I agree that they have useful semantics; I just wonder if it’s more clear to have explicit recursion (with TCO ;) rather than to add a looping construct that effectively does the same thing...<br>&gt;&gt; <br>&gt;&gt; Can’t lie though, given the lack of TCO in Swift, a keyword like this would probably mean fewer stack frames in code I’ve written myself (for instance, a parser combinator library).<br>&gt; <br>&gt; Semantically they&#39;re equivalent, but you&#39;re putting more into the optimizer&#39;s hands than many would feel comfortable with. TCO notwithstanding, the naive CFG that results from a self-recursive call still funnels the switch dispatch jump into the top of the loop, which means you&#39;re sharing one branch predictor slot for every &quot;reswitch&quot;. This is one of the main reasons computed goto exists in GCC instead of letting people just use &#39;switch x { }; unreachable()&#39;. An explicit &quot;reswitch&quot; could emit the rebranch in-line at the reswitch point. <br></p><p>I took a look at the manual for computed goto, and I think I understand now. Instead of  always branching back the top of the switch, you can branch directly to whichever case you know you need to go to -- the branch is now entirely computed at the call site, instead of indirecting thru the (recursive) callee. Thanks Joe!<br></p><p>-Colin (via thumbs)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/cefcefe9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>I’ve always shied away from fallthrough no matter what language I’m using. Perhaps there are situations where it is required, but in spirit I agree it maybe should be removed.<br></p><p>I’d amend this to also prevent “break” from applying to switch statements so that they can break out of loops if you’ve nested a switch inside of a loop. I ran into this situation and spent entirely too long confused about why it didn’t break out like I thought it should have:<br></p><p>for thing in collection {<br>  switch thing {<br>  case .Special: break<br>  default { … }<br>  }<br>}<br></p><p>The reason I expected this to work is that I don’t need to use a “break” in Swift cases so it stood to reason this would mean the “break” statement would only apply to the loop. I was wrong. :P<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 4, 2015, at 4:05 PM, jalkut at red-sweater.com wrote:<br>&gt; <br>&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt; <br>&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt; <br>&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt; <br>&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt; <br>&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt; <br>&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt; <br>&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Daniel<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>I don&#39;t use `fallthrough` very often, but when I do, it&#39;s extremely<br>useful. Removing it would make some of my code significantly harder to<br>read. In fact, I actually wish `fallthrough` was more powerful, allowing<br>me to fall into cases that bound identifiers if every bound identifier<br>was already bound with the same type in the current case, though I<br>understand why the language doesn&#39;t allow it (it&#39;s significant<br>complexity for a relatively minor gain).<br></p><p>Similarly, the ability to use `break` in switch statements, while not<br>something I use very often outside of using it for empty cases, is still<br>invaluable when I do occasionally need it. And since you can already<br>break out of loops by using a label, I don&#39;t see why we should remove<br>it. An example of doing that is<br></p><p>loop: for thing in collection {<br>    switch thing {<br>    case .Special: break loop<br>    default: ...<br>    }<br>}<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 02:14 PM, Sean Heber wrote:<br>&gt; I’ve always shied away from fallthrough no matter what language I’m<br>&gt; using. Perhaps there are situations where it is required, but in spirit I<br>&gt; agree it maybe should be removed.<br>&gt; <br>&gt; I’d amend this to also prevent “break” from applying to switch statements<br>&gt; so that they can break out of loops if you’ve nested a switch inside of a<br>&gt; loop. I ran into this situation and spent entirely too long confused<br>&gt; about why it didn’t break out like I thought it should have:<br>&gt; <br>&gt; for thing in collection {<br>&gt;   switch thing {<br>&gt;   case .Special: break<br>&gt;   default { … }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; The reason I expected this to work is that I don’t need to use a “break”<br>&gt; in Swift cases so it stood to reason this would mean the “break”<br>&gt; statement would only apply to the loop. I was wrong. :P<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 4, 2015, at 4:05 PM, jalkut at red-sweater.com wrote:<br>&gt; &gt; <br>&gt; &gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt; &gt; <br>&gt; &gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt; &gt; <br>&gt; &gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt; &gt; <br>&gt; &gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt; &gt; <br>&gt; &gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt; &gt; <br>&gt; &gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt; &gt; <br>&gt; &gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt; &gt; <br>&gt; &gt; Thoughts?<br>&gt; &gt; <br>&gt; &gt; Daniel<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a37f99aa1daf8c27aaa81e4f019484d?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Andy Matuschak</string> &lt;andy at andymatuschak.org&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>On a few occasions, fallthrough has been the most expressive path for a non-performance-related reason: rather, because it’s not possible to destructure a value and also have multiple predicates in a case, e.g.<br></p><p>switch downloadStatus {<br>	case let .Downloading(progress) where progress == 0.0:<br>		fallthrough<br>	case .NotStarted:<br>		// do things implying we have no data<br>	default:<br>		// do things implying we have some data<br>}<br></p><p>Of course, we might resolve this by changing the destructuring semantics.<br></p><p>&gt; On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com wrote:<br>&gt; <br>&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt; <br>&gt; My understanding is this keyword is only used for the archaic seeming purpose of perpetuating C-style fallthrough from one switch statement to the subsequent one. The documentation hedges the use of this keyword in forbidding terms that make it clear its use is not encouraged. The presence of the keyword, while an improvement over C’s implicit fallthrough, is a mark of inelegance on an otherwise well-designed, opinionated implementation of swtich statements.<br>&gt; <br>&gt; The ugliness of fallthrough’s C-style behavior even demands a caveat in the documentation:<br>&gt; <br>&gt; &quot;The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.&quot;<br>&gt; <br>&gt; To my mind, the caveat explains just what is wrong with fallthrough, both in C or Swift: coded that is clearly labeled with deliberate conditions can nonetheless be reached.<br>&gt; <br>&gt; I quipped about this on Twitter, and the most common pushback I got seemed to be from people who either did not know about Swift’s support for comma-separated case statements, or harbored an aesthetic preference for clustering such cases together with fallthrough statements.<br>&gt; <br>&gt; In my opinion, unless somebody can think of a strong defense for supporting intentional fallthrough in Swift, removing the keyword would be a move in the direction of minimizing the language’s complexity while also discouraging poor coding style in switch statements.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Daniel<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/66f1fb80/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 09:00:00am</p></header><div class="content"><p>On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com wrote:<br>&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br></p><p>I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are &quot;syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.<br></p><p>All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness&quot; of fallthrough.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>December  5, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 9:02 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com wrote:<br>&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt; <br>&gt; I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are &quot;syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.<br>&gt; <br>&gt; All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness&quot; of fallthrough.<br></p><p>Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.<br></p><p>in system programming C, I find myself writing things like this very often:<br></p><p><br>switch (some_value) {<br>case ENUM_VALUE_REFINED:<br>    if (validate(some_value)) {<br>        return NULL;<br>    }<br>    /* fallthrough */<br>case ENUM_VALUE_BASE:<br>    handle_enum_value();<br>    …<br>}<br></p><p>Where the swift equivalent would roughly be:<br></p><p>switch some_value {<br>case .REFINED:<br>    if !validate(some_value) { return NULL }<br>    fallthrough<br>case .BASE:<br>    handle_enum_value();<br>}<br></p><p>This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.<br></p><p>Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:<br></p><p>switch (some_value) {<br>case ENUM_VALUE_REFINED_1:<br>    if (validate(some_value)) {<br>        return NULL;<br>    }<br>    goto base_value;<br>case ENUM_VALUE_REFINED_2:<br>    if (validate(some_value)) {<br>        return NULL;<br>    }<br>    goto base_value;<br></p><p>case ENUM_VALUE_BASE:<br>base_value:<br>    handle_enum_value();<br>    …<br>}<br></p><p><br>cannot be written in swift, despite also being quite useful.<br></p><p>Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.<br></p><p>-Pierre<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/0198fd04/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/706baf09e574d70814e4af2d54a315e0?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Vinicius Vendramini</string> &lt;vinivendra at gmail.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.<br></p><p>In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like<br></p><p>if some_value == .Refined &amp;&amp; !validate(some_value) {<br>	return NULL<br>}<br>handle_enum_value()<br></p><p>More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.<br></p><p>&gt; On Dec 5, 2015, at 12:15 PM, Pierre Habouzit &lt;phabouzit at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 9:02 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt; <br>&gt;&gt; I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are &quot;syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.<br>&gt;&gt; <br>&gt;&gt; All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness&quot; of fallthrough.<br>&gt; <br>&gt; Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.<br>&gt; <br>&gt; in system programming C, I find myself writing things like this very often:<br>&gt; <br>&gt; <br>&gt; switch (some_value) {<br>&gt; case ENUM_VALUE_REFINED:<br>&gt;     if (validate(some_value)) {<br>&gt;         return NULL;<br>&gt;     }<br>&gt;     /* fallthrough */<br>&gt; case ENUM_VALUE_BASE:<br>&gt;     handle_enum_value();<br>&gt;     …<br>&gt; }<br>&gt; <br>&gt; Where the swift equivalent would roughly be:<br>&gt; <br>&gt; switch some_value {<br>&gt; case .REFINED:<br>&gt;     if !validate(some_value) { return NULL }<br>&gt;     fallthrough<br>&gt; case .BASE:<br>&gt;     handle_enum_value();<br>&gt; }<br>&gt; <br>&gt; This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.<br>&gt; <br>&gt; Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:<br>&gt; <br>&gt; switch (some_value) {<br>&gt; case ENUM_VALUE_REFINED_1:<br>&gt;     if (validate(some_value)) {<br>&gt;         return NULL;<br>&gt;     }<br>&gt;     goto base_value;<br>&gt; case ENUM_VALUE_REFINED_2:<br>&gt;     if (validate(some_value)) {<br>&gt;         return NULL;<br>&gt;     }<br>&gt;     goto base_value;<br>&gt; <br>&gt; case ENUM_VALUE_BASE:<br>&gt; base_value:<br>&gt;     handle_enum_value();<br>&gt;     …<br>&gt; }<br>&gt; <br>&gt; <br>&gt; cannot be written in swift, despite also being quite useful.<br>&gt; <br>&gt; Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.<br>&gt; <br>&gt; -Pierre<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/2db69eba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>Is there a reason we cannot use labelled case statements?<br></p><p>    switch some_value {<br>    case .REFINED:<br>        if !validate(some_value) { return NULL }<br>        fallthrough base<br></p><p>    base: case .BASE:<br>        handle_enum_value();<br>    }<br></p><p>At least this is explicit now.<br></p><p>&gt; On Dec 5, 2015, at 10:04 AM, Vinicius Vendramini &lt;vinivendra at gmail.com&gt; wrote:<br>&gt; <br>&gt; I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.<br>&gt; <br>&gt; In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like<br>&gt; <br>&gt; if some_value == .Refined &amp;&amp; !validate(some_value) {<br>&gt; 	return NULL<br>&gt; }<br>&gt; handle_enum_value()<br>&gt; <br>&gt; More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.<br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 12:15 PM, Pierre Habouzit &lt;phabouzit at apple.com &lt;mailto:phabouzit at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 5, 2015, at 9:02 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are &quot;syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness&quot; of fallthrough.<br>&gt;&gt; <br>&gt;&gt; Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.<br>&gt;&gt; <br>&gt;&gt; in system programming C, I find myself writing things like this very often:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; switch (some_value) {<br>&gt;&gt; case ENUM_VALUE_REFINED:<br>&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;         return NULL;<br>&gt;&gt;     }<br>&gt;&gt;     /* fallthrough */<br>&gt;&gt; case ENUM_VALUE_BASE:<br>&gt;&gt;     handle_enum_value();<br>&gt;&gt;     …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Where the swift equivalent would roughly be:<br>&gt;&gt; <br>&gt;&gt; switch some_value {<br>&gt;&gt; case .REFINED:<br>&gt;&gt;     if !validate(some_value) { return NULL }<br>&gt;&gt;     fallthrough<br>&gt;&gt; case .BASE:<br>&gt;&gt;     handle_enum_value();<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.<br>&gt;&gt; <br>&gt;&gt; Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:<br>&gt;&gt; <br>&gt;&gt; switch (some_value) {<br>&gt;&gt; case ENUM_VALUE_REFINED_1:<br>&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;         return NULL;<br>&gt;&gt;     }<br>&gt;&gt;     goto base_value;<br>&gt;&gt; case ENUM_VALUE_REFINED_2:<br>&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;         return NULL;<br>&gt;&gt;     }<br>&gt;&gt;     goto base_value;<br>&gt;&gt; <br>&gt;&gt; case ENUM_VALUE_BASE:<br>&gt;&gt; base_value:<br>&gt;&gt;     handle_enum_value();<br>&gt;&gt;     …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; cannot be written in swift, despite also being quite useful.<br>&gt;&gt; <br>&gt;&gt; Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.<br>&gt;&gt; <br>&gt;&gt; -Pierre<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/f210f882/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 10:13 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Is there a reason we cannot use labelled case statements?<br>&gt; <br>&gt;     switch some_value {<br>&gt;     case .REFINED:<br>&gt;         if !validate(some_value) { return NULL }<br>&gt;         fallthrough base<br>&gt; <br>&gt;     base: case .BASE:<br>&gt;         handle_enum_value();<br>&gt;     }<br>&gt; <br>&gt; At least this is explicit now.<br></p><p>that would be awesome.<br></p><p>&gt; <br>&gt;&gt; On Dec 5, 2015, at 10:04 AM, Vinicius Vendramini &lt;vinivendra at gmail.com &lt;mailto:vinivendra at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.<br>&gt;&gt; <br>&gt;&gt; In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like<br></p><p>the pattern I showed is really really pervasive in system programming code, especially because in that example below:<br></p><p>&gt;&gt; if some_value == .Refined &amp;&amp; !validate(some_value) {<br>&gt;&gt; 	return NULL<br>&gt;&gt; }<br>&gt;&gt; handle_enum_value()<br></p><p><br>the “validate” is shifted to the right, which hides the essential thing you’re doing, which is the validation.<br>it is important to me to see the validation stand out and be one indent level away, and not arbitrarily pushed to the right.<br></p><p>it allows to read your code keeping your eyes aligned on the first columns of your text editor to get a sense of the flow of what is going on.<br></p><p>David’s example has this property and I find it very desireable.<br></p><p><br>&gt;&gt; More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 5, 2015, at 12:15 PM, Pierre Habouzit &lt;phabouzit at apple.com &lt;mailto:phabouzit at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 5, 2015, at 9:02 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are &quot;syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness&quot; of fallthrough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; in system programming C, I find myself writing things like this very often:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (some_value) {<br>&gt;&gt;&gt; case ENUM_VALUE_REFINED:<br>&gt;&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;&gt;         return NULL;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     /* fallthrough */<br>&gt;&gt;&gt; case ENUM_VALUE_BASE:<br>&gt;&gt;&gt;     handle_enum_value();<br>&gt;&gt;&gt;     …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where the swift equivalent would roughly be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch some_value {<br>&gt;&gt;&gt; case .REFINED:<br>&gt;&gt;&gt;     if !validate(some_value) { return NULL }<br>&gt;&gt;&gt;     fallthrough<br>&gt;&gt;&gt; case .BASE:<br>&gt;&gt;&gt;     handle_enum_value();<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (some_value) {<br>&gt;&gt;&gt; case ENUM_VALUE_REFINED_1:<br>&gt;&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;&gt;         return NULL;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     goto base_value;<br>&gt;&gt;&gt; case ENUM_VALUE_REFINED_2:<br>&gt;&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;&gt;         return NULL;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     goto base_value;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case ENUM_VALUE_BASE:<br>&gt;&gt;&gt; base_value:<br>&gt;&gt;&gt;     handle_enum_value();<br>&gt;&gt;&gt;     …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; cannot be written in swift, despite also being quite useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Pierre<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/9cba0e16/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Remove the &quot;fallthrough&quot; keyword</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 10:13 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Is there a reason we cannot use labelled case statements?<br>&gt; <br>&gt;     switch some_value {<br>&gt;     case .REFINED:<br>&gt;         if !validate(some_value) { return NULL }<br>&gt;         fallthrough base<br>&gt; <br>&gt;     base: case .BASE:<br>&gt;         handle_enum_value();<br>&gt;     }<br>&gt; <br>&gt; At least this is explicit now.<br></p><p>Yeah, maybe there&#39;s a more general language feature that could replace &#39;fallthrough&#39; here. Instead of labelling cases, we could support a &#39;reswitch&#39; statement that redispatches the switch to the case matching the operand:<br></p><p>    switch some_value {<br>    case .REFINED:<br>        if !validate(some_value) { return NULL }<br>        reswitch .BASE<br></p><p>    case .BASE:<br>        handle_enum_value();<br>    }<br></p><p>That should be easy to peephole to a proper fallthrough in constant cases, but would also nicely generalize to applications like interpreters, where it&#39;s often desirable to push the dispatch inline into the logic for better pipelining.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; On Dec 5, 2015, at 10:04 AM, Vinicius Vendramini &lt;vinivendra at gmail.com &lt;mailto:vinivendra at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I understand there might be some cases in which the syntax provided is indeed useful for experienced programmers writing their code. However, in almost all the examples here, I had to struggle to understand the logic behind the code. Not because it’s poorly written... probably because this syntax may be used for many different purposes, so it’s hard to get what exactly is the intent behind each use.<br>&gt;&gt; <br>&gt;&gt; In Pierre’s latest example, for instance, it took me a few seconds to understand what was going on. I know it’s a simplified case, but it seems clearer to me to just write something like<br>&gt;&gt; <br>&gt;&gt; if some_value == .Refined &amp;&amp; !validate(some_value) {<br>&gt;&gt; 	return NULL<br>&gt;&gt; }<br>&gt;&gt; handle_enum_value()<br>&gt;&gt; <br>&gt;&gt; More complex cases make for a better argument for `switch`es, mainly because they avoid big `if` pyramids, but especially in those I feel the resulting code is significantly harder to understand.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 5, 2015, at 12:15 PM, Pierre Habouzit &lt;phabouzit at apple.com &lt;mailto:phabouzit at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 5, 2015, at 9:02 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 4, 2015, at 2:05 PM, jalkut at red-sweater.com &lt;mailto:jalkut at red-sweater.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; In the spirit of some other proposals that remove C or C++ style artifacts, what do folks think about the possibility of removing the &quot;fallthrough&quot; keyword from the language?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not making an argument either way, but I want to point something out: there is a major difference between fallthrough vs ++/c-style-for.  To someone who doesn’t know them, the later are &quot;syntactic magic” with no reasonable way to decipher other than looking them up somewhere.  The former is an English word whose meaning is obvious in context.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All I’m saying is that to a reader of code, the “badness” of ++ and c-style for loops is greater than the “badness&quot; of fallthrough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that Swift has the goal to also be a low level language, fallthrough is really useful for conciseness and readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; in system programming C, I find myself writing things like this very often:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (some_value) {<br>&gt;&gt;&gt; case ENUM_VALUE_REFINED:<br>&gt;&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;&gt;         return NULL;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     /* fallthrough */<br>&gt;&gt;&gt; case ENUM_VALUE_BASE:<br>&gt;&gt;&gt;     handle_enum_value();<br>&gt;&gt;&gt;     …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where the swift equivalent would roughly be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch some_value {<br>&gt;&gt;&gt; case .REFINED:<br>&gt;&gt;&gt;     if !validate(some_value) { return NULL }<br>&gt;&gt;&gt;     fallthrough<br>&gt;&gt;&gt; case .BASE:<br>&gt;&gt;&gt;     handle_enum_value();<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is as readable as it gets and is a pattern that the libdispatch has in several places e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, you cannot fall through to arbitrary cases, so things like this C code cannot be done in swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; switch (some_value) {<br>&gt;&gt;&gt; case ENUM_VALUE_REFINED_1:<br>&gt;&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;&gt;         return NULL;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     goto base_value;<br>&gt;&gt;&gt; case ENUM_VALUE_REFINED_2:<br>&gt;&gt;&gt;     if (validate(some_value)) {<br>&gt;&gt;&gt;         return NULL;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     goto base_value;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case ENUM_VALUE_BASE:<br>&gt;&gt;&gt; base_value:<br>&gt;&gt;&gt;     handle_enum_value();<br>&gt;&gt;&gt;     …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; cannot be written in swift, despite also being quite useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jumping between arbitrary points inside a switch is disgusting. jumping from label to label is useful and not harmful especially in swift where you can’t place code between the “switch” and the first case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Pierre<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/193d117e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
