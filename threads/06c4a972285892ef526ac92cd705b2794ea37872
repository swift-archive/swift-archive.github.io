<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 13, 2016 at 01:00:00pm</p></header><div class="content"><p>Am 13. Mai 2016 um 09:36 schrieb &quot;Vladimir.S via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;:<br></p><p><br>Why did you decide to drop the `#` ? As `StaticSelf` will be resolved on<br>compilation time like #file etc ? I feel like this is inconsistent solution.<br></p><p><br># is not needed just like it is not needed for generic type parameters which are also resolved at compilation time. <br>#file etc. insert information about artefacts outside of the language (i.e. the name of the file wherein the code resides) which is very different.<br></p><p><br>-Thorsten<br></p><p><br></p><p><br></p><p><br>Also, do you expect this will work:<br></p><p>protocol A {<br>func g()-&gt;StaticSelf<br>}<br></p><p>class B: A {<br>func g()-&gt;StaticSelf {return B()}<br>}<br></p><p>class C: B {<br>//func f(s: C) {}<br>}<br></p><p>func x(a: A ){<br>var xx : A = a.g() // ?<br>print(xx)<br>}<br></p><p>func z&lt;T: A&gt;(t: T) {<br>let u = t.g() // ?<br>print(u)<br>}<br></p><p>let c = C()<br>z(c)<br>x(c)<br></p><p><br>On 13.05.2016 3:49, Matthew Johnson via swift-evolution wrote:<br></p><p>Erica Sadun and I have written a proposal are following up the recent<br>discussion thread &quot;[RFC] #Self” with a proposal to introduce StaticSelf, an<br>invariant Self.<br></p><p><br>The recent discussion can be found<br>here: http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565<br></p><p><br></p><p>The proposal can be found<br>here: https://github.com/anandabits/swift-evolution/blob/static-self/proposals/NNNN-static-self.md<br></p><p><br></p><p>We look forward to continuing the discussion. We plan to submit a PR in<br>the near future after incorporating your final feedback.<br></p><p><br>Thanks,<br>Matthew<br></p><p><br></p><p><br>Introducing StaticSelf, an Invariant Self<br></p><p><br>* Proposal: TBD<br>* Authors: Matthew Johnson &lt;https://github.com/anandabits&gt;, Erica Sadun<br>&lt;https://github.com/erica&gt;<br></p><p>* Status: TBD<br>* Review manager: TBD<br></p><p><br></p><p><br>Introduction<br></p><p><br>This proposal introduces a new keyword that provides consistent invariant<br>type semantics in all contexts.<br></p><p><br>/The Swift-evolution thread about this topic can be found here: [RFC] #Self<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/16565&gt;/<br></p><p><br></p><p><br></p><p>Motivation<br></p><p><br>The distinction between covariant and non-covariant type references come<br>into play when<br>conforming non-final classes to protocols. Fixing a protocol requirement to<br>a covarying type<br>means that a method returning |Self| must be overriden by all subclasses in<br>order to return<br>the correct, matching type.<br></p><p><br>This proposal builds on the covariant construct |Self| accepted in SE–0068<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md&gt;<br></p><p>to introduce an invariant type identifier. It enables protocol declarations<br>to consistently<br>refer to a type that is fixed at compile time. This ensures that subclasses<br>can inherit<br>protocol implementations without having to re-implement that code at each<br>level of<br>inheritance.<br></p><p><br>Under this proposal, a new identifier keyword is fixed in use /at the point<br>of protocol conformance/<br>to the static type of that construct.<br></p><p><br>|class A: MyProtocol|<br></p><p><br>The invariant |StaticSelf| identifier will always refer to |A|,<br>unlike |Self|, which is covarying and refers to<br>the type of the actual instance. Since multiple inheritance for<br>non-protocol types is disallowed,<br>this establishes this invariant type identifier with no possibility for<br>conflict.<br></p><p><br>Consider the following example, under the current system:<br></p><p><br>|protocol StringCreatable { static func createWithString(s: String) -&gt; Self<br>} extension NSURL: StringCreatable { // cannot conform because NSURL is<br>non-final // error: method &#39;createWithString&#39; in non-final class &#39;NSURL&#39;<br>must return `Self` to conform to protocol &#39;A&#39; }|<br></p><p><br>Introducing a static, invariant version of |Self| permits the desired<br>conformance:<br></p><p><br>|protocol StringCreatable { static func createWithString(s: String) -&gt;<br>StaticSelf } extension NSURL: StringCreatable { // can now conform conform<br>because NSURL is fixed and matches the static // type of the conforming<br>construct. Subclasses need not re-implement // NOTE: the return type can be<br>declared as StaticSelf *or* as NSURL // they are interchangeable static<br>func createWithString(s: String) -&gt; StaticSelf { // ... } }|<br></p><p><br></p><p><br>Additional Utility<br></p><p><br>The utility of |StaticSelf| is not limited to protocols. A secondary use<br>enables code to refer to the lexical context’s current type without<br>explicitly mentioning its name. This provides a useful shortcut when<br>referencing static type members with especially long names and when<br>re-purposing code between types.<br></p><p><br>|class StructWithAVeryLongName { static func foo() -&gt; String { // ... } func<br>bar() { // ... let s = StaticSelf.foo() // } }|<br></p><p><br></p><p><br>Detailed Design<br></p><p><br>This proposal introduces |StaticSelf|, a new keyword that may be used in<br>protocols to refer to the invariant static type of a conforming<br>construct. |StaticSelf| may also be used in the lexical context of any type<br>declaration. In such use, the keyword is identical to spelling out the full<br>name of that type.<br></p><p><br></p><p><br>Impact on existing code<br></p><p><br>Being additive, there should be no impact on existing code.<br></p><p><br></p><p><br>Alternatives considered<br></p><p><br>The keyword is not fixed at this time. Alternatives that have been<br>discussed include |StaticType|, |InvariantSelf|, |SelfType|, or |Type|. The<br>community is welcome to bikeshed on the most clear and concise name for<br>this keyword.<br></p><p><br></p><p><br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/06c47872/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
