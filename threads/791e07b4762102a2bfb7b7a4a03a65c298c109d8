<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 19, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced&quot; begins now and runs through July 22. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0125-remove-nonobjectivecbase.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 19, 2016 at 11:00:00pm</p></header><div class="content"><p>On Tue, Jul 19, 2016 at 10:51 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; The review of &quot;SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced&quot; begins now and runs through July 22. The proposal is available here:<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0125-remove-nonobjectivecbase.md<br></p><p>I like the API simplification.  A few thoughts that I have after<br>reading the proposal that could take the simplification it even<br>further:<br></p><p>- I find it a little strange to see a mention of Objective-C, and a<br>negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>import, would we need to rename it to<br>`isUniquelyReferencedNonObjCAndNonCXX`?  I think that is the issue<br>with negation.  If we want to emphasize that the API will work only<br>with Swift types, we can do something<br>`isUniquelyReferencedSwiftReference`.  But I would probably suggest<br>that we just go with just `isUniquelyReferenced` and mention the<br>Swift-only requirement in the documentation.<br></p><p>- I find the use of different names in `isUniquelyReferenced()` and<br>`ManagedBufferPointer.holdsUniqueReference()` to be strange.  Why not<br>call the latter `ManagedBufferPointer. isUniquelyReferenced()`?  It is<br>true that we are not checking that pointer is not uniquely referenced,<br>if we want to emphasize that, maybe something like<br>`ManagedBufferPointer.isBufferUniquelyReferenced()` or<br>`isPointeeUniquelyReferenced()` will work?<br></p><p>The reason why I&#39;m suggesting this is that `isUniquelyReferenced` and<br>`holdsUniqueReference` don&#39;t immediately strike me as performing the<br>same operation, the immediate impression I get is that these<br>operations are related, but subtly different, and it is not obvious<br>what the difference is (but after reading the docs I figure out that<br>there is no difference... until I need to use these APIs again).<br></p><p>- We have `ManagedBufferPointer.holdsUniqueOrPinnedReference()`, but<br>don&#39;t have an equivalent free function `isUniquelyReferencedOrPinned`<br>(we actually have one, but it is internal).  Do we need a public one?<br>If we do, we could as well add it as a part of this proposal, while we<br>are cleaning up this library subsystem.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 20, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Jul 19, 2016, at 11:06 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt; import, would we need to rename it to<br>&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  I think that is the issue<br>&gt; with negation.  If we want to emphasize that the API will work only<br>&gt; with Swift types, we can do something<br>&gt; `isUniquelyReferencedSwiftReference`.  But I would probably suggest<br>&gt; that we just go with just `isUniquelyReferenced` and mention the<br>&gt; Swift-only requirement in the documentation.<br></p><p>I agree.<br></p><p>What is the reason that isUniquelyReferenced(_:) doesn&#39;t work with Objective-C? It doesn&#39;t seem like it&#39;d be difficult to implement—you&#39;d either call -retainCount, or get it from the Objective-C runtime somehow, and then test it against 1—so I assume there&#39;s a reason we don&#39;t.<br></p><p>I ask because knowing that may help us figure out how to name it. For instance, if the issue is that we can&#39;t rely on Objective-C reference counts, we might reverse the sense of the call and name it `mayBeShared(_:)` or `mayHaveOtherReferences(_:)`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 20 Jul 2016, at 11:13, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 19, 2016, at 11:06 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt;&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt;&gt; import, would we need to rename it to<br>&gt;&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  I think that is the issue<br>&gt;&gt; with negation.  If we want to emphasize that the API will work only<br>&gt;&gt; with Swift types, we can do something<br>&gt;&gt; `isUniquelyReferencedSwiftReference`.  But I would probably suggest<br>&gt;&gt; that we just go with just `isUniquelyReferenced` and mention the<br>&gt;&gt; Swift-only requirement in the documentation.<br>&gt; <br>&gt; I agree.<br>&gt; <br>&gt; What is the reason that isUniquelyReferenced(_:) doesn&#39;t work with Objective-C? It doesn&#39;t seem like it&#39;d be difficult to implement—you&#39;d either call -retainCount, or get it from the Objective-C runtime somehow, and then test it against 1—so I assume there&#39;s a reason we don&#39;t.<br>&gt; <br>&gt; I ask because knowing that may help us figure out how to name it. For instance, if the issue is that we can&#39;t rely on Objective-C reference counts, we might reverse the sense of the call and name it `mayBeShared(_:)` or `mayHaveOtherReferences(_:)`.<br></p><p>I&#39;m kind of undecided too; in fact it&#39;s never been clear to me why this is even a global function at all. In my mind the best solution would be some kind of ReferenceCounted class protocol with a .isUniquelyReferenced computed property, thus eliminating the global function entirely. The pure-Swift base type would conform to this protocol and provide the ability to test its uniqueness directly, though a static method could also be provided for testing unknown types as well (but I feel this is a relatively uncommon case), and the protocol conformance could be added to an Objective-C, C++ and so-on base-types whenever these are possible.<br></p><p>It also strikes me as odd that we have to specify a NonObjectiveCBase in any form (extension or function, doesn&#39;t really matter); I would think that a pure Swift base should be the default in most cases, with a distinction having to be made only when declaring public classes in a module with Objective-C bridging headers. In other words it feels strange that non-Objective-C is the exception, when the goal should be trying to write pure Swift code wherever possible.<br></p><p>I don&#39;t know about anyone else, but I mostly only use NonObjectiveCBase on private types implementing copy-on-write behaviour, so my only use-case for isUniquelyReferenced is private to the module anyway, so shouldn&#39;t really raise an issue of whether it&#39;s Objective-C compatible.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 5:03 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 20 Jul 2016, at 11:13, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 19, 2016, at 11:06 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt;&gt;&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt;&gt;&gt; import, would we need to rename it to<br>&gt;&gt;&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  I think that is the issue<br>&gt;&gt;&gt; with negation.  If we want to emphasize that the API will work only<br>&gt;&gt;&gt; with Swift types, we can do something<br>&gt;&gt;&gt; `isUniquelyReferencedSwiftReference`.  But I would probably suggest<br>&gt;&gt;&gt; that we just go with just `isUniquelyReferenced` and mention the<br>&gt;&gt;&gt; Swift-only requirement in the documentation.<br>&gt;&gt; <br>&gt;&gt; I agree.<br>&gt;&gt; <br>&gt;&gt; What is the reason that isUniquelyReferenced(_:) doesn&#39;t work with Objective-C? It doesn&#39;t seem like it&#39;d be difficult to implement—you&#39;d either call -retainCount, or get it from the Objective-C runtime somehow, and then test it against 1—so I assume there&#39;s a reason we don&#39;t.<br>&gt;&gt; <br>&gt;&gt; I ask because knowing that may help us figure out how to name it. For instance, if the issue is that we can&#39;t rely on Objective-C reference counts, we might reverse the sense of the call and name it `mayBeShared(_:)` or `mayHaveOtherReferences(_:)`.<br>&gt; <br>&gt; I&#39;m kind of undecided too; in fact it&#39;s never been clear to me why this is even a global function at all. In my mind the best solution would be some kind of ReferenceCounted class protocol with a .isUniquelyReferenced computed property, thus eliminating the global function entirely. The pure-Swift base type would conform to this protocol and provide the ability to test its uniqueness directly, though a static method could also be provided for testing unknown types as well (but I feel this is a relatively uncommon case), and the protocol conformance could be added to an Objective-C, C++ and so-on base-types whenever these are possible.<br>&gt; <br>&gt; It also strikes me as odd that we have to specify a NonObjectiveCBase in any form (extension or function, doesn&#39;t really matter); I would think that a pure Swift base should be the default in most cases, with a distinction having to be made only when declaring public classes in a module with Objective-C bridging headers. In other words it feels strange that non-Objective-C is the exception, when the goal should be trying to write pure Swift code wherever possible.<br>&gt; <br>&gt; I don&#39;t know about anyone else, but I mostly only use NonObjectiveCBase on private types implementing copy-on-write behaviour, so my only use-case for isUniquelyReferenced is private to the module anyway, so shouldn&#39;t really raise an issue of whether it&#39;s Objective-C compatible.<br></p><p>As mentioned in the other emails isUniquelyReferencedNonObjC works on @objc classes.<br></p><p>What has been misunderstood is the answer it returns. It returns false for @objc classes. Also see my other answers.<br></p><p> expectTrue(isUniquelyReferencedNonObjc(SwiftKlazz()))<br> expectFalse(isUniquelyReferencedNonObjc(ObjcKlazz()))<br> var y = SwiftKlazz()<br> var z = [Any]<br> z.append(y)<br> z.append(y)<br> expectFalse(isUniquelyReferencedNonObjc(y)<br></p><p>The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance.<br></p><p>isUniquelyReferencedNonObjC &lt;T: NonObjectiveBase&gt; was there as a separate function historically. Because it was faster. This has changed and there  is no need to have both anymore.<br></p><p>As mentioned in the proposal you can use isUniquelyReferencedNonObjC where you are using isUniquelyReferencedNonObjC today. And it is semantically equivalent and has the same performance.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 3:13 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 19, 2016, at 11:06 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt;&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt;&gt; import, would we need to rename it to<br>&gt;&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  I think that is the issue<br>&gt;&gt; with negation.  If we want to emphasize that the API will work only<br>&gt;&gt; with Swift types, we can do something<br>&gt;&gt; `isUniquelyReferencedSwiftReference`.  But I would probably suggest<br>&gt;&gt; that we just go with just `isUniquelyReferenced` and mention the<br>&gt;&gt; Swift-only requirement in the documentation.<br>&gt; <br>&gt; I agree.<br>&gt; <br>&gt; What is the reason that isUniquelyReferenced(_:) doesn&#39;t work with Objective-C? It doesn&#39;t seem like it&#39;d be difficult to implement—you&#39;d either call -retainCount, or get it from the Objective-C runtime somehow, and then test it against 1—so I assume there&#39;s a reason we don’t<br></p><p><br>Also, see my answer to Dmitri.<br></p><p>isUniquelyReferencedNonObjC checks that the object is a uniquely referenced swift only class. It works on non- at objc classes but will return false: The API will work for @objc-classes but return false.<br></p><p>The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance. (You can’t store to an NSArray for example, you would have to check it was a NSMutableArray, etc …)<br></p><p><br>&gt; I ask because knowing that may help us figure out how to name it. For instance, if the issue is that we can&#39;t rely on Objective-C reference counts, we might reverse the sense of the call and name it `mayBeShared(_:)` or `mayHaveOtherReferences(_:)`.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 20, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 5:59 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt; The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance. (You can’t store to an NSArray for example, you would have to check it was a NSMutableArray, etc …)<br></p><p>It sounds to me like this is specifically tuned to the bridging the standard library happens to do, but you could very well want the opposite behavior in other cases. (For instance, `NSCountedSet` and `NSURLComponents` are both always-mutable; COW structs built around them would want to examine their refcounts.)<br></p><p>Is this the design we want to publish to users of the standard library? Or would it be better to have an `isNonObjectiveC(_:)` call and an `isUniquelyReferenced(_:)` call, and perhaps wrap them into one call for the standard library&#39;s internal use?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 06:00:00am</p></header><div class="content"><p>On Darwin and iOS systems it would be hard to implement a uniques check efficiently for objective c objects.<br></p><p>You can&#39;t rely on retainCount is what I remember. NonPointer ISA, slide tables that contain weak and actual reference counts would make it hard to make such a check efficient.<br></p><p>This would certainly be out of scope for swift  3<br></p><p>We can add the API you propose later.<br></p><p>It has different semantics to the existing API.<br></p><p>Sent from my iPhone<br></p><p>On Jul 20, 2016, at 6:22 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 20, 2016, at 5:59 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance. (You can’t store to an NSArray for example, you would have to check it was a NSMutableArray, etc …)<br>&gt; <br>&gt; It sounds to me like this is specifically tuned to the bridging the standard library happens to do, but you could very well want the opposite behavior in other cases. (For instance, `NSCountedSet` and `NSURLComponents` are both always-mutable; COW structs built around them would want to examine their refcounts.)<br>&gt; <br>&gt; Is this the design we want to publish to users of the standard library? Or would it be better to have an `isNonObjectiveC(_:)` call and an `isUniquelyReferenced(_:)` call, and perhaps wrap them into one call for the standard library&#39;s internal use?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Jul 19, 2016, at 11:06 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Jul 19, 2016 at 10:51 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; The review of &quot;SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced&quot; begins now and runs through July 22. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/proposals/0125-remove-nonobjectivecbase.md<br>&gt; <br>&gt; I like the API simplification.  A few thoughts that I have after<br>&gt; reading the proposal that could take the simplification it even<br>&gt; further:<br>&gt; <br>&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt; import, would we need to rename it to<br>&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  I think that is the issue<br>&gt; with negation.  If we want to emphasize that the API will work only<br>&gt; with Swift types, we can do something<br>&gt; `isUniquelyReferencedSwiftReference`.  But I would probably suggest<br>&gt; that we just go with just `isUniquelyReferenced` and mention the<br>&gt; Swift-only requirement in the documentation.<br></p><p>isUniquelyReferencedNonObjC checks that the object is a uniquely referenced swift only class. It works on non- at objc classes but will return false: The API will work for @objc-classes but return false.<br></p><p>The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance.<br></p><p>  expectTrue(isUniquelyReferencedNonObjc(SwiftKlazz()))<br>  expectFalse(isUniquelyReferencedNonObjc(ObjcKlazz()))<br>  var y = SwiftKlazz()<br>  var z = [Any]<br>  z.append(y)<br>  z.append(y)<br>  expectFalse(isUniquelyReferencedNonObjc(y)<br></p><p>The simplification of this proposal just to remove the variant that had the NonObjectiveCBase prerequisite.<br></p><p><br></p><p>&gt; <br>&gt; - I find the use of different names in `isUniquelyReferenced()` and<br>&gt; `ManagedBufferPointer.holdsUniqueReference()` to be strange.  Why not<br>&gt; call the latter `ManagedBufferPointer. isUniquelyReferenced()`?  It is<br>&gt; true that we are not checking that pointer is not uniquely referenced,<br>&gt; if we want to emphasize that, maybe something like<br>&gt; `ManagedBufferPointer.isBufferUniquelyReferenced()` or<br>&gt; `isPointeeUniquelyReferenced()` will work?<br></p><p>Okay I think isBufferUniquelyReferenced is good. I’ll add that change to the proposal.<br></p><p><br>&gt; <br>&gt; The reason why I&#39;m suggesting this is that `isUniquelyReferenced` and<br>&gt; `holdsUniqueReference` don&#39;t immediately strike me as performing the<br>&gt; same operation, the immediate impression I get is that these<br>&gt; operations are related, but subtly different, and it is not obvious<br>&gt; what the difference is (but after reading the docs I figure out that<br>&gt; there is no difference... until I need to use these APIs again).<br>&gt; <br>&gt; - We have `ManagedBufferPointer.holdsUniqueOrPinnedReference()`, but<br>&gt; don&#39;t have an equivalent free function `isUniquelyReferencedOrPinned`<br>&gt; (we actually have one, but it is internal).  Do we need a public one?<br>&gt; If we do, we could as well add it as a part of this proposal, while we<br>&gt; are cleaning up this library subsystem.<br></p><p>No we don’t one. . We have not exposed pinning outside of the standard library (because we don’t have a design for it).<br></p><p>I will remove it.<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 5:55 AM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 19, 2016, at 11:06 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Jul 19, 2016 at 10:51 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; The review of &quot;SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced&quot; begins now and runs through July 22. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0125-remove-nonobjectivecbase.md<br>&gt;&gt; <br>&gt;&gt; I like the API simplification.  A few thoughts that I have after<br>&gt;&gt; reading the proposal that could take the simplification it even<br>&gt;&gt; further:<br>&gt;&gt; <br>&gt;&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt;&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt;&gt; import, would we need to rename it to<br>&gt;&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  I think that is the issue<br>&gt;&gt; with negation.  If we want to emphasize that the API will work only<br>&gt;&gt; with Swift types, we can do something<br>&gt;&gt; `isUniquelyReferencedSwiftReference`.  But I would probably suggest<br>&gt;&gt; that we just go with just `isUniquelyReferenced` and mention the<br>&gt;&gt; Swift-only requirement in the documentation.<br>&gt; <br>&gt; isUniquelyReferencedNonObjC checks that the object is a uniquely referenced swift only class. It works on non- at objc classes but will return false: The API will work for @objc-classes but return false.<br>&gt; <br>&gt; The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance.<br>&gt; <br>&gt;  expectTrue(isUniquelyReferencedNonObjc(SwiftKlazz()))<br>&gt;  expectFalse(isUniquelyReferencedNonObjc(ObjcKlazz()))<br>&gt;  var y = SwiftKlazz()<br>&gt;  var z = [Any]<br>&gt;  z.append(y)<br>&gt;  z.append(y)<br>&gt;  expectFalse(isUniquelyReferencedNonObjc(y)<br>&gt; <br>&gt; The simplification of this proposal just to remove the variant that had the NonObjectiveCBase prerequisite.<br></p><p><br>Your critique of the negation still holds though.<br></p><p>So maybe we still rename it from isUniquelyReferencedNonObjC to isUniquelyReferencedSwiftReference?<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; - I find the use of different names in `isUniquelyReferenced()` and<br>&gt;&gt; `ManagedBufferPointer.holdsUniqueReference()` to be strange.  Why not<br>&gt;&gt; call the latter `ManagedBufferPointer. isUniquelyReferenced()`?  It is<br>&gt;&gt; true that we are not checking that pointer is not uniquely referenced,<br>&gt;&gt; if we want to emphasize that, maybe something like<br>&gt;&gt; `ManagedBufferPointer.isBufferUniquelyReferenced()` or<br>&gt;&gt; `isPointeeUniquelyReferenced()` will work?<br>&gt; <br>&gt; Okay I think isBufferUniquelyReferenced is good. I’ll add that change to the proposal.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The reason why I&#39;m suggesting this is that `isUniquelyReferenced` and<br>&gt;&gt; `holdsUniqueReference` don&#39;t immediately strike me as performing the<br>&gt;&gt; same operation, the immediate impression I get is that these<br>&gt;&gt; operations are related, but subtly different, and it is not obvious<br>&gt;&gt; what the difference is (but after reading the docs I figure out that<br>&gt;&gt; there is no difference... until I need to use these APIs again).<br>&gt;&gt; <br>&gt;&gt; - We have `ManagedBufferPointer.holdsUniqueOrPinnedReference()`, but<br>&gt;&gt; don&#39;t have an equivalent free function `isUniquelyReferencedOrPinned`<br>&gt;&gt; (we actually have one, but it is internal).  Do we need a public one?<br>&gt;&gt; If we do, we could as well add it as a part of this proposal, while we<br>&gt;&gt; are cleaning up this library subsystem.<br>&gt; <br>&gt; No we don’t one. . We have not exposed pinning outside of the standard library (because we don’t have a design for it).<br>&gt; <br>&gt; I will remove it.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 6:12 AM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; isUniquelyReferencedNonObjC checks that the object is a uniquely referenced swift only class. It works on non- at objc classes but will return false: The API will work for @objc-classes but return false.<br>&gt;&gt; <br>&gt;&gt; The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance.<br>&gt;&gt; <br>&gt;&gt; expectTrue(isUniquelyReferencedNonObjc(SwiftKlazz()))<br>&gt;&gt; expectFalse(isUniquelyReferencedNonObjc(ObjcKlazz()))<br>&gt;&gt; var y = SwiftKlazz()<br>&gt;&gt; var z = [Any]<br>&gt;&gt; z.append(y)<br>&gt;&gt; z.append(y)<br>&gt;&gt; expectFalse(isUniquelyReferencedNonObjc(y)<br>&gt;&gt; <br>&gt;&gt; The simplification of this proposal just to remove the variant that had the NonObjectiveCBase prerequisite.<br>&gt; <br>&gt; <br>&gt; Your critique of the negation still holds though.<br>&gt; <br>&gt; So maybe we still rename it from isUniquelyReferencedNonObjC to isUniquelyReferencedSwiftReference?<br></p><p>What’s the difference between a “SwiftReference” and AnyObject?<br></p><p>The current name is the literal meaning. The intent of being literal and awkward is to encourage users to read the comments. This isn’t something people should be embedding in their program logic anyway. It’s very special purpose.<br></p><p>That said, something like “isUniquelyReferencedNativeSwift” would work assuming that’s semantically correct (“native&quot; Swfit objects do not inherit from NSObject). “isKnownUniquelyReferenced” would be fine with a warning in the doc comment that it may always return false for objc objects.<br></p><p>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/f38534b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 9:09 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 6:12 AM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; isUniquelyReferencedNonObjC checks that the object is a uniquely referenced swift only class. It works on non- at objc classes but will return false: The API will work for @objc-classes but return false.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; expectTrue(isUniquelyReferencedNonObjc(SwiftKlazz()))<br>&gt;&gt;&gt; expectFalse(isUniquelyReferencedNonObjc(ObjcKlazz()))<br>&gt;&gt;&gt; var y = SwiftKlazz()<br>&gt;&gt;&gt; var z = [Any]<br>&gt;&gt;&gt; z.append(y)<br>&gt;&gt;&gt; z.append(y)<br>&gt;&gt;&gt; expectFalse(isUniquelyReferencedNonObjc(y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The simplification of this proposal just to remove the variant that had the NonObjectiveCBase prerequisite.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Your critique of the negation still holds though.<br>&gt;&gt; <br>&gt;&gt; So maybe we still rename it from isUniquelyReferencedNonObjC to isUniquelyReferencedSwiftReference?<br>&gt; <br>&gt; What’s the difference between a “SwiftReference” and AnyObject?<br>&gt; <br>&gt; The current name is the literal meaning. The intent of being literal and awkward is to encourage users to read the comments. This isn’t something people should be embedding in their program logic anyway. It’s very special purpose.<br></p><p>The question is are they relying on the non- at objc post-condition when the API returns true? If they were to implement something like array they might.<br></p><p>&gt; <br>&gt; That said, something like “isUniquelyReferencedNativeSwift” would work assuming that’s semantically correct (“native&quot; Swfit objects do not inherit from NSObject). “isKnownUniquelyReferenced” would be fine with a warning in the doc comment that it may always return false for objc objects.<br></p><p><br>Native swift objects are the ones that use native swift reference counting and don’t alias Objc class instances. That is at least how we have defined it at the SIL (Builtin.NativeObject vs Builtin.UnknownObject) level:<br></p><p><br>* A ``Builtin.NativeObject`` may alias any native Swift heap object,<br>  including a Swift class instance, a box allocated by ``alloc_box``,<br>  or a thick function&#39;s closure context.<br>  It may not alias natively Objective-C class instances.<br></p><p><br>I think at the language/stdlib level the “native” concept is implementation detail that is not witnessed other than with the non- at objc requirement of ManageBufferPointer and  isUniquelyReferencedNonObjC, i.e at the language/stdlib level we call “native” &quot;non- at objc”. Which IMO is more descriptive.<br></p><p>I understand the desire to remove Objc’ness from API names that can be used on platforms without ObjC.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 9:44 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; The question is are they relying on the non- at objc post-condition when the API returns true? If they were to implement something like array they might.<br></p><p>The conservative thing to do is not make that promise for now and address need later if it’s important. Conservative makes sense to me given the current level of confusion.<br></p><p>&gt;&gt; <br>&gt;&gt; That said, something like “isUniquelyReferencedNativeSwift” would work assuming that’s semantically correct (“native&quot; Swfit objects do not inherit from NSObject). “isKnownUniquelyReferenced” would be fine with a warning in the doc comment that it may always return false for objc objects.<br>&gt; <br>&gt; <br>&gt; Native swift objects are the ones that use native swift reference counting and don’t alias Objc class instances. That is at least how we have defined it at the SIL (Builtin.NativeObject vs Builtin.UnknownObject) level:<br>&gt; <br>&gt; <br>&gt; * A ``Builtin.NativeObject`` may alias any native Swift heap object,<br>&gt;  including a Swift class instance, a box allocated by ``alloc_box``,<br>&gt;  or a thick function&#39;s closure context.<br>&gt;  It may not alias natively Objective-C class instances.<br>&gt; <br>&gt; <br>&gt; I think at the language/stdlib level the “native” concept is implementation detail that is not witnessed other than with the non- at objc requirement of ManageBufferPointer and  isUniquelyReferencedNonObjC, i.e at the language/stdlib level we call “native” &quot;non- at objc”. Which IMO is more descriptive.<br></p><p>I totally agree, but people can’t have it both ways. You can’t avoid a negative in the name and refuse to define the positive nomenclature.<br></p><p>&gt; I understand the desire to remove Objc’ness from API names that can be used on platforms without ObjC.<br></p><p>Me too.<br></p><p>+1 for isKnownUniquelyReferenced, with clarifying doc comments<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/5b515053/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 9:54 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 9:44 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The question is are they relying on the non- at objc post-condition when the API returns true? If they were to implement something like array they might.<br>&gt; <br>&gt; The conservative thing to do is not make that promise for now and address need later if it’s important. Conservative makes sense to me given the current level of confusion.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, something like “isUniquelyReferencedNativeSwift” would work assuming that’s semantically correct (“native&quot; Swfit objects do not inherit from NSObject). “isKnownUniquelyReferenced” would be fine with a warning in the doc comment that it may always return false for objc objects.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Native swift objects are the ones that use native swift reference counting and don’t alias Objc class instances. That is at least how we have defined it at the SIL (Builtin.NativeObject vs Builtin.UnknownObject) level:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * A ``Builtin.NativeObject`` may alias any native Swift heap object,<br>&gt;&gt;  including a Swift class instance, a box allocated by ``alloc_box``,<br>&gt;&gt;  or a thick function&#39;s closure context.<br>&gt;&gt;  It may not alias natively Objective-C class instances.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think at the language/stdlib level the “native” concept is implementation detail that is not witnessed other than with the non- at objc requirement of ManageBufferPointer and  isUniquelyReferencedNonObjC, i.e at the language/stdlib level we call “native” &quot;non- at objc”. Which IMO is more descriptive.<br>&gt; <br>&gt; I totally agree, but people can’t have it both ways. You can’t avoid a negative in the name and refuse to define the positive nomenclature.<br>&gt; <br>&gt;&gt; I understand the desire to remove Objc’ness from API names that can be used on platforms without ObjC.<br>&gt; <br>&gt; Me too.<br>&gt; <br>&gt; +1 forisKnownUniquelyReferenced, with clarifying doc comments<br></p><p><br>Do we continue promise that “isKnownUniquelyReferenced” returns false for non- at objc objects in the comments?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 10:12 AM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 20, 2016, at 9:54 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 9:44 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The question is are they relying on the non- at objc post-condition when the API returns true? If they were to implement something like array they might.<br>&gt;&gt; <br>&gt;&gt; The conservative thing to do is not make that promise for now and address need later if it’s important. Conservative makes sense to me given the current level of confusion.<br>&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, something like “isUniquelyReferencedNativeSwift” would work assuming that’s semantically correct (“native&quot; Swfit objects do not inherit from NSObject). “isKnownUniquelyReferenced” would be fine with a warning in the doc comment that it may always return false for objc objects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Native swift objects are the ones that use native swift reference counting and don’t alias Objc class instances. That is at least how we have defined it at the SIL (Builtin.NativeObject vs Builtin.UnknownObject) level:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * A ``Builtin.NativeObject`` may alias any native Swift heap object,<br>&gt;&gt;&gt; including a Swift class instance, a box allocated by ``alloc_box``,<br>&gt;&gt;&gt; or a thick function&#39;s closure context.<br>&gt;&gt;&gt; It may not alias natively Objective-C class instances.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think at the language/stdlib level the “native” concept is implementation detail that is not witnessed other than with the non- at objc requirement of ManageBufferPointer and  isUniquelyReferencedNonObjC, i.e at the language/stdlib level we call “native” &quot;non- at objc”. Which IMO is more descriptive.<br>&gt;&gt; <br>&gt;&gt; I totally agree, but people can’t have it both ways. You can’t avoid a negative in the name and refuse to define the positive nomenclature.<br>&gt;&gt; <br>&gt;&gt;&gt; I understand the desire to remove Objc’ness from API names that can be used on platforms without ObjC.<br>&gt;&gt; <br>&gt;&gt; Me too.<br>&gt;&gt; <br>&gt;&gt; +1 forisKnownUniquelyReferenced, with clarifying doc comments<br>&gt; <br>&gt; <br>&gt; Do we continue promise that “isKnownUniquelyReferenced” returns false for non- at objc objects in the comments?<br></p><p>I think the conservative answer is yes. Since there might be clients relying on the behavior.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 11:00:00am</p></header><div class="content"><p>Version 2 of the proposal https://github.com/aschwaighofer/swift-evolution/blob/remove_nonobjectivecbase_2/proposals/0125-remove-nonobjectivecbase.md<br></p><p>Which proposes to:<br></p><p>- Remove `NonObjectiveCBase` and `isUniquelyReferenced&lt;T: NonObjectiveCBase&gt;(_ object: T)`.<br></p><p>- Rename `isUniquelyReferencedNonObjC` to `isKnownUniquelyReferenced`.<br></p><p>- Cleanup the `ManagedBufferPointer` API by renaming `holdsUniqueReference` to<br>`isUniqueReference` and removing `holdsUniqueOrPinnedReference`.<br></p><p><br>&gt; On Jul 20, 2016, at 10:24 AM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 20, 2016, at 10:12 AM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 9:54 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 9:44 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The question is are they relying on the non- at objc post-condition when the API returns true? If they were to implement something like array they might.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The conservative thing to do is not make that promise for now and address need later if it’s important. Conservative makes sense to me given the current level of confusion.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, something like “isUniquelyReferencedNativeSwift” would work assuming that’s semantically correct (“native&quot; Swfit objects do not inherit from NSObject). “isKnownUniquelyReferenced” would be fine with a warning in the doc comment that it may always return false for objc objects.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Native swift objects are the ones that use native swift reference counting and don’t alias Objc class instances. That is at least how we have defined it at the SIL (Builtin.NativeObject vs Builtin.UnknownObject) level:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * A ``Builtin.NativeObject`` may alias any native Swift heap object,<br>&gt;&gt;&gt;&gt; including a Swift class instance, a box allocated by ``alloc_box``,<br>&gt;&gt;&gt;&gt; or a thick function&#39;s closure context.<br>&gt;&gt;&gt;&gt; It may not alias natively Objective-C class instances.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think at the language/stdlib level the “native” concept is implementation detail that is not witnessed other than with the non- at objc requirement of ManageBufferPointer and  isUniquelyReferencedNonObjC, i.e at the language/stdlib level we call “native” &quot;non- at objc”. Which IMO is more descriptive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I totally agree, but people can’t have it both ways. You can’t avoid a negative in the name and refuse to define the positive nomenclature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand the desire to remove Objc’ness from API names that can be used on platforms without ObjC.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Me too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 forisKnownUniquelyReferenced, with clarifying doc comments<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Do we continue promise that “isKnownUniquelyReferenced” returns false for non- at objc objects in the comments?<br>&gt; <br>&gt; I think the conservative answer is yes. Since there might be clients relying on the behavior.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 20, 2016 at 12:00:00pm</p></header><div class="content"><p>on Wed Jul 20 2016, Arnold Schwaighofer &lt;aschwaighofer-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 20, 2016, at 9:54 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 9:44 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The question is are they relying on the non- at objc post-condition<br>&gt;&gt;&gt; when the API returns true? If they were to implement something like<br>&gt;&gt;&gt; array they might.<br>&gt;&gt; <br>&gt;&gt; The conservative thing to do is not make that promise for now and<br>&gt;&gt; address need later if it’s important. Conservative makes sense to me<br>&gt;&gt; given the current level of confusion.<br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, something like “isUniquelyReferencedNativeSwift” would<br>&gt;&gt;&gt;&gt; work assuming that’s semantically correct (“native&quot; Swfit objects<br>&gt;&gt;&gt;&gt; do not inherit from NSObject). “isKnownUniquelyReferenced” would<br>&gt;&gt;&gt;&gt; be fine with a warning in the doc comment that it may always<br>&gt;&gt;&gt;&gt; return false for objc objects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Native swift objects are the ones that use native swift reference<br>&gt;&gt;&gt; counting and don’t alias Objc class instances. That is at least how<br>&gt;&gt;&gt; we have defined it at the SIL (Builtin.NativeObject vs<br>&gt;&gt;&gt; Builtin.UnknownObject) level:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * A ``Builtin.NativeObject`` may alias any native Swift heap object,<br>&gt;&gt;&gt;  including a Swift class instance, a box allocated by ``alloc_box``,<br>&gt;&gt;&gt;  or a thick function&#39;s closure context.<br>&gt;&gt;&gt;  It may not alias natively Objective-C class instances.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think at the language/stdlib level the “native” concept is<br>&gt;&gt;&gt; implementation detail that is not witnessed other than with the<br>&gt;&gt;&gt; non- at objc requirement of ManageBufferPointer and<br>&gt;&gt;&gt; isUniquelyReferencedNonObjC, i.e at the language/stdlib level we<br>&gt;&gt;&gt; call “native” &quot;non- at objc”. Which IMO is more descriptive.<br>&gt;&gt; <br>&gt;&gt; I totally agree, but people can’t have it both ways. You can’t avoid<br>&gt;&gt; a negative in the name and refuse to define the positive<br>&gt;&gt; nomenclature.<br>&gt;&gt; <br>&gt;&gt;&gt; I understand the desire to remove Objc’ness from API names that can be used on platforms without ObjC.<br>&gt;&gt; <br>&gt;&gt; Me too.<br>&gt;&gt; <br>&gt;&gt; +1 forisKnownUniquelyReferenced, with clarifying doc comments<br>&gt;<br>&gt; Do we continue promise that “isKnownUniquelyReferenced” returns false<br>&gt;for non- at objc objects in the comments?<br></p><p>I think you mean, “do we promise that “isKnownUniquelyReferenced” returns<br>false for @objc objects?”<br></p><p>IMO we should not make that promise.  There&#39;s not much you can do with it.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jul 20, 2016, at 12:47 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jul 20 2016, Arnold Schwaighofer &lt;aschwaighofer-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 9:54 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 9:44 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The question is are they relying on the non- at objc post-condition<br>&gt;&gt;&gt;&gt; when the API returns true? If they were to implement something like<br>&gt;&gt;&gt;&gt; array they might.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The conservative thing to do is not make that promise for now and<br>&gt;&gt;&gt; address need later if it’s important. Conservative makes sense to me<br>&gt;&gt;&gt; given the current level of confusion.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, something like “isUniquelyReferencedNativeSwift” would<br>&gt;&gt;&gt;&gt;&gt; work assuming that’s semantically correct (“native&quot; Swfit objects<br>&gt;&gt;&gt;&gt;&gt; do not inherit from NSObject). “isKnownUniquelyReferenced” would<br>&gt;&gt;&gt;&gt;&gt; be fine with a warning in the doc comment that it may always<br>&gt;&gt;&gt;&gt;&gt; return false for objc objects.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Native swift objects are the ones that use native swift reference<br>&gt;&gt;&gt;&gt; counting and don’t alias Objc class instances. That is at least how<br>&gt;&gt;&gt;&gt; we have defined it at the SIL (Builtin.NativeObject vs<br>&gt;&gt;&gt;&gt; Builtin.UnknownObject) level:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * A ``Builtin.NativeObject`` may alias any native Swift heap object,<br>&gt;&gt;&gt;&gt; including a Swift class instance, a box allocated by ``alloc_box``,<br>&gt;&gt;&gt;&gt; or a thick function&#39;s closure context.<br>&gt;&gt;&gt;&gt; It may not alias natively Objective-C class instances.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think at the language/stdlib level the “native” concept is<br>&gt;&gt;&gt;&gt; implementation detail that is not witnessed other than with the<br>&gt;&gt;&gt;&gt; non- at objc requirement of ManageBufferPointer and<br>&gt;&gt;&gt;&gt; isUniquelyReferencedNonObjC, i.e at the language/stdlib level we<br>&gt;&gt;&gt;&gt; call “native” &quot;non- at objc”. Which IMO is more descriptive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I totally agree, but people can’t have it both ways. You can’t avoid<br>&gt;&gt;&gt; a negative in the name and refuse to define the positive<br>&gt;&gt;&gt; nomenclature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand the desire to remove Objc’ness from API names that can be used on platforms without ObjC.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Me too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 forisKnownUniquelyReferenced, with clarifying doc comments<br>&gt;&gt; <br>&gt;&gt; Do we continue promise that “isKnownUniquelyReferenced” returns false<br>&gt;&gt; for non- at objc objects in the comments?<br>&gt; <br>&gt; I think you mean, “do we promise that “isKnownUniquelyReferenced” returns<br>&gt; false for @objc objects?”<br></p><p>Yes.<br></p><p>&gt; <br>&gt; IMO we should not make that promise.  There&#39;s not much you can do with it.<br></p><p><br>You can implement Array (or a similar bridged) type outside of the standard library -- at least the aspect of it that transitions to a native representation when you write to it if it is non-native.<br></p><p>I am fine with dropping the promise, though.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 1:00 PM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 12:47 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jul 20 2016, Arnold Schwaighofer &lt;aschwaighofer-AT-apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 9:54 AM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 9:44 AM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The question is are they relying on the non- at objc post-condition<br>&gt;&gt;&gt;&gt;&gt; when the API returns true? If they were to implement something like<br>&gt;&gt;&gt;&gt;&gt; array they might.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The conservative thing to do is not make that promise for now and<br>&gt;&gt;&gt;&gt; address need later if it’s important. Conservative makes sense to me<br>&gt;&gt;&gt;&gt; given the current level of confusion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That said, something like “isUniquelyReferencedNativeSwift” would<br>&gt;&gt;&gt;&gt;&gt;&gt; work assuming that’s semantically correct (“native&quot; Swfit objects<br>&gt;&gt;&gt;&gt;&gt;&gt; do not inherit from NSObject). “isKnownUniquelyReferenced” would<br>&gt;&gt;&gt;&gt;&gt;&gt; be fine with a warning in the doc comment that it may always<br>&gt;&gt;&gt;&gt;&gt;&gt; return false for objc objects.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Native swift objects are the ones that use native swift reference<br>&gt;&gt;&gt;&gt;&gt; counting and don’t alias Objc class instances. That is at least how<br>&gt;&gt;&gt;&gt;&gt; we have defined it at the SIL (Builtin.NativeObject vs<br>&gt;&gt;&gt;&gt;&gt; Builtin.UnknownObject) level:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * A ``Builtin.NativeObject`` may alias any native Swift heap object,<br>&gt;&gt;&gt;&gt;&gt; including a Swift class instance, a box allocated by ``alloc_box``,<br>&gt;&gt;&gt;&gt;&gt; or a thick function&#39;s closure context.<br>&gt;&gt;&gt;&gt;&gt; It may not alias natively Objective-C class instances.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think at the language/stdlib level the “native” concept is<br>&gt;&gt;&gt;&gt;&gt; implementation detail that is not witnessed other than with the<br>&gt;&gt;&gt;&gt;&gt; non- at objc requirement of ManageBufferPointer and<br>&gt;&gt;&gt;&gt;&gt; isUniquelyReferencedNonObjC, i.e at the language/stdlib level we<br>&gt;&gt;&gt;&gt;&gt; call “native” &quot;non- at objc”. Which IMO is more descriptive.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I totally agree, but people can’t have it both ways. You can’t avoid<br>&gt;&gt;&gt;&gt; a negative in the name and refuse to define the positive<br>&gt;&gt;&gt;&gt; nomenclature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand the desire to remove Objc’ness from API names that can be used on platforms without ObjC.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Me too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 forisKnownUniquelyReferenced, with clarifying doc comments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do we continue promise that “isKnownUniquelyReferenced” returns false<br>&gt;&gt;&gt; for non- at objc objects in the comments?<br>&gt;&gt; <br>&gt;&gt; I think you mean, “do we promise that “isKnownUniquelyReferenced” returns<br>&gt;&gt; false for @objc objects?”<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; IMO we should not make that promise.  There&#39;s not much you can do with it.<br>&gt; <br>&gt; <br>&gt; You can implement Array (or a similar bridged) type outside of the standard library -- at least the aspect of it that transitions to a native representation when you write to it if it is non-native.<br>&gt; <br>&gt; I am fine with dropping the promise, though.<br></p><p>Yeah, I think we’re more interested in directly supporting CoW than we are in supporting awkward bridging models.<br></p><p>-Andy<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>July 20, 2016 at 09:00:00am</p></header><div class="content"><p>I agree that `isKnownUniquelyReferenced` (with a doc comment about Objective-C) seems like a reasonable solution. It feels bizarre to name Objective-C in a Swift standard library function name. If I recall correctly, Swift on Linux doesn’t interop with Objective-C, so this name feels very out of place there. I’m definitely +1 for any solution that drops this negation from the function name and moves it to the doc comment.<br></p><p>&gt; On Jul 20, 2016, at 9:09 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 6:12 AM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; isUniquelyReferencedNonObjC checks that the object is a uniquely referenced swift only class. It works on non- at objc classes but will return false: The API will work for @objc-classes but return false.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reason for this combination is data structures like Array which might hold an objc class which is not mutable. On a mutating operation you check is it uniquely reference and a swift class - if the answer is yes and you have enough storage you store to the current instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; expectTrue(isUniquelyReferencedNonObjc(SwiftKlazz()))<br>&gt;&gt;&gt; expectFalse(isUniquelyReferencedNonObjc(ObjcKlazz()))<br>&gt;&gt;&gt; var y = SwiftKlazz()<br>&gt;&gt;&gt; var z = [Any]<br>&gt;&gt;&gt; z.append(y)<br>&gt;&gt;&gt; z.append(y)<br>&gt;&gt;&gt; expectFalse(isUniquelyReferencedNonObjc(y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The simplification of this proposal just to remove the variant that had the NonObjectiveCBase prerequisite.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Your critique of the negation still holds though.<br>&gt;&gt; <br>&gt;&gt; So maybe we still rename it from isUniquelyReferencedNonObjC to isUniquelyReferencedSwiftReference?<br>&gt; <br>&gt; What’s the difference between a “SwiftReference” and AnyObject?<br>&gt; <br>&gt; The current name is the literal meaning. The intent of being literal and awkward is to encourage users to read the comments. This isn’t something people should be embedding in their program logic anyway. It’s very special purpose.<br>&gt; <br>&gt; That said, something like “isUniquelyReferencedNativeSwift” would work assuming that’s semantically correct (“native&quot; Swfit objects do not inherit from NSObject). “isKnownUniquelyReferenced” would be fine with a warning in the doc comment that it may always return false for objc objects.<br>&gt; <br>&gt; Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/e9cde611/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 20, 2016 at 12:00:00pm</p></header><div class="content"><p>on Wed Jul 20 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 20, 2016, at 6:12 AM, Arnold Schwaighofer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; isUniquelyReferencedNonObjC checks that the object is a uniquely<br>&gt;&gt;&gt; referenced swift only class. It works on non- at objc classes but will<br>&gt;&gt;&gt; return false: The API will work for @objc-classes but return false.<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reason for this combination is data structures like Array which<br>&gt;&gt;&gt; might hold an objc class which is not mutable. On a mutating<br>&gt;&gt;&gt; operation you check is it uniquely reference and a swift class - if<br>&gt;&gt;&gt; the answer is yes and you have enough storage you store to the<br>&gt;&gt;&gt; current instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; expectTrue(isUniquelyReferencedNonObjc(SwiftKlazz()))<br>&gt;&gt;&gt; expectFalse(isUniquelyReferencedNonObjc(ObjcKlazz()))<br>&gt;&gt;&gt; var y = SwiftKlazz()<br>&gt;&gt;&gt; var z = [Any]<br>&gt;&gt;&gt; z.append(y)<br>&gt;&gt;&gt; z.append(y)<br>&gt;&gt;&gt; expectFalse(isUniquelyReferencedNonObjc(y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The simplification of this proposal just to remove the variant that had the NonObjectiveCBase prerequisite.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Your critique of the negation still holds though.<br>&gt;&gt; <br>&gt;&gt; So maybe we still rename it from isUniquelyReferencedNonObjC to isUniquelyReferencedSwiftReference?<br>&gt;<br>&gt; What’s the difference between a “SwiftReference” and AnyObject?<br>&gt;<br>&gt; The current name is the literal meaning. The intent of being literal<br>&gt; and awkward is to encourage users to read the comments. This isn’t<br>&gt; something people should be embedding in their program logic<br>&gt; anyway. It’s very special purpose.<br>&gt;<br>&gt; That said, something like “isUniquelyReferencedNativeSwift” would work<br>&gt; assuming that’s semantically correct (“native&quot; Swfit objects do not<br>&gt; inherit from NSObject). <br></p><p>It&#39;s semantically correct today but I&#39;m not sure it always be.  If we<br>decided interop with Python, for example, we&#39;d be able to detect<br>uniqueness of Python objects and this method should do so.  <br></p><p>&gt; “isKnownUniquelyReferenced” would be fine with a warning in the doc<br>&gt; comment that it may always return false for objc objects.<br></p><p>That&#39;s a better name.  <br></p><p>P.S. It&#39;s conceivable that someday we could correctly detect uniqueness<br>in (a subset of) ObjC types.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>July 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 12:44 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; “isKnownUniquelyReferenced” would be fine with a warning in the doc<br>&gt;&gt; comment that it may always return false for objc objects.<br>&gt; <br>&gt; That&#39;s a better name.  <br>&gt; <br>&gt; P.S. It&#39;s conceivable that someday we could correctly detect uniqueness<br>&gt; in (a subset of) ObjC types.<br></p><p>Since we’re renaming this API, it’s a good time to drop the guarantee that it will return false for NonObjC.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/2917bd62/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 20, 2016 at 06:00:00am</p></header><div class="content"><p>on Tue Jul 19 2016, Dmitri Gribenko &lt;gribozavr-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Tue, Jul 19, 2016 at 10:51 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; The review of &quot;SE-0125: Remove NonObjectiveCBase and<br>&gt;&gt; isUniquelyReferenced&quot; begins now and runs through July 22. The<br>&gt;&gt; proposal is available here:<br>&gt;&gt;<br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0125-remove-nonobjectivecbase.md<br>&gt;<br>&gt; I like the API simplification.  A few thoughts that I have after<br>&gt; reading the proposal that could take the simplification it even<br>&gt; further:<br>&gt;<br>&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt; import, would we need to rename it to<br>&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  <br></p><p>Only if we were unable to determine that CXX imports were<br>uniquely-referenced.<br></p><p>&gt; I think that is the issue with negation.  If we want to emphasize that<br>&gt; the API will work only with Swift types, we can do something<br>&gt; `isUniquelyReferencedSwiftReference`.  <br></p><p>That&#39;s not really the point.  The point is to find out whether it&#39;s<br>*known* to be a unique reference.  False negatives are part of the<br>game.<br></p><p>       isKnownUniquelyReferenced<br></p><p>would work.<br></p><p>&gt; But I would probably suggest that we just go with just<br>&gt; `isUniquelyReferenced` and mention the Swift-only requirement in the<br>&gt; documentation.<br></p><p>It&#39;s not a requirement, as in “precondition.”  The point of having<br>`NonObjC` in this API is actually that it *does* work on ObjC<br>references, by returning false.<br></p><p>&gt; - I find the use of different names in `isUniquelyReferenced()` and<br>&gt; `ManagedBufferPointer.holdsUniqueReference()` to be strange.  Why not<br>&gt; call the latter `ManagedBufferPointer. isUniquelyReferenced()`?  It is<br>&gt; true that we are not checking that pointer is not uniquely referenced,<br>&gt; if we want to emphasize that, maybe something like<br>&gt; `ManagedBufferPointer.isBufferUniquelyReferenced()` or<br>&gt; `isPointeeUniquelyReferenced()` will work?<br></p><p>       isUniqueReference<br></p><p>would work for ManagedBufferPointer.<br></p><p>&gt; The reason why I&#39;m suggesting this is that `isUniquelyReferenced` and<br>&gt; `holdsUniqueReference` don&#39;t immediately strike me as performing the<br>&gt; same operation, the immediate impression I get is that these<br>&gt; operations are related, but subtly different, and it is not obvious<br>&gt; what the difference is (but after reading the docs I figure out that<br>&gt; there is no difference... until I need to use these APIs again).<br>&gt;<br>&gt; - We have `ManagedBufferPointer.holdsUniqueOrPinnedReference()`, but<br>&gt; don&#39;t have an equivalent free function `isUniquelyReferencedOrPinned`<br>&gt; (we actually have one, but it is internal).  Do we need a public one?<br>&gt; If we do, we could as well add it as a part of this proposal, while we<br>&gt; are cleaning up this library subsystem.<br></p><p>Maybe, but it&#39;s not crucial.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>July 20, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jul 20, 2016, at 6:50 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Tue Jul 19 2016, Dmitri Gribenko &lt;gribozavr-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jul 19, 2016 at 10:51 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; The review of &quot;SE-0125: Remove NonObjectiveCBase and<br>&gt;&gt;&gt; isUniquelyReferenced&quot; begins now and runs through July 22. The<br>&gt;&gt;&gt; proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/proposals/0125-remove-nonobjectivecbase.md<br>&gt;&gt; <br>&gt;&gt; I like the API simplification.  A few thoughts that I have after<br>&gt;&gt; reading the proposal that could take the simplification it even<br>&gt;&gt; further:<br>&gt;&gt; <br>&gt;&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt;&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt;&gt; import, would we need to rename it to<br>&gt;&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  <br>&gt; <br>&gt; Only if we were unable to determine that CXX imports were<br>&gt; uniquely-referenced.<br>&gt; <br>&gt;&gt; I think that is the issue with negation.  If we want to emphasize that<br>&gt;&gt; the API will work only with Swift types, we can do something<br>&gt;&gt; `isUniquelyReferencedSwiftReference`.  <br>&gt; <br>&gt; That&#39;s not really the point.  The point is to find out whether it&#39;s<br>&gt; *known* to be a unique reference.  False negatives are part of the<br>&gt; game.<br>&gt; <br>&gt;       isKnownUniquelyReferenced<br>&gt; <br>&gt; would work.<br></p><p><br>This would be a change to the semantics of the API. Currently, you can rely on -- and is documented as -- that if it returns true you can assume the reference points to a non- at objc instance.<br></p><p>Users may be relying on this behavior.<br></p><p>Do we want to add an isNativeSwiftReference API?<br></p><p><br>&gt; <br>&gt;&gt; But I would probably suggest that we just go with just<br>&gt;&gt; `isUniquelyReferenced` and mention the Swift-only requirement in the<br>&gt;&gt; documentation.<br>&gt; <br>&gt; It&#39;s not a requirement, as in “precondition.”  The point of having<br>&gt; `NonObjC` in this API is actually that it *does* work on ObjC<br>&gt; references, by returning false.<br>&gt; <br>&gt;&gt; - I find the use of different names in `isUniquelyReferenced()` and<br>&gt;&gt; `ManagedBufferPointer.holdsUniqueReference()` to be strange.  Why not<br>&gt;&gt; call the latter `ManagedBufferPointer. isUniquelyReferenced()`?  It is<br>&gt;&gt; true that we are not checking that pointer is not uniquely referenced,<br>&gt;&gt; if we want to emphasize that, maybe something like<br>&gt;&gt; `ManagedBufferPointer.isBufferUniquelyReferenced()` or<br>&gt;&gt; `isPointeeUniquelyReferenced()` will work?<br>&gt; <br>&gt;       isUniqueReference<br>&gt; <br>&gt; would work for ManagedBufferPointer.<br>&gt; <br>&gt;&gt; The reason why I&#39;m suggesting this is that `isUniquelyReferenced` and<br>&gt;&gt; `holdsUniqueReference` don&#39;t immediately strike me as performing the<br>&gt;&gt; same operation, the immediate impression I get is that these<br>&gt;&gt; operations are related, but subtly different, and it is not obvious<br>&gt;&gt; what the difference is (but after reading the docs I figure out that<br>&gt;&gt; there is no difference... until I need to use these APIs again).<br>&gt;&gt; <br>&gt;&gt; - We have `ManagedBufferPointer.holdsUniqueOrPinnedReference()`, but<br>&gt;&gt; don&#39;t have an equivalent free function `isUniquelyReferencedOrPinned`<br>&gt;&gt; (we actually have one, but it is internal).  Do we need a public one?<br>&gt;&gt; If we do, we could as well add it as a part of this proposal, while we<br>&gt;&gt; are cleaning up this library subsystem.<br>&gt; <br>&gt; Maybe, but it&#39;s not crucial.<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>July 20, 2016 at 08:00:00am</p></header><div class="content"><p>For what it’s worth, I agree with Dmitri on the naming of this function. I think we should find a way to give it a name without “NonObjC” in it.<br></p><p>- Tony<br></p><p>&gt; On Jul 20, 2016, at 8:15 AM, Arnold via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 6:50 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; on Tue Jul 19 2016, Dmitri Gribenko &lt;gribozavr-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Jul 19, 2016 at 10:51 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; The review of &quot;SE-0125: Remove NonObjectiveCBase and<br>&gt;&gt;&gt;&gt; isUniquelyReferenced&quot; begins now and runs through July 22. The<br>&gt;&gt;&gt;&gt; proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0125-remove-nonobjectivecbase.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the API simplification.  A few thoughts that I have after<br>&gt;&gt;&gt; reading the proposal that could take the simplification it even<br>&gt;&gt;&gt; further:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I find it a little strange to see a mention of Objective-C, and a<br>&gt;&gt;&gt; negation in `isUniquelyReferencedNonObjC`.  For example, if we get C++<br>&gt;&gt;&gt; import, would we need to rename it to<br>&gt;&gt;&gt; `isUniquelyReferencedNonObjCAndNonCXX`?  <br>&gt;&gt; <br>&gt;&gt; Only if we were unable to determine that CXX imports were<br>&gt;&gt; uniquely-referenced.<br>&gt;&gt; <br>&gt;&gt;&gt; I think that is the issue with negation.  If we want to emphasize that<br>&gt;&gt;&gt; the API will work only with Swift types, we can do something<br>&gt;&gt;&gt; `isUniquelyReferencedSwiftReference`.  <br>&gt;&gt; <br>&gt;&gt; That&#39;s not really the point.  The point is to find out whether it&#39;s<br>&gt;&gt; *known* to be a unique reference.  False negatives are part of the<br>&gt;&gt; game.<br>&gt;&gt; <br>&gt;&gt;      isKnownUniquelyReferenced<br>&gt;&gt; <br>&gt;&gt; would work.<br>&gt; <br>&gt; <br>&gt; This would be a change to the semantics of the API. Currently, you can rely on -- and is documented as -- that if it returns true you can assume the reference points to a non- at objc instance.<br>&gt; <br>&gt; Users may be relying on this behavior.<br>&gt; <br>&gt; Do we want to add an isNativeSwiftReference API?<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; But I would probably suggest that we just go with just<br>&gt;&gt;&gt; `isUniquelyReferenced` and mention the Swift-only requirement in the<br>&gt;&gt;&gt; documentation.<br>&gt;&gt; <br>&gt;&gt; It&#39;s not a requirement, as in “precondition.”  The point of having<br>&gt;&gt; `NonObjC` in this API is actually that it *does* work on ObjC<br>&gt;&gt; references, by returning false.<br>&gt;&gt; <br>&gt;&gt;&gt; - I find the use of different names in `isUniquelyReferenced()` and<br>&gt;&gt;&gt; `ManagedBufferPointer.holdsUniqueReference()` to be strange.  Why not<br>&gt;&gt;&gt; call the latter `ManagedBufferPointer. isUniquelyReferenced()`?  It is<br>&gt;&gt;&gt; true that we are not checking that pointer is not uniquely referenced,<br>&gt;&gt;&gt; if we want to emphasize that, maybe something like<br>&gt;&gt;&gt; `ManagedBufferPointer.isBufferUniquelyReferenced()` or<br>&gt;&gt;&gt; `isPointeeUniquelyReferenced()` will work?<br>&gt;&gt; <br>&gt;&gt;      isUniqueReference<br>&gt;&gt; <br>&gt;&gt; would work for ManagedBufferPointer.<br>&gt;&gt; <br>&gt;&gt;&gt; The reason why I&#39;m suggesting this is that `isUniquelyReferenced` and<br>&gt;&gt;&gt; `holdsUniqueReference` don&#39;t immediately strike me as performing the<br>&gt;&gt;&gt; same operation, the immediate impression I get is that these<br>&gt;&gt;&gt; operations are related, but subtly different, and it is not obvious<br>&gt;&gt;&gt; what the difference is (but after reading the docs I figure out that<br>&gt;&gt;&gt; there is no difference... until I need to use these APIs again).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - We have `ManagedBufferPointer.holdsUniqueOrPinnedReference()`, but<br>&gt;&gt;&gt; don&#39;t have an equivalent free function `isUniquelyReferencedOrPinned`<br>&gt;&gt;&gt; (we actually have one, but it is internal).  Do we need a public one?<br>&gt;&gt;&gt; If we do, we could as well add it as a part of this proposal, while we<br>&gt;&gt;&gt; are cleaning up this library subsystem.<br>&gt;&gt; <br>&gt;&gt; Maybe, but it&#39;s not crucial.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/53ea95ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Just wanted to write the same comment as Tony: remove `NonObjC` from the<br>name. If possible, we should also make this work for ObjC classes.<br></p><p>2016-07-20 18:55 GMT+03:00 Tony Parker via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; For what it’s worth, I agree with Dmitri on the naming of this function. I<br>&gt; think we should find a way to give it a name without “NonObjC” in it.<br>&gt;<br>&gt; - Tony<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/7c302df9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0125: Remove NonObjectiveCBase and isUniquelyReferenced</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 20, 2016 at 03:00:00pm</p></header><div class="content"><p>`isUniquelyReferencedNative`?<br>On Wed, Jul 20, 2016 at 10:57 Anton Zhilin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Just wanted to write the same comment as Tony: remove `NonObjC` from the<br>&gt; name. If possible, we should also make this work for ObjC classes.<br>&gt;<br>&gt; 2016-07-20 18:55 GMT+03:00 Tony Parker via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; For what it’s worth, I agree with Dmitri on the naming of this function.<br>&gt;&gt; I think we should find a way to give it a name without “NonObjC” in it.<br>&gt;&gt;<br>&gt;&gt; - Tony<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/0c60bb56/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
