<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a39ef1491768b90e7de8e0ec4d0b0091?s=50"></div><header><strong>Large Structs, and COW.</strong> from <string>Daniel Tartaglia</string> &lt;danielt1263 at gmail.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>If I have a large struct with lots of sub-structs and I assign to just one field of one of the sub-structs, will the system make a deep copy of the struct or a shallow copy where the unmodified portions of the object still point the same memory as the original struct?<br></p><p>In other words, given this code:<br></p><p>struct SubStruct {<br>    var a: Int = 0<br>    var b: Int = 0<br>}<br></p><p>struct VeryLarge {<br>    var subStructA = SubStruct()<br>    var subStructB = SubStruct()<br>    var subStructC = SubStruct()<br>    // lots of other stuff<br>}<br></p><p>func bar(var vl: VeryLarge) -&gt; VeryLarge {<br>    vl.subStructA.a = 5<br>    return vl<br>}<br></p><p>let vl1 = VeryLarge()<br>let vl2 = bar(vl1)<br></p><p>Will vl2.subStructB be a copy of vl1.subStructB, or an entirely new object?<br></p><p>I’m worried about performance when making small changes to large objects.<br></p><p>Thanks,<br>Daniel T.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160122/5a44eebe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Large Structs, and COW.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 11:22 AM, Daniel Tartaglia via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; If I have a large struct with lots of sub-structs and I assign to just one field of one of the sub-structs, will the system make a deep copy of the struct or a shallow copy where the unmodified portions of the object still point the same memory as the original struct?<br>&gt; <br>&gt; In other words, given this code:<br>&gt; <br>&gt; struct SubStruct {<br>&gt;     var a: Int = 0<br>&gt;     var b: Int = 0<br>&gt; }<br>&gt; <br>&gt; struct VeryLarge {<br>&gt;     var subStructA = SubStruct()<br>&gt;     var subStructB = SubStruct()<br>&gt;     var subStructC = SubStruct()<br>&gt;     // lots of other stuff<br>&gt; }<br>&gt; <br>&gt; func bar(var vl: VeryLarge) -&gt; VeryLarge {<br>&gt;     vl.subStructA.a = 5<br>&gt;     return vl<br>&gt; }<br>&gt; <br>&gt; let vl1 = VeryLarge()<br>&gt; let vl2 = bar(vl1)<br>&gt; <br>&gt; Will vl2.subStructB be a copy of vl1.subStructB, or an entirely new object?<br>&gt; <br>&gt; I’m worried about performance when making small changes to large objects.<br></p><p>Semantically, vl2 is always a distinct value, though how that ends up manifesting depends on the optimizer. By default, struct fields are stored in-line, like C structs, so sizeof(VeryLarge) will be sizeof(SubStruct) * 3 + sizeof(lots of other stuff), and a copy will be a full copy. If you want copy-on-write behavior, you currently have to implement it yourself, or build from already-implemented COW value types like Array. When structs pass a certain size threshold, the calling convention changes over to passing and returning them indirectly, though &#39;bar&#39; will still naively introduce a copy to transfer the modified value from the argument to the result buffer. However, in optimized builds, if bar is inlined, then I&#39;d expect this to ultimately reduce down to an in-place modification without copies, since vl1 is never used after assigning vl2.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160122/570f07df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a39ef1491768b90e7de8e0ec4d0b0091?s=50"></div><header><strong>Large Structs, and COW.</strong> from <string>Daniel Tartaglia</string> &lt;danielt1263 at gmail.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 4:35 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 22, 2016, at 11:22 AM, Daniel Tartaglia via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If I have a large struct with lots of sub-structs and I assign to just one field of one of the sub-structs, will the system make a deep copy of the struct or a shallow copy where the unmodified portions of the object still point the same memory as the original struct?<br>&gt;&gt; <br>&gt;&gt; In other words, given this code:<br>&gt;&gt; <br>&gt;&gt; struct SubStruct {<br>&gt;&gt;     var a: Int = 0<br>&gt;&gt;     var b: Int = 0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct VeryLarge {<br>&gt;&gt;     var subStructA = SubStruct()<br>&gt;&gt;     var subStructB = SubStruct()<br>&gt;&gt;     var subStructC = SubStruct()<br>&gt;&gt;     // lots of other stuff<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func bar(var vl: VeryLarge) -&gt; VeryLarge {<br>&gt;&gt;     vl.subStructA.a = 5<br>&gt;&gt;     return vl<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let vl1 = VeryLarge()<br>&gt;&gt; let vl2 = bar(vl1)<br>&gt;&gt; <br>&gt;&gt; Will vl2.subStructB be a copy of vl1.subStructB, or an entirely new object?<br>&gt;&gt; <br>&gt;&gt; I’m worried about performance when making small changes to large objects.<br>&gt; <br>&gt; Semantically, vl2 is always a distinct value, though how that ends up manifesting depends on the optimizer. By default, struct fields are stored in-line, like C structs, so sizeof(VeryLarge) will be sizeof(SubStruct) * 3 + sizeof(lots of other stuff), and a copy will be a full copy. If you want copy-on-write behavior, you currently have to implement it yourself, or build from already-implemented COW value types like Array. When structs pass a certain size threshold, the calling convention changes over to passing and returning them indirectly, though &#39;bar&#39; will still naively introduce a copy to transfer the modified value from the argument to the result buffer. However, in optimized builds, if bar is inlined, then I&#39;d expect this to ultimately reduce down to an in-place modification without copies, since vl1 is never used after assigning vl2.<br></p><p>Thanks for the reply. I’m asking because I am considering using a Redux system for an app I’m working on. One of the basic principles of Redux is that the entire app state be held in one struct, and I was worried about the system making a deep copy of the state struct every time I change any little variable.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160122/872ec018/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Large Structs, and COW.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 1:52 PM, Daniel Tartaglia &lt;danielt1263 at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 4:35 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 11:22 AM, Daniel Tartaglia via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I have a large struct with lots of sub-structs and I assign to just one field of one of the sub-structs, will the system make a deep copy of the struct or a shallow copy where the unmodified portions of the object still point the same memory as the original struct?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, given this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct SubStruct {<br>&gt;&gt;&gt;     var a: Int = 0<br>&gt;&gt;&gt;     var b: Int = 0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct VeryLarge {<br>&gt;&gt;&gt;     var subStructA = SubStruct()<br>&gt;&gt;&gt;     var subStructB = SubStruct()<br>&gt;&gt;&gt;     var subStructC = SubStruct()<br>&gt;&gt;&gt;     // lots of other stuff<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func bar(var vl: VeryLarge) -&gt; VeryLarge {<br>&gt;&gt;&gt;     vl.subStructA.a = 5<br>&gt;&gt;&gt;     return vl<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let vl1 = VeryLarge()<br>&gt;&gt;&gt; let vl2 = bar(vl1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Will vl2.subStructB be a copy of vl1.subStructB, or an entirely new object?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m worried about performance when making small changes to large objects.<br>&gt;&gt; <br>&gt;&gt; Semantically, vl2 is always a distinct value, though how that ends up manifesting depends on the optimizer. By default, struct fields are stored in-line, like C structs, so sizeof(VeryLarge) will be sizeof(SubStruct) * 3 + sizeof(lots of other stuff), and a copy will be a full copy. If you want copy-on-write behavior, you currently have to implement it yourself, or build from already-implemented COW value types like Array. When structs pass a certain size threshold, the calling convention changes over to passing and returning them indirectly, though &#39;bar&#39; will still naively introduce a copy to transfer the modified value from the argument to the result buffer. However, in optimized builds, if bar is inlined, then I&#39;d expect this to ultimately reduce down to an in-place modification without copies, since vl1 is never used after assigning vl2.<br>&gt; <br>&gt; Thanks for the reply. I’m asking because I am considering using a Redux system for an app I’m working on. One of the basic principles of Redux is that the entire app state be held in one struct, and I was worried about the system making a deep copy of the state struct every time I change any little variable.<br></p><p>Copy-on-write storage is one of many use cases I had in mind for my property behaviors feature, currently under discussion over on swift-evolution. It would make it possible to declare a property with copy-on-write, out-of-line storage using an &quot;indirect&quot; behavior:<br></p><p>struct VeryLargeCOW {<br>  var [indirect] subStructA = SubStruct()<br>  var [indirect] subStructB = SubStruct()<br>  var [indirect] subStructC = SubStruct()<br>}<br></p><p>Today, you could manually simulate this by placing your fields in one-element arrays:<br></p><p>struct VeryLargeCOW {<br>  private var _subStructA: [SubStruct]<br>  var subStructA: SubStruct {<br>    get { return _subStructA[0] }<br>    set { _subStructA = newValue }<br>  }<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160122/7c454a38/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>Large Structs, and COW.</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>January 26, 2016 at 11:00:00pm</p></header><div class="content"><p>Great question!<br></p><p>I&#39;m using Redux in my Swift app too! My state struct is tiny though. <br></p><p>Anyway, just wanted to say hello and welcome to the Redux club. :)<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 22 Jan 2016, at 22:52, Daniel Tartaglia via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 4:35 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 11:22 AM, Daniel Tartaglia via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I have a large struct with lots of sub-structs and I assign to just one field of one of the sub-structs, will the system make a deep copy of the struct or a shallow copy where the unmodified portions of the object still point the same memory as the original struct?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, given this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct SubStruct {<br>&gt;&gt;&gt;     var a: Int = 0<br>&gt;&gt;&gt;     var b: Int = 0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct VeryLarge {<br>&gt;&gt;&gt;     var subStructA = SubStruct()<br>&gt;&gt;&gt;     var subStructB = SubStruct()<br>&gt;&gt;&gt;     var subStructC = SubStruct()<br>&gt;&gt;&gt;     // lots of other stuff<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func bar(var vl: VeryLarge) -&gt; VeryLarge {<br>&gt;&gt;&gt;     vl.subStructA.a = 5<br>&gt;&gt;&gt;     return vl<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let vl1 = VeryLarge()<br>&gt;&gt;&gt; let vl2 = bar(vl1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Will vl2.subStructB be a copy of vl1.subStructB, or an entirely new object?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m worried about performance when making small changes to large objects.<br>&gt;&gt; <br>&gt;&gt; Semantically, vl2 is always a distinct value, though how that ends up manifesting depends on the optimizer. By default, struct fields are stored in-line, like C structs, so sizeof(VeryLarge) will be sizeof(SubStruct) * 3 + sizeof(lots of other stuff), and a copy will be a full copy. If you want copy-on-write behavior, you currently have to implement it yourself, or build from already-implemented COW value types like Array. When structs pass a certain size threshold, the calling convention changes over to passing and returning them indirectly, though &#39;bar&#39; will still naively introduce a copy to transfer the modified value from the argument to the result buffer. However, in optimized builds, if bar is inlined, then I&#39;d expect this to ultimately reduce down to an in-place modification without copies, since vl1 is never used after assigning vl2.<br>&gt; <br>&gt; Thanks for the reply. I’m asking because I am considering using a Redux system for an app I’m working on. One of the basic principles of Redux is that the entire app state be held in one struct, and I was worried about the system making a deep copy of the state struct every time I change any little variable.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160126/97245757/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
