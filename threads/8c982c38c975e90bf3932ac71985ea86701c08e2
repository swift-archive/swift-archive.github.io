<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 12, 2016 at 08:00:00am</p></header><div class="content"><p>on Fri Feb 12 2016, Taras Zakharko &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; IMO, using the converb/gerund/participle (whatever you call it) here<br>&gt; is a terrible idea (I say that as someone with a PhD in linguistics :)<br>&gt; ). It appears very counter-intuitive to me that ‘union’ should be the<br>&gt; in-place version, as it goes agains any convention I am aware of.  I’d<br>&gt; rather just keep InPlace here or, as Greg suggests, rely on compiler<br>&gt; optimisations.<br></p><p>FWIW, I think it&#39;s almost impossible for compler optimizations to help<br>with arbitrarily complex LHS expressions such as a[b].c.d[e] =<br>a[b].c.d[e].union(f)<br></p><p>...and then you have the readability problem of repeated code.<br></p><p>&gt;<br>&gt; — Taras<br>&gt;<br>&gt;&gt; On 12 Feb 2016, at 08:43, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I could get behind that. At the call site there would be little<br>&gt;&gt; visible difference between this and the alternative where functions<br>&gt;&gt; beginning with &quot;=&quot; are allowed. One I can think of would be that the<br>&gt;&gt; `.=` operator would require some instances (of classes that have<br>&gt;&gt; properties that are reference types) declared with `let` to be<br>&gt;&gt; declared with `var`.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Feb 12, 2016 at 1:26 AM, Greg Parker via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 10:05 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Feb 11 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Understandable. FWIW, if one believes in autocomplete, superscript<br>&gt;&gt;&gt;&gt;&gt; equal sign is already a valid identifier head character (per<br>&gt;&gt;&gt;&gt;&gt; documentation and experimentation in a playground). So, if the gist of<br>&gt;&gt;&gt;&gt;&gt; the proposal is acceptable, one can already name a pair of functions<br>&gt;&gt;&gt;&gt;&gt; union() and union=() if the &quot;=&quot; is replaced with its superscript (and<br>&gt;&gt;&gt;&gt;&gt; for that matter, =union(), but autocomplete might not help with that<br>&gt;&gt;&gt;&gt;&gt; one).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hmm, use the fullwidth equal sign; it reads better, and compiles:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; mutating func ＝union(other: Self) { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt;&gt;&gt;&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt;&gt;&gt;&gt; fixed by tooling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now y&#39;all are approaching the syntax of a proposal I made long ago<br>&gt;&gt;&gt; for a .= operator. Here&#39;s what I wrote then (with a handful of<br>&gt;&gt;&gt; syntax updates).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suggest eliminating &quot;…InPlace&quot; as follows:<br>&gt;&gt;&gt; 1. Use the same method name for value-creating methods and in-place<br>&gt;&gt;&gt; mutation methods. No &quot;…InPlace&quot; suffix.<br>&gt;&gt;&gt; 2. Write all client code syntactically as if the in-place<br>&gt;&gt;&gt; implementations did not exist. Rely on the compiler to choose the<br>&gt;&gt;&gt; in-place implementation when possible.<br>&gt;&gt;&gt; 3. Add a new operator .= for in-place modification, to shorten the<br>&gt;&gt;&gt; &quot;expr = expr.method()&quot; case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Use the same method name for value-creating methods and in-place mutation methods<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct String {<br>&gt;&gt;&gt;   func upper() -&gt; String { ... }  // value-creating / out-of-place implementation<br>&gt;&gt;&gt;   @inplace func upper() { ... }   // in-place implementation<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct String2 {<br>&gt;&gt;&gt;   @inplace func upper() { ... }   // in-place implementation<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The value-creating implementation is optional. If it is not<br>&gt;&gt;&gt; present, the compiler will generate a default value-creating<br>&gt;&gt;&gt; implementation that copies the object and calls the in-place<br>&gt;&gt;&gt; implementation. There is no default in-place implementation; if<br>&gt;&gt;&gt; there is no in-place implementation of a value-creating method then<br>&gt;&gt;&gt; the compiler simply fails to optimize to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Write all client code syntactically as if the in-place implementations did not exist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead of this<br>&gt;&gt;&gt;   s.upperInPlace()<br>&gt;&gt;&gt; write this<br>&gt;&gt;&gt;   s = s.upper()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler optimizer can choose the in-place upper() implementation if it is present.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead of this<br>&gt;&gt;&gt;   t = s.upper().trim().truncate(toLength: 5) // oops, there&#39;s an<br>&gt;&gt;&gt; extra copy here<br>&gt;&gt;&gt;   t = s.upper().trimInPlace().truncateInPlace(toLength: 5)  // oops, compile error<br>&gt;&gt;&gt; write this<br>&gt;&gt;&gt;   t = s.upper().trim().truncate(toLength: 5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The developer can chain methods together and let the compiler<br>&gt;&gt;&gt; optimizer choose which in-place implementations to use. In this<br>&gt;&gt;&gt; case, if all in-place implementations are available, it should call<br>&gt;&gt;&gt; value-creating upper() followed by in-place trim() and in-place<br>&gt;&gt;&gt; truncate(toLength:).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Add operator .= for in-place modification.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Operator .= is analogous to arithmetic operators like += . It is<br>&gt;&gt;&gt; shorthand for `expr = expr.stuff` for the case where `expr` is<br>&gt;&gt;&gt; inconveniently long. (It also doesn&#39;t evaluate `expr` twice, if<br>&gt;&gt;&gt; Swift&#39;s optimization rules otherwise would allow it or require it<br>&gt;&gt;&gt; for the longhand case.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; s .= upper()<br>&gt;&gt;&gt; // like s = s.upper()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; p .= next<br>&gt;&gt;&gt; // like p = p.next<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; some().long().expression .= upper().trim().truncateToLength(5)<br>&gt;&gt;&gt; // like some().long().expression =<br>&gt;&gt;&gt; some().long().expression.upper().trim().truncateToLength(5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As seen in this last example, one advantage of this syntax is that<br>&gt;&gt;&gt; it allows chained mutations but cleanly separates the &quot;lookup&quot;<br>&gt;&gt;&gt; calls from the &quot;mutate&quot; calls. This is an improvement upon language<br>&gt;&gt;&gt; and API designs with mutating methods where the property being<br>&gt;&gt;&gt; changed is buried in the middle of the expression somewhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; some().long().expression.upperInPlace().trimInPlace().truncateInPlace(toLength: 5)<br>&gt;&gt;&gt; some().long().expression().upper.trimInPlace().truncateInPlace(toLength: 5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; some().long().expression .= upper().trim().truncate(toLength: 5)<br>&gt;&gt;&gt; some().long().expression().upper .= trim().truncate(toLength: 5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One consequence of these changes is that compiler optimizations to<br>&gt;&gt;&gt; take advantage of in-place implementation are much more important<br>&gt;&gt;&gt; for performance, because there isn&#39;t any syntax to call the<br>&gt;&gt;&gt; in-place implementation directly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 12 Feb 2016, at 17:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Feb 12 2016, Taras Zakharko &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; IMO, using the converb/gerund/participle (whatever you call it) here<br>&gt;&gt; is a terrible idea (I say that as someone with a PhD in linguistics :)<br>&gt;&gt; ). It appears very counter-intuitive to me that ‘union’ should be the<br>&gt;&gt; in-place version, as it goes agains any convention I am aware of.  I’d<br>&gt;&gt; rather just keep InPlace here or, as Greg suggests, rely on compiler<br>&gt;&gt; optimisations.<br>&gt; <br>&gt; FWIW, I think it&#39;s almost impossible for compler optimizations to help<br>&gt; with arbitrarily complex LHS expressions such as a[b].c.d[e] =<br>&gt; a[b].c.d[e].union(f)<br>&gt; <br>&gt; ...and then you have the readability problem of repeated code.<br></p><p>I don’t think that the problem is that complicated: if the compiler detects that the invoked member has a in-place version, it just needs to check that the expression ASTs on the left and right side are identical (and that no getters have side effects). In the end, its just a special case of CSE, but its also true that Swift does not seem to do anything like this right now. <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; — Taras<br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Feb 2016, at 08:43, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could get behind that. At the call site there would be little<br>&gt;&gt;&gt; visible difference between this and the alternative where functions<br>&gt;&gt;&gt; beginning with &quot;=&quot; are allowed. One I can think of would be that the<br>&gt;&gt;&gt; `.=` operator would require some instances (of classes that have<br>&gt;&gt;&gt; properties that are reference types) declared with `let` to be<br>&gt;&gt;&gt; declared with `var`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Feb 12, 2016 at 1:26 AM, Greg Parker via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 11, 2016, at 10:05 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Thu Feb 11 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Understandable. FWIW, if one believes in autocomplete, superscript<br>&gt;&gt;&gt;&gt;&gt;&gt; equal sign is already a valid identifier head character (per<br>&gt;&gt;&gt;&gt;&gt;&gt; documentation and experimentation in a playground). So, if the gist of<br>&gt;&gt;&gt;&gt;&gt;&gt; the proposal is acceptable, one can already name a pair of functions<br>&gt;&gt;&gt;&gt;&gt;&gt; union() and union=() if the &quot;=&quot; is replaced with its superscript (and<br>&gt;&gt;&gt;&gt;&gt;&gt; for that matter, =union(), but autocomplete might not help with that<br>&gt;&gt;&gt;&gt;&gt;&gt; one).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hmm, use the fullwidth equal sign; it reads better, and compiles:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; mutating func ＝union(other: Self) { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Heh, that is awesome; we could do some real fun proofs-of-concept for<br>&gt;&gt;&gt;&gt;&gt; the proposal using that trick.  The autocomplete problem can/should be<br>&gt;&gt;&gt;&gt;&gt; fixed by tooling.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now y&#39;all are approaching the syntax of a proposal I made long ago<br>&gt;&gt;&gt;&gt; for a .= operator. Here&#39;s what I wrote then (with a handful of<br>&gt;&gt;&gt;&gt; syntax updates).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suggest eliminating &quot;…InPlace&quot; as follows:<br>&gt;&gt;&gt;&gt; 1. Use the same method name for value-creating methods and in-place<br>&gt;&gt;&gt;&gt; mutation methods. No &quot;…InPlace&quot; suffix.<br>&gt;&gt;&gt;&gt; 2. Write all client code syntactically as if the in-place<br>&gt;&gt;&gt;&gt; implementations did not exist. Rely on the compiler to choose the<br>&gt;&gt;&gt;&gt; in-place implementation when possible.<br>&gt;&gt;&gt;&gt; 3. Add a new operator .= for in-place modification, to shorten the<br>&gt;&gt;&gt;&gt; &quot;expr = expr.method()&quot; case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Use the same method name for value-creating methods and in-place mutation methods<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct String {<br>&gt;&gt;&gt;&gt;  func upper() -&gt; String { ... }  // value-creating / out-of-place implementation<br>&gt;&gt;&gt;&gt;  @inplace func upper() { ... }   // in-place implementation<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct String2 {<br>&gt;&gt;&gt;&gt;  @inplace func upper() { ... }   // in-place implementation<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The value-creating implementation is optional. If it is not<br>&gt;&gt;&gt;&gt; present, the compiler will generate a default value-creating<br>&gt;&gt;&gt;&gt; implementation that copies the object and calls the in-place<br>&gt;&gt;&gt;&gt; implementation. There is no default in-place implementation; if<br>&gt;&gt;&gt;&gt; there is no in-place implementation of a value-creating method then<br>&gt;&gt;&gt;&gt; the compiler simply fails to optimize to it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Write all client code syntactically as if the in-place implementations did not exist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Instead of this<br>&gt;&gt;&gt;&gt;  s.upperInPlace()<br>&gt;&gt;&gt;&gt; write this<br>&gt;&gt;&gt;&gt;  s = s.upper()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler optimizer can choose the in-place upper() implementation if it is present.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Instead of this<br>&gt;&gt;&gt;&gt;  t = s.upper().trim().truncate(toLength: 5) // oops, there&#39;s an<br>&gt;&gt;&gt;&gt; extra copy here<br>&gt;&gt;&gt;&gt;  t = s.upper().trimInPlace().truncateInPlace(toLength: 5)  // oops, compile error<br>&gt;&gt;&gt;&gt; write this<br>&gt;&gt;&gt;&gt;  t = s.upper().trim().truncate(toLength: 5)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The developer can chain methods together and let the compiler<br>&gt;&gt;&gt;&gt; optimizer choose which in-place implementations to use. In this<br>&gt;&gt;&gt;&gt; case, if all in-place implementations are available, it should call<br>&gt;&gt;&gt;&gt; value-creating upper() followed by in-place trim() and in-place<br>&gt;&gt;&gt;&gt; truncate(toLength:).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. Add operator .= for in-place modification.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Operator .= is analogous to arithmetic operators like += . It is<br>&gt;&gt;&gt;&gt; shorthand for `expr = expr.stuff` for the case where `expr` is<br>&gt;&gt;&gt;&gt; inconveniently long. (It also doesn&#39;t evaluate `expr` twice, if<br>&gt;&gt;&gt;&gt; Swift&#39;s optimization rules otherwise would allow it or require it<br>&gt;&gt;&gt;&gt; for the longhand case.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; s .= upper()<br>&gt;&gt;&gt;&gt; // like s = s.upper()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; p .= next<br>&gt;&gt;&gt;&gt; // like p = p.next<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; some().long().expression .= upper().trim().truncateToLength(5)<br>&gt;&gt;&gt;&gt; // like some().long().expression =<br>&gt;&gt;&gt;&gt; some().long().expression.upper().trim().truncateToLength(5)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As seen in this last example, one advantage of this syntax is that<br>&gt;&gt;&gt;&gt; it allows chained mutations but cleanly separates the &quot;lookup&quot;<br>&gt;&gt;&gt;&gt; calls from the &quot;mutate&quot; calls. This is an improvement upon language<br>&gt;&gt;&gt;&gt; and API designs with mutating methods where the property being<br>&gt;&gt;&gt;&gt; changed is buried in the middle of the expression somewhere.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; some().long().expression.upperInPlace().trimInPlace().truncateInPlace(toLength: 5)<br>&gt;&gt;&gt;&gt; some().long().expression().upper.trimInPlace().truncateInPlace(toLength: 5)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; some().long().expression .= upper().trim().truncate(toLength: 5)<br>&gt;&gt;&gt;&gt; some().long().expression().upper .= trim().truncate(toLength: 5)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One consequence of these changes is that compiler optimizations to<br>&gt;&gt;&gt;&gt; take advantage of in-place implementation are much more important<br>&gt;&gt;&gt;&gt; for performance, because there isn&#39;t any syntax to call the<br>&gt;&gt;&gt;&gt; in-place implementation directly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/6594200b/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
