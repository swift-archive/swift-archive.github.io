<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Proposal Discussion Thread: SwiftPM: Locking and Overriding Dependencies</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 17, 2016 at 11:00:00am</p></header><div class="content"><p>The following is a draft proposal, feedback welcome.<br></p><p>____________<br>SwiftPM Dependency Version Locking<br>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-dependency-lockfiles.md&gt;<br>Author(s): Ankit Agarwal &lt;https://github.com/aciidb0mb3r&gt;, Max Howell &lt;https://github.com/mxcl&gt;<br>Status: Discussion<br>Review manager: Rick Ballard<br>Introduction<br>This proposal seeks to declare a new, generated file Packages/VersionLocks.json that describes the exact state of a package’s dependency graph and then by default will be respected when executing most package manager commands. Thus it is considered a “version lock” for a package’s dependency sources.<br></p><p>Swift-evolution thread &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/000067.html&gt;<br>Terminology<br>A package refers to a published, versioned git repository designed to be consumed as a dependency by SwiftPM.<br>A project refers to an end-user workspace that uses SwiftPM (via a Package.swift and swift build) fetching and building packages as part of its build<br>Describing this distinction is required because both the above have the same form, but are used differently by an end-user. An end-user may publish packages, but will eventually consume those packages in a project.<br></p><p>As justification for this confusion, it is considered a feature that projects can easily and trivially become packages when using SwiftPM. Encouraging a vibrant packaging ecosystem is one of our goals.<br></p><p>Motivation<br>In a vibrant packaging ecosystem, dependencies update continuously with bug-fixes and new features. A development team needs:<br></p><p>To ensure they are all using the same versions of their dependencies for any given version-control commit.<br>Ensure they are all using the same versions of the underlying Swift toolchain<br>Be able to override or modify dependency specifications for the whole team for specific commits.<br>Currently with SwiftPM it is possible to fulfill 1. by committing the sources of a package’s dependencies with the package itself, but this is not always desirable. There is no way to achieve 2. and 3. with SwiftPM alone.<br></p><p>Additionally, there is not currently a way to know which version of Swift a package requires to build. At this time this situation is particularly precarious because Swift itself is not backwards compatible. As a Swift developer at the very least recording which Swift version a package was built with by the package developer is essential information in order to assess a package&#39;s suitability. Practically the package manager could in the future use this information to aid an end-user or even fix the problem when packages fail to compile.<br></p><p>Proposed Solution<br>A file: Packages/VersionLocks.json will be created alongside the Package.swift file. Its contents will describe:<br></p><p>The URL and versions of cloned dependencies<br>An inline diff of any local modifications made to those packages relative to their pristine cloned states<br>The exact version of the Swift toolchain used as part of the last successful build of the package<br>This file is generated by SwiftPM.<br></p><p>This file should be checked-in with projects.<br></p><p>This file is generated and should not be edited by users. If the file is edited by users the behavior is undefined.<br></p><p>This file should be checked-in with packages designed for consumption in projects, however SwiftPM will not use the checkout files of dependencies when determining a project’s dependency graph (this would make dependency graphs much less likely to resolve due to overly strict versioning requirements). In the future we may choose to make it possible for end-users to attempt to build a package using all checkout files since in certain deployment scenarios where an exact graph has already been tested, this is a solid reliabiity feature.<br></p><p>Any local, modifications made to the clones in Packages are recorded in Packages/VersionLocks.json as part of the flow described in the next section. Modifications here means: changes to git remotes and the git-ref of the checked-out HEAD.<br></p><p>Detailed Design<br>In a fresh clone that does not contain a Packages directory swift build will determine the dependency graph, clone the packages into Packages and generate a Packages/VersionLocks.json file.<br></p><p>The user can now step into the Packages directory and modify package sources. If the user then runs swift build again the package manager will error out:<br></p><p>error: dependency sources have been modified<br>execute `swift build --lock` or `swift build --ignore-lock`<br>It is an error to build against an unlocked dependency graph, but to facilitate fixing bugs etc. an ignore flag can be specified.<br></p><p>When swift build --lock is specified the package manager regenerates the lockfile detailing the active git remote and the SHA that is checked-out.<br></p><p>Every time swift build completes a build the lockfile is updated (if necessary) recording the current version of the Swift toolchain that achieved the build.<br></p><p>Packages/VersionLocks.json<br></p><p>The exact design of the contents of this file will be explored during iterative development, but here is a possible example:<br></p><p>json { &quot;packages&quot;: [ { &quot;clone&quot;: &quot;Packages/PromiseKit-3.0.3&quot;, &quot;origin&quot;: &quot;https://github.com/mxcl/PromiseKit&quot; &quot;ref&quot;: &quot;3.0.3&quot; }, { &quot;clone&quot;: &quot;Packages/Alamofire-1.2.3&quot;, &quot;origin&quot;: &quot;https://github.com/a-fork-somewhere/Alamofire&quot; &quot;ref&quot;: &quot;crucial-fix&quot; }, { &quot;clone&quot;: &quot;Packages/Quick-1.2.3&quot;, &quot;origin&quot;: &quot;https://github.com/Quick/Quick&quot; &quot;ref&quot;: &quot;1.2.3&quot; } ] }<br></p><p>Workflow — Regular Build<br></p><p>User runs swift build<br>If Packages/ contains clones and a VersionLocks.jsonSwiftPM skips to 7.<br>If Packages/ contains clones and no VersionLocks.json the lockfile is generated from the clones<br>If Packages/ contains checked out sources without git information and no VersionLocks.json SwiftPM fetches the git information and provided there is no diff, generates the Lockfile, if there is variation it is an error *<br>If Packages/VersionLocks.json is present its dependency graph is used<br>If Packages doesn&#39;t exist or is empty the dependency graph is resolved, packages are cloned and the Lockfile is generated<br>Build, if Packages are missing because we skipped from 2. the build will error, it is the user&#39;s responsibility to instruct SwiftPM to --update or to fix their dependency graph some other way.<br></p><p>This scenario is so users can check in their complete dependency sources to their tree instead of / as well as the VersionLocks.json file: a situation which sometimes is necessary if your dependencies are removed from their third party online location, etc.<br></p><p>Workflow — Making Modifications<br></p><p>User makes local modification to a dependency’s sources<br>User runs swift build<br>swift build errors out.<br>User must either lock the graph or run with --ignore-lock<br>The error-out is likely to be considered tedious by users, however we consider it important that users are made aware and forced to act when they modify their dependencies and thus are exposing their team/users to so-called “dependency hell”.<br></p><p>Runing swift build --lock regenerates the lockfile, but does not build.<br></p><p>Modifications must be committed. This means that if the modifications are not uploaded to a location accessible to the rest of the team they will fail to build when they update their checkouts.<br></p><p>The package manager could check for this by asking git if the specified origin has the current locked ref and error out as appropriate.<br></p><p>Workflow — Overriding Packages<br></p><p>User steps into a Package directory eg. Packages/Foo-1.2.3<br>User changes the origin of Foo to their own fork<br>User alters HEAD to point to a fix in their own fork<br>swift build errors out.<br>User must either lock the graph or run with --ignore-lock<br>Running swift build --lock regenerates the lockfile, the new origin and tag is stored. Thus a fresh clone of this project would use these overrides.<br></p><p>It is important to note that this workflow will not be respected for dependencies, only for projects.<br></p><p>If a package author requires an override they have a few options:<br></p><p>Change the Package.swift dependency specification. This should only be done as a last resort, for example, a critical bug must be fixed in a dependency and that dependency author is not being responsive. It is up to the Package author to ensure this scenario goes well. SwiftPM itself wants to guard against these conditions with our proposed “publish &amp; lint” step that validates such decisions before signing a published package tag. But we are not there yet and thus package authors should be responsible.<br>Advise end-users in a package README that they should override the dependency themselves.<br>2 is preferred, but 1 will happen. We consider it our responsibility to develop tooling that makes 1. safe or unnecessary, but we are not there yet.<br></p><p>Workflow — Updating Packages<br></p><p>SwiftPM has no update mechanism yet, but once it does running swift build --update will fetch the latest versions of all dependencies and update the lockfile.<br></p><p>Impact on existing code<br>This proposal will have no impact on existing code.<br></p><p>Alternatives Considered<br>One alternative is to allow mentioning refs in manifest file while declaring a dependency but as discussed in this &lt;http://markdownlivepreview.com/%22https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/&gt; thread it might not be the best idea.<br></p><p>Using Git submodules for this feature was considered. However something additionally would be required to specify swift version and record local diffs. Also this would lock us into git, and despite the fact that currently we only use git, we have not yet ruled out supporting other version control systems.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160317/624940ec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal Discussion Thread: SwiftPM: Locking and Overriding Dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>March 19, 2016 at 10:00:00pm</p></header><div class="content"><p>My thoughts on this proposal:<br></p><p>1. I agree with some of the other comments that I would prefer the version file be adjacent to &quot;Package.swift&quot;. When the Packages directory isn&#39;t being checked in, I really would like to think of it as an &quot;implementation detail&quot; and not embed functionality inside it that would make it hard to remove or change in the future.<br></p><p>2. I like VersionLocks.json well enough, but would like to see a discussion about possible alternatives. My personal proposal (in line with #1) is to use &quot;PackageVersions.json&quot; which has a nice agreement with Package.swift and would mean two common metadata files show up adjacent. I don&#39;t really want to bike shed on the name, but I suspect whatever we pick first will last for a while so I would at least like to review the various alternatives. I also will throw out that my personal opinion is we don&#39;t need to pick a name that bears much resemblance with existing terminology, whatever we pick will eventually become &quot;the standard&quot; for the SwiftPM ecosystem so I would prefer to pick the most-descriptive-possible name up front, not one that alludes to the same concept in other systems.<br></p><p>3. I like the terminology section here, I almost feel like we should adopt that as official terminology in our documentation (which I don&#39;t think we have yet, correct me if I am wrong).<br></p><p>4. I would like it if the lock file recorded the exact SHA it received, and validate that when retrieving. This helps protect users against MITM attacks or unexpected changes if an upstream modifies a tag. It also can be used as part of safety checks when migrating to an alternate repository host which is expected to have the same content.<br></p><p>5. The &quot;workflow - build&quot; sections #2,3,4 are rather complicated. Is this because the proposal is trying to work with existing Packages layouts, or because the proposal is trying to handle the various variations of what the user may have checked in inside the Packages subdirectory?<br></p><p>6. I wonder if we should be defining, as Eloy alludes to, two different things:<br> - The version lock file, which defines the expected versions for the package manager to use when it is doing package resolution.<br> - The package state file (in Packages.swift), which is used by the package manager to track information on the Packages/ subdir state in order to provide useful features primarily focused at the scenarios when the user is modifying those files.<br>Currently it seems like a lot of the behaviors in the proposal are focused at the latter case, but they feel like they should be decoupled problems to me.<br></p><p> - Daniel<br></p><p>&gt; On Mar 17, 2016, at 11:23 AM, Max Howell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The following is a draft proposal, feedback welcome.<br>&gt; <br>&gt; ____________<br>&gt; SwiftPM Dependency Version Locking<br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-dependency-lockfiles.md&gt;<br>&gt; Author(s): Ankit Agarwal &lt;https://github.com/aciidb0mb3r&gt;, Max Howell &lt;https://github.com/mxcl&gt;<br>&gt; Status: Discussion<br>&gt; Review manager: Rick Ballard<br>&gt; Introduction<br>&gt; This proposal seeks to declare a new, generated file Packages/VersionLocks.json that describes the exact state of a package’s dependency graph and then by default will be respected when executing most package manager commands. Thus it is considered a “version lock” for a package’s dependency sources.<br>&gt; <br>&gt; Swift-evolution thread &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/000067.html&gt;<br>&gt; Terminology<br>&gt; A package refers to a published, versioned git repository designed to be consumed as a dependency by SwiftPM.<br>&gt; A project refers to an end-user workspace that uses SwiftPM (via a Package.swift and swift build) fetching and building packages as part of its build<br>&gt; Describing this distinction is required because both the above have the same form, but are used differently by an end-user. An end-user may publish packages, but will eventually consume those packages in a project.<br>&gt; <br>&gt; As justification for this confusion, it is considered a feature that projects can easily and trivially become packages when using SwiftPM. Encouraging a vibrant packaging ecosystem is one of our goals.<br>&gt; <br>&gt; Motivation<br>&gt; In a vibrant packaging ecosystem, dependencies update continuously with bug-fixes and new features. A development team needs:<br>&gt; <br>&gt; To ensure they are all using the same versions of their dependencies for any given version-control commit.<br>&gt; Ensure they are all using the same versions of the underlying Swift toolchain<br>&gt; Be able to override or modify dependency specifications for the whole team for specific commits.<br>&gt; Currently with SwiftPM it is possible to fulfill 1. by committing the sources of a package’s dependencies with the package itself, but this is not always desirable. There is no way to achieve 2. and 3. with SwiftPM alone.<br>&gt; <br>&gt; Additionally, there is not currently a way to know which version of Swift a package requires to build. At this time this situation is particularly precarious because Swift itself is not backwards compatible. As a Swift developer at the very least recording which Swift version a package was built with by the package developer is essential information in order to assess a package&#39;s suitability. Practically the package manager could in the future use this information to aid an end-user or even fix the problem when packages fail to compile.<br>&gt; <br>&gt; Proposed Solution<br>&gt; A file: Packages/VersionLocks.json will be created alongside the Package.swift file. Its contents will describe:<br>&gt; <br>&gt; The URL and versions of cloned dependencies<br>&gt; An inline diff of any local modifications made to those packages relative to their pristine cloned states<br>&gt; The exact version of the Swift toolchain used as part of the last successful build of the package<br>&gt; This file is generated by SwiftPM.<br>&gt; <br>&gt; This file should be checked-in with projects.<br>&gt; <br>&gt; This file is generated and should not be edited by users. If the file is edited by users the behavior is undefined.<br>&gt; <br>&gt; This file should be checked-in with packages designed for consumption in projects, however SwiftPM will not use the checkout files of dependencies when determining a project’s dependency graph (this would make dependency graphs much less likely to resolve due to overly strict versioning requirements). In the future we may choose to make it possible for end-users to attempt to build a package using all checkout files since in certain deployment scenarios where an exact graph has already been tested, this is a solid reliabiity feature.<br>&gt; <br>&gt; Any local, modifications made to the clones in Packages are recorded in Packages/VersionLocks.json as part of the flow described in the next section. Modifications here means: changes to git remotes and the git-ref of the checked-out HEAD.<br>&gt; <br>&gt; Detailed Design<br>&gt; In a fresh clone that does not contain a Packages directory swift build will determine the dependency graph, clone the packages into Packages and generate a Packages/VersionLocks.json file.<br>&gt; <br>&gt; The user can now step into the Packages directory and modify package sources. If the user then runs swift build again the package manager will error out:<br>&gt; <br>&gt; error: dependency sources have been modified<br>&gt; execute `swift build --lock` or `swift build --ignore-lock`<br>&gt; It is an error to build against an unlocked dependency graph, but to facilitate fixing bugs etc. an ignore flag can be specified.<br>&gt; <br>&gt; When swift build --lock is specified the package manager regenerates the lockfile detailing the active git remote and the SHA that is checked-out.<br>&gt; <br>&gt; Every time swift build completes a build the lockfile is updated (if necessary) recording the current version of the Swift toolchain that achieved the build.<br>&gt; <br>&gt; Packages/VersionLocks.json<br>&gt; <br>&gt; The exact design of the contents of this file will be explored during iterative development, but here is a possible example:<br>&gt; <br>&gt; json { &quot;packages&quot;: [ { &quot;clone&quot;: &quot;Packages/PromiseKit-3.0.3&quot;, &quot;origin&quot;: &quot;https://github.com/mxcl/PromiseKit &lt;https://github.com/mxcl/PromiseKit&gt;&quot; &quot;ref&quot;: &quot;3.0.3&quot; }, { &quot;clone&quot;: &quot;Packages/Alamofire-1.2.3&quot;, &quot;origin&quot;: &quot;https://github.com/a-fork-somewhere/Alamofire &lt;https://github.com/a-fork-somewhere/Alamofire&gt;&quot; &quot;ref&quot;: &quot;crucial-fix&quot; }, { &quot;clone&quot;: &quot;Packages/Quick-1.2.3&quot;, &quot;origin&quot;: &quot;https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;&quot; &quot;ref&quot;: &quot;1.2.3&quot; } ] }<br>&gt; <br>&gt; Workflow — Regular Build<br>&gt; <br>&gt; User runs swift build<br>&gt; If Packages/ contains clones and a VersionLocks.jsonSwiftPM skips to 7.<br>&gt; If Packages/ contains clones and no VersionLocks.json the lockfile is generated from the clones<br>&gt; If Packages/ contains checked out sources without git information and no VersionLocks.json SwiftPM fetches the git information and provided there is no diff, generates the Lockfile, if there is variation it is an error *<br>&gt; If Packages/VersionLocks.json is present its dependency graph is used<br>&gt; If Packages doesn&#39;t exist or is empty the dependency graph is resolved, packages are cloned and the Lockfile is generated<br>&gt; Build, if Packages are missing because we skipped from 2. the build will error, it is the user&#39;s responsibility to instruct SwiftPM to --update or to fix their dependency graph some other way.<br>&gt; <br>&gt; This scenario is so users can check in their complete dependency sources to their tree instead of / as well as the VersionLocks.json file: a situation which sometimes is necessary if your dependencies are removed from their third party online location, etc.<br>&gt; <br>&gt; Workflow — Making Modifications<br>&gt; <br>&gt; User makes local modification to a dependency’s sources<br>&gt; User runs swift build<br>&gt; swift build errors out.<br>&gt; User must either lock the graph or run with --ignore-lock<br>&gt; The error-out is likely to be considered tedious by users, however we consider it important that users are made aware and forced to act when they modify their dependencies and thus are exposing their team/users to so-called “dependency hell”.<br>&gt; <br>&gt; Runing swift build --lock regenerates the lockfile, but does not build.<br>&gt; <br>&gt; Modifications must be committed. This means that if the modifications are not uploaded to a location accessible to the rest of the team they will fail to build when they update their checkouts.<br>&gt; <br>&gt; The package manager could check for this by asking git if the specified origin has the current locked ref and error out as appropriate.<br>&gt; <br>&gt; Workflow — Overriding Packages<br>&gt; <br>&gt; User steps into a Package directory eg. Packages/Foo-1.2.3<br>&gt; User changes the origin of Foo to their own fork<br>&gt; User alters HEAD to point to a fix in their own fork<br>&gt; swift build errors out.<br>&gt; User must either lock the graph or run with --ignore-lock<br>&gt; Running swift build --lock regenerates the lockfile, the new origin and tag is stored. Thus a fresh clone of this project would use these overrides.<br>&gt; <br>&gt; It is important to note that this workflow will not be respected for dependencies, only for projects.<br>&gt; <br>&gt; If a package author requires an override they have a few options:<br>&gt; <br>&gt; Change the Package.swift dependency specification. This should only be done as a last resort, for example, a critical bug must be fixed in a dependency and that dependency author is not being responsive. It is up to the Package author to ensure this scenario goes well. SwiftPM itself wants to guard against these conditions with our proposed “publish &amp; lint” step that validates such decisions before signing a published package tag. But we are not there yet and thus package authors should be responsible.<br>&gt; Advise end-users in a package README that they should override the dependency themselves.<br>&gt; 2 is preferred, but 1 will happen. We consider it our responsibility to develop tooling that makes 1. safe or unnecessary, but we are not there yet.<br>&gt; <br>&gt; Workflow — Updating Packages<br>&gt; <br>&gt; SwiftPM has no update mechanism yet, but once it does running swift build --update will fetch the latest versions of all dependencies and update the lockfile.<br>&gt; <br>&gt; Impact on existing code<br>&gt; This proposal will have no impact on existing code.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; One alternative is to allow mentioning refs in manifest file while declaring a dependency but as discussed in this &lt;http://markdownlivepreview.com/%22https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/&gt; thread it might not be the best idea.<br>&gt; <br>&gt; Using Git submodules for this feature was considered. However something additionally would be required to specify swift version and record local diffs. Also this would lock us into git, and despite the fact that currently we only use git, we have not yet ruled out supporting other version control systems.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160319/a7ef32dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a28b53f05e7f3067fb104cb78fbb585?s=50"></div><header><strong>[swift-evolution] Proposal Discussion Thread: SwiftPM: Locking and Overriding Dependencies</strong> from <string>Kostiantyn Koval</string> &lt;konstantin.koval1 at gmail.com&gt;<p>March 21, 2016 at 09:00:00pm</p></header><div class="content"><p>I like the proposal.<br></p><p>I have 1 concern. <br>As a package author, like PromiseKit &lt;https://github.com/mxcl/PromiseKit&gt;  I often have a need to fix some of my dependencies and publish it to my package users.<br></p><p>With the current proposal I can do it:<br>  - Advise it in README, which is not really a solution done by swift package manager.<br>  - update Manifest.swift file. There is no convent way to do it now.<br></p><p>I would love to have some functionality to make it simpler for me to specify (modify Manifest.swift or smt else) that Dependency X should: <br>  - use specific tag X<br>  - use commit X<br></p><p>But maybe that should be part of another proposal. The lock file would perfectly solve the problems for developing projects that uses packages.<br></p><p>- Kostiantyn<br></p><p>&gt; On 20 Mar 2016, at 06:07, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; My thoughts on this proposal:<br>&gt; <br>&gt; 1. I agree with some of the other comments that I would prefer the version file be adjacent to &quot;Package.swift&quot;. When the Packages directory isn&#39;t being checked in, I really would like to think of it as an &quot;implementation detail&quot; and not embed functionality inside it that would make it hard to remove or change in the future.<br>&gt; <br>&gt; 2. I like VersionLocks.json well enough, but would like to see a discussion about possible alternatives. My personal proposal (in line with #1) is to use &quot;PackageVersions.json&quot; which has a nice agreement with Package.swift and would mean two common metadata files show up adjacent. I don&#39;t really want to bike shed on the name, but I suspect whatever we pick first will last for a while so I would at least like to review the various alternatives. I also will throw out that my personal opinion is we don&#39;t need to pick a name that bears much resemblance with existing terminology, whatever we pick will eventually become &quot;the standard&quot; for the SwiftPM ecosystem so I would prefer to pick the most-descriptive-possible name up front, not one that alludes to the same concept in other systems.<br>&gt; <br>&gt; 3. I like the terminology section here, I almost feel like we should adopt that as official terminology in our documentation (which I don&#39;t think we have yet, correct me if I am wrong).<br>&gt; <br>&gt; 4. I would like it if the lock file recorded the exact SHA it received, and validate that when retrieving. This helps protect users against MITM attacks or unexpected changes if an upstream modifies a tag. It also can be used as part of safety checks when migrating to an alternate repository host which is expected to have the same content.<br>&gt; <br>&gt; 5. The &quot;workflow - build&quot; sections #2,3,4 are rather complicated. Is this because the proposal is trying to work with existing Packages layouts, or because the proposal is trying to handle the various variations of what the user may have checked in inside the Packages subdirectory?<br>&gt; <br>&gt; 6. I wonder if we should be defining, as Eloy alludes to, two different things:<br>&gt;  - The version lock file, which defines the expected versions for the package manager to use when it is doing package resolution.<br>&gt;  - The package state file (in Packages.swift), which is used by the package manager to track information on the Packages/ subdir state in order to provide useful features primarily focused at the scenarios when the user is modifying those files.<br>&gt; Currently it seems like a lot of the behaviors in the proposal are focused at the latter case, but they feel like they should be decoupled problems to me.<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; On Mar 17, 2016, at 11:23 AM, Max Howell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The following is a draft proposal, feedback welcome.<br>&gt;&gt; <br>&gt;&gt; ____________<br>&gt;&gt; SwiftPM Dependency Version Locking<br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-dependency-lockfiles.md&gt;<br>&gt;&gt; Author(s): Ankit Agarwal &lt;https://github.com/aciidb0mb3r&gt;, Max Howell &lt;https://github.com/mxcl&gt;<br>&gt;&gt; Status: Discussion<br>&gt;&gt; Review manager: Rick Ballard<br>&gt;&gt; Introduction<br>&gt;&gt; This proposal seeks to declare a new, generated file Packages/VersionLocks.json that describes the exact state of a package’s dependency graph and then by default will be respected when executing most package manager commands. Thus it is considered a “version lock” for a package’s dependency sources.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/000067.html&gt;<br>&gt;&gt; Terminology<br>&gt;&gt; A package refers to a published, versioned git repository designed to be consumed as a dependency by SwiftPM.<br>&gt;&gt; A project refers to an end-user workspace that uses SwiftPM (via a Package.swift and swift build) fetching and building packages as part of its build<br>&gt;&gt; Describing this distinction is required because both the above have the same form, but are used differently by an end-user. An end-user may publish packages, but will eventually consume those packages in a project.<br>&gt;&gt; <br>&gt;&gt; As justification for this confusion, it is considered a feature that projects can easily and trivially become packages when using SwiftPM. Encouraging a vibrant packaging ecosystem is one of our goals.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; In a vibrant packaging ecosystem, dependencies update continuously with bug-fixes and new features. A development team needs:<br>&gt;&gt; <br>&gt;&gt; To ensure they are all using the same versions of their dependencies for any given version-control commit.<br>&gt;&gt; Ensure they are all using the same versions of the underlying Swift toolchain<br>&gt;&gt; Be able to override or modify dependency specifications for the whole team for specific commits.<br>&gt;&gt; Currently with SwiftPM it is possible to fulfill 1. by committing the sources of a package’s dependencies with the package itself, but this is not always desirable. There is no way to achieve 2. and 3. with SwiftPM alone.<br>&gt;&gt; <br>&gt;&gt; Additionally, there is not currently a way to know which version of Swift a package requires to build. At this time this situation is particularly precarious because Swift itself is not backwards compatible. As a Swift developer at the very least recording which Swift version a package was built with by the package developer is essential information in order to assess a package&#39;s suitability. Practically the package manager could in the future use this information to aid an end-user or even fix the problem when packages fail to compile.<br>&gt;&gt; <br>&gt;&gt; Proposed Solution<br>&gt;&gt; A file: Packages/VersionLocks.json will be created alongside the Package.swift file. Its contents will describe:<br>&gt;&gt; <br>&gt;&gt; The URL and versions of cloned dependencies<br>&gt;&gt; An inline diff of any local modifications made to those packages relative to their pristine cloned states<br>&gt;&gt; The exact version of the Swift toolchain used as part of the last successful build of the package<br>&gt;&gt; This file is generated by SwiftPM.<br>&gt;&gt; <br>&gt;&gt; This file should be checked-in with projects.<br>&gt;&gt; <br>&gt;&gt; This file is generated and should not be edited by users. If the file is edited by users the behavior is undefined.<br>&gt;&gt; <br>&gt;&gt; This file should be checked-in with packages designed for consumption in projects, however SwiftPM will not use the checkout files of dependencies when determining a project’s dependency graph (this would make dependency graphs much less likely to resolve due to overly strict versioning requirements). In the future we may choose to make it possible for end-users to attempt to build a package using all checkout files since in certain deployment scenarios where an exact graph has already been tested, this is a solid reliabiity feature.<br>&gt;&gt; <br>&gt;&gt; Any local, modifications made to the clones in Packages are recorded in Packages/VersionLocks.json as part of the flow described in the next section. Modifications here means: changes to git remotes and the git-ref of the checked-out HEAD.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; In a fresh clone that does not contain a Packages directory swift build will determine the dependency graph, clone the packages into Packages and generate a Packages/VersionLocks.json file.<br>&gt;&gt; <br>&gt;&gt; The user can now step into the Packages directory and modify package sources. If the user then runs swift build again the package manager will error out:<br>&gt;&gt; <br>&gt;&gt; error: dependency sources have been modified<br>&gt;&gt; execute `swift build --lock` or `swift build --ignore-lock`<br>&gt;&gt; It is an error to build against an unlocked dependency graph, but to facilitate fixing bugs etc. an ignore flag can be specified.<br>&gt;&gt; <br>&gt;&gt; When swift build --lock is specified the package manager regenerates the lockfile detailing the active git remote and the SHA that is checked-out.<br>&gt;&gt; <br>&gt;&gt; Every time swift build completes a build the lockfile is updated (if necessary) recording the current version of the Swift toolchain that achieved the build.<br>&gt;&gt; <br>&gt;&gt; Packages/VersionLocks.json<br>&gt;&gt; <br>&gt;&gt; The exact design of the contents of this file will be explored during iterative development, but here is a possible example:<br>&gt;&gt; <br>&gt;&gt; json { &quot;packages&quot;: [ { &quot;clone&quot;: &quot;Packages/PromiseKit-3.0.3&quot;, &quot;origin&quot;: &quot;https://github.com/mxcl/PromiseKit &lt;https://github.com/mxcl/PromiseKit&gt;&quot; &quot;ref&quot;: &quot;3.0.3&quot; }, { &quot;clone&quot;: &quot;Packages/Alamofire-1.2.3&quot;, &quot;origin&quot;: &quot;https://github.com/a-fork-somewhere/Alamofire &lt;https://github.com/a-fork-somewhere/Alamofire&gt;&quot; &quot;ref&quot;: &quot;crucial-fix&quot; }, { &quot;clone&quot;: &quot;Packages/Quick-1.2.3&quot;, &quot;origin&quot;: &quot;https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;&quot; &quot;ref&quot;: &quot;1.2.3&quot; } ] }<br>&gt;&gt; <br>&gt;&gt; Workflow — Regular Build<br>&gt;&gt; <br>&gt;&gt; User runs swift build<br>&gt;&gt; If Packages/ contains clones and a VersionLocks.jsonSwiftPM skips to 7.<br>&gt;&gt; If Packages/ contains clones and no VersionLocks.json the lockfile is generated from the clones<br>&gt;&gt; If Packages/ contains checked out sources without git information and no VersionLocks.json SwiftPM fetches the git information and provided there is no diff, generates the Lockfile, if there is variation it is an error *<br>&gt;&gt; If Packages/VersionLocks.json is present its dependency graph is used<br>&gt;&gt; If Packages doesn&#39;t exist or is empty the dependency graph is resolved, packages are cloned and the Lockfile is generated<br>&gt;&gt; Build, if Packages are missing because we skipped from 2. the build will error, it is the user&#39;s responsibility to instruct SwiftPM to --update or to fix their dependency graph some other way.<br>&gt;&gt; <br>&gt;&gt; This scenario is so users can check in their complete dependency sources to their tree instead of / as well as the VersionLocks.json file: a situation which sometimes is necessary if your dependencies are removed from their third party online location, etc.<br>&gt;&gt; <br>&gt;&gt; Workflow — Making Modifications<br>&gt;&gt; <br>&gt;&gt; User makes local modification to a dependency’s sources<br>&gt;&gt; User runs swift build<br>&gt;&gt; swift build errors out.<br>&gt;&gt; User must either lock the graph or run with --ignore-lock<br>&gt;&gt; The error-out is likely to be considered tedious by users, however we consider it important that users are made aware and forced to act when they modify their dependencies and thus are exposing their team/users to so-called “dependency hell”.<br>&gt;&gt; <br>&gt;&gt; Runing swift build --lock regenerates the lockfile, but does not build.<br>&gt;&gt; <br>&gt;&gt; Modifications must be committed. This means that if the modifications are not uploaded to a location accessible to the rest of the team they will fail to build when they update their checkouts.<br>&gt;&gt; <br>&gt;&gt; The package manager could check for this by asking git if the specified origin has the current locked ref and error out as appropriate.<br>&gt;&gt; <br>&gt;&gt; Workflow — Overriding Packages<br>&gt;&gt; <br>&gt;&gt; User steps into a Package directory eg. Packages/Foo-1.2.3<br>&gt;&gt; User changes the origin of Foo to their own fork<br>&gt;&gt; User alters HEAD to point to a fix in their own fork<br>&gt;&gt; swift build errors out.<br>&gt;&gt; User must either lock the graph or run with --ignore-lock<br>&gt;&gt; Running swift build --lock regenerates the lockfile, the new origin and tag is stored. Thus a fresh clone of this project would use these overrides.<br>&gt;&gt; <br>&gt;&gt; It is important to note that this workflow will not be respected for dependencies, only for projects.<br>&gt;&gt; <br>&gt;&gt; If a package author requires an override they have a few options:<br>&gt;&gt; <br>&gt;&gt; Change the Package.swift dependency specification. This should only be done as a last resort, for example, a critical bug must be fixed in a dependency and that dependency author is not being responsive. It is up to the Package author to ensure this scenario goes well. SwiftPM itself wants to guard against these conditions with our proposed “publish &amp; lint” step that validates such decisions before signing a published package tag. But we are not there yet and thus package authors should be responsible.<br>&gt;&gt; Advise end-users in a package README that they should override the dependency themselves.<br>&gt;&gt; 2 is preferred, but 1 will happen. We consider it our responsibility to develop tooling that makes 1. safe or unnecessary, but we are not there yet.<br>&gt;&gt; <br>&gt;&gt; Workflow — Updating Packages<br>&gt;&gt; <br>&gt;&gt; SwiftPM has no update mechanism yet, but once it does running swift build --update will fetch the latest versions of all dependencies and update the lockfile.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; This proposal will have no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; One alternative is to allow mentioning refs in manifest file while declaring a dependency but as discussed in this &lt;http://markdownlivepreview.com/%22https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/&gt; thread it might not be the best idea.<br>&gt;&gt; <br>&gt;&gt; Using Git submodules for this feature was considered. However something additionally would be required to specify swift version and record local diffs. Also this would lock us into git, and despite the fact that currently we only use git, we have not yet ruled out supporting other version control systems.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160321/3f3452fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>[swift-evolution] Proposal Discussion Thread: SwiftPM: Locking and Overriding Dependencies</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 21, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;   - update Manifest.swift file. There is no convent way to do it now.<br></p><p>It is not convenient enough to edit it with a text editor and commit? Seems pretty convenient to me.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>[swift-evolution] Proposal Discussion Thread: SwiftPM: Locking and Overriding Dependencies</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 21, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 2. I like VersionLocks.json well enough, but would like to see a discussion about possible alternatives. My personal proposal (in line with #1) is to use &quot;PackageVersions.json&quot; which has a nice agreement with Package.swift and would mean two common metadata files show up adjacent. I don&#39;t really want to bike shed on the name, but I suspect whatever we pick first will last for a while so I would at least like to review the various alternatives. I also will throw out that my personal opinion is we don&#39;t need to pick a name that bears much resemblance with existing terminology, whatever we pick will eventually become &quot;the standard&quot; for the SwiftPM ecosystem so I would prefer to pick the most-descriptive-possible name up front, not one that alludes to the same concept in other systems.<br></p><p>I like PackageVersions.json<br>&gt; <br>&gt; 3. I like the terminology section here, I almost feel like we should adopt that as official terminology in our documentation (which I don&#39;t think we have yet, correct me if I am wrong).<br></p><p>We don’t, but I agree, we should aim to pick some names and use them consistently.<br></p><p>&gt; 4. I would like it if the lock file recorded the exact SHA it received, and validate that when retrieving. This helps protect users against MITM attacks or unexpected changes if an upstream modifies a tag. It also can be used as part of safety checks when migrating to an alternate repository host which is expected to have the same content.<br></p><p>Good point, this should be there.<br></p><p>&gt; 5. The &quot;workflow - build&quot; sections #2,3,4 are rather complicated. Is this because the proposal is trying to work with existing Packages layouts, or because the proposal is trying to handle the various variations of what the user may have checked in inside the Packages subdirectory?<br></p><p>The latter, if we are to support checking in the `Packages` directory, we should handle it when it is so. Is there a simpler way you can see?<br></p><p>&gt; 6. I wonder if we should be defining, as Eloy alludes to, two different things:<br>&gt;  - The version lock file, which defines the expected versions for the package manager to use when it is doing package resolution.<br>&gt;  - The package state file (in Packages.swift), which is used by the package manager to track information on the Packages/ subdir state in order to provide useful features primarily focused at the scenarios when the user is modifying those files.<br>&gt; Currently it seems like a lot of the behaviors in the proposal are focused at the latter case, but they feel like they should be decoupled problems to me.<br></p><p>I’m not sure we need a second file, since the versions of the “installed dependencies” are recorded in the directory names as well as that we also do full clones, so that information is part of the clone &amp; checkout.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160321/83fb74bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>[swift-evolution] Proposal Discussion Thread: SwiftPM: Locking and Overriding Dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 21, 2016, at 4:05 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; 2. I like VersionLocks.json well enough, but would like to see a discussion about possible alternatives. My personal proposal (in line with #1) is to use &quot;PackageVersions.json&quot; which has a nice agreement with Package.swift and would mean two common metadata files show up adjacent. I don&#39;t really want to bike shed on the name, but I suspect whatever we pick first will last for a while so I would at least like to review the various alternatives. I also will throw out that my personal opinion is we don&#39;t need to pick a name that bears much resemblance with existing terminology, whatever we pick will eventually become &quot;the standard&quot; for the SwiftPM ecosystem so I would prefer to pick the most-descriptive-possible name up front, not one that alludes to the same concept in other systems.<br>&gt; <br>&gt; I like PackageVersions.json<br></p><p>Cool. There are still some instances of `VersionLocks.json` in the doc, btw.<br></p><p>&gt;&gt; 3. I like the terminology section here, I almost feel like we should adopt that as official terminology in our documentation (which I don&#39;t think we have yet, correct me if I am wrong).<br>&gt; <br>&gt; We don’t, but I agree, we should aim to pick some names and use them consistently.<br>&gt; <br>&gt;&gt; 4. I would like it if the lock file recorded the exact SHA it received, and validate that when retrieving. This helps protect users against MITM attacks or unexpected changes if an upstream modifies a tag. It also can be used as part of safety checks when migrating to an alternate repository host which is expected to have the same content.<br>&gt; <br>&gt; Good point, this should be there.<br>&gt; <br>&gt;&gt; 5. The &quot;workflow - build&quot; sections #2,3,4 are rather complicated. Is this because the proposal is trying to work with existing Packages layouts, or because the proposal is trying to handle the various variations of what the user may have checked in inside the Packages subdirectory?<br>&gt; <br>&gt; The latter, if we are to support checking in the `Packages` directory, we should handle it when it is so. Is there a simpler way you can see?<br></p><p>I think the minimal feature here is that swiftpm grows the ability to read a specification file which declares how the package dependency tree is resolved. These seems like it should be primitive, and straightforward, so it is worrisome that the proposal is so complex.<br></p><p>What is your mental model for what checked in Packages should be? I can see several ways to interpret them:<br>A. The checked in copy is just a replica of the dependency repository. It exists to ensure the product can be built in a self contained manner.<br>B. The checked in copy *is* the dependency, it is basically a &quot;convenient fork at a pinned version&quot;. SwiftPM recognizes the use case so that it can provide convenient features for the use case (like easily updating the fork).<br>C. Something in between. The checked in copy exists to ensure self containment, but it is also not treated like a fork.<br></p><p>I feel that too many problems are being combined into one proposal, and I think it makes it hard to work through and discuss the ramifications of all the changes here. There are at least five problems discussed in the current proposal:<br>1. The feature for pinning of package versions.<br>2. The workflow for interacting with the pinning feature (i.e., --lock, etc.).<br>3. Interactions between checked in Package trees and package versions.<br>4. Swift toolchain versioning issues.<br>5. Local diffs.<br>#1 and #2 obviously make sense together, and I can see how #1 and #3 might have to be in the same proposal (since implementing #1 may require solving #3 to not break things). I would like to see the rest be teased apart just so it is easier to understand all the implications.<br></p><p>A priori, I don&#39;t see how that minimal feature should require significant discussion w.r.t. checked in Packages. For example, consider the three models I gave above:<br>- If the expected model is (A), then the behavior I get with checked in Packages should always be exactly the same as if I blew it away (assuming the remote hasn&#39;t had content deleted). Therefore, the only new behaviors that need come with version pinning are probably a few cases of error detection (when updating versus a remote which has deleted content).<br> - If the expected model is (B), then I would expect the behavior to be that there *must* be a PackageVersions.json, and the Packages *must* match those in that file. This may be what the existing rules are trying to codify, if so I think it would be most clear to simply specify the intent.<br>	o I can see how there are workflow issues around the user editing their &quot;local fork&quot; and needing to update both the PackageVersions.json, but it seems like they follow from the basic behavior of &quot;the PackageVersions *must* match the local fork&quot;.<br> - If the expected model is (C), then I think it is important to clarify exactly what a checked in Packages subdirectory is for first. I have trouble seeing what that is when the implementation uses it *and* the user may modify it.<br></p><p>&gt;&gt; 6. I wonder if we should be defining, as Eloy alludes to, two different things:<br>&gt;&gt;  - The version lock file, which defines the expected versions for the package manager to use when it is doing package resolution.<br>&gt;&gt;  - The package state file (in Packages.swift), which is used by the package manager to track information on the Packages/ subdir state in order to provide useful features primarily focused at the scenarios when the user is modifying those files.<br>&gt;&gt; Currently it seems like a lot of the behaviors in the proposal are focused at the latter case, but they feel like they should be decoupled problems to me.<br>&gt; <br>&gt; I’m not sure we need a second file, since the versions of the “installed dependencies” are recorded in the directory names as well as that we also do full clones, so that information is part of the clone &amp; checkout.<br></p><p>Good point. I thought it might help to have all the data combined in a file we could easily read, but I guess the only thing we can&#39;t infer is if the user makes a modification to a tag or something where we wouldn&#39;t have the previous hash.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Proposal Discussion Thread: SwiftPM: Locking and Overriding Dependencies</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 21, 2016 at 04:00:00pm</p></header><div class="content"><p>I have revised the proposal based on feedback:<br></p><p>https://github.com/mxcl/swift-evolution/blob/lockfiles/proposals/NNNN-swiftpm-dependency-lockfiles.md<br></p><p>Changed location and name, included SHAs, revised build-workflow steps.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc2018ce0c170425a51033a54850a538?s=50"></div><header><strong>[swift-evolution] Proposal Discussion Thread: SwiftPM: Locking and Overriding Dependencies</strong> from <string>Lukas Stabe</string> &lt;ahti333 at gmail.com&gt;<p>April  4, 2016 at 03:00:00pm</p></header><div class="content"><p>This is a very welcome addition. Thanks!<br></p><p>A nitpicky detail: I’d prefer the format for the lock file to be yaml or toml over json, since those read a little easier in git diffs (which is, in my experience with cocoapods lockfiles, the only place I ever interact with the lockfiles contents).<br></p><p>— Lukas<br></p><p>&gt; On 17 Mar 2016, at 19:23, Max Howell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The following is a draft proposal, feedback welcome.<br>&gt; <br>&gt; ____________<br>&gt; SwiftPM Dependency Version Locking<br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-dependency-lockfiles.md&gt;<br>&gt; Author(s): Ankit Agarwal &lt;https://github.com/aciidb0mb3r&gt;, Max Howell &lt;https://github.com/mxcl&gt;<br>&gt; Status: Discussion<br>&gt; Review manager: Rick Ballard<br>&gt; Introduction<br>&gt; This proposal seeks to declare a new, generated file Packages/VersionLocks.json that describes the exact state of a package’s dependency graph and then by default will be respected when executing most package manager commands. Thus it is considered a “version lock” for a package’s dependency sources.<br>&gt; <br>&gt; Swift-evolution thread &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/000067.html&gt;<br>&gt; Terminology<br>&gt; A package refers to a published, versioned git repository designed to be consumed as a dependency by SwiftPM.<br>&gt; A project refers to an end-user workspace that uses SwiftPM (via a Package.swift and swift build) fetching and building packages as part of its build<br>&gt; Describing this distinction is required because both the above have the same form, but are used differently by an end-user. An end-user may publish packages, but will eventually consume those packages in a project.<br>&gt; <br>&gt; As justification for this confusion, it is considered a feature that projects can easily and trivially become packages when using SwiftPM. Encouraging a vibrant packaging ecosystem is one of our goals.<br>&gt; <br>&gt; Motivation<br>&gt; In a vibrant packaging ecosystem, dependencies update continuously with bug-fixes and new features. A development team needs:<br>&gt; <br>&gt; To ensure they are all using the same versions of their dependencies for any given version-control commit.<br>&gt; Ensure they are all using the same versions of the underlying Swift toolchain<br>&gt; Be able to override or modify dependency specifications for the whole team for specific commits.<br>&gt; Currently with SwiftPM it is possible to fulfill 1. by committing the sources of a package’s dependencies with the package itself, but this is not always desirable. There is no way to achieve 2. and 3. with SwiftPM alone.<br>&gt; <br>&gt; Additionally, there is not currently a way to know which version of Swift a package requires to build. At this time this situation is particularly precarious because Swift itself is not backwards compatible. As a Swift developer at the very least recording which Swift version a package was built with by the package developer is essential information in order to assess a package&#39;s suitability. Practically the package manager could in the future use this information to aid an end-user or even fix the problem when packages fail to compile.<br>&gt; <br>&gt; Proposed Solution<br>&gt; A file: Packages/VersionLocks.json will be created alongside the Package.swift file. Its contents will describe:<br>&gt; <br>&gt; The URL and versions of cloned dependencies<br>&gt; An inline diff of any local modifications made to those packages relative to their pristine cloned states<br>&gt; The exact version of the Swift toolchain used as part of the last successful build of the package<br>&gt; This file is generated by SwiftPM.<br>&gt; <br>&gt; This file should be checked-in with projects.<br>&gt; <br>&gt; This file is generated and should not be edited by users. If the file is edited by users the behavior is undefined.<br>&gt; <br>&gt; This file should be checked-in with packages designed for consumption in projects, however SwiftPM will not use the checkout files of dependencies when determining a project’s dependency graph (this would make dependency graphs much less likely to resolve due to overly strict versioning requirements). In the future we may choose to make it possible for end-users to attempt to build a package using all checkout files since in certain deployment scenarios where an exact graph has already been tested, this is a solid reliabiity feature.<br>&gt; <br>&gt; Any local, modifications made to the clones in Packages are recorded in Packages/VersionLocks.json as part of the flow described in the next section. Modifications here means: changes to git remotes and the git-ref of the checked-out HEAD.<br>&gt; <br>&gt; Detailed Design<br>&gt; In a fresh clone that does not contain a Packages directory swift build will determine the dependency graph, clone the packages into Packages and generate a Packages/VersionLocks.json file.<br>&gt; <br>&gt; The user can now step into the Packages directory and modify package sources. If the user then runs swift build again the package manager will error out:<br>&gt; <br>&gt; error: dependency sources have been modified<br>&gt; execute `swift build --lock` or `swift build --ignore-lock`<br>&gt; It is an error to build against an unlocked dependency graph, but to facilitate fixing bugs etc. an ignore flag can be specified.<br>&gt; <br>&gt; When swift build --lock is specified the package manager regenerates the lockfile detailing the active git remote and the SHA that is checked-out.<br>&gt; <br>&gt; Every time swift build completes a build the lockfile is updated (if necessary) recording the current version of the Swift toolchain that achieved the build.<br>&gt; <br>&gt; Packages/VersionLocks.json<br>&gt; <br>&gt; The exact design of the contents of this file will be explored during iterative development, but here is a possible example:<br>&gt; <br>&gt; json { &quot;packages&quot;: [ { &quot;clone&quot;: &quot;Packages/PromiseKit-3.0.3&quot;, &quot;origin&quot;: &quot;https://github.com/mxcl/PromiseKit &lt;https://github.com/mxcl/PromiseKit&gt;&quot; &quot;ref&quot;: &quot;3.0.3&quot; }, { &quot;clone&quot;: &quot;Packages/Alamofire-1.2.3&quot;, &quot;origin&quot;: &quot;https://github.com/a-fork-somewhere/Alamofire &lt;https://github.com/a-fork-somewhere/Alamofire&gt;&quot; &quot;ref&quot;: &quot;crucial-fix&quot; }, { &quot;clone&quot;: &quot;Packages/Quick-1.2.3&quot;, &quot;origin&quot;: &quot;https://github.com/Quick/Quick &lt;https://github.com/Quick/Quick&gt;&quot; &quot;ref&quot;: &quot;1.2.3&quot; } ] }<br>&gt; <br>&gt; Workflow — Regular Build<br>&gt; <br>&gt; User runs swift build<br>&gt; If Packages/ contains clones and a VersionLocks.jsonSwiftPM skips to 7.<br>&gt; If Packages/ contains clones and no VersionLocks.json the lockfile is generated from the clones<br>&gt; If Packages/ contains checked out sources without git information and no VersionLocks.json SwiftPM fetches the git information and provided there is no diff, generates the Lockfile, if there is variation it is an error *<br>&gt; If Packages/VersionLocks.json is present its dependency graph is used<br>&gt; If Packages doesn&#39;t exist or is empty the dependency graph is resolved, packages are cloned and the Lockfile is generated<br>&gt; Build, if Packages are missing because we skipped from 2. the build will error, it is the user&#39;s responsibility to instruct SwiftPM to --update or to fix their dependency graph some other way.<br>&gt; <br>&gt; This scenario is so users can check in their complete dependency sources to their tree instead of / as well as the VersionLocks.json file: a situation which sometimes is necessary if your dependencies are removed from their third party online location, etc.<br>&gt; <br>&gt; Workflow — Making Modifications<br>&gt; <br>&gt; User makes local modification to a dependency’s sources<br>&gt; User runs swift build<br>&gt; swift build errors out.<br>&gt; User must either lock the graph or run with --ignore-lock<br>&gt; The error-out is likely to be considered tedious by users, however we consider it important that users are made aware and forced to act when they modify their dependencies and thus are exposing their team/users to so-called “dependency hell”.<br>&gt; <br>&gt; Runing swift build --lock regenerates the lockfile, but does not build.<br>&gt; <br>&gt; Modifications must be committed. This means that if the modifications are not uploaded to a location accessible to the rest of the team they will fail to build when they update their checkouts.<br>&gt; <br>&gt; The package manager could check for this by asking git if the specified origin has the current locked ref and error out as appropriate.<br>&gt; <br>&gt; Workflow — Overriding Packages<br>&gt; <br>&gt; User steps into a Package directory eg. Packages/Foo-1.2.3<br>&gt; User changes the origin of Foo to their own fork<br>&gt; User alters HEAD to point to a fix in their own fork<br>&gt; swift build errors out.<br>&gt; User must either lock the graph or run with --ignore-lock<br>&gt; Running swift build --lock regenerates the lockfile, the new origin and tag is stored. Thus a fresh clone of this project would use these overrides.<br>&gt; <br>&gt; It is important to note that this workflow will not be respected for dependencies, only for projects.<br>&gt; <br>&gt; If a package author requires an override they have a few options:<br>&gt; <br>&gt; Change the Package.swift dependency specification. This should only be done as a last resort, for example, a critical bug must be fixed in a dependency and that dependency author is not being responsive. It is up to the Package author to ensure this scenario goes well. SwiftPM itself wants to guard against these conditions with our proposed “publish &amp; lint” step that validates such decisions before signing a published package tag. But we are not there yet and thus package authors should be responsible.<br>&gt; Advise end-users in a package README that they should override the dependency themselves.<br>&gt; 2 is preferred, but 1 will happen. We consider it our responsibility to develop tooling that makes 1. safe or unnecessary, but we are not there yet.<br>&gt; <br>&gt; Workflow — Updating Packages<br>&gt; <br>&gt; SwiftPM has no update mechanism yet, but once it does running swift build --update will fetch the latest versions of all dependencies and update the lockfile.<br>&gt; <br>&gt; Impact on existing code<br>&gt; This proposal will have no impact on existing code.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; One alternative is to allow mentioning refs in manifest file while declaring a dependency but as discussed in this &lt;http://markdownlivepreview.com/%22https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/&gt; thread it might not be the best idea.<br>&gt; <br>&gt; Using Git submodules for this feature was considered. However something additionally would be required to specify swift version and record local diffs. Also this would lock us into git, and despite the fact that currently we only use git, we have not yet ruled out supporting other version control systems.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160404/3a4ba688/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
