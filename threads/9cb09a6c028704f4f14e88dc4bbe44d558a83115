<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 29, 2016 at 08:00:00am</p></header><div class="content"><p>Gmane is down as far as my browser is concerned and I haven&#39;t found anything by Googling.<br></p><p>Given the following:<br></p><p>protocol A {func foo()}<br>protocol B {} // empty protocol<br></p><p>extension A where Self:B {<br>    func foo() {<br>        print(&quot;Self is B&quot;)<br>    }<br>}<br></p><p>// Works<br>struct S1: A, B {}<br>S1().foo()<br></p><p>Is there a way to produce a similar extension that exempts any type that conforms to B?<br></p><p>cc&#39;ing in Wux because this is a direct response to a scenario he brought up yesterday.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/9cb03115/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Just writing an extension for plain A without a where clause works.<br></p><p>-Thorsten <br></p><p>&gt; Am 29.04.2016 um 16:03 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Gmane is down as far as my browser is concerned and I haven&#39;t found anything by Googling.<br>&gt; <br>&gt; Given the following:<br>&gt; <br>&gt; protocol A {func foo()}<br>&gt; protocol B {} // empty protocol<br>&gt; <br>&gt; extension A where Self:B {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is B&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; // Works<br>&gt; struct S1: A, B {}<br>&gt; S1().foo()<br>&gt; <br>&gt; Is there a way to produce a similar extension that exempts any type that conforms to B?<br>&gt; <br>&gt; cc&#39;ing in Wux because this is a direct response to a scenario he brought up yesterday.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/b26cf71c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>In Wux&#39;s example, he has third party code:<br></p><p>```<br>Type ThirdParty {<br>    func foo() { print(&quot;from third party&quot;) }<br>}<br>```<br></p><p>Then in his own code, he defines protocol A and extends it:<br></p><p>extension A {<br>    func foo() {<br>        print(&quot;Self is B&quot;)<br>    }<br>}<br></p><p>and conforms ThirdParty to A. But he wants the original  foo() implementation. Your approach<br>for writing an extension for plain A without a where clause doesn&#39;t offer that solution. The goal<br>here is &quot;Add this default behavior *only* where a type does not conform to B&quot;<br></p><p>-- E<br></p><p><br>&gt; On Apr 29, 2016, at 9:10 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Just writing an extension for plain A without a where clause works.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 29.04.2016 um 16:03 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Gmane is down as far as my browser is concerned and I haven&#39;t found anything by Googling.<br>&gt;&gt; <br>&gt;&gt; Given the following:<br>&gt;&gt; <br>&gt;&gt; protocol A {func foo()}<br>&gt;&gt; protocol B {} // empty protocol<br>&gt;&gt; <br>&gt;&gt; extension A where Self:B {<br>&gt;&gt;     func foo() {<br>&gt;&gt;         print(&quot;Self is B&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Works<br>&gt;&gt; struct S1: A, B {}<br>&gt;&gt; S1().foo()<br>&gt;&gt; <br>&gt;&gt; Is there a way to produce a similar extension that exempts any type that conforms to B?<br>&gt;&gt; <br>&gt;&gt; cc&#39;ing in Wux because this is a direct response to a scenario he brought up yesterday.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/12ad5b91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 29, 2016 at 07:00:00pm</p></header><div class="content"><p>No problem, that still works, because the most specific implementation is chosen:<br></p><p>protocol A { func foo()}<br>protocol B {} // empty protocol<br></p><p>extension A  {<br>    func foo() {<br>        print(&quot;Self is A&quot;)<br>    }<br>}<br></p><p>extension A where Self: B {<br>    func foo() {<br>        print(&quot;Self is B&quot;)<br>    }<br>}<br></p><p>// Works<br>struct S1: A, B {}<br>S1().foo() // Self is B<br></p><p>struct S2: A {}<br>S2().foo() // Self is A<br></p><p><br>// Wu&#39;s example works, too<br></p><p>struct ThirdParty {<br>    func foo() {<br>        print(&quot;Self is ThirdParty&quot;)<br>    }<br>}<br></p><p>extension ThirdParty : A {}<br></p><p>ThirdParty().foo() // Self is ThirdParty<br></p><p><br>// dynamic dispatch works, too<br></p><p>let a1: A = S1()<br>a1.foo() // Self is B<br></p><p>let a2: A = S2()<br>a2.foo() // Self is A<br></p><p>let a3: A = ThirdParty() // Self is ThirdParty<br>a3.foo()<br></p><p><br>-Thorsten<br></p><p><br>&gt; Am 29.04.2016 um 17:20 schrieb Erica Sadun &lt;erica at ericasadun.com&gt;:<br>&gt; <br>&gt; In Wux&#39;s example, he has third party code:<br>&gt; <br>&gt; ```<br>&gt; Type ThirdParty {<br>&gt;     func foo() { print(&quot;from third party&quot;) }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Then in his own code, he defines protocol A and extends it:<br>&gt; <br>&gt; extension A {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is B&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; and conforms ThirdParty to A. But he wants the original  foo() implementation. Your approach<br>&gt; for writing an extension for plain A without a where clause doesn&#39;t offer that solution. The goal<br>&gt; here is &quot;Add this default behavior *only* where a type does not conform to B&quot;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 29, 2016, at 9:10 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just writing an extension for plain A without a where clause works.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 29.04.2016 um 16:03 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Gmane is down as far as my browser is concerned and I haven&#39;t found anything by Googling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A {func foo()}<br>&gt;&gt;&gt; protocol B {} // empty protocol<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A where Self:B {<br>&gt;&gt;&gt;     func foo() {<br>&gt;&gt;&gt;         print(&quot;Self is B&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Works<br>&gt;&gt;&gt; struct S1: A, B {}<br>&gt;&gt;&gt; S1().foo()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a way to produce a similar extension that exempts any type that conforms to B?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; cc&#39;ing in Wux because this is a direct response to a scenario he brought up yesterday.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/9271df6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Yes, certainly this works today. The motivation for Erica&#39;s question is<br>that this would not work without modifying the third-party code if keywords<br>were required to indicate implementation of protocol requirements.<br></p><p>One possible solution might emerge if it is possible to extend a protocol<br>conditional on Self not being some concrete type. Thus, asking whether<br>there is a way to express that.<br>On Fri, Apr 29, 2016 at 12:45 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt; No problem, that still works, because the most specific implementation is<br>&gt; chosen:<br>&gt;<br>&gt; protocol A { func foo()}<br>&gt; protocol B {} // empty protocol<br>&gt;<br>&gt; extension A  {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is A&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension A where Self: B {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is B&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; // Works<br>&gt; struct S1: A, B {}<br>&gt; S1().foo() // Self is B<br>&gt;<br>&gt; struct S2: A {}<br>&gt; S2().foo() // Self is A<br>&gt;<br>&gt;<br>&gt; // Wu&#39;s example works, too<br>&gt;<br>&gt; struct ThirdParty {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is ThirdParty&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extension ThirdParty : A {}<br>&gt;<br>&gt; ThirdParty().foo() // Self is ThirdParty<br>&gt;<br>&gt;<br>&gt; // dynamic dispatch works, too<br>&gt;<br>&gt; let a1: A = S1()<br>&gt; a1.foo() // Self is B<br>&gt;<br>&gt; let a2: A = S2()<br>&gt; a2.foo() // Self is A<br>&gt;<br>&gt; let a3: A = ThirdParty() // Self is ThirdParty<br>&gt; a3.foo()<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 29.04.2016 um 17:20 schrieb Erica Sadun &lt;erica at ericasadun.com&gt;:<br>&gt;<br>&gt; In Wux&#39;s example, he has third party code:<br>&gt;<br>&gt; ```<br>&gt; Type ThirdParty {<br>&gt;     func foo() { print(&quot;from third party&quot;) }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Then in his own code, he defines protocol A and extends it:<br>&gt;<br>&gt; extension A {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is B&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; and conforms ThirdParty to A. But he wants the original  foo()<br>&gt; implementation. Your approach<br>&gt; for writing an extension for plain A without a where clause doesn&#39;t offer<br>&gt; that solution. The goal<br>&gt; here is &quot;Add this default behavior *only* where a type does not conform to<br>&gt; B&quot;<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Apr 29, 2016, at 9:10 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt; Just writing an extension for plain A without a where clause works.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 29.04.2016 um 16:03 schrieb Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Gmane is down as far as my browser is concerned and I haven&#39;t found<br>&gt; anything by Googling.<br>&gt;<br>&gt; Given the following:<br>&gt;<br>&gt; protocol A {func foo()}<br>&gt; protocol B {} // empty protocol<br>&gt;<br>&gt; extension A where Self:B {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is B&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; // Works<br>&gt; struct S1: A, B {}<br>&gt; S1().foo()<br>&gt;<br>&gt; Is there a way to produce a similar extension that exempts any type that<br>&gt; conforms to B?<br>&gt;<br>&gt; cc&#39;ing in Wux because this is a direct response to a scenario he brought<br>&gt; up yesterday.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/f1889b22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 29, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 29.04.2016 um 19:51 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt; <br>&gt; Yes, certainly this works today. The motivation for Erica&#39;s question is that this would not work without modifying the third-party code if keywords were required to indicate implementation of protocol requirements.<br></p><p>If I understood the motivation correctly, the requirements should protect against typos where I planned to *replace* a method but due to a typo instead created a new method and inherited the default (or superclass) implementation.<br>But this use case does not apply to modeling after the fact, because I simply *cannot make typos* there as the type to be extended in general is a third party type and cannot be edited by me.<br>Therefore extensions declaring conformance of a type to a protocol should not require any special markup for methods existing elsewhere (i.e. already in the type or other extensions of that type). <br>But requiring `override` markers for new methods written within the extension would still be sensible because these would again protect against typos in my own code.<br></p><p>In addition some people like to split their types in parts writing them as extensions, e.g. one for each protocol conformance. This looks quite similar to modeling after the fact and the same rationale applies: requiring `override` markers within the extension make sense.<br></p><p>So we would have:<br></p><p>// third party code; using split declarations<br></p><p>struct ThirdPartyProtocol {<br>	func bar()<br>}<br></p><p>struct ThirdParty { <br>	func foo() { … }<br>}<br></p><p>extension ThirdParty : ThirdPartyProtocol {<br>	override func bar() { … } // `override` marker required<br>}<br></p><p>// my code: modeling after the fact<br></p><p>protocol A { <br>	func foo() <br>	func baz()<br>}<br></p><p>extension ThirdParty : A {<br>	// no markers required for foo()  <br>	override func baz() { … } // `override` marker required<br>}<br></p><p><br>&gt; One possible solution might emerge if it is possible to extend a protocol conditional on Self not being some concrete type. Thus, asking whether there is a way to express that.<br></p><p>I do not see the need for that. This sounds like introducing something together with a workaround for it :-)<br>But maybe I have misunderstood what you intend.<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; On Fri, Apr 29, 2016 at 12:45 Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; No problem, that still works, because the most specific implementation is chosen:<br>&gt; <br>&gt; protocol A { func foo()}<br>&gt; protocol B {} // empty protocol<br>&gt; <br>&gt; extension A  {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is A&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension A where Self: B {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is B&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; // Works<br>&gt; struct S1: A, B {}<br>&gt; S1().foo() // Self is B<br>&gt; <br>&gt; struct S2: A {}<br>&gt; S2().foo() // Self is A<br>&gt; <br>&gt; <br>&gt; // Wu&#39;s example works, too<br>&gt; <br>&gt; struct ThirdParty {<br>&gt;     func foo() {<br>&gt;         print(&quot;Self is ThirdParty&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension ThirdParty : A {}<br>&gt; <br>&gt; ThirdParty().foo() // Self is ThirdParty<br>&gt; <br>&gt; <br>&gt; // dynamic dispatch works, too<br>&gt; <br>&gt; let a1: A = S1()<br>&gt; a1.foo() // Self is B<br>&gt; <br>&gt; let a2: A = S2()<br>&gt; a2.foo() // Self is A<br>&gt; <br>&gt; let a3: A = ThirdParty() // Self is ThirdParty<br>&gt; a3.foo()<br>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 29.04.2016 um 17:20 schrieb Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; In Wux&#39;s example, he has third party code:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; Type ThirdParty {<br>&gt;&gt;     func foo() { print(&quot;from third party&quot;) }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Then in his own code, he defines protocol A and extends it:<br>&gt;&gt; <br>&gt;&gt; extension A {<br>&gt;&gt;     func foo() {<br>&gt;&gt;         print(&quot;Self is B&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and conforms ThirdParty to A. But he wants the original  foo() implementation. Your approach<br>&gt;&gt; for writing an extension for plain A without a where clause doesn&#39;t offer that solution. The goal<br>&gt;&gt; here is &quot;Add this default behavior *only* where a type does not conform to B&quot;<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 29, 2016, at 9:10 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just writing an extension for plain A without a where clause works.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 29.04.2016 um 16:03 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gmane is down as far as my browser is concerned and I haven&#39;t found anything by Googling.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol A {func foo()}<br>&gt;&gt;&gt;&gt; protocol B {} // empty protocol<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension A where Self:B {<br>&gt;&gt;&gt;&gt;     func foo() {<br>&gt;&gt;&gt;&gt;         print(&quot;Self is B&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Works<br>&gt;&gt;&gt;&gt; struct S1: A, B {}<br>&gt;&gt;&gt;&gt; S1().foo()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a way to produce a similar extension that exempts any type that conforms to B?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; cc&#39;ing in Wux because this is a direct response to a scenario he brought up yesterday.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/7edb5539/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 30, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 29, 2016, at 3:18 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 29.04.2016 um 19:51 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Yes, certainly this works today. The motivation for Erica&#39;s question is that this would not work without modifying the third-party code if keywords were required to indicate implementation of protocol requirements.<br>&gt; <br>&gt; If I understood the motivation correctly, the requirements should protect against typos where I planned to *replace* a method but due to a typo instead created a new method and inherited the default (or superclass) implementation.<br></p><p>extension A where !x:B {<br>    ....<br>}<br></p><p><br>then conforming a type to A and B would exclude the type from inheriting the extension.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/ce20c2c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 01.05.2016 um 03:03 schrieb Erica Sadun &lt;erica at ericasadun.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 29, 2016, at 3:18 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 29.04.2016 um 19:51 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, certainly this works today. The motivation for Erica&#39;s question is that this would not work without modifying the third-party code if keywords were required to indicate implementation of protocol requirements.<br>&gt;&gt; <br>&gt;&gt; If I understood the motivation correctly, the requirements should protect against typos where I planned to *replace* a method but due to a typo instead created a new method and inherited the default (or superclass) implementation.<br>&gt; <br>&gt; extension A where !x:B {<br>&gt;     ....<br>&gt; }<br>&gt; <br>&gt; <br>&gt; then conforming a type to A and B would exclude the type from inheriting the extension.<br></p><p>I still don’t see the need for that. As my code example demonstrated an extension will not override an existing method in a conforming type and my other mail demonstrated that it is not necessary to have „required“ keywords in existing code which is extended.<br></p><p>Maybe I still haven’t understood the use case you are trying to solve. In that case I’d appreciate if you would give a complete example that shows what should happen why.<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/000d761a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  1, 2016 at 09:00:00pm</p></header><div class="content"><p>The point is pretty much moot. In Erica&#39;s draft proposal, keywords are<br>required in any Swift code that hasn&#39;t been compiled in order to indicate<br>conformance. Under that scheme, it might be useful to be able to express<br>something like what Erica asked about in this email thread. I understood it<br>to be a factual question--is it or is it not possible to exclude one<br>particular conforming type from an extension of a protocol? The answer<br>seems to be that the it is not possible in current Swift syntax, which is<br>fine.<br></p><p>I understand that you are saying that it isn&#39;t currently necessary to use<br>such a feature for retroactive modeling and that it might be possible to<br>write an alternative proposal for keywords like `required` in which it<br>continues not to be necessary. I don&#39;t think there&#39;s any disagreement here.<br>On Sun, May 1, 2016 at 16:24 Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt;<br>&gt; Am 01.05.2016 um 03:03 schrieb Erica Sadun &lt;erica at ericasadun.com&gt;:<br>&gt;<br>&gt;<br>&gt; On Apr 29, 2016, at 3:18 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Am 29.04.2016 um 19:51 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt;<br>&gt; Yes, certainly this works today. The motivation for Erica&#39;s question is<br>&gt; that this would not work without modifying the third-party code if keywords<br>&gt; were required to indicate implementation of protocol requirements.<br>&gt;<br>&gt;<br>&gt; If I understood the motivation correctly, the requirements should protect<br>&gt; against typos where I planned to *replace* a method but due to a typo<br>&gt; instead created a new method and inherited the default (or superclass)<br>&gt; implementation.<br>&gt;<br>&gt;<br>&gt; extension A where !x:B {<br>&gt;     ....<br>&gt; }<br>&gt;<br>&gt;<br>&gt; then conforming a type to A and B would exclude the type from inheriting<br>&gt; the extension.<br>&gt;<br>&gt;<br>&gt; I still don’t see the need for that. As my code example demonstrated an<br>&gt; extension will not override an existing method in a conforming type and my<br>&gt; other mail demonstrated that it is not necessary to have „required“<br>&gt; keywords in existing code which is extended.<br>&gt;<br>&gt; Maybe I still haven’t understood the use case you are trying to solve. In<br>&gt; that case I’d appreciate if you would give a complete example that shows<br>&gt; what should happen why.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/ca0db736/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Protocol non-conformance clause</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 01.05.2016 um 23:34 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br>&gt; <br>&gt; The point is pretty much moot. In Erica&#39;s draft proposal, keywords are required in any Swift code that hasn&#39;t been compiled in order to indicate conformance. Under that scheme, it might be useful to be able to express something like what Erica asked about in this email thread. I understood it to be a factual question--is it or is it not possible to exclude one particular conforming type from an extension of a protocol? The answer seems to be that the it is not possible in current Swift syntax, which is fine.<br>&gt; <br>&gt; I understand that you are saying that it isn&#39;t currently necessary to use such a feature for retroactive modeling and that it might be possible to write an alternative proposal for keywords like `required` in which it continues not to be necessary. I don&#39;t think there&#39;s any disagreement here.<br></p><p>Ok :-)<br></p><p>-Thorsten<br></p><p><br>&gt; On Sun, May 1, 2016 at 16:24 Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Am 01.05.2016 um 03:03 schrieb Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 29, 2016, at 3:18 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 29.04.2016 um 19:51 schrieb Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, certainly this works today. The motivation for Erica&#39;s question is that this would not work without modifying the third-party code if keywords were required to indicate implementation of protocol requirements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I understood the motivation correctly, the requirements should protect against typos where I planned to *replace* a method but due to a typo instead created a new method and inherited the default (or superclass) implementation.<br>&gt;&gt; <br>&gt;&gt; extension A where !x:B {<br>&gt;&gt;     ....<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; then conforming a type to A and B would exclude the type from inheriting the extension.<br>&gt; <br>&gt; I still don’t see the need for that. As my code example demonstrated an extension will not override an existing method in a conforming type and my other mail demonstrated that it is not necessary to have „required“ keywords in existing code which is extended.<br>&gt; <br>&gt; Maybe I still haven’t understood the use case you are trying to solve. In that case I’d appreciate if you would give a complete example that shows what should happen why.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/2deac491/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
