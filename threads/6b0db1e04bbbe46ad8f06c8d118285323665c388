<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 11, 2016 at 08:00:00am</p></header><div class="content"><p>Hi All,<br></p><p>The API guidelines working group took up the issue of the InPlace suffix<br>yesterday, and decided that it was not to be used anywhere in the<br>standard library.  We are planning to apply the changes shown here<br>&lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>SetAlgebra (and consequently Set) to make it conform to the guidelines<br>under development.<br></p><p>Comments welcome as usual,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 8:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br>&gt; <br>&gt; Comments welcome as usual,<br></p><p>-///   - `x.intersect(x) == x`<br>-///   - `x.intersect([]) == []`<br>-///   - `x.union(x) == x`<br>-///   - `x.union([]) == x`<br>+///   - `x.intersection(with: x) == x`<br>+///   - `x.intersection(with: []) == []`<br>+///   - `x.unioning(with: x) == x`<br>+///   - `x.unioning(with: []) == x`<br></p><p>What&#39;s with the (with:)? That seems like a pretty needless word. Same with &#39;of:&#39; and friends.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&quot;intersection should form a pair with „union“, both being a noun.<br></p><p>&quot;unioning“ is a bad choice. AFAIK „union“ is only rarely used as verb, so its present participle just sounds … strange.<br></p><p><br>I’d like to repeat my suggestion:<br></p><p>mutating (verbs):<br>x.intersect(x)<br>x.add(x)<br>x.subtract(x)<br></p><p>nonmutating (nouns):<br>x.intersection(x)<br>x.union(x)<br>x.difference(x)<br></p><p><br>-Thorsten<br></p><p><br>&gt; Am 11.02.2016 um 19:06 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 8:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hi All,<br>&gt;&gt; <br>&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt; under development.<br>&gt;&gt; <br>&gt;&gt; Comments welcome as usual,<br>&gt; <br>&gt; -///   - `x.intersect(x) == x`<br>&gt; -///   - `x.intersect([]) == []`<br>&gt; -///   - `x.union(x) == x`<br>&gt; -///   - `x.union([]) == x`<br>&gt; +///   - `x.intersection(with: x) == x`<br>&gt; +///   - `x.intersection(with: []) == []`<br>&gt; +///   - `x.unioning(with: x) == x`<br>&gt; +///   - `x.unioning(with: []) == x`<br>&gt; <br>&gt; What&#39;s with the (with:)? That seems like a pretty needless word. Same with &#39;of:&#39; and friends.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 12, 2016 at 01:00:00am</p></header><div class="content"><p>or x.merge(x) for mutating union.<br></p><p>&gt; On 2016-02-12, at 1:49:23, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’d like to repeat my suggestion:<br>&gt; <br>&gt; mutating (verbs):<br>&gt; x.intersect(x)<br>&gt; x.add(x)<br>&gt; x.subtract(x)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/f2b847a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 08:00:00pm</p></header><div class="content"><p>Good idea!<br></p><p>-Thorsten<br></p><p><br>&gt; Am 11.02.2016 um 19:52 schrieb Craig Cruden &lt;ccruden at novafore.com&gt;:<br>&gt; <br>&gt; or x.merge(x) for mutating union.<br>&gt; <br>&gt;&gt; On 2016-02-12, at 1:49:23, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’d like to repeat my suggestion:<br>&gt;&gt; <br>&gt;&gt; mutating (verbs):<br>&gt;&gt; x.intersect(x)<br>&gt;&gt; x.add(x)<br>&gt;&gt; x.subtract(x)<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/f27404e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 12, 2016 at 02:00:00am</p></header><div class="content"><p>I was thinking of maybe:<br></p><p>x.remove(x) for subtract (java mutable remove).  <br></p><p>&gt; On 2016-02-12, at 2:00:41, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Good idea!<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 11.02.2016 um 19:52 schrieb Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; or x.merge(x) for mutating union.<br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-12, at 1:49:23, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to repeat my suggestion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; mutating (verbs):<br>&gt;&gt;&gt; x.intersect(x)<br>&gt;&gt;&gt; x.add(x)<br>&gt;&gt;&gt; x.subtract(x)<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/91facb2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 12, 2016 at 02:00:00am</p></header><div class="content"><p>I was trying to think of a non mathematical term for intersect in a mutating manner….<br></p><p>but that one is hard…. the only thing that came to mind was “overlap” but I don’t think anyone would find it (maybe not a bad thing :p )<br></p><p><br>&gt; On 2016-02-12, at 2:05:59, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; I was thinking of maybe:<br>&gt; <br>&gt; x.remove(x) for subtract (java mutable remove).  <br>&gt; <br>&gt;&gt; On 2016-02-12, at 2:00:41, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Good idea!<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 11.02.2016 um 19:52 schrieb Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or x.merge(x) for mutating union.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2016-02-12, at 1:49:23, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to repeat my suggestion:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; mutating (verbs):<br>&gt;&gt;&gt;&gt; x.intersect(x)<br>&gt;&gt;&gt;&gt; x.add(x)<br>&gt;&gt;&gt;&gt; x.subtract(x)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/449f2088/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 12, 2016 at 04:00:00pm</p></header><div class="content"><p>intersect is a verb so it is fine for mutating.<br>The noun intersection can then be used for the nonmutating variant.<br></p><p>remove/merge/add/unite sound all good to me for for the mutating variant of union.<br></p><p>-Thorsten <br></p><p>&gt; Am 11.02.2016 um 20:19 schrieb Craig Cruden &lt;ccruden at novafore.com&gt;:<br>&gt; <br>&gt; I was trying to think of a non mathematical term for intersect in a mutating manner….<br>&gt; <br>&gt; but that one is hard…. the only thing that came to mind was “overlap” but I don’t think anyone would find it (maybe not a bad thing :p )<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-12, at 2:05:59, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was thinking of maybe:<br>&gt;&gt; <br>&gt;&gt; x.remove(x) for subtract (java mutable remove).  <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-12, at 2:00:41, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good idea!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 11.02.2016 um 19:52 schrieb Craig Cruden &lt;ccruden at novafore.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or x.merge(x) for mutating union.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-02-12, at 1:49:23, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d like to repeat my suggestion:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; mutating (verbs):<br>&gt;&gt;&gt;&gt;&gt; x.intersect(x)<br>&gt;&gt;&gt;&gt;&gt; x.add(x)<br>&gt;&gt;&gt;&gt;&gt; x.subtract(x)<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/ab88a356/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>I like Thorsten’s suggestion. I’m not an authority, but as far as I can tell, ‘add’ and ’subtract&#39; are still mathematical correct and precise when used this way.<br></p><p>—CK<br></p><p>&gt; On Feb 11, 2016, at 10:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;intersection should form a pair with „union“, both being a noun.<br>&gt; <br>&gt; &quot;unioning“ is a bad choice. AFAIK „union“ is only rarely used as verb, so its present participle just sounds … strange.<br>&gt; <br>&gt; <br>&gt; I’d like to repeat my suggestion:<br>&gt; <br>&gt; mutating (verbs):<br>&gt; x.intersect(x)<br>&gt; x.add(x)<br>&gt; x.subtract(x)<br>&gt; <br>&gt; nonmutating (nouns):<br>&gt; x.intersection(x)<br>&gt; x.union(x)<br>&gt; x.difference(x)<br>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 11.02.2016 um 19:06 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 8:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi All,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt;&gt; under development.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments welcome as usual,<br>&gt;&gt; <br>&gt;&gt; -///   - `x.intersect(x) == x`<br>&gt;&gt; -///   - `x.intersect([]) == []`<br>&gt;&gt; -///   - `x.union(x) == x`<br>&gt;&gt; -///   - `x.union([]) == x`<br>&gt;&gt; +///   - `x.intersection(with: x) == x`<br>&gt;&gt; +///   - `x.intersection(with: []) == []`<br>&gt;&gt; +///   - `x.unioning(with: x) == x`<br>&gt;&gt; +///   - `x.unioning(with: []) == x`<br>&gt;&gt; <br>&gt;&gt; What&#39;s with the (with:)? That seems like a pretty needless word. Same with &#39;of:&#39; and friends.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 13, 2016 at 12:00:00am</p></header><div class="content"><p>I had this as one of my alternatives which I think is also a good one.  It is missing the &quot;exclusive or” though, also known as &quot;symmetric difference”.  Perhaps it could be named symmetricSubtract() for the mutable method and symmetricDifference() for the non-mutable one.  Or maybe xor() and xorDifference() respectively.<br></p><p><br></p><p>&gt; On Feb 11, 2016, at 1:49 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;intersection should form a pair with „union“, both being a noun.<br>&gt; <br>&gt; &quot;unioning“ is a bad choice. AFAIK „union“ is only rarely used as verb, so its present participle just sounds … strange.<br>&gt; <br>&gt; <br>&gt; I’d like to repeat my suggestion:<br>&gt; <br>&gt; mutating (verbs):<br>&gt; x.intersect(x)<br>&gt; x.add(x)<br>&gt; x.subtract(x)<br>&gt; <br>&gt; nonmutating (nouns):<br>&gt; x.intersection(x)<br>&gt; x.union(x)<br>&gt; x.difference(x)<br>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 11.02.2016 um 19:06 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 8:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi All,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt;&gt; under development.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments welcome as usual,<br>&gt;&gt; <br>&gt;&gt; -///   - `x.intersect(x) == x`<br>&gt;&gt; -///   - `x.intersect([]) == []`<br>&gt;&gt; -///   - `x.union(x) == x`<br>&gt;&gt; -///   - `x.union([]) == x`<br>&gt;&gt; +///   - `x.intersection(with: x) == x`<br>&gt;&gt; +///   - `x.intersection(with: []) == []`<br>&gt;&gt; +///   - `x.unioning(with: x) == x`<br>&gt;&gt; +///   - `x.unioning(with: []) == x`<br>&gt;&gt; <br>&gt;&gt; What&#39;s with the (with:)? That seems like a pretty needless word. Same with &#39;of:&#39; and friends.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>MHO: +1 on the intention of using less unwieldy names, but -1 on the<br>specific solution. I fear that the current solution has some inexplicable<br>inconsistencies and some Englishing which verges, again MHO, on<br>Hungarianisms that others have mentioned are to be explicitly avoided.<br></p><p>For example, why is it intersection() but unioning()? Surely it should be<br>either intersecting() and unioning() or intersection() and union()? Also, I<br>understand that there&#39;s precedent elsewhere and that uniting() is not a<br>good counterpart to union(), but unioning() is a pretty unsavory mangling<br>of the noun. And then we have exclusiveOring(), which is just not English.<br></p><p>Could I propose an alternative that just came to mind? Reading about set<br>algebra methods called to mind math class way back when. We&#39;d say things<br>like &quot;take the derivative,&quot; &quot;take the union,&quot; etc., which seems to me to<br>imply an operation that is not in-place. &quot;Take&quot; is almost as short as<br>&quot;-ion&quot; and &quot;-ing&quot; and might be more universally usable without mangling<br>words: takeUnion(), takeExclusiveOr(), etc. It also has the advantage of<br>calling to mind &quot;make&quot;, which implies something constructor-like and thus<br>not in-place.<br>On Thu, Feb 11, 2016 at 11:38 AM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Hi All,<br>&gt;<br>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br>&gt;<br>&gt; Comments welcome as usual,<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/eb9a7341/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 12, 2016 at 01:00:00am</p></header><div class="content"><p>All algebraic terms actually infer not in place.  I don’t know of any algebra functions that mutates in place (at least not on the chalk board).  <br></p><p>I would actually prefer algebraic terms such as union and intersection be reserved for immutable only.  <br></p><p>union is the state of being united (i.e. past-tense).  <br></p><p>Is unioning even a word?<br></p><p><br>&gt; On 2016-02-12, at 1:09:43, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MHO: +1 on the intention of using less unwieldy names, but -1 on the specific solution. I fear that the current solution has some inexplicable inconsistencies and some Englishing which verges, again MHO, on Hungarianisms that others have mentioned are to be explicitly avoided.<br>&gt; <br>&gt; For example, why is it intersection() but unioning()? Surely it should be either intersecting() and unioning() or intersection() and union()? Also, I understand that there&#39;s precedent elsewhere and that uniting() is not a good counterpart to union(), but unioning() is a pretty unsavory mangling of the noun. And then we have exclusiveOring(), which is just not English.<br>&gt; <br>&gt; Could I propose an alternative that just came to mind? Reading about set algebra methods called to mind math class way back when. We&#39;d say things like &quot;take the derivative,&quot; &quot;take the union,&quot; etc., which seems to me to imply an operation that is not in-place. &quot;Take&quot; is almost as short as &quot;-ion&quot; and &quot;-ing&quot; and might be more universally usable without mangling words: takeUnion(), takeExclusiveOr(), etc. It also has the advantage of calling to mind &quot;make&quot;, which implies something constructor-like and thus not in-place.<br>&gt; On Thu, Feb 11, 2016 at 11:38 AM Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5 &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt;&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br>&gt; <br>&gt; Comments welcome as usual,<br>&gt; <br>&gt; --<br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/46f10e24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4030f7e8f6b6d3c09d10ec12691773c1?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>John Randolph</string> &lt;jcr at mac.com&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 10:48 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is unioning even a word?<br></p><p>Nope.  The verb is “unite”.<br></p><p>-jcr<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/32c6098a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; Is unioning even a word?<br>&gt; <br>&gt; Nope.  The verb is “unite”.<br></p><p>If we don&#39;t like &quot;unite&quot;, alternatives include &quot;unify&quot; and even &quot;unionize&quot;.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 13, 2016 at 08:00:00am</p></header><div class="content"><p>I would not mind unify.<br></p><p>:-)<br></p><p><br>&gt; On Feb 11, 2016, at 8:20 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Is unioning even a word?<br>&gt;&gt; <br>&gt;&gt; Nope.  The verb is “unite”.<br>&gt; <br>&gt; If we don&#39;t like &quot;unite&quot;, alternatives include &quot;unify&quot; and even &quot;unionize&quot;.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/df65d69ec35e73390ddd0e6a2c335737?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>James Hillhouse IV</string> &lt;jimhillhouse at me.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Are these function names being based on the present participle of each verb, e.g. &#39;union&#39; and &#39;intersect&#39;? <br></p><p>The present participle of &#39;union&#39; is technically speaking, &#39;unioning&#39;. But it is not widely used. In fact, in both Pages and Word, &#39;unioning&#39; is flagged as a misspelling of &#39;union&#39;.<br></p><p>The present participle of &#39;intersect&#39; is &#39;intersecting&#39;; &#39;intersection&#39; is a noun. <br></p><p>As currently presented, the use of &#39;union&#39; and &#39;intersection&#39; are a mixing of rarely used though correct present participle verb tense and a noun. I think it would be better to recognize that &#39;union&#39; and &#39;intersection&#39; are two universally used mathematical terms and to forego the suggested verb tense gymnastics. <br></p><p>Jim<br></p><p>jimhillhouse at me.com<br>512-484-9489<br></p><p>Sent from Jim&#39;s iPhone<br></p><p><br>&gt; On Feb 11, 2016, at 12:09 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MHO: +1 on the intention of using less unwieldy names, but -1 on the specific solution. I fear that the current solution has some inexplicable inconsistencies and some Englishing which verges, again MHO, on Hungarianisms that others have mentioned are to be explicitly avoided.<br>&gt; <br>&gt; For example, why is it intersection() but unioning()? Surely it should be either intersecting() and unioning() or intersection() and union()? Also, I understand that there&#39;s precedent elsewhere and that uniting() is not a good counterpart to union(), but unioning() is a pretty unsavory mangling of the noun. And then we have exclusiveOring(), which is just not English.<br>&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 11:38 AM Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi All,<br>&gt;&gt; <br>&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt; under development.<br>&gt;&gt; <br>&gt;&gt; Comments welcome as usual,<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/17307ce0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Feb 11, 2016 at 12:54 PM, Jim Hillhouse via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The present participle of &#39;union&#39; is technically speaking, &#39;unioning&#39;. But<br>&gt; it is not widely used. In fact, in both Pages and Word, &#39;unioning&#39; is<br>&gt; flagged as a misspelling of &#39;union&#39;.<br>&gt;<br></p><p>Outside of programming, &quot;union&quot; is a noun, not a verb, and &quot;unite&quot; is<br>already a perfectly good verb that means &quot;create the union of&quot;.  So why not<br></p><p>    func union(with other: Self) -&gt; Self<br>    func unite(with other: Self)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/103b2435/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>February 12, 2016 at 08:00:00am</p></header><div class="content"><p>On Thu, Feb 11, 2016 at 4:27 PM, Rob Mayoff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Feb 11, 2016 at 12:54 PM, Jim Hillhouse via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; The present participle of &#39;union&#39; is technically speaking, &#39;unioning&#39;.<br>&gt;&gt; But it is not widely used. In fact, in both Pages and Word, &#39;unioning&#39; is<br>&gt;&gt; flagged as a misspelling of &#39;union&#39;.<br>&gt;&gt;<br>&gt;<br>&gt; Outside of programming, &quot;union&quot; is a noun, not a verb, and &quot;unite&quot; is<br>&gt; already a perfectly good verb that means &quot;create the union of&quot;.  So why not<br>&gt;<br>&gt;     func union(with other: Self) -&gt; Self<br>&gt;     func unite(with other: Self)<br>&gt;<br>&gt;<br>My biggest problem with this diff is the different treatment of &quot;union&quot; and<br>&quot;intersection&quot;... it is confusing that one is mutating and the other is<br>non-mutating. They are both the same part of speech and both the term of<br>art, so they should both have the same mutability implications.<br></p><p>I&#39;d vote either of the following (leaning toward the first group because I<br>think the term of art implies non-mutating):<br></p><p>func union(other: Self) -&gt; Self<br>func unite(other: Self)<br>func intersection(other: Self) -&gt; Self<br>func intersect(other: Self)<br></p><p>func uniting(other: Self) -&gt; Self<br>func union(other: Self)<br>func intersecting(other: Self) -&gt; Self<br>func intersection(other: Self)<br></p><p>unite and uniting are still reasonably close to union (exactly the same for<br>the first 3 characters which should help with autocomplete discoverability).<br></p><p><br></p><p>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/8836caf2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 12, 2016 at 02:00:00pm</p></header><div class="content"><p>I would like to warn agains attempts to use ‘grammar’ as justification for API design. The problem is that language is not just about following some particular rules of grammar. Language is all about convention, and grammar is essentially an optimisation technique that allows us to use convention more efficiently. Still, grammar is only one of the tools we have when communicating — the actual rules of language use are much more complicated. I am not sure  that every mathematician will immediately understand what you mean by ‘uniting two sets’ — because nobody uses that particular terminology. Now, ‘creating a union of two sets’ is a perfectly clear concept. Its not the grammatical form that conveys the meaning but what we conventionally associate with that particular form in that particular context. Union, intersection etc. are conventionally non-mutating concepts. All proposals for mutating concepts I have seen so far are not semantically transparent, because they do not follow the commonly accepted convention. The most appropriate names for those APIs I can come put with is something like<br></p><p>func replaceWithUnion(with: Self)<br>func replaceWithIntersection(with: Self)<br></p><p>or maybe<br></p><p>func unionUpdate(with: Self)<br>func intersectionUpdate(with: Self)<br></p><p>e.g. names that actually communicate what is going on. <br></p><p>— Taras<br></p><p>&gt; On 12 Feb 2016, at 14:23, Matthew Judge via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Thu, Feb 11, 2016 at 4:27 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Thu, Feb 11, 2016 at 12:54 PM, Jim Hillhouse via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The present participle of &#39;union&#39; is technically speaking, &#39;unioning&#39;. But it is not widely used. In fact, in both Pages and Word, &#39;unioning&#39; is flagged as a misspelling of &#39;union&#39;.<br>&gt; <br>&gt; Outside of programming, &quot;union&quot; is a noun, not a verb, and &quot;unite&quot; is already a perfectly good verb that means &quot;create the union of&quot;.  So why not<br>&gt; <br>&gt;     func union(with other: Self) -&gt; Self<br>&gt;     func unite(with other: Self)<br>&gt; <br>&gt;  <br>&gt; My biggest problem with this diff is the different treatment of &quot;union&quot; and &quot;intersection&quot;... it is confusing that one is mutating and the other is non-mutating. They are both the same part of speech and both the term of art, so they should both have the same mutability implications.<br>&gt; <br>&gt; I&#39;d vote either of the following (leaning toward the first group because I think the term of art implies non-mutating):<br>&gt; <br>&gt; func union(other: Self) -&gt; Self<br>&gt; func unite(other: Self)<br>&gt; func intersection(other: Self) -&gt; Self<br>&gt; func intersect(other: Self)<br>&gt; <br>&gt; func uniting(other: Self) -&gt; Self<br>&gt; func union(other: Self)<br>&gt; func intersecting(other: Self) -&gt; Self<br>&gt; func intersection(other: Self)<br>&gt; <br>&gt; unite and uniting are still reasonably close to union (exactly the same for the first 3 characters which should help with autocomplete discoverability).<br>&gt; <br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/d57017e3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 13, 2016 at 12:00:00am</p></header><div class="content"><p>I agree!<br></p><p><br>&gt; On Feb 11, 2016, at 4:27 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Feb 11, 2016 at 12:54 PM, Jim Hillhouse via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The present participle of &#39;union&#39; is technically speaking, &#39;unioning&#39;. But it is not widely used. In fact, in both Pages and Word, &#39;unioning&#39; is flagged as a misspelling of &#39;union&#39;.<br>&gt; <br>&gt; Outside of programming, &quot;union&quot; is a noun, not a verb, and &quot;unite&quot; is already a perfectly good verb that means &quot;create the union of&quot;.  So why not<br>&gt; <br>&gt;     func union(with other: Self) -&gt; Self<br>&gt;     func unite(with other: Self)<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/0cd427b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/df65d69ec35e73390ddd0e6a2c335737?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>James Hillhouse IV</string> &lt;jimhillhouse at me.com&gt;<p>February 13, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 10:28 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; ALTERNATIVE 1<br>&gt; <br>&gt; Non-mutable (noun-based)<br>&gt; <br>&gt; -  func union(other: Self) -&gt; Self<br>&gt; +  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br>&gt; …<br>&gt; <br>&gt; Mutable (verb-based)<br>&gt; <br>&gt; -  mutating func unionInPlace(other: Self)<br>&gt; +  mutating func unite(other: Self)<br>&gt; …<br></p><p>+1 for ALTERNATIVE 1.<br></p><p>Although &#39;union&#39; is both a noun and a verb*, because &#39;unite&#39; is more commonly used today when unioning things, I&#39;m in favor of using it. ‘union/unite’ just flows better for me than ‘union/add’, but that’s just me.<br></p><p><br></p><p>*The OED entry for the verb ‘union’, <br></p><p>http://www.oed.com/view/Entry/214680?redirectedFrom=Unioning#eid &lt;http://www.oed.com/view/Entry/214680?redirectedFrom=Unioning#eid&gt;<br> <br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/08221f07/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>My expectations is that the standard operators act upon a set, changing the set. <br></p><p>set1.union(with: set2) tells set1 to perform the union. <br>set1.unioned(with: set2) creates a new instance where set1 has been unioned with set 2.<br></p><p>Naming: intersected, unioned, and exclusiveOred over intersecting, unioning, exclusiveOring. <br>Mutating: union, intersection, exclusiveOr. <br>Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br></p><p>Reasoning:<br></p><p>* I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>* I think you have the nature of the words mis-assigned. In my opinion in this rare case, union, intersection, and exclusiveOr act as verbs as they are mathematical set operations. For example, &quot;what is the result of A union B?&quot; is a reasonable thing to say to a math person or put on an exam question, etc. <br></p><p>Importantly, they produce significant side effects, and should be treated as verbs that operate upon the receiver, updating the receiver, establishing their use for mutating ops.<br></p><p>Dave wrote:<br>&gt;&gt;&gt; - use nouns for methods with no side effects (or only incidental ones,  like logging)<br>&gt;&gt;&gt; - use verbs for methods with significant side-effects<br></p><p><br>-- E<br></p><p>&gt; On Feb 11, 2016, at 9:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br>&gt; <br>&gt; Comments welcome as usual,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/62938e63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; *Non-Mutating, returning new value*: unioned(with), intersected(with),<br>&gt; exclusiveOred(with)<br>&gt;<br>&gt; Reasoning:<br>&gt;<br>&gt; * *I think the -ing endings sound unnatural, stilted, and unmathematical.<br>&gt; *They make me wince.<br>&gt;<br></p><p>So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient<br>suffix.<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/6e678a1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 2:19 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt; <br>&gt; Reasoning:<br>&gt; <br>&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt; <br>&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br></p><p>“exclusiveOr” is pretty awkward too.  I would tend to call this either “xor” or “symmetricDifference”.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/7d0c313d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>xor is a well known and widely used synonym. &quot;symmetricDifference&quot; not so much. <br></p><p>-- E<br></p><p><br>&gt; On Feb 11, 2016, at 12:22 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 2:19 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt; <br>&gt;&gt; Reasoning:<br>&gt;&gt; <br>&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt; <br>&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt; <br>&gt; “exclusiveOr” is pretty awkward too.  I would tend to call this either “xor” or “symmetricDifference”.<br>&gt; <br>&gt; – Steve<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/cf108793/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&#39;Symmetric difference&#39; sounds weird to me too, but per Wikipedia, the<br>counterpart name to &#39;union&#39; and &#39;intersection&#39; for the result of a XOR<br>operation on a set would in fact be the &#39;symmetric difference,&#39; with<br>apparently no alternative or more commonly used name:<br></p><p>&gt; * Union of the sets A and B, denoted A ∪ B, is the set of all objects that are a member of A, or B, or both. The union of {1, 2, 3} and {2, 3, 4} is the set {1, 2, 3, 4} .<br>&gt; * Intersection of the sets A and B, denoted A ∩ B, is the set of all objects that are members of both A and B. The intersection of {1, 2, 3} and {2, 3, 4} is the set {2, 3} .<br>...<br>&gt; * Symmetric difference of sets A and B, denoted A △ B or A ⊖ B, is the set of all objects that are a member of exactly one of A and B (elements which are in one of the sets, but not in both). For instance, for the sets {1,2,3} and {2,3,4} , the symmetric difference set is {1,4} . It is the set difference of the union and the intersection, (A ∪ B) \ (A ∩ B) or (A \ B) ∪ (B \ A).<br></p><p><br>On Thu, Feb 11, 2016 at 1:26 PM, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; xor is a well known and widely used synonym. &quot;symmetricDifference&quot; not so<br>&gt; much.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Feb 11, 2016, at 12:22 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Feb 11, 2016, at 2:19 PM, Jacob Bandes-Storch via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with),<br>&gt;&gt; exclusiveOred(with)<br>&gt;&gt;<br>&gt;&gt; Reasoning:<br>&gt;&gt;<br>&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical.<br>&gt;&gt; They make me wince.<br>&gt;<br>&gt;<br>&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient<br>&gt; suffix.<br>&gt;<br>&gt;<br>&gt; “exclusiveOr” is pretty awkward too.  I would tend to call this either “xor”<br>&gt; or “symmetricDifference”.<br>&gt;<br>&gt; – Steve<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>Yes, “symmetric difference” is the common name for this operation in Mathematics.<br>– Steve<br></p><p>&gt; On Feb 11, 2016, at 2:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; &#39;Symmetric difference&#39; sounds weird to me too, but per Wikipedia, the<br>&gt; counterpart name to &#39;union&#39; and &#39;intersection&#39; for the result of a XOR<br>&gt; operation on a set would in fact be the &#39;symmetric difference,&#39; with<br>&gt; apparently no alternative or more commonly used name:<br>&gt; <br>&gt;&gt; * Union of the sets A and B, denoted A ∪ B, is the set of all objects that are a member of A, or B, or both. The union of {1, 2, 3} and {2, 3, 4} is the set {1, 2, 3, 4} .<br>&gt;&gt; * Intersection of the sets A and B, denoted A ∩ B, is the set of all objects that are members of both A and B. The intersection of {1, 2, 3} and {2, 3, 4} is the set {2, 3} .<br>&gt; ...<br>&gt;&gt; * Symmetric difference of sets A and B, denoted A △ B or A ⊖ B, is the set of all objects that are a member of exactly one of A and B (elements which are in one of the sets, but not in both). For instance, for the sets {1,2,3} and {2,3,4} , the symmetric difference set is {1,4} . It is the set difference of the union and the intersection, (A ∪ B) \ (A ∩ B) or (A \ B) ∪ (B \ A).<br>&gt; <br>&gt; <br>&gt; On Thu, Feb 11, 2016 at 1:26 PM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; xor is a well known and widely used synonym. &quot;symmetricDifference&quot; not so<br>&gt;&gt; much.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 11, 2016, at 12:22 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 11, 2016, at 2:19 PM, Jacob Bandes-Storch via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with),<br>&gt;&gt;&gt; exclusiveOred(with)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical.<br>&gt;&gt;&gt; They make me wince.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient<br>&gt;&gt; suffix.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; “exclusiveOr” is pretty awkward too.  I would tend to call this either “xor”<br>&gt;&gt; or “symmetricDifference”.<br>&gt;&gt; <br>&gt;&gt; – Steve<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I agree strongly with Craig that algebraic terms all strongly imply<br>that the operation is not in-place. Reductio ad absurdum: I don&#39;t<br>think very many people could stomach sin(x) being mutating.<br></p><p><br>On Thu, Feb 11, 2016 at 1:19 PM, Jacob Bandes-Storch via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with),<br>&gt;&gt; exclusiveOred(with)<br>&gt;&gt;<br>&gt;&gt; Reasoning:<br>&gt;&gt;<br>&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical.<br>&gt;&gt; They make me wince.<br>&gt;<br>&gt;<br>&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient<br>&gt; suffix.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I see the -ed versions as short for -edSet, with the Set being implied. Under this reasoning, unioned == unionedSet, intersected == intersectedSet, thus acting as nouns not verbs, and used for non-mutating application.<br></p><p>inPlace is only for mutating application. I mildly prefer the shorter union to unionInPlace, although I could argue both sides. (The latter is clearer but longer, the former is the short verb action that the whole guideline thing is supposed to endorse.)<br></p><p>-- E<br></p><p>&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt; <br>&gt; Reasoning:<br>&gt; <br>&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt; <br>&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt; <br>&gt; Jacob<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/e4103f31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>&quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and &quot;ored&quot; is not<br>something I&#39;d want in the standard library. Neither is &quot;oring&quot;.<br></p><p>On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; I see the -ed versions as short for -edSet, with the Set being implied.<br>&gt; Under this reasoning, unioned == unionedSet, intersected == intersectedSet,<br>&gt; thus acting as nouns not verbs, and used for non-mutating application.<br>&gt;<br>&gt; inPlace is only for mutating application. I mildly prefer the shorter<br>&gt; union to unionInPlace, although I could argue both sides. (The latter is<br>&gt; clearer but longer, the former is the short verb action that the whole<br>&gt; guideline thing is supposed to endorse.)<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; *Non-Mutating, returning new value*: unioned(with), intersected(with),<br>&gt;&gt; exclusiveOred(with)<br>&gt;&gt;<br>&gt;&gt; Reasoning:<br>&gt;&gt;<br>&gt;&gt; * *I think the -ing endings sound unnatural, stilted, and<br>&gt;&gt; unmathematical. *They make me wince.<br>&gt;&gt;<br>&gt;<br>&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient<br>&gt; suffix.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/f92464b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Assuming one would want to avoid the -ed suffix (and also -ing), one might consider:<br></p><p>* intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>* setIntersection(), setOr(), setUnion(),<br>* intersectionResult(), orResult(), unionResult(),<br>etc<br></p><p>-- E<br></p><p><br>&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and &quot;ored&quot; is not something I&#39;d want in the standard library. Neither is &quot;oring&quot;.<br>&gt; <br>&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; I see the -ed versions as short for -edSet, with the Set being implied. Under this reasoning, unioned == unionedSet, intersected == intersectedSet, thus acting as nouns not verbs, and used for non-mutating application.<br>&gt; <br>&gt; inPlace is only for mutating application. I mildly prefer the shorter union to unionInPlace, although I could argue both sides. (The latter is clearer but longer, the former is the short verb action that the whole guideline thing is supposed to endorse.)<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt; <br>&gt;&gt; Reasoning:<br>&gt;&gt; <br>&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt; <br>&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/8fc36d5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>Just thinking out loud here:<br></p><p>&quot;x&#39;s intersection with y&quot; makes sense. So &quot;x.intersection(with: y)&quot; makes<br>sense.  That&#39;s already in Dave&#39;s diff.<br></p><p>Unfortunately the same doesn&#39;t work well for &quot;x&#39;s union with y&quot; — should<br>&quot;x.union(with: y)&quot; be a mutating or nonmutating operation? Hard to tell.<br></p><p>How about we just move to ∪ and ∪= operators and call it a day? :-)<br></p><p>On Thu, Feb 11, 2016 at 11:36 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might<br>&gt; consider:<br>&gt;<br>&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt; * setIntersection(), setOr(), setUnion(),<br>&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt; etc<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and &quot;ored&quot; is<br>&gt; not something I&#39;d want in the standard library. Neither is &quot;oring&quot;.<br>&gt;<br>&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I see the -ed versions as short for -edSet, with the Set being implied.<br>&gt;&gt; Under this reasoning, unioned == unionedSet, intersected == intersectedSet,<br>&gt;&gt; thus acting as nouns not verbs, and used for non-mutating application.<br>&gt;&gt;<br>&gt;&gt; inPlace is only for mutating application. I mildly prefer the shorter<br>&gt;&gt; union to unionInPlace, although I could argue both sides. (The latter is<br>&gt;&gt; clearer but longer, the former is the short verb action that the whole<br>&gt;&gt; guideline thing is supposed to endorse.)<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Non-Mutating, returning new value*: unioned(with), intersected(with),<br>&gt;&gt;&gt; exclusiveOred(with)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * *I think the -ing endings sound unnatural, stilted, and<br>&gt;&gt;&gt; unmathematical. *They make me wince.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient<br>&gt;&gt; suffix.<br>&gt;&gt;<br>&gt;&gt; Jacob<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/0eadadc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m good with that.<br></p><p>+1<br></p><p>-- E<br></p><p>&gt; On Feb 11, 2016, at 12:43 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just thinking out loud here:<br>&gt; <br>&gt; &quot;x&#39;s intersection with y&quot; makes sense. So &quot;x.intersection(with: y)&quot; makes sense.  That&#39;s already in Dave&#39;s diff.<br>&gt; <br>&gt; Unfortunately the same doesn&#39;t work well for &quot;x&#39;s union with y&quot; — should &quot;x.union(with: y)&quot; be a mutating or nonmutating operation? Hard to tell.<br>&gt; <br>&gt; How about we just move to ∪ and ∪= operators and call it a day? :-)<br>&gt; <br>&gt; On Thu, Feb 11, 2016 at 11:36 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might consider:<br>&gt; <br>&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt; * setIntersection(), setOr(), setUnion(),<br>&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt; etc<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and &quot;ored&quot; is not something I&#39;d want in the standard library. Neither is &quot;oring&quot;.<br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; I see the -ed versions as short for -edSet, with the Set being implied. Under this reasoning, unioned == unionedSet, intersected == intersectedSet, thus acting as nouns not verbs, and used for non-mutating application.<br>&gt;&gt; <br>&gt;&gt; inPlace is only for mutating application. I mildly prefer the shorter union to unionInPlace, although I could argue both sides. (The latter is clearer but longer, the former is the short verb action that the whole guideline thing is supposed to endorse.)<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/6817813a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>Going with only operators wouldn&#39;t be the worst idea :) I do like<br>Thorsten&#39;s suggestion, though, and would propose to extend to XOR<br>with:<br></p><p>mutating: symmetricSubtract() or xor()<br>non-mutating: symmetricDifference()<br></p><p><br>On Thu, Feb 11, 2016 at 1:46 PM, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I&#39;m good with that.<br>&gt;<br>&gt; +1<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; On Feb 11, 2016, at 12:43 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Just thinking out loud here:<br>&gt;<br>&gt; &quot;x&#39;s intersection with y&quot; makes sense. So &quot;x.intersection(with: y)&quot; makes<br>&gt; sense.  That&#39;s already in Dave&#39;s diff.<br>&gt;<br>&gt; Unfortunately the same doesn&#39;t work well for &quot;x&#39;s union with y&quot; — should<br>&gt; &quot;x.union(with: y)&quot; be a mutating or nonmutating operation? Hard to tell.<br>&gt;<br>&gt; How about we just move to ∪ and ∪= operators and call it a day? :-)<br>&gt;<br>&gt; On Thu, Feb 11, 2016 at 11:36 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might<br>&gt;&gt; consider:<br>&gt;&gt;<br>&gt;&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt;&gt; * setIntersection(), setOr(), setUnion(),<br>&gt;&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt;&gt; etc<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and &quot;ored&quot; is<br>&gt;&gt; not something I&#39;d want in the standard library. Neither is &quot;oring&quot;.<br>&gt;&gt;<br>&gt;&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I see the -ed versions as short for -edSet, with the Set being implied.<br>&gt;&gt;&gt; Under this reasoning, unioned == unionedSet, intersected == intersectedSet,<br>&gt;&gt;&gt; thus acting as nouns not verbs, and used for non-mutating application.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; inPlace is only for mutating application. I mildly prefer the shorter<br>&gt;&gt;&gt; union to unionInPlace, although I could argue both sides. (The latter is<br>&gt;&gt;&gt; clearer but longer, the former is the short verb action that the whole<br>&gt;&gt;&gt; guideline thing is supposed to endorse.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with),<br>&gt;&gt;&gt;&gt; exclusiveOred(with)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical.<br>&gt;&gt;&gt;&gt; They make me wince.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient<br>&gt;&gt;&gt; suffix.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>Here are some thoughts after having quietly pondered the mutating method naming discussion for a while.<br></p><p>My view is that an &quot;ed/ing&quot; mutation rule is fraught with undesirable compromises. It&#39;s tempting because it works so well in the majority of cases, but it seems that cases where it doesn&#39;t work are not uncommon, even when the scope of the discussion is narrowed to a small set of operations such as this. We&#39;re trying to play nice with English, but we&#39;re butting up against its fundamental lack of clarity.<br></p><p>As far as I see it, these are the options (forgive me for repeating much of what others have said -- I&#39;d like to accurately convey my perception of the situation as a whole):<br></p><p>1. Move forward with ed/ing-based guidelines that work well in many cases. For the cases which don&#39;t work well, we can either:<br></p><p>Have explicit exceptions, likely leading to overly-complicated guidelines that people may not be bothered to follow.<br>Leave it up to the developer to decide what&#39;s best on a case-by-case basis, likely leading to inconsistencies and lots of time spent on discussions of this magnitude.<br></p><p>There&#39;s also a worrying amount of uncertainty and subjectivity involved in identifying the situations where the base guidelines don&#39;t work well, particularly for developers who aren&#39;t experts in English.<br></p><p>2. Use &quot;inPlace&quot; or some other simple adornment that can be universally applied to a method without exceptions.<br></p><p>An inPlace suffix would be a significant eyesore for such a common pattern. There doesn&#39;t seem to be another less obtrusive suffix that properly conveys mutation, so we&#39;re either stuck with inPlace, or we could try to find a more terse symbolic pattern (the same idea as Ruby&#39;s postfix ! to indicate mutation). Nothing desirable comes to mind, though.<br></p><p>3. Add a language-level feature that allows a method on a type which returns a value of that same type to be called in a way that mutates the callee.<br></p><p>Even when naming isn&#39;t an issue, defining mutating / non-mutating versions of method is somewhat tedious and inflates the type&#39;s interface. Any method that returns a value of the callee&#39;s type is a valid candidate for a mutating version of that API, but defining the mutating version is 100% boilerplate.<br></p><p>Support from the compiler would eliminate this boilerplate as well as this seemingly-unsolvable naming problem at the cost of some additional complexity in the compiler.<br></p><p>I can see two options off the top of my head. First, a method that returns the same type as the callee mutates when its return value is unused instead of producing a warning:<br></p><p>let c = a.union(with: b) // Doesn&#39;t mutate.<br>a.union(with: b)         // Mutates.<br></p><p>This is somewhat subtle and has some potential for confusion, but I think Swift&#39;s strong immutability features would make it extremely rare for this pattern to create bugs.<br></p><p>Or, we can create a special syntax for mutating a callee with the return value of its method:<br></p><p>a .= union(with: b) // First thing that comes to mind. It&#39;s conceptually similar to += and friends and makes assignment explicit.<br>a = .union(with: b) // Similar idea, looks less like you&#39;re calling a global method called union.<br></p><p>My personal preference lies strongly in option 3 with roughly equal preference for either sub-option, but I&#39;d really like to hear what others think.<br></p><p>Jarod<br></p><p>&gt; On Feb 11, 2016, at 11:43, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just thinking out loud here:<br>&gt; <br>&gt; &quot;x&#39;s intersection with y&quot; makes sense. So &quot;x.intersection(with: y)&quot; makes sense.  That&#39;s already in Dave&#39;s diff.<br>&gt; <br>&gt; Unfortunately the same doesn&#39;t work well for &quot;x&#39;s union with y&quot; — should &quot;x.union(with: y)&quot; be a mutating or nonmutating operation? Hard to tell.<br>&gt; <br>&gt; How about we just move to ∪ and ∪= operators and call it a day? :-)<br>&gt; <br>&gt; On Thu, Feb 11, 2016 at 11:36 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might consider:<br>&gt; <br>&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt; * setIntersection(), setOr(), setUnion(),<br>&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt; etc<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and &quot;ored&quot; is not something I&#39;d want in the standard library. Neither is &quot;oring&quot;.<br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; I see the -ed versions as short for -edSet, with the Set being implied. Under this reasoning, unioned == unionedSet, intersected == intersectedSet, thus acting as nouns not verbs, and used for non-mutating application.<br>&gt;&gt; <br>&gt;&gt; inPlace is only for mutating application. I mildly prefer the shorter union to unionInPlace, although I could argue both sides. (The latter is clearer but longer, the former is the short verb action that the whole guideline thing is supposed to endorse.)<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/16ebb308/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 11, 2016 at 11:00:00pm</p></header><div class="content"><p>FYI this (2/3) has already been sketched out: https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;<br></p><p>My understanding is that this will be considered in the future, and the naming discussion is something important for now (i.e Swift 2.x-3.x era)<br></p><p>— Radek<br></p><p>&gt; On 11 Feb 2016, at 23:13, Jarod Long via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here are some thoughts after having quietly pondered the mutating method naming discussion for a while.<br>&gt; <br>&gt; My view is that an &quot;ed/ing&quot; mutation rule is fraught with undesirable compromises. It&#39;s tempting because it works so well in the majority of cases, but it seems that cases where it doesn&#39;t work are not uncommon, even when the scope of the discussion is narrowed to a small set of operations such as this. We&#39;re trying to play nice with English, but we&#39;re butting up against its fundamental lack of clarity.<br>&gt; <br>&gt; As far as I see it, these are the options (forgive me for repeating much of what others have said -- I&#39;d like to accurately convey my perception of the situation as a whole):<br>&gt; <br>&gt; 1. Move forward with ed/ing-based guidelines that work well in many cases. For the cases which don&#39;t work well, we can either:<br>&gt; <br>&gt; Have explicit exceptions, likely leading to overly-complicated guidelines that people may not be bothered to follow.<br>&gt; Leave it up to the developer to decide what&#39;s best on a case-by-case basis, likely leading to inconsistencies and lots of time spent on discussions of this magnitude.<br>&gt; <br>&gt; There&#39;s also a worrying amount of uncertainty and subjectivity involved in identifying the situations where the base guidelines don&#39;t work well, particularly for developers who aren&#39;t experts in English.<br>&gt; <br>&gt; 2. Use &quot;inPlace&quot; or some other simple adornment that can be universally applied to a method without exceptions.<br>&gt; <br>&gt; An inPlace suffix would be a significant eyesore for such a common pattern. There doesn&#39;t seem to be another less obtrusive suffix that properly conveys mutation, so we&#39;re either stuck with inPlace, or we could try to find a more terse symbolic pattern (the same idea as Ruby&#39;s postfix ! to indicate mutation). Nothing desirable comes to mind, though.<br>&gt; <br>&gt; 3. Add a language-level feature that allows a method on a type which returns a value of that same type to be called in a way that mutates the callee.<br>&gt; <br>&gt; Even when naming isn&#39;t an issue, defining mutating / non-mutating versions of method is somewhat tedious and inflates the type&#39;s interface. Any method that returns a value of the callee&#39;s type is a valid candidate for a mutating version of that API, but defining the mutating version is 100% boilerplate.<br>&gt; <br>&gt; Support from the compiler would eliminate this boilerplate as well as this seemingly-unsolvable naming problem at the cost of some additional complexity in the compiler.<br>&gt; <br>&gt; I can see two options off the top of my head. First, a method that returns the same type as the callee mutates when its return value is unused instead of producing a warning:<br>&gt; <br>&gt; let c = a.union(with: b) // Doesn&#39;t mutate.<br>&gt; a.union(with: b)         // Mutates.<br>&gt; <br>&gt; This is somewhat subtle and has some potential for confusion, but I think Swift&#39;s strong immutability features would make it extremely rare for this pattern to create bugs.<br>&gt; <br>&gt; Or, we can create a special syntax for mutating a callee with the return value of its method:<br>&gt; <br>&gt; a .= union(with: b) // First thing that comes to mind. It&#39;s conceptually similar to += and friends and makes assignment explicit.<br>&gt; a = .union(with: b) // Similar idea, looks less like you&#39;re calling a global method called union.<br>&gt; <br>&gt; My personal preference lies strongly in option 3 with roughly equal preference for either sub-option, but I&#39;d really like to hear what others think.<br>&gt; <br>&gt; Jarod<br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 11:43, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just thinking out loud here:<br>&gt;&gt; <br>&gt;&gt; &quot;x&#39;s intersection with y&quot; makes sense. So &quot;x.intersection(with: y)&quot; makes sense.  That&#39;s already in Dave&#39;s diff.<br>&gt;&gt; <br>&gt;&gt; Unfortunately the same doesn&#39;t work well for &quot;x&#39;s union with y&quot; — should &quot;x.union(with: y)&quot; be a mutating or nonmutating operation? Hard to tell.<br>&gt;&gt; <br>&gt;&gt; How about we just move to ∪ and ∪= operators and call it a day? :-)<br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 11:36 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might consider:<br>&gt;&gt; <br>&gt;&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt;&gt; * setIntersection(), setOr(), setUnion(),<br>&gt;&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt;&gt; etc<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and &quot;ored&quot; is not something I&#39;d want in the standard library. Neither is &quot;oring&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I see the -ed versions as short for -edSet, with the Set being implied. Under this reasoning, unioned == unionedSet, intersected == intersectedSet, thus acting as nouns not verbs, and used for non-mutating application.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; inPlace is only for mutating application. I mildly prefer the shorter union to unionInPlace, although I could argue both sides. (The latter is clearer but longer, the former is the short verb action that the whole guideline thing is supposed to endorse.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/1f2c1630/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>on Thu Feb 11 2016, Jarod Long &lt;swift-AT-lng.la&gt; wrote:<br></p><p>&gt; Here are some thoughts after having quietly pondered the mutating method naming discussion for a while.<br>&gt;<br>&gt; My view is that an &quot;ed/ing&quot; mutation rule is fraught with undesirable<br>&gt; compromises. It&#39;s tempting because it works so well in the majority of<br>&gt; cases, but it seems that cases where it doesn&#39;t work are not uncommon,<br>&gt; even when the scope of the discussion is narrowed to a small set of<br>&gt; operations such as this. We&#39;re trying to play nice with English, but<br>&gt; we&#39;re butting up against its fundamental lack of clarity.<br>&gt;<br>&gt; As far as I see it, these are the options (forgive me for repeating<br>&gt; much of what others have said -- I&#39;d like to accurately convey my<br>&gt; perception of the situation as a whole):<br>&gt;<br>&gt; 1. Move forward with ed/ing-based guidelines that work well in many<br>&gt; cases. For the cases which don&#39;t work well, we can either:<br>&gt;<br>&gt; Have explicit exceptions, likely leading to overly-complicated guidelines that people may not be bothered to follow.<br>&gt; Leave it up to the developer to decide what&#39;s best on a case-by-case<br>&gt; basis, likely leading to inconsistencies and lots of time spent on<br>&gt; discussions of this magnitude.<br>&gt;<br>&gt; There&#39;s also a worrying amount of uncertainty and subjectivity<br>&gt; involved in identifying the situations where the base guidelines don&#39;t<br>&gt; work well, particularly for developers who aren&#39;t experts in English.<br></p><p>It looks like we are poised to:<br></p><p>* Force Set into the mold by “verbing” nouns as noted in the beginning<br>  of the thread, because it&#39;s a prominent type and it should follow the<br>  main guideline.<br></p><p>* “Punt” on the more general question of what to do about other cases<br>  that don&#39;t fit well.  That is, we&#39;ll make a decision later.  In the<br>  meantime it would be great if the community would gather a list of<br>  problematic cases.  There is some starter material in<br>  https://gist.github.com/dabrahams/847cf573f8795fc07596 if it helps.<br></p><p>&gt; 2. Use &quot;inPlace&quot; or some other simple adornment that can be universally applied to a method without exceptions.<br>&gt;<br>&gt; An inPlace suffix would be a significant eyesore for such a common<br>&gt; pattern. There doesn&#39;t seem to be another less obtrusive suffix that<br>&gt; properly conveys mutation, so we&#39;re either stuck with inPlace, or we<br>&gt; could try to find a more terse symbolic pattern (the same idea as<br>&gt; Ruby&#39;s postfix ! to indicate mutation). Nothing desirable comes to<br>&gt; mind, though.<br></p><p>Others have suggested the &quot;form&quot; prefix:<br></p><p>       x.formUnion(with: y)<br></p><p>&gt; 3. Add a language-level feature that allows a method on a type which<br>&gt; returns a value of that same type to be called in a way that mutates<br>&gt; the callee.<br>&gt;<br>&gt; Even when naming isn&#39;t an issue, defining mutating / non-mutating<br>&gt; versions of method is somewhat tedious and inflates the type&#39;s<br>&gt; interface. Any method that returns a value of the callee&#39;s type is a<br>&gt; valid candidate for a mutating version of that API, but defining the<br>&gt; mutating version is 100% boilerplate.<br>&gt;<br>&gt; Support from the compiler would eliminate this boilerplate as well as<br>&gt; this seemingly-unsolvable naming problem at the cost of some<br>&gt; additional complexity in the compiler.<br>&gt;<br>&gt; I can see two options off the top of my head. First, a method that<br>&gt; returns the same type as the callee mutates when its return value is<br>&gt; unused instead of producing a warning:<br>&gt;<br>&gt; let c = a.union(with: b) // Doesn&#39;t mutate.<br>&gt; a.union(with: b)         // Mutates.<br>&gt;<br>&gt; This is somewhat subtle and has some potential for confusion, but I<br>&gt; think Swift&#39;s strong immutability features would make it extremely<br>&gt; rare for this pattern to create bugs.<br>&gt;<br>&gt; Or, we can create a special syntax for mutating a callee with the return value of its method:<br>&gt;<br>&gt; a .= union(with: b) // First thing that comes to mind. It&#39;s<br>&gt; conceptually similar to += and friends and makes assignment explicit.<br></p><p>I suppose you haven&#39;t seen<br>https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst already?<br></p><p>&gt; <br>&gt; a = .union(with: b) // Similar idea, looks less like you&#39;re calling a<br>&gt; global method called union.<br>&gt;<br>&gt; My personal preference lies strongly in option 3 with roughly equal<br>&gt; preference for either sub-option, but I&#39;d really like to hear what<br>&gt; others think.<br>&gt;<br>&gt; Jarod<br>&gt;<br>&gt;&gt; On Feb 11, 2016, at 11:43, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just thinking out loud here:<br>&gt;&gt; <br>&gt;&gt; &quot;x&#39;s intersection with y&quot; makes sense. So &quot;x.intersection(with: y)&quot; makes sense.  That&#39;s already in Dave&#39;s diff.<br>&gt;&gt; <br>&gt;&gt; Unfortunately the same doesn&#39;t work well for &quot;x&#39;s union with y&quot; —<br>&gt;&gt; should &quot;x.union(with: y)&quot; be a mutating or nonmutating operation?<br>&gt;&gt; Hard to tell.<br>&gt;&gt; <br>&gt;&gt; How about we just move to ∪ and ∪= operators and call it a day? :-)<br>&gt;&gt; <br>&gt;&gt; On Thu, Feb 11, 2016 at 11:36 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might consider:<br>&gt;&gt; <br>&gt;&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt;&gt; * setIntersection(), setOr(), setUnion(),<br>&gt;&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt;&gt; etc<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and<br>&gt;&gt;&gt; &quot;ored&quot; is not something I&#39;d want in the standard library. Neither<br>&gt;&gt;&gt; is &quot;oring&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I see the -ed versions as short for -edSet, with the Set being<br>&gt;&gt;&gt; implied. Under this reasoning, unioned == unionedSet, intersected<br>&gt;&gt;&gt; == intersectedSet, thus acting as nouns not verbs, and used for<br>&gt;&gt;&gt; non-mutating application.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; inPlace is only for mutating application. I mildly prefer the<br>&gt;&gt;&gt; shorter union to unionInPlace, although I could argue both<br>&gt;&gt;&gt; sides. (The latter is clearer but longer, the former is the short<br>&gt;&gt;&gt; verb action that the whole guideline thing is supposed to endorse.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 14:40, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Feb 11 2016, Jarod Long &lt;swift-AT-lng.la&gt; wrote:<br>&gt; <br>&gt;&gt; Here are some thoughts after having quietly pondered the mutating method naming discussion for a while.<br>&gt;&gt; <br>&gt;&gt; My view is that an &quot;ed/ing&quot; mutation rule is fraught with undesirable<br>&gt;&gt; compromises. It&#39;s tempting because it works so well in the majority of<br>&gt;&gt; cases, but it seems that cases where it doesn&#39;t work are not uncommon,<br>&gt;&gt; even when the scope of the discussion is narrowed to a small set of<br>&gt;&gt; operations such as this. We&#39;re trying to play nice with English, but<br>&gt;&gt; we&#39;re butting up against its fundamental lack of clarity.<br>&gt;&gt; <br>&gt;&gt; As far as I see it, these are the options (forgive me for repeating<br>&gt;&gt; much of what others have said -- I&#39;d like to accurately convey my<br>&gt;&gt; perception of the situation as a whole):<br>&gt;&gt; <br>&gt;&gt; 1. Move forward with ed/ing-based guidelines that work well in many<br>&gt;&gt; cases. For the cases which don&#39;t work well, we can either:<br>&gt;&gt; <br>&gt;&gt; Have explicit exceptions, likely leading to overly-complicated guidelines that people may not be bothered to follow.<br>&gt;&gt; Leave it up to the developer to decide what&#39;s best on a case-by-case<br>&gt;&gt; basis, likely leading to inconsistencies and lots of time spent on<br>&gt;&gt; discussions of this magnitude.<br>&gt;&gt; <br>&gt;&gt; There&#39;s also a worrying amount of uncertainty and subjectivity<br>&gt;&gt; involved in identifying the situations where the base guidelines don&#39;t<br>&gt;&gt; work well, particularly for developers who aren&#39;t experts in English.<br>&gt; <br>&gt; It looks like we are poised to:<br>&gt; <br>&gt; * Force Set into the mold by “verbing” nouns as noted in the beginning<br>&gt;  of the thread, because it&#39;s a prominent type and it should follow the<br>&gt;  main guideline.<br>&gt; <br>&gt; * “Punt” on the more general question of what to do about other cases<br>&gt;  that don&#39;t fit well.  That is, we&#39;ll make a decision later.  In the<br>&gt;  meantime it would be great if the community would gather a list of<br>&gt;  problematic cases.  There is some starter material in<br>&gt;  https://gist.github.com/dabrahams/847cf573f8795fc07596 &lt;https://gist.github.com/dabrahams/847cf573f8795fc07596&gt; if it helps.<br>&gt; <br>&gt;&gt; 2. Use &quot;inPlace&quot; or some other simple adornment that can be universally applied to a method without exceptions.<br>&gt;&gt; <br>&gt;&gt; An inPlace suffix would be a significant eyesore for such a common<br>&gt;&gt; pattern. There doesn&#39;t seem to be another less obtrusive suffix that<br>&gt;&gt; properly conveys mutation, so we&#39;re either stuck with inPlace, or we<br>&gt;&gt; could try to find a more terse symbolic pattern (the same idea as<br>&gt;&gt; Ruby&#39;s postfix ! to indicate mutation). Nothing desirable comes to<br>&gt;&gt; mind, though.<br>&gt; <br>&gt; Others have suggested the &quot;form&quot; prefix:<br>&gt; <br>&gt;       x.formUnion(with: y)<br>&gt; <br>&gt;&gt; 3. Add a language-level feature that allows a method on a type which<br>&gt;&gt; returns a value of that same type to be called in a way that mutates<br>&gt;&gt; the callee.<br>&gt;&gt; <br>&gt;&gt; Even when naming isn&#39;t an issue, defining mutating / non-mutating<br>&gt;&gt; versions of method is somewhat tedious and inflates the type&#39;s<br>&gt;&gt; interface. Any method that returns a value of the callee&#39;s type is a<br>&gt;&gt; valid candidate for a mutating version of that API, but defining the<br>&gt;&gt; mutating version is 100% boilerplate.<br>&gt;&gt; <br>&gt;&gt; Support from the compiler would eliminate this boilerplate as well as<br>&gt;&gt; this seemingly-unsolvable naming problem at the cost of some<br>&gt;&gt; additional complexity in the compiler.<br>&gt;&gt; <br>&gt;&gt; I can see two options off the top of my head. First, a method that<br>&gt;&gt; returns the same type as the callee mutates when its return value is<br>&gt;&gt; unused instead of producing a warning:<br>&gt;&gt; <br>&gt;&gt; let c = a.union(with: b) // Doesn&#39;t mutate.<br>&gt;&gt; a.union(with: b)         // Mutates.<br>&gt;&gt; <br>&gt;&gt; This is somewhat subtle and has some potential for confusion, but I<br>&gt;&gt; think Swift&#39;s strong immutability features would make it extremely<br>&gt;&gt; rare for this pattern to create bugs.<br>&gt;&gt; <br>&gt;&gt; Or, we can create a special syntax for mutating a callee with the return value of its method:<br>&gt;&gt; <br>&gt;&gt; a .= union(with: b) // First thing that comes to mind. It&#39;s<br>&gt;&gt; conceptually similar to += and friends and makes assignment explicit.<br>&gt; <br>&gt; I suppose you haven&#39;t seen<br>&gt; https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt; already?<br></p><p>I sure haven&#39;t! Now I feel a little silly for typing all this up, but I&#39;m glad this is something being considered for the future. If we&#39;re reasonably confident that something like this will end up in Swift one day, then I&#39;m much less concerned about making the naming guidelines work perfectly for every use case in the mean time.<br></p><p>Thanks for your patience in my overlooking things that have already been discussed.<br></p><p>&gt;&gt; a = .union(with: b) // Similar idea, looks less like you&#39;re calling a<br>&gt;&gt; global method called union.<br>&gt;&gt; <br>&gt;&gt; My personal preference lies strongly in option 3 with roughly equal<br>&gt;&gt; preference for either sub-option, but I&#39;d really like to hear what<br>&gt;&gt; others think.<br>&gt;&gt; <br>&gt;&gt; Jarod<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 11:43, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just thinking out loud here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;x&#39;s intersection with y&quot; makes sense. So &quot;x.intersection(with: y)&quot; makes sense.  That&#39;s already in Dave&#39;s diff.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately the same doesn&#39;t work well for &quot;x&#39;s union with y&quot; —<br>&gt;&gt;&gt; should &quot;x.union(with: y)&quot; be a mutating or nonmutating operation?<br>&gt;&gt;&gt; Hard to tell.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about we just move to ∪ and ∪= operators and call it a day? :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:36 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt; &lt;mailto:erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might consider:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt;&gt;&gt; * setIntersection(), setOr(), setUnion(),<br>&gt;&gt;&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt;&gt;&gt; etc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt; &lt;mailto:jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and<br>&gt;&gt;&gt;&gt; &quot;ored&quot; is not something I&#39;d want in the standard library. Neither<br>&gt;&gt;&gt;&gt; is &quot;oring&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt; &lt;mailto:erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I see the -ed versions as short for -edSet, with the Set being<br>&gt;&gt;&gt;&gt; implied. Under this reasoning, unioned == unionedSet, intersected<br>&gt;&gt;&gt;&gt; == intersectedSet, thus acting as nouns not verbs, and used for<br>&gt;&gt;&gt;&gt; non-mutating application.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; inPlace is only for mutating application. I mildly prefer the<br>&gt;&gt;&gt;&gt; shorter union to unionInPlace, although I could argue both<br>&gt;&gt;&gt;&gt; sides. (The latter is clearer but longer, the former is the short<br>&gt;&gt;&gt;&gt; verb action that the whole guideline thing is supposed to endorse.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt; &lt;mailto:jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/a5283757/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>on Thu Feb 11 2016, Jarod Long &lt;swift-AT-lng.la&gt; wrote:<br></p><p>&gt;&gt; On Feb 11, 2016, at 14:40, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Feb 11 2016, Jarod Long &lt;swift-AT-lng.la&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Here are some thoughts after having quietly pondered the mutating method naming discussion for a while.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My view is that an &quot;ed/ing&quot; mutation rule is fraught with undesirable<br>&gt;&gt;&gt; compromises. It&#39;s tempting because it works so well in the majority of<br>&gt;&gt;&gt; cases, but it seems that cases where it doesn&#39;t work are not uncommon,<br>&gt;&gt;&gt; even when the scope of the discussion is narrowed to a small set of<br>&gt;&gt;&gt; operations such as this. We&#39;re trying to play nice with English, but<br>&gt;&gt;&gt; we&#39;re butting up against its fundamental lack of clarity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I see it, these are the options (forgive me for repeating<br>&gt;&gt;&gt; much of what others have said -- I&#39;d like to accurately convey my<br>&gt;&gt;&gt; perception of the situation as a whole):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Move forward with ed/ing-based guidelines that work well in many<br>&gt;&gt;&gt; cases. For the cases which don&#39;t work well, we can either:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have explicit exceptions, likely leading to overly-complicated guidelines that people may not be bothered to follow.<br>&gt;&gt;&gt; Leave it up to the developer to decide what&#39;s best on a case-by-case<br>&gt;&gt;&gt; basis, likely leading to inconsistencies and lots of time spent on<br>&gt;&gt;&gt; discussions of this magnitude.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s also a worrying amount of uncertainty and subjectivity<br>&gt;&gt;&gt; involved in identifying the situations where the base guidelines don&#39;t<br>&gt;&gt;&gt; work well, particularly for developers who aren&#39;t experts in English.<br>&gt;&gt; <br>&gt;&gt; It looks like we are poised to:<br>&gt;&gt; <br>&gt;&gt; * Force Set into the mold by “verbing” nouns as noted in the beginning<br>&gt;&gt;  of the thread, because it&#39;s a prominent type and it should follow the<br>&gt;&gt;  main guideline.<br>&gt;&gt; <br>&gt;&gt; * “Punt” on the more general question of what to do about other cases<br>&gt;&gt;  that don&#39;t fit well.  That is, we&#39;ll make a decision later.  In the<br>&gt;&gt;  meantime it would be great if the community would gather a list of<br>&gt;&gt;  problematic cases.  There is some starter material in<br>&gt;&gt;  https://gist.github.com/dabrahams/847cf573f8795fc07596<br>&gt;&gt; &lt;https://gist.github.com/dabrahams/847cf573f8795fc07596&gt; if it<br>&gt;&gt; helps.<br>&gt;&gt; <br>&gt;&gt;&gt; 2. Use &quot;inPlace&quot; or some other simple adornment that can be universally applied to a method without exceptions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An inPlace suffix would be a significant eyesore for such a common<br>&gt;&gt;&gt; pattern. There doesn&#39;t seem to be another less obtrusive suffix that<br>&gt;&gt;&gt; properly conveys mutation, so we&#39;re either stuck with inPlace, or we<br>&gt;&gt;&gt; could try to find a more terse symbolic pattern (the same idea as<br>&gt;&gt;&gt; Ruby&#39;s postfix ! to indicate mutation). Nothing desirable comes to<br>&gt;&gt;&gt; mind, though.<br>&gt;&gt; <br>&gt;&gt; Others have suggested the &quot;form&quot; prefix:<br>&gt;&gt; <br>&gt;&gt;       x.formUnion(with: y)<br>&gt;&gt; <br>&gt;&gt;&gt; 3. Add a language-level feature that allows a method on a type which<br>&gt;&gt;&gt; returns a value of that same type to be called in a way that mutates<br>&gt;&gt;&gt; the callee.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even when naming isn&#39;t an issue, defining mutating / non-mutating<br>&gt;&gt;&gt; versions of method is somewhat tedious and inflates the type&#39;s<br>&gt;&gt;&gt; interface. Any method that returns a value of the callee&#39;s type is a<br>&gt;&gt;&gt; valid candidate for a mutating version of that API, but defining the<br>&gt;&gt;&gt; mutating version is 100% boilerplate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Support from the compiler would eliminate this boilerplate as well as<br>&gt;&gt;&gt; this seemingly-unsolvable naming problem at the cost of some<br>&gt;&gt;&gt; additional complexity in the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can see two options off the top of my head. First, a method that<br>&gt;&gt;&gt; returns the same type as the callee mutates when its return value is<br>&gt;&gt;&gt; unused instead of producing a warning:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let c = a.union(with: b) // Doesn&#39;t mutate.<br>&gt;&gt;&gt; a.union(with: b)         // Mutates.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is somewhat subtle and has some potential for confusion, but I<br>&gt;&gt;&gt; think Swift&#39;s strong immutability features would make it extremely<br>&gt;&gt;&gt; rare for this pattern to create bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or, we can create a special syntax for mutating a callee with the return value of its method:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a .= union(with: b) // First thing that comes to mind. It&#39;s<br>&gt;&gt;&gt; conceptually similar to += and friends and makes assignment explicit.<br>&gt;&gt; <br>&gt;&gt; I suppose you haven&#39;t seen<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/proposals/Inplace.rst&gt;<br>&gt;&gt; already?<br>&gt;<br>&gt; I sure haven&#39;t! Now I feel a little silly for typing all this up, but<br>&gt; I&#39;m glad this is something being considered for the future. If we&#39;re<br>&gt; reasonably confident that something like this will end up in Swift one<br>&gt; day, then I&#39;m much less concerned about making the naming guidelines<br>&gt; work perfectly for every use case in the mean time.<br></p><p>For the record, I do not feel at all confident anything like this will<br>end up in swift.  This feature was proposed back in 2013, before Swift<br>was released, eventually accepted then not implemented because we were<br>out of time, then revised, then re-accepted and implemented, then ripped<br>out of the compiler because of various concerns about what it does to<br>the shape of the language (e.g. is this just a second version of<br>“mutating?”  What about classes?).  Based on history, I don&#39;t think it&#39;s<br>a sure bet, and I personally may be out of energy and time to fight for<br>it.  But we&#39;ll have to see...<br></p><p>&gt; Thanks for your patience in my overlooking things that have already<br>&gt; been discussed.<br>&gt;<br>&gt;&gt;&gt; a = .union(with: b) // Similar idea, looks less like you&#39;re calling a<br>&gt;&gt;&gt; global method called union.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My personal preference lies strongly in option 3 with roughly equal<br>&gt;&gt;&gt; preference for either sub-option, but I&#39;d really like to hear what<br>&gt;&gt;&gt; others think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jarod<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 11:43, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just thinking out loud here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;x&#39;s intersection with y&quot; makes sense. So &quot;x.intersection(with: y)&quot; makes sense.  That&#39;s already in Dave&#39;s diff.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately the same doesn&#39;t work well for &quot;x&#39;s union with y&quot; —<br>&gt;&gt;&gt;&gt; should &quot;x.union(with: y)&quot; be a mutating or nonmutating operation?<br>&gt;&gt;&gt;&gt; Hard to tell.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about we just move to ∪ and ∪= operators and call it a day? :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:36 AM, Erica Sadun<br>&gt;&gt;&gt;&gt; &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might consider:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt;&gt;&gt;&gt; * setIntersection(), setOr(), setUnion(),<br>&gt;&gt;&gt;&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt;&gt;&gt;&gt; etc<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch<br>&gt;&gt;&gt;&gt;&gt; &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and<br>&gt;&gt;&gt;&gt;&gt; &quot;ored&quot; is not something I&#39;d want in the standard library. Neither<br>&gt;&gt;&gt;&gt;&gt; is &quot;oring&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun<br>&gt;&gt;&gt;&gt;&gt; &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I see the -ed versions as short for -edSet, with the Set being<br>&gt;&gt;&gt;&gt;&gt; implied. Under this reasoning, unioned == unionedSet, intersected<br>&gt;&gt;&gt;&gt;&gt; == intersectedSet, thus acting as nouns not verbs, and used for<br>&gt;&gt;&gt;&gt;&gt; non-mutating application.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; inPlace is only for mutating application. I mildly prefer the<br>&gt;&gt;&gt;&gt;&gt; shorter union to unionInPlace, although I could argue both<br>&gt;&gt;&gt;&gt;&gt; sides. (The latter is clearer but longer, the former is the short<br>&gt;&gt;&gt;&gt;&gt; verb action that the whole guideline thing is supposed to endorse.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 4:17 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; For the record, I do not feel at all confident anything like this will<br>&gt; end up in swift.  This feature was proposed back in 2013, before Swift<br>&gt; was released, eventually accepted then not implemented because we were<br>&gt; out of time, then revised, then re-accepted and implemented, then ripped<br>&gt; out of the compiler because of various concerns about what it does to<br>&gt; the shape of the language (e.g. is this just a second version of<br>&gt; “mutating?”  What about classes?).  Based on history, I don&#39;t think it&#39;s<br>&gt; a sure bet, and I personally may be out of energy and time to fight for<br>&gt; it.  But we&#39;ll have to see...<br>&gt; <br></p><p>Using foo and fooInPlace is obvious, understandable, and easy. As a suffix, it perfectly communicates the difference between a mutating and non-mutating version, and doesn&#39;t involve anything on the level of gerunds, past participles, pluperfects, prozac, or anything like that.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/263bdb23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 6:20 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 4:17 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For the record, I do not feel at all confident anything like this will<br>&gt;&gt; end up in swift.  This feature was proposed back in 2013, before Swift<br>&gt;&gt; was released, eventually accepted then not implemented because we were<br>&gt;&gt; out of time, then revised, then re-accepted and implemented, then ripped<br>&gt;&gt; out of the compiler because of various concerns about what it does to<br>&gt;&gt; the shape of the language (e.g. is this just a second version of<br>&gt;&gt; “mutating?”  What about classes?).  Based on history, I don&#39;t think it&#39;s<br>&gt;&gt; a sure bet, and I personally may be out of energy and time to fight for<br>&gt;&gt; it.  But we&#39;ll have to see...<br>&gt;&gt; <br>&gt; <br>&gt; Using foo and fooInPlace is obvious, understandable, and easy. As a suffix, it perfectly communicates the difference between a mutating and non-mutating version, and doesn&#39;t involve anything on the level of gerunds, past participles, pluperfects, prozac, or anything like that.<br></p><p>Seconded.  Attempting to convey a precisely-defined abstract property (mutating) via the irregular grammatical conjugation rules of the English language is madness.  There should be a single unambiguous sigil for mutating methods.  “InPlace&quot; is verbose, but totally unambiguous and usable.<br></p><p>My own preference would be to adopt the “=“-prefixed mutating method names from the in place proposal Dave linked to.  If that’s not going to happen for whatever reason, “InPlace” is far less cumbersome than “ed/ing”.  “unioning” is horrifying.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/bf1ad99b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d1bff9080a4237cc9b79c5751afb6f7?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Jarod Long</string> &lt;swift at lng.la&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 15:20, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 4:17 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For the record, I do not feel at all confident anything like this will<br>&gt;&gt; end up in swift.  This feature was proposed back in 2013, before Swift<br>&gt;&gt; was released, eventually accepted then not implemented because we were<br>&gt;&gt; out of time, then revised, then re-accepted and implemented, then ripped<br>&gt;&gt; out of the compiler because of various concerns about what it does to<br>&gt;&gt; the shape of the language (e.g. is this just a second version of<br>&gt;&gt; “mutating?”  What about classes?).  Based on history, I don&#39;t think it&#39;s<br>&gt;&gt; a sure bet, and I personally may be out of energy and time to fight for<br>&gt;&gt; it.  But we&#39;ll have to see...<br>&gt;&gt; <br></p><p>Interesting -- I wasn&#39;t aware of the history of the proposal. I would be very interested in revisiting it to get the consideration of the larger Swift community. Is this something that would be reasonable in the Swift 3 timeframe, or should this wait until we can discuss Swift 4?<br></p><p>&gt; Using foo and fooInPlace is obvious, understandable, and easy. As a suffix, it perfectly communicates the difference between a mutating and non-mutating version, and doesn&#39;t involve anything on the level of gerunds, past participles, pluperfects, prozac, or anything like that.<br>&gt; <br>&gt; -- E<br></p><p>As for the immediate situation, I agree with this. InPlace feels clunky, but it&#39;s the only naming-based solution I&#39;ve seen that clearly communicates the semantics in all cases.<br></p><p>Jarod <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/8b6baadb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 3:20 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Using foo and fooInPlace is obvious, understandable, and easy. As a suffix, it perfectly communicates the difference between a mutating and non-mutating version, and doesn&#39;t involve anything on the level of gerunds, past participles, pluperfects, prozac, or anything like that.<br></p><p>One downside of foo / fooInPlace is that it may not be immediately obvious that `foo` is not an in-place operation. @warn_unused_result helps solve that. If you incorrectly use `foo` as if it were an in-place operation then @warn_unused_result will complain in most contexts.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 11, 2016 at 05:00:00pm</p></header><div class="content"><p>This is an interesting bit of historical perspective. Dave--may I ask<br>a naive question?<br></p><p>The proposal as shown is extensive. Would it be within reach/easier to<br>pitch/feasible to implement a narrower set of changes to facilitate<br>naming convention only? Namely: alter Swift syntax to allow function<br>names to begin with &quot;=&quot; and adopt naming conventions that<br>mutating/non-mutating pairs of functions are named<br>=frobnicate()/frobnicate()? That would, it seems, go a long way.<br></p><p><br>On Thu, Feb 11, 2016 at 5:17 PM, Dave Abrahams via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; For the record, I do not feel at all confident anything like this will<br>&gt; end up in swift.  This feature was proposed back in 2013, before Swift<br>&gt; was released, eventually accepted then not implemented because we were<br>&gt; out of time, then revised, then re-accepted and implemented, then ripped<br>&gt; out of the compiler because of various concerns about what it does to<br>&gt; the shape of the language (e.g. is this just a second version of<br>&gt; “mutating?”  What about classes?).  Based on history, I don&#39;t think it&#39;s<br>&gt; a sure bet, and I personally may be out of energy and time to fight for<br>&gt; it.  But we&#39;ll have to see...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 3:54 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is an interesting bit of historical perspective. Dave--may I ask<br>&gt; a naive question?<br>&gt; <br>&gt; The proposal as shown is extensive. Would it be within reach/easier to<br>&gt; pitch/feasible to implement a narrower set of changes to facilitate<br>&gt; naming convention only? Namely: alter Swift syntax to allow function<br>&gt; names to begin with &quot;=&quot; and adopt naming conventions that<br>&gt; mutating/non-mutating pairs of functions are named<br>&gt; =frobnicate()/frobnicate()? That would, it seems, go a long way.<br></p><p>That would not be a small change. The strict separation between operator characters and non-operator characters is deeply embedded into Swift&#39;s grammar and compiler.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Darn. Would have been nice. Thanks for explaining why though. Can I<br>try your patience with another naive question?<br></p><p>Unless the functions also return an error, mutating/non-mutating pairs<br>of functions return Void/Self (or maybe Optional&lt;Self&gt;) respectively.<br>Are there other possibilities? But Swift is pretty unique among<br>C-family languages in allowing overloaded functions that differ only<br>by return type. Besides the loss of clarity to the reader at the call<br>site, what are downsides of simply naming both functions exactly the<br>same in today&#39;s Swift syntax?<br></p><p>```<br>let foo: Foo<br>// suppose I can call a mutating or non-mutating foo.frobnicate()<br></p><p>let bar = foo.frobnicate() // surely, I must mean the non-mutating form<br></p><p>foo.frobnicate() // I must want to mutate `foo` unless I want only<br>side effects and an unused result<br>foo.frobnicate() as Foo // if so, I could always do this<br>```<br></p><p><br>On Thu, Feb 11, 2016 at 5:57 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Feb 11, 2016, at 3:54 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is an interesting bit of historical perspective. Dave--may I ask<br>&gt;&gt; a naive question?<br>&gt;&gt;<br>&gt;&gt; The proposal as shown is extensive. Would it be within reach/easier to<br>&gt;&gt; pitch/feasible to implement a narrower set of changes to facilitate<br>&gt;&gt; naming convention only? Namely: alter Swift syntax to allow function<br>&gt;&gt; names to begin with &quot;=&quot; and adopt naming conventions that<br>&gt;&gt; mutating/non-mutating pairs of functions are named<br>&gt;&gt; =frobnicate()/frobnicate()? That would, it seems, go a long way.<br>&gt;<br>&gt; That would not be a small change. The strict separation between operator characters and non-operator characters is deeply embedded into Swift&#39;s grammar and compiler.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>on Thu Feb 11 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; This is an interesting bit of historical perspective. Dave--may I ask<br>&gt; a naive question?<br>&gt;<br>&gt; The proposal as shown is extensive. Would it be within reach/easier to<br>&gt; pitch/feasible to implement a narrower set of changes to facilitate<br>&gt; naming convention only? Namely: alter Swift syntax to allow function<br>&gt; names to begin with &quot;=&quot; and adopt naming conventions that<br>&gt; mutating/non-mutating pairs of functions are named<br>&gt; =frobnicate()/frobnicate()? That would, it seems, go a long way.<br></p><p>It might be more feasible.  I&#39;m guessing it&#39;s out of scope for Swift 3,<br>of course.<br></p><p>&gt;<br>&gt;<br>&gt; On Thu, Feb 11, 2016 at 5:17 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; For the record, I do not feel at all confident anything like this will<br>&gt;&gt; end up in swift.  This feature was proposed back in 2013, before Swift<br>&gt;&gt; was released, eventually accepted then not implemented because we were<br>&gt;&gt; out of time, then revised, then re-accepted and implemented, then ripped<br>&gt;&gt; out of the compiler because of various concerns about what it does to<br>&gt;&gt; the shape of the language (e.g. is this just a second version of<br>&gt;&gt; “mutating?”  What about classes?).  Based on history, I don&#39;t think it&#39;s<br>&gt;&gt; a sure bet, and I personally may be out of energy and time to fight for<br>&gt;&gt; it.  But we&#39;ll have to see...<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On Thu, Feb 11, 2016 at 4:40 PM, Dave Abrahams via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; It looks like we are poised to:<br>&gt;<br>&gt; * Force Set into the mold by “verbing” nouns as noted in the beginning<br>&gt;   of the thread, because it&#39;s a prominent type and it should follow the<br>&gt;   main guideline.<br>&gt;<br>&gt; * “Punt” on the more general question of what to do about other cases<br>&gt;   that don&#39;t fit well.  That is, we&#39;ll make a decision later.  In the<br>&gt;   meantime it would be great if the community would gather a list of<br>&gt;   problematic cases.  There is some starter material in<br>&gt;   https://gist.github.com/dabrahams/847cf573f8795fc07596 if it helps.<br></p><p>If that&#39;s the decision of the core team, then I suppose we&#39;ll have to<br>live with it. But, FWIW, if you&#39;re noting feedback from the community,<br>my two cents are:<br>(a) Both union()/unionInPlace() and unioning()/union() are less than<br>ideal function names, but the former is both immediately clear and<br>less &#39;horrifying&#39; in terms of contorting the English language.<br>(b) It seems that many are willing to live with the wording if it&#39;s<br>only temporary, but if the long-term roadmap as currently envisioned<br>is to take today&#39;s union(), turn it into unioning(), then turn it back<br>into union(); and to take today&#39;s unionInPlace(), turn it into<br>union(), then into =union() [and yes, the right tooling will mitigate<br>the pain of these transitions to a long extent], is making this change<br>as proposed now clearly superior to the status quo?<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/df65d69ec35e73390ddd0e6a2c335737?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>James Hillhouse IV</string> &lt;jimhillhouse at me.com&gt;<p>February 11, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 for this suggestion. <br></p><p>Jim<br></p><p>jimhillhouse at me.com<br>512-484-9489<br></p><p>Sent from Jim&#39;s iPhone<br></p><p><br>&gt; On Feb 11, 2016, at 1:36 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Assuming one would want to avoid the -ed suffix (and also -ing), one might consider:<br>&gt; <br>&gt; * intersectionOf(), orOf(), unionOf() (or &quot;With&quot; over &quot;Of&quot;)<br>&gt; * setIntersection(), setOr(), setUnion(),<br>&gt; * intersectionResult(), orResult(), unionResult(),<br>&gt; etc<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 12:28 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &quot;intersected&quot; sounds okay to me. &quot;unioned&quot; is borderline, and &quot;ored&quot; is not something I&#39;d want in the standard library. Neither is &quot;oring&quot;.<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:25 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; I see the -ed versions as short for -edSet, with the Set being implied. Under this reasoning, unioned == unionedSet, intersected == intersectedSet, thus acting as nouns not verbs, and used for non-mutating application.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; inPlace is only for mutating application. I mildly prefer the shorter union to unionInPlace, although I could argue both sides. (The latter is clearer but longer, the former is the short verb action that the whole guideline thing is supposed to endorse.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 12:19 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Feb 11, 2016 at 11:09 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Reasoning:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So do the -ed versions, IMO. That&#39;s why -InPlace is such a convenient suffix.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/abfee02a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 12, 2016 at 04:00:00pm</p></header><div class="content"><p>I beg to disagree with your reasoning.<br>I think &quot;union&quot; is more commonly used as a noun and &quot;intersection&quot; certainly is not a verb. Your example sounded weird for me (but maybe that&#39;s because I&#39;m not a native speaker) and I would rather expect the question to be &quot;What is the union of A and B?&quot;<br></p><p>-Thorsten <br></p><p>&gt; Am 11.02.2016 um 20:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; My expectations is that the standard operators act upon a set, changing the set. <br>&gt; <br>&gt; set1.union(with: set2) tells set1 to perform the union. <br>&gt; set1.unioned(with: set2) creates a new instance where set1 has been unioned with set 2.<br>&gt; <br>&gt; Naming: intersected, unioned, and exclusiveOred over intersecting, unioning, exclusiveOring. <br>&gt; Mutating: union, intersection, exclusiveOr. <br>&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt; <br>&gt; Reasoning:<br>&gt; <br>&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt; * I think you have the nature of the words mis-assigned. In my opinion in this rare case, union, intersection, and exclusiveOr act as verbs as they are mathematical set operations. For example, &quot;what is the result of A union B?&quot; is a reasonable thing to say to a math person or put on an exam question, etc. <br>&gt; <br>&gt; Importantly, they produce significant side effects, and should be treated as verbs that operate upon the receiver, updating the receiver, establishing their use for mutating ops.<br>&gt; <br>&gt; Dave wrote:<br>&gt;&gt;&gt;&gt; - use nouns for methods with no side effects (or only incidental ones,  like logging)<br>&gt;&gt;&gt;&gt; - use verbs for methods with significant side-effects<br>&gt; <br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 9:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hi All,<br>&gt;&gt; <br>&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt; under development.<br>&gt;&gt; <br>&gt;&gt; Comments welcome as usual,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/06704a30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 12, 2016 at 10:00:00pm</p></header><div class="content"><p>Not to mention - mutating (in my limited and aged math knowledge) is NOT mathematical (computer simulations might use math in simulations which simulating something that mutates)<br></p><p>Mathematicians (typically) don’t mutate - they might be mutants….  but they don’t mutate their equations.<br></p><p>When was the last time you saw a mutating equation?  If equations mutate then it makes it much more difficult to prove correctness.<br></p><p>Probably why even OO programming languages don’t allow you to mutate an Integer or Decimal ….. bad things can happen.<br></p><p>Union and intersection have more in common with operations like + and - which also do not mutate the values.<br></p><p>:p<br></p><p>&gt;&gt; Reasoning:<br>&gt;&gt; <br>&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt; * I think you have the nature of the words mis-assigned. In my opinion in this rare case, union, intersection, and exclusiveOr act as verbs as they are mathematical set operations. For example, &quot;what is the result of A union B?&quot; is a reasonable thing to say to a math person or put on an exam question, etc. <br></p><p>&gt; <br></p><p><br></p><p><br>&gt; On 2016-02-12, at 22:20:01, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I beg to disagree with your reasoning.<br>&gt; I think &quot;union&quot; is more commonly used as a noun and &quot;intersection&quot; certainly is not a verb. Your example sounded weird for me (but maybe that&#39;s because I&#39;m not a native speaker) and I would rather expect the question to be &quot;What is the union of A and B?&quot;<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 11.02.2016 um 20:09 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; My expectations is that the standard operators act upon a set, changing the set. <br>&gt;&gt; <br>&gt;&gt; set1.union(with: set2) tells set1 to perform the union. <br>&gt;&gt; set1.unioned(with: set2) creates a new instance where set1 has been unioned with set 2.<br>&gt;&gt; <br>&gt;&gt; Naming: intersected, unioned, and exclusiveOred over intersecting, unioning, exclusiveOring. <br>&gt;&gt; Mutating: union, intersection, exclusiveOr. <br>&gt;&gt; Non-Mutating, returning new value: unioned(with), intersected(with), exclusiveOred(with)<br>&gt;&gt; <br>&gt;&gt; Reasoning:<br>&gt;&gt; <br>&gt;&gt; * I think the -ing endings sound unnatural, stilted, and unmathematical. They make me wince.<br>&gt;&gt; * I think you have the nature of the words mis-assigned. In my opinion in this rare case, union, intersection, and exclusiveOr act as verbs as they are mathematical set operations. For example, &quot;what is the result of A union B?&quot; is a reasonable thing to say to a math person or put on an exam question, etc. <br>&gt;&gt; <br>&gt;&gt; Importantly, they produce significant side effects, and should be treated as verbs that operate upon the receiver, updating the receiver, establishing their use for mutating ops.<br>&gt;&gt; <br>&gt;&gt; Dave wrote:<br>&gt;&gt;&gt;&gt;&gt; - use nouns for methods with no side effects (or only incidental ones,  like logging)<br>&gt;&gt;&gt;&gt;&gt; - use verbs for methods with significant side-effects<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 9:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi All,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5 &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt;&gt; to the API of<br>&gt;&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt;&gt; under development.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comments welcome as usual,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/3a085a15/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>-1 to the current diff.<br></p><p>`unioning`, `oring` really make me cringe. (O-ring? Let’s hope it’s not too cold outside.)<br></p><p>I also agree with Joe that the “with”s and “of”s are redundant. I really don’t see how they help explain the semantics of the method, or truly make anything clearer. Seems like an unnecessary attempt to make it sound like English, whether it’s useful or not.<br></p><p>— Radek<br></p><p>&gt; On 11 Feb 2016, at 17:52, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br>&gt; <br>&gt; Comments welcome as usual,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>February 11, 2016 at 05:00:00pm</p></header><div class="content"><p>I’ll also chime in with horror at “unioning.” Eew.<br></p><p>Mathematicians read A ∪ B as “A union B” — never “A union with B” or “A unioned with B” or anything else.<br></p><p>In short, the word “union” functions grammatically much like the word “plus.” The current proposal thus sounds as ridiculous as “a.plussing(with: b)”.<br></p><p>• • •<br></p><p>I agree with all those who’ve remarked on the uselessness of the “with:” for set operations.<br></p><p>• • •<br></p><p>On the part-of-speech aspect of this question:<br></p><p>This suggestion from Throsten makes the most sense, and feels the most natural — though it has the disadvantage that the add/union and subtract/difference correspondence is not immediately self-evident:<br></p><p>&gt; On Feb 11, 2016, at 10:49 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; mutating (verbs):<br>&gt; x.intersect(x)<br>&gt; x.add(x)<br>&gt; x.subtract(x)<br>&gt; <br>&gt; nonmutating (nouns):<br>&gt; x.intersection(x)<br>&gt; x.union(x)<br>&gt; x.difference(x)<br></p><p><br>This suggestion from Erica makes lots of logical sense, but is a likely source of programmer error, because I (and I’m sure many others) would assume that a.union(b) is non-mutating:<br></p><p>&gt; set1.union(with: set2) tells set1 to perform the union. <br>&gt; set1.unioned(with: set2) creates a new instance where set1 has been unioned with set 2.<br></p><p><br>This one from Rob overcomes those problems, though “unite” feels like an affectation:<br></p><p>&gt; On Feb 11, 2016, at 3:27 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;unite&quot; is already a perfectly good verb that means &quot;create the union of&quot;.  So why not<br>&gt; <br>&gt;     func union(with other: Self) -&gt; Self<br>&gt;     func unite(with other: Self)<br></p><p><br>All these are superior to “unioning.”<br></p><p>Cheers, P<br></p><p><br>&gt; On Feb 11, 2016, at 3:46 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1 to the current diff.<br>&gt; <br>&gt; `unioning`, `oring` really make me cringe. (O-ring? Let’s hope it’s not too cold outside.)<br>&gt; <br>&gt; I also agree with Joe that the “with”s and “of”s are redundant. I really don’t see how they help explain the semantics of the method, or truly make anything clearer. Seems like an unnecessary attempt to make it sound like English, whether it’s useful or not.<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 11 Feb 2016, at 17:52, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hi All,<br>&gt;&gt; <br>&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt; under development.<br>&gt;&gt; <br>&gt;&gt; Comments welcome as usual,<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/0fa2aaf1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br></p><p>My suggestions:<br></p><p>	union -&gt; union<br>	intersect -&gt; intersection<br>	subtract -&gt; subtraction<br></p><p>	unionInPlace -&gt; unite<br>	intersectInPlace -&gt; intersect<br>	subtractInPlace -&gt; subtract<br></p><p>In other words, treat the mutating forms as imperative verbs and the nonmutating forms as nouns. This basically makes the nonmutating forms into accessors, which I think is a good alternative given the trouble we&#39;re having with -ing/-ed.<br></p><p>That still leaves exclusiveOr, which is frankly a horrible name to begin with. I think we have to derive a name from the &quot;symmetric difference&quot; terminology, giving us<br></p><p>	exclusiveOr -&gt; difference<br>	exclusiveOrInPlace -&gt; differ<br></p><p>However, given the difficulty we&#39;re having coming up with names, we might want to explore using operators instead.<br></p><p>	union -&gt; |<br>	intersect -&gt; &amp;<br>	subtract -&gt; -<br>	exclusiveOr -&gt; ^<br></p><p>This gives us extremely straightforward mutating operators, of course, since we do have a convention for in-place operators:<br></p><p>	unionInPlace -&gt; |=<br>	intersectInPlace -&gt; &amp;=<br>	subtract -&gt; -=<br>	exclusiveOr -&gt; ^=<br></p><p>Some things to like about these operators:<br></p><p>* They are not used for anything on sequences or collections, so they don&#39;t overload existing concepts like concatenation with incompatible semantics.<br>* They have the same commutativity and transitivity as the associated integer operations.<br>* The bitwise forms of `|` and `&amp;` are already documented (in `_DisallowMixedSignArithmetic`) as the union and intersection of the bits, and `^` is documented in a compatible way.  Meanwhile, `-` literally means &quot;subtraction&quot;, the exact same operation we&#39;re exposing.<br>* And of course, it&#39;s just *nice* to not have to write long, unwieldy method names for fundamental operations.<br></p><p>Swift generally tries not to overload operators too much, but I think in this case, these overloads would be appropriate and helpful, while also getting us out of a sticky naming problem.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 11, 2016 at 05:00:00pm</p></header><div class="content"><p>On Thu, Feb 11, 2016 at 5:24 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; My suggestions:<br>&gt;<br>&gt;         union -&gt; union<br>&gt;         intersect -&gt; intersection<br>&gt;         subtract -&gt; subtraction<br>&gt;<br>&gt;         unionInPlace -&gt; unite<br>&gt;         intersectInPlace -&gt; intersect<br>&gt;         subtractInPlace -&gt; subtract<br>&gt;<br>&gt; In other words, treat the mutating forms as imperative verbs and the nonmutating forms as nouns. This basically makes the nonmutating forms into accessors, which I think is a good alternative given the trouble we&#39;re having with -ing/-ed.<br></p><p>I could live with that.<br></p><p>&gt; That still leaves exclusiveOr, which is frankly a horrible name to begin with. I think we have to derive a name from the &quot;symmetric difference&quot; terminology, giving us<br>&gt;<br>&gt;         exclusiveOr -&gt; difference<br>&gt;         exclusiveOrInPlace -&gt; differ<br></p><p>Nit: the set difference, or just difference, of two sets is the term<br>for the result of subtraction() and isn&#39;t the same as the symmetric<br>difference.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 6:24 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	exclusiveOrInPlace -&gt; differ<br></p><p>While there’s a straightforward line of reasoning that led to this point, anyone who doesn’t know the history will be completely baffled when they come across:<br></p><p>	x.differ(y)<br></p><p>in source.  Even knowing the history, it’s awkward.<br></p><p>This really needs to be either “xor” or “symmetricDifference” to be understandable.  “symmetricDifferenceInPlace” gets to be a bit ridiculous, so I’d prefer “xor[InPlace]”.  “xor” is sufficiently widely-used to qualify as a term-of-art; it’s the easiest-to-read unambiguous name for this operation.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/a338985d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72390862d2525bc8e2883ea3c36f8e5b?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Sébastien Blondiau</string> &lt;sebastien.blondiau at me.com&gt;<p>February 12, 2016 at 11:00:00pm</p></header><div class="content"><p>Using only the operators | &amp; - ^ |= &amp;= -= ^= for the operations on Set would simplify the code and resolve the problem of the names of these functions. Set do not really need these functions as method, only the operators would be enough, like the BitwiseOperationsType which do not have the methods xor and orInPlace ...<br></p><p>With the operators, the question of &quot;does this function mutate?&quot; would not be anymore. The code would get clarity and brevity without problem of naming. Isn’t that the API Design Guidelines?<br></p><p>--<br>Sébastien<br></p><p><br>&gt; Le 12 févr. 2016 à 00:24, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt; under development.<br>&gt; <br>&gt; My suggestions:<br>&gt; <br>&gt; 	union -&gt; union<br>&gt; 	intersect -&gt; intersection<br>&gt; 	subtract -&gt; subtraction<br>&gt; <br>&gt; 	unionInPlace -&gt; unite<br>&gt; 	intersectInPlace -&gt; intersect<br>&gt; 	subtractInPlace -&gt; subtract<br>&gt; <br>&gt; In other words, treat the mutating forms as imperative verbs and the nonmutating forms as nouns. This basically makes the nonmutating forms into accessors, which I think is a good alternative given the trouble we&#39;re having with -ing/-ed.<br>&gt; <br>&gt; That still leaves exclusiveOr, which is frankly a horrible name to begin with. I think we have to derive a name from the &quot;symmetric difference&quot; terminology, giving us<br>&gt; <br>&gt; 	exclusiveOr -&gt; difference<br>&gt; 	exclusiveOrInPlace -&gt; differ<br>&gt; <br>&gt; However, given the difficulty we&#39;re having coming up with names, we might want to explore using operators instead.<br>&gt; <br>&gt; 	union -&gt; |<br>&gt; 	intersect -&gt; &amp;<br>&gt; 	subtract -&gt; -<br>&gt; 	exclusiveOr -&gt; ^<br>&gt; <br>&gt; This gives us extremely straightforward mutating operators, of course, since we do have a convention for in-place operators:<br>&gt; <br>&gt; 	unionInPlace -&gt; |=<br>&gt; 	intersectInPlace -&gt; &amp;=<br>&gt; 	subtract -&gt; -=<br>&gt; 	exclusiveOr -&gt; ^=<br>&gt; <br>&gt; Some things to like about these operators:<br>&gt; <br>&gt; * They are not used for anything on sequences or collections, so they don&#39;t overload existing concepts like concatenation with incompatible semantics.<br>&gt; * They have the same commutativity and transitivity as the associated integer operations.<br>&gt; * The bitwise forms of `|` and `&amp;` are already documented (in `_DisallowMixedSignArithmetic`) as the union and intersection of the bits, and `^` is documented in a compatible way.  Meanwhile, `-` literally means &quot;subtraction&quot;, the exact same operation we&#39;re exposing.<br>&gt; * And of course, it&#39;s just *nice* to not have to write long, unwieldy method names for fundamental operations.<br>&gt; <br>&gt; Swift generally tries not to overload operators too much, but I think in this case, these overloads would be appropriate and helpful, while also getting us out of a sticky naming problem.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/18eaa0b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 13, 2016 at 05:00:00am</p></header><div class="content"><p>I like the set operators being “operator”  infix symbols - and would be happy with those.  <br></p><p>Definitely far better than some of the programmer assaults on the english language so far :p<br></p><p><br>&gt; On 2016-02-13, at 5:30:20, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Using only the operators | &amp; - ^ |= &amp;= -= ^= for the operations on Set would simplify the code and resolve the problem of the names of these functions. Set do not really need these functions as method, only the operators would be enough, like the BitwiseOperationsType which do not have the methods xor and orInPlace ...<br>&gt; <br>&gt; With the operators, the question of &quot;does this function mutate?&quot; would not be anymore. The code would get clarity and brevity without problem of naming. Isn’t that the API Design Guidelines?<br>&gt; <br>&gt; --<br>&gt; Sébastien<br>&gt; <br>&gt; <br>&gt;&gt; Le 12 févr. 2016 à 00:24, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5 &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt;&gt; to the API of<br>&gt;&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt;&gt; under development.<br>&gt;&gt; <br>&gt;&gt; My suggestions:<br>&gt;&gt; <br>&gt;&gt; 	union -&gt; union<br>&gt;&gt; 	intersect -&gt; intersection<br>&gt;&gt; 	subtract -&gt; subtraction<br>&gt;&gt; <br>&gt;&gt; 	unionInPlace -&gt; unite<br>&gt;&gt; 	intersectInPlace -&gt; intersect<br>&gt;&gt; 	subtractInPlace -&gt; subtract<br>&gt;&gt; <br>&gt;&gt; In other words, treat the mutating forms as imperative verbs and the nonmutating forms as nouns. This basically makes the nonmutating forms into accessors, which I think is a good alternative given the trouble we&#39;re having with -ing/-ed.<br>&gt;&gt; <br>&gt;&gt; That still leaves exclusiveOr, which is frankly a horrible name to begin with. I think we have to derive a name from the &quot;symmetric difference&quot; terminology, giving us<br>&gt;&gt; <br>&gt;&gt; 	exclusiveOr -&gt; difference<br>&gt;&gt; 	exclusiveOrInPlace -&gt; differ<br>&gt;&gt; <br>&gt;&gt; However, given the difficulty we&#39;re having coming up with names, we might want to explore using operators instead.<br>&gt;&gt; <br>&gt;&gt; 	union -&gt; |<br>&gt;&gt; 	intersect -&gt; &amp;<br>&gt;&gt; 	subtract -&gt; -<br>&gt;&gt; 	exclusiveOr -&gt; ^<br>&gt;&gt; <br>&gt;&gt; This gives us extremely straightforward mutating operators, of course, since we do have a convention for in-place operators:<br>&gt;&gt; <br>&gt;&gt; 	unionInPlace -&gt; |=<br>&gt;&gt; 	intersectInPlace -&gt; &amp;=<br>&gt;&gt; 	subtract -&gt; -=<br>&gt;&gt; 	exclusiveOr -&gt; ^=<br>&gt;&gt; <br>&gt;&gt; Some things to like about these operators:<br>&gt;&gt; <br>&gt;&gt; * They are not used for anything on sequences or collections, so they don&#39;t overload existing concepts like concatenation with incompatible semantics.<br>&gt;&gt; * They have the same commutativity and transitivity as the associated integer operations.<br>&gt;&gt; * The bitwise forms of `|` and `&amp;` are already documented (in `_DisallowMixedSignArithmetic`) as the union and intersection of the bits, and `^` is documented in a compatible way.  Meanwhile, `-` literally means &quot;subtraction&quot;, the exact same operation we&#39;re exposing.<br>&gt;&gt; * And of course, it&#39;s just *nice* to not have to write long, unwieldy method names for fundamental operations.<br>&gt;&gt; <br>&gt;&gt; Swift generally tries not to overload operators too much, but I think in this case, these overloads would be appropriate and helpful, while also getting us out of a sticky naming problem.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/7003568e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f163c0be9c7f32231614d28b2ceccab?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Donald Pinckney</string> &lt;djpinckney at ucdavis.edu&gt;<p>February 12, 2016 at 08:00:00pm</p></header><div class="content"><p>I also am greatly in favor of set algebra using infix and assignment operators.  As already mentioned, this removes ambiguity about mutating or not mutating. <br></p><p>In addition, I believe this is not an abuse of operators such that they become confusing: all of the operators are familiar from other uses. Furthermore, I feel this adds consistency mathematically with the rest of the language: all of the major algebras (integers, reals, booleans) and now sets would have similar syntax and &quot;feel&quot;.<br></p><p>Then again, I might have an excessive preference for mathematical constructs in Swift to come out &quot;cute&quot;, which isn&#39;t necessarily the goal of Swift.<br></p><p>Just my 2 cents,<br></p><p>Donald Pinckney<br></p><p>&gt; On Feb 12, 2016, at 2:33 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the set operators being “operator”  infix symbols - and would be happy with those.  <br>&gt; <br>&gt; Definitely far better than some of the programmer assaults on the english language so far :p<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-13, at 5:30:20, Sébastien Blondiau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Using only the operators | &amp; - ^ |= &amp;= -= ^= for the operations on Set would simplify the code and resolve the problem of the names of these functions. Set do not really need these functions as method, only the operators would be enough, like the BitwiseOperationsType which do not have the methods xor and orInPlace ...<br>&gt;&gt; <br>&gt;&gt; With the operators, the question of &quot;does this function mutate?&quot; would not be anymore. The code would get clarity and brevity without problem of naming. Isn’t that the API Design Guidelines?<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Sébastien<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 12 févr. 2016 à 00:24, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt;&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt;&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt;&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt;&gt;&gt; under development.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My suggestions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	union -&gt; union<br>&gt;&gt;&gt; 	intersect -&gt; intersection<br>&gt;&gt;&gt; 	subtract -&gt; subtraction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	unionInPlace -&gt; unite<br>&gt;&gt;&gt; 	intersectInPlace -&gt; intersect<br>&gt;&gt;&gt; 	subtractInPlace -&gt; subtract<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, treat the mutating forms as imperative verbs and the nonmutating forms as nouns. This basically makes the nonmutating forms into accessors, which I think is a good alternative given the trouble we&#39;re having with -ing/-ed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That still leaves exclusiveOr, which is frankly a horrible name to begin with. I think we have to derive a name from the &quot;symmetric difference&quot; terminology, giving us<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	exclusiveOr -&gt; difference<br>&gt;&gt;&gt; 	exclusiveOrInPlace -&gt; differ<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, given the difficulty we&#39;re having coming up with names, we might want to explore using operators instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	union -&gt; |<br>&gt;&gt;&gt; 	intersect -&gt; &amp;<br>&gt;&gt;&gt; 	subtract -&gt; -<br>&gt;&gt;&gt; 	exclusiveOr -&gt; ^<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This gives us extremely straightforward mutating operators, of course, since we do have a convention for in-place operators:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	unionInPlace -&gt; |=<br>&gt;&gt;&gt; 	intersectInPlace -&gt; &amp;=<br>&gt;&gt;&gt; 	subtract -&gt; -=<br>&gt;&gt;&gt; 	exclusiveOr -&gt; ^=<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some things to like about these operators:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * They are not used for anything on sequences or collections, so they don&#39;t overload existing concepts like concatenation with incompatible semantics.<br>&gt;&gt;&gt; * They have the same commutativity and transitivity as the associated integer operations.<br>&gt;&gt;&gt; * The bitwise forms of `|` and `&amp;` are already documented (in `_DisallowMixedSignArithmetic`) as the union and intersection of the bits, and `^` is documented in a compatible way.  Meanwhile, `-` literally means &quot;subtraction&quot;, the exact same operation we&#39;re exposing.<br>&gt;&gt;&gt; * And of course, it&#39;s just *nice* to not have to write long, unwieldy method names for fundamental operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift generally tries not to overload operators too much, but I think in this case, these overloads would be appropriate and helpful, while also getting us out of a sticky naming problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/ebed191f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>I don’t know if this has been suggested already… but why not just use the same name and have an `inPlace` parameter with a default value?<br></p><p>x.sort()<br>x.sort(inPlace: false)<br></p><p>x.add(y)<br>x.add(y, inPlace: false)<br></p><p>x.intersect(y)<br>x.intersect(y, inPlace: false)<br></p><p>Having to come up with all of these different word forms is confusing and the English language is terrible an consistency; we have no real chance here.<br></p><p>-David<br></p><p><br>&gt; On Feb 11, 2016, at 8:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br>&gt; <br>&gt; Comments welcome as usual,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 10:28 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t know if this has been suggested already… but why not just use the same name and have an `inPlace` parameter with a default value?<br></p><p>inplace, or not, fundamentally affects the operation, including the return type.  On a struct, it is the different between the method being mutating or not.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 10:30 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 10:28 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don’t know if this has been suggested already… but why not just use the same name and have an `inPlace` parameter with a default value?<br>&gt; <br>&gt; inplace, or not, fundamentally affects the operation, including the return type.  On a struct, it is the different between the method being mutating or not.<br>&gt; <br>&gt; -Chris<br></p><p>The return type is not always different, but in the case where it is and when we need mutating, can’t overloads solve this problem?<br></p><p>mutating func sort() {}<br>func sort(inPlace: Bool) -&gt; T {}<br></p><p>Maybe I’m just overlooking something really obvious here…<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 10:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 10:30 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 10:28 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know if this has been suggested already… but why not just use the same name and have an `inPlace` parameter with a default value?<br>&gt;&gt; <br>&gt;&gt; inplace, or not, fundamentally affects the operation, including the return type.  On a struct, it is the different between the method being mutating or not.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; The return type is not always different, but in the case where it is and when we need mutating, can’t overloads solve this problem?<br>&gt; <br>&gt; mutating func sort() {}<br>&gt; func sort(inPlace: Bool) -&gt; T {}<br>&gt; <br>&gt; Maybe I’m just overlooking something really obvious here…<br></p><p>x.sort(inPlace: true) can&#39;t work with those definitions.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>on Thu Feb 11 2016, Greg Parker &lt;gparker-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Feb 11, 2016, at 10:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 10:30 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 10:28 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t know if this has been suggested already… but why not just<br>&gt;&gt;&gt;&gt; use the same name and have an `inPlace` parameter with a default<br>&gt;&gt;&gt;&gt; value?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; inplace, or not, fundamentally affects the operation, including the<br>&gt;&gt;&gt; return type.  On a struct, it is the different between the method<br>&gt;&gt;&gt; being mutating or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; The return type is not always different, but in the case where it is<br>&gt;&gt; and when we need mutating, can’t overloads solve this problem?<br>&gt;&gt; <br>&gt;&gt; mutating func sort() {}<br>&gt;&gt; func sort(inPlace: Bool) -&gt; T {}<br>&gt;&gt; <br>&gt;&gt; Maybe I’m just overlooking something really obvious here…<br>&gt;<br>&gt; x.sort(inPlace: true) can&#39;t work with those definitions.<br></p><p>You need something like:<br></p><p>enum InPlace { case inPlace }<br>extension MutableCollectionType where Index : RandomAccessIndexType, Generator.Element: Comparable {<br>   mutating func sort(_: InPlace) {<br>      sortInPlace()<br>   }<br>}<br>var x = Array((10..&lt;40).reverse())<br>x.sort(.inPlace)<br></p><p>-- <br>-Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>Yes… yes I am… <br></p><p>&gt; On Feb 11, 2016, at 10:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 10:30 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 10:28 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know if this has been suggested already… but why not just use the same name and have an `inPlace` parameter with a default value?<br>&gt;&gt; <br>&gt;&gt; inplace, or not, fundamentally affects the operation, including the return type.  On a struct, it is the different between the method being mutating or not.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; The return type is not always different, but in the case where it is and when we need mutating, can’t overloads solve this problem?<br>&gt; <br>&gt; mutating func sort() {}<br>&gt; func sort(inPlace: Bool) -&gt; T {}<br>&gt; <br>&gt; Maybe I’m just overlooking something really obvious here…<br>&gt; <br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 12, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I can’t make up my mind.  Let me propose two different alternatives that I’m not sure if they have been considered:<br></p><p>ALTERNATIVE 1<br></p><p>Non-mutable (noun-based)<br></p><p>-  func union(other: Self) -&gt; Self<br>+  func union(other: Self) -&gt; Self		Assumes union is a noun, i.e. not a verb<br></p><p>-  func intersect(other: Self) -&gt; Self<br>+  func intersection(other: Self) -&gt; Self<br></p><p>-  func subtract(other: Self) -&gt; Self<br>+  func subtraction(other: Self) -&gt; Self<br></p><p>-  func exclusiveOr(other: Self) -&gt; Self<br>+  func symmetricSubtraction(other: Self) -&gt; Self<br></p><p>Mutable (verb-based)<br></p><p>-  mutating func unionInPlace(other: Self)<br>+  mutating func unite(other: Self)<br></p><p>-  mutating func intersectInPlace(other: Self)<br>+  mutating func intersect(other: Self)<br></p><p>-  mutating func subtractInPlace(other: Self)<br>+  mutating func subtract(other: Self)<br></p><p>-  mutating func exclusiveOrInPlace(other: Self)<br>+  mutating func symmetricSubtract(other: Self)<br></p><p><br>Comments: <br></p><p>With this alternative we keep the union name which I assume is popular.  However, one has to accept unite as a verb (for the mutable version) as I wanted all the mutable methods use verbs for consistency.  I think unite is acceptable because it can be found in the dictionary and it is a verb.   <br></p><p>Notice that all the non-mutable methods use nouns: union, intersection, subtraction and symmetricSubtraction.  <br></p><p>I understand some may oppose to symmetricSubtraction saying that symmetricSubraction is not as common as &quot;exclusive or&quot;.  However, using symmetricSubtraction is consistent with subtraction and it hints to a variation of the “subtraction&quot; operation.  We will get used to it quickly / easily.<br></p><p>The mutable methods all use verbs:  unite, intersect, subtract and symmetricSubtract.<br></p><p><br></p><p>ALTERNATIVE 2<br></p><p>Non-mutable<br></p><p>-  func union(other: Self) -&gt; Self<br>+  func adding(other: Self) -&gt; Self<br></p><p>-  func intersect(other: Self) -&gt; Self<br>+  func intersecting(other: Self) -&gt; Self<br></p><p>-  func exclusiveOr(other: Self) -&gt; Self<br>+  func exclusiveOring(other: Self) -&gt; Self<br></p><p>-  func subtract(other: Self) -&gt; Self<br>+  func removing(other: Self) -&gt; Self<br></p><p><br>Mutable<br></p><p>-  mutating func unionInPlace(other: Self)<br>+  mutating func add(other: Self)<br></p><p>-  mutating func intersectInPlace(other: Self)<br>+  mutating func intersect(other: Self)<br></p><p>-  mutating func exclusiveOrInPlace(other: Self)<br>+  mutating func exclusiveOr(other: Self)<br></p><p>-  mutating func subtractInPlace(other: Self)<br>+  mutating func remove(other: Self)<br></p><p><br>Comments: This alternative gives up on union in favor or add.  Many may not like this, that is why I have it as the second alternative.  It brings back exclusiveOr and treats it as a verb.  Some may argue that exclusiveOr is a noun for the &quot;exclusive or&quot; operation.<br></p><p><br></p><p><br></p><p><br>&gt; On Feb 11, 2016, at 11:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br>&gt; <br>&gt; Comments welcome as usual,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/9e164ee7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 13, 2016 at 11:00:00am</p></header><div class="content"><p>On a skim, if there’s a specific explanation as to *why* `inPlace` is a now a no-go, I don’t see it. I can’t say I like the proposed changes very much, and I definitely don’t like some of the more-creative suggestions.<br></p><p>It’s hard to offer help when it’s not clear what was deemed problematic about the existing (and “perfectly fine with me”!) names.<br></p><p>Separately, can I ask here why SetAlgebra protocol doesn’t contain an *overridable* method like `func intersects(other: Self) -&gt; Bool`? <br></p><p>(Note: I am *well-aware* that `a intersects b &lt;=&gt; !(a and b are disjoint)`).<br></p><p>That absence has been puzzling me ever whichever release of Swift first introduced this protocol, particularly since e.g. both `isSubsetOf` and `isSupersetOf` are individually-overridable. <br></p><p> (Likewise, but less so, I do wonder why the protocol doesn’t contain *overridable* `isStrictSubset` and `isStrictSuperset` functions, either...).<br></p><p>&gt; On Feb 11, 2016, at 10:52 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Hi All,<br>&gt; <br>&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt; standard library.  We are planning to apply the changes shown here<br>&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt; under development.<br>&gt; <br>&gt; Comments welcome as usual,<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
