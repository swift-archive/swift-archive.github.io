<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>May 21, 2016 at 10:00:00am</p></header><div class="content"><p>Hello everyone,<br></p><p>I have added a very simple, but powerful method into a Dictionary extension<br>on multiple projects in the last weeks, so I&#39;d like to bring up the idea of<br>adding it into the standard library, in case other people can see its<br>benefits as well.<br></p><p>Currently, Dictionary conforms to Collection with its Element being the<br>tuple of Key and Value. Thus transforming the Dictionary with regular map<br>results in [T], whereas I&#39;d find it more useful to also have a method which<br>results in [Key:T].<br></p><p>Let me present an example of where this makes sense.<br></p><p>I recently used the GitHub API to crawl some information about<br>repositories. I started with just names (e.g. &quot;/apple/swift&quot;,<br>&quot;/apple/llvm&quot;) and fetched a JSON response for each of the repos, each<br>returning a dictionary, which got saved into one large dictionary as the<br>end of the full operation, keyed by its name, so the structure was<br>something like<br></p><p>{<br>  &quot;/apple/swift&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>  &quot;/apple/llvm&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>  ...<br>}<br></p><p>To perform analysis, I just needed a dictionary mapping the name of the<br>repository to its size, freeing me to discard the rest of the results.<br>This is where things get interesting, because you can&#39;t keep this action<br>nicely functional anymore. I had to do the following:<br></p><p>let repos: [String: JSON] = ...<br>var sizes: [String: Int] = [:]<br>for (key, value) in repos {<br>  sizes[key] = value[&quot;size&quot;].int<br>}<br>// use sizes...<br></p><p>Which isn&#39;t a huge amount of work, but it creates unnecessary mutable state<br>in your transformation pipeline (and your current scope). And I had to<br>write it enough times to justify bringing it up on this list.<br></p><p>I suggest we add the following method to Dictionary:<br></p><p>extension Dictionary {<br>      public func mapValues&lt;T&gt;(_ transform: @noescape (Value) throws -&gt; T)<br>rethrows -&gt; [Key: T] {<br>        var transformed: [Key: T] = [:]<br>        for (key, value) in self {<br>            transformed[key] = try transform(value)<br>        }<br>        return transformed<br>    }<br>}<br></p><p>It is modeled after Collection&#39;s `map` function, with the difference that<br> a) only values are transformed, instead of the Key,Value tuple and<br> b) the returned structure is a transformed Dictionary [Key:T], instead of<br>[T]<br></p><p>This now allows a much nicer workflow:<br></p><p>let repos: [String: JSON] = ...<br>var sizes = repos.mapValues { $0[&quot;size&quot;].int }<br>// use sizes...<br></p><p>and even multi-step transformations on Dictionaries, previously only<br>possible on Arrays, e.g.<br>var descriptionTextLengths = repos.mapValues { $0[&quot;description&quot;].string<br>}.mapValues { $0.characters.count }<br></p><p>You get the idea.<br></p><p>What do you think? I welcome all feedback, I&#39;d like to see if people would<br>support it before I write a proper proposal.<br></p><p>Thanks! :)<br>Honza Dvorsky<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/3dce23aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; What do you think? I welcome all feedback, I&#39;d like to see if people would support it before I write a proper proposal.<br></p><p>This has come up a couple of times, I believe most recently in the April 12 thread &quot;[Proposal] mapValues&quot;. It always gets substantial, but not universal, support.<br></p><p>If I were you, I would search the list archives for previous threads about mapping dictionaries and see which arguments have come up before. If they change your mind, great. If they don&#39;t, they&#39;ll make up your proposal&#39;s &quot;Alternatives Considered&quot; section.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>May 21, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Brent,<br></p><p>thanks, I should have caught that, unfortunately I don&#39;t know of a nice way<br>to search the mailing list, other than searching your own inbox, which<br>doesn&#39;t include messages from the time you weren&#39;t subscribed - how do you<br>do it?<br></p><p>You&#39;re right, I found the previous conversation from over a month ago,<br>where almost everyone +1&#39;d, but it hasn&#39;t moved anywhere since, as far as I<br>know. Or is there a proposal already? (Nothing was linked from the thread).<br></p><p>So apologies for the duplication, but let&#39;s take this as a signal to revive<br>that conversation, as I haven&#39;t found any responses which were negative, I<br>mostly saw positive ones and ones that didn&#39;t feel strongly about it.<br></p><p>Honza<br></p><p><br>On Sat, May 21, 2016 at 12:58 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; What do you think? I welcome all feedback, I&#39;d like to see if people<br>&gt; would support it before I write a proper proposal.<br>&gt;<br>&gt; This has come up a couple of times, I believe most recently in the April<br>&gt; 12 thread &quot;[Proposal] mapValues&quot;. It always gets substantial, but not<br>&gt; universal, support.<br>&gt;<br>&gt; If I were you, I would search the list archives for previous threads about<br>&gt; mapping dictionaries and see which arguments have come up before. If they<br>&gt; change your mind, great. If they don&#39;t, they&#39;ll make up your proposal&#39;s<br>&gt; &quot;Alternatives Considered&quot; section.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/de21fc26/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 21, 2016 at 02:00:00pm</p></header><div class="content"><p>I think that before this can be done there needs to be an abstraction of what a Dictionary is, for example a Map&lt;Key, Value&gt; protocol. This would allow us to also implement the important lazy variations of what you suggest, which would likely be more important for very large dictionaries as dictionaries are rarely consumed in their entirety; in other words, calculating and storing the transformed value for every key/value pair is quite a performance overhead if only a fraction of those keys may actually be accessed. Even if you are consuming the whole transformed dictionary the lazy version is better since it doesn’t store any intermediate values, you only really want a fully transformed dictionary if you know the transformation is either very costly, or transformed values will be accessed frequently.<br></p><p>Anyway, long way of saying that while the specific implementation is definitely wanted, the complete solution requires a few extra steps which should be done too, as lazy computation can have big performance benefits.<br></p><p>That and it’d be nice to have a Map protocol in stdlib for defining other map types, such as trees, since these don’t require Hashable keys, but dictionaries do.<br></p><p>&gt; On 21 May 2016, at 11:27, Honza Dvorsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello everyone,<br>&gt; <br>&gt; I have added a very simple, but powerful method into a Dictionary extension on multiple projects in the last weeks, so I&#39;d like to bring up the idea of adding it into the standard library, in case other people can see its benefits as well.<br>&gt; <br>&gt; Currently, Dictionary conforms to Collection with its Element being the tuple of Key and Value. Thus transforming the Dictionary with regular map results in [T], whereas I&#39;d find it more useful to also have a method which results in [Key:T].<br>&gt; <br>&gt; Let me present an example of where this makes sense.<br>&gt; <br>&gt; I recently used the GitHub API to crawl some information about repositories. I started with just names (e.g. &quot;/apple/swift&quot;, &quot;/apple/llvm&quot;) and fetched a JSON response for each of the repos, each returning a dictionary, which got saved into one large dictionary as the end of the full operation, keyed by its name, so the structure was something like<br>&gt; <br>&gt; {<br>&gt;   &quot;/apple/swift&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt;   &quot;/apple/llvm&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt;   ...<br>&gt; }<br>&gt; <br>&gt; To perform analysis, I just needed a dictionary mapping the name of the repository to its size, freeing me to discard the rest of the results.<br>&gt; This is where things get interesting, because you can&#39;t keep this action nicely functional anymore. I had to do the following:<br>&gt; <br>&gt; let repos: [String: JSON] = ...<br>&gt; var sizes: [String: Int] = [:]<br>&gt; for (key, value) in repos {<br>&gt;   sizes[key] = value[&quot;size&quot;].int<br>&gt; }<br>&gt; // use sizes...<br>&gt; <br>&gt; Which isn&#39;t a huge amount of work, but it creates unnecessary mutable state in your transformation pipeline (and your current scope). And I had to write it enough times to justify bringing it up on this list.<br>&gt; <br>&gt; I suggest we add the following method to Dictionary:<br>&gt; <br>&gt; extension Dictionary {<br>&gt;       public func mapValues&lt;T&gt;(_ transform: @noescape (Value) throws -&gt; T) rethrows -&gt; [Key: T] {<br>&gt;         var transformed: [Key: T] = [:]<br>&gt;         for (key, value) in self {<br>&gt;             transformed[key] = try transform(value)<br>&gt;         }<br>&gt;         return transformed<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; It is modeled after Collection&#39;s `map` function, with the difference that <br>&gt;  a) only values are transformed, instead of the Key,Value tuple and <br>&gt;  b) the returned structure is a transformed Dictionary [Key:T], instead of [T]<br>&gt; <br>&gt; This now allows a much nicer workflow:<br>&gt; <br>&gt; let repos: [String: JSON] = ...<br>&gt; var sizes = repos.mapValues { $0[&quot;size&quot;].int }<br>&gt; // use sizes...<br>&gt; <br>&gt; and even multi-step transformations on Dictionaries, previously only possible on Arrays, e.g. <br>&gt; var descriptionTextLengths = repos.mapValues { $0[&quot;description&quot;].string }.mapValues { $0.characters.count }<br>&gt; <br>&gt; You get the idea.<br>&gt; <br>&gt; What do you think? I welcome all feedback, I&#39;d like to see if people would support it before I write a proper proposal.<br>&gt; <br>&gt; Thanks! :)<br>&gt; Honza Dvorsky<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 21, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 21, 2016, at 8:45 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think that before this can be done there needs to be an abstraction of what a Dictionary is, for example a Map&lt;Key, Value&gt; protocol. This would allow us to also implement the important lazy variations of what you suggest, which would likely be more important for very large dictionaries as dictionaries are rarely consumed in their entirety; in other words, calculating and storing the transformed value for every key/value pair is quite a performance overhead if only a fraction of those keys may actually be accessed. Even if you are consuming the whole transformed dictionary the lazy version is better since it doesn’t store any intermediate values, you only really want a fully transformed dictionary if you know the transformation is either very costly, or transformed values will be accessed frequently.<br>&gt; <br>&gt; Anyway, long way of saying that while the specific implementation is definitely wanted, the complete solution requires a few extra steps which should be done too, as lazy computation can have big performance benefits.<br>&gt; <br>&gt; That and it’d be nice to have a Map protocol in stdlib for defining other map types, such as trees, since these don’t require Hashable keys, but dictionaries do.<br></p><p>+1 to defining map abstractions in the standard library (separating read only from read write).  The value associatedtype should not take a position on optionality, allowing for maps which have a valid value for all possible keys.  I have done similar things in other languages and found it extremely useful.  It is not uncommon to have code that just needs to read and / or write to / from a map without having concern for the implementation of the map.<br></p><p>One issue I think we should sort out along side this is some kind of abstraction which allows code to use functions or user-defined types without regard for which it is accessing.  The map abstraction would build on this abstraction, allowing single argument functions to be viewed as a read only map.<br></p><p>One option is to allow functions to conform to protocols that only have subscript { get } requirements (we would probably only allow them to be subscripted through the protocol interface).  I think this feels like the most Swifty direction.<br></p><p>Another option is to take the path I have seen in several languages which is to allow overloading of the function call &quot;operator&quot;.  I originally wanted this in Swift but now wonder if the first option might be a better way to accomplish the same goals.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt;&gt;  On 21 May 2016, at 11:27, Honza Dvorsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello everyone,<br>&gt;&gt; <br>&gt;&gt; I have added a very simple, but powerful method into a Dictionary extension on multiple projects in the last weeks, so I&#39;d like to bring up the idea of adding it into the standard library, in case other people can see its benefits as well.<br>&gt;&gt; <br>&gt;&gt; Currently, Dictionary conforms to Collection with its Element being the tuple of Key and Value. Thus transforming the Dictionary with regular map results in [T], whereas I&#39;d find it more useful to also have a method which results in [Key:T].<br>&gt;&gt; <br>&gt;&gt; Let me present an example of where this makes sense.<br>&gt;&gt; <br>&gt;&gt; I recently used the GitHub API to crawl some information about repositories. I started with just names (e.g. &quot;/apple/swift&quot;, &quot;/apple/llvm&quot;) and fetched a JSON response for each of the repos, each returning a dictionary, which got saved into one large dictionary as the end of the full operation, keyed by its name, so the structure was something like<br>&gt;&gt; <br>&gt;&gt; {<br>&gt;&gt;  &quot;/apple/swift&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt;&gt;  &quot;/apple/llvm&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt;&gt;  ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; To perform analysis, I just needed a dictionary mapping the name of the repository to its size, freeing me to discard the rest of the results.<br>&gt;&gt; This is where things get interesting, because you can&#39;t keep this action nicely functional anymore. I had to do the following:<br>&gt;&gt; <br>&gt;&gt; let repos: [String: JSON] = ...<br>&gt;&gt; var sizes: [String: Int] = [:]<br>&gt;&gt; for (key, value) in repos {<br>&gt;&gt;  sizes[key] = value[&quot;size&quot;].int<br>&gt;&gt; }<br>&gt;&gt; // use sizes...<br>&gt;&gt; <br>&gt;&gt; Which isn&#39;t a huge amount of work, but it creates unnecessary mutable state in your transformation pipeline (and your current scope). And I had to write it enough times to justify bringing it up on this list.<br>&gt;&gt; <br>&gt;&gt; I suggest we add the following method to Dictionary:<br>&gt;&gt; <br>&gt;&gt; extension Dictionary {<br>&gt;&gt;      public func mapValues&lt;T&gt;(_ transform: @noescape (Value) throws -&gt; T) rethrows -&gt; [Key: T] {<br>&gt;&gt;        var transformed: [Key: T] = [:]<br>&gt;&gt;        for (key, value) in self {<br>&gt;&gt;            transformed[key] = try transform(value)<br>&gt;&gt;        }<br>&gt;&gt;        return transformed<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; It is modeled after Collection&#39;s `map` function, with the difference that <br>&gt;&gt; a) only values are transformed, instead of the Key,Value tuple and <br>&gt;&gt; b) the returned structure is a transformed Dictionary [Key:T], instead of [T]<br>&gt;&gt; <br>&gt;&gt; This now allows a much nicer workflow:<br>&gt;&gt; <br>&gt;&gt; let repos: [String: JSON] = ...<br>&gt;&gt; var sizes = repos.mapValues { $0[&quot;size&quot;].int }<br>&gt;&gt; // use sizes...<br>&gt;&gt; <br>&gt;&gt; and even multi-step transformations on Dictionaries, previously only possible on Arrays, e.g. <br>&gt;&gt; var descriptionTextLengths = repos.mapValues { $0[&quot;description&quot;].string }.mapValues { $0.characters.count }<br>&gt;&gt; <br>&gt;&gt; You get the idea.<br>&gt;&gt; <br>&gt;&gt; What do you think? I welcome all feedback, I&#39;d like to see if people would support it before I write a proper proposal.<br>&gt;&gt; <br>&gt;&gt; Thanks! :)<br>&gt;&gt; Honza Dvorsky<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>May 21, 2016 at 02:00:00pm</p></header><div class="content"><p>While I agree that it&#39;d be nice to add a Map abstraction into which we<br>could move a lot of the Dictionary-ness, my original pitch is *just* about<br>adding the specific implementation of `mapValues` in its regular, non-lazy<br>form. My example was about only keeping a subset of the information in<br>memory in a Dictionary to allow for quick and frequent access (lazy goes<br>against that). I think it&#39;d be better to get that in first, or at least<br>evaluate that separately from a comprehensive refactoring of the<br>Dictionary, which would just accumulate more opinions and slow this<br>specific step down.<br></p><p>If one of you have specific ideas about the potential Map protocol, I<br>encourage you to start a separate thread for that, to focus the<br>conversation on the parameters of what it would look like.<br></p><p>I guess I&#39;m now asking - would you support a proposal for adding the basic<br>mapValues function as the first step, with the potential extendability to a<br>Map protocol allowing for a lazy version? Because I&#39;d like to keep the<br>proposal as focused as possible to increase the chance of an on-point<br>discussion.<br></p><p>Thanks,<br>Honza<br></p><p><br>On Sat, May 21, 2016 at 3:27 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; &gt; On May 21, 2016, at 8:45 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think that before this can be done there needs to be an abstraction of<br>&gt; what a Dictionary is, for example a Map&lt;Key, Value&gt; protocol. This would<br>&gt; allow us to also implement the important lazy variations of what you<br>&gt; suggest, which would likely be more important for very large dictionaries<br>&gt; as dictionaries are rarely consumed in their entirety; in other words,<br>&gt; calculating and storing the transformed value for every key/value pair is<br>&gt; quite a performance overhead if only a fraction of those keys may actually<br>&gt; be accessed. Even if you are consuming the whole transformed dictionary the<br>&gt; lazy version is better since it doesn’t store any intermediate values, you<br>&gt; only really want a fully transformed dictionary if you know the<br>&gt; transformation is either very costly, or transformed values will be<br>&gt; accessed frequently.<br>&gt; &gt;<br>&gt; &gt; Anyway, long way of saying that while the specific implementation is<br>&gt; definitely wanted, the complete solution requires a few extra steps which<br>&gt; should be done too, as lazy computation can have big performance benefits.<br>&gt; &gt;<br>&gt; &gt; That and it’d be nice to have a Map protocol in stdlib for defining<br>&gt; other map types, such as trees, since these don’t require Hashable keys,<br>&gt; but dictionaries do.<br>&gt;<br>&gt; +1 to defining map abstractions in the standard library (separating read<br>&gt; only from read write).  The value associatedtype should not take a position<br>&gt; on optionality, allowing for maps which have a valid value for all possible<br>&gt; keys.  I have done similar things in other languages and found it extremely<br>&gt; useful.  It is not uncommon to have code that just needs to read and / or<br>&gt; write to / from a map without having concern for the implementation of the<br>&gt; map.<br>&gt;<br>&gt; One issue I think we should sort out along side this is some kind of<br>&gt; abstraction which allows code to use functions or user-defined types<br>&gt; without regard for which it is accessing.  The map abstraction would build<br>&gt; on this abstraction, allowing single argument functions to be viewed as a<br>&gt; read only map.<br>&gt;<br>&gt; One option is to allow functions to conform to protocols that only have<br>&gt; subscript { get } requirements (we would probably only allow them to be<br>&gt; subscripted through the protocol interface).  I think this feels like the<br>&gt; most Swifty direction.<br>&gt;<br>&gt; Another option is to take the path I have seen in several languages which<br>&gt; is to allow overloading of the function call &quot;operator&quot;.  I originally<br>&gt; wanted this in Swift but now wonder if the first option might be a better<br>&gt; way to accomplish the same goals.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;  On 21 May 2016, at 11:27, Honza Dvorsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hello everyone,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I have added a very simple, but powerful method into a Dictionary<br>&gt; extension on multiple projects in the last weeks, so I&#39;d like to bring up<br>&gt; the idea of adding it into the standard library, in case other people can<br>&gt; see its benefits as well.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Currently, Dictionary conforms to Collection with its Element being the<br>&gt; tuple of Key and Value. Thus transforming the Dictionary with regular map<br>&gt; results in [T], whereas I&#39;d find it more useful to also have a method which<br>&gt; results in [Key:T].<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Let me present an example of where this makes sense.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I recently used the GitHub API to crawl some information about<br>&gt; repositories. I started with just names (e.g. &quot;/apple/swift&quot;,<br>&gt; &quot;/apple/llvm&quot;) and fetched a JSON response for each of the repos, each<br>&gt; returning a dictionary, which got saved into one large dictionary as the<br>&gt; end of the full operation, keyed by its name, so the structure was<br>&gt; something like<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; {<br>&gt; &gt;&gt;  &quot;/apple/swift&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt; &gt;&gt;  &quot;/apple/llvm&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt; &gt;&gt;  ...<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; To perform analysis, I just needed a dictionary mapping the name of the<br>&gt; repository to its size, freeing me to discard the rest of the results.<br>&gt; &gt;&gt; This is where things get interesting, because you can&#39;t keep this<br>&gt; action nicely functional anymore. I had to do the following:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let repos: [String: JSON] = ...<br>&gt; &gt;&gt; var sizes: [String: Int] = [:]<br>&gt; &gt;&gt; for (key, value) in repos {<br>&gt; &gt;&gt;  sizes[key] = value[&quot;size&quot;].int<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; // use sizes...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Which isn&#39;t a huge amount of work, but it creates unnecessary mutable<br>&gt; state in your transformation pipeline (and your current scope). And I had<br>&gt; to write it enough times to justify bringing it up on this list.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I suggest we add the following method to Dictionary:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension Dictionary {<br>&gt; &gt;&gt;      public func mapValues&lt;T&gt;(_ transform: @noescape (Value) throws -&gt;<br>&gt; T) rethrows -&gt; [Key: T] {<br>&gt; &gt;&gt;        var transformed: [Key: T] = [:]<br>&gt; &gt;&gt;        for (key, value) in self {<br>&gt; &gt;&gt;            transformed[key] = try transform(value)<br>&gt; &gt;&gt;        }<br>&gt; &gt;&gt;        return transformed<br>&gt; &gt;&gt;    }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It is modeled after Collection&#39;s `map` function, with the difference<br>&gt; that<br>&gt; &gt;&gt; a) only values are transformed, instead of the Key,Value tuple and<br>&gt; &gt;&gt; b) the returned structure is a transformed Dictionary [Key:T], instead<br>&gt; of [T]<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This now allows a much nicer workflow:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let repos: [String: JSON] = ...<br>&gt; &gt;&gt; var sizes = repos.mapValues { $0[&quot;size&quot;].int }<br>&gt; &gt;&gt; // use sizes...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and even multi-step transformations on Dictionaries, previously only<br>&gt; possible on Arrays, e.g.<br>&gt; &gt;&gt; var descriptionTextLengths = repos.mapValues { $0[&quot;description&quot;].string<br>&gt; }.mapValues { $0.characters.count }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You get the idea.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What do you think? I welcome all feedback, I&#39;d like to see if people<br>&gt; would support it before I write a proper proposal.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thanks! :)<br>&gt; &gt;&gt; Honza Dvorsky<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/cfb93089/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 21, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 21, 2016, at 9:47 AM, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt; <br>&gt; While I agree that it&#39;d be nice to add a Map abstraction into which we could move a lot of the Dictionary-ness, my original pitch is *just* about adding the specific implementation of `mapValues` in its regular, non-lazy form. My example was about only keeping a subset of the information in memory in a Dictionary to allow for quick and frequent access (lazy goes against that). I think it&#39;d be better to get that in first, or at least evaluate that separately from a comprehensive refactoring of the Dictionary, which would just accumulate more opinions and slow this specific step down.<br>&gt; <br>&gt; If one of you have specific ideas about the potential Map protocol, I encourage you to start a separate thread for that, to focus the conversation on the parameters of what it would look like.<br>&gt; <br>&gt; I guess I&#39;m now asking - would you support a proposal for adding the basic mapValues function as the first step, with the potential extendability to a Map protocol allowing for a lazy version? Because I&#39;d like to keep the proposal as focused as possible to increase the chance of an on-point discussion.<br></p><p>Yeah, sorry for the digression.  I would support it.  I don&#39;t think we&#39;ll see the Map abstraction is Swift 3 and it would be very useful on its own.<br></p><p>&gt; <br>&gt; Thanks,<br>&gt; Honza<br>&gt; <br>&gt; <br>&gt;&gt; On Sat, May 21, 2016 at 3:27 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; &gt; On May 21, 2016, at 8:45 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think that before this can be done there needs to be an abstraction of what a Dictionary is, for example a Map&lt;Key, Value&gt; protocol. This would allow us to also implement the important lazy variations of what you suggest, which would likely be more important for very large dictionaries as dictionaries are rarely consumed in their entirety; in other words, calculating and storing the transformed value for every key/value pair is quite a performance overhead if only a fraction of those keys may actually be accessed. Even if you are consuming the whole transformed dictionary the lazy version is better since it doesn’t store any intermediate values, you only really want a fully transformed dictionary if you know the transformation is either very costly, or transformed values will be accessed frequently.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Anyway, long way of saying that while the specific implementation is definitely wanted, the complete solution requires a few extra steps which should be done too, as lazy computation can have big performance benefits.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That and it’d be nice to have a Map protocol in stdlib for defining other map types, such as trees, since these don’t require Hashable keys, but dictionaries do.<br>&gt;&gt; <br>&gt;&gt; +1 to defining map abstractions in the standard library (separating read only from read write).  The value associatedtype should not take a position on optionality, allowing for maps which have a valid value for all possible keys.  I have done similar things in other languages and found it extremely useful.  It is not uncommon to have code that just needs to read and / or write to / from a map without having concern for the implementation of the map.<br>&gt;&gt; <br>&gt;&gt; One issue I think we should sort out along side this is some kind of abstraction which allows code to use functions or user-defined types without regard for which it is accessing.  The map abstraction would build on this abstraction, allowing single argument functions to be viewed as a read only map.<br>&gt;&gt; <br>&gt;&gt; One option is to allow functions to conform to protocols that only have subscript { get } requirements (we would probably only allow them to be subscripted through the protocol interface).  I think this feels like the most Swifty direction.<br>&gt;&gt; <br>&gt;&gt; Another option is to take the path I have seen in several languages which is to allow overloading of the function call &quot;operator&quot;.  I originally wanted this in Swift but now wonder if the first option might be a better way to accomplish the same goals.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;  On 21 May 2016, at 11:27, Honza Dvorsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I have added a very simple, but powerful method into a Dictionary extension on multiple projects in the last weeks, so I&#39;d like to bring up the idea of adding it into the standard library, in case other people can see its benefits as well.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Currently, Dictionary conforms to Collection with its Element being the tuple of Key and Value. Thus transforming the Dictionary with regular map results in [T], whereas I&#39;d find it more useful to also have a method which results in [Key:T].<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Let me present an example of where this makes sense.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I recently used the GitHub API to crawl some information about repositories. I started with just names (e.g. &quot;/apple/swift&quot;, &quot;/apple/llvm&quot;) and fetched a JSON response for each of the repos, each returning a dictionary, which got saved into one large dictionary as the end of the full operation, keyed by its name, so the structure was something like<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; {<br>&gt;&gt; &gt;&gt;  &quot;/apple/swift&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt;&gt; &gt;&gt;  &quot;/apple/llvm&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt;&gt; &gt;&gt;  ...<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; To perform analysis, I just needed a dictionary mapping the name of the repository to its size, freeing me to discard the rest of the results.<br>&gt;&gt; &gt;&gt; This is where things get interesting, because you can&#39;t keep this action nicely functional anymore. I had to do the following:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let repos: [String: JSON] = ...<br>&gt;&gt; &gt;&gt; var sizes: [String: Int] = [:]<br>&gt;&gt; &gt;&gt; for (key, value) in repos {<br>&gt;&gt; &gt;&gt;  sizes[key] = value[&quot;size&quot;].int<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; // use sizes...<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Which isn&#39;t a huge amount of work, but it creates unnecessary mutable state in your transformation pipeline (and your current scope). And I had to write it enough times to justify bringing it up on this list.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I suggest we add the following method to Dictionary:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; extension Dictionary {<br>&gt;&gt; &gt;&gt;      public func mapValues&lt;T&gt;(_ transform: @noescape (Value) throws -&gt; T) rethrows -&gt; [Key: T] {<br>&gt;&gt; &gt;&gt;        var transformed: [Key: T] = [:]<br>&gt;&gt; &gt;&gt;        for (key, value) in self {<br>&gt;&gt; &gt;&gt;            transformed[key] = try transform(value)<br>&gt;&gt; &gt;&gt;        }<br>&gt;&gt; &gt;&gt;        return transformed<br>&gt;&gt; &gt;&gt;    }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; It is modeled after Collection&#39;s `map` function, with the difference that<br>&gt;&gt; &gt;&gt; a) only values are transformed, instead of the Key,Value tuple and<br>&gt;&gt; &gt;&gt; b) the returned structure is a transformed Dictionary [Key:T], instead of [T]<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This now allows a much nicer workflow:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let repos: [String: JSON] = ...<br>&gt;&gt; &gt;&gt; var sizes = repos.mapValues { $0[&quot;size&quot;].int }<br>&gt;&gt; &gt;&gt; // use sizes...<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; and even multi-step transformations on Dictionaries, previously only possible on Arrays, e.g.<br>&gt;&gt; &gt;&gt; var descriptionTextLengths = repos.mapValues { $0[&quot;description&quot;].string }.mapValues { $0.characters.count }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; You get the idea.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; What do you think? I welcome all feedback, I&#39;d like to see if people would support it before I write a proper proposal.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Thanks! :)<br>&gt;&gt; &gt;&gt; Honza Dvorsky<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/c718a9f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>May 21, 2016 at 03:00:00pm</p></header><div class="content"><p>Great! And FWIW I thought the same thing, the Map abstraction might be a<br>too large of a task at this time (but I&#39;ll definitely support it if it<br>eventually comes up).<br></p><p>On Sat, May 21, 2016 at 3:54 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 21, 2016, at 9:47 AM, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt;<br>&gt; While I agree that it&#39;d be nice to add a Map abstraction into which we<br>&gt; could move a lot of the Dictionary-ness, my original pitch is *just* about<br>&gt; adding the specific implementation of `mapValues` in its regular, non-lazy<br>&gt; form. My example was about only keeping a subset of the information in<br>&gt; memory in a Dictionary to allow for quick and frequent access (lazy goes<br>&gt; against that). I think it&#39;d be better to get that in first, or at least<br>&gt; evaluate that separately from a comprehensive refactoring of the<br>&gt; Dictionary, which would just accumulate more opinions and slow this<br>&gt; specific step down.<br>&gt;<br>&gt; If one of you have specific ideas about the potential Map protocol, I<br>&gt; encourage you to start a separate thread for that, to focus the<br>&gt; conversation on the parameters of what it would look like.<br>&gt;<br>&gt; I guess I&#39;m now asking - would you support a proposal for adding the basic<br>&gt; mapValues function as the first step, with the potential extendability to a<br>&gt; Map protocol allowing for a lazy version? Because I&#39;d like to keep the<br>&gt; proposal as focused as possible to increase the chance of an on-point<br>&gt; discussion.<br>&gt;<br>&gt;<br>&gt; Yeah, sorry for the digression.  I would support it.  I don&#39;t think we&#39;ll<br>&gt; see the Map abstraction is Swift 3 and it would be very useful on its own.<br>&gt;<br>&gt;<br>&gt; Thanks,<br>&gt; Honza<br>&gt;<br>&gt;<br>&gt; On Sat, May 21, 2016 at 3:27 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; &gt; On May 21, 2016, at 8:45 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think that before this can be done there needs to be an abstraction<br>&gt;&gt; of what a Dictionary is, for example a Map&lt;Key, Value&gt; protocol. This would<br>&gt;&gt; allow us to also implement the important lazy variations of what you<br>&gt;&gt; suggest, which would likely be more important for very large dictionaries<br>&gt;&gt; as dictionaries are rarely consumed in their entirety; in other words,<br>&gt;&gt; calculating and storing the transformed value for every key/value pair is<br>&gt;&gt; quite a performance overhead if only a fraction of those keys may actually<br>&gt;&gt; be accessed. Even if you are consuming the whole transformed dictionary the<br>&gt;&gt; lazy version is better since it doesn’t store any intermediate values, you<br>&gt;&gt; only really want a fully transformed dictionary if you know the<br>&gt;&gt; transformation is either very costly, or transformed values will be<br>&gt;&gt; accessed frequently.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Anyway, long way of saying that while the specific implementation is<br>&gt;&gt; definitely wanted, the complete solution requires a few extra steps which<br>&gt;&gt; should be done too, as lazy computation can have big performance benefits.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That and it’d be nice to have a Map protocol in stdlib for defining<br>&gt;&gt; other map types, such as trees, since these don’t require Hashable keys,<br>&gt;&gt; but dictionaries do.<br>&gt;&gt;<br>&gt;&gt; +1 to defining map abstractions in the standard library (separating read<br>&gt;&gt; only from read write).  The value associatedtype should not take a position<br>&gt;&gt; on optionality, allowing for maps which have a valid value for all possible<br>&gt;&gt; keys.  I have done similar things in other languages and found it extremely<br>&gt;&gt; useful.  It is not uncommon to have code that just needs to read and / or<br>&gt;&gt; write to / from a map without having concern for the implementation of the<br>&gt;&gt; map.<br>&gt;&gt;<br>&gt;&gt; One issue I think we should sort out along side this is some kind of<br>&gt;&gt; abstraction which allows code to use functions or user-defined types<br>&gt;&gt; without regard for which it is accessing.  The map abstraction would build<br>&gt;&gt; on this abstraction, allowing single argument functions to be viewed as a<br>&gt;&gt; read only map.<br>&gt;&gt;<br>&gt;&gt; One option is to allow functions to conform to protocols that only have<br>&gt;&gt; subscript { get } requirements (we would probably only allow them to be<br>&gt;&gt; subscripted through the protocol interface).  I think this feels like the<br>&gt;&gt; most Swifty direction.<br>&gt;&gt;<br>&gt;&gt; Another option is to take the path I have seen in several languages which<br>&gt;&gt; is to allow overloading of the function call &quot;operator&quot;.  I originally<br>&gt;&gt; wanted this in Swift but now wonder if the first option might be a better<br>&gt;&gt; way to accomplish the same goals.<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;  On 21 May 2016, at 11:27, Honza Dvorsky via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Hello everyone,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I have added a very simple, but powerful method into a Dictionary<br>&gt;&gt; extension on multiple projects in the last weeks, so I&#39;d like to bring up<br>&gt;&gt; the idea of adding it into the standard library, in case other people can<br>&gt;&gt; see its benefits as well.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Currently, Dictionary conforms to Collection with its Element being<br>&gt;&gt; the tuple of Key and Value. Thus transforming the Dictionary with regular<br>&gt;&gt; map results in [T], whereas I&#39;d find it more useful to also have a method<br>&gt;&gt; which results in [Key:T].<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Let me present an example of where this makes sense.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I recently used the GitHub API to crawl some information about<br>&gt;&gt; repositories. I started with just names (e.g. &quot;/apple/swift&quot;,<br>&gt;&gt; &quot;/apple/llvm&quot;) and fetched a JSON response for each of the repos, each<br>&gt;&gt; returning a dictionary, which got saved into one large dictionary as the<br>&gt;&gt; end of the full operation, keyed by its name, so the structure was<br>&gt;&gt; something like<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; {<br>&gt;&gt; &gt;&gt;  &quot;/apple/swift&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt;&gt; &gt;&gt;  &quot;/apple/llvm&quot;: { &quot;url&quot;:..., &quot;size&quot;:...., &quot;homepage&quot;:... },<br>&gt;&gt; &gt;&gt;  ...<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; To perform analysis, I just needed a dictionary mapping the name of<br>&gt;&gt; the repository to its size, freeing me to discard the rest of the results.<br>&gt;&gt; &gt;&gt; This is where things get interesting, because you can&#39;t keep this<br>&gt;&gt; action nicely functional anymore. I had to do the following:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let repos: [String: JSON] = ...<br>&gt;&gt; &gt;&gt; var sizes: [String: Int] = [:]<br>&gt;&gt; &gt;&gt; for (key, value) in repos {<br>&gt;&gt; &gt;&gt;  sizes[key] = value[&quot;size&quot;].int<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; // use sizes...<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Which isn&#39;t a huge amount of work, but it creates unnecessary mutable<br>&gt;&gt; state in your transformation pipeline (and your current scope). And I had<br>&gt;&gt; to write it enough times to justify bringing it up on this list.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I suggest we add the following method to Dictionary:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; extension Dictionary {<br>&gt;&gt; &gt;&gt;      public func mapValues&lt;T&gt;(_ transform: @noescape (Value) throws -&gt;<br>&gt;&gt; T) rethrows -&gt; [Key: T] {<br>&gt;&gt; &gt;&gt;        var transformed: [Key: T] = [:]<br>&gt;&gt; &gt;&gt;        for (key, value) in self {<br>&gt;&gt; &gt;&gt;            transformed[key] = try transform(value)<br>&gt;&gt; &gt;&gt;        }<br>&gt;&gt; &gt;&gt;        return transformed<br>&gt;&gt; &gt;&gt;    }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; It is modeled after Collection&#39;s `map` function, with the difference<br>&gt;&gt; that<br>&gt;&gt; &gt;&gt; a) only values are transformed, instead of the Key,Value tuple and<br>&gt;&gt; &gt;&gt; b) the returned structure is a transformed Dictionary [Key:T], instead<br>&gt;&gt; of [T]<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This now allows a much nicer workflow:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let repos: [String: JSON] = ...<br>&gt;&gt; &gt;&gt; var sizes = repos.mapValues { $0[&quot;size&quot;].int }<br>&gt;&gt; &gt;&gt; // use sizes...<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; and even multi-step transformations on Dictionaries, previously only<br>&gt;&gt; possible on Arrays, e.g.<br>&gt;&gt; &gt;&gt; var descriptionTextLengths = repos.mapValues {<br>&gt;&gt; $0[&quot;description&quot;].string }.mapValues { $0.characters.count }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; You get the idea.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; What do you think? I welcome all feedback, I&#39;d like to see if people<br>&gt;&gt; would support it before I write a proper proposal.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Thanks! :)<br>&gt;&gt; &gt;&gt; Honza Dvorsky<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/e016fa77/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 21, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 21 May 2016, at 15:47, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt; <br>&gt; While I agree that it&#39;d be nice to add a Map abstraction into which we could move a lot of the Dictionary-ness, my original pitch is *just* about adding the specific implementation of `mapValues` in its regular, non-lazy form. My example was about only keeping a subset of the information in memory in a Dictionary to allow for quick and frequent access (lazy goes against that). I think it&#39;d be better to get that in first, or at least evaluate that separately from a comprehensive refactoring of the Dictionary, which would just accumulate more opinions and slow this specific step down.<br></p><p>Sorry, my point was that I think it’s better to wait until we can also do the lazy equivalent and have both done together, otherwise we end up with one map function that can work both lazily and one that never does. Sure that will require a refactoring into a protocol, but it seems to me that it’s better to do that as the first step, then add the feature after that. In the mean time extensions have you well covered for convenience.<br></p><p>Another alternative to this feature might be to add a key/value pair constructor to Dictionary (it technically already has one, but it’s variadic only) so you could do something like this:<br></p><p>	let myTransformedDictionary = Dictionary(myIntegerDictionary.lazy.map { ($0, $1 + 5) })<br></p><p>Since this would be a useful initialiser both now and in future. I dunno, it’s just my opinion, but I find it a bit weird to get half the implementation now, and could lead to misunderstandings with people trying to do myMap.lazy.mapValues (won’t be recognised) and wondering why there isn’t one.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/cbfcb895/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>May 21, 2016 at 07:00:00pm</p></header><div class="content"><p>I see your point, I agree it would definitely be nicer to have both<br>variants, but is that a rule that *all* methods on Collection and<br>Dictionary etc also have lazy variants? I actually don&#39;t know (please tell<br>me if you do).<br></p><p>The question here is not really whether to add a lazy variant later (I<br>don&#39;t think anyone would object to that), but as that would require quite<br>substantial refactoring and abstraction change into a Map protocol (which<br>will definitely gather a lot of feedback and could drag on for months), I<br>don&#39;t see why we can&#39;t add the regular variant already and benefit from it<br>now. Another option is that there won&#39;t be demand for the lazy variant, in<br>which case it makes even less sense to block the regular variant right now<br>(and could even hurt this proposal).<br></p><p>Maybe I&#39;m missing some information about the core team requiring always<br>adding both non-lazy and lazy variants, if so, please do tell me so that I<br>can re-evaluate my approach. If not, I&#39;d like to keep the thread focused<br>strictly on the one method I&#39;m proposing we add, for the benefits and<br>examples I provided.<br></p><p>The Dictionary initializers could slightly help things, but it&#39;d require<br>nesting if you do more than one level, whereas `mapValues` would allow for<br>multiple transformations to be applied in sequence without additional<br>nesting (my example from the original pitch would turn into `var<br>descriptionTextLengths = Dictionary(Dictionary(repos.mapValues {<br>$0[&quot;description&quot;].string }).mapValues { $0.characters.count })` which is<br>much uglier in my opinion (and kind of breaks the natural left-to-right<br>composition).<br></p><p>On Sat, May 21, 2016 at 8:01 PM Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On 21 May 2016, at 15:47, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt;<br>&gt; While I agree that it&#39;d be nice to add a Map abstraction into which we<br>&gt; could move a lot of the Dictionary-ness, my original pitch is *just* about<br>&gt; adding the specific implementation of `mapValues` in its regular, non-lazy<br>&gt; form. My example was about only keeping a subset of the information in<br>&gt; memory in a Dictionary to allow for quick and frequent access (lazy goes<br>&gt; against that). I think it&#39;d be better to get that in first, or at least<br>&gt; evaluate that separately from a comprehensive refactoring of the<br>&gt; Dictionary, which would just accumulate more opinions and slow this<br>&gt; specific step down.<br>&gt;<br>&gt;<br>&gt; Sorry, my point was that I think it’s better to wait until we can also do<br>&gt; the lazy equivalent and have both done together, otherwise we end up with<br>&gt; one map function that can work both lazily and one that never does. Sure<br>&gt; that will require a refactoring into a protocol, but it seems to me that<br>&gt; it’s better to do that as the first step, then add the feature after that.<br>&gt; In the mean time extensions have you well covered for convenience.<br>&gt;<br>&gt; Another alternative to this feature might be to add a key/value pair<br>&gt; constructor to Dictionary (it technically already has one, but it’s<br>&gt; variadic only) so you could do something like this:<br>&gt;<br>&gt; let myTransformedDictionary = Dictionary(myIntegerDictionary.lazy.map {<br>&gt; ($0, $1 + 5) })<br>&gt;<br>&gt; Since this would be a useful initialiser both now and in future. I dunno,<br>&gt; it’s just my opinion, but I find it a bit weird to get half the<br>&gt; implementation now, and could lead to misunderstandings with people trying<br>&gt; to do myMap.lazy.mapValues (won’t be recognised) and wondering why there<br>&gt; isn’t one.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/24b5bfdd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>May 21, 2016 at 08:00:00pm</p></header><div class="content"><p>Correct me if I&#39;m wrong, but isn&#39;t part of the goal of lazy collections to<br>be able to prefix a whole chain of operations with .lazy and have it still<br>compile (and be more efficient)? If so, then the core team would probably<br>want both variants in the standard library.<br>On Sat, May 21, 2016 at 12:16 PM Honza Dvorsky via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I see your point, I agree it would definitely be nicer to have both<br>&gt; variants, but is that a rule that *all* methods on Collection and<br>&gt; Dictionary etc also have lazy variants? I actually don&#39;t know (please tell<br>&gt; me if you do).<br>&gt;<br>&gt; The question here is not really whether to add a lazy variant later (I<br>&gt; don&#39;t think anyone would object to that), but as that would require quite<br>&gt; substantial refactoring and abstraction change into a Map protocol (which<br>&gt; will definitely gather a lot of feedback and could drag on for months), I<br>&gt; don&#39;t see why we can&#39;t add the regular variant already and benefit from it<br>&gt; now. Another option is that there won&#39;t be demand for the lazy variant, in<br>&gt; which case it makes even less sense to block the regular variant right now<br>&gt; (and could even hurt this proposal).<br>&gt;<br>&gt; Maybe I&#39;m missing some information about the core team requiring always<br>&gt; adding both non-lazy and lazy variants, if so, please do tell me so that I<br>&gt; can re-evaluate my approach. If not, I&#39;d like to keep the thread focused<br>&gt; strictly on the one method I&#39;m proposing we add, for the benefits and<br>&gt; examples I provided.<br>&gt;<br>&gt; The Dictionary initializers could slightly help things, but it&#39;d require<br>&gt; nesting if you do more than one level, whereas `mapValues` would allow for<br>&gt; multiple transformations to be applied in sequence without additional<br>&gt; nesting (my example from the original pitch would turn into `var<br>&gt; descriptionTextLengths = Dictionary(Dictionary(repos.mapValues {<br>&gt; $0[&quot;description&quot;].string }).mapValues { $0.characters.count })` which is<br>&gt; much uglier in my opinion (and kind of breaks the natural left-to-right<br>&gt; composition).<br>&gt;<br>&gt; On Sat, May 21, 2016 at 8:01 PM Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 21 May 2016, at 15:47, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; While I agree that it&#39;d be nice to add a Map abstraction into which we<br>&gt;&gt; could move a lot of the Dictionary-ness, my original pitch is *just* about<br>&gt;&gt; adding the specific implementation of `mapValues` in its regular, non-lazy<br>&gt;&gt; form. My example was about only keeping a subset of the information in<br>&gt;&gt; memory in a Dictionary to allow for quick and frequent access (lazy goes<br>&gt;&gt; against that). I think it&#39;d be better to get that in first, or at least<br>&gt;&gt; evaluate that separately from a comprehensive refactoring of the<br>&gt;&gt; Dictionary, which would just accumulate more opinions and slow this<br>&gt;&gt; specific step down.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sorry, my point was that I think it’s better to wait until we can also do<br>&gt;&gt; the lazy equivalent and have both done together, otherwise we end up with<br>&gt;&gt; one map function that can work both lazily and one that never does. Sure<br>&gt;&gt; that will require a refactoring into a protocol, but it seems to me that<br>&gt;&gt; it’s better to do that as the first step, then add the feature after that.<br>&gt;&gt; In the mean time extensions have you well covered for convenience.<br>&gt;&gt;<br>&gt;&gt; Another alternative to this feature might be to add a key/value pair<br>&gt;&gt; constructor to Dictionary (it technically already has one, but it’s<br>&gt;&gt; variadic only) so you could do something like this:<br>&gt;&gt;<br>&gt;&gt; let myTransformedDictionary = Dictionary(myIntegerDictionary.lazy.map {<br>&gt;&gt; ($0, $1 + 5) })<br>&gt;&gt;<br>&gt;&gt; Since this would be a useful initialiser both now and in future. I dunno,<br>&gt;&gt; it’s just my opinion, but I find it a bit weird to get half the<br>&gt;&gt; implementation now, and could lead to misunderstandings with people trying<br>&gt;&gt; to do myMap.lazy.mapValues (won’t be recognised) and wondering why there<br>&gt;&gt; isn’t one.<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/005da84e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>May 21, 2016 at 08:00:00pm</p></header><div class="content"><p>That&#39;s the part that I don&#39;t know, would encourage anyone who has a link of<br>that being said (or anyone from the core team) to step in here. Obviously<br>if it&#39;s required to have a lazy variant for all collection methods, I&#39;d<br>probably pull back this proposal, as it would automatically be rejected by<br>the core team. (But I hope it&#39;s not the case, as that means there&#39;s a<br>pretty high barrier of entry for adding more convenience methods to the<br>stdlib).<br></p><p>On Sat, May 21, 2016 at 9:11 PM Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br></p><p>&gt; Correct me if I&#39;m wrong, but isn&#39;t part of the goal of lazy collections to<br>&gt; be able to prefix a whole chain of operations with .lazy and have it still<br>&gt; compile (and be more efficient)? If so, then the core team would probably<br>&gt; want both variants in the standard library.<br>&gt; On Sat, May 21, 2016 at 12:16 PM Honza Dvorsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I see your point, I agree it would definitely be nicer to have both<br>&gt;&gt; variants, but is that a rule that *all* methods on Collection and<br>&gt;&gt; Dictionary etc also have lazy variants? I actually don&#39;t know (please tell<br>&gt;&gt; me if you do).<br>&gt;&gt;<br>&gt;&gt; The question here is not really whether to add a lazy variant later (I<br>&gt;&gt; don&#39;t think anyone would object to that), but as that would require quite<br>&gt;&gt; substantial refactoring and abstraction change into a Map protocol (which<br>&gt;&gt; will definitely gather a lot of feedback and could drag on for months), I<br>&gt;&gt; don&#39;t see why we can&#39;t add the regular variant already and benefit from it<br>&gt;&gt; now. Another option is that there won&#39;t be demand for the lazy variant, in<br>&gt;&gt; which case it makes even less sense to block the regular variant right now<br>&gt;&gt; (and could even hurt this proposal).<br>&gt;&gt;<br>&gt;&gt; Maybe I&#39;m missing some information about the core team requiring always<br>&gt;&gt; adding both non-lazy and lazy variants, if so, please do tell me so that I<br>&gt;&gt; can re-evaluate my approach. If not, I&#39;d like to keep the thread focused<br>&gt;&gt; strictly on the one method I&#39;m proposing we add, for the benefits and<br>&gt;&gt; examples I provided.<br>&gt;&gt;<br>&gt;&gt; The Dictionary initializers could slightly help things, but it&#39;d require<br>&gt;&gt; nesting if you do more than one level, whereas `mapValues` would allow for<br>&gt;&gt; multiple transformations to be applied in sequence without additional<br>&gt;&gt; nesting (my example from the original pitch would turn into `var<br>&gt;&gt; descriptionTextLengths = Dictionary(Dictionary(repos.mapValues {<br>&gt;&gt; $0[&quot;description&quot;].string }).mapValues { $0.characters.count })` which is<br>&gt;&gt; much uglier in my opinion (and kind of breaks the natural left-to-right<br>&gt;&gt; composition).<br>&gt;&gt;<br>&gt;&gt; On Sat, May 21, 2016 at 8:01 PM Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 21 May 2016, at 15:47, Honza Dvorsky &lt;jan.dvorsky at me.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While I agree that it&#39;d be nice to add a Map abstraction into which we<br>&gt;&gt;&gt; could move a lot of the Dictionary-ness, my original pitch is *just* about<br>&gt;&gt;&gt; adding the specific implementation of `mapValues` in its regular, non-lazy<br>&gt;&gt;&gt; form. My example was about only keeping a subset of the information in<br>&gt;&gt;&gt; memory in a Dictionary to allow for quick and frequent access (lazy goes<br>&gt;&gt;&gt; against that). I think it&#39;d be better to get that in first, or at least<br>&gt;&gt;&gt; evaluate that separately from a comprehensive refactoring of the<br>&gt;&gt;&gt; Dictionary, which would just accumulate more opinions and slow this<br>&gt;&gt;&gt; specific step down.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sorry, my point was that I think it’s better to wait until we can also<br>&gt;&gt;&gt; do the lazy equivalent and have both done together, otherwise we end up<br>&gt;&gt;&gt; with one map function that can work both lazily and one that never does.<br>&gt;&gt;&gt; Sure that will require a refactoring into a protocol, but it seems to me<br>&gt;&gt;&gt; that it’s better to do that as the first step, then add the feature after<br>&gt;&gt;&gt; that. In the mean time extensions have you well covered for convenience.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another alternative to this feature might be to add a key/value pair<br>&gt;&gt;&gt; constructor to Dictionary (it technically already has one, but it’s<br>&gt;&gt;&gt; variadic only) so you could do something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let myTransformedDictionary = Dictionary(myIntegerDictionary.lazy.map {<br>&gt;&gt;&gt; ($0, $1 + 5) })<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Since this would be a useful initialiser both now and in future. I<br>&gt;&gt;&gt; dunno, it’s just my opinion, but I find it a bit weird to get half the<br>&gt;&gt;&gt; implementation now, and could lead to misunderstandings with people trying<br>&gt;&gt;&gt; to do myMap.lazy.mapValues (won’t be recognised) and wondering why there<br>&gt;&gt;&gt; isn’t one.<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;<br>&gt;<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; Dan Appel<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160521/61a76107/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 21, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Obviously if it&#39;s required to have a lazy variant for all collection methods, I&#39;d probably pull back this proposal, as it would automatically be rejected by the core team.<br></p><p>I&#39;m not a member of the core team, but I doubt it&#39;s necessary.<br></p><p>I don&#39;t think it makes much sense to wait for a lazy implementation. If there *is* going to be a Map protocol, then the best way to implement it will require an advanced generics feature that&#39;s still in the proposal stages:<br></p><p>	// Note: I&#39;m simplifying signatures here.<br></p><p>	protocol Map: Collection {<br>		associatedtype Key<br>		associatedtype Value<br>		associatedtype Iterator: IteratorProtocol where Iterator.Element == (Key, Value)<br>		<br>		subscript (key: Key) -&gt; Value? { get }<br>		func mapValues&lt;T&gt;(transform: Value -&gt; T) -&gt; [Key: T]<br>	}<br></p><p>And implementing the laziness will similarly work best with not only that feature, but also conditional conformances:<br>	<br>	protocol LazyMap: Map, LazyCollectionProtocol {<br>		subscript (key: Base.Key) -&gt; Base.Value? { get }<br>		func mapValues&lt;T&gt;(transform: Value -&gt; T)(…) -&gt; LazyMappedValuesMap&lt;Base, T&gt;<br>	}<br></p><p>	extension LazyCollection: LazyMap where Base: Map {<br>		…<br>	}<br>	<br>	struct LazyMapValuesMap&lt;Base: Map, NewValue&gt;: Map {<br>		…<br>	}<br></p><p>If we *don&#39;t* wait, on the other hand, we&#39;re going to end up in manual-specification and GYB hell. (And even then, I believe conditional conformances are not enough to force all LazyCollectionProtocol conformers to support Map if they have a Map base. You&#39;d need conditional *conformance requirements*, which are *not* planned because it&#39;s not safe to add a requirement to a protocol.)<br></p><p>I just don&#39;t think laziness is so crucial that we should stop the presses until we have it. `mapValues` carries water all by itself, even without a matching `lazy.mapValues`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>May 22, 2016 at 06:00:00am</p></header><div class="content"><p>I don&#39;t understand - why do we need a map protocol for a lazy mapvalues?<br>On Sat, May 21, 2016 at 11:12 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Obviously if it&#39;s required to have a lazy variant for all collection<br>&gt; methods, I&#39;d probably pull back this proposal, as it would automatically be<br>&gt; rejected by the core team.<br>&gt;<br>&gt; I&#39;m not a member of the core team, but I doubt it&#39;s necessary.<br>&gt;<br>&gt; I don&#39;t think it makes much sense to wait for a lazy implementation. If<br>&gt; there *is* going to be a Map protocol, then the best way to implement it<br>&gt; will require an advanced generics feature that&#39;s still in the proposal<br>&gt; stages:<br>&gt;<br>&gt;         // Note: I&#39;m simplifying signatures here.<br>&gt;<br>&gt;         protocol Map: Collection {<br>&gt;                 associatedtype Key<br>&gt;                 associatedtype Value<br>&gt;                 associatedtype Iterator: IteratorProtocol where<br>&gt; Iterator.Element == (Key, Value)<br>&gt;<br>&gt;                 subscript (key: Key) -&gt; Value? { get }<br>&gt;                 func mapValues&lt;T&gt;(transform: Value -&gt; T) -&gt; [Key: T]<br>&gt;         }<br>&gt;<br>&gt; And implementing the laziness will similarly work best with not only that<br>&gt; feature, but also conditional conformances:<br>&gt;<br>&gt;         protocol LazyMap: Map, LazyCollectionProtocol {<br>&gt;                 subscript (key: Base.Key) -&gt; Base.Value? { get }<br>&gt;                 func mapValues&lt;T&gt;(transform: Value -&gt; T)(…) -&gt;<br>&gt; LazyMappedValuesMap&lt;Base, T&gt;<br>&gt;         }<br>&gt;<br>&gt;         extension LazyCollection: LazyMap where Base: Map {<br>&gt;                 …<br>&gt;         }<br>&gt;<br>&gt;         struct LazyMapValuesMap&lt;Base: Map, NewValue&gt;: Map {<br>&gt;                 …<br>&gt;         }<br>&gt;<br>&gt; If we *don&#39;t* wait, on the other hand, we&#39;re going to end up in<br>&gt; manual-specification and GYB hell. (And even then, I believe conditional<br>&gt; conformances are not enough to force all LazyCollectionProtocol conformers<br>&gt; to support Map if they have a Map base. You&#39;d need conditional *conformance<br>&gt; requirements*, which are *not* planned because it&#39;s not safe to add a<br>&gt; requirement to a protocol.)<br>&gt;<br>&gt; I just don&#39;t think laziness is so crucial that we should stop the presses<br>&gt; until we have it. `mapValues` carries water all by itself, even without a<br>&gt; matching `lazy.mapValues`.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; --<br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/79ac53a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc38aef146f886571b3c445851add884?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Honza Dvorsky</string> &lt;jan.dvorsky at me.com&gt;<p>May 22, 2016 at 09:00:00am</p></header><div class="content"><p>Please correct me if I&#39;m off here, but I quickly looked at the<br>implementation of lazy collections/sequences, and I think it&#39;s because the<br>goal is to keep the API of e.g. normal Array and a lazy Array the same, so<br>that you don&#39;t actually have to know which one you&#39;re working with. But<br>under the hood, they&#39;re very different objects, as one owns the memory of<br>its elements, whereas the lazy one goes back to the array it was created<br>with and pulls it elements (before e.g. transforming them). And as structs<br>cannot be subclassed, a lot of the functionality is implemented in default<br>functions on the protocol. So if you wanted to create a lazy version of a<br>Dictionary, which has an identical API, you&#39;d have to duplicate a lot of<br>code - unless you pull the Dictionary-ness into a protocol, make Dictionary<br>just the normal form of Dictionary, but allow a LazyDictionary under the<br>hood to pull values from a parent dictionary based on keys, transform them<br>with mapValues and return them.<br></p><p>Does that make sense? I looked at the implementation of Dictionary in the<br>stdlib yesterday, and IMO it&#39;d be a pretty huge amount of work to refactor<br>it into the Map protocol first, so I&#39;m trying to push for having a non-lazy<br>version done first, and then add the lazy version once someone proposes to<br>add the Map protocol later (otherwise this&#39;ll just get stuck here for<br>months, because I doubt the core team would be happy with making such large<br>changes for allowing one convenience method only, now that Swift 3 is being<br>stabilized).<br></p><p><br>On Sun, May 22, 2016 at 7:48 AM Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br></p><p>&gt; I don&#39;t understand - why do we need a map protocol for a lazy mapvalues?<br>&gt; On Sat, May 21, 2016 at 11:12 PM Brent Royal-Gordon &lt;<br>&gt; brent at architechies.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; Obviously if it&#39;s required to have a lazy variant for all collection<br>&gt;&gt; methods, I&#39;d probably pull back this proposal, as it would automatically be<br>&gt;&gt; rejected by the core team.<br>&gt;&gt;<br>&gt;&gt; I&#39;m not a member of the core team, but I doubt it&#39;s necessary.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think it makes much sense to wait for a lazy implementation. If<br>&gt;&gt; there *is* going to be a Map protocol, then the best way to implement it<br>&gt;&gt; will require an advanced generics feature that&#39;s still in the proposal<br>&gt;&gt; stages:<br>&gt;&gt;<br>&gt;&gt;         // Note: I&#39;m simplifying signatures here.<br>&gt;&gt;<br>&gt;&gt;         protocol Map: Collection {<br>&gt;&gt;                 associatedtype Key<br>&gt;&gt;                 associatedtype Value<br>&gt;&gt;                 associatedtype Iterator: IteratorProtocol where<br>&gt;&gt; Iterator.Element == (Key, Value)<br>&gt;&gt;<br>&gt;&gt;                 subscript (key: Key) -&gt; Value? { get }<br>&gt;&gt;                 func mapValues&lt;T&gt;(transform: Value -&gt; T) -&gt; [Key: T]<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; And implementing the laziness will similarly work best with not only that<br>&gt;&gt; feature, but also conditional conformances:<br>&gt;&gt;<br>&gt;&gt;         protocol LazyMap: Map, LazyCollectionProtocol {<br>&gt;&gt;                 subscript (key: Base.Key) -&gt; Base.Value? { get }<br>&gt;&gt;                 func mapValues&lt;T&gt;(transform: Value -&gt; T)(…) -&gt;<br>&gt;&gt; LazyMappedValuesMap&lt;Base, T&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension LazyCollection: LazyMap where Base: Map {<br>&gt;&gt;                 …<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         struct LazyMapValuesMap&lt;Base: Map, NewValue&gt;: Map {<br>&gt;&gt;                 …<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; If we *don&#39;t* wait, on the other hand, we&#39;re going to end up in<br>&gt;&gt; manual-specification and GYB hell. (And even then, I believe conditional<br>&gt;&gt; conformances are not enough to force all LazyCollectionProtocol conformers<br>&gt;&gt; to support Map if they have a Map base. You&#39;d need conditional *conformance<br>&gt;&gt; requirements*, which are *not* planned because it&#39;s not safe to add a<br>&gt;&gt; requirement to a protocol.)<br>&gt;&gt;<br>&gt;&gt; I just don&#39;t think laziness is so crucial that we should stop the presses<br>&gt;&gt; until we have it. `mapValues` carries water all by itself, even without a<br>&gt;&gt; matching `lazy.mapValues`.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; --<br>&gt; Dan Appel<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/6b828c1b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 22, 2016, at 1:12 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Obviously if it&#39;s required to have a lazy variant for all collection methods, I&#39;d probably pull back this proposal, as it would automatically be rejected by the core team.<br>&gt; <br>&gt; I&#39;m not a member of the core team, but I doubt it&#39;s necessary.<br>&gt; <br>&gt; I don&#39;t think it makes much sense to wait for a lazy implementation. If there *is* going to be a Map protocol, then the best way to implement it will require an advanced generics feature that&#39;s still in the proposal stages:<br>&gt; <br>&gt;    // Note: I&#39;m simplifying signatures here.<br>&gt; <br>&gt;    protocol Map: Collection {<br>&gt;        associatedtype Key<br>&gt;        associatedtype Value<br>&gt;        associatedtype Iterator: IteratorProtocol where Iterator.Element == (Key, Value)<br>&gt;        <br>&gt;        subscript (key: Key) -&gt; Value? { get }<br>&gt;        func mapValues&lt;T&gt;(transform: Value -&gt; T) -&gt; [Key: T]<br>&gt;    }<br></p><p>Map should not refine Collection.  We could have MapCollection (or KeyValueCollection) that refines both.  <br></p><p>protocol Map {<br>       associatedtype Key<br>       associatedtype Value<br>       subscript (key: Key) -&gt; Value { get }<br>}<br></p><p>protocol MutableMap {<br>       associatedtype Key<br>       associatedtype Value<br>       subscript (key: Key) -&gt; Value { get set }<br>}<br></p><p>There are plenty of times where you need to be able to read from (and sometimes write to) a map without needing to know anything about how the map is implemented.  A single argument function should be a valid Map (I know functions cannot conform to protocols, but I argue that they should have this ability eventually, at least protocols that only have subscript requirements). <br></p><p>Also note that Value *is not* Optional.  There are valid maps that don&#39;t return Optional.  For example, you can implement a Dictionary that takes a default value in its initializer.  The function example I just gave is another example.  Because Dictionary already defines a Value generic argument and returns &#39;Value?&#39; From the subscript we will need to either use something clunky like MapValue (which would be &#39;Value?&#39; for Dictionary) or make a change in Dictionary.  But the Map protocol *should not* make the assumption that all maps are partial.<br></p><p>&gt; <br>&gt; And implementing the laziness will similarly work best with not only that feature, but also conditional conformances:<br>&gt;    <br>&gt;    protocol LazyMap: Map, LazyCollectionProtocol {<br>&gt;        subscript (key: Base.Key) -&gt; Base.Value? { get }<br>&gt;        func mapValues&lt;T&gt;(transform: Value -&gt; T)(…) -&gt; LazyMappedValuesMap&lt;Base, T&gt;<br>&gt;    }<br>&gt; <br>&gt;    extension LazyCollection: LazyMap where Base: Map {<br>&gt;        …<br>&gt;    }<br>&gt;    <br>&gt;    struct LazyMapValuesMap&lt;Base: Map, NewValue&gt;: Map {<br>&gt;        …<br>&gt;    }<br>&gt; <br>&gt; If we *don&#39;t* wait, on the other hand, we&#39;re going to end up in manual-specification and GYB hell. (And even then, I believe conditional conformances are not enough to force all LazyCollectionProtocol conformers to support Map if they have a Map base. You&#39;d need conditional *conformance requirements*, which are *not* planned because it&#39;s not safe to add a requirement to a protocol.)<br>&gt; <br>&gt; I just don&#39;t think laziness is so crucial that we should stop the presses until we have it. `mapValues` carries water all by itself, even without a matching `lazy.mapValues`.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/23a516f0/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Add `mapValues` method to Dictionary</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 22, 2016 at 02:00:00pm</p></header><div class="content"><p>This seems like a great way to do mapValues, as you get the ability to lazily map or flatMap the pairs. I’m pretty sure a key/value pair constructor is coming to Dictionary.<br></p><p><br>&gt; On 22 May 2016, at 5:01 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 21 May 2016, at 15:47, Honza Dvorsky &lt;jan.dvorsky at me.com &lt;mailto:jan.dvorsky at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While I agree that it&#39;d be nice to add a Map abstraction into which we could move a lot of the Dictionary-ness, my original pitch is *just* about adding the specific implementation of `mapValues` in its regular, non-lazy form. My example was about only keeping a subset of the information in memory in a Dictionary to allow for quick and frequent access (lazy goes against that). I think it&#39;d be better to get that in first, or at least evaluate that separately from a comprehensive refactoring of the Dictionary, which would just accumulate more opinions and slow this specific step down.<br>&gt; <br>&gt; Sorry, my point was that I think it’s better to wait until we can also do the lazy equivalent and have both done together, otherwise we end up with one map function that can work both lazily and one that never does. Sure that will require a refactoring into a protocol, but it seems to me that it’s better to do that as the first step, then add the feature after that. In the mean time extensions have you well covered for convenience.<br>&gt; <br>&gt; Another alternative to this feature might be to add a key/value pair constructor to Dictionary (it technically already has one, but it’s variadic only) so you could do something like this:<br>&gt; <br>&gt; 	let myTransformedDictionary = Dictionary(myIntegerDictionary.lazy.map { ($0, $1 + 5) })<br>&gt; <br>&gt; Since this would be a useful initialiser both now and in future. I dunno, it’s just my opinion, but I find it a bit weird to get half the implementation now, and could lead to misunderstandings with people trying to do myMap.lazy.mapValues (won’t be recognised) and wondering why there isn’t one.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/2ed42781/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
