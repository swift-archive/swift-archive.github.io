<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d4a05714c6a4fd106a8cc2957bf5426d?s=50"></div><header><strong>SE-0062 Referencing Objective-C key-paths</strong> from <string>Les Pruszynski</string> &lt;lpruszynski at gmail.com&gt;<p>April  8, 2016 at 05:00:00am</p></header><div class="content"><p>This is my first post on this list so please bear with me.<br></p><p>I very much like this proposal but what bothers me is this doubling of valueForKeyPath(#keyPath(xxx) in the signature of the function.<br></p><p>chris.valueForKeyPath(#keyPath(Person.bestFriend.lastName)) // =&gt; Groff<br>chris.valueForKeyPath(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas&quot;]<br></p><p>I’m not sure whether the form below is actually possible. For me it reads more naturally and is more consistent with “Modern Swift” as far as I know.<br></p><p>chris.valueFor(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas”]<br>or maybe<br>chris.valueOf(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas”]<br></p><p>Just my observation.<br>Regards<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/7f078e7a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0062 Referencing Objective-C key-paths</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 12, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; I very much like this proposal but what bothers me is this doubling of valueForKeyPath(#keyPath(xxx) in the signature of the function.<br>&gt; <br>&gt; chris.valueForKeyPath(#keyPath(Person.bestFriend.lastName)) // =&gt; Groff<br>&gt; <br>&gt; chris<br>&gt; .valueForKeyPath(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas&quot;]<br>&gt; <br>&gt; I’m not sure whether the form below is actually possible. For me it reads more naturally and is more consistent with “Modern Swift” as far as I know.<br>&gt; <br>&gt; chris.valueFor(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas”]<br>&gt; or maybe<br>&gt; chris.valueOf(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas”]<br></p><p>Interesting.<br></p><p>If Foundation, Core Data, AppKit, and other frameworks properly annotated their APIs, I think we could actually get this from the already accepted SE-0033 &quot;Import Objective-C Constants as Swift Types&quot; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md&gt;. Specifically, Foundation would have to include this typedef:<br></p><p>	typedef NSString * NSKeyPath __attribute__((swift_wrapper(struct)));<br></p><p>And all APIs with string types which were actually key paths would have to be modified to use it. Then `-(nullable id)valueForKeyPath:(NSKeyPath)keyPath` would import as `func value(for: NSKeyPath) -&gt; AnyObject?`. This proposal&#39;s `#keyPath` construct would have to then construct an `NSKeyPath` instead of a `String`.<br></p><p>(To make this all work, it might make sense to add a KeyPathLiteralConvertible protocol to the standard library. As a bonus, if this protocol&#39;s initializer received enough metadata, it might be able to construct alternate forms of key paths, such as the Rails-style ones which handle arrays somewhat differently from Foundation&#39;s.)<br></p><p>This is more work, but it&#39;s also more general, which is a pretty cool prospect!<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f5a95f2923ff92903f68be6c574f9a3?s=50"></div><header><strong>SE-0062 Referencing Objective-C key-paths</strong> from <string>Christian Kienle</string> &lt;christian.kienle at rewe-digital.com&gt;<p>April 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Key-Paths do support operators and custom functions. How should this work<br>within the context of this proposal?<br></p><p>2016-04-12 11:14 GMT+02:00 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; &gt; I very much like this proposal but what bothers me is this doubling of<br>&gt; valueForKeyPath(#keyPath(xxx) in the signature of the function.<br>&gt; &gt;<br>&gt; &gt; chris.valueForKeyPath(#keyPath(Person.bestFriend.lastName)) // =&gt; Groff<br>&gt; &gt;<br>&gt; &gt; chris<br>&gt; &gt; .valueForKeyPath(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;,<br>&gt; &quot;Douglas&quot;]<br>&gt; &gt;<br>&gt; &gt; I’m not sure whether the form below is actually possible. For me it<br>&gt; reads more naturally and is more consistent with “Modern Swift” as far as I<br>&gt; know.<br>&gt; &gt;<br>&gt; &gt; chris.valueFor(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;,<br>&gt; &quot;Douglas”]<br>&gt; &gt; or maybe<br>&gt; &gt; chris.valueOf(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;,<br>&gt; &quot;Douglas”]<br>&gt;<br>&gt; Interesting.<br>&gt;<br>&gt; If Foundation, Core Data, AppKit, and other frameworks properly annotated<br>&gt; their APIs, I think we could actually get this from the already accepted<br>&gt; SE-0033 &quot;Import Objective-C Constants as Swift Types&quot; &lt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md&gt;.<br>&gt; Specifically, Foundation would have to include this typedef:<br>&gt;<br>&gt;         typedef NSString * NSKeyPath<br>&gt; __attribute__((swift_wrapper(struct)));<br>&gt;<br>&gt; And all APIs with string types which were actually key paths would have to<br>&gt; be modified to use it. Then `-(nullable<br>&gt; id)valueForKeyPath:(NSKeyPath)keyPath` would import as `func value(for:<br>&gt; NSKeyPath) -&gt; AnyObject?`. This proposal&#39;s `#keyPath` construct would have<br>&gt; to then construct an `NSKeyPath` instead of a `String`.<br>&gt;<br>&gt; (To make this all work, it might make sense to add a<br>&gt; KeyPathLiteralConvertible protocol to the standard library. As a bonus, if<br>&gt; this protocol&#39;s initializer received enough metadata, it might be able to<br>&gt; construct alternate forms of key paths, such as the Rails-style ones which<br>&gt; handle arrays somewhat differently from Foundation&#39;s.)<br>&gt;<br>&gt; This is more work, but it&#39;s also more general, which is a pretty cool<br>&gt; prospect!<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Mit freundlichen Grüßen<br></p><p>*Christian Kienle*<br>Mobile Developer<br></p><p>*REWE Digital GmbH*<br>Domstraße 20, 50668 Köln, Büro: Schanzenstr. 6-20, 51063 Köln<br>Geschäftsführer: Dr. Jean-Jacques Michel van Oosten (Vorsitzender),<br>Christoph Eltze, Dr. Johannes Steegmann, Dr. Robert Zores<br>Handelsregister: Amtsgericht Köln (HRB 78670) UST-ID-Nr.: DE 290 605 450<br></p><p>Telefon: +49 151 11441782<br>E-Mail: christian.kienle at rewe-digital.com<br>Internet: *www.rewe-digital.com &lt;http://www.rewe-digital.com/&gt;*<br></p><p>Ein Unternehmen der *REWE GROUP*<br>http://www.rewe-group.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/a7f0b20e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SE-0062 Referencing Objective-C key-paths</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 7, 2016, at 9:34 PM, Les Pruszynski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is my first post on this list so please bear with me.<br>&gt; <br>&gt; I very much like this proposal but what bothers me is this doubling of valueForKeyPath(#keyPath(xxx) in the signature of the function.<br>&gt; <br>&gt; chris.valueForKeyPath(#keyPath(Person.bestFriend.lastName)) // =&gt; Groff<br>&gt; chris.valueForKeyPath(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas&quot;]<br>&gt; <br>&gt; I’m not sure whether the form below is actually possible. For me it reads more naturally and is more consistent with “Modern Swift” as far as I know.<br>&gt; <br>&gt; chris.valueFor(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas”]<br>&gt; or maybe<br>&gt; chris.valueOf(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas”]<br>&gt; <br></p><p>If key paths were some stronger type (as Brent is suggesting), we could do this. However, because key paths are just Strings, we need to compensate for weak type information &lt;https://swift.org/documentation/api-design-guidelines/#promote-clear-usage&gt;, so valueForKeyPath should retain it’s currently name despite the redundancy in many use sites with #keyPath.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/6dc6d703/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>SE-0062 Referencing Objective-C key-paths</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>April 14, 2016 at 11:00:00am</p></header><div class="content"><p>Hi All.<br></p><p>Aeons ago, I was on the team that invented key paths. There were some pretty major performance issues:<br></p><p>- the key path had to be separated into its individual components, requiring processing time and generating a bunch of garbage<br></p><p>- the obvious thing to do would have been to parse the key path into an array of strings up front, and then simply process the key path in a loop, but this was not possible because some objects might override valueForKeyPath and be expecting to parse their own portion of the key path (and down) in some special way<br></p><p>- pre-parsing may also be problematic because key paths could contain operators like @count, or @sum, @avg, etc.<br></p><p>That being said, it would certainly be nice if the compiler pre-parsed key paths into either:<br>- key path objects<br>- arrays of strings<br>- arrays of “key” objects<br></p><p>and KVC was modified to accept these as a lower level API.<br></p><p>Perhaps it would be prudent to pull in the Foundation guys on this and get their input before implementing something on the Swift side that would be hard to take back.<br></p><p>-Kenny<br></p><p><br>&gt; On Apr 12, 2016, at 9:35 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 7, 2016, at 9:34 PM, Les Pruszynski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is my first post on this list so please bear with me.<br>&gt;&gt; <br>&gt;&gt; I very much like this proposal but what bothers me is this doubling of valueForKeyPath(#keyPath(xxx) in the signature of the function.<br>&gt;&gt; <br>&gt;&gt; chris.valueForKeyPath(#keyPath(Person.bestFriend.lastName)) // =&gt; Groff<br>&gt;&gt; <br>&gt;&gt; chris<br>&gt;&gt; .valueForKeyPath(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas&quot;]<br>&gt;&gt; <br>&gt;&gt; I’m not sure whether the form below is actually possible. For me it reads more naturally and is more consistent with “Modern Swift” as far as I know.<br>&gt;&gt; <br>&gt;&gt; chris.valueFor(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas”]<br>&gt;&gt; or maybe<br>&gt;&gt; chris.valueOf(#keyPath(Person.friends.firstName)) // =&gt; [&quot;Joe&quot;, &quot;Douglas”]<br>&gt;&gt; <br>&gt; <br>&gt; If key paths were some stronger type (as Brent is suggesting), we could do this. However, because key paths are just Strings, we need to compensate for weak type information, so valueForKeyPath should retain it’s currently name despite the redundancy in many use sites with #keyPath.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
