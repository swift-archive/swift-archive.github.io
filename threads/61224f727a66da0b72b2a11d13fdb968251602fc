<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] mutable `newValue` in willSet</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 12, 2016 at 05:00:00am</p></header><div class="content"><p>Sometimes you would like to modify the value being set to a property before it is set.<br></p><p>Currently, you would have to add a separate backing property and implement the getter and setter, even if you want to perform a simple bounds-check on the value being set and want to cap it to allowed values.<br></p><p>e.g:<br></p><p>var bounds : Bounds {<br>    willSet {<br>      // Cap the bounds<br>      newValue = newValue.capped(to: maximumSize)<br>      // Some comments to demonstrate noise if we were doing more processing<br>      // Some comments to demonstrate noise if we were doing more processing<br>      // Some comments to demonstrate noise if we were doing more processing<br>    }<br></p><p>    didSet {<br>      // Load the new bounds<br>      // Some comments to demonstrate noise if we were doing more processing<br>      // Some comments to demonstrate noise if we were doing more processing<br>      // Some comments to demonstrate noise if we were doing more processing<br>    }<br>}<br></p><p>Against the workaround you have to do currently:<br></p><p>var _bounds : Bounds<br>var bounds : Bounds {<br>    get { return _bounds }<br>    set {<br>      // Cap the bounds<br>      _bounds = newValue.capped(to: maximumSize)<br>      // Some comments to demonstrate noise if we were doing more processing<br>      // Some comments to demonstrate noise if we were doing more processing<br>      // Some comments to demonstrate noise if we were doing more processing<br></p><p>      // Load the new bounds<br>      // Some comments to demonstrate noise if we were doing more processing<br>      // Some comments to demonstrate noise if we were doing more processing<br>      // Some comments to demonstrate noise if we were doing more processing<br>    }<br>}<br></p><p>Currently, the capping in willSet is a compile-time error because `newValue` is a let constant, but I find that breaking your accessor code up in to willSet/didSet blocks allows for greater readability, especially when you have lots of processing to do (in the workaround example, the validation/preprocessing code and effects/postprocessing code are only separated by a comment). I propose that, at least for the scope of willSet (and *not* didSet, if we can manage that), that the variable should be mutable.<br></p><p>Any thoughts?<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] mutable `newValue` in willSet</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 12, 2016 at 06:00:00am</p></header><div class="content"><p>I&#39;ve run up against this too and had a similar thought. But on reflection I<br>think the current &quot;workaround&quot; is actually the superior solution.<br></p><p>Even though in your example it&#39;s very clear that newValue is being mutated,<br>if newValue were mutable, it would be possible to *accidentally* mutate it<br>without warning or error if you are calling certain methods on newValue<br>instead of using an assignment operator. For instance, in other contexts,<br>I&#39;ve made such a mistake more than once with array.append() when array is<br>mutable, and I can never quite remember which of popFirst, dropFirst, etc.,<br>is a non-mutating term-of-art and which is mutating.<br></p><p>Of course, this can happen with any mutable value, but in all other<br>circumstances you actually write &quot;var something&quot;, whereas in your proposal<br>you never have to write &quot;var newValue&quot;. In fact, what you&#39;re actually<br>proposing isn&#39;t even the equivalent of &quot;var newValue&quot;; it&#39;s to have<br>newValue be of type `inout T` instead of `T`. I think such an implicit<br>inout has no precedent in Swift and would be confusing to users.<br></p><p>By contrast, I think the current solution is very clear and hard to make a<br>mistake with, although it is a little wordy.<br></p><p>On Sun, Sep 11, 2016 at 10:50 PM Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sometimes you would like to modify the value being set to a property<br>&gt; before it is set.<br>&gt;<br>&gt; Currently, you would have to add a separate backing property and implement<br>&gt; the getter and setter, even if you want to perform a simple bounds-check on<br>&gt; the value being set and want to cap it to allowed values.<br>&gt;<br>&gt; e.g:<br>&gt;<br>&gt; var bounds : Bounds {<br>&gt;     willSet {<br>&gt;       // Cap the bounds<br>&gt;       newValue = newValue.capped(to: maximumSize)<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;     }<br>&gt;<br>&gt;     didSet {<br>&gt;       // Load the new bounds<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Against the workaround you have to do currently:<br>&gt;<br>&gt; var _bounds : Bounds<br>&gt; var bounds : Bounds {<br>&gt;     get { return _bounds }<br>&gt;     set {<br>&gt;       // Cap the bounds<br>&gt;       _bounds = newValue.capped(to: maximumSize)<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;<br>&gt;       // Load the new bounds<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt; processing<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Currently, the capping in willSet is a compile-time error because<br>&gt; `newValue` is a let constant, but I find that breaking your accessor code<br>&gt; up in to willSet/didSet blocks allows for greater readability, especially<br>&gt; when you have lots of processing to do (in the workaround example, the<br>&gt; validation/preprocessing code and effects/postprocessing code are only<br>&gt; separated by a comment). I propose that, at least for the scope of willSet<br>&gt; (and *not* didSet, if we can manage that), that the variable should be<br>&gt; mutable.<br>&gt;<br>&gt; Any thoughts?<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/0b8ec571/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] mutable `newValue` in willSet</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>September 12, 2016 at 08:00:00am</p></header><div class="content"><p>The current solution is IMHO fine if you implement the property. Once you&#39;re overriding it, I don&#39;t think it&#39;s pretty that you need to override the getter as well:<br></p><p>override var bounds: CGRect {<br>	get { <br>		return super.bounds <br>	}<br>	set {<br>		var bounds = newValue<br>		// modify bounds<br>		super.bounds = bounds<br>	}<br>}<br></p><p>I&#39;d suggest requiring &quot;mutating willSet&quot; if you want to modify the value:<br></p><p>override var bounds: CGRect {<br>	mutating willSet {<br>		/// modify newValue<br>	}<br>}<br></p><p>Given the required &quot;mutating&quot; keyword, you can&#39;t make a mistake by accidently modifying the value.<br></p><p><br></p><p>&gt; On Sep 12, 2016, at 8:03 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve run up against this too and had a similar thought. But on reflection I think the current &quot;workaround&quot; is actually the superior solution.<br>&gt; <br>&gt; Even though in your example it&#39;s very clear that newValue is being mutated, if newValue were mutable, it would be possible to *accidentally* mutate it without warning or error if you are calling certain methods on newValue instead of using an assignment operator. For instance, in other contexts, I&#39;ve made such a mistake more than once with array.append() when array is mutable, and I can never quite remember which of popFirst, dropFirst, etc., is a non-mutating term-of-art and which is mutating.<br>&gt; <br>&gt; Of course, this can happen with any mutable value, but in all other circumstances you actually write &quot;var something&quot;, whereas in your proposal you never have to write &quot;var newValue&quot;. In fact, what you&#39;re actually proposing isn&#39;t even the equivalent of &quot;var newValue&quot;; it&#39;s to have newValue be of type `inout T` instead of `T`. I think such an implicit inout has no precedent in Swift and would be confusing to users.<br>&gt; <br>&gt; By contrast, I think the current solution is very clear and hard to make a mistake with, although it is a little wordy.<br>&gt; <br>&gt; On Sun, Sep 11, 2016 at 10:50 PM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Sometimes you would like to modify the value being set to a property before it is set.<br>&gt; <br>&gt; Currently, you would have to add a separate backing property and implement the getter and setter, even if you want to perform a simple bounds-check on the value being set and want to cap it to allowed values.<br>&gt; <br>&gt; e.g:<br>&gt; <br>&gt; var bounds : Bounds {<br>&gt;     willSet {<br>&gt;       // Cap the bounds<br>&gt;       newValue = newValue.capped(to: maximumSize)<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;     }<br>&gt; <br>&gt;     didSet {<br>&gt;       // Load the new bounds<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Against the workaround you have to do currently:<br>&gt; <br>&gt; var _bounds : Bounds<br>&gt; var bounds : Bounds {<br>&gt;     get { return _bounds }<br>&gt;     set {<br>&gt;       // Cap the bounds<br>&gt;       _bounds = newValue.capped(to: maximumSize)<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt; <br>&gt;       // Load the new bounds<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Currently, the capping in willSet is a compile-time error because `newValue` is a let constant, but I find that breaking your accessor code up in to willSet/didSet blocks allows for greater readability, especially when you have lots of processing to do (in the workaround example, the validation/preprocessing code and effects/postprocessing code are only separated by a comment). I propose that, at least for the scope of willSet (and *not* didSet, if we can manage that), that the variable should be mutable.<br>&gt; <br>&gt; Any thoughts?<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/e8a205eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] mutable `newValue` in willSet</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 12, 2016 at 02:00:00pm</p></header><div class="content"><p>Okay, it’s a fair point that it should be explicit. As I see it there are a couple of options:<br></p><p>1. “mutating willSet”<br></p><p>This is very clean, my only concern is that “mutating” typically refers to the containing type. OTOH, all setters are mutating (aren’t they?), so it should be simple enough to disambiguate.<br></p><p>2. “willSet(var newValue)”<br></p><p>Using the existing implicit variable name override mechanism, we could define the parameter as variable. The downside is that we recently removed this syntax from function parameters, so we possibly shouldn’t reintroduce something so similar. OTOH, the reasoning behind removing that syntax from function parameters (that you can define a variable in the function body which serves the same purpose) doesn’t apply in this case.<br></p><p>3. Returning a value from willSet<br></p><p>Make it so that you may optionally return a substitute value in willSet (which must be the same type as the property). When the compiler sees such a willSet implementation, it will synthesise an appropriate setter. I like this from a mutability perspective, but there may be a performance cost for large data-types and we don’t have this notion of a non-required return anywhere else in the language.<br></p><p>I would be happy with any of them, to be honest.<br></p><p>Karl<br></p><p>&gt; On 12 Sep 2016, at 08:37, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; The current solution is IMHO fine if you implement the property. Once you&#39;re overriding it, I don&#39;t think it&#39;s pretty that you need to override the getter as well:<br>&gt; <br>&gt; override var bounds: CGRect {<br>&gt; 	get { <br>&gt; 		return super.bounds <br>&gt; 	}<br>&gt; 	set {<br>&gt; 		var bounds = newValue<br>&gt; 		// modify bounds<br>&gt; 		super.bounds = bounds<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; I&#39;d suggest requiring &quot;mutating willSet&quot; if you want to modify the value:<br>&gt; <br>&gt; override var bounds: CGRect {<br>&gt; 	mutating willSet {<br>&gt; 		/// modify newValue<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Given the required &quot;mutating&quot; keyword, you can&#39;t make a mistake by accidently modifying the value.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Sep 12, 2016, at 8:03 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve run up against this too and had a similar thought. But on reflection I think the current &quot;workaround&quot; is actually the superior solution.<br>&gt;&gt; <br>&gt;&gt; Even though in your example it&#39;s very clear that newValue is being mutated, if newValue were mutable, it would be possible to *accidentally* mutate it without warning or error if you are calling certain methods on newValue instead of using an assignment operator. For instance, in other contexts, I&#39;ve made such a mistake more than once with array.append() when array is mutable, and I can never quite remember which of popFirst, dropFirst, etc., is a non-mutating term-of-art and which is mutating.<br>&gt;&gt; <br>&gt;&gt; Of course, this can happen with any mutable value, but in all other circumstances you actually write &quot;var something&quot;, whereas in your proposal you never have to write &quot;var newValue&quot;. In fact, what you&#39;re actually proposing isn&#39;t even the equivalent of &quot;var newValue&quot;; it&#39;s to have newValue be of type `inout T` instead of `T`. I think such an implicit inout has no precedent in Swift and would be confusing to users.<br>&gt;&gt; <br>&gt;&gt; By contrast, I think the current solution is very clear and hard to make a mistake with, although it is a little wordy.<br>&gt;&gt; <br>&gt;&gt; On Sun, Sep 11, 2016 at 10:50 PM Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Sometimes you would like to modify the value being set to a property before it is set.<br>&gt;&gt; <br>&gt;&gt; Currently, you would have to add a separate backing property and implement the getter and setter, even if you want to perform a simple bounds-check on the value being set and want to cap it to allowed values.<br>&gt;&gt; <br>&gt;&gt; e.g:<br>&gt;&gt; <br>&gt;&gt; var bounds : Bounds {<br>&gt;&gt;     willSet {<br>&gt;&gt;       // Cap the bounds<br>&gt;&gt;       newValue = newValue.capped(to: maximumSize)<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     didSet {<br>&gt;&gt;       // Load the new bounds<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Against the workaround you have to do currently:<br>&gt;&gt; <br>&gt;&gt; var _bounds : Bounds<br>&gt;&gt; var bounds : Bounds {<br>&gt;&gt;     get { return _bounds }<br>&gt;&gt;     set {<br>&gt;&gt;       // Cap the bounds<br>&gt;&gt;       _bounds = newValue.capped(to: maximumSize)<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt; <br>&gt;&gt;       // Load the new bounds<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more processing<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Currently, the capping in willSet is a compile-time error because `newValue` is a let constant, but I find that breaking your accessor code up in to willSet/didSet blocks allows for greater readability, especially when you have lots of processing to do (in the workaround example, the validation/preprocessing code and effects/postprocessing code are only separated by a comment). I propose that, at least for the scope of willSet (and *not* didSet, if we can manage that), that the variable should be mutable.<br>&gt;&gt; <br>&gt;&gt; Any thoughts?<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/166fdfe3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] mutable `newValue` in willSet</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 12, 2016 at 12:00:00pm</p></header><div class="content"><p>I have the same concern about &quot;mutating&quot; as you do regarding inconsistency<br>with the rest of the language.<br></p><p>As I mentioned, &quot;var newValue&quot; is incorrect. One reason it was removed is<br>that people kept trying to use it when they meant inout, which is what you<br>are doing here. You would need to write &quot;willSet(newValue: inout T)&quot;. &quot;var<br>newValue&quot; would shadow the variable that you want to change.<br></p><p>Returning a value has problems as you described and is inconsistent with<br>the rest of the language.<br></p><p>At this point, I&#39;d prefer the status quo over any of these.<br></p><p>One alternative you haven&#39;t mentioned is setting the variable directly from<br>willSet (&quot;bounds = newValue + 1&quot;). The rules can be changed such that this<br>is allowed and does not trigger a new willSet and didSet (much like setting<br>the property inside init does not).<br></p><p>On Mon, Sep 12, 2016 at 07:32 Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; Okay, it’s a fair point that it should be explicit. As I see it there are<br>&gt; a couple of options:<br>&gt;<br>&gt; 1. “mutating willSet”<br>&gt;<br>&gt; This is very clean, my only concern is that “mutating” typically refers to<br>&gt; the containing type. OTOH, all setters are mutating (aren’t they?), so it<br>&gt; should be simple enough to disambiguate.<br>&gt;<br>&gt; 2. “willSet(var newValue)”<br>&gt;<br>&gt; Using the existing implicit variable name override mechanism, we could<br>&gt; define the parameter as variable. The downside is that we recently removed<br>&gt; this syntax from function parameters, so we possibly shouldn’t reintroduce<br>&gt; something so similar. OTOH, the reasoning behind removing that syntax from<br>&gt; function parameters (that you can define a variable in the function body<br>&gt; which serves the same purpose) doesn’t apply in this case.<br>&gt;<br>&gt; 3. Returning a value from willSet<br>&gt;<br>&gt; Make it so that you may optionally return a substitute value in willSet<br>&gt; (which must be the same type as the property). When the compiler sees such<br>&gt; a willSet implementation, it will synthesise an appropriate setter. I like<br>&gt; this from a mutability perspective, but there may be a performance cost for<br>&gt; large data-types and we don’t have this notion of a non-required return<br>&gt; anywhere else in the language.<br>&gt;<br>&gt; I would be happy with any of them, to be honest.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; On 12 Sep 2016, at 08:37, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>&gt; wrote:<br>&gt;<br>&gt; The current solution is IMHO fine if you implement the property. Once<br>&gt; you&#39;re overriding it, I don&#39;t think it&#39;s pretty that you need to override<br>&gt; the getter as well:<br>&gt;<br>&gt; override var bounds: CGRect {<br>&gt; get {<br>&gt; return super.bounds<br>&gt; }<br>&gt; set {<br>&gt; var bounds = newValue<br>&gt; // modify bounds<br>&gt; super.bounds = bounds<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; I&#39;d suggest requiring &quot;mutating willSet&quot; if you want to modify the value:<br>&gt;<br>&gt; override var bounds: CGRect {<br>&gt; mutating willSet {<br>&gt; /// modify newValue<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Given the required &quot;mutating&quot; keyword, you can&#39;t make a mistake by<br>&gt; accidently modifying the value.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sep 12, 2016, at 8:03 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;ve run up against this too and had a similar thought. But on reflection<br>&gt; I think the current &quot;workaround&quot; is actually the superior solution.<br>&gt;<br>&gt; Even though in your example it&#39;s very clear that newValue is being<br>&gt; mutated, if newValue were mutable, it would be possible to *accidentally*<br>&gt; mutate it without warning or error if you are calling certain methods on<br>&gt; newValue instead of using an assignment operator. For instance, in other<br>&gt; contexts, I&#39;ve made such a mistake more than once with array.append() when<br>&gt; array is mutable, and I can never quite remember which of popFirst,<br>&gt; dropFirst, etc., is a non-mutating term-of-art and which is mutating.<br>&gt;<br>&gt; Of course, this can happen with any mutable value, but in all other<br>&gt; circumstances you actually write &quot;var something&quot;, whereas in your proposal<br>&gt; you never have to write &quot;var newValue&quot;. In fact, what you&#39;re actually<br>&gt; proposing isn&#39;t even the equivalent of &quot;var newValue&quot;; it&#39;s to have<br>&gt; newValue be of type `inout T` instead of `T`. I think such an implicit<br>&gt; inout has no precedent in Swift and would be confusing to users.<br>&gt;<br>&gt; By contrast, I think the current solution is very clear and hard to make a<br>&gt; mistake with, although it is a little wordy.<br>&gt;<br>&gt; On Sun, Sep 11, 2016 at 10:50 PM Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Sometimes you would like to modify the value being set to a property<br>&gt;&gt; before it is set.<br>&gt;&gt;<br>&gt;&gt; Currently, you would have to add a separate backing property and<br>&gt;&gt; implement the getter and setter, even if you want to perform a simple<br>&gt;&gt; bounds-check on the value being set and want to cap it to allowed values.<br>&gt;&gt;<br>&gt;&gt; e.g:<br>&gt;&gt;<br>&gt;&gt; var bounds : Bounds {<br>&gt;&gt;     willSet {<br>&gt;&gt;       // Cap the bounds<br>&gt;&gt;       newValue = newValue.capped(to: maximumSize)<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     didSet {<br>&gt;&gt;       // Load the new bounds<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Against the workaround you have to do currently:<br>&gt;&gt;<br>&gt;&gt; var _bounds : Bounds<br>&gt;&gt; var bounds : Bounds {<br>&gt;&gt;     get { return _bounds }<br>&gt;&gt;     set {<br>&gt;&gt;       // Cap the bounds<br>&gt;&gt;       _bounds = newValue.capped(to: maximumSize)<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;<br>&gt;&gt;       // Load the new bounds<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;       // Some comments to demonstrate noise if we were doing more<br>&gt;&gt; processing<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Currently, the capping in willSet is a compile-time error because<br>&gt;&gt; `newValue` is a let constant, but I find that breaking your accessor code<br>&gt;&gt; up in to willSet/didSet blocks allows for greater readability, especially<br>&gt;&gt; when you have lots of processing to do (in the workaround example, the<br>&gt;&gt; validation/preprocessing code and effects/postprocessing code are only<br>&gt;&gt; separated by a comment). I propose that, at least for the scope of willSet<br>&gt;&gt; (and *not* didSet, if we can manage that), that the variable should be<br>&gt;&gt; mutable.<br>&gt;&gt;<br>&gt;&gt; Any thoughts?<br>&gt;&gt;<br>&gt;&gt; Karl<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/20cdc15e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
