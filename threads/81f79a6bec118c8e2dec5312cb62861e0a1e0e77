<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>Here&#39;s a function signature from some code from today:<br></p><p>func scaleAndCropImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    fitImage: Bool = true<br>    ) -&gt; UIImage {<br></p><p><br>And here&#39;s what I want the function signature to actually look like:<br></p><p>func scaleAndCropImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    operation: (.Fit | .Fill) = .Fit<br>    ) -&gt; UIImage {<br></p><p><br>where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br></p><p>I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br></p><p>Thanks for your feedback,<br></p><p>-- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/81f70e77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>May 31, 2016 at 09:00:00am</p></header><div class="content"><p>Definitely an interesting idea, and I like it, but how would this be used from Objective C? <br>&gt; On May 31, 2016, at 9:16 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here&#39;s a function signature from some code from today:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     fitImage: Bool = true<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt; <br>&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt; <br>&gt; Thanks for your feedback,<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>On May 31, 2016, at 10:20 AM, Kevin Nattinger &lt;swift at nattinger.net&gt; wrote:<br>&gt; <br>&gt; Definitely an interesting idea, and I like it, but how would this be used from Objective C? <br></p><p>Interop is a separate question. I&#39;m sticking mostly to pure Swift these days, or doing all my calls from Swift. In such a light, it falls under the &quot;not available to ObjC&quot; or &quot;if made available to ObjcC, does not fall under the scope of introduction of this idea&quot; umbrellas.<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>Most ideas discussed here lately cannot be used from ObjC.<br></p><p>&gt; On May 31, 2016, at 6:20 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Definitely an interesting idea, and I like it, but how would this be used from Objective C? <br>&gt;&gt; On May 31, 2016, at 9:16 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a function signature from some code from today:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;    image: UIImage,<br>&gt;&gt;    toSize size: CGSize,<br>&gt;&gt;    fitImage: Bool = true<br>&gt;&gt;    ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;    image: UIImage,<br>&gt;&gt;    toSize size: CGSize,<br>&gt;&gt;    operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;    ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt;&gt; <br>&gt;&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback,<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 31, 2016, at 10:24 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Most ideas discussed here lately cannot be used from ObjC.<br></p><p>That is a fair point. It may be reasonable to add an ObjC interop section to the proposal template. <br></p><p>At the same time, I&#39;m not sure the core Swift team has made it clear how much responsibility Swift has to this area, especially when considering the language going multiplatform.<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>This is interesting. I don&#39;t think there is anything preventing these<br>to be internally translated by the compiler as a true enums with<br>random names (or<br>any-other-way-we-shall-never-be-able-to-reference-again) thus adding<br>the needed ObjC interop.<br></p><p>L<br></p><p>On 31 May 2016 at 13:24, Charlie Monroe via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Most ideas discussed here lately cannot be used from ObjC.<br>&gt;<br>&gt;&gt; On May 31, 2016, at 6:20 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Definitely an interesting idea, and I like it, but how would this be used from Objective C?<br>&gt;&gt;&gt; On May 31, 2016, at 9:16 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here&#39;s a function signature from some code from today:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;&gt;    image: UIImage,<br>&gt;&gt;&gt;    toSize size: CGSize,<br>&gt;&gt;&gt;    fitImage: Bool = true<br>&gt;&gt;&gt;    ) -&gt; UIImage {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;&gt;    image: UIImage,<br>&gt;&gt;&gt;    toSize size: CGSize,<br>&gt;&gt;&gt;    operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;    ) -&gt; UIImage {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks for your feedback,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 31, 2016 at 07:00:00pm</p></header><div class="content"><p>IMO interesting idea.. We have ad hoc structs as tuples and it seems like <br>ad-hoc enums also could be helpful when we don&#39;t need a separate class for <br>using in limited scope.<br></p><p>I also can see advantage to use such anonymous enum type in code:<br></p><p>var codePath : (.one | .two | .three) = .one<br></p><p>...<br></p><p>switch codePath {<br>   case .one : ...<br>   case .two : ...<br>   case .three : ...<br>}<br></p><p>IMO very clean and expressive code and I like the proposed syntax.<br>So I&#39;d like to have such in Swift<br></p><p>On 31.05.2016 19:16, Erica Sadun via swift-evolution wrote:<br>&gt; func scaleAndCropImage(<br>&gt; 	image: UIImage,<br>&gt; 	toSize size: CGSize,<br>&gt; 	*operation: (.Fit | .Fill) = .Fit*<br>&gt; 	) -&gt; UIImage {<br>&gt;<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>Forwarding on behalf of Chris Kornher:<br></p><p>I think that this is a great idea. It would be nice to:<br>	1) Have a standard way to generate these values from textual or other serialized representations.<br>	2) A way to be able to store these vales (as preferences, for example)<br></p><p>A simple way to do support this is to make these into full-fledged enums:<br>	 1) make these rawrepresentable string enums<br>	 2) give the type a name for use when needed: e.g.<br>		<br>	scaleAndCropImage.fitImage.options_t<br></p><p>		or perhaps, :<br>	<br>	scaleAndCropImage_fitImage_options_t<br></p><p><br>enabling: <br></p><p>struct MyPreferenceStruct {<br>.. <br>var fitOptions: scaleAndCropImage_fitImage_options_t<br>}<br> <br>Thinking about this a bit more, requiring a name like:<br></p><p>func scaleAndCropImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    operation: ScaleCropFitFitFill{.Fit | .Fill} = .Fit<br>    ) -&gt; UIImage {<br></p><p>would be cleaner.  <br></p><p>- Chris<br></p><p><br>&gt; On May 31, 2016, at 10:16 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Here&#39;s a function signature from some code from today:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     fitImage: Bool = true<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt; <br>&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt; <br>&gt; Thanks for your feedback,<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/6c379492/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>An enthusiastic +1 to Erica&#39;s suggestion.<br></p><p>While I also see the appeal of Chris Kornher&#39;s suggestion of giving the<br>enum a proper Type, I think Erica&#39;s syntax is more appropriate. I haven&#39;t<br>though through the implications of having an &quot;anonymous enum&quot; but since the<br>main use case is just to give functions a more convenient and legible way<br>to specify options, I think shorter is better.<br></p><p>I really like this proposal. It would result in a lot of Swift code, out<br>there in the world, being a little easier to read :)<br></p><p><br></p><p>On Tue, May 31, 2016 at 9:53 AM, Christopher Kornher via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; *Forwarding on behalf of Chris Kornher:*<br>&gt;<br>&gt; I think that this is a great idea. It would be nice to:<br>&gt; 1) Have a standard way to generate these values from textual or other<br>&gt; serialized representations.<br>&gt; 2) A way to be able to store these vales (as preferences, for example)<br>&gt;<br>&gt; A simple way to do support this is to make these into full-fledged enums:<br>&gt;  1) make these rawrepresentable string enums<br>&gt;  2) give the type a name for use when needed: e.g.<br>&gt; scaleAndCropImage.fitImage.options_t or perhaps, :<br>&gt; scaleAndCropImage_fitImage_options_t enabling:  struct MyPreferenceStruct<br>&gt; { .. var fitOptions: scaleAndCropImage_fitImage_options_t }<br>&gt;<br>&gt; Thinking about this a bit more, requiring a name like:<br>&gt;<br>&gt; func scaleAndCropImage(<br>&gt; image: UIImage,<br>&gt; toSize size: CGSize,<br>&gt; *operation: ScaleCropFitFitFill{.Fit | .Fill} = .Fit*<br>&gt; ) -&gt; UIImage {<br>&gt; would be cleaner.<br>&gt;<br>&gt; - Chris<br>&gt;<br>&gt;<br>&gt; On May 31, 2016, at 10:16 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Here&#39;s a function signature from some code from today:<br>&gt;<br>&gt; func scaleAndCropImage(<br>&gt; image: UIImage,<br>&gt; toSize size: CGSize,<br>&gt; *fitImage: Bool = true*<br>&gt; ) -&gt; UIImage {<br>&gt;<br>&gt;<br>&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;<br>&gt; func scaleAndCropImage(<br>&gt; image: UIImage,<br>&gt; toSize size: CGSize,<br>&gt; *operation: (.Fit | .Fill) = .Fit*<br>&gt; ) -&gt; UIImage {<br>&gt;<br>&gt;<br>&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc<br>&gt; enumeration-like semantics for the call. A while back, Yong hee Lee<br>&gt; introduced anonymous enumerations (and the possibility of anonymous option<br>&gt; flags) but the discussion rather died.<br>&gt;<br>&gt; I&#39;m bringing it up again to see whether there is any general interest in<br>&gt; pursuing this further as I think the second example is more readable,<br>&gt; appropriate, and Swifty than the first, provides better semantics, and is<br>&gt; more self documenting.<br>&gt;<br>&gt; Thanks for your feedback,<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/f7c7d499/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 31, 2016 at 07:00:00pm</p></header><div class="content"><p>I have mixed feelings about this since it may lead to redeclarations over and over of the same values instead of actually declaring an enum.<br></p><p><br>&gt; On May 31, 2016, at 7:31 PM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; An enthusiastic +1 to Erica&#39;s suggestion. <br>&gt; <br>&gt; While I also see the appeal of Chris Kornher&#39;s suggestion of giving the enum a proper Type, I think Erica&#39;s syntax is more appropriate. I haven&#39;t though through the implications of having an &quot;anonymous enum&quot; but since the main use case is just to give functions a more convenient and legible way to specify options, I think shorter is better.<br>&gt; <br>&gt; I really like this proposal. It would result in a lot of Swift code, out there in the world, being a little easier to read :)<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, May 31, 2016 at 9:53 AM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Forwarding on behalf of Chris Kornher:<br>&gt; <br>&gt; I think that this is a great idea. It would be nice to:<br>&gt; 	1) Have a standard way to generate these values from textual or other serialized representations.<br>&gt; 	2) A way to be able to store these vales (as preferences, for example)<br>&gt; <br>&gt; A simple way to do support this is to make these into full-fledged enums:<br>&gt; 	 1) make these rawrepresentable string enums<br>&gt; 	 2) give the type a name for use when needed: e.g.<br>&gt; 		<br>&gt; 	scaleAndCropImage.fitImage.options_t<br>&gt; <br>&gt; 		or perhaps, :<br>&gt; 	<br>&gt; 	scaleAndCropImage_fitImage_options_t<br>&gt; <br>&gt; <br>&gt; enabling: <br>&gt; <br>&gt; struct MyPreferenceStruct {<br>&gt; .. <br>&gt; var fitOptions: scaleAndCropImage_fitImage_options_t<br>&gt; }<br>&gt;  <br>&gt; Thinking about this a bit more, requiring a name like:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: ScaleCropFitFitFill{.Fit | .Fill} = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; would be cleaner.  <br>&gt; <br>&gt; - Chris<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 10:16 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a function signature from some code from today:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     fitImage: Bool = true<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt;&gt; <br>&gt;&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback,<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/725605db/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>Big +1. I had similar thoughts a while back when I was writing some C++ or<br>Java code that had boolean arguments, and I found myself hating how<br>non-documenting they were and I would contrive two-valued enums to make<br>call sites look better. Having a crisp clean syntax for this would be<br>fantastic and encourage people to write self-documenting APIs.<br></p><p>Having argument labels solves some of the problems that come along with<br>boolean arguments, but &quot;fitImage&quot; is a great example where the false case<br>(&quot;not fit?&quot;) doesn&#39;t really convey enough information (or can convey<br>misleading information).<br></p><p><br>On Tue, May 31, 2016 at 9:17 AM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Here&#39;s a function signature from some code from today:<br>&gt;<br>&gt; func scaleAndCropImage(<br>&gt; image: UIImage,<br>&gt; toSize size: CGSize,<br>&gt; *fitImage: Bool = true*<br>&gt; ) -&gt; UIImage {<br>&gt;<br>&gt;<br>&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;<br>&gt; func scaleAndCropImage(<br>&gt; image: UIImage,<br>&gt; toSize size: CGSize,<br>&gt; *operation: (.Fit | .Fill) = .Fit*<br>&gt; ) -&gt; UIImage {<br>&gt;<br>&gt;<br>&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc<br>&gt; enumeration-like semantics for the call. A while back, Yong hee Lee<br>&gt; introduced anonymous enumerations (and the possibility of anonymous option<br>&gt; flags) but the discussion rather died.<br>&gt;<br>&gt; I&#39;m bringing it up again to see whether there is any general interest in<br>&gt; pursuing this further as I think the second example is more readable,<br>&gt; appropriate, and Swifty than the first, provides better semantics, and is<br>&gt; more self documenting.<br>&gt;<br>&gt; Thanks for your feedback,<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/a9a4ac05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>I think I&#39;m -1 on this.  It makes things easier for the implementer of the function and harder for the caller.  <br></p><p>It&#39;s not clear whether the caller could store an argument to pass in a variable, but if they could they would need to list out all cases in the type of the variable (unless these anonymous enums have structural subtyping).  This is fragile.  Any time that list changes all variable declarations will have to be updated.<br></p><p>Functions are implemented once and usually called more many times.  It&#39;s better for callers if you just write it like this:<br></p><p>enum FitOrFill { case fit, fill }<br>func scaleAndCropImage(<br>image: UIImage,<br>toSize size: CGSize,<br>operation: FitOrFill = .fit<br>) -&gt; UIImage {<br></p><p>So unless these anonymous enums are structurally subtyped I think it&#39;s a bad idea.  And introducing structural subtyping here seems like a pretty large hammer for this use case.<br></p><p>Sent from my iPad<br></p><p>&gt; On May 31, 2016, at 12:44 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Big +1. I had similar thoughts a while back when I was writing some C++ or Java code that had boolean arguments, and I found myself hating how non-documenting they were and I would contrive two-valued enums to make call sites look better. Having a crisp clean syntax for this would be fantastic and encourage people to write self-documenting APIs.<br>&gt; <br>&gt; Having argument labels solves some of the problems that come along with boolean arguments, but &quot;fitImage&quot; is a great example where the false case (&quot;not fit?&quot;) doesn&#39;t really convey enough information (or can convey misleading information).<br>&gt; <br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 9:17 AM Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Here&#39;s a function signature from some code from today:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     fitImage: Bool = true<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt;&gt; <br>&gt;&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback,<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/382b3049/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 12:35 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I think I&#39;m -1 on this.  It makes things easier for the implementer of the function and harder for the caller.  <br>&gt; <br>&gt; It&#39;s not clear whether the caller could store an argument to pass in a variable, but if they could they would need to list out all cases in the type of the variable (unless these anonymous enums have structural subtyping).  This is fragile.  Any time that list changes all variable declarations will have to be updated.<br>&gt; <br>&gt; Functions are implemented once and usually called more many times.  It&#39;s better for callers if you just write it like this:<br>&gt; <br>&gt; enum FitOrFill { case fit, fill }<br>&gt; func scaleAndCropImage(<br>&gt; image: UIImage,<br>&gt; toSize size: CGSize,<br>&gt; operation: FitOrFill = .fit<br>&gt; ) -&gt; UIImage {<br>&gt; <br>&gt; So unless these anonymous enums are structurally subtyped I think it&#39;s a bad idea.  And introducing structural subtyping here seems like a pretty large hammer for this use case.<br></p><p><br>From the caller&#39;s point of view, the type must be inferable and exactly match a token listed in the declaration (which would also appear in Quick Help):<br></p><p>let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br></p><p>You would not be able to assign `.fill` to a variable and use that for the operation value.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/e8749d48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 2:04 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 31, 2016, at 12:35 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think I&#39;m -1 on this.  It makes things easier for the implementer of the function and harder for the caller.  <br>&gt;&gt; <br>&gt;&gt; It&#39;s not clear whether the caller could store an argument to pass in a variable, but if they could they would need to list out all cases in the type of the variable (unless these anonymous enums have structural subtyping).  This is fragile.  Any time that list changes all variable declarations will have to be updated.<br>&gt;&gt; <br>&gt;&gt; Functions are implemented once and usually called more many times.  It&#39;s better for callers if you just write it like this:<br>&gt;&gt; <br>&gt;&gt; enum FitOrFill { case fit, fill }<br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt; image: UIImage,<br>&gt;&gt; toSize size: CGSize,<br>&gt;&gt; operation: FitOrFill = .fit<br>&gt;&gt; ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; So unless these anonymous enums are structurally subtyped I think it&#39;s a bad idea.  And introducing structural subtyping here seems like a pretty large hammer for this use case.<br>&gt; <br>&gt; <br>&gt; From the caller&#39;s point of view, the type must be inferable and exactly match a token listed in the declaration (which would also appear in Quick Help):<br>&gt; <br>&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt; <br>&gt; You would not be able to assign `.fill` to a variable and use that for the operation value.<br></p><p>If you are not allowing callers to store their argument in a variable then I am 100% opposed to this.  That would the first case in Swift where you *MUST* provide a literal argument when calling a function, and *CANNOT* provide a value you store in a variable (possibly something you receive as an argument from somewhere else).  Why would we want to restrict the flexibility of callers in that way?<br></p><p>&gt; <br>&gt; -- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/64b5dfbe/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 31, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; If you are not allowing callers to store their argument in a variable then<br> &gt; I am 100% opposed to this.  That would the first case in Swift where you<br> &gt; *MUST* provide a literal argument when calling a function, and *CANNOT*<br> &gt; provide a value you store in a variable (possibly something you receive as<br> &gt; an argument from somewhere else).  Why would we want to restrict the<br> &gt; flexibility of callers in that way?<br></p><p>Definitely we *must* be able to use a variable in call to function. The <br>problem is how (in case we agreee that the proposed feature could be useful).<br></p><p>I&#39;m thinking about similarity of tuples and this anonymous enums.. If you <br>have tuple in function parameter - how would you use variable to pass it to <br>function? You&#39;ll define a variable of the exact same tuple as required, <br>manually, no some separate type provided for this. Yes, if tuple in <br>function definition changed - you&#39;ll need to change tuple on caller side:<br></p><p>func foo(int: Int, tuple: (Int, String)) {}<br></p><p>foo(1, tuple: (1, &quot;string&quot;))<br></p><p>var tupleVar : (Int, String) = (1, &quot;string&quot;)<br></p><p>foo(1, tuple: tupleVar)<br></p><p>So, why not have the same for such anonymous enums?<br></p><p>func foo(int: Int, variant: (.one | .two)) {}<br></p><p>foo(1, variant: .one)<br></p><p>var enumVar : (.one | .two) = .one<br></p><p>foo(1, variant: enumVar)<br></p><p><br>Seems like consistent solution.<br></p><p><br>On 31.05.2016 22:07, Matthew Johnson via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On May 31, 2016, at 2:04 PM, Erica Sadun &lt;erica at ericasadun.com<br>&gt;&gt; &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 31, 2016, at 12:35 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt; &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think I&#39;m -1 on this.  It makes things easier for the implementer of<br>&gt;&gt;&gt; the function and harder for the caller.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s not clear whether the caller could store an argument to pass in a<br>&gt;&gt;&gt; variable, but if they could they would need to list out all cases in the<br>&gt;&gt;&gt; type of the variable (unless these anonymous enums have structural<br>&gt;&gt;&gt; subtyping).  This is fragile.  Any time that list changes all variable<br>&gt;&gt;&gt; declarations will have to be updated.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Functions are implemented once and usually called more many times.  It&#39;s<br>&gt;&gt;&gt; better for callers if you just write it like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum FitOrFill { case fit, fill }<br>&gt;&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;&gt; 	image: UIImage,<br>&gt;&gt;&gt; 	toSize size: CGSize,<br>&gt;&gt;&gt; 	*operation: FitOrFill = .fit*<br>&gt;&gt;&gt; 	) -&gt; UIImage {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So unless these anonymous enums are structurally subtyped I think it&#39;s a<br>&gt;&gt;&gt; bad idea.  And introducing structural subtyping here seems like a pretty<br>&gt;&gt;&gt; large hammer for this use case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; From the caller&#39;s point of view, the type must be inferable and exactly<br>&gt;&gt; match a token listed in the declaration (which would also appear in Quick<br>&gt;&gt; Help):<br>&gt;&gt;<br>&gt;&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt;&gt;<br>&gt;&gt; You would not be able to assign `.fill` to a variable and use that for<br>&gt;&gt; the operation value.<br>&gt;<br>&gt; If you are not allowing callers to store their argument in a variable then<br>&gt; I am 100% opposed to this.  That would the first case in Swift where you<br>&gt; *MUST* provide a literal argument when calling a function, and *CANNOT*<br>&gt; provide a value you store in a variable (possibly something you receive as<br>&gt; an argument from somewhere else).  Why would we want to restrict the<br>&gt; flexibility of callers in that way?<br>&gt;<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 3:46 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; If you are not allowing callers to store their argument in a variable then<br>&gt; &gt; I am 100% opposed to this.  That would the first case in Swift where you<br>&gt; &gt; *MUST* provide a literal argument when calling a function, and *CANNOT*<br>&gt; &gt; provide a value you store in a variable (possibly something you receive as<br>&gt; &gt; an argument from somewhere else).  Why would we want to restrict the<br>&gt; &gt; flexibility of callers in that way?<br>&gt; <br>&gt; Definitely we *must* be able to use a variable in call to function. The problem is how (in case we agreee that the proposed feature could be useful).<br>&gt; <br>&gt; I&#39;m thinking about similarity of tuples and this anonymous enums.. If you have tuple in function parameter - how would you use variable to pass it to function? You&#39;ll define a variable of the exact same tuple as required, manually, no some separate type provided for this. Yes, if tuple in function definition changed - you&#39;ll need to change tuple on caller side:<br>&gt; <br>&gt; func foo(int: Int, tuple: (Int, String)) {}<br>&gt; <br>&gt; foo(1, tuple: (1, &quot;string&quot;))<br>&gt; <br>&gt; var tupleVar : (Int, String) = (1, &quot;string&quot;)<br>&gt; <br>&gt; foo(1, tuple: tupleVar)<br>&gt; <br>&gt; So, why not have the same for such anonymous enums?<br>&gt; <br>&gt; func foo(int: Int, variant: (.one | .two)) {}<br>&gt; <br>&gt; foo(1, variant: .one)<br>&gt; <br>&gt; var enumVar : (.one | .two) = .one<br>&gt; <br>&gt; foo(1, variant: enumVar)<br>&gt; <br>&gt; <br>&gt; Seems like consistent solution.<br></p><p>It is consistent with tuples, but using a tuple instead of distinct parameters is usually going to be a bad idea.  If we introduce ad-hoc enums people are going to use it frequently.  And options like this are the kind of thing that *does* change periodically.  <br></p><p>Because those changes are usually additive I’m not too concerned about removing options.  But I *am* concerned about re-ordering existing options or adding new options impacting existing variable declarations.  For this reason, these would need to be order-independent and support structural subtyping.  That way my `(.foo | .bar)` variable is still a valid argument when you change the option list to `(.baz | .bar | .foo)`.<br></p><p>The existing approach of just defining an enum is really not so bad and removes this issue altogether.  IMO it is a reasonable “workaround” for now.<br></p><p>I believe there is a lot of overlap between doing this the right way and introducing structural unions like those in Ceylon (fortunately there seems to be growing support for this).  For that reason I think it makes sense to wait until we have that feature to look at ad-hoc types with enumerated values like this.<br></p><p>&gt; <br>&gt; <br>&gt; On 31.05.2016 22:07, Matthew Johnson via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 2:04 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;<br>&gt;&gt;&gt; &lt;mailto:erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 12:35 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think I&#39;m -1 on this.  It makes things easier for the implementer of<br>&gt;&gt;&gt;&gt; the function and harder for the caller.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s not clear whether the caller could store an argument to pass in a<br>&gt;&gt;&gt;&gt; variable, but if they could they would need to list out all cases in the<br>&gt;&gt;&gt;&gt; type of the variable (unless these anonymous enums have structural<br>&gt;&gt;&gt;&gt; subtyping).  This is fragile.  Any time that list changes all variable<br>&gt;&gt;&gt;&gt; declarations will have to be updated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Functions are implemented once and usually called more many times.  It&#39;s<br>&gt;&gt;&gt;&gt; better for callers if you just write it like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum FitOrFill { case fit, fill }<br>&gt;&gt;&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;&gt;&gt; 	image: UIImage,<br>&gt;&gt;&gt;&gt; 	toSize size: CGSize,<br>&gt;&gt;&gt;&gt; 	*operation: FitOrFill = .fit*<br>&gt;&gt;&gt;&gt; 	) -&gt; UIImage {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So unless these anonymous enums are structurally subtyped I think it&#39;s a<br>&gt;&gt;&gt;&gt; bad idea.  And introducing structural subtyping here seems like a pretty<br>&gt;&gt;&gt;&gt; large hammer for this use case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the caller&#39;s point of view, the type must be inferable and exactly<br>&gt;&gt;&gt; match a token listed in the declaration (which would also appear in Quick<br>&gt;&gt;&gt; Help):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You would not be able to assign `.fill` to a variable and use that for<br>&gt;&gt;&gt; the operation value.<br>&gt;&gt; <br>&gt;&gt; If you are not allowing callers to store their argument in a variable then<br>&gt;&gt; I am 100% opposed to this.  That would the first case in Swift where you<br>&gt;&gt; *MUST* provide a literal argument when calling a function, and *CANNOT*<br>&gt;&gt; provide a value you store in a variable (possibly something you receive as<br>&gt;&gt; an argument from somewhere else).  Why would we want to restrict the<br>&gt;&gt; flexibility of callers in that way?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/4ba758a7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 3:04 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt; <br>&gt; You would not be able to assign `.fill` to a variable and use that for the operation value.<br></p><p>This is my objection to this idea. It does not encourage reuse. <br></p><p>I would not be able to assign to a variable:<br></p><p>let selectedOperation = .fill<br></p><p>In order to then do this later in the program:<br></p><p>scaleAndCropImage(image: myImage, toSize: size, operation: selectedOperation)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/ba6c8038/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 7:48 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On May 31, 2016, at 3:04 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt;&gt; <br>&gt;&gt; You would not be able to assign `.fill` to a variable and use that for the operation value.<br>&gt; <br>&gt; This is my objection to this idea. It does not encourage reuse.<br></p><p>-1For me too. Introducing this quasi-enum would increase cognitive load with little, if any, net benefit. This is the sort of feature that looks great and works wonderfully in example apps, but does not scale well to real systems, where options show up in more methods through time, get passed around to helpers, stored, marshaled into various formats, etc.<br></p><p>As someone mentioned, this would probably be a good fit If Swift adopts a structural type system (I suppose, I have ever used a language with one to my knowledge, unless duck typing counts)<br></p><p>As syntactic sugar for a true enum declaration, it would be a “cool” feature, but reuse would still be problematic. <br></p><p>&gt; <br>&gt; I would not be able to assign to a variable:<br>&gt; <br>&gt; let selectedOperation = .fill<br>&gt; <br>&gt; In order to then do this later in the program:<br>&gt; <br>&gt; scaleAndCropImage(image: myImage, toSize: size, operation: selectedOperation)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/e58afffc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June  1, 2016 at 08:00:00pm</p></header><div class="content"><p>What if (.Fit | .Fill) was just a shorthand for enums that you could use anywhere, like a tuple type?<br></p><p>let foo: (.Fit | .Fill) = .Fit<br>let bar: (.Fit | .Fill) = .Fill<br>let frob = cond ? foo : bar // foo and bar have the same type<br></p><p>You could typealias it too.<br></p><p>Félix<br></p><p>&gt; Le 1 juin 2016 à 20:05:06, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 7:48 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On May 31, 2016, at 3:04 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You would not be able to assign `.fill` to a variable and use that for the operation value.<br>&gt;&gt; <br>&gt;&gt; This is my objection to this idea. It does not encourage reuse.<br>&gt; <br>&gt; -1For me too. Introducing this quasi-enum would increase cognitive load with little, if any, net benefit. This is the sort of feature that looks great and works wonderfully in example apps, but does not scale well to real systems, where options show up in more methods through time, get passed around to helpers, stored, marshaled into various formats, etc.<br>&gt; <br>&gt; As someone mentioned, this would probably be a good fit If Swift adopts a structural type system (I suppose, I have ever used a language with one to my knowledge, unless duck typing counts)<br>&gt; <br>&gt; As syntactic sugar for a true enum declaration, it would be a “cool” feature, but reuse would still be problematic. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I would not be able to assign to a variable:<br>&gt;&gt; <br>&gt;&gt; let selectedOperation = .fill<br>&gt;&gt; <br>&gt;&gt; In order to then do this later in the program:<br>&gt;&gt; <br>&gt;&gt; scaleAndCropImage(image: myImage, toSize: size, operation: selectedOperation)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/757739ad/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  2, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 5:05 AM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 7:48 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On May 31, 2016, at 3:04 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You would not be able to assign `.fill` to a variable and use that for the operation value.<br>&gt;&gt; <br>&gt;&gt; This is my objection to this idea. It does not encourage reuse.<br>&gt; <br>&gt; -1For me too. Introducing this quasi-enum would increase cognitive load with little, if any, net benefit. This is the sort of feature that looks great and works wonderfully in example apps, but does not scale well to real systems, where options show up in more methods through time, get passed around to helpers, stored, marshaled into various formats, etc.<br>&gt; <br>&gt; As someone mentioned, this would probably be a good fit If Swift adopts a structural type system (I suppose, I have ever used a language with one to my knowledge, unless duck typing counts)<br>&gt; <br>&gt; As syntactic sugar for a true enum declaration, it would be a “cool” feature, but reuse would still be problematic. <br></p><p><br>there is no reuse problem in the interpretation I propose, and the long/short form names are completely interchangeable.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; I would not be able to assign to a variable:<br>&gt;&gt; <br>&gt;&gt; let selectedOperation = .fill<br>&gt;&gt; <br>&gt;&gt; In order to then do this later in the program:<br>&gt;&gt; <br>&gt;&gt; scaleAndCropImage(image: myImage, toSize: size, operation: selectedOperation)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/55eb47a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Laurent,<br></p><p>Do you have the details of your proposal, I missed it. <br></p><p>Thanks<br></p><p>&gt; On Jun 2, 2016, at 1:48 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 5:05 AM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 7:48 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 3:04 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You would not be able to assign `.fill` to a variable and use that for the operation value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my objection to this idea. It does not encourage reuse.<br>&gt;&gt; <br>&gt;&gt; -1For me too. Introducing this quasi-enum would increase cognitive load with little, if any, net benefit. This is the sort of feature that looks great and works wonderfully in example apps, but does not scale well to real systems, where options show up in more methods through time, get passed around to helpers, stored, marshaled into various formats, etc.<br>&gt;&gt; <br>&gt;&gt; As someone mentioned, this would probably be a good fit If Swift adopts a structural type system (I suppose, I have ever used a language with one to my knowledge, unless duck typing counts)<br>&gt;&gt; <br>&gt;&gt; As syntactic sugar for a true enum declaration, it would be a “cool” feature, but reuse would still be problematic. <br>&gt; <br>&gt; <br>&gt; there is no reuse problem in the interpretation I propose, and the long/short form names are completely interchangeable.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would not be able to assign to a variable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let selectedOperation = .fill<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to then do this later in the program:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; scaleAndCropImage(image: myImage, toSize: size, operation: selectedOperation)<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/c430a432/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  4, 2016 at 08:00:00am</p></header><div class="content"><p>See<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019825.html<br></p><p>as well as <br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019908.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019827.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019826.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019905.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019878.html<br></p><p><br>Regards<br>(From mobile)<br></p><p>&gt; On Jun 2, 2016, at 8:56 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; Hi Laurent,<br>&gt; <br>&gt; Do you have the details of your proposal, I missed it. <br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 1:48 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 5:05 AM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 7:48 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 3:04 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You would not be able to assign `.fill` to a variable and use that for the operation value.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is my objection to this idea. It does not encourage reuse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1For me too. Introducing this quasi-enum would increase cognitive load with little, if any, net benefit. This is the sort of feature that looks great and works wonderfully in example apps, but does not scale well to real systems, where options show up in more methods through time, get passed around to helpers, stored, marshaled into various formats, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As someone mentioned, this would probably be a good fit If Swift adopts a structural type system (I suppose, I have ever used a language with one to my knowledge, unless duck typing counts)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As syntactic sugar for a true enum declaration, it would be a “cool” feature, but reuse would still be problematic. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; there is no reuse problem in the interpretation I propose, and the long/short form names are completely interchangeable.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would not be able to assign to a variable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let selectedOperation = .fill<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order to then do this later in the program:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; scaleAndCropImage(image: myImage, toSize: size, operation: selectedOperation)<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/e6679e2b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  2, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 31.05.2016 um 21:04 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 12:35 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think I&#39;m -1 on this.  It makes things easier for the implementer of the function and harder for the caller.  <br>&gt;&gt; <br>&gt;&gt; It&#39;s not clear whether the caller could store an argument to pass in a variable, but if they could they would need to list out all cases in the type of the variable (unless these anonymous enums have structural subtyping).  This is fragile.  Any time that list changes all variable declarations will have to be updated.<br>&gt;&gt; <br>&gt;&gt; Functions are implemented once and usually called more many times.  It&#39;s better for callers if you just write it like this:<br>&gt;&gt; <br>&gt;&gt; enum FitOrFill { case fit, fill }<br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt; image: UIImage,<br>&gt;&gt; toSize size: CGSize,<br>&gt;&gt; operation: FitOrFill = .fit<br>&gt;&gt; ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; So unless these anonymous enums are structurally subtyped I think it&#39;s a bad idea.  And introducing structural subtyping here seems like a pretty large hammer for this use case.<br>&gt; <br>&gt; <br>&gt; From the caller&#39;s point of view, the type must be inferable and exactly match a token listed in the declaration (which would also appear in Quick Help):<br>&gt; <br>&gt; let _ = scaleAndCropImage(image: myImage, toSize: size, operation: .fill)<br>&gt; <br>&gt; You would not be able to assign `.fill` to a variable and use that for the operation value.<br></p><p>That&#39;s a big negative point. This means that a small convenience for the implementor results in heavy restrictions for the caller who cannot structure his algorithm appropriately and will probably have to create (i.e. duplicate) the enum anyway.<br>Thinking of your example: where might the value for .fit or .fill come from? In most cases it won&#39;t be hardcoded in the call, but be either the result of a user setting or an algorithm. Both would need to be able to assign this value.<br></p><p>As a consequence this is just a feature for use in a Playground where it is very convenient, but that means it doesn&#39;t pull its own weight, because it degrades the design outside of Playgrounds.<br>So a -1 from me.<br></p><p>-Thorsten <br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/0c75a89a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes, great point! I think this is a sign it’s better to just have one way with an enum, so there’s no deciding on which method to use, or reluctance to switch away from ad hoc enums because they felt nicer initially. And enums aren’t that much to write.<br></p><p>With the addition of a macro system in future Swift you could probably create your own ad hoc enums, and that would be perfect for something like a playground.<br></p><p>Patrick<br></p><p>&gt; On 2 Jun 2016, at 2:57 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thinking of your example: where might the value for .fit or .fill come from? In most cases it won&#39;t be hardcoded in the call, but be either the result of a user setting or an algorithm. Both would need to be able to assign this value.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/cdda243c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br></p><p>As I said the last time this proposal came up, I think this is great right up until the moment you need `operation` to be computed or kept in a variable. Then you need to start copying your anonymous enum type all over your source, and there&#39;s no central place to make changes. The same thing is true of tuples, but tuples are easy to structure and destructure from individual values on the spot; anonymous enums aren&#39;t really like that.<br></p><p>And this problem starts occurring *very* quickly. I mean, you&#39;ve left `scaleAndCropImage`&#39;s implementation out. Imagine implementing it with a couple helper functions, and you start to see this problem occurring:<br></p><p>	func scaleAndCrop(image: UIImage, to size: CGSize, operation: (.fit | .fill) = .fit) -&gt; UIImage {<br>		let drawingRect = rect(of: size, for: operation)<br>		return drawnImage(image, in: drawingRect)<br>	}<br>	<br>	private func rect(of size: CGSize, for operation: (.fit | .fill)) -&gt; CGRect {<br></p><p>Already we have one duplication; if we add .fillWidth and .fillHeight modes, we&#39;ll need to change signatures in two places.<br></p><p>In short, when you dig into this proposal and start thinking of use cases that are even slightly less than completely trivial, I think the case for it falls apart.<br></p><p>(It&#39;s also worth noting that this isn&#39;t suitable for options, because it creates an anonymous enum, not an anonymous option set.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 3:20 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;    image: UIImage,<br>&gt;&gt;    toSize size: CGSize,<br>&gt;&gt;    operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;    ) -&gt; UIImage {<br>&gt; <br>&gt; As I said the last time this proposal came up, I think this is great right up until the moment you need `operation` to be computed or kept in a variable. Then you need to start copying your anonymous enum type all over your source, and there&#39;s no central place to make changes. The same thing is true of tuples, but tuples are easy to structure and destructure from individual values on the spot; anonymous enums aren&#39;t really like that.<br></p><p>And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>If we go back to your original example:<br></p><p><br></p><p>func scaleAndCropImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    fitImage: Bool = true<br>    ) -&gt; UIImage {<br></p><p>There is a different type of sugar that I would like to have: Having label stand for `true` when we have a defaulted boolean flag, whose default value is false.<br></p><p>At call site we either say:<br></p><p>scaleAndCropImage(image: myImage, toSize: mySize)<br></p><p>or: <br></p><p>scaleAndCropImage(image: myImage, toSize: mySize, fitImage)<br></p><p>We could still use:<br></p><p>scaleAndCropImage(image: myImage, toSize: mySize, fitImage: true)<br>or<br>scaleAndCropImage(image: myImage, toSize: mySize, fitImage: false)<br></p><p>Note that this is addressing a different situation: When we have multiple boolean flag parameters that can be combined like an OptionSet.<br></p><p>This is purely sugar: if the identifier matches the label of a defaulted to false boolean flag, it is interpreted as if the flag was passed as true. Other than that there is no effect.<br></p><p>I also like your idea as long as we put a limitation like what you proposed: Having it strictly be a UInt8 (or whatever) enum. Still the general resilience issues with enums remain and may get more complicated with this addition.<br></p><p><br>&gt; On May 31, 2016, at 3:00 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 3:20 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;&gt;   image: UIImage,<br>&gt;&gt;&gt;   toSize size: CGSize,<br>&gt;&gt;&gt;   operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;   ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; As I said the last time this proposal came up, I think this is great right up until the moment you need `operation` to be computed or kept in a variable. Then you need to start copying your anonymous enum type all over your source, and there&#39;s no central place to make changes. The same thing is true of tuples, but tuples are easy to structure and destructure from individual values on the spot; anonymous enums aren&#39;t really like that.<br>&gt; <br>&gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/52d5894d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>Correction/ Clarification. My assumption. The signature I am assuming is actually:<br></p><p><br>func scaleAndCropImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    fitImage: Bool = false<br>    ) -&gt; UIImage {<br></p><p>&gt; On May 31, 2016, at 3:27 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If we go back to your original example:<br>&gt; <br>&gt; <br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     fitImage: Bool = true<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; There is a different type of sugar that I would like to have: Having label stand for `true` when we have a defaulted boolean flag, whose default value is false.<br>&gt; <br>&gt; At call site we either say:<br>&gt; <br>&gt; scaleAndCropImage(image: myImage, toSize: mySize)<br>&gt; <br>&gt; or: <br>&gt; <br>&gt; scaleAndCropImage(image: myImage, toSize: mySize, fitImage)<br>&gt; <br>&gt; We could still use:<br>&gt; <br>&gt; scaleAndCropImage(image: myImage, toSize: mySize, fitImage: true)<br>&gt; or<br>&gt; scaleAndCropImage(image: myImage, toSize: mySize, fitImage: false)<br>&gt; <br>&gt; Note that this is addressing a different situation: When we have multiple boolean flag parameters that can be combined like an OptionSet.<br>&gt; <br>&gt; This is purely sugar: if the identifier matches the label of a defaulted to false boolean flag, it is interpreted as if the flag was passed as true. Other than that there is no effect.<br>&gt; <br>&gt; I also like your idea as long as we put a limitation like what you proposed: Having it strictly be a UInt8 (or whatever) enum. Still the general resilience issues with enums remain and may get more complicated with this addition.<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 3:00 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 3:20 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;&gt;&gt;   image: UIImage,<br>&gt;&gt;&gt;&gt;   toSize size: CGSize,<br>&gt;&gt;&gt;&gt;   operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;&gt;   ) -&gt; UIImage {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I said the last time this proposal came up, I think this is great right up until the moment you need `operation` to be computed or kept in a variable. Then you need to start copying your anonymous enum type all over your source, and there&#39;s no central place to make changes. The same thing is true of tuples, but tuples are easy to structure and destructure from individual values on the spot; anonymous enums aren&#39;t really like that.<br>&gt;&gt; <br>&gt;&gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/f31ef535/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br></p><p>If I wanted a language like that, I&#39;d be writing C, not Swift.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 09:00:00pm</p></header><div class="content"><p>I admire the desire of this proposal to increase the readability of code.<br>I&#39;m -1 to the proposal itself, though:<br></p><p>- It breaks the ability to pass in a variable containing the desired value,<br>rather than the literal value itself. (Unless you actually want a<br>not-so-anonymous enum type whose definition happens to live in a function<br>signature rather than somewhere you&#39;d usually expect a type definition to<br>live.)<br>- It breaks the ability to store a reference to the function in a variable<br>of function type (ditto).<br>- Almost every time I&#39;ve wanted to use one of these &quot;anonymous enums&quot; in my<br>code, I&#39;ve ended up needing to use that same enum elsewhere. In my<br>experience, &#39;lightweight enums&#39; don&#39;t end up saving much time compared to a<br>full-fledged one.<br></p><p>Like Brent said, I have to say no to any proposal that tries to make enums<br>synonyms for numerical values. What happens if you rearrange your anonymous<br>enum cases between library versions? Do you somehow store an opaque<br>case-to-UInt8 table somewhere for every anonymous enum you define for<br>resilience? What happens when people start bringing back terrible C<br>patterns, like doing arithmetic or bitwise ops on the underlying case<br>values? At least you have to try pretty hard as it is to abuse Swift&#39;s<br>enums.<br></p><p>Austin<br></p><p>On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; And the obvious answer is you can have up to 255 of these babies for the<br>&gt; anonymous enum type, and be able to pass numerical equivalents UInt8 with<br>&gt; compile time substitution. That the ad-hoc enumeration is basically a<br>&gt; syntactic shorthand for UInt8, with an enforced upper bound compile time<br>&gt; check simplifies everything including switch statements.<br>&gt;<br>&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/fe86392b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>May 31, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;  It breaks the ability to pass in a variable containing the desired<br>value, rather than the literal value itself.<br></p><p>Maybe that&#39;s appropriate? If the caller is not passing in a hardcoded enum<br>case, then that enum is probably general enough that it warrants a normal<br>enum. But there are also situations where the same function is called from<br>several files in the same code-base with different flags. Those are<br>situations where it feels like overkill to clutter up my codebase with<br>separate enums, only used by a single function.<br></p><p><br></p><p><br></p><p>On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I admire the desire of this proposal to increase the readability of code.<br>&gt; I&#39;m -1 to the proposal itself, though:<br>&gt;<br>&gt; - It breaks the ability to pass in a variable containing the desired<br>&gt; value, rather than the literal value itself. (Unless you actually want a<br>&gt; not-so-anonymous enum type whose definition happens to live in a function<br>&gt; signature rather than somewhere you&#39;d usually expect a type definition to<br>&gt; live.)<br>&gt; - It breaks the ability to store a reference to the function in a variable<br>&gt; of function type (ditto).<br>&gt; - Almost every time I&#39;ve wanted to use one of these &quot;anonymous enums&quot; in<br>&gt; my code, I&#39;ve ended up needing to use that same enum elsewhere. In my<br>&gt; experience, &#39;lightweight enums&#39; don&#39;t end up saving much time compared to a<br>&gt; full-fledged one.<br>&gt;<br>&gt; Like Brent said, I have to say no to any proposal that tries to make enums<br>&gt; synonyms for numerical values. What happens if you rearrange your anonymous<br>&gt; enum cases between library versions? Do you somehow store an opaque<br>&gt; case-to-UInt8 table somewhere for every anonymous enum you define for<br>&gt; resilience? What happens when people start bringing back terrible C<br>&gt; patterns, like doing arithmetic or bitwise ops on the underlying case<br>&gt; values? At least you have to try pretty hard as it is to abuse Swift&#39;s<br>&gt; enums.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; And the obvious answer is you can have up to 255 of these babies for<br>&gt;&gt; the anonymous enum type, and be able to pass numerical equivalents UInt8<br>&gt;&gt; with compile time substitution. That the ad-hoc enumeration is basically a<br>&gt;&gt; syntactic shorthand for UInt8, with an enforced upper bound compile time<br>&gt;&gt; check simplifies everything including switch statements.<br>&gt;&gt;<br>&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/b438e8cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 11:00:00pm</p></header><div class="content"><p>Maybe it&#39;s overkill. My personal opinion is that breaking the symmetry of the language like this (are there any other types of function arguments that cannot be passed as either variable values or literals?) is too much a price to pay. Your library thinks it&#39;s being clever and vends its functions as taking anonymous enum flags, and now there are a bunch of things I can&#39;t do with those functions anymore.<br></p><p>A regular enum can be declared in one line anyways:<br></p><p>enum ScaleCropMode { case Fit, Fill }<br></p><p>Austin <br></p><p>&gt; On May 31, 2016, at 11:44 PM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt; <br>&gt; &gt;  It breaks the ability to pass in a variable containing the desired value, rather than the literal value itself.<br>&gt; <br>&gt; Maybe that&#39;s appropriate? If the caller is not passing in a hardcoded enum case, then that enum is probably general enough that it warrants a normal enum. But there are also situations where the same function is called from several files in the same code-base with different flags. Those are situations where it feels like overkill to clutter up my codebase with separate enums, only used by a single function. <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I admire the desire of this proposal to increase the readability of code. I&#39;m -1 to the proposal itself, though:<br>&gt; <br>&gt; - It breaks the ability to pass in a variable containing the desired value, rather than the literal value itself. (Unless you actually want a not-so-anonymous enum type whose definition happens to live in a function signature rather than somewhere you&#39;d usually expect a type definition to live.)<br>&gt; - It breaks the ability to store a reference to the function in a variable of function type (ditto).<br>&gt; - Almost every time I&#39;ve wanted to use one of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to use that same enum elsewhere. In my experience, &#39;lightweight enums&#39; don&#39;t end up saving much time compared to a full-fledged one.<br>&gt; <br>&gt; Like Brent said, I have to say no to any proposal that tries to make enums synonyms for numerical values. What happens if you rearrange your anonymous enum cases between library versions? Do you somehow store an opaque case-to-UInt8 table somewhere for every anonymous enum you define for resilience? What happens when people start bringing back terrible C patterns, like doing arithmetic or bitwise ops on the underlying case values? At least you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br>&gt; <br>&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/acb7f4aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  1, 2016 at 10:00:00am</p></header><div class="content"><p>On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the symmetry of<br>&gt; the language like this (are there any other types of function arguments<br>&gt; that cannot be passed as either variable values or literals?) is too much a<br>&gt; price to pay. Your library thinks it&#39;s being clever and vends its functions<br>&gt; as taking anonymous enum flags, and now there are a bunch of things I can&#39;t<br>&gt; do with those functions anymore.<br>&gt;<br>&gt; A regular enum can be declared in one line anyways:<br>&gt;<br>&gt; enum ScaleCropMode { case Fit, Fill }<br></p><p>Why do we have tuples? Struct could be defined by one line `struct <br>SomeValue { var x = 0, y = 0 }` ;-)<br>I.e. from my point of view developer should decide what he/she wants to <br>use: ad-hoc enum or defined enum type *exactly* as now he/she can decide to <br>use the same tuples in multiply functions instead of one defined struct type.<br></p><p>I replied regarding the variable on other message. (In short: I think of <br>the same principle as for tuples: you can declare variable `let e: (.fill | <br>.fit) = .fill` and use it)<br></p><p>&gt;<br>&gt; Austin<br>&gt;<br>&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant &lt;charles at charlesism.com<br>&gt;&gt; &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;  It breaks the ability to pass in a variable containing the desired<br>&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;<br>&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a hardcoded<br>&gt;&gt; enum case, then that enum is probably general enough that it warrants a<br>&gt;&gt; normal enum. But there are also situations where the same function is<br>&gt;&gt; called from several files in the same code-base with different flags.<br>&gt;&gt; Those are situations where it feels like overkill to clutter up my<br>&gt;&gt; codebase with separate enums, only used by a single function.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     I admire the desire of this proposal to increase the readability of<br>&gt;&gt;     code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;<br>&gt;&gt;     - It breaks the ability to pass in a variable containing the desired<br>&gt;&gt;     value, rather than the literal value itself. (Unless you actually<br>&gt;&gt;     want a not-so-anonymous enum type whose definition happens to live in<br>&gt;&gt;     a function signature rather than somewhere you&#39;d usually expect a<br>&gt;&gt;     type definition to live.)<br>&gt;&gt;     - It breaks the ability to store a reference to the function in a<br>&gt;&gt;     variable of function type (ditto).<br>&gt;&gt;     - Almost every time I&#39;ve wanted to use one of these &quot;anonymous enums&quot;<br>&gt;&gt;     in my code, I&#39;ve ended up needing to use that same enum elsewhere. In<br>&gt;&gt;     my experience, &#39;lightweight enums&#39; don&#39;t end up saving much time<br>&gt;&gt;     compared to a full-fledged one.<br>&gt;&gt;<br>&gt;&gt;     Like Brent said, I have to say no to any proposal that tries to make<br>&gt;&gt;     enums synonyms for numerical values. What happens if you rearrange<br>&gt;&gt;     your anonymous enum cases between library versions? Do you somehow<br>&gt;&gt;     store an opaque case-to-UInt8 table somewhere for every anonymous<br>&gt;&gt;     enum you define for resilience? What happens when people start<br>&gt;&gt;     bringing back terrible C patterns, like doing arithmetic or bitwise<br>&gt;&gt;     ops on the underlying case values? At least you have to try pretty<br>&gt;&gt;     hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;<br>&gt;&gt;     Austin<br>&gt;&gt;<br>&gt;&gt;     On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;     swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;         &gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br>&gt;&gt;<br>&gt;&gt;         If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;<br>&gt;&gt;         --<br>&gt;&gt;         Brent Royal-Gordon<br>&gt;&gt;         Architechies<br>&gt;&gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  1, 2016 at 01:00:00am</p></header><div class="content"><p>Tuples are a structural type, they are described entirely by the fact that they are a tuple, plus their contained types.<br></p><p>Enum cases are not individual types; that precedent exists nowhere in Swift. You can&#39;t (yet) build a structural type out of something that isn&#39;t a type. The fact that you had to propose something like &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that describes itself, while an anonymous enum isn&#39;t.<br></p><p>Now if enum cases were equivalent if they had the same name (like how &quot;Int&quot; means the same thing no matter what tuple or generic type it is used in), we&#39;d have a good foundation for a self-describing structural type. But this isn&#39;t how the existing named enum types work. Why would it be a good idea to make anonymous enum cases interchangeable by name? Properties on different types aren&#39;t interchangeable, even if they have the same type. In fact, no type member that I am aware of is interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely different things.<br></p><p>Finally, I have to ask: if you are updating your anonymous enum in multiple places, how much effort have you actually saved over a one-line enum definition? In fact, tuples are a great example of this: best practices usually state that they are good for ad-hoc destructuring, such as retrieving multiple return values from a function or pattern matching across several values at once, but structs are better used for almost everything else, since they carry semantic meaning that tuples don&#39;t.<br></p><p>I hope that clarifies my thoughts on the matter.<br></p><p>Best,<br>Austin<br></p><p><br>&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the symmetry of<br>&gt;&gt; the language like this (are there any other types of function arguments<br>&gt;&gt; that cannot be passed as either variable values or literals?) is too much a<br>&gt;&gt; price to pay. Your library thinks it&#39;s being clever and vends its functions<br>&gt;&gt; as taking anonymous enum flags, and now there are a bunch of things I can&#39;t<br>&gt;&gt; do with those functions anymore.<br>&gt;&gt; <br>&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt; <br>&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt; <br>&gt; Why do we have tuples? Struct could be defined by one line `struct SomeValue { var x = 0, y = 0 }` ;-)<br>&gt; I.e. from my point of view developer should decide what he/she wants to use: ad-hoc enum or defined enum type *exactly* as now he/she can decide to use the same tuples in multiply functions instead of one defined struct type.<br>&gt; <br>&gt; I replied regarding the variable on other message. (In short: I think of the same principle as for tuples: you can declare variable `let e: (.fill | .fit) = .fill` and use it)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant &lt;charles at charlesism.com<br>&gt;&gt;&gt; &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;  It breaks the ability to pass in a variable containing the desired<br>&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a hardcoded<br>&gt;&gt;&gt; enum case, then that enum is probably general enough that it warrants a<br>&gt;&gt;&gt; normal enum. But there are also situations where the same function is<br>&gt;&gt;&gt; called from several files in the same code-base with different flags.<br>&gt;&gt;&gt; Those are situations where it feels like overkill to clutter up my<br>&gt;&gt;&gt; codebase with separate enums, only used by a single function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    I admire the desire of this proposal to increase the readability of<br>&gt;&gt;&gt;    code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    - It breaks the ability to pass in a variable containing the desired<br>&gt;&gt;&gt;    value, rather than the literal value itself. (Unless you actually<br>&gt;&gt;&gt;    want a not-so-anonymous enum type whose definition happens to live in<br>&gt;&gt;&gt;    a function signature rather than somewhere you&#39;d usually expect a<br>&gt;&gt;&gt;    type definition to live.)<br>&gt;&gt;&gt;    - It breaks the ability to store a reference to the function in a<br>&gt;&gt;&gt;    variable of function type (ditto).<br>&gt;&gt;&gt;    - Almost every time I&#39;ve wanted to use one of these &quot;anonymous enums&quot;<br>&gt;&gt;&gt;    in my code, I&#39;ve ended up needing to use that same enum elsewhere. In<br>&gt;&gt;&gt;    my experience, &#39;lightweight enums&#39; don&#39;t end up saving much time<br>&gt;&gt;&gt;    compared to a full-fledged one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Like Brent said, I have to say no to any proposal that tries to make<br>&gt;&gt;&gt;    enums synonyms for numerical values. What happens if you rearrange<br>&gt;&gt;&gt;    your anonymous enum cases between library versions? Do you somehow<br>&gt;&gt;&gt;    store an opaque case-to-UInt8 table somewhere for every anonymous<br>&gt;&gt;&gt;    enum you define for resilience? What happens when people start<br>&gt;&gt;&gt;    bringing back terrible C patterns, like doing arithmetic or bitwise<br>&gt;&gt;&gt;    ops on the underlying case values? At least you have to try pretty<br>&gt;&gt;&gt;    hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;    swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        &gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        --<br>&gt;&gt;&gt;        Brent Royal-Gordon<br>&gt;&gt;&gt;        Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        _______________________________________________<br>&gt;&gt;&gt;        swift-evolution mailing list<br>&gt;&gt;&gt;        swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  1, 2016 at 03:00:00pm</p></header><div class="content"><p>On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt; that they are a tuple, plus their contained types.<br>&gt;<br>&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt; describes itself, while an anonymous enum isn&#39;t.<br></p><p>Yes, I understand the point about the type of such adhoc enum.<br>The only workaround I can see in this case(if we&#39;d really want to have it <br>in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual <br>representation if the declared type. As I understand this also could not be <br>a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br></p><p> From other point of view, adding such type to typesystem will add some <br>consistence : you can create a function that don&#39;t need definition of <br>separate structure type(tuple will be used) and don&#39;t need separate enum <br>type(ad-hoc enum will be used). I.e. all data the function needs to process <br>could be described in function definition. Today we need to use ugly Bool <br>flags in case we want to achieve the same target.<br></p><p>&gt;<br>&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt; the same type. In fact, no type member that I am aware of is<br>&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt; different things.<br></p><p>I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like <br>tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum <br>in function parameters - then they are of the same type.<br></p><p>I.e. :<br></p><p>func foo(option: (.fit|.fill)) {..}<br></p><p>foo(.fit) // .fit is of type  (.fit|.fill) from definition<br></p><p>let e : (.fit|.fill) = .fit<br>foo(e) // e is of (.fit|.fill) type, equal to definition<br></p><p>but<br></p><p>func foo2(option: (.fit|.fill|.other)) {..}<br></p><p>foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br></p><p>&gt;<br>&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt; such as retrieving multiple return values from a function or pattern<br>&gt; matching across several values at once, but structs are better used for<br>&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt; don&#39;t.<br>&gt;<br></p><p>Just the same pros and cons for ad-hoc enums vs enum declaration as for <br>tuples vs struct declaration. Yes can use it with care and you can use it <br>in wrong way.<br></p><p>Btw, I feel like this could be very handy to return adhoc enum:<br></p><p>func something() -&gt; (.one|.two|.three) {...}<br></p><p>&gt; I hope that clarifies my thoughts on the matter.<br>&gt;<br>&gt; Best, Austin<br>&gt;<br>&gt;<br>&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt;<br>&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt;<br>&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt;&gt;&gt; one.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt; <br>&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt; demonstrates the proposal&#39;s weaknesses:<br></p><p>Vehemently disagree! The problem is only to think that the name must be random: It CAN ABSOLUTELY NOT be random in order to respect the semantic of a nominal type. Once you accept that, then this is just a very simple and clever syntax sugaring for enum declarations.<br></p><p>See my other response for more details<br></p><p>&gt;&gt; a tuple is an ad-hoc type that<br>&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt; <br>&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt; The only workaround I can see in this case(if we&#39;d really want to have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual representation if the declared type. As I understand this also could not be a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt; <br>&gt; From other point of view, adding such type to typesystem will add some consistence : you can create a function that don&#39;t need definition of separate structure type(tuple will be used) and don&#39;t need separate enum type(ad-hoc enum will be used). I.e. all data the function needs to process could be described in function definition. Today we need to use ugly Bool flags in case we want to achieve the same target.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt; different things.<br>&gt; <br>&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum in function parameters - then they are of the same type.<br>&gt; <br>&gt; I.e. :<br>&gt; <br>&gt; func foo(option: (.fit|.fill)) {..}<br>&gt; <br>&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt; <br>&gt; let e : (.fit|.fill) = .fit<br>&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt; <br>&gt; but<br>&gt; <br>&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt; <br>&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt; matching across several values at once, but structs are better used for<br>&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt; don&#39;t.<br>&gt;&gt; <br>&gt; <br>&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as for tuples vs struct declaration. Yes can use it with care and you can use it in wrong way.<br>&gt; <br>&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt; <br>&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt; <br>&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt; <br>&gt;&gt; Best, Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 8:58 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses:<br>&gt; <br>&gt; Vehemently disagree! The problem is only to think that the name must be random: It CAN ABSOLUTELY NOT be random in order to respect the semantic of a nominal type. Once you accept that, then this is just a very simple and clever syntax sugaring for enum declarations.<br></p><p>My point isn&#39;t that the name is random, it&#39;s that you need an autogenerated name to begin with, and that it shouldn&#39;t be compared to a tuple because (like you said) it&#39;s a nominal type (albeit one that you don&#39;t directly name).<br></p><p>That being said, I completely agree with you that this is just language sugar around some types that the compiler synthesizes for you. It&#39;s sugar I consider a largely useless addition to the language, but there is nothing technical stopping it from being implemented.<br></p><p>&gt; <br>&gt; See my other response for more details<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  1, 2016 at 06:00:00pm</p></header><div class="content"><p>The only problem with this proposal is to consider them ad-hoc enums... If we view them as having nothing ad-hoc about them and the thing to be a simple sugaring exercise, then I think all the opositions on grounds of breaking the language disapear. It still does not mean it should be done if the core team does not like the idea of encouraging laziness, or simply do not like what it makes them look like. No matter what, this type of sugaring exercise has been clearly stated as out of scope for 3.0<br></p><p>&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt; <br>&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt; <br>&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt; The only workaround I can see in this case(if we&#39;d really want to have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual representation if the declared type. As I understand this also could not be a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt; <br>&gt; From other point of view, adding such type to typesystem will add some consistence : you can create a function that don&#39;t need definition of separate structure type(tuple will be used) and don&#39;t need separate enum type(ad-hoc enum will be used). I.e. all data the function needs to process could be described in function definition. Today we need to use ugly Bool flags in case we want to achieve the same target.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt; different things.<br>&gt; <br>&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum in function parameters - then they are of the same type.<br>&gt; <br>&gt; I.e. :<br>&gt; <br>&gt; func foo(option: (.fit|.fill)) {..}<br>&gt; <br>&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt; <br>&gt; let e : (.fit|.fill) = .fit<br>&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt; <br>&gt; but<br>&gt; <br>&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt; <br>&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt; matching across several values at once, but structs are better used for<br>&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt; don&#39;t.<br>&gt;&gt; <br>&gt; <br>&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as for tuples vs struct declaration. Yes can use it with care and you can use it in wrong way.<br>&gt; <br>&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt; <br>&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt; <br>&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt; <br>&gt;&gt; Best, Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Yes, I also can support the idea of autogenerated type name (like <br>Enum_fit_OR_fill) as long as it allows to do all the things we are <br>discussing here: declare (.fit|.fill) in function, use .fit on calling <br>side, use (.fit|.fill) to declare temporary variable of type compatible <br>with such function parameter etc.<br></p><p>But how do you suggest to define a type of such function in `typealias` for <br>example? i.e. for func my(option: (.fit|.fill) {..}<br></p><p>typealias MyFunc = ((.fit|.fill)) -&gt; ()<br></p><p>or as<br></p><p>typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br></p><p>?<br></p><p>But I still can&#39;t support the idea of limiting the usage of such enums - <br>i.e. &quot;To deal with milti site definition, the compiler would simply flag a <br>error/warning, or be silent in the presence of a new annotation:&quot;. I really <br>think we need then introduce the same rule for tuples - so no one can use <br>the same tuple declaration in function - they then should declare separate <br>struct type or use @something for such functions. Nobody wants such rule <br>for tuples.<br></p><p>On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt; The only problem with this proposal is to consider them ad-hoc enums... If we view them as having nothing ad-hoc about them and the thing to be a simple sugaring exercise, then I think all the opositions on grounds of breaking the language disapear. It still does not mean it should be done if the core team does not like the idea of encouraging laziness, or simply do not like what it makes them look like. No matter what, this type of sugaring exercise has been clearly stated as out of scope for 3.0<br>&gt;<br>&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;&gt;<br>&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual representation if the declared type. As I understand this also could not be a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;&gt;<br>&gt;&gt; From other point of view, adding such type to typesystem will add some consistence : you can create a function that don&#39;t need definition of separate structure type(tuple will be used) and don&#39;t need separate enum type(ad-hoc enum will be used). I.e. all data the function needs to process could be described in function definition. Today we need to use ugly Bool flags in case we want to achieve the same target.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt;&gt; different things.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum in function parameters - then they are of the same type.<br>&gt;&gt;<br>&gt;&gt; I.e. :<br>&gt;&gt;<br>&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;&gt;<br>&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;&gt;<br>&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;&gt;<br>&gt;&gt; but<br>&gt;&gt;<br>&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;&gt;<br>&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt;&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt;&gt; matching across several values at once, but structs are better used for<br>&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt;&gt; don&#39;t.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as for tuples vs struct declaration. Yes can use it with care and you can use it in wrong way.<br>&gt;&gt;<br>&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;&gt;<br>&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;&gt;<br>&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best, Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  1, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes, I also can support the idea of autogenerated type name (like Enum_fit_OR_fill) as long as it allows to do all the things we are discussing here: declare (.fit|.fill) in function, use .fit on calling side, use (.fit|.fill) to declare temporary variable of type compatible with such function parameter etc.<br>&gt; <br></p><p>It all works because the compiler is just being a thoughless scribe that just writes the standard enum we don&#39;t bother to write ourselves. Because the heuristic is simple and straightforward then it is predictible. The enum can be used with its long name be ause it is a real enum. And writing the short form of it also works because the compiler knowns uniquely what the long name is everytime it runs into the short name.<br></p><p><br>&gt; But how do you suggest to define a type of such function in `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt; <br>&gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt; or as<br>&gt; <br>&gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt; <br></p><p>Ideally there is no difference whatsoever, there is a single enum, it is produced at the module level, and it has the long form name.<br></p><p>There can be rules that would prevent us from doing that with externally visible APIs, if the core team fuges that we should take the time to write our enums manually and cleanly to make them visible to the world, but it is not a necessary rule.<br></p><p><br>&gt; <br>&gt; But I still can&#39;t support the idea of limiting the usage of such enums - i.e. &quot;To deal with milti site definition, the compiler would simply flag a error/warning, or be silent in the presence of a new annotation:&quot;. I really think we need then introduce the same rule for tuples - so no one can use the same tuple declaration in function - they then should declare separate struct type or use @something for such functions. Nobody wants such rule for tuples.<br>&gt; <br></p><p>Multi site thing is not a limitation... Is is a proposed rule to say that we are able to be lazy twice without being penalized. Yhe compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. But because this is about concise and lazy, then the compiler can let us get away with it if we use an annotation that lets it know that &quot;it is not a mistake.. I really dont want to write that enum myself, even though I am using the same abbreviation twice&quot;. Otherwise, the compiler would let us know that the second time could be a mistake because there is already something with the same name...<br></p><p>But again this is a separate idea from the core notion of a syntax sugaring for writing real enums the lazy (clever) way<br></p><p>&gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;&gt; The only problem with this proposal is to consider them ad-hoc enums... If we view them as having nothing ad-hoc about them and the thing to be a simple sugaring exercise, then I think all the opositions on grounds of breaking the language disapear. It still does not mean it should be done if the core team does not like the idea of encouraging laziness, or simply do not like what it makes them look like. No matter what, this type of sugaring exercise has been clearly stated as out of scope for 3.0<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual representation if the declared type. As I understand this also could not be a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From other point of view, adding such type to typesystem will add some consistence : you can create a function that don&#39;t need definition of separate structure type(tuple will be used) and don&#39;t need separate enum type(ad-hoc enum will be used). I.e. all data the function needs to process could be described in function definition. Today we need to use ugly Bool flags in case we want to achieve the same target.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt;&gt;&gt; different things.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum in function parameters - then they are of the same type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I.e. :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt;&gt;&gt; matching across several values at once, but structs are better used for<br>&gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt;&gt;&gt; don&#39;t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as for tuples vs struct declaration. Yes can use it with care and you can use it in wrong way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  2, 2016 at 12:00:00am</p></header><div class="content"><p>OK, I understand most of your points and feel the same regarding the <br>proposed feature... but:<br></p><p> &gt; .. the compiler does not like when we define the same thing twice, and <br>thse short form amount to doing what he does not let us do. ..<br> &gt; .. if we use an annotation that lets it know that &quot;it is not a mistake..<br> &gt; I really dont want to write that enum myself, even though I am using the<br> &gt; same abbreviation twice&quot;. Otherwise, the compiler would let us know that<br> &gt; the second time could be a mistake because there is already something<br> &gt; with the same name...<br></p><p>I just wanted to understand how such enums are different than tuples in <br>meaning of &quot;I don&#39;t want to write the struct myself&quot;, &quot;Yes, I&#39;m using the <br>same tuple twice&quot;, &quot;Compiler will let us know that we used the same tuple <br>again and probably mistake as has already the same&quot;. (Not about differences <br>in implementation/representation on compiler level, but on level of one who <br>is writting the code)<br></p><p>Should we use the same arguments to propose the special annotation when we <br>have the same tuple more than once? No. So I believe there should be no <br>such limitation and special annotation for proposed enums.<br></p><p>On 01.06.2016 23:43, L. Mihalkovic wrote:<br>&gt;<br>&gt;<br>&gt;&gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Yes, I also can support the idea of autogenerated type name (like Enum_fit_OR_fill) as long as it allows to do all the things we are discussing here: declare (.fit|.fill) in function, use .fit on calling side, use (.fit|.fill) to declare temporary variable of type compatible with such function parameter etc.<br>&gt;&gt;<br>&gt;<br>&gt; It all works because the compiler is just being a thoughless scribe that just writes the standard enum we don&#39;t bother to write ourselves. Because the heuristic is simple and straightforward then it is predictible. The enum can be used with its long name be ause it is a real enum. And writing the short form of it also works because the compiler knowns uniquely what the long name is everytime it runs into the short name.<br>&gt;<br>&gt;<br>&gt;&gt; But how do you suggest to define a type of such function in `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt;&gt;<br>&gt;&gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt;&gt; or as<br>&gt;&gt;<br>&gt;&gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt;&gt;<br>&gt;<br>&gt; Ideally there is no difference whatsoever, there is a single enum, it is produced at the module level, and it has the long form name.<br>&gt;<br>&gt; There can be rules that would prevent us from doing that with externally visible APIs, if the core team fuges that we should take the time to write our enums manually and cleanly to make them visible to the world, but it is not a necessary rule.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; But I still can&#39;t support the idea of limiting the usage of such enums - i.e. &quot;To deal with milti site definition, the compiler would simply flag a error/warning, or be silent in the presence of a new annotation:&quot;. I really think we need then introduce the same rule for tuples - so no one can use the same tuple declaration in function - they then should declare separate struct type or use @something for such functions. Nobody wants such rule for tuples.<br>&gt;&gt;<br>&gt;<br>&gt; Multi site thing is not a limitation... Is is a proposed rule to say that we are able to be lazy twice without being penalized. Yhe compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. But because this is about concise and lazy, then the compiler can let us get away with it if we use an annotation that lets it know that &quot;it is not a mistake.. I really dont want to write that enum myself, even though I am using the same abbreviation twice&quot;. Otherwise, the compiler would let us know that the second time could be a mistake because there is already something with the same name...<br>&gt;<br>&gt; But again this is a separate idea from the core notion of a syntax sugaring for writing real enums the lazy (clever) way<br>&gt;<br>&gt;&gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;&gt;&gt; The only problem with this proposal is to consider them ad-hoc enums... If we view them as having nothing ad-hoc about them and the thing to be a simple sugaring exercise, then I think all the opositions on grounds of breaking the language disapear. It still does not mean it should be done if the core team does not like the idea of encouraging laziness, or simply do not like what it makes them look like. No matter what, this type of sugaring exercise has been clearly stated as out of scope for 3.0<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;&gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;&gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual representation if the declared type. As I understand this also could not be a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; From other point of view, adding such type to typesystem will add some consistence : you can create a function that don&#39;t need definition of separate structure type(tuple will be used) and don&#39;t need separate enum type(ad-hoc enum will be used). I.e. all data the function needs to process could be described in function definition. Today we need to use ugly Bool flags in case we want to achieve the same target.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt;&gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt;&gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt;&gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt;&gt;&gt;&gt; different things.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum in function parameters - then they are of the same type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I.e. :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;&gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; but<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;&gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt;&gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt;&gt;&gt;&gt; matching across several values at once, but structs are better used for<br>&gt;&gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt;&gt;&gt;&gt; don&#39;t.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as for tuples vs struct declaration. Yes can use it with care and you can use it in wrong way.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  2, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 11:20 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; OK, I understand most of your points and feel the same regarding the proposed feature... but:<br>&gt; <br>&gt; &gt; .. the compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. ..<br>&gt; &gt; .. if we use an annotation that lets it know that &quot;it is not a mistake..<br>&gt; &gt; I really dont want to write that enum myself, even though I am using the<br>&gt; &gt; same abbreviation twice&quot;. Otherwise, the compiler would let us know that<br>&gt; &gt; the second time could be a mistake because there is already something<br>&gt; &gt; with the same name...<br>&gt; <br>&gt; I just wanted to understand how such enums are different than tuples in meaning of &quot;I don&#39;t want to write the struct myself&quot;, &quot;Yes, I&#39;m using the same tuple twice&quot;, &quot;Compiler will let us know that we used the same tuple again and probably mistake as has already the same&quot;. (Not about differences in implementation/representation on compiler level, but on level of one who is writting the code)<br>&gt; <br>&gt; Should we use the same arguments to propose the special annotation when we have the same tuple more than once? No. So I believe there should be no such limitation and special annotation for proposed enums.<br>&gt; <br></p><p>I am not sure the parallel can be made. A tuple is characterized by its structure, BUT the scope of its use is the VARIABLE where it is being used (I am simplifying by only referring to var/let cases). So from the compiler’s point of view, there is not a giant Tuples hash table where it can look for a given tuple definition based on its intrinsic name. So even if you repeat the same tuple definition every other line in your source code, the compiler never thinks that they are the same type because they ARE NOT the same. Each one is a different variable (the compiler would complain that the variable is defined multiple times though). To simplify the model, you could almost think that a tuple is a degenerate struct that is internally given the name of its usage site. It is not quite true but it is a close-enough approximation of what it really is.<br></p><p>The only rational for allowing a @I_know_what_I_am_doing_so_please_dont_complain annotation is to allow (and I am not saying it should be allowed)<br></p><p><br>func scaleAndCropLargeImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    operation: (.Fit | .Fill) = .Fit<br>    ) -&gt; UIImage {<br>  whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>}<br></p><p>func scaleAndCropSmallImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    operation: (.Fit | .Fill) = .Fit<br>    ) -&gt; UIImage {<br>  whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>}<br></p><p><br>private <br>func whoCaresThereIsReallyASingleTypeOfImagesAnyhow(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    operation: (.Fit | .Fill) = .Fit<br>    ) -&gt; UIImage {<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/cea0c45b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June  1, 2016 at 11:00:00pm</p></header><div class="content"><p>I was once relying on the state of things to judge the validity of some access modifier claims and I was rebuked on the grounds that proposals should be evaluated based on their merits, not on implementation details.<br></p><p>And as far as implementation details go, this doesn&#39;t match what I understand of tuples. Looking at SIL, tuple types from different declarations appear just as identical as they do in source code. In fact, the output is exactly the same even when using a tuple typealias. Do you have an experiment or compiler code that would support your claims?<br></p><p>Félix<br></p><p>&gt; Le 1 juin 2016 à 22:35:21, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 11:20 PM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; OK, I understand most of your points and feel the same regarding the proposed feature... but:<br>&gt;&gt; <br>&gt;&gt; &gt; .. the compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. ..<br>&gt;&gt; &gt; .. if we use an annotation that lets it know that &quot;it is not a mistake..<br>&gt;&gt; &gt; I really dont want to write that enum myself, even though I am using the<br>&gt;&gt; &gt; same abbreviation twice&quot;. Otherwise, the compiler would let us know that<br>&gt;&gt; &gt; the second time could be a mistake because there is already something<br>&gt;&gt; &gt; with the same name...<br>&gt;&gt; <br>&gt;&gt; I just wanted to understand how such enums are different than tuples in meaning of &quot;I don&#39;t want to write the struct myself&quot;, &quot;Yes, I&#39;m using the same tuple twice&quot;, &quot;Compiler will let us know that we used the same tuple again and probably mistake as has already the same&quot;. (Not about differences in implementation/representation on compiler level, but on level of one who is writting the code)<br>&gt;&gt; <br>&gt;&gt; Should we use the same arguments to propose the special annotation when we have the same tuple more than once? No. So I believe there should be no such limitation and special annotation for proposed enums.<br>&gt;&gt; <br>&gt; <br>&gt; I am not sure the parallel can be made. A tuple is characterized by its structure, BUT the scope of its use is the VARIABLE where it is being used (I am simplifying by only referring to var/let cases). So from the compiler’s point of view, there is not a giant Tuples hash table where it can look for a given tuple definition based on its intrinsic name. So even if you repeat the same tuple definition every other line in your source code, the compiler never thinks that they are the same type because they ARE NOT the same. Each one is a different variable (the compiler would complain that the variable is defined multiple times though). To simplify the model, you could almost think that a tuple is a degenerate struct that is internally given the name of its usage site. It is not quite true but it is a close-enough approximation of what it really is.<br>&gt; <br>&gt; The only rational for allowing a @I_know_what_I_am_doing_so_please_dont_complain annotation is to allow (and I am not saying it should be allowed)<br>&gt; <br>&gt; <br>&gt; func scaleAndCropLargeImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt;   whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>&gt; }<br>&gt; <br>&gt; func scaleAndCropSmallImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt;   whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>&gt; }<br>&gt; <br>&gt; <br>&gt; private <br>&gt; func whoCaresThereIsReallyASingleTypeOfImagesAnyhow(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/11c8064f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  2, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 8:04 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I was once relying on the state of things to judge the validity of some access modifier claims and I was rebuked on the grounds that proposals should be evaluated based on their merits, not on implementation details.<br>&gt; <br>&gt; And as far as implementation details go, this doesn&#39;t match what I understand of tuples. Looking at SIL, tuple types from different declarations appear just as identical as they do in source code. In fact, the output is exactly the same even when using a tuple typealias. Do you have an experiment or compiler code that would support your claims?<br></p><p>I do not understand your question as it is formulated. What I described is the external behavior. I did not make any reference to the internal structure of the C++ that has managed to make heavy reuse of certain concepts across the whole type system, so indeed part of the differences we perceive at the language level do not exist identically at the implementation level. A fact remains, the language is defined by its grammar… and the grammar chose to expose certain concepts through what we know as struct, class, enum, tuple. Swift could have decided to offer a single Ω data type that would have displayed the behavior of all it current user defined types depending on where it was used. but that would not be swift, right?!<br></p><p>&gt; Félix<br>&gt; <br>&gt;&gt; Le 1 juin 2016 à 22:35:21, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 11:20 PM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; OK, I understand most of your points and feel the same regarding the proposed feature... but:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; .. the compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. ..<br>&gt;&gt;&gt; &gt; .. if we use an annotation that lets it know that &quot;it is not a mistake..<br>&gt;&gt;&gt; &gt; I really dont want to write that enum myself, even though I am using the<br>&gt;&gt;&gt; &gt; same abbreviation twice&quot;. Otherwise, the compiler would let us know that<br>&gt;&gt;&gt; &gt; the second time could be a mistake because there is already something<br>&gt;&gt;&gt; &gt; with the same name...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just wanted to understand how such enums are different than tuples in meaning of &quot;I don&#39;t want to write the struct myself&quot;, &quot;Yes, I&#39;m using the same tuple twice&quot;, &quot;Compiler will let us know that we used the same tuple again and probably mistake as has already the same&quot;. (Not about differences in implementation/representation on compiler level, but on level of one who is writting the code)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should we use the same arguments to propose the special annotation when we have the same tuple more than once? No. So I believe there should be no such limitation and special annotation for proposed enums.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I am not sure the parallel can be made. A tuple is characterized by its structure, BUT the scope of its use is the VARIABLE where it is being used (I am simplifying by only referring to var/let cases). So from the compiler’s point of view, there is not a giant Tuples hash table where it can look for a given tuple definition based on its intrinsic name. So even if you repeat the same tuple definition every other line in your source code, the compiler never thinks that they are the same type because they ARE NOT the same. Each one is a different variable (the compiler would complain that the variable is defined multiple times though). To simplify the model, you could almost think that a tuple is a degenerate struct that is internally given the name of its usage site. It is not quite true but it is a close-enough approximation of what it really is.<br>&gt;&gt; <br>&gt;&gt; The only rational for allowing a @I_know_what_I_am_doing_so_please_dont_complain annotation is to allow (and I am not saying it should be allowed)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func scaleAndCropLargeImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt;   whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropSmallImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt;   whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; private <br>&gt;&gt; func whoCaresThereIsReallyASingleTypeOfImagesAnyhow(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/ef624de7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June  2, 2016 at 09:00:00am</p></header><div class="content"><p>You talked about the &quot;compiler&#39;s point of view&quot; and said about tuples that &quot;the compiler never thinks that they are the same type&quot;. At which level is that true if we&#39;re not talking about the internal workings of the compiler?<br></p><p>There is consensus that Swift does not currently allow enums to be defined like tuples. Of course this is not how things work currently; we wouldn&#39;t be having a proposal otherwise! I don&#39;t see what this adds to the conversation. You could use that argument against any idea of future development.<br></p><p>Félix<br></p><p>&gt; Le 1 juin 2016 à 23:25:10, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 8:04 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was once relying on the state of things to judge the validity of some access modifier claims and I was rebuked on the grounds that proposals should be evaluated based on their merits, not on implementation details.<br>&gt;&gt; <br>&gt;&gt; And as far as implementation details go, this doesn&#39;t match what I understand of tuples. Looking at SIL, tuple types from different declarations appear just as identical as they do in source code. In fact, the output is exactly the same even when using a tuple typealias. Do you have an experiment or compiler code that would support your claims?<br>&gt; <br>&gt; I do not understand your question as it is formulated. What I described is the external behavior. I did not make any reference to the internal structure of the C++ that has managed to make heavy reuse of certain concepts across the whole type system, so indeed part of the differences we perceive at the language level do not exist identically at the implementation level. A fact remains, the language is defined by its grammar… and the grammar chose to expose certain concepts through what we know as struct, class, enum, tuple. Swift could have decided to offer a single Ω data type that would have displayed the behavior of all it current user defined types depending on where it was used. but that would not be swift, right?!<br>&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 1 juin 2016 à 22:35:21, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 11:20 PM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; OK, I understand most of your points and feel the same regarding the proposed feature... but:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; .. the compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. ..<br>&gt;&gt;&gt;&gt; &gt; .. if we use an annotation that lets it know that &quot;it is not a mistake..<br>&gt;&gt;&gt;&gt; &gt; I really dont want to write that enum myself, even though I am using the<br>&gt;&gt;&gt;&gt; &gt; same abbreviation twice&quot;. Otherwise, the compiler would let us know that<br>&gt;&gt;&gt;&gt; &gt; the second time could be a mistake because there is already something<br>&gt;&gt;&gt;&gt; &gt; with the same name...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I just wanted to understand how such enums are different than tuples in meaning of &quot;I don&#39;t want to write the struct myself&quot;, &quot;Yes, I&#39;m using the same tuple twice&quot;, &quot;Compiler will let us know that we used the same tuple again and probably mistake as has already the same&quot;. (Not about differences in implementation/representation on compiler level, but on level of one who is writting the code)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should we use the same arguments to propose the special annotation when we have the same tuple more than once? No. So I believe there should be no such limitation and special annotation for proposed enums.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not sure the parallel can be made. A tuple is characterized by its structure, BUT the scope of its use is the VARIABLE where it is being used (I am simplifying by only referring to var/let cases). So from the compiler’s point of view, there is not a giant Tuples hash table where it can look for a given tuple definition based on its intrinsic name. So even if you repeat the same tuple definition every other line in your source code, the compiler never thinks that they are the same type because they ARE NOT the same. Each one is a different variable (the compiler would complain that the variable is defined multiple times though). To simplify the model, you could almost think that a tuple is a degenerate struct that is internally given the name of its usage site. It is not quite true but it is a close-enough approximation of what it really is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only rational for allowing a @I_know_what_I_am_doing_so_please_dont_complain annotation is to allow (and I am not saying it should be allowed)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func scaleAndCropLargeImage(<br>&gt;&gt;&gt;     image: UIImage,<br>&gt;&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt;&gt;   whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func scaleAndCropSmallImage(<br>&gt;&gt;&gt;     image: UIImage,<br>&gt;&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt;&gt;   whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private <br>&gt;&gt;&gt; func whoCaresThereIsReallyASingleTypeOfImagesAnyhow(<br>&gt;&gt;&gt;     image: UIImage,<br>&gt;&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/459e67fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  3, 2016 at 08:00:00am</p></header><div class="content"><p>Ohh... I get it. We are saying the same thing, just differently. You look at source code then SIL and see that the SIL form is the same, which you formulate as they are the same for the compiler. The same situation is what i refer to as unique: the compiler does not realize what you did.. It simply did the work many times, producing the same code over and over. I call this &quot;each one is unique&quot;.<br></p><p>&gt; On Jun 2, 2016, at 6:03 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; You talked about the &quot;compiler&#39;s point of view&quot; and said about tuples that &quot;the compiler never thinks that they are the same type&quot;. At which level is that true if we&#39;re not talking about the internal workings of the compiler?<br>&gt; <br>&gt; There is consensus that Swift does not currently allow enums to be defined like tuples. Of course this is not how things work currently;<br></p><p>To me the double negative translates to &quot;of course the compiler currently allow enum to be defined like tuples&quot;. Am I understanding it correctly?<br></p><p>If u want yo see how far the differences go, u may want to try to create tiny app with one enum then one with one tuple, then inspect the binaries.<br></p><p>&gt; we wouldn&#39;t be having a proposal otherwise! I don&#39;t see what this adds to the conversation. You could use that argument against any idea of future development.<br></p><p>Could, but hopefully never actually would, right!?<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt;&gt; Le 1 juin 2016 à 23:25:10, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 8:04 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was once relying on the state of things to judge the validity of some access modifier claims and I was rebuked on the grounds that proposals should be evaluated based on their merits, not on implementation details.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And as far as implementation details go, this doesn&#39;t match what I understand of tuples. Looking at SIL, tuple types from different declarations appear just as identical as they do in source code. In fact, the output is exactly the same even when using a tuple typealias. Do you have an experiment or compiler code that would support your claims?<br>&gt;&gt; <br>&gt;&gt; I do not understand your question as it is formulated. What I described is the external behavior. I did not make any reference to the internal structure of the C++ that has managed to make heavy reuse of certain concepts across the whole type system, so indeed part of the differences we perceive at the language level do not exist identically at the implementation level. A fact remains, the language is defined by its grammar… and the grammar chose to expose certain concepts through what we know as struct, class, enum, tuple. Swift could have decided to offer a single Ω data type that would have displayed the behavior of all it current user defined types depending on where it was used. but that would not be swift, right?!<br>&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 1 juin 2016 à 22:35:21, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 11:20 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; OK, I understand most of your points and feel the same regarding the proposed feature... but:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; .. the compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. ..<br>&gt;&gt;&gt;&gt;&gt; &gt; .. if we use an annotation that lets it know that &quot;it is not a mistake..<br>&gt;&gt;&gt;&gt;&gt; &gt; I really dont want to write that enum myself, even though I am using the<br>&gt;&gt;&gt;&gt;&gt; &gt; same abbreviation twice&quot;. Otherwise, the compiler would let us know that<br>&gt;&gt;&gt;&gt;&gt; &gt; the second time could be a mistake because there is already something<br>&gt;&gt;&gt;&gt;&gt; &gt; with the same name...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I just wanted to understand how such enums are different than tuples in meaning of &quot;I don&#39;t want to write the struct myself&quot;, &quot;Yes, I&#39;m using the same tuple twice&quot;, &quot;Compiler will let us know that we used the same tuple again and probably mistake as has already the same&quot;. (Not about differences in implementation/representation on compiler level, but on level of one who is writting the code)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Should we use the same arguments to propose the special annotation when we have the same tuple more than once? No. So I believe there should be no such limitation and special annotation for proposed enums.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am not sure the parallel can be made. A tuple is characterized by its structure, BUT the scope of its use is the VARIABLE where it is being used (I am simplifying by only referring to var/let cases). So from the compiler’s point of view, there is not a giant Tuples hash table where it can look for a given tuple definition based on its intrinsic name. So even if you repeat the same tuple definition every other line in your source code, the compiler never thinks that they are the same type because they ARE NOT the same. Each one is a different variable (the compiler would complain that the variable is defined multiple times though). To simplify the model, you could almost think that a tuple is a degenerate struct that is internally given the name of its usage site. It is not quite true but it is a close-enough approximation of what it really is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only rational for allowing a @I_know_what_I_am_doing_so_please_dont_complain annotation is to allow (and I am not saying it should be allowed)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func scaleAndCropLargeImage(<br>&gt;&gt;&gt;&gt;     image: UIImage,<br>&gt;&gt;&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt;&gt;&gt;   whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func scaleAndCropSmallImage(<br>&gt;&gt;&gt;&gt;     image: UIImage,<br>&gt;&gt;&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt;&gt;&gt;   whoCaresThereIsReallyASingleTypeOfImagesAnyhow()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private <br>&gt;&gt;&gt;&gt; func whoCaresThereIsReallyASingleTypeOfImagesAnyhow(<br>&gt;&gt;&gt;&gt;     image: UIImage,<br>&gt;&gt;&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/911ecfe2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>I find myself agreeing with the idea that ad hoc enums are to enums as<br>structs are to tuples. Based on that analogy, why should an ad hoc enum<br>*need* a name (autogenerated or otherwise) any more than a tuple needs a<br>name? Would those who dislike ad hoc enums argue that this also shouldn&#39;t<br>be allowed:<br></p><p>    func foo(bar: (x: Int, y: Int)) {}<br>    let t: (x: Int, y: Int) = (x: 5, y: 5)<br></p><p>If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax<br>might be), that should just *be* the type the same way that `(x: Int, y:<br>Int)` is a type without a name, and that type can be used in argument<br>lists, variables, or whatever. There shouldn&#39;t be any worry about<br>declarations across multiple functions colliding or being incompatible any<br>more than we would worry about two functions declaring arguments of type<br>`(x: Int, y: Int)` would collide or be incompatible.<br></p><p>One side of ad hoc enums that I&#39;d like to see explored is that, by being<br>unnamed, they&#39;re basically anonymous finite sets and we could apply<br>well-defined subset relationships to them: in other words, we could<br>consider allowing this:<br></p><p>    func foo(bar: (.fit | .fill)) {<br>      baz(bar: bar)<br>    }<br>    func baz(bar: (.fit | .fill | .florp) { ... }<br></p><p>In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>expected if T ⊆ U.<br></p><p><br>On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yes, I also can support the idea of autogenerated type name (like<br>&gt; Enum_fit_OR_fill) as long as it allows to do all the things we are<br>&gt; discussing here: declare (.fit|.fill) in function, use .fit on calling<br>&gt; side, use (.fit|.fill) to declare temporary variable of type compatible<br>&gt; with such function parameter etc.<br>&gt; &gt;<br>&gt;<br>&gt; It all works because the compiler is just being a thoughless scribe that<br>&gt; just writes the standard enum we don&#39;t bother to write ourselves. Because<br>&gt; the heuristic is simple and straightforward then it is predictible. The<br>&gt; enum can be used with its long name be ause it is a real enum. And writing<br>&gt; the short form of it also works because the compiler knowns uniquely what<br>&gt; the long name is everytime it runs into the short name.<br>&gt;<br>&gt;<br>&gt; &gt; But how do you suggest to define a type of such function in `typealias`<br>&gt; for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt; &gt;<br>&gt; &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt; &gt; or as<br>&gt; &gt;<br>&gt; &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt; &gt;<br>&gt;<br>&gt; Ideally there is no difference whatsoever, there is a single enum, it is<br>&gt; produced at the module level, and it has the long form name.<br>&gt;<br>&gt; There can be rules that would prevent us from doing that with externally<br>&gt; visible APIs, if the core team fuges that we should take the time to write<br>&gt; our enums manually and cleanly to make them visible to the world, but it is<br>&gt; not a necessary rule.<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt; But I still can&#39;t support the idea of limiting the usage of such enums -<br>&gt; i.e. &quot;To deal with milti site definition, the compiler would simply flag a<br>&gt; error/warning, or be silent in the presence of a new annotation:&quot;. I really<br>&gt; think we need then introduce the same rule for tuples - so no one can use<br>&gt; the same tuple declaration in function - they then should declare separate<br>&gt; struct type or use @something for such functions. Nobody wants such rule<br>&gt; for tuples.<br>&gt; &gt;<br>&gt;<br>&gt; Multi site thing is not a limitation... Is is a proposed rule to say that<br>&gt; we are able to be lazy twice without being penalized. Yhe compiler does not<br>&gt; like when we define the same thing twice, and thse short form amount to<br>&gt; doing what he does not let us do. But because this is about concise and<br>&gt; lazy, then the compiler can let us get away with it if we use an annotation<br>&gt; that lets it know that &quot;it is not a mistake.. I really dont want to write<br>&gt; that enum myself, even though I am using the same abbreviation twice&quot;.<br>&gt; Otherwise, the compiler would let us know that the second time could be a<br>&gt; mistake because there is already something with the same name...<br>&gt;<br>&gt; But again this is a separate idea from the core notion of a syntax<br>&gt; sugaring for writing real enums the lazy (clever) way<br>&gt;<br>&gt; &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt; &gt;&gt; The only problem with this proposal is to consider them ad-hoc enums...<br>&gt; If we view them as having nothing ad-hoc about them and the thing to be a<br>&gt; simple sugaring exercise, then I think all the opositions on grounds of<br>&gt; breaking the language disapear. It still does not mean it should be done if<br>&gt; the core team does not like the idea of encouraging laziness, or simply do<br>&gt; not like what it makes them look like. No matter what, this type of<br>&gt; sugaring exercise has been clearly stated as out of scope for 3.0<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt; &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt; &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt; &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt; &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt; &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt; &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt; &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt; &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to have<br>&gt; it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual<br>&gt; representation if the declared type. As I understand this also could not be<br>&gt; a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; From other point of view, adding such type to typesystem will add some<br>&gt; consistence : you can create a function that don&#39;t need definition of<br>&gt; separate structure type(tuple will be used) and don&#39;t need separate enum<br>&gt; type(ad-hoc enum will be used). I.e. all data the function needs to process<br>&gt; could be described in function definition. Today we need to use ugly Bool<br>&gt; flags in case we want to achieve the same target.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt; &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt; &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt; &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt; &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by<br>&gt; name?<br>&gt; &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they<br>&gt; have<br>&gt; &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt; &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot;<br>&gt; and<br>&gt; &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt; &gt;&gt;&gt;&gt; different things.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like<br>&gt; tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum<br>&gt; in function parameters - then they are of the same type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I.e. :<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt; &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; but<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt; &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt; &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a<br>&gt; one-line<br>&gt; &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt; &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt; &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt; &gt;&gt;&gt;&gt; matching across several values at once, but structs are better used<br>&gt; for<br>&gt; &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt; &gt;&gt;&gt;&gt; don&#39;t.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as<br>&gt; for tuples vs struct declaration. Yes can use it with care and you can use<br>&gt; it in wrong way.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Best, Austin<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt; &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt; &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt; &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt; &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt; &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt; &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/76e42444/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  2, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; in other words, we could consider allowing this:<br> &gt;    func foo(bar: (.fit | .fill)) {<br> &gt;      baz(bar: bar)<br> &gt;    }<br> &gt;    func baz(bar: (.fit | .fill | .florp) { ... }<br> &gt;<br> &gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br> &gt; expected if T ⊆ U.<br></p><p>Can&#39;t agree with this. Just because the same analogue with tuples : <br>differently defined tuples are different types. Tuples with different order <br>of types in declaration - are different types. So I expect here instance of <br>(.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br></p><p>But +1 to be able to &#39;convert&#39; instance of (.fit | .fill) to instance of <br>(.fit | .fill | .florp). For example(if we&#39;ll have init(caseName) and <br>.caseName for enums):<br></p><p>func foo(bar: (.fit | .fill)) {<br>     let bazbar = (.fit | .fill | .florp).init(caseName: bar.caseName)<br>     baz(bar: bazbar)<br>}<br>func baz(bar: (.fit | .fill | .florp) { ... }<br></p><p><br></p><p>On 02.06.2016 0:38, Tony Allevato wrote:<br>&gt; I find myself agreeing with the idea that ad hoc enums are to enums as<br>&gt; structs are to tuples. Based on that analogy, why should an ad hoc enum<br>&gt; *need* a name (autogenerated or otherwise) any more than a tuple needs a<br>&gt; name? Would those who dislike ad hoc enums argue that this also shouldn&#39;t<br>&gt; be allowed:<br>&gt;<br>&gt;     func foo(bar: (x: Int, y: Int)) {}<br>&gt;     let t: (x: Int, y: Int) = (x: 5, y: 5)<br>&gt;<br>&gt; If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax<br>&gt; might be), that should just *be* the type the same way that `(x: Int, y:<br>&gt; Int)` is a type without a name, and that type can be used in argument<br>&gt; lists, variables, or whatever. There shouldn&#39;t be any worry about<br>&gt; declarations across multiple functions colliding or being incompatible any<br>&gt; more than we would worry about two functions declaring arguments of type<br>&gt; `(x: Int, y: Int)` would collide or be incompatible.<br>&gt;<br>&gt; One side of ad hoc enums that I&#39;d like to see explored is that, by being<br>&gt; unnamed, they&#39;re basically anonymous finite sets and we could apply<br>&gt; well-defined subset relationships to them: in other words, we could<br>&gt; consider allowing this:<br>&gt;<br>&gt;     func foo(bar: (.fit | .fill)) {<br>&gt;       baz(bar: bar)<br>&gt;     }<br>&gt;     func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;<br>&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt; expected if T ⊆ U.<br>&gt;<br>&gt;<br>&gt; On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt;     &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; Yes, I also can support the idea of autogenerated type name (like<br>&gt;     Enum_fit_OR_fill) as long as it allows to do all the things we are<br>&gt;     discussing here: declare (.fit|.fill) in function, use .fit on calling<br>&gt;     side, use (.fit|.fill) to declare temporary variable of type compatible<br>&gt;     with such function parameter etc.<br>&gt;     &gt;<br>&gt;<br>&gt;     It all works because the compiler is just being a thoughless scribe<br>&gt;     that just writes the standard enum we don&#39;t bother to write ourselves.<br>&gt;     Because the heuristic is simple and straightforward then it is<br>&gt;     predictible. The enum can be used with its long name be ause it is a<br>&gt;     real enum. And writing the short form of it also works because the<br>&gt;     compiler knowns uniquely what the long name is everytime it runs into<br>&gt;     the short name.<br>&gt;<br>&gt;<br>&gt;     &gt; But how do you suggest to define a type of such function in<br>&gt;     `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt;     &gt;<br>&gt;     &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt;     &gt; or as<br>&gt;     &gt;<br>&gt;     &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt;     &gt;<br>&gt;<br>&gt;     Ideally there is no difference whatsoever, there is a single enum, it<br>&gt;     is produced at the module level, and it has the long form name.<br>&gt;<br>&gt;     There can be rules that would prevent us from doing that with<br>&gt;     externally visible APIs, if the core team fuges that we should take the<br>&gt;     time to write our enums manually and cleanly to make them visible to<br>&gt;     the world, but it is not a necessary rule.<br>&gt;<br>&gt;<br>&gt;     &gt;<br>&gt;     &gt; But I still can&#39;t support the idea of limiting the usage of such<br>&gt;     enums - i.e. &quot;To deal with milti site definition, the compiler would<br>&gt;     simply flag a error/warning, or be silent in the presence of a new<br>&gt;     annotation:&quot;. I really think we need then introduce the same rule for<br>&gt;     tuples - so no one can use the same tuple declaration in function -<br>&gt;     they then should declare separate struct type or use @something for<br>&gt;     such functions. Nobody wants such rule for tuples.<br>&gt;     &gt;<br>&gt;<br>&gt;     Multi site thing is not a limitation... Is is a proposed rule to say<br>&gt;     that we are able to be lazy twice without being penalized. Yhe compiler<br>&gt;     does not like when we define the same thing twice, and thse short form<br>&gt;     amount to doing what he does not let us do. But because this is about<br>&gt;     concise and lazy, then the compiler can let us get away with it if we<br>&gt;     use an annotation that lets it know that &quot;it is not a mistake.. I<br>&gt;     really dont want to write that enum myself, even though I am using the<br>&gt;     same abbreviation twice&quot;. Otherwise, the compiler would let us know<br>&gt;     that the second time could be a mistake because there is already<br>&gt;     something with the same name...<br>&gt;<br>&gt;     But again this is a separate idea from the core notion of a syntax<br>&gt;     sugaring for writing real enums the lazy (clever) way<br>&gt;<br>&gt;     &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;     &gt;&gt; The only problem with this proposal is to consider them ad-hoc<br>&gt;     enums... If we view them as having nothing ad-hoc about them and the<br>&gt;     thing to be a simple sugaring exercise, then I think all the opositions<br>&gt;     on grounds of breaking the language disapear. It still does not mean it<br>&gt;     should be done if the core team does not like the idea of encouraging<br>&gt;     laziness, or simply do not like what it makes them look like. No matter<br>&gt;     what, this type of sugaring exercise has been clearly stated as out of<br>&gt;     scope for 3.0<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;     &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;     &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;     &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;     &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;     &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;     &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;     &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;     &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to<br>&gt;     have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e.<br>&gt;     textual representation if the declared type. As I understand this also<br>&gt;     could not be a solution.. I.e. for example<br>&gt;     `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; From other point of view, adding such type to typesystem will add<br>&gt;     some consistence : you can create a function that don&#39;t need definition<br>&gt;     of separate structure type(tuple will be used) and don&#39;t need separate<br>&gt;     enum type(ad-hoc enum will be used). I.e. all data the function needs<br>&gt;     to process could be described in function definition. Today we need to<br>&gt;     use ugly Bool flags in case we want to achieve the same target.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;     &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;     &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;     &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;     &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by<br>&gt;     name?<br>&gt;     &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they<br>&gt;     have<br>&gt;     &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;     &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An<br>&gt;     &quot;ArtistAction.Draw&quot; and<br>&gt;     &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;     &gt;&gt;&gt;&gt; different things.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just<br>&gt;     like tuples if you defined adhoc enum with exactly the same cases as<br>&gt;     ad-hoc enum in function parameters - then they are of the same type.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; I.e. :<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;     &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; but<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;     &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;     &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a<br>&gt;     one-line<br>&gt;     &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;     &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;     &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;     &gt;&gt;&gt;&gt; matching across several values at once, but structs are better<br>&gt;     used for<br>&gt;     &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;     &gt;&gt;&gt;&gt; don&#39;t.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as<br>&gt;     for tuples vs struct declaration. Yes can use it with care and you can<br>&gt;     use it in wrong way.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Best, Austin<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com<br>&gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;     &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;     &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;     &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;     &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;     &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;     &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;<br>&gt;     &lt;mailto:charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; _______________________________________________<br>&gt;     &gt;&gt;&gt; swift-evolution mailing list<br>&gt;     &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 07:00:00pm</p></header><div class="content"><p>I think I should start writing that proposal for enum case names now.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Vladimir.S via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎01/‎06/‎2016 07:02 PM<br>To: &quot;Tony Allevato&quot; &lt;allevato at google.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Ad hoc enums / options<br></p><p> &gt; in other words, we could consider allowing this:<br> &gt;    func foo(bar: (.fit | .fill)) {<br> &gt;      baz(bar: bar)<br> &gt;    }<br> &gt;    func baz(bar: (.fit | .fill | .florp) { ... }<br> &gt;<br> &gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br> &gt; expected if T ⊆ U.<br></p><p>Can&#39;t agree with this. Just because the same analogue with tuples : <br>differently defined tuples are different types. Tuples with different order <br>of types in declaration - are different types. So I expect here instance of <br>(.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br></p><p>But +1 to be able to &#39;convert&#39; instance of (.fit | .fill) to instance of <br>(.fit | .fill | .florp). For example(if we&#39;ll have init(caseName) and <br>.caseName for enums):<br></p><p>func foo(bar: (.fit | .fill)) {<br>     let bazbar = (.fit | .fill | .florp).init(caseName: bar.caseName)<br>     baz(bar: bazbar)<br>}<br>func baz(bar: (.fit | .fill | .florp) { ... }<br></p><p><br></p><p>On 02.06.2016 0:38, Tony Allevato wrote:<br>&gt; I find myself agreeing with the idea that ad hoc enums are to enums as<br>&gt; structs are to tuples. Based on that analogy, why should an ad hoc enum<br>&gt; *need* a name (autogenerated or otherwise) any more than a tuple needs a<br>&gt; name? Would those who dislike ad hoc enums argue that this also shouldn&#39;t<br>&gt; be allowed:<br>&gt;<br>&gt;     func foo(bar: (x: Int, y: Int)) {}<br>&gt;     let t: (x: Int, y: Int) = (x: 5, y: 5)<br>&gt;<br>&gt; If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax<br>&gt; might be), that should just *be* the type the same way that `(x: Int, y:<br>&gt; Int)` is a type without a name, and that type can be used in argument<br>&gt; lists, variables, or whatever. There shouldn&#39;t be any worry about<br>&gt; declarations across multiple functions colliding or being incompatible any<br>&gt; more than we would worry about two functions declaring arguments of type<br>&gt; `(x: Int, y: Int)` would collide or be incompatible.<br>&gt;<br>&gt; One side of ad hoc enums that I&#39;d like to see explored is that, by being<br>&gt; unnamed, they&#39;re basically anonymous finite sets and we could apply<br>&gt; well-defined subset relationships to them: in other words, we could<br>&gt; consider allowing this:<br>&gt;<br>&gt;     func foo(bar: (.fit | .fill)) {<br>&gt;       baz(bar: bar)<br>&gt;     }<br>&gt;     func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;<br>&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt; expected if T ⊆ U.<br>&gt;<br>&gt;<br>&gt; On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt;     &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; Yes, I also can support the idea of autogenerated type name (like<br>&gt;     Enum_fit_OR_fill) as long as it allows to do all the things we are<br>&gt;     discussing here: declare (.fit|.fill) in function, use .fit on calling<br>&gt;     side, use (.fit|.fill) to declare temporary variable of type compatible<br>&gt;     with such function parameter etc.<br>&gt;     &gt;<br>&gt;<br>&gt;     It all works because the compiler is just being a thoughless scribe<br>&gt;     that just writes the standard enum we don&#39;t bother to write ourselves.<br>&gt;     Because the heuristic is simple and straightforward then it is<br>&gt;     predictible. The enum can be used with its long name be ause it is a<br>&gt;     real enum. And writing the short form of it also works because the<br>&gt;     compiler knowns uniquely what the long name is everytime it runs into<br>&gt;     the short name.<br>&gt;<br>&gt;<br>&gt;     &gt; But how do you suggest to define a type of such function in<br>&gt;     `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt;     &gt;<br>&gt;     &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt;     &gt; or as<br>&gt;     &gt;<br>&gt;     &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt;     &gt;<br>&gt;<br>&gt;     Ideally there is no difference whatsoever, there is a single enum, it<br>&gt;     is produced at the module level, and it has the long form name.<br>&gt;<br>&gt;     There can be rules that would prevent us from doing that with<br>&gt;     externally visible APIs, if the core team fuges that we should take the<br>&gt;     time to write our enums manually and cleanly to make them visible to<br>&gt;     the world, but it is not a necessary rule.<br>&gt;<br>&gt;<br>&gt;     &gt;<br>&gt;     &gt; But I still can&#39;t support the idea of limiting the usage of such<br>&gt;     enums - i.e. &quot;To deal with milti site definition, the compiler would<br>&gt;     simply flag a error/warning, or be silent in the presence of a new<br>&gt;     annotation:&quot;. I really think we need then introduce the same rule for<br>&gt;     tuples - so no one can use the same tuple declaration in function -<br>&gt;     they then should declare separate struct type or use @something for<br>&gt;     such functions. Nobody wants such rule for tuples.<br>&gt;     &gt;<br>&gt;<br>&gt;     Multi site thing is not a limitation... Is is a proposed rule to say<br>&gt;     that we are able to be lazy twice without being penalized. Yhe compiler<br>&gt;     does not like when we define the same thing twice, and thse short form<br>&gt;     amount to doing what he does not let us do. But because this is about<br>&gt;     concise and lazy, then the compiler can let us get away with it if we<br>&gt;     use an annotation that lets it know that &quot;it is not a mistake.. I<br>&gt;     really dont want to write that enum myself, even though I am using the<br>&gt;     same abbreviation twice&quot;. Otherwise, the compiler would let us know<br>&gt;     that the second time could be a mistake because there is already<br>&gt;     something with the same name...<br>&gt;<br>&gt;     But again this is a separate idea from the core notion of a syntax<br>&gt;     sugaring for writing real enums the lazy (clever) way<br>&gt;<br>&gt;     &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;     &gt;&gt; The only problem with this proposal is to consider them ad-hoc<br>&gt;     enums... If we view them as having nothing ad-hoc about them and the<br>&gt;     thing to be a simple sugaring exercise, then I think all the opositions<br>&gt;     on grounds of breaking the language disapear. It still does not mean it<br>&gt;     should be done if the core team does not like the idea of encouraging<br>&gt;     laziness, or simply do not like what it makes them look like. No matter<br>&gt;     what, this type of sugaring exercise has been clearly stated as out of<br>&gt;     scope for 3.0<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;     &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;     &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;     &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;     &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;     &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;     &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;     &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;     &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to<br>&gt;     have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e.<br>&gt;     textual representation if the declared type. As I understand this also<br>&gt;     could not be a solution.. I.e. for example<br>&gt;     `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; From other point of view, adding such type to typesystem will add<br>&gt;     some consistence : you can create a function that don&#39;t need definition<br>&gt;     of separate structure type(tuple will be used) and don&#39;t need separate<br>&gt;     enum type(ad-hoc enum will be used). I.e. all data the function needs<br>&gt;     to process could be described in function definition. Today we need to<br>&gt;     use ugly Bool flags in case we want to achieve the same target.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;     &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;     &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;     &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;     &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by<br>&gt;     name?<br>&gt;     &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they<br>&gt;     have<br>&gt;     &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;     &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An<br>&gt;     &quot;ArtistAction.Draw&quot; and<br>&gt;     &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;     &gt;&gt;&gt;&gt; different things.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just<br>&gt;     like tuples if you defined adhoc enum with exactly the same cases as<br>&gt;     ad-hoc enum in function parameters - then they are of the same type.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; I.e. :<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;     &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; but<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;     &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;     &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a<br>&gt;     one-line<br>&gt;     &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;     &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;     &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;     &gt;&gt;&gt;&gt; matching across several values at once, but structs are better<br>&gt;     used for<br>&gt;     &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;     &gt;&gt;&gt;&gt; don&#39;t.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as<br>&gt;     for tuples vs struct declaration. Yes can use it with care and you can<br>&gt;     use it in wrong way.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Best, Austin<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com<br>&gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;     &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;     &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;     &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;     &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;     &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;     &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;<br>&gt;     &lt;mailto:charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;  <br></p><p>[The entire original message is not included.]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/e3f72d23/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  1, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, Jun 1, 2016 at 3:02 PM Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt;  &gt; in other words, we could consider allowing this:<br>&gt;  &gt;    func foo(bar: (.fit | .fill)) {<br>&gt;  &gt;      baz(bar: bar)<br>&gt;  &gt;    }<br>&gt;  &gt;    func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;  &gt;<br>&gt;  &gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U<br>&gt; is<br>&gt;  &gt; expected if T ⊆ U.<br>&gt;<br>&gt; Can&#39;t agree with this. Just because the same analogue with tuples :<br>&gt; differently defined tuples are different types. Tuples with different order<br>&gt; of types in declaration - are different types. So I expect here instance of<br>&gt; (.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br>&gt;<br></p><p>I would argue that the analogy to tuples doesn&#39;t apply in this case. For<br>tuples, order of the arguments matters, and part of the structural<br>definition of a tuple is the number of its elements. Neither of those<br>applies for an ad hoc enum—it is defined solely as a set of named cases.<br></p><p>After writing that, however, that *does* seem like the kind of implicit<br>conversion that Swift tends to avoid. So maybe an explicit conversion would<br>better fit the language design.<br></p><p><br>&gt;<br>&gt; But +1 to be able to &#39;convert&#39; instance of (.fit | .fill) to instance of<br>&gt; (.fit | .fill | .florp). For example(if we&#39;ll have init(caseName) and<br>&gt; .caseName for enums):<br>&gt;<br>&gt; func foo(bar: (.fit | .fill)) {<br>&gt;      let bazbar = (.fit | .fill | .florp).init(caseName: bar.caseName)<br>&gt;      baz(bar: bazbar)<br>&gt; }<br>&gt; func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;<br></p><p>I&#39;m not crazy about this because I would expect a conversion that requires<br>a round-trip transformation of the string case name to be negative for<br>performance. Why not just:<br></p><p>    let bazbar = (.fit | .fill | .florp)(bar)<br></p><p>which the compiler ought to be able to optimize much better?<br></p><p><br>&gt;<br>&gt;<br>&gt; On 02.06.2016 0:38, Tony Allevato wrote:<br>&gt; &gt; I find myself agreeing with the idea that ad hoc enums are to enums as<br>&gt; &gt; structs are to tuples. Based on that analogy, why should an ad hoc enum<br>&gt; &gt; *need* a name (autogenerated or otherwise) any more than a tuple needs a<br>&gt; &gt; name? Would those who dislike ad hoc enums argue that this also shouldn&#39;t<br>&gt; &gt; be allowed:<br>&gt; &gt;<br>&gt; &gt;     func foo(bar: (x: Int, y: Int)) {}<br>&gt; &gt;     let t: (x: Int, y: Int) = (x: 5, y: 5)<br>&gt; &gt;<br>&gt; &gt; If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax<br>&gt; &gt; might be), that should just *be* the type the same way that `(x: Int, y:<br>&gt; &gt; Int)` is a type without a name, and that type can be used in argument<br>&gt; &gt; lists, variables, or whatever. There shouldn&#39;t be any worry about<br>&gt; &gt; declarations across multiple functions colliding or being incompatible<br>&gt; any<br>&gt; &gt; more than we would worry about two functions declaring arguments of type<br>&gt; &gt; `(x: Int, y: Int)` would collide or be incompatible.<br>&gt; &gt;<br>&gt; &gt; One side of ad hoc enums that I&#39;d like to see explored is that, by being<br>&gt; &gt; unnamed, they&#39;re basically anonymous finite sets and we could apply<br>&gt; &gt; well-defined subset relationships to them: in other words, we could<br>&gt; &gt; consider allowing this:<br>&gt; &gt;<br>&gt; &gt;     func foo(bar: (.fit | .fill)) {<br>&gt; &gt;       baz(bar: bar)<br>&gt; &gt;     }<br>&gt; &gt;     func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt; &gt;<br>&gt; &gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt; &gt; expected if T ⊆ U.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;     &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt; &gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; Yes, I also can support the idea of autogenerated type name (like<br>&gt; &gt;     Enum_fit_OR_fill) as long as it allows to do all the things we are<br>&gt; &gt;     discussing here: declare (.fit|.fill) in function, use .fit on<br>&gt; calling<br>&gt; &gt;     side, use (.fit|.fill) to declare temporary variable of type<br>&gt; compatible<br>&gt; &gt;     with such function parameter etc.<br>&gt; &gt;     &gt;<br>&gt; &gt;<br>&gt; &gt;     It all works because the compiler is just being a thoughless scribe<br>&gt; &gt;     that just writes the standard enum we don&#39;t bother to write<br>&gt; ourselves.<br>&gt; &gt;     Because the heuristic is simple and straightforward then it is<br>&gt; &gt;     predictible. The enum can be used with its long name be ause it is a<br>&gt; &gt;     real enum. And writing the short form of it also works because the<br>&gt; &gt;     compiler knowns uniquely what the long name is everytime it runs into<br>&gt; &gt;     the short name.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;     &gt; But how do you suggest to define a type of such function in<br>&gt; &gt;     `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt; &gt;     &gt; or as<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt; &gt;     &gt;<br>&gt; &gt;<br>&gt; &gt;     Ideally there is no difference whatsoever, there is a single enum, it<br>&gt; &gt;     is produced at the module level, and it has the long form name.<br>&gt; &gt;<br>&gt; &gt;     There can be rules that would prevent us from doing that with<br>&gt; &gt;     externally visible APIs, if the core team fuges that we should take<br>&gt; the<br>&gt; &gt;     time to write our enums manually and cleanly to make them visible to<br>&gt; &gt;     the world, but it is not a necessary rule.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; But I still can&#39;t support the idea of limiting the usage of such<br>&gt; &gt;     enums - i.e. &quot;To deal with milti site definition, the compiler would<br>&gt; &gt;     simply flag a error/warning, or be silent in the presence of a new<br>&gt; &gt;     annotation:&quot;. I really think we need then introduce the same rule for<br>&gt; &gt;     tuples - so no one can use the same tuple declaration in function -<br>&gt; &gt;     they then should declare separate struct type or use @something for<br>&gt; &gt;     such functions. Nobody wants such rule for tuples.<br>&gt; &gt;     &gt;<br>&gt; &gt;<br>&gt; &gt;     Multi site thing is not a limitation... Is is a proposed rule to say<br>&gt; &gt;     that we are able to be lazy twice without being penalized. Yhe<br>&gt; compiler<br>&gt; &gt;     does not like when we define the same thing twice, and thse short<br>&gt; form<br>&gt; &gt;     amount to doing what he does not let us do. But because this is about<br>&gt; &gt;     concise and lazy, then the compiler can let us get away with it if we<br>&gt; &gt;     use an annotation that lets it know that &quot;it is not a mistake.. I<br>&gt; &gt;     really dont want to write that enum myself, even though I am using<br>&gt; the<br>&gt; &gt;     same abbreviation twice&quot;. Otherwise, the compiler would let us know<br>&gt; &gt;     that the second time could be a mistake because there is already<br>&gt; &gt;     something with the same name...<br>&gt; &gt;<br>&gt; &gt;     But again this is a separate idea from the core notion of a syntax<br>&gt; &gt;     sugaring for writing real enums the lazy (clever) way<br>&gt; &gt;<br>&gt; &gt;     &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt; &gt;     &gt;&gt; The only problem with this proposal is to consider them ad-hoc<br>&gt; &gt;     enums... If we view them as having nothing ad-hoc about them and the<br>&gt; &gt;     thing to be a simple sugaring exercise, then I think all the<br>&gt; opositions<br>&gt; &gt;     on grounds of breaking the language disapear. It still does not mean<br>&gt; it<br>&gt; &gt;     should be done if the core team does not like the idea of encouraging<br>&gt; &gt;     laziness, or simply do not like what it makes them look like. No<br>&gt; matter<br>&gt; &gt;     what, this type of sugaring exercise has been clearly stated as out<br>&gt; of<br>&gt; &gt;     scope for 3.0<br>&gt; &gt;     &gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution<br>&gt; &gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; wrote:<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt; &gt;     &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by<br>&gt; the fact<br>&gt; &gt;     &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists<br>&gt; nowhere in<br>&gt; &gt;     &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something<br>&gt; that<br>&gt; &gt;     &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt; &gt;     &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt; &gt;     &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc<br>&gt; type that<br>&gt; &gt;     &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt; &gt;     &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to<br>&gt; &gt;     have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e.<br>&gt; &gt;     textual representation if the declared type. As I understand this<br>&gt; also<br>&gt; &gt;     could not be a solution.. I.e. for example<br>&gt; &gt;     `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; From other point of view, adding such type to typesystem will add<br>&gt; &gt;     some consistence : you can create a function that don&#39;t need<br>&gt; definition<br>&gt; &gt;     of separate structure type(tuple will be used) and don&#39;t need<br>&gt; separate<br>&gt; &gt;     enum type(ad-hoc enum will be used). I.e. all data the function needs<br>&gt; &gt;     to process could be described in function definition. Today we need<br>&gt; to<br>&gt; &gt;     use ugly Bool flags in case we want to achieve the same target.<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name<br>&gt; (like how<br>&gt; &gt;     &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type<br>&gt; it is<br>&gt; &gt;     &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing<br>&gt; structural<br>&gt; &gt;     &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work.<br>&gt; Why would<br>&gt; &gt;     &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable<br>&gt; by<br>&gt; &gt;     name?<br>&gt; &gt;     &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if<br>&gt; they<br>&gt; &gt;     have<br>&gt; &gt;     &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt; &gt;     &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An<br>&gt; &gt;     &quot;ArtistAction.Draw&quot; and<br>&gt; &gt;     &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean<br>&gt; completely<br>&gt; &gt;     &gt;&gt;&gt;&gt; different things.<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just<br>&gt; &gt;     like tuples if you defined adhoc enum with exactly the same cases as<br>&gt; &gt;     ad-hoc enum in function parameters - then they are of the same type.<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; I.e. :<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt; &gt;     &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; but<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt; &gt;     &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum<br>&gt; in<br>&gt; &gt;     &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a<br>&gt; &gt;     one-line<br>&gt; &gt;     &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this:<br>&gt; best<br>&gt; &gt;     &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc<br>&gt; destructuring,<br>&gt; &gt;     &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or<br>&gt; pattern<br>&gt; &gt;     &gt;&gt;&gt;&gt; matching across several values at once, but structs are better<br>&gt; &gt;     used for<br>&gt; &gt;     &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that<br>&gt; tuples<br>&gt; &gt;     &gt;&gt;&gt;&gt; don&#39;t.<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration<br>&gt; as<br>&gt; &gt;     for tuples vs struct declaration. Yes can use it with care and you<br>&gt; can<br>&gt; &gt;     use it in wrong way.<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt; &gt;     &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt; Best, Austin<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com<br>&gt; &gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types<br>&gt; of<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable<br>&gt; values<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks<br>&gt; it&#39;s<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum<br>&gt; flags,<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those<br>&gt; functions<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line<br>&gt; `struct<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum<br>&gt; or<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use<br>&gt; the same<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct<br>&gt; type.<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short:<br>&gt; I think<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable<br>&gt; `let e:<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;<br>&gt; &gt;     &lt;mailto:charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt;&gt;<br>&gt; wrote:<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general<br>&gt; enough<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the<br>&gt; same<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate<br>&gt; enums,<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via<br>&gt; swift-evolution<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;<br>&gt; &gt;     &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the<br>&gt; readability<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless<br>&gt; you<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks<br>&gt; the<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to<br>&gt; use one<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing<br>&gt; to<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a<br>&gt; full-fledged<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries<br>&gt; to<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library<br>&gt; versions? Do<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens<br>&gt; when<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At<br>&gt; least<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt; &gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these<br>&gt; babies<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for<br>&gt; UInt8,<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not<br>&gt; Swift.<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; swift-evolution<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt; &gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; swift-evolution<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt; &gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt; &gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; swift-evolution<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt; &gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt;&gt;<br>&gt; &gt;     &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;     &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;     &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;     &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;&gt;<br>&gt; &gt;     _______________________________________________<br>&gt; &gt;     swift-evolution mailing list<br>&gt; &gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/31d15cba/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>June  1, 2016 at 03:00:00pm</p></header><div class="content"><p>A single member version of this could be useful, too. Has anyone else here<br>ever found themself trying to think of an argument label for an init<br>method, just to ensure it has a unique signature? This would be handy:<br></p><p>*    extension Foo {*<br>*        convenience init( _ kind:(.DiskBased) ){*<br>*            // *<br>*        }*<br>*    }*<br></p><p><br>*    let diskFoo = Foo( .DiskBased )*<br></p><p>The thread does have some convincing arguments against it. It&#39;s not very<br>attractive if you think of it as a standard type like the existing enum. I<br>guess I think of it more as a preprocessor type of thing, as a replacement<br>for a function name or placeholder.<br></p><p><br></p><p>On Wed, Jun 1, 2016 at 3:02 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; in other words, we could consider allowing this:<br>&gt; &gt;    func foo(bar: (.fit | .fill)) {<br>&gt; &gt;      baz(bar: bar)<br>&gt; &gt;    }<br>&gt; &gt;    func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt; &gt;<br>&gt; &gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt; &gt; expected if T ⊆ U.<br>&gt;<br>&gt; Can&#39;t agree with this. Just because the same analogue with tuples :<br>&gt; differently defined tuples are different types. Tuples with different order<br>&gt; of types in declaration - are different types. So I expect here instance of<br>&gt; (.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br>&gt;<br>&gt; But +1 to be able to &#39;convert&#39; instance of (.fit | .fill) to instance of<br>&gt; (.fit | .fill | .florp). For example(if we&#39;ll have init(caseName) and<br>&gt; .caseName for enums):<br>&gt;<br>&gt; func foo(bar: (.fit | .fill)) {<br>&gt;     let bazbar = (.fit | .fill | .florp).init(caseName: bar.caseName)<br>&gt;     baz(bar: bazbar)<br>&gt; }<br>&gt; func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 02.06.2016 0:38, Tony Allevato wrote:<br>&gt;<br>&gt;&gt; I find myself agreeing with the idea that ad hoc enums are to enums as<br>&gt;&gt; structs are to tuples. Based on that analogy, why should an ad hoc enum<br>&gt;&gt; *need* a name (autogenerated or otherwise) any more than a tuple needs a<br>&gt;&gt; name? Would those who dislike ad hoc enums argue that this also shouldn&#39;t<br>&gt;&gt; be allowed:<br>&gt;&gt;<br>&gt;&gt;     func foo(bar: (x: Int, y: Int)) {}<br>&gt;&gt;     let t: (x: Int, y: Int) = (x: 5, y: 5)<br>&gt;&gt;<br>&gt;&gt; If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax<br>&gt;&gt; might be), that should just *be* the type the same way that `(x: Int, y:<br>&gt;&gt; Int)` is a type without a name, and that type can be used in argument<br>&gt;&gt; lists, variables, or whatever. There shouldn&#39;t be any worry about<br>&gt;&gt; declarations across multiple functions colliding or being incompatible any<br>&gt;&gt; more than we would worry about two functions declaring arguments of type<br>&gt;&gt; `(x: Int, y: Int)` would collide or be incompatible.<br>&gt;&gt;<br>&gt;&gt; One side of ad hoc enums that I&#39;d like to see explored is that, by being<br>&gt;&gt; unnamed, they&#39;re basically anonymous finite sets and we could apply<br>&gt;&gt; well-defined subset relationships to them: in other words, we could<br>&gt;&gt; consider allowing this:<br>&gt;&gt;<br>&gt;&gt;     func foo(bar: (.fit | .fill)) {<br>&gt;&gt;       baz(bar: bar)<br>&gt;&gt;     }<br>&gt;&gt;     func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;&gt;<br>&gt;&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt;&gt; expected if T ⊆ U.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Yes, I also can support the idea of autogenerated type name (like<br>&gt;&gt;     Enum_fit_OR_fill) as long as it allows to do all the things we are<br>&gt;&gt;     discussing here: declare (.fit|.fill) in function, use .fit on calling<br>&gt;&gt;     side, use (.fit|.fill) to declare temporary variable of type<br>&gt;&gt; compatible<br>&gt;&gt;     with such function parameter etc.<br>&gt;&gt;     &gt;<br>&gt;&gt;<br>&gt;&gt;     It all works because the compiler is just being a thoughless scribe<br>&gt;&gt;     that just writes the standard enum we don&#39;t bother to write ourselves.<br>&gt;&gt;     Because the heuristic is simple and straightforward then it is<br>&gt;&gt;     predictible. The enum can be used with its long name be ause it is a<br>&gt;&gt;     real enum. And writing the short form of it also works because the<br>&gt;&gt;     compiler knowns uniquely what the long name is everytime it runs into<br>&gt;&gt;     the short name.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &gt; But how do you suggest to define a type of such function in<br>&gt;&gt;     `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt;&gt;     &gt; or as<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt;&gt;     &gt;<br>&gt;&gt;<br>&gt;&gt;     Ideally there is no difference whatsoever, there is a single enum, it<br>&gt;&gt;     is produced at the module level, and it has the long form name.<br>&gt;&gt;<br>&gt;&gt;     There can be rules that would prevent us from doing that with<br>&gt;&gt;     externally visible APIs, if the core team fuges that we should take<br>&gt;&gt; the<br>&gt;&gt;     time to write our enums manually and cleanly to make them visible to<br>&gt;&gt;     the world, but it is not a necessary rule.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; But I still can&#39;t support the idea of limiting the usage of such<br>&gt;&gt;     enums - i.e. &quot;To deal with milti site definition, the compiler would<br>&gt;&gt;     simply flag a error/warning, or be silent in the presence of a new<br>&gt;&gt;     annotation:&quot;. I really think we need then introduce the same rule for<br>&gt;&gt;     tuples - so no one can use the same tuple declaration in function -<br>&gt;&gt;     they then should declare separate struct type or use @something for<br>&gt;&gt;     such functions. Nobody wants such rule for tuples.<br>&gt;&gt;     &gt;<br>&gt;&gt;<br>&gt;&gt;     Multi site thing is not a limitation... Is is a proposed rule to say<br>&gt;&gt;     that we are able to be lazy twice without being penalized. Yhe<br>&gt;&gt; compiler<br>&gt;&gt;     does not like when we define the same thing twice, and thse short form<br>&gt;&gt;     amount to doing what he does not let us do. But because this is about<br>&gt;&gt;     concise and lazy, then the compiler can let us get away with it if we<br>&gt;&gt;     use an annotation that lets it know that &quot;it is not a mistake.. I<br>&gt;&gt;     really dont want to write that enum myself, even though I am using the<br>&gt;&gt;     same abbreviation twice&quot;. Otherwise, the compiler would let us know<br>&gt;&gt;     that the second time could be a mistake because there is already<br>&gt;&gt;     something with the same name...<br>&gt;&gt;<br>&gt;&gt;     But again this is a separate idea from the core notion of a syntax<br>&gt;&gt;     sugaring for writing real enums the lazy (clever) way<br>&gt;&gt;<br>&gt;&gt;     &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;&gt;     &gt;&gt; The only problem with this proposal is to consider them ad-hoc<br>&gt;&gt;     enums... If we view them as having nothing ad-hoc about them and the<br>&gt;&gt;     thing to be a simple sugaring exercise, then I think all the<br>&gt;&gt; opositions<br>&gt;&gt;     on grounds of breaking the language disapear. It still does not mean<br>&gt;&gt; it<br>&gt;&gt;     should be done if the core team does not like the idea of encouraging<br>&gt;&gt;     laziness, or simply do not like what it makes them look like. No<br>&gt;&gt; matter<br>&gt;&gt;     what, this type of sugaring exercise has been clearly stated as out of<br>&gt;&gt;     scope for 3.0<br>&gt;&gt;     &gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution<br>&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the<br>&gt;&gt; fact<br>&gt;&gt;     &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists<br>&gt;&gt; nowhere in<br>&gt;&gt;     &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something<br>&gt;&gt; that<br>&gt;&gt;     &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt;     &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt;     &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc<br>&gt;&gt; type that<br>&gt;&gt;     &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;&gt;     &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to<br>&gt;&gt;     have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e.<br>&gt;&gt;     textual representation if the declared type. As I understand this also<br>&gt;&gt;     could not be a solution.. I.e. for example<br>&gt;&gt;     `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; From other point of view, adding such type to typesystem will add<br>&gt;&gt;     some consistence : you can create a function that don&#39;t need<br>&gt;&gt; definition<br>&gt;&gt;     of separate structure type(tuple will be used) and don&#39;t need separate<br>&gt;&gt;     enum type(ad-hoc enum will be used). I.e. all data the function needs<br>&gt;&gt;     to process could be described in function definition. Today we need to<br>&gt;&gt;     use ugly Bool flags in case we want to achieve the same target.<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name<br>&gt;&gt; (like how<br>&gt;&gt;     &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type<br>&gt;&gt; it is<br>&gt;&gt;     &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing<br>&gt;&gt; structural<br>&gt;&gt;     &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why<br>&gt;&gt; would<br>&gt;&gt;     &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by<br>&gt;&gt;     name?<br>&gt;&gt;     &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if<br>&gt;&gt; they<br>&gt;&gt;     have<br>&gt;&gt;     &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt;     &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An<br>&gt;&gt;     &quot;ArtistAction.Draw&quot; and<br>&gt;&gt;     &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean<br>&gt;&gt; completely<br>&gt;&gt;     &gt;&gt;&gt;&gt; different things.<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just<br>&gt;&gt;     like tuples if you defined adhoc enum with exactly the same cases as<br>&gt;&gt;     ad-hoc enum in function parameters - then they are of the same type.<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; I.e. :<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;&gt;     &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; but<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;&gt;     &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum<br>&gt;&gt; in<br>&gt;&gt;     &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a<br>&gt;&gt;     one-line<br>&gt;&gt;     &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this:<br>&gt;&gt; best<br>&gt;&gt;     &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc<br>&gt;&gt; destructuring,<br>&gt;&gt;     &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or<br>&gt;&gt; pattern<br>&gt;&gt;     &gt;&gt;&gt;&gt; matching across several values at once, but structs are better<br>&gt;&gt;     used for<br>&gt;&gt;     &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that<br>&gt;&gt; tuples<br>&gt;&gt;     &gt;&gt;&gt;&gt; don&#39;t.<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration<br>&gt;&gt; as<br>&gt;&gt;     for tuples vs struct declaration. Yes can use it with care and you can<br>&gt;&gt;     use it in wrong way.<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;&gt;     &gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;     &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types<br>&gt;&gt; of<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable<br>&gt;&gt; values<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks<br>&gt;&gt; it&#39;s<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum<br>&gt;&gt; flags,<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those<br>&gt;&gt; functions<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line<br>&gt;&gt; `struct<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the<br>&gt;&gt; same<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I<br>&gt;&gt; think<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable<br>&gt;&gt; `let e:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;<br>&gt;&gt;     &lt;mailto:charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the<br>&gt;&gt; same<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate<br>&gt;&gt; enums,<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via<br>&gt;&gt; swift-evolution<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the<br>&gt;&gt; readability<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless<br>&gt;&gt; you<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks<br>&gt;&gt; the<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use<br>&gt;&gt; one<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing<br>&gt;&gt; to<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a<br>&gt;&gt; full-fledged<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries<br>&gt;&gt; to<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions?<br>&gt;&gt; Do<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens<br>&gt;&gt; when<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At<br>&gt;&gt; least<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these<br>&gt;&gt; babies<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for<br>&gt;&gt; UInt8,<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;     &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt;&gt;<br>&gt;&gt;     &gt;&gt;&gt; _______________________________________________<br>&gt;&gt;     &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;     &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/cafe413f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 1, 2016, at 5:02 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; in other words, we could consider allowing this:<br>&gt; &gt;    func foo(bar: (.fit | .fill)) {<br>&gt; &gt;      baz(bar: bar)<br>&gt; &gt;    }<br>&gt; &gt;    func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt; &gt;<br>&gt; &gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt; &gt; expected if T ⊆ U.<br>&gt; <br>&gt; Can&#39;t agree with this. Just because the same analogue with tuples : differently defined tuples are different types. Tuples with different order of types in declaration - are different types. So I expect here instance of (.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br></p><p>They are not the same type but there is a structural subtype relationship between them.  All values of type (.fit | .fill) are also values of type (.fit | .fill | .florp).<br></p><p>&gt; <br>&gt; But +1 to be able to &#39;convert&#39; instance of (.fit | .fill) to instance of (.fit | .fill | .florp). For example(if we&#39;ll have init(caseName) and .caseName for enums):<br>&gt; <br>&gt; func foo(bar: (.fit | .fill)) {<br>&gt;    let bazbar = (.fit | .fill | .florp).init(caseName: bar.caseName)<br>&gt;    baz(bar: bazbar)<br>&gt; }<br>&gt; func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 02.06.2016 0:38, Tony Allevato wrote:<br>&gt;&gt; I find myself agreeing with the idea that ad hoc enums are to enums as<br>&gt;&gt; structs are to tuples. Based on that analogy, why should an ad hoc enum<br>&gt;&gt; *need* a name (autogenerated or otherwise) any more than a tuple needs a<br>&gt;&gt; name? Would those who dislike ad hoc enums argue that this also shouldn&#39;t<br>&gt;&gt; be allowed:<br>&gt;&gt; <br>&gt;&gt;    func foo(bar: (x: Int, y: Int)) {}<br>&gt;&gt;    let t: (x: Int, y: Int) = (x: 5, y: 5)<br>&gt;&gt; <br>&gt;&gt; If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax<br>&gt;&gt; might be), that should just *be* the type the same way that `(x: Int, y:<br>&gt;&gt; Int)` is a type without a name, and that type can be used in argument<br>&gt;&gt; lists, variables, or whatever. There shouldn&#39;t be any worry about<br>&gt;&gt; declarations across multiple functions colliding or being incompatible any<br>&gt;&gt; more than we would worry about two functions declaring arguments of type<br>&gt;&gt; `(x: Int, y: Int)` would collide or be incompatible.<br>&gt;&gt; <br>&gt;&gt; One side of ad hoc enums that I&#39;d like to see explored is that, by being<br>&gt;&gt; unnamed, they&#39;re basically anonymous finite sets and we could apply<br>&gt;&gt; well-defined subset relationships to them: in other words, we could<br>&gt;&gt; consider allowing this:<br>&gt;&gt; <br>&gt;&gt;    func foo(bar: (.fit | .fill)) {<br>&gt;&gt;      baz(bar: bar)<br>&gt;&gt;    }<br>&gt;&gt;    func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;&gt; <br>&gt;&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt;&gt; expected if T ⊆ U.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;    &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;    &gt;<br>&gt;&gt;    &gt; Yes, I also can support the idea of autogenerated type name (like<br>&gt;&gt;    Enum_fit_OR_fill) as long as it allows to do all the things we are<br>&gt;&gt;    discussing here: declare (.fit|.fill) in function, use .fit on calling<br>&gt;&gt;    side, use (.fit|.fill) to declare temporary variable of type compatible<br>&gt;&gt;    with such function parameter etc.<br>&gt;&gt;    &gt;<br>&gt;&gt; <br>&gt;&gt;    It all works because the compiler is just being a thoughless scribe<br>&gt;&gt;    that just writes the standard enum we don&#39;t bother to write ourselves.<br>&gt;&gt;    Because the heuristic is simple and straightforward then it is<br>&gt;&gt;    predictible. The enum can be used with its long name be ause it is a<br>&gt;&gt;    real enum. And writing the short form of it also works because the<br>&gt;&gt;    compiler knowns uniquely what the long name is everytime it runs into<br>&gt;&gt;    the short name.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &gt; But how do you suggest to define a type of such function in<br>&gt;&gt;    `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt;&gt;    &gt;<br>&gt;&gt;    &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt;&gt;    &gt; or as<br>&gt;&gt;    &gt;<br>&gt;&gt;    &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt;&gt;    &gt;<br>&gt;&gt; <br>&gt;&gt;    Ideally there is no difference whatsoever, there is a single enum, it<br>&gt;&gt;    is produced at the module level, and it has the long form name.<br>&gt;&gt; <br>&gt;&gt;    There can be rules that would prevent us from doing that with<br>&gt;&gt;    externally visible APIs, if the core team fuges that we should take the<br>&gt;&gt;    time to write our enums manually and cleanly to make them visible to<br>&gt;&gt;    the world, but it is not a necessary rule.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;    &gt;<br>&gt;&gt;    &gt; But I still can&#39;t support the idea of limiting the usage of such<br>&gt;&gt;    enums - i.e. &quot;To deal with milti site definition, the compiler would<br>&gt;&gt;    simply flag a error/warning, or be silent in the presence of a new<br>&gt;&gt;    annotation:&quot;. I really think we need then introduce the same rule for<br>&gt;&gt;    tuples - so no one can use the same tuple declaration in function -<br>&gt;&gt;    they then should declare separate struct type or use @something for<br>&gt;&gt;    such functions. Nobody wants such rule for tuples.<br>&gt;&gt;    &gt;<br>&gt;&gt; <br>&gt;&gt;    Multi site thing is not a limitation... Is is a proposed rule to say<br>&gt;&gt;    that we are able to be lazy twice without being penalized. Yhe compiler<br>&gt;&gt;    does not like when we define the same thing twice, and thse short form<br>&gt;&gt;    amount to doing what he does not let us do. But because this is about<br>&gt;&gt;    concise and lazy, then the compiler can let us get away with it if we<br>&gt;&gt;    use an annotation that lets it know that &quot;it is not a mistake.. I<br>&gt;&gt;    really dont want to write that enum myself, even though I am using the<br>&gt;&gt;    same abbreviation twice&quot;. Otherwise, the compiler would let us know<br>&gt;&gt;    that the second time could be a mistake because there is already<br>&gt;&gt;    something with the same name...<br>&gt;&gt; <br>&gt;&gt;    But again this is a separate idea from the core notion of a syntax<br>&gt;&gt;    sugaring for writing real enums the lazy (clever) way<br>&gt;&gt; <br>&gt;&gt;    &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;&gt;    &gt;&gt; The only problem with this proposal is to consider them ad-hoc<br>&gt;&gt;    enums... If we view them as having nothing ad-hoc about them and the<br>&gt;&gt;    thing to be a simple sugaring exercise, then I think all the opositions<br>&gt;&gt;    on grounds of breaking the language disapear. It still does not mean it<br>&gt;&gt;    should be done if the core team does not like the idea of encouraging<br>&gt;&gt;    laziness, or simply do not like what it makes them look like. No matter<br>&gt;&gt;    what, this type of sugaring exercise has been clearly stated as out of<br>&gt;&gt;    scope for 3.0<br>&gt;&gt;    &gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt;    &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt;    &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt;    &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt;    &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt;    &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt;    &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;&gt;    &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;&gt;    &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to<br>&gt;&gt;    have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e.<br>&gt;&gt;    textual representation if the declared type. As I understand this also<br>&gt;&gt;    could not be a solution.. I.e. for example<br>&gt;&gt;    `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; From other point of view, adding such type to typesystem will add<br>&gt;&gt;    some consistence : you can create a function that don&#39;t need definition<br>&gt;&gt;    of separate structure type(tuple will be used) and don&#39;t need separate<br>&gt;&gt;    enum type(ad-hoc enum will be used). I.e. all data the function needs<br>&gt;&gt;    to process could be described in function definition. Today we need to<br>&gt;&gt;    use ugly Bool flags in case we want to achieve the same target.<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt;    &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt;    &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt;    &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt;    &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by<br>&gt;&gt;    name?<br>&gt;&gt;    &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they<br>&gt;&gt;    have<br>&gt;&gt;    &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt;    &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An<br>&gt;&gt;    &quot;ArtistAction.Draw&quot; and<br>&gt;&gt;    &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt;    &gt;&gt;&gt;&gt; different things.<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just<br>&gt;&gt;    like tuples if you defined adhoc enum with exactly the same cases as<br>&gt;&gt;    ad-hoc enum in function parameters - then they are of the same type.<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; I.e. :<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;&gt;    &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; but<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;&gt;    &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt;    &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a<br>&gt;&gt;    one-line<br>&gt;&gt;    &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt;    &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt;    &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt;    &gt;&gt;&gt;&gt; matching across several values at once, but structs are better<br>&gt;&gt;    used for<br>&gt;&gt;    &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt;    &gt;&gt;&gt;&gt; don&#39;t.<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as<br>&gt;&gt;    for tuples vs struct declaration. Yes can use it with care and you can<br>&gt;&gt;    use it in wrong way.<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;&gt;    &gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt;    &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;<br>&gt;&gt;    &lt;mailto:charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt;&gt; wrote:<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;    &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;    &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;    &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt;&gt;<br>&gt;&gt;    &gt;&gt;&gt; _______________________________________________<br>&gt;&gt;    &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;    &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;    &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;    &gt;&gt;<br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>June  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 5:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 5:02 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; in other words, we could consider allowing this:<br>&gt;&gt;&gt;   func foo(bar: (.fit | .fill)) {<br>&gt;&gt;&gt;     baz(bar: bar)<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt;&gt;&gt; expected if T ⊆ U.<br>&gt;&gt; <br>&gt;&gt; Can&#39;t agree with this. Just because the same analogue with tuples : differently defined tuples are different types. Tuples with different order of types in declaration - are different types. So I expect here instance of (.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br>&gt; <br>&gt; They are not the same type but there is a structural subtype relationship between them.  All values of type (.fit | .fill) are also values of type (.fit | .fill | .florp).<br></p><p>What about disjoint types? Some values of type (.fit | .fill) are values of type (.fit | .florp) and some are not. I&#39;m not a type system expert but my understanding is that this capability gets very complicated very fast.<br></p><p><br>What about the ABI? This sounds expensive to implement.<br></p><p>Consider this set of ad-hoc enum types:<br></p><p>  (.a | .b)<br>  (.c | .d)<br></p><p>Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br></p><p>The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br></p><p>  (.a | .b | .c | .d)<br></p><p>In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br></p><p>You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br></p><p>An implementation like ObjC&#39;s @selector or C/C++ weak definition would work, but those are expensive in memory overhead and launch time. <br></p><p>You could give each linkage unit its own copy of the value that includes a string of the value&#39;s name plus an == operator that compares the name strings; that would avoid uniquing but would make some operations slow. <br></p><p>In any case the performance of these things will not be comparable to ints nor to typical Swift enums that are encoded as ints.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/445b49d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  3, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 5:20 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; What about the ABI? This sounds expensive to implement.<br>&gt; <br>&gt; Consider this set of ad-hoc enum types:<br>&gt; <br>&gt;   (.a | .b)<br>&gt;   (.c | .d)<br>&gt; <br>&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt; <br>&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt; <br>&gt;   (.a | .b | .c | .d)<br>&gt; <br>&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt; <br>&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br></p><p>In my mind, the ad hoc enum must be tied to a specific function or method signature. In doing so, it has a unique module/selector associated with it, so it&#39;s not just .a but rather Foo.funcname.a (assuming no more than one ad hoc enum per function) or Foo.funcname.3.a (assuming its the third parameter of the selector). The conversation has drifted a bit from my request.<br></p><p>If the enum needs to be used in more situations, it needs to be a proper enum because the semantics are tied to a higher level of visibility.<br></p><p>I&#39;m striving for enhanced readability in intent (for example, where !x is a poor description of the option other than x, or even when there are &gt;2 options that will never be used elsewhere such as fill, fit, scale) and in expression (choosing self-annotating switch statements over if statements, where its clear what each branch intends to do).<br></p><p>These enums would be limited to basic hashValue types, and would appear in QuickHelp as annotations of legal values to supply to the argument. My intent is that there never be more than 3-5 enumeration cases used in this anonymous fashion.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  3, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 3, 2016, at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 5:20 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; What about the ABI? This sounds expensive to implement.<br>&gt;&gt; <br>&gt;&gt; Consider this set of ad-hoc enum types:<br>&gt;&gt; <br>&gt;&gt;  (.a | .b)<br>&gt;&gt;  (.c | .d)<br>&gt;&gt; <br>&gt;&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt;&gt; <br>&gt;&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt;&gt; <br>&gt;&gt;  (.a | .b | .c | .d)<br>&gt;&gt; <br>&gt;&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt;&gt; <br>&gt;&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br>&gt; <br>&gt; In my mind, the ad hoc enum must be tied to a specific function or method signature. In doing so, it has a unique module/selector associated with it, so it&#39;s not just .a but rather Foo.funcname.a (assuming no more than one ad hoc enum per function) or Foo.funcname.3.a (assuming its the third parameter of the selector). The conversation has drifted a bit from my request.<br>&gt; <br>&gt; If the enum needs to be used in more situations, it needs to be a proper enum because the semantics are tied to a higher level of visibility.<br>&gt; <br>&gt; I&#39;m striving for enhanced readability in intent (for example, where !x is a poor description of the option other than x, or even when there are &gt;2 options that will never be used elsewhere such as fill, fit, scale) and in expression (choosing self-annotating switch statements over if statements, where its clear what each branch intends to do).<br>&gt; <br>&gt; These enums would be limited to basic hashValue types, and would appear in QuickHelp as annotations of legal values to supply to the argument. My intent is that there never be more than 3-5 enumeration cases used in this anonymous fashion.<br></p><p>Are you still insisting that we not be able to declare a variable holding one of these to call the function with later?  If so, what is the justification for placing a burden on callers that the argument must always be a literal?  If not, how do you suggest a variable be declared?<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>June  4, 2016 at 07:00:00am</p></header><div class="content"><p>How about this:<br></p><p><br>Going back to Erica’s original example:<br></p><p>func scaleAndCropImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    operation: (.Fit | .Fill) = .Fit<br>    ) -&gt; UIImage {<br></p><p>And noting that we are already allowed to declare an enum inside the function, compiler can generate  an enum scoped inside the function named the label of the enum:<br></p><p>func scaleAndCropImage(<br>    image: UIImage,<br>    toSize size: CGSize,<br>    operation: (.Fit | .Fill) = .Fit<br>    ) -&gt; UIImage {<br>	@_exposed num operation {<br>	case Fit<br>	case Fill<br>    }<br></p><p>Then you could declare a var:<br></p><p>var myOperation: scaleAndCropImage.operation = .Fill<br></p><p>Then you can call:<br></p><p>let scaledImage = scaleAndCropImage(image: myImage, toSize: theSize, operation: myOperation)<br></p><p>@_exposed above would be a compiler private annotation for the auto generated enum that will make if visible outside of the function. This way the impact is minimal and such ad hoc enum would be just the same as any other enum. The only big change in the compiler would be the ability to make some declaration inside functions visible to the outside code.<br></p><p>&gt; On Jun 3, 2016, at 5:10 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 3, 2016, at 5:20 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; What about the ABI? This sounds expensive to implement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider this set of ad-hoc enum types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (.a | .b)<br>&gt;&gt;&gt; (.c | .d)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (.a | .b | .c | .d)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br>&gt;&gt; <br>&gt;&gt; In my mind, the ad hoc enum must be tied to a specific function or method signature. In doing so, it has a unique module/selector associated with it, so it&#39;s not just .a but rather Foo.funcname.a (assuming no more than one ad hoc enum per function) or Foo.funcname.3.a (assuming its the third parameter of the selector). The conversation has drifted a bit from my request.<br>&gt;&gt; <br>&gt;&gt; If the enum needs to be used in more situations, it needs to be a proper enum because the semantics are tied to a higher level of visibility.<br>&gt;&gt; <br>&gt;&gt; I&#39;m striving for enhanced readability in intent (for example, where !x is a poor description of the option other than x, or even when there are &gt;2 options that will never be used elsewhere such as fill, fit, scale) and in expression (choosing self-annotating switch statements over if statements, where its clear what each branch intends to do).<br>&gt;&gt; <br>&gt;&gt; These enums would be limited to basic hashValue types, and would appear in QuickHelp as annotations of legal values to supply to the argument. My intent is that there never be more than 3-5 enumeration cases used in this anonymous fashion.<br>&gt; <br>&gt; Are you still insisting that we not be able to declare a variable holding one of these to call the function with later?  If so, what is the justification for placing a burden on callers that the argument must always be a literal?  If not, how do you suggest a variable be declared?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/af82e536/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  4, 2016 at 05:00:00pm</p></header><div class="content"><p>Anyone thinking about complexity????<br></p><p>&gt; On Jun 4, 2016, at 4:58 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about this:<br>&gt; <br>&gt; <br>&gt; Going back to Erica’s original example:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; And noting that we are already allowed to declare an enum inside the function, compiler can generate  an enum scoped inside the function named the label of the enum:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; 	@_exposed num operation {<br>&gt; 	case Fit<br>&gt; 	case Fill<br>&gt;     }<br>&gt; <br>&gt; Then you could declare a var:<br>&gt; <br>&gt; var myOperation: scaleAndCropImage.operation = .Fill<br>&gt; <br>&gt; Then you can call:<br>&gt; <br>&gt; let scaledImage = scaleAndCropImage(image: myImage, toSize: theSize, operation: myOperation)<br>&gt; <br>&gt; @_exposed above would be a compiler private annotation for the auto generated enum that will make if visible outside of the function. This way the impact is minimal and such ad hoc enum would be just the same as any other enum. The only big change in the compiler would be the ability to make some declaration inside functions visible to the outside code.<br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 5:10 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 5:20 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; What about the ABI? This sounds expensive to implement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider this set of ad-hoc enum types:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (.a | .b)<br>&gt;&gt;&gt;&gt; (.c | .d)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (.a | .b | .c | .d)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my mind, the ad hoc enum must be tied to a specific function or method signature. In doing so, it has a unique module/selector associated with it, so it&#39;s not just .a but rather Foo.funcname.a (assuming no more than one ad hoc enum per function) or Foo.funcname.3.a (assuming its the third parameter of the selector). The conversation has drifted a bit from my request.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the enum needs to be used in more situations, it needs to be a proper enum because the semantics are tied to a higher level of visibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m striving for enhanced readability in intent (for example, where !x is a poor description of the option other than x, or even when there are &gt;2 options that will never be used elsewhere such as fill, fit, scale) and in expression (choosing self-annotating switch statements over if statements, where its clear what each branch intends to do).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These enums would be limited to basic hashValue types, and would appear in QuickHelp as annotations of legal values to supply to the argument. My intent is that there never be more than 3-5 enumeration cases used in this anonymous fashion.<br>&gt;&gt; <br>&gt;&gt; Are you still insisting that we not be able to declare a variable holding one of these to call the function with later?  If so, what is the justification for placing a burden on callers that the argument must always be a literal?  If not, how do you suggest a variable be declared?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/14585c29/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>June  4, 2016 at 08:00:00am</p></header><div class="content"><p>Good point. <br></p><p>This is one of my main concerns: Adding too much to the core language makes it harder to learn. <br></p><p>I think we should focus on eliminating special cases and exceptions in the language and only add simple foundational enabling features that can enable addressing other issues (boilerplate, namespace pollution, etc.) An example of such enabling feature would be property behaviors. It is a pity that it didn’t make it to Swift 3.0. <br></p><p>There are many accepted proposals that individually make sense, but when you add all of them together it leads to (in my opinion) more complexity in the core language than is really necessary. <br></p><p>I think what I proposed is a step in limiting the introduced complexity for fully covering the feature if we really have to have this feature. <br></p><p><br>&gt; On Jun 4, 2016, at 8:03 AM, LM &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Anyone thinking about complexity????<br>&gt; <br>&gt; On Jun 4, 2016, at 4:58 PM, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; How about this:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Going back to Erica’s original example:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; And noting that we are already allowed to declare an enum inside the function, compiler can generate  an enum scoped inside the function named the label of the enum:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; 	@_exposed num operation {<br>&gt;&gt; 	case Fit<br>&gt;&gt; 	case Fill<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Then you could declare a var:<br>&gt;&gt; <br>&gt;&gt; var myOperation: scaleAndCropImage.operation = .Fill<br>&gt;&gt; <br>&gt;&gt; Then you can call:<br>&gt;&gt; <br>&gt;&gt; let scaledImage = scaleAndCropImage(image: myImage, toSize: theSize, operation: myOperation)<br>&gt;&gt; <br>&gt;&gt; @_exposed above would be a compiler private annotation for the auto generated enum that will make if visible outside of the function. This way the impact is minimal and such ad hoc enum would be just the same as any other enum. The only big change in the compiler would be the ability to make some declaration inside functions visible to the outside code.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 3, 2016, at 5:10 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 3, 2016, at 5:20 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; What about the ABI? This sounds expensive to implement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Consider this set of ad-hoc enum types:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (.a | .b)<br>&gt;&gt;&gt;&gt;&gt; (.c | .d)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (.a | .b | .c | .d)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my mind, the ad hoc enum must be tied to a specific function or method signature. In doing so, it has a unique module/selector associated with it, so it&#39;s not just .a but rather Foo.funcname.a (assuming no more than one ad hoc enum per function) or Foo.funcname.3.a (assuming its the third parameter of the selector). The conversation has drifted a bit from my request.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the enum needs to be used in more situations, it needs to be a proper enum because the semantics are tied to a higher level of visibility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m striving for enhanced readability in intent (for example, where !x is a poor description of the option other than x, or even when there are &gt;2 options that will never be used elsewhere such as fill, fit, scale) and in expression (choosing self-annotating switch statements over if statements, where its clear what each branch intends to do).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These enums would be limited to basic hashValue types, and would appear in QuickHelp as annotations of legal values to supply to the argument. My intent is that there never be more than 3-5 enumeration cases used in this anonymous fashion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you still insisting that we not be able to declare a variable holding one of these to call the function with later?  If so, what is the justification for placing a burden on callers that the argument must always be a literal?  If not, how do you suggest a variable be declared?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/a5ce997e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  4, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 4, 2016, at 9:58 AM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt; <br>&gt; How about this:<br>&gt; <br>&gt; <br>&gt; Going back to Erica’s original example:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; And noting that we are already allowed to declare an enum inside the function, compiler can generate  an enum scoped inside the function named the label of the enum:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; 	@_exposed num operation {<br>&gt; 	case Fit<br>&gt; 	case Fill<br>&gt;     }<br>&gt; <br>&gt; Then you could declare a var:<br>&gt; <br>&gt; var myOperation: scaleAndCropImage.operation = .Fill<br>&gt; <br>&gt; Then you can call:<br>&gt; <br>&gt; let scaledImage = scaleAndCropImage(image: myImage, toSize: theSize, operation: myOperation)<br>&gt; <br>&gt; @_exposed above would be a compiler private annotation for the auto generated enum that will make if visible outside of the function. This way the impact is minimal and such ad hoc enum would be just the same as any other enum. The only big change in the compiler would be the ability to make some declaration inside functions visible to the outside code.<br>&gt; <br></p><p>The type name would be super verbose, but this does address the basic concerns I have with the original proposal and it is a lot simpler than structural subtyping.<br></p><p><br>&gt;&gt; On Jun 3, 2016, at 5:10 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 3, 2016, at 5:20 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; What about the ABI? This sounds expensive to implement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider this set of ad-hoc enum types:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (.a | .b)<br>&gt;&gt;&gt;&gt; (.c | .d)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (.a | .b | .c | .d)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my mind, the ad hoc enum must be tied to a specific function or method signature. In doing so, it has a unique module/selector associated with it, so it&#39;s not just .a but rather Foo.funcname.a (assuming no more than one ad hoc enum per function) or Foo.funcname.3.a (assuming its the third parameter of the selector). The conversation has drifted a bit from my request.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the enum needs to be used in more situations, it needs to be a proper enum because the semantics are tied to a higher level of visibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m striving for enhanced readability in intent (for example, where !x is a poor description of the option other than x, or even when there are &gt;2 options that will never be used elsewhere such as fill, fit, scale) and in expression (choosing self-annotating switch statements over if statements, where its clear what each branch intends to do).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These enums would be limited to basic hashValue types, and would appear in QuickHelp as annotations of legal values to supply to the argument. My intent is that there never be more than 3-5 enumeration cases used in this anonymous fashion.<br>&gt;&gt; <br>&gt;&gt; Are you still insisting that we not be able to declare a variable holding one of these to call the function with later?  If so, what is the justification for placing a burden on callers that the argument must always be a literal?  If not, how do you suggest a variable be declared?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/61e9026a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 4, 2016, at 8:58 AM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt; <br>&gt; How about this:<br>&gt; <br>&gt; <br>&gt; Going back to Erica’s original example:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; And noting that we are already allowed to declare an enum inside the function, compiler can generate  an enum scoped inside the function named the label of the enum:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; 	@_exposed num operation {<br>&gt; 	case Fit<br>&gt; 	case Fill<br>&gt;     }<br>&gt; <br>&gt; Then you could declare a var:<br>&gt; <br>&gt; var myOperation: scaleAndCropImage.operation = .Fill<br>&gt; <br>&gt; Then you can call:<br>&gt; <br>&gt; let scaledImage = scaleAndCropImage(image: myImage, toSize: theSize, operation: myOperation)<br>&gt; <br>&gt; @_exposed above would be a compiler private annotation for the auto generated enum that will make if visible outside of the function. This way the impact is minimal and such ad hoc enum would be just the same as any other enum. The only big change in the compiler would be the ability to make some declaration inside functions visible to the outside code.<br></p><p>This is my favorite approach (assuming it&#39;s technically feasible) as it preserves the limitation that the enumerations are scoped strictly to the function but can be referenced outside of it.<br></p><p>It allows type inference for dropped prefixes because the compiler can unambiguously match the ad hoc enumeration type to the parameter.<br>It introduces the possibility (for Matthew) of assigning a value to a variable.<br>It preserves the notion that an ad-hoc enum makes syntactic and semantic sense only with respect to its use in a function/method parameter list.<br></p><p>If an enumeration needs wider semantics, it should be a standalone type, whether as a nested or not.<br></p><p>Reiterating the reasons for this pitch:<br>It streamlines coding, eliminating standalone enumeration types that are used only once<br>It enables you to see all enumeration options at a glance, and can be reflected in the QuickHelp documentation<br>It encourages `switch` coding over `if-then-else` coding so each case is labeled and self documenting<br>It pushes semantics to the call-site in a way that simple Boolean flags cannot: `operation: .Fit` means more than `shouldFill: false`.<br>I&#39;d like to know at this point whether Hooman&#39;s approach is even technically feasible, although it&#39;s horrible timing the Tuesday before WWDC to get core team feedback on anything.<br></p><p>-- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/df6f7def/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 10:29 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 4, 2016, at 8:58 AM, Hooman Mehr &lt;hooman at mac.com &lt;mailto:hooman at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How about this:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Going back to Erica’s original example:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; And noting that we are already allowed to declare an enum inside the function, compiler can generate  an enum scoped inside the function named the label of the enum:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; 	@_exposed num operation {<br>&gt;&gt; 	case Fit<br>&gt;&gt; 	case Fill<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Then you could declare a var:<br>&gt;&gt; <br>&gt;&gt; var myOperation: scaleAndCropImage.operation = .Fill<br>&gt;&gt; <br>&gt;&gt; Then you can call:<br>&gt;&gt; <br>&gt;&gt; let scaledImage = scaleAndCropImage(image: myImage, toSize: theSize, operation: myOperation)<br>&gt;&gt; <br>&gt;&gt; @_exposed above would be a compiler private annotation for the auto generated enum that will make if visible outside of the function. This way the impact is minimal and such ad hoc enum would be just the same as any other enum. The only big change in the compiler would be the ability to make some declaration inside functions visible to the outside code.<br>&gt; <br>&gt; This is my favorite approach (assuming it&#39;s technically feasible) as it preserves the limitation that the enumerations are scoped strictly to the function but can be referenced outside of it.<br>&gt; <br>&gt; It allows type inference for dropped prefixes because the compiler can unambiguously match the ad hoc enumeration type to the parameter.<br>&gt; It introduces the possibility (for Matthew) of assigning a value to a variable.<br>&gt; It preserves the notion that an ad-hoc enum makes syntactic and semantic sense only with respect to its use in a function/method parameter list.<br>&gt; <br>&gt; If an enumeration needs wider semantics, it should be a standalone type, whether as a nested or not.<br>&gt; <br>&gt; Reiterating the reasons for this pitch:<br>&gt; It streamlines coding, eliminating standalone enumeration types that are used only once<br>&gt; It enables you to see all enumeration options at a glance, and can be reflected in the QuickHelp documentation<br>&gt; It encourages `switch` coding over `if-then-else` coding so each case is labeled and self documenting<br>&gt; It pushes semantics to the call-site in a way that simple Boolean flags cannot: `operation: .Fit` means more than `shouldFill: false`.<br>&gt; I&#39;d like to know at this point whether Hooman&#39;s approach is even technically feasible, although it&#39;s horrible timing the Tuesday before WWDC to get core team feedback on anything.<br>&gt; <br></p><p>There is currently a draft circulating for the removal of @noreturn. If memory serves, I think there was another annotation recently removed. There was also the recent change of dynamicType into something like type(of:).. all these changes have one thing in common: they are streamlining the language, chasing the magic out and replacing it with the careful application of a few simple principles. @_exposed would IMVHO be a setback: <br></p><p>it would introduce a new special annotation<br>the annotation would have very little chance of being anything but a one of, used for a single scenario<br></p><p>Scala went that way years ago, going left right and center, with all sort of great ideas. In the end, for the past few Scala Days Oderski has been going on stage explaining why a language with too many clever tricks is in nobody’s interest.<br></p><p>if and when they decide to focus on small syntactic sugaring enhancements (akin to javac&#39;s Project Coin), then they have an easy way to make it happen without any magic or special rules.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/50af2653/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  7, 2016 at 03:00:00pm</p></header><div class="content"><p>On Jun 7, 2016, at 2:49 PM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; This is my favorite approach (assuming it&#39;s technically feasible) as it preserves the limitation that the enumerations are scoped strictly to the function but can be referenced outside of it.<br>&gt;&gt; <br>&gt;&gt; It allows type inference for dropped prefixes because the compiler can unambiguously match the ad hoc enumeration type to the parameter.<br>&gt;&gt; It introduces the possibility (for Matthew) of assigning a value to a variable.<br>&gt;&gt; It preserves the notion that an ad-hoc enum makes syntactic and semantic sense only with respect to its use in a function/method parameter list.<br>&gt;&gt; <br>&gt;&gt; If an enumeration needs wider semantics, it should be a standalone type, whether as a nested or not.<br>&gt;&gt; <br>&gt;&gt; Reiterating the reasons for this pitch:<br>&gt;&gt; It streamlines coding, eliminating standalone enumeration types that are used only once<br>&gt;&gt; It enables you to see all enumeration options at a glance, and can be reflected in the QuickHelp documentation<br>&gt;&gt; It encourages `switch` coding over `if-then-else` coding so each case is labeled and self documenting<br>&gt;&gt; It pushes semantics to the call-site in a way that simple Boolean flags cannot: `operation: .Fit` means more than `shouldFill: false`.<br>&gt;&gt; I&#39;d like to know at this point whether Hooman&#39;s approach is even technically feasible, although it&#39;s horrible timing the Tuesday before WWDC to get core team feedback on anything.<br>&gt;&gt; <br>&gt; <br>&gt; There is currently a draft circulating for the removal of @noreturn. If memory serves, I think there was another annotation recently removed. There was also the recent change of dynamicType into something like type(of:).. all these changes have one thing in common: they are streamlining the language, chasing the magic out and replacing it with the careful application of a few simple principles. @_exposed would IMVHO be a setback: <br>&gt; <br>&gt; it would introduce a new special annotation<br>&gt; the annotation would have very little chance of being anything but a one of, used for a single scenario<br>&gt; <br>&gt; Scala went that way years ago, going left right and center, with all sort of great ideas. In the end, for the past few Scala Days Oderski has been going on stage explaining why a language with too many clever tricks is in nobody’s interest.<br>&gt; <br>&gt; if and when they decide to focus on small syntactic sugaring enhancements (akin to javac&#39;s Project Coin), then they have an easy way to make it happen without any magic or special rules.<br></p><p>What appeals to me is scoping the enumeration to the function: Semantic sugar that creates a global<br></p><p>function.parameterName.enum {case ... }<br></p><p>You had suggested using semantic sugar in a different way, did you not? <br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/07f6a764/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  8, 2016 at 09:00:00pm</p></header><div class="content"><p>Agree that &#39;@_exposed&#39; would be a step back and additional magic. Also, it <br>is obvious for me that ad-hoc enum should not require using only as literal <br>on call site - you can have no rights/other reasons to change such function <br>to extract adhoc to standalone enum to be able to use variable. Also, if we <br>can declare such ad-hoc enum as type of function parameter - we should be <br>able to declare such &#39;simplified&#39; enum type anywhere in our code.<br></p><p>I believe the main question with ad-hoc enum is how such enum will be <br>represented in type system. I.e. what will be a result of this:<br>typealias MyType = ((.one|.two)) -&gt; ()<br>print(MyType)<br></p><p>Will it be<br>`(adhocenum_7682736) -&gt; ()` or<br>`(adhocenum_one_two) -&gt; ()` or<br>`((.one|.two)) -&gt; ()` or other variant?<br></p><p>I believe the only right way to have such ad-hoc enums in Swift is <br>introduce new kind of type with full rights, so the above typealias will be <br>printed as `((.one|.two)) -&gt; ()`, so we can declare variable `var e : <br>(.fill|.fit) = .fill&#39; and have e.dynamicType == &quot;(.fill|.fit)&quot; etc.<br>But as I understand after the discussion, community don&#39;t want/need such <br>new type and that probably the idea if such new type kind is not really good.<br>So personally I don&#39;t expect any variant of ad-hoc enum will be accepted.<br></p><p><br>On 07.06.2016 23:49, L Mihalkovic via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Jun 7, 2016, at 10:29 PM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 4, 2016, at 8:58 AM, Hooman Mehr &lt;hooman at mac.com<br>&gt;&gt;&gt; &lt;mailto:hooman at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How about this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Going back to Erica’s original example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;&gt; 	image: UIImage,<br>&gt;&gt;&gt; 	toSize size: CGSize,<br>&gt;&gt;&gt; 	*operation: (.Fit | .Fill) = .Fit*<br>&gt;&gt;&gt; 	) -&gt; UIImage {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And noting that we are already allowed to declare an enum inside the<br>&gt;&gt;&gt; function, compiler can generate  an enum scoped inside the function<br>&gt;&gt;&gt; named the label of the enum:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;&gt; 	image: UIImage,<br>&gt;&gt;&gt; 	toSize size: CGSize,<br>&gt;&gt;&gt; 	*operation: (.Fit | .Fill) = .Fit*<br>&gt;&gt;&gt; 	) -&gt; UIImage {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @_exposed num *operation*{<br>&gt;&gt;&gt; case *Fit*<br>&gt;&gt;&gt; case *Fill*<br>&gt;&gt;&gt; *  *}<br>&gt;&gt;&gt; *<br>&gt;&gt;&gt; *<br>&gt;&gt;&gt; Then you could declare a var:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; varmyOperation: scaleAndCropImage.operation = .Fill<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Then you can call:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; letscaledImage = scaleAndCropImage(image: myImage, toSize: theSize,<br>&gt;&gt;&gt; operation: myOperation)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @_exposed above would be a compiler private annotation for the auto<br>&gt;&gt;&gt; generated enum that will make if visible outside of the function. This<br>&gt;&gt;&gt; way the impact is minimal and such ad hoc enum would be just the same as<br>&gt;&gt;&gt; any other enum. The only big change in the compiler would be the ability<br>&gt;&gt;&gt; to make some declaration inside functions visible to the outside code.<br>&gt;&gt;<br>&gt;&gt; This is my favorite approach (assuming it&#39;s technically feasible) as it<br>&gt;&gt; preserves the limitation that the enumerations are scoped strictly to the<br>&gt;&gt; function but can be referenced outside of it.<br>&gt;&gt;<br>&gt;&gt;   * It allows type inference for dropped prefixes because the compiler<br>&gt;&gt;     can unambiguously match the ad hoc enumeration type to the parameter.<br>&gt;&gt;   * It introduces the possibility (for Matthew) of assigning a value to a<br>&gt;&gt;     variable.<br>&gt;&gt;   * It preserves the notion that an ad-hoc enum makes syntactic and<br>&gt;&gt;     semantic sense only with respect to its use in a function/method<br>&gt;&gt;     parameter list.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If an enumeration needs wider semantics, it should be a standalone type,<br>&gt;&gt; whether as a nested or not.<br>&gt;&gt;<br>&gt;&gt; Reiterating the reasons for this pitch:<br>&gt;&gt;<br>&gt;&gt;   * It streamlines coding, eliminating standalone enumeration types that<br>&gt;&gt;     are used only once<br>&gt;&gt;   * It enables you to see all enumeration options at a glance, and can be<br>&gt;&gt;     reflected in the QuickHelp documentation<br>&gt;&gt;   * It encourages `switch` coding over `if-then-else` coding so each case<br>&gt;&gt;     is labeled and self documenting<br>&gt;&gt;   * It pushes semantics to the call-site in a way that simple Boolean<br>&gt;&gt;     flags cannot: `operation: .Fit` means more than `shouldFill: false`.<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to know at this point whether Hooman&#39;s approach is even<br>&gt;&gt; technically feasible, although it&#39;s horrible timing the Tuesday before<br>&gt;&gt; WWDC to get core team feedback on anything.<br>&gt;&gt;<br>&gt;<br>&gt; There is currently a draft circulating for the removal of @noreturn. If<br>&gt; memory serves, I think there was another annotation recently removed. There<br>&gt; was also the recent change of dynamicType into something like type(of:)..<br>&gt; all these changes have one thing in common: they are streamlining the<br>&gt; language, chasing the magic out and replacing it with the careful<br>&gt; application of a few simple principles. @_exposed would IMVHO be a setback:<br>&gt;<br>&gt;   * it would introduce a new special annotation<br>&gt;   * the annotation would have very little chance of being anything but a<br>&gt;     one of, used for a single scenario<br>&gt;<br>&gt;<br>&gt; Scala went that way years ago, going left right and center, with all sort<br>&gt; of great ideas. In the end, for the past few Scala Days Oderski has been<br>&gt; going on stage explaining why a language with too many clever tricks is in<br>&gt; nobody’s interest.<br>&gt;<br>&gt; if and when they decide to focus on small syntactic sugaring enhancements<br>&gt; (akin to javac&#39;s Project Coin), then they have an easy way to make it<br>&gt; happen without any magic or special rules.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  3, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 3, 2016, at 6:20 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 5:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 5:02 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; in other words, we could consider allowing this:<br>&gt;&gt;&gt;&gt;   func foo(bar: (.fit | .fill)) {<br>&gt;&gt;&gt;&gt;     baz(bar: bar)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt;&gt;&gt;&gt; expected if T ⊆ U.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can&#39;t agree with this. Just because the same analogue with tuples : differently defined tuples are different types. Tuples with different order of types in declaration - are different types. So I expect here instance of (.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br>&gt;&gt; <br>&gt;&gt; They are not the same type but there is a structural subtype relationship between them.  All values of type (.fit | .fill) are also values of type (.fit | .fill | .florp).<br>&gt; <br>&gt; What about disjoint types? Some values of type (.fit | .fill) are values of type (.fit | .florp) and some are not. I&#39;m not a type system expert but my understanding is that this capability gets very complicated very fast.<br></p><p>It feels like the only sane way to model these is as union types where each member of the union has a single literal value like &#39;.fit&#39;.  This is where structural subtyping would come from.<br></p><p>In your example I would say there is no subtype relationship there, just as a union of &#39;Fit | Fill&#39; would not have any subtype / supertype relationship with &#39;Fit | Florp&#39; in a language like Ceylon that has union types.  <br></p><p>Without the structural subtyping these types would be way too fragile to be considered IMO.<br></p><p>&gt; <br>&gt; <br>&gt; What about the ABI? This sounds expensive to implement.<br>&gt; <br>&gt; Consider this set of ad-hoc enum types:<br>&gt; <br>&gt;   (.a | .b)<br>&gt;   (.c | .d)<br>&gt; <br>&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt; <br>&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt; <br>&gt;   (.a | .b | .c | .d)<br>&gt; <br>&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt; <br>&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br>&gt; <br>&gt; An implementation like ObjC&#39;s @selector or C/C++ weak definition would work, but those are expensive in memory overhead and launch time. <br>&gt; <br>&gt; You could give each linkage unit its own copy of the value that includes a string of the value&#39;s name plus an == operator that compares the name strings; that would avoid uniquing but would make some operations slow. <br>&gt; <br>&gt; In any case the performance of these things will not be comparable to ints nor to typical Swift enums that are encoded as ints.<br></p><p>You bring up very good points.  I&#39;m not saying we *should* do this.  Only that if we do introduce ad-hoc enums this seems like the only sane way to do it.  I would want to be able to declare declare variables, etc that use the type without having every mention of the type break when the author of the function adds a new option.<br></p><p>My opinion is that everything you bring up is a pretty solid argument against ad-hoc enums.  Maybe is Swift ever gets union types we could revisit the idea under that umbrella (but that is sounding unlikely, and is definitely not something that will happen soon).<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/88e71921/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June  3, 2016 at 08:00:00pm</p></header><div class="content"><p>If there&#39;s any interest in going down that road, it seems to me that the only viable option is to allow subsets to be convertible to their superset. Items of (.foo | .bar) would be convertible to (.foo | .bar | .baz), but not the opposite (and not necessarily, although preferably, through a simple bitcast).<br></p><p>Félix<br></p><p>&gt; Le 3 juin 2016 à 16:20:18, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 5:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 5:02 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; in other words, we could consider allowing this:<br>&gt;&gt;&gt;&gt;   func foo(bar: (.fit | .fill)) {<br>&gt;&gt;&gt;&gt;     baz(bar: bar)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt;&gt;&gt;&gt; expected if T ⊆ U.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can&#39;t agree with this. Just because the same analogue with tuples : differently defined tuples are different types. Tuples with different order of types in declaration - are different types. So I expect here instance of (.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br>&gt;&gt; <br>&gt;&gt; They are not the same type but there is a structural subtype relationship between them.  All values of type (.fit | .fill) are also values of type (.fit | .fill | .florp).<br>&gt; <br>&gt; What about disjoint types? Some values of type (.fit | .fill) are values of type (.fit | .florp) and some are not. I&#39;m not a type system expert but my understanding is that this capability gets very complicated very fast.<br>&gt; <br>&gt; <br>&gt; What about the ABI? This sounds expensive to implement.<br>&gt; <br>&gt; Consider this set of ad-hoc enum types:<br>&gt; <br>&gt;   (.a | .b)<br>&gt;   (.c | .d)<br>&gt; <br>&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt; <br>&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt; <br>&gt;   (.a | .b | .c | .d)<br>&gt; <br>&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt; <br>&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br>&gt; <br>&gt; An implementation like ObjC&#39;s @selector or C/C++ weak definition would work, but those are expensive in memory overhead and launch time. <br>&gt; <br>&gt; You could give each linkage unit its own copy of the value that includes a string of the value&#39;s name plus an == operator that compares the name strings; that would avoid uniquing but would make some operations slow. <br>&gt; <br>&gt; In any case the performance of these things will not be comparable to ints nor to typical Swift enums that are encoded as ints.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/0642d5f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  4, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 3, 2016, at 10:27 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; If there&#39;s any interest in going down that road, it seems to me that the only viable option is to allow subsets to be convertible to their superset. Items of (.foo | .bar) would be convertible to (.foo | .bar | .baz), but not the opposite (and not necessarily, although preferably, through a simple bitcast).<br></p><p>Yes, I suppose in this case implicit convertibility would suffice.  Thanks for bringing it up.  It is effectively a subtype relationship.<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt;&gt; Le 3 juin 2016 à 16:20:18, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 5:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 5:02 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; in other words, we could consider allowing this:<br>&gt;&gt;&gt;&gt;&gt;   func foo(bar: (.fit | .fill)) {<br>&gt;&gt;&gt;&gt;&gt;     baz(bar: bar)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is<br>&gt;&gt;&gt;&gt;&gt; expected if T ⊆ U.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can&#39;t agree with this. Just because the same analogue with tuples : differently defined tuples are different types. Tuples with different order of types in declaration - are different types. So I expect here instance of (.fit | .fill) `bar` is not of the same type as (.fit | .fill | .florp)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They are not the same type but there is a structural subtype relationship between them.  All values of type (.fit | .fill) are also values of type (.fit | .fill | .florp).<br>&gt;&gt; <br>&gt;&gt; What about disjoint types? Some values of type (.fit | .fill) are values of type (.fit | .florp) and some are not. I&#39;m not a type system expert but my understanding is that this capability gets very complicated very fast.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What about the ABI? This sounds expensive to implement.<br>&gt;&gt; <br>&gt;&gt; Consider this set of ad-hoc enum types:<br>&gt;&gt; <br>&gt;&gt;   (.a | .b)<br>&gt;&gt;   (.c | .d)<br>&gt;&gt; <br>&gt;&gt; Naive implementation: we&#39;ll represent these things as ints, with .a=1, .b=2, .c=1, .d=2.<br>&gt;&gt; <br>&gt;&gt; The naive implementation breaks when a newly-loaded shared library or some library evolution adds this type:<br>&gt;&gt; <br>&gt;&gt;   (.a | .b | .c | .d)<br>&gt;&gt; <br>&gt;&gt; In order to provide ABI stability in the face of arbitrary ad-hoc enum types we must ensure that every ad-hoc enum value has a globally unique ABI representation. <br>&gt;&gt; <br>&gt;&gt; You could constrain ad-hoc enum values to module or class boundaries and prevent creation of types that use values from different places. For example, if Foundation defines (.a | .b) then you can&#39;t define your own ad-hoc enum (.a | .b | .c) that is compatible with Foundation&#39;s value for .a. Then the implementation could use ordinary symbols. If usage of ad-hoc enums is not constrained then ordinary symbols don&#39;t work because there is no universally agreed-upon place where .a is defined.<br>&gt;&gt; <br>&gt;&gt; An implementation like ObjC&#39;s @selector or C/C++ weak definition would work, but those are expensive in memory overhead and launch time. <br>&gt;&gt; <br>&gt;&gt; You could give each linkage unit its own copy of the value that includes a string of the value&#39;s name plus an == operator that compares the name strings; that would avoid uniquing but would make some operations slow. <br>&gt;&gt; <br>&gt;&gt; In any case the performance of these things will not be comparable to ints nor to typical Swift enums that are encoded as ints.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/10f63044/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 1, 2016, at 4:38 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I find myself agreeing with the idea that ad hoc enums are to enums as structs are to tuples. Based on that analogy, why should an ad hoc enum *need* a name (autogenerated or otherwise) any more than a tuple needs a name? Would those who dislike ad hoc enums argue that this also shouldn&#39;t be allowed:<br>&gt; <br>&gt;     func foo(bar: (x: Int, y: Int)) {}<br>&gt;     let t: (x: Int, y: Int) = (x: 5, y: 5)<br>&gt; <br>&gt; If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax might be), that should just *be* the type the same way that `(x: Int, y: Int)` is a type without a name, and that type can be used in argument lists, variables, or whatever. There shouldn&#39;t be any worry about declarations across multiple functions colliding or being incompatible any more than we would worry about two functions declaring arguments of type `(x: Int, y: Int)` would collide or be incompatible.<br>&gt; <br>&gt; One side of ad hoc enums that I&#39;d like to see explored is that, by being unnamed, they&#39;re basically anonymous finite sets and we could apply well-defined subset relationships to them: in other words, we could consider allowing this:<br>&gt; <br>&gt;     func foo(bar: (.fit | .fill)) {<br>&gt;       baz(bar: bar)<br>&gt;     }<br>&gt;     func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt; <br>&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is expected if T ⊆ U.<br></p><p>When I said I am very opposed to this feature *unless* these ad-hoc enums have structural subtyping this is what I was talking about.  IMO this is absolutely essential if we introduce ad-hoc enums (as well as the ability to use the types for variables, not just parameters).<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes, I also can support the idea of autogenerated type name (like Enum_fit_OR_fill) as long as it allows to do all the things we are discussing here: declare (.fit|.fill) in function, use .fit on calling side, use (.fit|.fill) to declare temporary variable of type compatible with such function parameter etc.<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; It all works because the compiler is just being a thoughless scribe that just writes the standard enum we don&#39;t bother to write ourselves. Because the heuristic is simple and straightforward then it is predictible. The enum can be used with its long name be ause it is a real enum. And writing the short form of it also works because the compiler knowns uniquely what the long name is everytime it runs into the short name.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; But how do you suggest to define a type of such function in `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt;&gt; &gt; or as<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Ideally there is no difference whatsoever, there is a single enum, it is produced at the module level, and it has the long form name.<br>&gt;&gt; <br>&gt;&gt; There can be rules that would prevent us from doing that with externally visible APIs, if the core team fuges that we should take the time to write our enums manually and cleanly to make them visible to the world, but it is not a necessary rule.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I still can&#39;t support the idea of limiting the usage of such enums - i.e. &quot;To deal with milti site definition, the compiler would simply flag a error/warning, or be silent in the presence of a new annotation:&quot;. I really think we need then introduce the same rule for tuples - so no one can use the same tuple declaration in function - they then should declare separate struct type or use @something for such functions. Nobody wants such rule for tuples.<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Multi site thing is not a limitation... Is is a proposed rule to say that we are able to be lazy twice without being penalized. Yhe compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. But because this is about concise and lazy, then the compiler can let us get away with it if we use an annotation that lets it know that &quot;it is not a mistake.. I really dont want to write that enum myself, even though I am using the same abbreviation twice&quot;. Otherwise, the compiler would let us know that the second time could be a mistake because there is already something with the same name...<br>&gt;&gt; <br>&gt;&gt; But again this is a separate idea from the core notion of a syntax sugaring for writing real enums the lazy (clever) way<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;&gt; &gt;&gt; The only problem with this proposal is to consider them ad-hoc enums... If we view them as having nothing ad-hoc about them and the thing to be a simple sugaring exercise, then I think all the opositions on grounds of breaking the language disapear. It still does not mean it should be done if the core team does not like the idea of encouraging laziness, or simply do not like what it makes them look like. No matter what, this type of sugaring exercise has been clearly stated as out of scope for 3.0<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt; &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt; &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt; &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt; &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;&gt; &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;&gt; &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual representation if the declared type. As I understand this also could not be a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; From other point of view, adding such type to typesystem will add some consistence : you can create a function that don&#39;t need definition of separate structure type(tuple will be used) and don&#39;t need separate enum type(ad-hoc enum will be used). I.e. all data the function needs to process could be described in function definition. Today we need to use ugly Bool flags in case we want to achieve the same target.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt; &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt; &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt; &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt;&gt; &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt;&gt; &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt; &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt; &gt;&gt;&gt;&gt; different things.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum in function parameters - then they are of the same type.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I.e. :<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;&gt; &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; but<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;&gt; &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt; &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt;&gt; &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt; &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt; &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt; &gt;&gt;&gt;&gt; matching across several values at once, but structs are better used for<br>&gt;&gt; &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt; &gt;&gt;&gt;&gt; don&#39;t.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as for tuples vs struct declaration. Yes can use it with care and you can use it in wrong way.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/1193da4f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>June  1, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 5:38 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; we could consider allowing this:<br>&gt; <br>&gt;     func foo(bar: (.fit | .fill)) {<br>&gt;       baz(bar: bar)<br>&gt;     }<br>&gt;     func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt; <br>&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is expected if T ⊆ U.<br></p><p>If that were the case then it may not be that bad. <br></p><p>I would not use it that much as I favor reusability and would normally create an enum for it for maximum flexibility and reuse. <br></p><p>I like tuples but I don&#39;t use them much and I have survived in other languages without them. :-)<br></p><p>This is all sugar to me. I may use it when putting code together quickly but not in formal APIs. <br></p><p>I really look forward to seeing other features in Swift that will elevate the language and run-time to levels where Objective-C still has an edge over Swift. In particular reflection, property behaviors, KVC, etc.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 2 Jun 2016, at 7:38 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would those who dislike ad hoc enums argue that this also shouldn&#39;t be allowed:<br>&gt; <br>&gt;     func foo(bar: (x: Int, y: Int)) {}<br>&gt;     let t: (x: Int, y: Int) = (x: 5, y: 5)<br></p><p><br>I would argue that example contains a code smell, so while it compiles, I personally wouldn’t allow it.<br></p><p>But it depends on the semantics of course. And there should always be a pull as a writer to turn a tuple into a struct.<br></p><p>My issue with ad hoc enums is that their context is to the function. They should instead be an independent concept, and that’s why an enum type is so useful, because it even names the concept.<br></p><p>Tuples from what I see are primarily function based, so it’s really overcoming the fact that while you can pass multiple parameters to a function, you only get one back, so a tuple is the best way to solve that. (And of course they work with callbacks too, an asynchronous version of returning from a function, or functions that alter and return their input).<br></p><p>As soon as you start passing a tuple around, it has meaning, and our job as programmers is to assign names and flesh out meaning.<br></p><p>And if you are translating from (.fit | .fill) to (.fit | .fill | .florp), that’s a lot of boilerplate code, which goes against the whole reason for having ad hoc enums (or just imagine going the opposite way, there’s a lot more to be discussed on how ad hoc enums work I think). It would be better in mind to break them up into thoughtful pieces, such as two enums or an enum and an extra bool. This isn’t always easy of course. Them’s the breaks!<br></p><p>Patrick<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  2, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 11:38 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt; <br>&gt; I find myself agreeing with the idea that ad hoc enums are to enums as structs are to tuples. Based on that analogy, why should an ad hoc enum *need* a name (autogenerated or otherwise) any more than a tuple needs a name?<br></p><p>A nameless enum is basically a square circle. An enum is a nominal type, which entails that it is characterized by the existence of its name. Two enums with the exact same internal shape are different if their names are different, and two enums with different internal shapes but the same name will trigger a compiler type redefinition error because the name is what identities the enum. <br></p><p><br>&gt; Would those who dislike ad hoc enums argue that this also shouldn&#39;t be allowed:<br>&gt; <br>&gt;     func foo(bar: (x: Int, y: Int)) {}<br>&gt;     let t: (x: Int, y: Int) = (x: 5, y: 5)<br>&gt; <br>&gt; If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax might be), that should just *be* the type the same way that `(x: Int, y: Int)` is a type without a name, and that type can be used in argument lists, variables, or whatever. There shouldn&#39;t be any worry about declarations across multiple functions colliding or being incompatible any more than we would worry about two functions declaring arguments of type `(x: Int, y: Int)` would collide or be incompatible.<br>&gt; <br>&gt; One side of ad hoc enums that I&#39;d like to see explored is that, by being unnamed, they&#39;re basically anonymous finite sets and we could apply well-defined subset relationships to them: in other words, we could consider allowing this:<br>&gt; <br>&gt;     func foo(bar: (.fit | .fill)) {<br>&gt;       baz(bar: bar)<br>&gt;     }<br>&gt;     func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt; <br>&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is expected if T ⊆ U.<br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes, I also can support the idea of autogenerated type name (like Enum_fit_OR_fill) as long as it allows to do all the things we are discussing here: declare (.fit|.fill) in function, use .fit on calling side, use (.fit|.fill) to declare temporary variable of type compatible with such function parameter etc.<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; It all works because the compiler is just being a thoughless scribe that just writes the standard enum we don&#39;t bother to write ourselves. Because the heuristic is simple and straightforward then it is predictible. The enum can be used with its long name be ause it is a real enum. And writing the short form of it also works because the compiler knowns uniquely what the long name is everytime it runs into the short name.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; But how do you suggest to define a type of such function in `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt;&gt; &gt; or as<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Ideally there is no difference whatsoever, there is a single enum, it is produced at the module level, and it has the long form name.<br>&gt;&gt; <br>&gt;&gt; There can be rules that would prevent us from doing that with externally visible APIs, if the core team fuges that we should take the time to write our enums manually and cleanly to make them visible to the world, but it is not a necessary rule.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I still can&#39;t support the idea of limiting the usage of such enums - i.e. &quot;To deal with milti site definition, the compiler would simply flag a error/warning, or be silent in the presence of a new annotation:&quot;. I really think we need then introduce the same rule for tuples - so no one can use the same tuple declaration in function - they then should declare separate struct type or use @something for such functions. Nobody wants such rule for tuples.<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Multi site thing is not a limitation... Is is a proposed rule to say that we are able to be lazy twice without being penalized. Yhe compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. But because this is about concise and lazy, then the compiler can let us get away with it if we use an annotation that lets it know that &quot;it is not a mistake.. I really dont want to write that enum myself, even though I am using the same abbreviation twice&quot;. Otherwise, the compiler would let us know that the second time could be a mistake because there is already something with the same name...<br>&gt;&gt; <br>&gt;&gt; But again this is a separate idea from the core notion of a syntax sugaring for writing real enums the lazy (clever) way<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;&gt; &gt;&gt; The only problem with this proposal is to consider them ad-hoc enums... If we view them as having nothing ad-hoc about them and the thing to be a simple sugaring exercise, then I think all the opositions on grounds of breaking the language disapear. It still does not mean it should be done if the core team does not like the idea of encouraging laziness, or simply do not like what it makes them look like. No matter what, this type of sugaring exercise has been clearly stated as out of scope for 3.0<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt; &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt; &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt; &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt; &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;&gt; &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;&gt; &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual representation if the declared type. As I understand this also could not be a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; From other point of view, adding such type to typesystem will add some consistence : you can create a function that don&#39;t need definition of separate structure type(tuple will be used) and don&#39;t need separate enum type(ad-hoc enum will be used). I.e. all data the function needs to process could be described in function definition. Today we need to use ugly Bool flags in case we want to achieve the same target.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt; &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt; &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt; &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt;&gt; &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt;&gt; &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt; &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt; &gt;&gt;&gt;&gt; different things.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum in function parameters - then they are of the same type.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I.e. :<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;&gt; &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; but<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;&gt; &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt; &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt;&gt; &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt; &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt; &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt; &gt;&gt;&gt;&gt; matching across several values at once, but structs are better used for<br>&gt;&gt; &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt; &gt;&gt;&gt;&gt; don&#39;t.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as for tuples vs struct declaration. Yes can use it with care and you can use it in wrong way.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/0e566077/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>I don&#39;t understand this. All of what you said applies to structs and does not apply to tuples. What makes it fundamentally impossible to have a &quot;tuple-like enum&quot;?<br></p><p>Félix<br></p><p>&gt; Le 1 juin 2016 à 20:56:27, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Jun 1, 2016, at 11:38 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I find myself agreeing with the idea that ad hoc enums are to enums as structs are to tuples. Based on that analogy, why should an ad hoc enum *need* a name (autogenerated or otherwise) any more than a tuple needs a name?<br>&gt; <br>&gt; A nameless enum is basically a square circle. An enum is a nominal type, which entails that it is characterized by the existence of its name. Two enums with the exact same internal shape are different if their names are different, and two enums with different internal shapes but the same name will trigger a compiler type redefinition error because the name is what identities the enum. <br>&gt; <br>&gt; <br>&gt;&gt; Would those who dislike ad hoc enums argue that this also shouldn&#39;t be allowed:<br>&gt;&gt; <br>&gt;&gt;     func foo(bar: (x: Int, y: Int)) {}<br>&gt;&gt;     let t: (x: Int, y: Int) = (x: 5, y: 5)<br>&gt;&gt; <br>&gt;&gt; If someone writes `(.fit | .fill)` (or whatever the hypothetical syntax might be), that should just *be* the type the same way that `(x: Int, y: Int)` is a type without a name, and that type can be used in argument lists, variables, or whatever. There shouldn&#39;t be any worry about declarations across multiple functions colliding or being incompatible any more than we would worry about two functions declaring arguments of type `(x: Int, y: Int)` would collide or be incompatible.<br>&gt;&gt; <br>&gt;&gt; One side of ad hoc enums that I&#39;d like to see explored is that, by being unnamed, they&#39;re basically anonymous finite sets and we could apply well-defined subset relationships to them: in other words, we could consider allowing this:<br>&gt;&gt; <br>&gt;&gt;     func foo(bar: (.fit | .fill)) {<br>&gt;&gt;       baz(bar: bar)<br>&gt;&gt;     }<br>&gt;&gt;     func baz(bar: (.fit | .fill | .florp) { ... }<br>&gt;&gt; <br>&gt;&gt; In other words, an ad hoc enum T can be used wherever an ad hoc enum U is expected if T ⊆ U.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 1, 2016 at 1:43 PM L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 1, 2016, at 6:51 PM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes, I also can support the idea of autogenerated type name (like Enum_fit_OR_fill) as long as it allows to do all the things we are discussing here: declare (.fit|.fill) in function, use .fit on calling side, use (.fit|.fill) to declare temporary variable of type compatible with such function parameter etc.<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; It all works because the compiler is just being a thoughless scribe that just writes the standard enum we don&#39;t bother to write ourselves. Because the heuristic is simple and straightforward then it is predictible. The enum can be used with its long name be ause it is a real enum. And writing the short form of it also works because the compiler knowns uniquely what the long name is everytime it runs into the short name.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; But how do you suggest to define a type of such function in `typealias` for example? i.e. for func my(option: (.fit|.fill) {..}<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; typealias MyFunc = ((.fit|.fill)) -&gt; ()<br>&gt;&gt; &gt; or as<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; typealias MyFunc = (Enum_fit_OR_fill) -&gt; ()<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Ideally there is no difference whatsoever, there is a single enum, it is produced at the module level, and it has the long form name.<br>&gt;&gt; <br>&gt;&gt; There can be rules that would prevent us from doing that with externally visible APIs, if the core team fuges that we should take the time to write our enums manually and cleanly to make them visible to the world, but it is not a necessary rule.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But I still can&#39;t support the idea of limiting the usage of such enums - i.e. &quot;To deal with milti site definition, the compiler would simply flag a error/warning, or be silent in the presence of a new annotation:&quot;. I really think we need then introduce the same rule for tuples - so no one can use the same tuple declaration in function - they then should declare separate struct type or use @something for such functions. Nobody wants such rule for tuples.<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Multi site thing is not a limitation... Is is a proposed rule to say that we are able to be lazy twice without being penalized. Yhe compiler does not like when we define the same thing twice, and thse short form amount to doing what he does not let us do. But because this is about concise and lazy, then the compiler can let us get away with it if we use an annotation that lets it know that &quot;it is not a mistake.. I really dont want to write that enum myself, even though I am using the same abbreviation twice&quot;. Otherwise, the compiler would let us know that the second time could be a mistake because there is already something with the same name...<br>&gt;&gt; <br>&gt;&gt; But again this is a separate idea from the core notion of a syntax sugaring for writing real enums the lazy (clever) way<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; On 01.06.2016 19:04, L. Mihalkovic wrote:<br>&gt;&gt; &gt;&gt; The only problem with this proposal is to consider them ad-hoc enums... If we view them as having nothing ad-hoc about them and the thing to be a simple sugaring exercise, then I think all the opositions on grounds of breaking the language disapear. It still does not mean it should be done if the core team does not like the idea of encouraging laziness, or simply do not like what it makes them look like. No matter what, this type of sugaring exercise has been clearly stated as out of scope for 3.0<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jun 1, 2016, at 2:38 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On 01.06.2016 11:00, Austin Zheng wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt; Tuples are a structural type, they are described entirely by the fact<br>&gt;&gt; &gt;&gt;&gt;&gt; that they are a tuple, plus their contained types.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Enum cases are not individual types; that precedent exists nowhere in<br>&gt;&gt; &gt;&gt;&gt;&gt; Swift. You can&#39;t (yet) build a structural type out of something that<br>&gt;&gt; &gt;&gt;&gt;&gt; isn&#39;t a type. The fact that you had to propose something like<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;AdhocEnumFitFill_2383748&quot; as an autogenerated name for the type<br>&gt;&gt; &gt;&gt;&gt;&gt; demonstrates the proposal&#39;s weaknesses: a tuple is an ad-hoc type that<br>&gt;&gt; &gt;&gt;&gt;&gt; describes itself, while an anonymous enum isn&#39;t.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Yes, I understand the point about the type of such adhoc enum.<br>&gt;&gt; &gt;&gt;&gt; The only workaround I can see in this case(if we&#39;d really want to have it in language) if adhoc enum type will be `(.Fit|.Fill)` i.e. textual representation if the declared type. As I understand this also could not be a solution.. I.e. for example `(Int,String,(.Fit|.Fill))-&gt;String`<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; From other point of view, adding such type to typesystem will add some consistence : you can create a function that don&#39;t need definition of separate structure type(tuple will be used) and don&#39;t need separate enum type(ad-hoc enum will be used). I.e. all data the function needs to process could be described in function definition. Today we need to use ugly Bool flags in case we want to achieve the same target.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Now if enum cases were equivalent if they had the same name (like how<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;Int&quot; means the same thing no matter what tuple or generic type it is<br>&gt;&gt; &gt;&gt;&gt;&gt; used in), we&#39;d have a good foundation for a self-describing structural<br>&gt;&gt; &gt;&gt;&gt;&gt; type. But this isn&#39;t how the existing named enum types work. Why would<br>&gt;&gt; &gt;&gt;&gt;&gt; it be a good idea to make anonymous enum cases interchangeable by name?<br>&gt;&gt; &gt;&gt;&gt;&gt; Properties on different types aren&#39;t interchangeable, even if they have<br>&gt;&gt; &gt;&gt;&gt;&gt; the same type. In fact, no type member that I am aware of is<br>&gt;&gt; &gt;&gt;&gt;&gt; interchangeable solely on the basis of name. An &quot;ArtistAction.Draw&quot; and<br>&gt;&gt; &gt;&gt;&gt;&gt; &quot;CowboyAction.Draw&quot; might have the same name, but they mean completely<br>&gt;&gt; &gt;&gt;&gt;&gt; different things.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I don&#39;t think they should be &#39;interchangeable by name&#39;, but just like tuples if you defined adhoc enum with exactly the same cases as ad-hoc enum in function parameters - then they are of the same type.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I.e. :<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func foo(option: (.fit|.fill)) {..}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; foo(.fit) // .fit is of type  (.fit|.fill) from definition<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; let e : (.fit|.fill) = .fit<br>&gt;&gt; &gt;&gt;&gt; foo(e) // e is of (.fit|.fill) type, equal to definition<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; but<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func foo2(option: (.fit|.fill|.other)) {..}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; foo2(.fit) // ok, here .fit is of (.fit|.fill|.other) type<br>&gt;&gt; &gt;&gt;&gt; foo2(e) --&gt; Error, e is not of type (.fit|.fill|.other)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Finally, I have to ask: if you are updating your anonymous enum in<br>&gt;&gt; &gt;&gt;&gt;&gt; multiple places, how much effort have you actually saved over a one-line<br>&gt;&gt; &gt;&gt;&gt;&gt; enum definition? In fact, tuples are a great example of this: best<br>&gt;&gt; &gt;&gt;&gt;&gt; practices usually state that they are good for ad-hoc destructuring,<br>&gt;&gt; &gt;&gt;&gt;&gt; such as retrieving multiple return values from a function or pattern<br>&gt;&gt; &gt;&gt;&gt;&gt; matching across several values at once, but structs are better used for<br>&gt;&gt; &gt;&gt;&gt;&gt; almost everything else, since they carry semantic meaning that tuples<br>&gt;&gt; &gt;&gt;&gt;&gt; don&#39;t.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Just the same pros and cons for ad-hoc enums vs enum declaration as for tuples vs struct declaration. Yes can use it with care and you can use it in wrong way.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Btw, I feel like this could be very handy to return adhoc enum:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; func something() -&gt; (.one|.two|.three) {...}<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; I hope that clarifies my thoughts on the matter.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 12:36 AM, Vladimir.S &lt;svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On 01.06.2016 9:55, Austin Zheng via swift-evolution wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; symmetry of the language like this (are there any other types of<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; function arguments that cannot be passed as either variable values<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or literals?) is too much a price to pay. Your library thinks it&#39;s<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; being clever and vends its functions as taking anonymous enum flags,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and now there are a bunch of things I can&#39;t do with those functions<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; anymore.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; A regular enum can be declared in one line anyways:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Why do we have tuples? Struct could be defined by one line `struct<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; SomeValue { var x = 0, y = 0 }` ;-) I.e. from my point of view<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; developer should decide what he/she wants to use: ad-hoc enum or<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; defined enum type *exactly* as now he/she can decide to use the same<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; tuples in multiply functions instead of one defined struct type.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I replied regarding the variable on other message. (In short: I think<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; of the same principle as for tuples: you can declare variable `let e:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; (.fill | .fit) = .fill` and use it)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt; &lt;mailto:charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It breaks the ability to pass in a variable containing the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; desired<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; value, rather than the literal value itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; hardcoded enum case, then that enum is probably general enough<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that it warrants a normal enum. But there are also situations<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; where the same function is called from several files in the same<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; code-base with different flags. Those are situations where it<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; feels like overkill to clutter up my codebase with separate enums,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; only used by a single function.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; I admire the desire of this proposal to increase the readability<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; desired value, rather than the literal value itself. (Unless you<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; actually want a not-so-anonymous enum type whose definition<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; happens to live in a function signature rather than somewhere<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you&#39;d usually expect a type definition to live.) - It breaks the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; ability to store a reference to the function in a variable of<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; function type (ditto). - Almost every time I&#39;ve wanted to use one<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; use that same enum elsewhere. In my experience, &#39;lightweight<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; enums&#39; don&#39;t end up saving much time compared to a full-fledged<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; one.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; make enums synonyms for numerical values. What happens if you<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rearrange your anonymous enum cases between library versions? Do<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you somehow store an opaque case-to-UInt8 table somewhere for<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; every anonymous enum you define for resilience? What happens when<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; people start bringing back terrible C patterns, like doing<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; arithmetic or bitwise ops on the underlying case values? At least<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And the obvious answer is you can have up to 255 of these babies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the anonymous enum type, and be able to pass numerical<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; equivalents UInt8 with compile time substitution. That the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ad-hoc enumeration is basically a syntactic shorthand for UInt8,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with an enforced upper bound compile time check simplifies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; everything including switch statements.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/65ca2aac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  2, 2016 at 08:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/9b5074a6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  1, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 1, 2016, at 1:55 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the symmetry of the language like this (are there any other types of function arguments that cannot be passed as either variable values or literals?) is too much a price to pay. Your library thinks it&#39;s being clever and vends its functions as taking anonymous enum flags, and now there are a bunch of things I can&#39;t do with those functions anymore.<br></p><p>+1.  Total non-starter to allow functions that are pretty much broken by design. <br></p><p>&gt; <br>&gt; A regular enum can be declared in one line anyways:<br>&gt; <br>&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt; <br>&gt; Austin <br>&gt; <br>&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;  It breaks the ability to pass in a variable containing the desired value, rather than the literal value itself.<br>&gt;&gt; <br>&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a hardcoded enum case, then that enum is probably general enough that it warrants a normal enum. But there are also situations where the same function is called from several files in the same code-base with different flags. Those are situations where it feels like overkill to clutter up my codebase with separate enums, only used by a single function. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I admire the desire of this proposal to increase the readability of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the desired value, rather than the literal value itself. (Unless you actually want a not-so-anonymous enum type whose definition happens to live in a function signature rather than somewhere you&#39;d usually expect a type definition to live.)<br>&gt;&gt;&gt; - It breaks the ability to store a reference to the function in a variable of function type (ditto).<br>&gt;&gt;&gt; - Almost every time I&#39;ve wanted to use one of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to use that same enum elsewhere. In my experience, &#39;lightweight enums&#39; don&#39;t end up saving much time compared to a full-fledged one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to make enums synonyms for numerical values. What happens if you rearrange your anonymous enum cases between library versions? Do you somehow store an opaque case-to-UInt8 table somewhere for every anonymous enum you define for resilience? What happens when people start bringing back terrible C patterns, like doing arithmetic or bitwise ops on the underlying case values? At least you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/dfa084f6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>June  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 1 juin 2016 à 02:55, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Maybe it&#39;s overkill. My personal opinion is that breaking the symmetry of the language like this (are there any other types of function arguments that cannot be passed as either variable values or literals?) is too much a price to pay. Your library thinks it&#39;s being clever and vends its functions as taking anonymous enum flags, and now there are a bunch of things I can&#39;t do with those functions anymore.<br></p><p>&#39;inout&#39; doesn&#39;t accept literal, function-like compiler directive cannot use variables. So both variables and literals are not always both accepted; not sure though if it can be used as a precedent for this ad-hoc enum.<br></p><p>Dany<br></p><p>&gt; A regular enum can be declared in one line anyways:<br>&gt; <br>&gt; enum ScaleCropMode { case Fit, Fill }<br>&gt; <br>&gt; Austin <br>&gt; <br>&gt;&gt; On May 31, 2016, at 11:44 PM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;  It breaks the ability to pass in a variable containing the desired value, rather than the literal value itself.<br>&gt;&gt; <br>&gt;&gt; Maybe that&#39;s appropriate? If the caller is not passing in a hardcoded enum case, then that enum is probably general enough that it warrants a normal enum. But there are also situations where the same function is called from several files in the same code-base with different flags. Those are situations where it feels like overkill to clutter up my codebase with separate enums, only used by a single function. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 9:24 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I admire the desire of this proposal to increase the readability of code. I&#39;m -1 to the proposal itself, though:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - It breaks the ability to pass in a variable containing the desired value, rather than the literal value itself. (Unless you actually want a not-so-anonymous enum type whose definition happens to live in a function signature rather than somewhere you&#39;d usually expect a type definition to live.)<br>&gt;&gt;&gt; - It breaks the ability to store a reference to the function in a variable of function type (ditto).<br>&gt;&gt;&gt; - Almost every time I&#39;ve wanted to use one of these &quot;anonymous enums&quot; in my code, I&#39;ve ended up needing to use that same enum elsewhere. In my experience, &#39;lightweight enums&#39; don&#39;t end up saving much time compared to a full-fledged one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Like Brent said, I have to say no to any proposal that tries to make enums synonyms for numerical values. What happens if you rearrange your anonymous enum cases between library versions? Do you somehow store an opaque case-to-UInt8 table somewhere for every anonymous enum you define for resilience? What happens when people start bringing back terrible C patterns, like doing arithmetic or bitwise ops on the underlying case values? At least you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/42198e65/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; - It breaks the ability to store a reference to the function in a variable<br> &gt; of function type (ditto).<br></p><p>IMO the most important point. Probably we can have autogenerated names for <br>such enums like:<br></p><p>function : func f(e: (.fit | .fill))-&gt;String<br>type is : (AdhocEnumFitFill)-&gt;String<br></p><p>or with no pre-defined syntax for such enum(so can&#39;t be used as type in code):<br>(AdhocEnumFitFill_2383748)-&gt;String<br>or just<br>(_enum_2383748)-&gt;String<br></p><p>But in this case two functions with different AdhocEnum_xxxx should be <br>compatible between each other if cases exactly the same.<br>I.e. we should be able to write:<br></p><p>typealias MyFunc = func (x: (.fit | .fill))-&gt;String<br>// internally this will be (_enum_9823765)-&gt;String<br>let myfunc : MyFunc = f<br></p><p>Probably we could have such syntax for adhoc enums:<br>func f(e: enum(.fit, .fill)) {}<br></p><p>As for other questions, for myself, I use the analogue with tuples: if <br>function requires a tuple, you can define tuple variable by typing its <br>declaration manually. And you can have the same tuples in a number of <br>functions, instead of structs. Yes, you will need to change tuple variables <br>*anywhere* in your code if tuple in function declaration changed.<br>You have this freedom for tupes(ad-hoc structure). Why don&#39;t we need the <br>same for enums ?<br></p><p>On 01.06.2016 7:24, Austin Zheng via swift-evolution wrote:<br>&gt; I admire the desire of this proposal to increase the readability of code.<br>&gt; I&#39;m -1 to the proposal itself, though:<br>&gt;<br>&gt; - It breaks the ability to pass in a variable containing the desired value,<br>&gt; rather than the literal value itself. (Unless you actually want a<br>&gt; not-so-anonymous enum type whose definition happens to live in a function<br>&gt; signature rather than somewhere you&#39;d usually expect a type definition to<br>&gt; live.)<br>&gt; - It breaks the ability to store a reference to the function in a variable<br>&gt; of function type (ditto).<br>&gt; - Almost every time I&#39;ve wanted to use one of these &quot;anonymous enums&quot; in my<br>&gt; code, I&#39;ve ended up needing to use that same enum elsewhere. In my<br>&gt; experience, &#39;lightweight enums&#39; don&#39;t end up saving much time compared to a<br>&gt; full-fledged one.<br>&gt;<br>&gt; Like Brent said, I have to say no to any proposal that tries to make enums<br>&gt; synonyms for numerical values. What happens if you rearrange your anonymous<br>&gt; enum cases between library versions? Do you somehow store an opaque<br>&gt; case-to-UInt8 table somewhere for every anonymous enum you define for<br>&gt; resilience? What happens when people start bringing back terrible C<br>&gt; patterns, like doing arithmetic or bitwise ops on the underlying case<br>&gt; values? At least you have to try pretty hard as it is to abuse Swift&#39;s enums.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 31, 2016 at 8:25 PM, Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     &gt; And the obvious answer is you can have up to 255 of these babies for the anonymous enum type, and be able to pass numerical equivalents UInt8 with compile time substitution. That the ad-hoc enumeration is basically a syntactic shorthand for UInt8, with an enforced upper bound compile time check simplifies everything including switch statements.<br>&gt;<br>&gt;     If I wanted a language like that, I&#39;d be writing C, not Swift.<br>&gt;<br>&gt;     --<br>&gt;     Brent Royal-Gordon<br>&gt;     Architechies<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>June  1, 2016 at 02:00:00pm</p></header><div class="content"><p>I support the original proposal. My assumption is that (.fit|.fill) is the<br>name of a type that can be used anywhere types can be named.<br></p><p>I think the concern about duplicates is misplaced. If the same developer<br>creates the scaleAndCrop function and the rect function, they may decide to<br>extract the enum type to a named enum when they see the second use. If they<br>don&#39;t, it&#39;s because they&#39;re in the flow - no harm results from naming this<br>type in two places. They have the opportunity to reconsider their decision<br>if they add cases later.<br></p><p>Ad hoc enums are to named enums as closures are to funcs: closures and ad<br>hoc enums both increase developer flow at the risk that the developer needs<br>to refactor later to maximize reuse and minimize duplication. Allowing<br>developers to make these trade-offs according to their own preference is a<br>good thing.<br></p><p>-- Callionica<br></p><p>On Tue, May 31, 2016 at 2:20 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; func scaleAndCropImage(<br>&gt; &gt;     image: UIImage,<br>&gt; &gt;     toSize size: CGSize,<br>&gt; &gt;     operation: (.Fit | .Fill) = .Fit<br>&gt; &gt;     ) -&gt; UIImage {<br>&gt;<br>&gt; As I said the last time this proposal came up, I think this is great right<br>&gt; up until the moment you need `operation` to be computed or kept in a<br>&gt; variable. Then you need to start copying your anonymous enum type all over<br>&gt; your source, and there&#39;s no central place to make changes. The same thing<br>&gt; is true of tuples, but tuples are easy to structure and destructure from<br>&gt; individual values on the spot; anonymous enums aren&#39;t really like that.<br>&gt;<br>&gt; And this problem starts occurring *very* quickly. I mean, you&#39;ve left<br>&gt; `scaleAndCropImage`&#39;s implementation out. Imagine implementing it with a<br>&gt; couple helper functions, and you start to see this problem occurring:<br>&gt;<br>&gt;         func scaleAndCrop(image: UIImage, to size: CGSize, operation:<br>&gt; (.fit | .fill) = .fit) -&gt; UIImage {<br>&gt;                 let drawingRect = rect(of: size, for: operation)<br>&gt;                 return drawnImage(image, in: drawingRect)<br>&gt;         }<br>&gt;<br>&gt;         private func rect(of size: CGSize, for operation: (.fit | .fill))<br>&gt; -&gt; CGRect {<br>&gt;<br>&gt; Already we have one duplication; if we add .fillWidth and .fillHeight<br>&gt; modes, we&#39;ll need to change signatures in two places.<br>&gt;<br>&gt; In short, when you dig into this proposal and start thinking of use cases<br>&gt; that are even slightly less than completely trivial, I think the case for<br>&gt; it falls apart.<br>&gt;<br>&gt; (It&#39;s also worth noting that this isn&#39;t suitable for options, because it<br>&gt; creates an anonymous enum, not an anonymous option set.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/b5d45b1a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>May 31, 2016 at 07:00:00pm</p></header><div class="content"><p>I like the idea, but it is worth noting that unless the syntax is generalized (which I&#39;m not necessarily against), the type of `operation` cannot be referenced. This means that you can&#39;t declare a variable of that type, unless you assign the argument to it.<br></p><p>Félix<br></p><p>&gt; Le 31 mai 2016 à 09:16:56, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Here&#39;s a function signature from some code from today:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     fitImage: Bool = true<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt; <br>&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt; <br>&gt; Thanks for your feedback,<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/4228226e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June  1, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree the second is much nicer, and a lot clearer on what each of the options does; fitImage: true is pretty clear, but fitImage: false is not, but the ad-hoc enum is clear on both counts. That said, the questions of interoperability are a big issue for ad-hoc enums, as either they’re too strict which becomes inconvenient (a .Fit | .Fill working with one method but not another) or too relaxed to be safe. Of course, in the latter case you’re replacing a Bool, which couldn’t be more relaxed in terms of where it accepts values from.<br></p><p>Still, I think in this case it would be better to fully-define an enum, as it gives you total control over compatibility and reusability of the type, which you can’t really with the ad-hoc form without making it overly complex.<br></p><p>The main type of ad-hoc enum I want to see is a union-type like so:<br></p><p>	func someMethod(value:(Int | String)) { … }<br></p><p>This would basically be an ad-hoc enum where each case identifies one of the possible types, and the value bound as that type. This works however because there’s no ambiguity in the meaning; an (Int | String) is the same wherever you use it, whereas a general-purpose ad-hoc enum is less clear, as an other method might also take .Fit and .Fill values, but these may have a slightly different meaning.<br></p><p>So yeah, I like the idea in principle, but I think in practice it has too many headaches to overcome for it to be as simple as it first appears =(<br></p><p>&gt; On 31 May 2016, at 17:16, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here&#39;s a function signature from some code from today:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     fitImage: Bool = true<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt; <br>&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt; <br>&gt; Thanks for your feedback,<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/f1df169e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 08:00:00am</p></header><div class="content"><p>Unions have been discussed earlier in this group and I personally<br>think this is an issue better solved using function overloading.<br>Despite this, I see how union types could be implemented (hint:<br>Optionals) but to use it in code would require you to, at least, test<br>for the type of the value at hand for the blocks of different code<br>between types. It feels like trying to bend a static typed language to<br>work a bit like a dynamic typed and while both have their pros and<br>cons I don&#39;t really think there is any benefit for the programmer and<br>the readability of the code in bending the type checker like this.<br></p><p>L<br></p><p>On 1 June 2016 at 08:06, Haravikk via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I agree the second is much nicer, and a lot clearer on what each of the<br>&gt; options does; fitImage: true is pretty clear, but fitImage: false is not,<br>&gt; but the ad-hoc enum is clear on both counts. That said, the questions of<br>&gt; interoperability are a big issue for ad-hoc enums, as either they’re too<br>&gt; strict which becomes inconvenient (a .Fit | .Fill working with one method<br>&gt; but not another) or too relaxed to be safe. Of course, in the latter case<br>&gt; you’re replacing a Bool, which couldn’t be more relaxed in terms of where it<br>&gt; accepts values from.<br>&gt;<br>&gt; Still, I think in this case it would be better to fully-define an enum, as<br>&gt; it gives you total control over compatibility and reusability of the type,<br>&gt; which you can’t really with the ad-hoc form without making it overly<br>&gt; complex.<br>&gt;<br>&gt; The main type of ad-hoc enum I want to see is a union-type like so:<br>&gt;<br>&gt; func someMethod(value:(Int | String)) { … }<br>&gt;<br>&gt; This would basically be an ad-hoc enum where each case identifies one of the<br>&gt; possible types, and the value bound as that type. This works however because<br>&gt; there’s no ambiguity in the meaning; an (Int | String) is the same wherever<br>&gt; you use it, whereas a general-purpose ad-hoc enum is less clear, as an other<br>&gt; method might also take .Fit and .Fill values, but these may have a slightly<br>&gt; different meaning.<br>&gt;<br>&gt; So yeah, I like the idea in principle, but I think in practice it has too<br>&gt; many headaches to overcome for it to be as simple as it first appears =(<br>&gt;<br>&gt; On 31 May 2016, at 17:16, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Here&#39;s a function signature from some code from today:<br>&gt;<br>&gt; func scaleAndCropImage(<br>&gt; image: UIImage,<br>&gt; toSize size: CGSize,<br>&gt; fitImage: Bool = true<br>&gt; ) -&gt; UIImage {<br>&gt;<br>&gt;<br>&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;<br>&gt; func scaleAndCropImage(<br>&gt; image: UIImage,<br>&gt; toSize size: CGSize,<br>&gt; operation: (.Fit | .Fill) = .Fit<br>&gt; ) -&gt; UIImage {<br>&gt;<br>&gt;<br>&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc<br>&gt; enumeration-like semantics for the call. A while back, Yong hee Lee<br>&gt; introduced anonymous enumerations (and the possibility of anonymous option<br>&gt; flags) but the discussion rather died.<br>&gt;<br>&gt; I&#39;m bringing it up again to see whether there is any general interest in<br>&gt; pursuing this further as I think the second example is more readable,<br>&gt; appropriate, and Swifty than the first, provides better semantics, and is<br>&gt; more self documenting.<br>&gt;<br>&gt; Thanks for your feedback,<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  1, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 1, 2016, at 6:35 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Unions have been discussed earlier in this group and I personally<br>&gt; think this is an issue better solved using function overloading.<br>&gt; Despite this, I see how union types could be implemented (hint:<br>&gt; Optionals) but to use it in code would require you to, at least, test<br>&gt; for the type of the value at hand for the blocks of different code<br>&gt; between types. It feels like trying to bend a static typed language to<br>&gt; work a bit like a dynamic typed and while both have their pros and<br>&gt; cons I don&#39;t really think there is any benefit for the programmer and<br>&gt; the readability of the code in bending the type checker like this.<br></p><p>Unions are a specialized tool that should be used carefully and precisely.  That said, I have been uncovering several use cases where they are *exactly* what is needed.  Without them you end up with boilerplate of one kind or another.<br></p><p>&gt; <br>&gt; L<br>&gt; <br>&gt; On 1 June 2016 at 08:06, Haravikk via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I agree the second is much nicer, and a lot clearer on what each of the<br>&gt;&gt; options does; fitImage: true is pretty clear, but fitImage: false is not,<br>&gt;&gt; but the ad-hoc enum is clear on both counts. That said, the questions of<br>&gt;&gt; interoperability are a big issue for ad-hoc enums, as either they’re too<br>&gt;&gt; strict which becomes inconvenient (a .Fit | .Fill working with one method<br>&gt;&gt; but not another) or too relaxed to be safe. Of course, in the latter case<br>&gt;&gt; you’re replacing a Bool, which couldn’t be more relaxed in terms of where it<br>&gt;&gt; accepts values from.<br>&gt;&gt; <br>&gt;&gt; Still, I think in this case it would be better to fully-define an enum, as<br>&gt;&gt; it gives you total control over compatibility and reusability of the type,<br>&gt;&gt; which you can’t really with the ad-hoc form without making it overly<br>&gt;&gt; complex.<br>&gt;&gt; <br>&gt;&gt; The main type of ad-hoc enum I want to see is a union-type like so:<br>&gt;&gt; <br>&gt;&gt; func someMethod(value:(Int | String)) { … }<br>&gt;&gt; <br>&gt;&gt; This would basically be an ad-hoc enum where each case identifies one of the<br>&gt;&gt; possible types, and the value bound as that type. This works however because<br>&gt;&gt; there’s no ambiguity in the meaning; an (Int | String) is the same wherever<br>&gt;&gt; you use it, whereas a general-purpose ad-hoc enum is less clear, as an other<br>&gt;&gt; method might also take .Fit and .Fill values, but these may have a slightly<br>&gt;&gt; different meaning.<br>&gt;&gt; <br>&gt;&gt; So yeah, I like the idea in principle, but I think in practice it has too<br>&gt;&gt; many headaches to overcome for it to be as simple as it first appears =(<br>&gt;&gt; <br>&gt;&gt; On 31 May 2016, at 17:16, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a function signature from some code from today:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt; image: UIImage,<br>&gt;&gt; toSize size: CGSize,<br>&gt;&gt; fitImage: Bool = true<br>&gt;&gt; ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt; image: UIImage,<br>&gt;&gt; toSize size: CGSize,<br>&gt;&gt; operation: (.Fit | .Fill) = .Fit<br>&gt;&gt; ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc<br>&gt;&gt; enumeration-like semantics for the call. A while back, Yong hee Lee<br>&gt;&gt; introduced anonymous enumerations (and the possibility of anonymous option<br>&gt;&gt; flags) but the discussion rather died.<br>&gt;&gt; <br>&gt;&gt; I&#39;m bringing it up again to see whether there is any general interest in<br>&gt;&gt; pursuing this further as I think the second example is more readable,<br>&gt;&gt; appropriate, and Swifty than the first, provides better semantics, and is<br>&gt;&gt; more self documenting.<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback,<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June  1, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 1 Jun 2016, at 12:35, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; Unions have been discussed earlier in this group and I personally<br>&gt; think this is an issue better solved using function overloading.<br></p><p>Sorry, my intention wasn’t to debate them, I was just using them as an example of a specialised ad-hoc enum where compatibility isn’t an issue (because a union of the same types means the same thing everywhere you use it, which isn’t the case for general ad-hoc enums).<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 1:06 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree the second is much nicer, and a lot clearer on what each of the options does; fitImage: true is pretty clear, but fitImage: false is not, but the ad-hoc enum is clear on both counts. That said, the questions of interoperability are a big issue for ad-hoc enums, as either they’re too strict which becomes inconvenient (a .Fit | .Fill working with one method but not another) or too relaxed to be safe. Of course, in the latter case you’re replacing a Bool, which couldn’t be more relaxed in terms of where it accepts values from.<br>&gt; <br>&gt; Still, I think in this case it would be better to fully-define an enum, as it gives you total control over compatibility and reusability of the type, which you can’t really with the ad-hoc form without making it overly complex.<br>&gt; <br>&gt; The main type of ad-hoc enum I want to see is a union-type like so:<br>&gt; <br>&gt; 	func someMethod(value:(Int | String)) { … }<br>&gt; <br>&gt; This would basically be an ad-hoc enum where each case identifies one of the possible types, and the value bound as that type. This works however because there’s no ambiguity in the meaning; an (Int | String) is the same wherever you use it, whereas a general-purpose ad-hoc enum is less clear, as an other method might also take .Fit and .Fill values, but these may have a slightly different meaning.<br>&gt; <br>&gt; So yeah, I like the idea in principle, but I think in practice it has too many headaches to overcome for it to be as simple as it first appears =(<br>&gt; <br>&gt;&gt; On 31 May 2016, at 17:16, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a function signature from some code from today:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     fitImage: Bool = true<br>&gt;&gt;     ) -&gt; UIImage {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt;&gt; <br>&gt;&gt; func scaleAndCropImage(<br>&gt;&gt;     image: UIImage,<br>&gt;&gt;     toSize size: CGSize,<br>&gt;&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;&gt;     ) -&gt; UIImage {<br></p><p>I think it is a very reasonable proposal that does not violate the language.<br></p><p>Enums are nominal types, so what makes them unique is their names. It means that the name CANNOT be RANDOMLY generated... But it does not mean that the name cannot be meaningfully generated... So it is perfectly reasonable for the compiler to behave like a beginer programmer might and go through a naive but predictable heuristic to derive a semantically meaningful unique name:<br></p><p>Public enum enum_Fit_OR_Fill {<br>    case Fit<br>    case Fill<br>}<br></p><p>The prefix may not even be required. There is no chance that the name would wind up colliding with something done manually, and fixing the declaration to be systematically done at the module level would ensure clear visibility. The method signature would also be clean with &quot;operation&quot; exposed as:<br>    operation: enum_Fit_OR_Fill<br></p><p>To deal with milti site definition, the compiler would simply flag a error/warning, or be silent in the presence of a new annotation:<br></p><p>@strawman_use_synthesised_enum func scaleAndCropImage(....)<br></p><p>This would indicate that we acknowledge taking full responsibility for avoiding name collisions<br></p><p>To be more defensive, there could be a rule stating that these cannot be exported from modules (basically cannot be API). This is nothing more than a simple exercise of syntax sugaring...<br></p><p>Now having said that, if I recall, chris was clear that sugaring in NOT for 3.0<br></p><p><br>&gt;&gt; <br>&gt;&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt;&gt; <br>&gt;&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback,<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/fd02eeff/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Ad hoc enums / options</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  2, 2016 at 12:00:00am</p></header><div class="content"><p>Lots of people have added their 2¢ now, you probably have about 10 dollars worth, but here goes.<br></p><p>While it looks nice and short, I think it has a range of drawbacks:<br>- It’s not a real type that can participate in protocols or extensions.<br>- Discourages DRY coding, because some people will think they are taking the easy way out, and even copy and paste this same declaration multiple times.<br>- Encourages adding subtypes to functions instead of types. Swift seems primarily type-focused more than function-focused. I remember seeing someone write their solution as an extension to UIImage, which was a nice way to do it. This subtype would be best conceptually as UIImage.FitOperation (use with multiple methods!) not scaleAndCropImage.Operation (use once!)<br></p><p>The beauty of Swift is that you can add methods to value types. This opens up interesting, more reusable solutions such as:<br></p><p><br>enum ContentFit {<br>  case fit<br>  case fill<br>  <br>  func adjust(size contentSize: CGSize, within bounds: CGRect) -&gt; CGRect {<br>    let (widthFactor, heightFactor) = (bounds.size.width / contentSize.width, bounds.size.height / contentSize.height)<br>    let scaleFactor: CGFloat<br>    switch self {<br>    case .fit: scaleFactor = min(widthFactor, heightFactor)<br>    case .fill: scaleFactor = max(widthFactor, heightFactor)<br>    }<br>    <br>    let adjustedSize = CGSize(width: contentSize.width * scaleFactor, height: contentSize.height * scaleFactor)<br>    let adjustedOrigin = CGPoint(x: (bounds.size.width - adjustedSize.width) / 2.0, y: (bounds.size.height - adjustedSize.height) / 2.0)<br>    return CGRect(origin: adjustedOrigin, size: adjustedSize)<br>  }<br>}<br></p><p><br>That way you break functions up into smaller chunks, while also making the types more useful in themselves.<br></p><p>(For context, Erica’s original post is here: http://ericasadun.com/2016/05/31/swift-rewrite-challenge/ &lt;http://ericasadun.com/2016/05/31/swift-rewrite-challenge/&gt;)<br></p><p>Patrick<br></p><p>&gt; On 1 Jun 2016, at 2:16 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here&#39;s a function signature from some code from today:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     fitImage: Bool = true<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; And here&#39;s what I want the function signature to actually look like:<br>&gt; <br>&gt; func scaleAndCropImage(<br>&gt;     image: UIImage,<br>&gt;     toSize size: CGSize,<br>&gt;     operation: (.Fit | .Fill) = .Fit<br>&gt;     ) -&gt; UIImage {<br>&gt; <br>&gt; <br>&gt; where I don&#39;t have to establish a separate enumeration to include ad-hoc enumeration-like semantics for the call. A while back, Yong hee Lee introduced anonymous enumerations (and the possibility of anonymous option flags) but the discussion rather died.<br>&gt; <br>&gt; I&#39;m bringing it up again to see whether there is any general interest in pursuing this further as I think the second example is more readable, appropriate, and Swifty than the first, provides better semantics, and is more self documenting.<br>&gt; <br>&gt; Thanks for your feedback,<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/32155d64/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
