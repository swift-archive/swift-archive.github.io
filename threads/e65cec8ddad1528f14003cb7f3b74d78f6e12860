<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/04e39d45455f95ce6dc18e918d18c2ad?s=50"></div><header><strong>Proposal: Add a Future type to the language</strong> from <string>Thomas Visser</string> &lt;thomas.visser at gmail.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>Futures (aka Promises) are a well known concept that aid in writing asynchronous code. I’d love to have a Future type that comes with the language.<br></p><p>The way I’d see this work is similar to how Optionals are currently implemented. There’d be a Future&lt;T&gt; type in the standard library, but most developers will choose not to use it directly. Instead, there are some new keywords and syntactic sugar that make it easy to work with the Future concept.<br></p><p>There’d be a new ‘async’ keyword indicating that a type (including return type) is asynchronous:<br></p><p>func blurImage(image: UIImage, radius: Int) -&gt; async UIImage {<br>	var blurredImage: async UIImage<br>	dispatch_async(globalQueue) {<br>		blurredImage = // expensive blur operation<br>	}<br>	return blurredImage<br>}<br></p><p>At the origin of an asynchronous value is something like GCD to actually execute the work on a different thread. (This is not the responsibility of the Future.)<br></p><p>An async type should largely just work like its ‘regular’ synchronous counterpart. The compiler would be able to generate code for methods on that type (e.g. hasPrefix(_:) on an async string returns an async Bool) or methods (including operators) that take that type as a parameter (E.g. concatenating two async strings should be as easy as: string1 + string2).<br></p><p>To unwrap a Future, i.e. getting its value, for cases that do not accept asynchronous values (e.g. UI updates), there’d be a new ‘when let’ statement with a control flow that is similar to the guard statement:<br></p><p>when let image = blurImage(image) else {<br>	throw ImageBlurringFailed()<br>}<br></p><p>imageView.image = image<br></p><p>This is all very brief, but should give you an idea of my proposal. You can find more details in a blog post I wrote recently: http://www.thomasvisser.me/2015/11/26/async-swift/. This description is probably rather simplistic compared to the work needed to actually support something like this, but I hope it can serve as a starting point.<br></p><p>Context:<br>- There is a proposal by Nadav Rotem from September 2015 that describes a lot of the foundational work that would have to be done before we can have a safe Future type: https://github.com/apple/swift/blob/5eaa3c43d069d5bd401e7879b43f6290823d180d/docs/proposals/Concurrency.rst. While I think a Future type could exist without language support for concurrency (e.g. using GCD directly, see https://github.com/Thomvis/BrightFutures, full disclosure: I wrote that library), I agree it makes a lot of sense to only do it once it can be done in a safe way.<br>- There are other concepts that have to do with asynchronous programming such as channels/signals/observables (Rx) and goroutines. I think there’s a place &amp; audience for more than one of these concepts in Swift, but these efforts should of course be coordinated.<br></p><p>I realize this is not in scope for Swift 3, but I’d love to get feedback from the community and hear how it can be incorporated in the discussion when concurrency will be on the agenda (for Swift 4 perhaps)?<br></p><p>Best,<br>Thomas Visser<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>Proposal: Add a Future type to the language</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>December 22, 2015 at 12:00:00pm</p></header><div class="content"><p>Like you mentioned, the Swift team has made it very clear that concurrency is out of scope for Swift 3, and we probably won’t see it until at least Swift 4 at a bare minimum.  That said, while your proposal is a much better alternative to the completion handler pyramids of doom we have today, I’ve personally never been a huge fan of Futures from an intuitiveness standpoint.  I would much rather see the language adopt something more akin to C#’s Async-Await, where the compiler handles restructuring synchronous-looking code into something asynchronous and non-blocking.<br></p><p>I guess in my perfect world, the following Swift 2 code:<br></p><p>func bar(completionHandler : (Int) -&gt; Void) -&gt; Void {<br>	dispatch_after( dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC * 1), dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0 ) ) {<br>		completionHandler(42)<br>	}<br>}<br></p><p>func barPlusBar(completionHandler : (Int) -&gt; Void) -&gt; Void {<br>	var barResult = 0<br></p><p>	bar() { (let result) -&gt; Void in<br>		barResult += result<br></p><p>		bar() { (let result) -&gt; Void in<br>			barResult += result<br>			completionHandler( barResult )<br>		}<br>	}<br>}<br></p><p>func foo() -&gt; Void {<br>	barPlusBar() { (let result) in<br>		print( result )<br>	}<br>}<br></p><p>would be replaced (and perhaps even become more optimizable) with:<br></p><p>async func bar() -&gt; Int {<br>	after( NSEC_PER_SEC * 1 )<br>	return 42<br>}<br></p><p>async func barPlusBar() -&gt; Int {<br>	return bar() + bar()<br>}<br></p><p>func foo() -&gt; Void {<br>	async {<br>		print( barPlusBar() )<br>	}<br>}<br></p><p><br>Again, this is pretty much all moot right now as the Swift team has much bigger fish to fry, but it sure is nice to dream.<br></p><p>Dan<br></p><p>&gt; On Dec 22, 2015, at 2:48 AM, Thomas Visser via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Futures (aka Promises) are a well known concept that aid in writing asynchronous code. I’d love to have a Future type that comes with the language.<br>&gt; <br>&gt; The way I’d see this work is similar to how Optionals are currently implemented. There’d be a Future&lt;T&gt; type in the standard library, but most developers will choose not to use it directly. Instead, there are some new keywords and syntactic sugar that make it easy to work with the Future concept.<br>&gt; <br>&gt; There’d be a new ‘async’ keyword indicating that a type (including return type) is asynchronous:<br>&gt; <br>&gt; func blurImage(image: UIImage, radius: Int) -&gt; async UIImage {<br>&gt; 	var blurredImage: async UIImage<br>&gt; 	dispatch_async(globalQueue) {<br>&gt; 		blurredImage = // expensive blur operation<br>&gt; 	}<br>&gt; 	return blurredImage<br>&gt; }<br>&gt; <br>&gt; At the origin of an asynchronous value is something like GCD to actually execute the work on a different thread. (This is not the responsibility of the Future.)<br>&gt; <br>&gt; An async type should largely just work like its ‘regular’ synchronous counterpart. The compiler would be able to generate code for methods on that type (e.g. hasPrefix(_:) on an async string returns an async Bool) or methods (including operators) that take that type as a parameter (E.g. concatenating two async strings should be as easy as: string1 + string2).<br>&gt; <br>&gt; To unwrap a Future, i.e. getting its value, for cases that do not accept asynchronous values (e.g. UI updates), there’d be a new ‘when let’ statement with a control flow that is similar to the guard statement:<br>&gt; <br>&gt; when let image = blurImage(image) else {<br>&gt; 	throw ImageBlurringFailed()<br>&gt; }<br>&gt; <br>&gt; imageView.image = image<br>&gt; <br>&gt; This is all very brief, but should give you an idea of my proposal. You can find more details in a blog post I wrote recently: http://www.thomasvisser.me/2015/11/26/async-swift/. This description is probably rather simplistic compared to the work needed to actually support something like this, but I hope it can serve as a starting point.<br>&gt; <br>&gt; Context:<br>&gt; - There is a proposal by Nadav Rotem from September 2015 that describes a lot of the foundational work that would have to be done before we can have a safe Future type: https://github.com/apple/swift/blob/5eaa3c43d069d5bd401e7879b43f6290823d180d/docs/proposals/Concurrency.rst. While I think a Future type could exist without language support for concurrency (e.g. using GCD directly, see https://github.com/Thomvis/BrightFutures, full disclosure: I wrote that library), I agree it makes a lot of sense to only do it once it can be done in a safe way.<br>&gt; - There are other concepts that have to do with asynchronous programming such as channels/signals/observables (Rx) and goroutines. I think there’s a place &amp; audience for more than one of these concepts in Swift, but these efforts should of course be coordinated.<br>&gt; <br>&gt; I realize this is not in scope for Swift 3, but I’d love to get feedback from the community and hear how it can be incorporated in the discussion when concurrency will be on the agenda (for Swift 4 perhaps)?<br>&gt; <br>&gt; Best,<br>&gt; Thomas Visser<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/7e9d6364/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/04e39d45455f95ce6dc18e918d18c2ad?s=50"></div><header><strong>Proposal: Add a Future type to the language</strong> from <string>Thomas Visser</string> &lt;thomas.visser at gmail.com&gt;<p>December 22, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; I would much rather see the language adopt something more akin to C#’s Async-Await, where the compiler handles restructuring synchronous-looking code into something asynchronous and non-blocking.<br></p><p>Agreed. The ‘when let’ syntax in my ‘proposal’ is a play on C#’s await. I think it’d be great if the compiler could turn that into code that uses the Future type to achieve said asynchronous and non-blocking behavior.<br></p><p>Thomas<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
