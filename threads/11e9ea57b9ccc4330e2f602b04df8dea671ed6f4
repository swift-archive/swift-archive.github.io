<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>March  4, 2016 at 04:00:00am</p></header><div class="content"><p>On 2016-03-03 16:25:45 +0000, Dave Abrahams via swift-evolution said:<br>&gt; <br>&gt; on Tue Mar 01 2016, Károly Lőrentey &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; This looks interesting! As the author of a number of custom collection<br>&gt;&gt; implementations, including a rather elaborate B-tree package<br>&gt;&gt; (https://github.com/lorentey/BTree),<br>&gt; <br>&gt; FWIW, I am impressed by (even jealous of) this work, so your feedback in<br>&gt; this area is much appreciated.<br></p><p>Why thank you. *blush*<br></p><p>&gt; One thing that hasn&#39;t been mentioned so far is that when the algorithms<br>&gt; using indices are extensions on the collection protocol (or members of a<br>&gt; specific collection) these APIs can be used without qualification, which<br>&gt; makes them read like free functions, which ends up looking quite natural<br>&gt; to my eye.<br></p><p>Nice!<br></p><p>&gt;&gt; - I know that it isn&#39;t a new requirement, but I do dislike that<br>&gt;&gt; `Indexable` specifies the complexity of index operations; this puts<br>&gt;&gt; a hard constraint on custom collection design. I do understand the<br>&gt;&gt; desire for concrete complexity promises on operations using<br>&gt;&gt; indexes, but can&#39;t we express these instead e.g. in terms of number<br>&gt;&gt; of index accesses?<br>&gt; <br>&gt; The problem is that eventually it becomes really difficult to simply<br>&gt; describe the efficiency of any given algorithm.  We don&#39;t want people to<br>&gt; have to do complex algebra to understand how algorithms compose with<br>&gt; data structures.<br>&gt; <br>&gt; Yes, it&#39;s a trade-off, and loosening the upper bound on the cost of<br>&gt; indexing was one of the things we considered.  We tried to carefully<br>&gt; think through different possible collection designs (trees in<br>&gt; particular!) to understand what the implications of keeping the O(1)<br>&gt; upper bound were.  We&#39;d be happy to discuss specific tradeoffs with you.<br></p><p>That&#39;s fair! So far, I&#39;ve always been able to implement constant access,<br>and the code has only become better of it.<br></p><p>The only place where I intentionally decided against it is the tree-backed,<br>Array-like `List`. It really wants to be indexed by an Int, to emulate<br>Array&#39;s loose approach to index invalidation. (Although, like you said,<br>B-tree lookup is practically O(1) anyway, so maybe I&#39;ll just call it that.)<br></p><p><br>This reminds me that index invalidation rules are all over the place across<br>the various collection types and not very well documented. Some ideas for<br>improvements:<br></p><p>- From the sample code in its documentation, it looks like<br>  `MutableCollection` requires subscript assignment to not invalidate<br>  indices. Can we make this a formal requirement?<br>- What about range assignment in `MutableCollection`? E.g., what happens<br>  to indices if it changes the element count? (Is supporting that a <br>requirement?)<br>- Does `RangeReplacableCollection` imply Array-like index invalidation?<br>  I think it should.<br></p><p>By the way, does the requirement for (amortized) constant complexity also<br>apply to advancing an index? That&#39;s OK for trees, but it may not come cheap<br>for hashed collections. Native dictionaries &amp; sets currently have an<br>index.successor() with O(n) complexity (if I&#39;m not mistaken).<br></p><p>What about `Collection.indices`? Getting the first index will definitely<br>take O(log(n)) for tree collections, and bridged dictionaries/sets have<br>this at O(n).<br></p><p>&gt;&gt; - I&#39;m using weak references inside the index, with a (seriously<br>&gt;&gt; underdeveloped) index invalidation method that happens to be closer<br>&gt;&gt; to #2b than #2a. I&#39;m not happy about using weak references, but this<br>&gt;&gt; seemed the most sensible thing to do. I&#39;d love to replace them with<br>&gt;&gt; `unowned(unsafe)`, and the mutation counter seems like a great idea.<br>&gt;&gt; The ARC issue mentioned at the end of the proposal is rather scary,<br>&gt;&gt; though -- I don&#39;t know how I would protect against that.<br>&gt; <br>&gt; Hmm, Dmitri, I thought we decided that using unowned(unsafe) to manage<br>&gt; the &quot;indices&quot; collection was simply untenable.  Remember the<br>&gt; thread-safety issue, iterating indices on one thread while mutating the<br>&gt; collection on another?<br></p><p>Hm, aren&#39;t multithreaded mutations supposed to use COW to get their own<br>copy to mutate?<br></p><p>Or is this about invalidation of the return value of `Collection.indices`?<br>That&#39;s not supposed to survive (all) mutations, is it?<br></p><p>(Ugh, how do I refer to an instance of Indices (the associated type) without<br>confusing it with indices in the sense of multiple `Index`es?)<br></p><p>&gt;&gt; - I&#39;m almost positive this has been discussed before, but what is the<br>&gt;&gt; rationale behind allowing non-Int `IndexDistance`s?<br>&gt; <br>&gt; One could imagine indexing a file-backed thing on a 32-bit platform,<br>&gt; which could require 64-bit distances.<br></p><p>Ah, OK! But it begs the question: would a file-backed collection be able<br>to satisfy the O(1) indexing requirement without making a complete<br>mockery of it? :-)<br></p><p>&gt;&gt; The distance is getting cast to Int in a lot of places anyway (IIRC,<br>&gt;&gt; even the stdlib uses numericCasts to cut a way through it.)<br>&gt; <br>&gt; We&#39;ve tried to be careful enough in balancing ease-of-use (Int<br>&gt; almost everywhere) with flexibility, but we might have made mistakes,<br>&gt; for sure.<br></p><p>I think the largest speed bump there is that sequences and collections<br>are often loaded into Arrays, and an oversized collection would have to<br>tread very carefully to avoid all of these places. The API is geared<br>towards finite (and relatively small-ish) collections/sequences.<br>I suspect a Collection with a billion elements wouldn&#39;t work much better<br>than an infinite sequence.<br></p><p>&gt;&gt; - In this declaration:<br>&gt;&gt; <br>&gt;&gt; subscript(position: Index) -&gt; Generator.Element { get }<br>&gt;&gt; <br>&gt;&gt; I find the argument name rather unfortunate, because I&#39;ve been using<br>&gt;&gt; the term &quot;position&quot; to consistently refer to the (numerical)<br>&gt;&gt; position of an element in an ordered collection,<br>&gt; <br>&gt; “Offset” would be a better name for that, IMO.<br></p><p>That&#39;s spot on! Although in some contexts it could be misunderstood to<br>mean a delta. I&#39;ll sleep on it, but I think you&#39;re right.<br></p><p>-- <br>Károly<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  3, 2016 at 08:00:00pm</p></header><div class="content"><p>On Thu, Mar 3, 2016 at 7:50 PM, Károly Lőrentey<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; This reminds me that index invalidation rules are all over the place across<br>&gt; the various collection types and not very well documented. Some ideas for<br>&gt; improvements:<br></p><p>You&#39;re right on!  We have a document, but it is incomplete, and it is<br>not a part of the public documentation of the library.<br></p><p>https://github.com/apple/swift/blob/master/docs/IndexInvalidation.rst<br></p><p>&gt; - From the sample code in its documentation, it looks like<br>&gt;  `MutableCollection` requires subscript assignment to not invalidate<br>&gt;  indices. Can we make this a formal requirement?<br></p><p>Yes, this is the intent.<br></p><p>&gt; - What about range assignment in `MutableCollection`? E.g., what happens<br>&gt;  to indices if it changes the element count? (Is supporting that a<br>&gt; requirement?)<br></p><p>A MutableCollection is not required to support assigning a range of a<br>different length.<br></p><p>&gt; - Does `RangeReplacableCollection` imply Array-like index invalidation?<br>&gt;  I think it should.<br></p><p>It does.  Might not be documented though, but it is tested in<br>StdilbCollectionUnittest with minimal collections (see<br>stdlib/private/StdlibCollectionUnittest/MinimalCollections.swift.gyb).<br></p><p>&gt; By the way, does the requirement for (amortized) constant complexity also<br>&gt; apply to advancing an index? That&#39;s OK for trees, but it may not come cheap<br>&gt; for hashed collections. Native dictionaries &amp; sets currently have an<br>&gt; index.successor() with O(n) complexity (if I&#39;m not mistaken).<br></p><p>They only do because they don&#39;t shrink the storage on deletion.  If<br>they could shrink the storage to maintain the load factor, then<br>advancing an index once, amortized over advancing it through the<br>entire hashtable would be O(1).<br></p><p>&gt; What about `Collection.indices`? Getting the first index will definitely<br>&gt; take O(log(n)) for tree collections, and bridged dictionaries/sets have<br>&gt; this at O(n).<br></p><p>For bridged dictionaries/sets, yes, but we are planning to fix that.<br>Our thought was that it was bidirectional indices that required to<br>store the array of keys, but we have downgraded the indices to be<br>forward-only, which can be implemented with NSFastEnumeration.  I<br>could be still overlooking some other reason why we need the array of<br>keys.<br></p><p>For trees though, it seems that you are right.<br></p><p>&gt;&gt;&gt; - I&#39;m using weak references inside the index, with a (seriously<br>&gt;&gt;&gt; underdeveloped) index invalidation method that happens to be closer<br>&gt;&gt;&gt; to #2b than #2a. I&#39;m not happy about using weak references, but this<br>&gt;&gt;&gt; seemed the most sensible thing to do. I&#39;d love to replace them with<br>&gt;&gt;&gt; `unowned(unsafe)`, and the mutation counter seems like a great idea.<br>&gt;&gt;&gt; The ARC issue mentioned at the end of the proposal is rather scary,<br>&gt;&gt;&gt; though -- I don&#39;t know how I would protect against that.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hmm, Dmitri, I thought we decided that using unowned(unsafe) to manage<br>&gt;&gt; the &quot;indices&quot; collection was simply untenable.  Remember the<br>&gt;&gt; thread-safety issue, iterating indices on one thread while mutating the<br>&gt;&gt; collection on another?<br>&gt;<br>&gt;<br>&gt; Hm, aren&#39;t multithreaded mutations supposed to use COW to get their own<br>&gt; copy to mutate?<br></p><p>They can only do so if all independent values hold a strong reference<br>to the storage.<br></p><p>&gt; Or is this about invalidation of the return value of `Collection.indices`?<br>&gt; That&#39;s not supposed to survive (all) mutations, is it?<br></p><p>Sorry, I don&#39;t quite understand the second question, but yes, this is<br>related to `.indices`.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
