<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed316d3a58253c2d51b67b1ed906bf5?s=50"></div><header><strong>Static linking</strong> from <string>David Beck</string> &lt;swift at tnku.co&gt;<p>June 18, 2016 at 08:00:00am</p></header><div class="content"><p>In session 406: optimizing app startup time at WWDC, most of the recommendations were very pro Swift. Things like using structs and the fact that it can automatically inline calls. One recommendation that was very anti swift, was the section on limiting dylibs. The presenter recommended keeping it to under 6. I’m not sure if the 15 libswift dylibs that get included by default in a Swift application count towards that (he did mention that Apple frameworks are optimized, but I’m not sure if that is limited to the ones preinstalled on the device).<br></p><p>His recommendation was to use static libraries, which makes sense, except that Swift on iOS doesn’t seem to support static linking. But for whatever reason, Swift PM ONLY supports static linking. Is there any plans to add static linking to Mac and iOS apps? The only alternative I see at this point is to simply include the source files from libraries in the app’s target, but Swift has from the beginning encouraged naming things generically and relying on modules for name spacing.<br></p><p>David Beck<br>http://davidbeck.co<br>http://twitter.com/davbeck<br>http://facebook.com/davbeck<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160618/d8b9b9db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Static linking</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>June 18, 2016 at 02:00:00pm</p></header><div class="content"><p>In regards to Mac and iOS apps, the dylibs are included because of the lack of ABI stability, which was a goal for Swift 3 that was pushed back due to the really significant changes that occurred in the language.<br></p><p>From what I understand, these dylibs are very light and simply act as binding between the actual frameworks and your code, rather than being their own code. Thus, I expect they’re as heavily optimised as they can be, and are relatively light impact. They were more discussing true frameworks and libraries.<br></p><p>I don’t have any official evidence of this and it’d be something I’d love to get an official comment on too, but this would be my understanding. Also, if they were a significant hit I would have expected them to mention it while they were throwing around their pro-Swift recommendations, as a caveat.<br></p><p><br>&gt; On 18 Jun 2016, at 8:41 AM, David Beck via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; In session 406: optimizing app startup time at WWDC, most of the recommendations were very pro Swift. Things like using structs and the fact that it can automatically inline calls. One recommendation that was very anti swift, was the section on limiting dylibs. The presenter recommended keeping it to under 6. I’m not sure if the 15 libswift dylibs that get included by default in a Swift application count towards that (he did mention that Apple frameworks are optimized, but I’m not sure if that is limited to the ones preinstalled on the device).<br>&gt; <br>&gt; His recommendation was to use static libraries, which makes sense, except that Swift on iOS doesn’t seem to support static linking. But for whatever reason, Swift PM ONLY supports static linking. Is there any plans to add static linking to Mac and iOS apps? The only alternative I see at this point is to simply include the source files from libraries in the app’s target, but Swift has from the beginning encouraged naming things generically and relying on modules for name spacing.<br>&gt; <br>&gt; David Beck<br>&gt; http://davidbeck.co &lt;http://davidbeck.co/&gt;<br>&gt; http://twitter.com/davbeck &lt;http://twitter.com/davbeck&gt;<br>&gt; http://facebook.com/davbeck &lt;http://facebook.com/davbeck&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160618/1fe45d4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc8eae356a7d359691154094ae6d56a7?s=50"></div><header><strong>Static linking</strong> from <string>Marco S Hyman</string> &lt;marc at snafu.org&gt;<p>June 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 18, 2016, at 2:55 PM, Rod Brown via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; From what I understand, these dylibs are very light <br></p><p>Not always so light as earlier discussed on this list.   An Xcode 8 Swift 3 compile shows swift Frameworks taking 9.2 MB of the 11.5 MB total app size for an OS X app I’m working with.<br></p><p>The code portion of this small app is less than .5 MB.   Resources are about 1.5 MB.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Static linking</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>June 18, 2016 at 09:00:00pm</p></header><div class="content"><p>Sorry, by light I was referring to the work required to process these dylibs. Not the actual size of them. From what I know they’re not directionally proportional.<br></p><p><br>&gt; On 18 Jun 2016, at 3:14 PM, Marco S Hyman &lt;marc at snafu.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 18, 2016, at 2:55 PM, Rod Brown via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From what I understand, these dylibs are very light <br>&gt; <br>&gt; Not always so light as earlier discussed on this list.   An Xcode 8 Swift 3 compile shows swift Frameworks taking 9.2 MB of the 11.5 MB total app size for an OS X app I’m working with.<br>&gt; <br>&gt; The code portion of this small app is less than .5 MB.   Resources are about 1.5 MB.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eed316d3a58253c2d51b67b1ed906bf5?s=50"></div><header><strong>Static linking</strong> from <string>David Beck</string> &lt;swift at tnku.co&gt;<p>June 20, 2016 at 08:00:00am</p></header><div class="content"><p>This morning I used the DYLD_PRINT_STATISTICS environment variable that was recommended in the session (I couldn’t get it to work on an iOS device, so these are numbers from the simulator). “Cold” refers to launching the app after a restart to make sure that the libraries aren’t already in memory and “hot” is when the app has been run recently. I created 2 basic iOS projects, one Swift and the other ObjC, using the empty view template, and changing nothing except the environment variable. I ran this experiment a few times over for all 4 scenarios, and these are typical results.<br></p><p>Swift:<br>Cold:<br>Total pre-main time: 140.49 milliseconds (100.0%)<br>         dylib loading time:  49.29 milliseconds (35.0%)<br>        rebase/binding time:  15.57 milliseconds (11.0%)<br>            ObjC setup time:  50.73 milliseconds (36.1%)<br>           initializer time:  24.72 milliseconds (17.5%)<br>           slowest intializers :<br>               libSystem.dylib :   7.22 milliseconds (5.1%)<br>   libBacktraceRecording.dylib :   8.49 milliseconds (6.0%)<br>                CoreFoundation :   3.41 milliseconds (2.4%)<br>                    Foundation :   4.42 milliseconds (3.1%)<br>Hot:<br>Total pre-main time:  63.33 milliseconds (100.0%)<br>         dylib loading time:  27.78 milliseconds (43.8%)<br>        rebase/binding time:  11.38 milliseconds (17.9%)<br>            ObjC setup time:  13.25 milliseconds (20.9%)<br>           initializer time:  10.83 milliseconds (17.1%)<br>           slowest intializers :<br>               libSystem.dylib :   2.46 milliseconds (3.8%)<br>   libBacktraceRecording.dylib :   4.84 milliseconds (7.6%)<br>                    Foundation :   1.52 milliseconds (2.4%)<br></p><p>ObjC:<br>Cold:<br>Total pre-main time: 133.77 milliseconds (100.0%)<br>         dylib loading time:  43.62 milliseconds (32.6%)<br>        rebase/binding time:  14.08 milliseconds (10.5%)<br>            ObjC setup time:  51.98 milliseconds (38.8%)<br>           initializer time:  23.88 milliseconds (17.8%)<br>           slowest intializers :<br>               libSystem.dylib :   6.52 milliseconds (4.8%)<br>   libBacktraceRecording.dylib :   7.93 milliseconds (5.9%)<br>                CoreFoundation :   3.89 milliseconds (2.9%)<br>                    Foundation :   4.32 milliseconds (3.2%)<br>Hot:<br>Total pre-main time:  55.55 milliseconds (100.0%)<br>         dylib loading time:  21.90 milliseconds (39.4%)<br>        rebase/binding time:  11.30 milliseconds (20.3%)<br>            ObjC setup time:  12.92 milliseconds (23.2%)<br>           initializer time:   9.34 milliseconds (16.8%)<br>           slowest intializers :<br>               libSystem.dylib :   2.98 milliseconds (5.3%)<br>   libBacktraceRecording.dylib :   3.52 milliseconds (6.3%)<br>                CoreFoundation :   1.23 milliseconds (2.2%)<br>                    Foundation :   1.15 milliseconds (2.0%)<br></p><p>Keep in mind that the recommended startup time is 400ms. The Swift standard libraries never show up in slowest initializers, but something does seem to be slowing the Swift startup time down at least a little, but not by a significant amount. My conclusion would be that the Swift libs are indeed optimized and shouldn’t be a major concern.<br></p><p>However, my bigger concern was in an app that has 3rd party dependencies (like my own). I’m looking at a 700ms pre-main time, with all my Carthage dependencies showing up in the slowest initializers list. While some of them could be refactored out, others are either non-simple, or for a service we use such as analytics. I’m curious how we can optimize the launch time of a Swift app that uses 3rd party frameworks, since iOS doesn’t support static linking of Swift code.<br></p><p>Interestingly, Crashlytics uses a framework, with a module map, that can be used by Swift code directly, but the binary is a static lib that doesn’t need to be embedded. I wonder how they created that...<br></p><p>David Beck<br>http://davidbeck.co<br>http://twitter.com/davbeck<br>http://facebook.com/davbeck<br></p><p>&gt; On Jun 18, 2016, at 8:41 AM, David Beck &lt;swift at tnku.co&gt; wrote:<br>&gt; <br>&gt; In session 406: optimizing app startup time at WWDC, most of the recommendations were very pro Swift. Things like using structs and the fact that it can automatically inline calls. One recommendation that was very anti swift, was the section on limiting dylibs. The presenter recommended keeping it to under 6. I’m not sure if the 15 libswift dylibs that get included by default in a Swift application count towards that (he did mention that Apple frameworks are optimized, but I’m not sure if that is limited to the ones preinstalled on the device).<br>&gt; <br>&gt; His recommendation was to use static libraries, which makes sense, except that Swift on iOS doesn’t seem to support static linking. But for whatever reason, Swift PM ONLY supports static linking. Is there any plans to add static linking to Mac and iOS apps? The only alternative I see at this point is to simply include the source files from libraries in the app’s target, but Swift has from the beginning encouraged naming things generically and relying on modules for name spacing.<br>&gt; <br>&gt; David Beck<br>&gt; http://davidbeck.co &lt;http://davidbeck.co/&gt;<br>&gt; http://twitter.com/davbeck &lt;http://twitter.com/davbeck&gt;<br>&gt; http://facebook.com/davbeck &lt;http://facebook.com/davbeck&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160620/bcbd174d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
