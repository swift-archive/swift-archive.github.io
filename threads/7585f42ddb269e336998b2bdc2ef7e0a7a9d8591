<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 17, 2016 at 07:00:00pm</p></header><div class="content"><p>Hello all,<br></p><p>I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br></p><p>Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br></p><p>let set = OrderedSet&lt;Int&gt;()<br>// error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>// Found this candidate: Foundation.OrderedSet:3:14<br>// Found this candidate: BTree.OrderedSet:12:15<br>To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br></p><p>let set = BTree.OrderedSet&lt;Int&gt;()<br>// error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br></p><p>I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br></p><p>Prevent modules from containing a type with the same name<br>Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br></p><p>Thoughts?<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/75858591/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 20, 2016 at 09:00:00am</p></header><div class="content"><p>If no one has anything to say, I&#39;ll be starting a proposal to introduce the _.Module.Type syntax.<br></p><p>Félix<br></p><p>&gt; Le 17 juin 2016 à 19:52:45, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt; <br>&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt; <br>&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt; <br>&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt; <br>&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt; <br>&gt; Prevent modules from containing a type with the same name<br>&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/9d16f109/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m not sure that `_.` reads very well; it rather seems to denote that<br>there is no module name.<br></p><p>The most conservative change would be to prohibit module names that collide<br>with a contained (public) type. If, later, this is found to be unduly<br>restrictive, another syntax can be designed and added. I don&#39;t believe it<br>is a commonly seen design pattern, though, is it?<br></p><p>On Mon, Jun 20, 2016 at 11:16 Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; If no one has anything to say, I&#39;ll be starting a proposal to introduce<br>&gt; the _.Module.Type syntax.<br>&gt;<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 17 juin 2016 à 19:52:45, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; Hello all,<br>&gt;<br>&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that<br>&gt; leaves me unable to fully-qualify the name of a type. If you import a<br>&gt; module named Foo that also contains a type named Foo, attempts to<br>&gt; fully-qualify any name in the Foo module will instead attempt to find<br>&gt; something inside the Foo type. This bug has already been reported<br>&gt; &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;<br>&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains<br>&gt; a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;<br>&gt; let set = OrderedSet&lt;Int&gt;()// error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context// Found this candidate: Foundation.OrderedSet:3:14// Found this candidate: BTree.OrderedSet:12:15<br>&gt;<br>&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift<br>&gt; thinks that BTree is the BTree type, not the BTree module:<br>&gt;<br>&gt; let set = BTree.OrderedSet&lt;Int&gt;()// error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;<br>&gt; Any fix will require a change to the language, and as Jordan Rose stated<br>&gt; on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and<br>&gt; discuss possible solutions.<br>&gt;<br>&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe<br>&gt; that this needs to be resolved):<br>&gt;<br>&gt;<br>&gt;    - Prevent modules from containing a type with the same name<br>&gt;    - Allow modules to be imported under different names (`import BTree as<br>&gt;    BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;    - Create a new syntax that indicates that you&#39;re naming a module, not<br>&gt;    a type (like `_.BTree.OrderedSet`)<br>&gt;<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/f2c1a2a9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 20, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;d like to suggest such alternative syntax to mention in your proposal:<br></p><p>Module::Type<br></p><p><br>On 20.06.2016 19:16, Félix Cloutier via swift-evolution wrote:<br>&gt; If no one has anything to say, I&#39;ll be starting a proposal to introduce the<br>&gt; _.Module.Type syntax.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt;&gt; Le 17 juin 2016 à 19:52:45, Félix Cloutier via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Hello all,<br>&gt;&gt;<br>&gt;&gt; I recently ran into a bug<br>&gt;&gt; &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to<br>&gt;&gt; fully-qualify the name of a type. If you import a module named Foo that<br>&gt;&gt; also contains a type named Foo, attempts to fully-qualify any name in the<br>&gt;&gt; Foo module will instead attempt to find something inside the Foo type.<br>&gt;&gt; This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt;<br>&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also<br>&gt;&gt; contains a BTree type) that I encountered while trying to use the<br>&gt;&gt; OrderedSet type:<br>&gt;&gt;<br>&gt;&gt; |letset=OrderedSet&lt;Int&gt;()// error: &#39;OrderedSet&#39; is ambiguous for type<br>&gt;&gt; lookup in this context// Found this candidate:<br>&gt;&gt; Foundation.OrderedSet:3:14// Found this candidate: BTree.OrderedSet:12:15|<br>&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift<br>&gt;&gt; thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;<br>&gt;&gt; |letset=BTree.OrderedSet&lt;Int&gt;()// error: reference to generic type &#39;BTree&#39;<br>&gt;&gt; requires arguments in &lt;...&gt;|<br>&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated<br>&gt;&gt; on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and<br>&gt;&gt; discuss possible solutions.<br>&gt;&gt;<br>&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe<br>&gt;&gt; that this needs to be resolved):<br>&gt;&gt;<br>&gt;&gt;   * Prevent modules from containing a type with the same name<br>&gt;&gt;   * Allow modules to be imported under different names (`import BTree as<br>&gt;&gt;     BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;   * Create a new syntax that indicates that you&#39;re naming a module, not a<br>&gt;&gt;     type (like `_.BTree.OrderedSet`)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 20, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br></p><p>I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br></p><p>Jordan<br></p><p><br>&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt; <br>&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt; <br>&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt; <br>&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt; <br>&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt; <br>&gt; Prevent modules from containing a type with the same name<br>&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/e166bd7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June 20, 2016 at 09:00:00pm</p></header><div class="content"><p>Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br></p><p><br>&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt; <br>&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt; <br>&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt; <br>&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt; <br>&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt; <br>&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/696c9ce9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 20, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;m trying to reply to everybody in this message.<br></p><p>I think that it&#39;s a rather common and intuitive thing to name a module after its most important class, especially for small-ish packages. What would you call a package that provides a BTree, or a BigInt, and not much else? I&#39;d also make the case that ManagedObject wouldn&#39;t be an awful name for CoreData, or Animation for CoreAnimation. If your package is big enough that it benefits from having a single class that serves as the entry point to it, it would also make sense to call it the same thing as your package.<br></p><p>I don&#39;t really like preventing modules from having a class with the same name, precisely because I think that it&#39;s an intuitive thing to do.<br></p><p>I could go with Module::Class too, given that : is not an operator character.<br></p><p>Paulo, given that I&#39;m not sure about the direction that you&#39;re taking, it&#39;s a little hard to come up with a good name. &quot;Disambiguating namespaces&quot; or &quot;namespace selection&quot; or something like that could be a good start, maybe?<br></p><p>Félix<br></p><p>&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io&gt; a écrit :<br>&gt; <br>&gt; Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt;&gt; <br>&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/fc1e336c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 09:00:00pm</p></header><div class="content"><p>On Mon, Jun 20, 2016 at 9:08 PM, Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; I&#39;m trying to reply to everybody in this message.<br>&gt;<br>&gt; I think that it&#39;s a rather common and intuitive thing to name a module<br>&gt; after its most important class, especially for small-ish packages. What<br>&gt; would you call a package that provides a BTree, or a BigInt, and not much<br>&gt; else?<br>&gt;<br></p><p>BTreeCore, BTreeKit, BTreePackage, MyBTree, MyBTreeCore, MyBTreeKit,<br>MyBTreePackage...<br></p><p><br>&gt; I&#39;d also make the case that ManagedObject wouldn&#39;t be an awful name for<br>&gt; CoreData, or Animation for CoreAnimation.<br>&gt;<br></p><p>On the contrary, I think these show that some sort of prefix or suffix is<br>greatly beneficial. IMO, Data would be an absurd package name. Note how<br>it&#39;s WebKit, UIKit, SpriteKit and not Web, UI, Sprite.<br></p><p><br>&gt; If your package is big enough that it benefits from having a single class<br>&gt; that serves as the entry point to it, it would also make sense to call it<br>&gt; the same thing as your package.<br>&gt;<br>&gt; I don&#39;t really like preventing modules from having a class with the same<br>&gt; name, precisely because I think that it&#39;s an intuitive thing to do.<br>&gt;<br>&gt; I could go with Module::Class too, given that : is not an operator<br>&gt; character.<br>&gt;<br>&gt; Paulo, given that I&#39;m not sure about the direction that you&#39;re taking,<br>&gt; it&#39;s a little hard to come up with a good name. &quot;Disambiguating namespaces&quot;<br>&gt; or &quot;namespace selection&quot; or something like that could be a good start,<br>&gt; maybe?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io&gt; a écrit :<br>&gt;<br>&gt; Yeah! I’m working on a formal proposal that would solve the same problem.<br>&gt; Jordan, the problem he described is exactly like the one you explained to<br>&gt; me, haha. Now I’m a bit confused about how the proposal should be called.<br>&gt; Have any suggestions? What title could fit the two use cases we mentioned.<br>&gt; By the way, can you see any other use case that would be solved with the<br>&gt; same solution?<br>&gt;<br>&gt;<br>&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a<br>&gt; way to disambiguate extension methods, with the thought being we could then<br>&gt; use the same syntax to differentiate top-level names as well.<br>&gt;<br>&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems<br>&gt; a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello all,<br>&gt;<br>&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that<br>&gt; leaves me unable to fully-qualify the name of a type. If you import a<br>&gt; module named Foo that also contains a type named Foo, attempts to<br>&gt; fully-qualify any name in the Foo module will instead attempt to find<br>&gt; something inside the Foo type. This bug has already been reported<br>&gt; &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;<br>&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains<br>&gt; a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;<br>&gt; let set = OrderedSet&lt;Int&gt;()// error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context// Found this candidate: Foundation.OrderedSet:3:14// Found this candidate: BTree.OrderedSet:12:15<br>&gt;<br>&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift<br>&gt; thinks that BTree is the BTree type, not the BTree module:<br>&gt;<br>&gt; let set = BTree.OrderedSet&lt;Int&gt;()// error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;<br>&gt; Any fix will require a change to the language, and as Jordan Rose stated<br>&gt; on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and<br>&gt; discuss possible solutions.<br>&gt;<br>&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe<br>&gt; that this needs to be resolved):<br>&gt;<br>&gt;<br>&gt;    - Prevent modules from containing a type with the same name<br>&gt;    - Allow modules to be imported under different names (`import BTree as<br>&gt;    BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;    - Create a new syntax that indicates that you&#39;re naming a module, not<br>&gt;    a type (like `_.BTree.OrderedSet`)<br>&gt;<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/3d29378b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>June 20, 2016 at 09:00:00pm</p></header><div class="content"><p>I think that it takes some chutzpah to declare that your B-tree is authoritative enough that it should be called &quot;BTreeCore&quot;. I also by far prefer BTree to MyBTree or BTreePackage; of course these are all possible workarounds for a name resolution *bug*, but they certainly don&#39;t sound great to me.<br></p><p>I&#39;m also not suggesting that you can just do away with the &quot;kit&quot; or &quot;core&quot; in a module name: I&#39;m saying that I find it intuitive to take the main class of a package and name your package after it. It&#39;s not like you can instantiate the Web from WebKit!<br></p><p>Either way, these &lt;https://github.com/kirsteins/BigInteger&gt; things &lt;https://github.com/lorentey/BTree&gt; happen and I don&#39;t see anything fundamentally wrong with it. I&#39;d prefer a fix to a restriction.<br></p><p>Félix<br></p><p>&gt; Le 20 juin 2016 à 19:21:45, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt; <br>&gt; On Mon, Jun 20, 2016 at 9:08 PM, Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I&#39;m trying to reply to everybody in this message.<br>&gt; <br>&gt; I think that it&#39;s a rather common and intuitive thing to name a module after its most important class, especially for small-ish packages. What would you call a package that provides a BTree, or a BigInt, and not much else?<br>&gt; <br>&gt; BTreeCore, BTreeKit, BTreePackage, MyBTree, MyBTreeCore, MyBTreeKit, MyBTreePackage...<br>&gt;  <br>&gt; I&#39;d also make the case that ManagedObject wouldn&#39;t be an awful name for CoreData, or Animation for CoreAnimation.<br>&gt; <br>&gt; On the contrary, I think these show that some sort of prefix or suffix is greatly beneficial. IMO, Data would be an absurd package name. Note how it&#39;s WebKit, UIKit, SpriteKit and not Web, UI, Sprite.<br>&gt;  <br>&gt; If your package is big enough that it benefits from having a single class that serves as the entry point to it, it would also make sense to call it the same thing as your package.<br>&gt; <br>&gt; I don&#39;t really like preventing modules from having a class with the same name, precisely because I think that it&#39;s an intuitive thing to do.<br>&gt; <br>&gt; I could go with Module::Class too, given that : is not an operator character.<br>&gt; <br>&gt; Paulo, given that I&#39;m not sure about the direction that you&#39;re taking, it&#39;s a little hard to come up with a good name. &quot;Disambiguating namespaces&quot; or &quot;namespace selection&quot; or something like that could be a good start, maybe?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt;&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt;&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt;&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/fb3cb2f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 11:00:00pm</p></header><div class="content"><p>On Mon, Jun 20, 2016 at 11:12 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; I think that it takes some chutzpah to declare that your B-tree is<br>&gt; authoritative enough that it should be called &quot;BTreeCore&quot;.<br>&gt;<br></p><p>I don&#39;t know why it sounds more authoritative than `BTree` itself. If you<br>and I both name a type `BTree` (very logical), then it&#39;s up to the module<br>name to distinguish them. But if we both think it&#39;s &#39;obvious&#39; that our own<br>`BTree` type should be the one that&#39;s in the module named `BTree`, isn&#39;t<br>that a claim to authoritativeness?<br></p><p>I also by far prefer BTree to MyBTree or BTreePackage; of course these are<br>&gt; all possible workarounds for a name resolution *bug*, but they certainly<br>&gt; don&#39;t sound great to me.<br>&gt;<br></p><p>I&#39;m not entirely convinced that this definitely falls into the category of<br>a bug. I&#39;d imagine there&#39;s a cogent argument why type names and module<br>names should be mutually distinct; it&#39;s too late in the evening for me to<br>come up with one at the moment.<br></p><p><br>&gt; I&#39;m also not suggesting that you can just do away with the &quot;kit&quot; or &quot;core&quot;<br>&gt; in a module name: I&#39;m saying that I find it intuitive to take the main<br>&gt; class of a package and name your package after it. It&#39;s not like you can<br>&gt; instantiate the Web from WebKit!<br>&gt;<br>&gt; Either way, these &lt;https://github.com/kirsteins/BigInteger&gt; things<br>&gt; &lt;https://github.com/lorentey/BTree&gt; happen and I don&#39;t see anything<br>&gt; fundamentally wrong with it. I&#39;d prefer a fix to a restriction.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 20 juin 2016 à 19:21:45, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; a écrit :<br>&gt;<br>&gt; On Mon, Jun 20, 2016 at 9:08 PM, Félix Cloutier &lt;swift-evolution at swift.org<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;m trying to reply to everybody in this message.<br>&gt;&gt;<br>&gt;&gt; I think that it&#39;s a rather common and intuitive thing to name a module<br>&gt;&gt; after its most important class, especially for small-ish packages. What<br>&gt;&gt; would you call a package that provides a BTree, or a BigInt, and not much<br>&gt;&gt; else?<br>&gt;&gt;<br>&gt;<br>&gt; BTreeCore, BTreeKit, BTreePackage, MyBTree, MyBTreeCore, MyBTreeKit,<br>&gt; MyBTreePackage...<br>&gt;<br>&gt;<br>&gt;&gt; I&#39;d also make the case that ManagedObject wouldn&#39;t be an awful name for<br>&gt;&gt; CoreData, or Animation for CoreAnimation.<br>&gt;&gt;<br>&gt;<br>&gt; On the contrary, I think these show that some sort of prefix or suffix is<br>&gt; greatly beneficial. IMO, Data would be an absurd package name. Note how<br>&gt; it&#39;s WebKit, UIKit, SpriteKit and not Web, UI, Sprite.<br>&gt;<br>&gt;<br>&gt;&gt; If your package is big enough that it benefits from having a single class<br>&gt;&gt; that serves as the entry point to it, it would also make sense to call it<br>&gt;&gt; the same thing as your package.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t really like preventing modules from having a class with the same<br>&gt;&gt; name, precisely because I think that it&#39;s an intuitive thing to do.<br>&gt;&gt;<br>&gt;&gt; I could go with Module::Class too, given that : is not an operator<br>&gt;&gt; character.<br>&gt;&gt;<br>&gt;&gt; Paulo, given that I&#39;m not sure about the direction that you&#39;re taking,<br>&gt;&gt; it&#39;s a little hard to come up with a good name. &quot;Disambiguating namespaces&quot;<br>&gt;&gt; or &quot;namespace selection&quot; or something like that could be a good start,<br>&gt;&gt; maybe?<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Yeah! I’m working on a formal proposal that would solve the same problem.<br>&gt;&gt; Jordan, the problem he described is exactly like the one you explained to<br>&gt;&gt; me, haha. Now I’m a bit confused about how the proposal should be called.<br>&gt;&gt; Have any suggestions? What title could fit the two use cases we mentioned.<br>&gt;&gt; By the way, can you see any other use case that would be solved with the<br>&gt;&gt; same solution?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a<br>&gt;&gt; way to disambiguate extension methods, with the thought being we could then<br>&gt;&gt; use the same syntax to differentiate top-level names as well.<br>&gt;&gt;<br>&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax<br>&gt;&gt; seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello all,<br>&gt;&gt;<br>&gt;&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that<br>&gt;&gt; leaves me unable to fully-qualify the name of a type. If you import a<br>&gt;&gt; module named Foo that also contains a type named Foo, attempts to<br>&gt;&gt; fully-qualify any name in the Foo module will instead attempt to find<br>&gt;&gt; something inside the Foo type. This bug has already been reported<br>&gt;&gt; &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt;<br>&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also<br>&gt;&gt; contains a BTree type) that I encountered while trying to use the<br>&gt;&gt; OrderedSet type:<br>&gt;&gt;<br>&gt;&gt; let set = OrderedSet&lt;Int&gt;()// error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context// Found this candidate: Foundation.OrderedSet:3:14// Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;<br>&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift<br>&gt;&gt; thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;<br>&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()// error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;<br>&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated<br>&gt;&gt; on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and<br>&gt;&gt; discuss possible solutions.<br>&gt;&gt;<br>&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe<br>&gt;&gt; that this needs to be resolved):<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Prevent modules from containing a type with the same name<br>&gt;&gt;    - Allow modules to be imported under different names (`import BTree<br>&gt;&gt;    as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;    - Create a new syntax that indicates that you&#39;re naming a module, not<br>&gt;&gt;    a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/f0e01d96/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 16, 2016 at 03:00:00pm</p></header><div class="content"><p>There is about 2 weeks left for source-breaking proposals, and this is going to be one of them. How is progress going? Do you think that you&#39;ll have enough time to push it out of the door?<br></p><p>Félix<br></p><p>&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io&gt; a écrit :<br>&gt; <br>&gt; Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt;&gt; <br>&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/09013a51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 17, 2016 at 01:00:00am</p></header><div class="content"><p>I don&#39;t see anything source breaking here. I&#39;m fairly sure it&#39;s 100% additive and will therefore wait for after Swift 3.<br></p><p>&gt; On 17 Jul 2016, at 00:19, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is about 2 weeks left for source-breaking proposals, and this is going to be one of them. How is progress going? Do you think that you&#39;ll have enough time to push it out of the door?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I recently ran into a bug that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt;&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt;&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt;&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160717/0c31b61d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 16, 2016 at 04:00:00pm</p></header><div class="content"><p>There is a lot of potential for it to be a breaking change. Currently, you can do module qualification with Module.Symbol. This causes problems. The two most obvious solutions (change the &quot;operator&quot; between Module and Symbol, or prevent symbols from having the same name as their module) are breaking changes.<br></p><p>Félix<br></p><p>&gt; Le 16 juil. 2016 à 16:01:28, David Hart &lt;david at hartbit.com&gt; a écrit :<br>&gt; <br>&gt; I don&#39;t see anything source breaking here. I&#39;m fairly sure it&#39;s 100% additive and will therefore wait for after Swift 3.<br>&gt; <br>&gt; On 17 Jul 2016, at 00:19, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; There is about 2 weeks left for source-breaking proposals, and this is going to be one of them. How is progress going? Do you think that you&#39;ll have enough time to push it out of the door?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt;&gt;&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt;&gt;&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;&gt;&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;&gt;&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt;&gt;&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;&gt;&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/00fa0659/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 17, 2016 at 03:00:00am</p></header><div class="content"><p>For what it’s worth, I renamed OrderedSet to SortedSet in the Swift 3 version of BTree, so the original instance of this issue is hopefully no more.<br></p><p>Prohibiting modules from containing a symbol of the same name would require a mass renaming of many microframeworks. Besides BTree, I also have BigInt, Deque and RedBlackTree; I know Rob Rix has Result, Box, Either, Memo, Delay, Stream, BinaryTree, etc.; and there are oodles more. Renaming them is certainly doable, but it definitely would be a pain in the neck for everyone involved. I’m not even sure what naming convention we should use: most of these packages essentially consist of the type that they’re named after, and naming them like this was the most obvious option. (These names work well at the point of use, too: you want to use Result, so you need to import Result). Requiring/allowing reverse DNS-style module names (e.g. com.apple.Foundation) would be one way to solve the naming issue, but this seems hard to incorporate into the language at this point.)<br></p><p>I’d much prefer having “import Foo as Bar” as a (hopefully) easy-to-implement stop-gap solution than to give up on these nice microframework names. This would not break existing code.<br></p><p>I like the idea to allow absolute naming to resolve ambiguous names, but using _ for the root symbol seems very different to its usual meaning. Perhaps it&#39;s worth spending the # character on this: #.BTree.OrderedSet&lt;Int&gt;. Or how about &quot;&lt;&gt;.BTree.OrderedSet&lt;Int&gt;”? None of these would be intuitively clear to read, though (and they need special magic to make sure a “&lt;root&gt;.BTree.” prefix is resolved to mean the module, not the struct.). If nested modules are in the cards for a future Swift, not having a delimiter at the end of the module path could become an issue.<br></p><p>What if we allowed type expressions like “(OrderedSet&lt;Int&gt; in BTree)” or “(OrderedSet&lt;Foo&gt; from Foundation)”? The swapped order sure is strange though, and I have no idea if such a construct would fit in the grammar. But at least the meaning of it is reasonably clear, and the same scheme could also support the extension method case: e.g., &quot;foo.(bar in MyModule)()”.<br></p><p>C# has a somewhat similar issue with its namespaces: https://blogs.msdn.microsoft.com/ericlippert/2010/03/09/do-not-name-a-class-the-same-as-its-namespace-part-one/ &lt;https://blogs.msdn.microsoft.com/ericlippert/2010/03/09/do-not-name-a-class-the-same-as-its-namespace-part-one/&gt;. They have &quot;global::” to refer to their root namespace, and they discourage (but not prohibit) naming a class the same as its enclosing namespace. I think Java&#39;s concept of obscured names is also relevant, but I’ll leave it to someone else to decipher the specification. :-)<br></p><p>-- <br>Karoly<br>@lorentey<br></p><p>&gt; On 2016-07-17, at 01:07, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is a lot of potential for it to be a breaking change. Currently, you can do module qualification with Module.Symbol. This causes problems. The two most obvious solutions (change the &quot;operator&quot; between Module and Symbol, or prevent symbols from having the same name as their module) are breaking changes.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 16 juil. 2016 à 16:01:28, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see anything source breaking here. I&#39;m fairly sure it&#39;s 100% additive and will therefore wait for after Swift 3.<br>&gt;&gt; <br>&gt;&gt; On 17 Jul 2016, at 00:19, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; There is about 2 weeks left for source-breaking proposals, and this is going to be one of them. How is progress going? Do you think that you&#39;ll have enough time to push it out of the door?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt;&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt;&gt;&gt;&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt;&gt;&gt;&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;&gt;&gt;&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt;&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt;&gt;&gt;&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;&gt;&gt;&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160717/b7212573/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>July 16, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;ve been wanting to do this kind of overhaul for the last 6 months.  My original spitball thread is here  http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1394 and I have a draft of a proposal that I hope to put out soon that I can let you view (or even coauthor if you desire) if anybody wishes to ping me off-list.<br></p><p>~Robert Widmann<br></p><p>2016/07/16 15:19、Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; There is about 2 weeks left for source-breaking proposals, and this is going to be one of them. How is progress going? Do you think that you&#39;ll have enough time to push it out of the door?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I recently ran into a bug that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt;&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt;&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt;&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/6bdea187/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Fixing modules that contain a type with the same name</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 16, 2016 at 09:00:00pm</p></header><div class="content"><p>To be clear, I think that you should be allowed to have a symbol that has the same name as the module. I was talking about that alternative because other people on this thread preferred it, but this does not reflect my opinion at all. As Károly writes, one very big reason to dislike it is that there is no possible automated migration for users of frameworks that rely on this pattern.<br></p><p>Renaming imports is one additive way to solve the problem. I was asking Paulo how his proposal is going, though, because my intuition is that it&#39;s headed towards something like `object.Module::extensionMethod()` to disambiguate extension methods, and we could reuse whatever syntax it has for global module symbols too.<br></p><p>Since I suggested _.Module.Class, it was brought to my attention (on this thread) that : is not an operator symbol, so there is no risk of ambiguity in Module::Class (which I think is better than _.Module.Class).<br></p><p>Félix<br></p><p>&gt; Le 16 juil. 2016 à 19:06:14, Robert Widmann &lt;devteam.codafi at gmail.com&gt; a écrit :<br>&gt; <br>&gt; I&#39;ve been wanting to do this kind of overhaul for the last 6 months.  My original spitball thread is here  http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1394 &lt;http://permalink.gmane.org/gmane.comp.lang.swift.evolution/1394&gt; and I have a draft of a proposal that I hope to put out soon that I can let you view (or even coauthor if you desire) if anybody wishes to ping me off-list.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/07/16 15:19、Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; There is about 2 weeks left for source-breaking proposals, and this is going to be one of them. How is progress going? Do you think that you&#39;ll have enough time to push it out of the door?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 20 juin 2016 à 17:33:03, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah! I’m working on a formal proposal that would solve the same problem. Jordan, the problem he described is exactly like the one you explained to me, haha. Now I’m a bit confused about how the proposal should be called. Have any suggestions? What title could fit the two use cases we mentioned. By the way, can you see any other use case that would be solved with the same solution?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 20, 2016, at 9:25 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve been encouraging Paulo Faria to mention this case in his push for a way to disambiguate extension methods, with the thought being we could then use the same syntax to differentiate top-level names as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d also be happy with the &quot;import as&quot; syntax. The underscore syntax seems a little opaque, but I suppose it wouldn&#39;t come up very often.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 17, 2016, at 19:52, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I recently ran into a bug &lt;http://stackoverflow.com/q/37892621/251153&gt; that leaves me unable to fully-qualify the name of a type. If you import a module named Foo that also contains a type named Foo, attempts to fully-qualify any name in the Foo module will instead attempt to find something inside the Foo type. This bug has already been reported &lt;https://bugs.swift.org/browse/SR-898&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here&#39;s an example with Károly Lőrentey&#39;s BTree module (which also contains a BTree type) that I encountered while trying to use the OrderedSet type:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let set = OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt;&gt; // error: &#39;OrderedSet&#39; is ambiguous for type lookup in this context<br>&gt;&gt;&gt;&gt;&gt; // Found this candidate: Foundation.OrderedSet:3:14<br>&gt;&gt;&gt;&gt;&gt; // Found this candidate: BTree.OrderedSet:12:15<br>&gt;&gt;&gt;&gt;&gt; To solve this, you would normally write BTree.OrderedSet, but now Swift thinks that BTree is the BTree type, not the BTree module:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let set = BTree.OrderedSet&lt;Int&gt;()<br>&gt;&gt;&gt;&gt;&gt; // error: reference to generic type &#39;BTree&#39; requires arguments in &lt;...&gt;<br>&gt;&gt;&gt;&gt;&gt; Any fix will require a change to the language, and as Jordan Rose stated on the bug, it &quot;needs design&quot;, so I would like to bring up the issue and discuss possible solutions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can see several options (leaving &quot;do nothing&quot; aside, since I believe that this needs to be resolved):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Prevent modules from containing a type with the same name<br>&gt;&gt;&gt;&gt;&gt; Allow modules to be imported under different names (`import BTree as BTreeModule`, `import BTreeModule = BTree` or any similar syntax)<br>&gt;&gt;&gt;&gt;&gt; Create a new syntax that indicates that you&#39;re naming a module, not a type (like `_.BTree.OrderedSet`)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/42f41b39/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
