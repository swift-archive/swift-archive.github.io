<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 30, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 12:26 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>Just read through it.<br></p><p>I&#39;d like to know more about how this proposal interacts with selector differentiation and overloading.<br></p><p>Thanks,<br></p><p>- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/9643e12e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 30, 2016 at 01:00:00pm</p></header><div class="content"><p>This mostly makes sense to me and it seems like mostly a good idea, but take this example:<br></p><p>func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>let x = doSomething<br>x(10, 10)<br></p><p>Is it then legal to do this?:<br></p><p>x(blahblah:10, totallyOffTheWallLabelThatDoesNotAppearANYWHERE: 10)<br></p><p>That would seem odd to me. Maybe it could be useful, but it might also be *super* confusing. I’m not sure I have a suggestion as to what to do in a situation like this - but it doesn’t seem “right” to allow it.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 30, 2016, at 1:26 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>This is a good point. I feel like calling `x` with any sort of argument<br>labels should be prohibited. I don&#39;t think there&#39;s any expressivity penalty<br>for doing so (especially since tuple splat is gone); plus, once a function<br>is reified as a value (as opposed to being invoked by naming it directly),<br>I think the most principled thing to do is to consider the argument labels<br>&quot;erased&quot;.<br></p><p>(There might be an alternate universe in which Swift&#39;s function types&#39;<br>argument labels are *fully* significant by disallowing conversions between<br>function values declared with different argument labels, but Swift has<br>never actually enforced such a requirement, and so it&#39;s probably better to<br>just formalize the semantics as described above than vacillating on whether<br>argument labels are significant or not.)<br></p><p>Austin<br></p><p>On Thu, Jun 30, 2016 at 11:37 AM, Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This mostly makes sense to me and it seems like mostly a good idea, but<br>&gt; take this example:<br>&gt;<br>&gt; func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>&gt; let x = doSomething<br>&gt; x(10, 10)<br>&gt;<br>&gt; Is it then legal to do this?:<br>&gt;<br>&gt; x(blahblah:10, totallyOffTheWallLabelThatDoesNotAppearANYWHERE: 10)<br>&gt;<br>&gt; That would seem odd to me. Maybe it could be useful, but it might also be<br>&gt; *super* confusing. I’m not sure I have a suggestion as to what to do in a<br>&gt; situation like this - but it doesn’t seem “right” to allow it.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 30, 2016, at 1:26 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt; available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/c2693ac7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 30, 2016 at 06:00:00pm</p></header><div class="content"><p>Austin, I agree with your point here that any sort of label should be<br>prohibited at the call site if your proposal is adopted; along those lines,<br>your suggested alternative of disallowing them in the type annotation might<br>win in terms of appropriately setting user expectations about labels<br>despite the loss in documentation.<br></p><p>On Thu, Jun 30, 2016 at 13:44 Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is a good point. I feel like calling `x` with any sort of argument<br>&gt; labels should be prohibited. I don&#39;t think there&#39;s any expressivity penalty<br>&gt; for doing so (especially since tuple splat is gone); plus, once a function<br>&gt; is reified as a value (as opposed to being invoked by naming it directly),<br>&gt; I think the most principled thing to do is to consider the argument labels<br>&gt; &quot;erased&quot;.<br>&gt;<br>&gt; (There might be an alternate universe in which Swift&#39;s function types&#39;<br>&gt; argument labels are *fully* significant by disallowing conversions between<br>&gt; function values declared with different argument labels, but Swift has<br>&gt; never actually enforced such a requirement, and so it&#39;s probably better to<br>&gt; just formalize the semantics as described above than vacillating on whether<br>&gt; argument labels are significant or not.)<br>&gt;<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Thu, Jun 30, 2016 at 11:37 AM, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This mostly makes sense to me and it seems like mostly a good idea, but<br>&gt;&gt; take this example:<br>&gt;&gt;<br>&gt;&gt; func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>&gt;&gt; let x = doSomething<br>&gt;&gt; x(10, 10)<br>&gt;&gt;<br>&gt;&gt; Is it then legal to do this?:<br>&gt;&gt;<br>&gt;&gt; x(blahblah:10, totallyOffTheWallLabelThatDoesNotAppearANYWHERE: 10)<br>&gt;&gt;<br>&gt;&gt; That would seem odd to me. Maybe it could be useful, but it might also be<br>&gt;&gt; *super* confusing. I’m not sure I have a suggestion as to what to do in a<br>&gt;&gt; situation like this - but it doesn’t seem “right” to allow it.<br>&gt;&gt;<br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 30, 2016, at 1:26 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello Swift community,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt; available here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What goes into a review?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?<br>&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of<br>&gt;&gt; Swift?<br>&gt;&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; More information about the Swift evolution process is available at<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thank you,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt; &gt; Review Manager<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/d927051f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 30, 2016 at 07:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt; ]<br></p><p>This is my feeling as well. Argument labels are definitely part of the name of the function, but they aren’t part of the type. A few functions happen to have argument labels <br></p><p>On future directions: I’m mildly in favor of allowing parameters and locals with closure type to have labels in the name: <br></p><p>func map&lt;Result&gt;(_ transform(from:): (Element) -&gt; Result) -&gt; [Result]<br>func map&lt;Result&gt;(_ transform: (from: Element) -&gt; Result) -&gt; [Result]<br></p><p>which, yes, would require you to rewrite the names if you cared, but would at least allow you to rewrite the names if you cared. More importantly, it lets you document callbacks properly. (This kind of works by coincidence today.)<br></p><p>I am in favor of this proposal.<br></p><p>Jordan<br></p><p>&gt; On Jun 30, 2016, at 11:44, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a good point. I feel like calling `x` with any sort of argument labels should be prohibited. I don&#39;t think there&#39;s any expressivity penalty for doing so (especially since tuple splat is gone); plus, once a function is reified as a value (as opposed to being invoked by naming it directly), I think the most principled thing to do is to consider the argument labels &quot;erased&quot;.<br>&gt; <br>&gt; (There might be an alternate universe in which Swift&#39;s function types&#39; argument labels are *fully* significant by disallowing conversions between function values declared with different argument labels, but Swift has never actually enforced such a requirement, and so it&#39;s probably better to just formalize the semantics as described above than vacillating on whether argument labels are significant or not.)<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Thu, Jun 30, 2016 at 11:37 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; This mostly makes sense to me and it seems like mostly a good idea, but take this example:<br>&gt; <br>&gt; func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>&gt; let x = doSomething<br>&gt; x(10, 10)<br>&gt; <br>&gt; Is it then legal to do this?:<br>&gt; <br>&gt; x(blahblah:10, totallyOffTheWallLabelThatDoesNotAppearANYWHERE: 10)<br>&gt; <br>&gt; That would seem odd to me. Maybe it could be useful, but it might also be *super* confusing. I’m not sure I have a suggestion as to what to do in a situation like this - but it doesn’t seem “right” to allow it.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 30, 2016, at 1:26 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;       * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/b185eee5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 9:36 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt; ]<br>&gt; <br>&gt; This is my feeling as well. Argument labels are definitely part of the name of the function, but they aren’t part of the type. A few functions happen to have argument labels <br>&gt; <br>&gt; On future directions: I’m mildly in favor of allowing parameters and locals with closure type to have labels in the name: <br>&gt; <br>&gt; func map&lt;Result&gt;(_ transform(from:): (Element) -&gt; Result) -&gt; [Result]<br>&gt; func map&lt;Result&gt;(_ transform: (from: Element) -&gt; Result) -&gt; [Result]<br>&gt; <br>&gt; which, yes, would require you to rewrite the names if you cared, but would at least allow you to rewrite the names if you cared. More importantly, it lets you document callbacks properly. (This kind of works by coincidence today.)<br></p><p>This *might* make sense.  I almost included something similar in my review.  It is one of the use cases I had in mind when I mentioned the possibility of designing a less fragile feature for specific uses cases.  But that discussion is for the future.  :)<br></p><p><br>&gt; <br>&gt; I am in favor of this proposal.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 11:44, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a good point. I feel like calling `x` with any sort of argument labels should be prohibited. I don&#39;t think there&#39;s any expressivity penalty for doing so (especially since tuple splat is gone); plus, once a function is reified as a value (as opposed to being invoked by naming it directly), I think the most principled thing to do is to consider the argument labels &quot;erased&quot;.<br>&gt;&gt; <br>&gt;&gt; (There might be an alternate universe in which Swift&#39;s function types&#39; argument labels are *fully* significant by disallowing conversions between function values declared with different argument labels, but Swift has never actually enforced such a requirement, and so it&#39;s probably better to just formalize the semantics as described above than vacillating on whether argument labels are significant or not.)<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 30, 2016 at 11:37 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; This mostly makes sense to me and it seems like mostly a good idea, but take this example:<br>&gt;&gt; <br>&gt;&gt; func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>&gt;&gt; let x = doSomething<br>&gt;&gt; x(10, 10)<br>&gt;&gt; <br>&gt;&gt; Is it then legal to do this?:<br>&gt;&gt; <br>&gt;&gt; x(blahblah:10, totallyOffTheWallLabelThatDoesNotAppearANYWHERE: 10)<br>&gt;&gt; <br>&gt;&gt; That would seem odd to me. Maybe it could be useful, but it might also be *super* confusing. I’m not sure I have a suggestion as to what to do in a situation like this - but it doesn’t seem “right” to allow it.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 30, 2016, at 1:26 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello Swift community,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What goes into a review?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt; &gt;       * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; &gt;       * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; More information about the Swift evolution process is available at<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thank you,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt; &gt; Review Manager<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/c93359a9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>I’d also like to know what the answer to this is before giving my vote for or against the proposal.<br></p><p>&gt; On 30 Jun 2016, at 20:37, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This mostly makes sense to me and it seems like mostly a good idea, but take this example:<br>&gt; <br>&gt; func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>&gt; let x = doSomething<br>&gt; x(10, 10)<br>&gt; <br>&gt; Is it then legal to do this?:<br>&gt; <br>&gt; x(blahblah:10, totallyOffTheWallLabelThatDoesNotAppearANYWHERE: 10)<br>&gt; <br>&gt; That would seem odd to me. Maybe it could be useful, but it might also be *super* confusing. I’m not sure I have a suggestion as to what to do in a situation like this - but it doesn’t seem “right” to allow it.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 1:26 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 30, 2016 at 11:00:00pm</p></header><div class="content"><p>On 30.06.2016 21:37, Sean Heber via swift-evolution wrote:<br>&gt; This mostly makes sense to me and it seems like mostly a good idea, but take this example:<br>&gt;<br>&gt; func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>&gt; let x = doSomething<br>&gt; x(10, 10)<br>&gt;<br>&gt; Is it then legal to do this?:<br>&gt;<br>&gt; x(blahblah:10, totallyOffTheWallLabelThatDoesNotAppearANYWHERE: 10)<br></p><p>Why this should be legal? The type of x does not contain definition of <br>`blahblah` and `totallyOffTheWallLabelThatDoesNotAppearANYWHERE` as labels.<br>So, I believe there no reasons to allow using of labels that was not <br>explicitly declared.<br></p><p>&gt;<br>&gt; That would seem odd to me. Maybe it could be useful, but it might also be *super* confusing. I’m not sure I have a suggestion as to what to do in a situation like this - but it doesn’t seem “right” to allow it.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt;&gt; On Jun 30, 2016, at 1:26 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt;&gt;<br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;<br>&gt;&gt; What goes into a review?<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;<br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;<br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt;<br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>-1<br></p><p>This proposal doesn’t even use Swift naming style to make its point, as soon as you do, the reason why Swift considers argument labels to be part of the type signature becomes apparent. <br></p><p>The author of the proposal uses the following example:<br></p><p>  func doSomething(x: Int, y: Int) -&gt; Bool<br></p><p><br>This is just not Swift-y, a much better example would be:<br></p><p>  func sinkBattleship(atX x: Int, y: Int) -&gt; Bool<br></p><p>the proposal states that the argument labels be then stripped from the type, which would make this method type-compatible with:<br></p><p>  func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool<br></p><p><br>I don’t think it’s desirable for this to work at all… Argument labels are not parameter names, they are a first class part of Swift’s type system, and always meaningful when employed properly.<br></p><p><br>Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Jun 30, 2016 at 11:43 AM, Scott James Remnant via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; -1<br>&gt;<br>&gt; This proposal doesn’t even use Swift naming style to make its point, as<br>&gt; soon as you do, the reason why Swift considers argument labels to be part<br>&gt; of the type signature becomes apparent.<br>&gt;<br>&gt; The author of the proposal uses the following example:<br>&gt;<br>&gt;   func doSomething(x: Int, y: Int) -&gt; Bool<br>&gt;<br>&gt;<br>&gt; This is just not Swift-y, a much better example would be:<br>&gt;<br>&gt;   func sinkBattleship(atX x: Int, y: Int) -&gt; Bool<br>&gt;<br>&gt; the proposal states that the argument labels be then stripped from the<br>&gt; type, which would make this method type-compatible with:<br>&gt;<br>&gt;   func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool<br>&gt;<br></p><p>They already *are* type compatible. This works right now:<br></p><p>var a : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage<br>a = sinkBattleship<br>// ???<br>a(ofHits: 1, forRuns: 2)<br></p><p><br>&gt;<br>&gt;<br>&gt; I don’t think it’s desirable for this to work at all… Argument labels are<br>&gt; not parameter names, they are a first class part of Swift’s type system,<br>&gt; and always meaningful when employed properly.<br></p><p><br>No they aren&#39;t, because of the implicit subtyping demonstrated above. It&#39;s<br>better to remove the significance of argument labels completely than to<br>vacillate on the topic and make promises we can&#39;t actually keep (per that<br>example).<br></p><p><br>&gt;<br>&gt;<br>&gt; Scott<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/fae3d067/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; They already *are* type compatible. This works right now:<br>&gt; <br>&gt; var a : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage<br>&gt; a = sinkBattleship<br>&gt; // ???<br>&gt; a(ofHits: 1, forRuns: 2)<br></p><p>Your proposal does not make it clear that this works (which is surprising to me).<br></p><p>I would argue the proposal the other way: that there should be an error on line 2, and this should not be permitted implicitly.<br></p><p>Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 30, 2016 at 11:00:00am</p></header><div class="content"><p>This should probably be a motivating example.<br></p><p>I&#39;ll add an Alternative to keep the present behavior and tighten the<br>requirements.<br></p><p>Austin<br></p><p>On Thu, Jun 30, 2016 at 11:56 AM, Scott James Remnant &lt;scott at netsplit.com&gt;<br>wrote:<br></p><p>&gt; &gt; They already *are* type compatible. This works right now:<br>&gt; &gt;<br>&gt; &gt; var a : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage<br>&gt; &gt; a = sinkBattleship<br>&gt; &gt; // ???<br>&gt; &gt; a(ofHits: 1, forRuns: 2)<br>&gt;<br>&gt; Your proposal does not make it clear that this works (which is surprising<br>&gt; to me).<br>&gt;<br>&gt; I would argue the proposal the other way: that there should be an error on<br>&gt; line 2, and this should not be permitted implicitly.<br>&gt;<br>&gt; Scott<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/92ccb4ef/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 30, 2016 at 11:00:00pm</p></header><div class="content"><p>On 30.06.2016 21:56, Scott James Remnant via swift-evolution wrote:<br>&gt;&gt; They already *are* type compatible. This works right now:<br>&gt;&gt;<br>&gt;&gt; var a : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage a =<br>&gt;&gt; sinkBattleship // ??? a(ofHits: 1, forRuns: 2)<br>&gt;<br>&gt; Your proposal does not make it clear that this works (which is<br>&gt; surprising to me).<br>&gt;<br>&gt; I would argue the proposal the other way: that there should be an error<br>&gt; on line 2, and this should not be permitted implicitly.<br></p><p>I&#39;m not sure if this is a definitely bad thing. Let&#39;s assume I have a <br>number of funcs with similar but different labels and I want to define a <br>function variable with another labels and assign one of these funcs:<br></p><p>func foo(one: Int, two: Int) {..}<br>func bar(first: Int, second: Int) {..}<br></p><p>var a : (alfa: Int, betta: Int) -&gt; () = foo<br>a(alfa: 1, betta: 2)<br>a = bar<br>a(alfa: 1, betta: 2)<br></p><p>But the type of `a` is still (Int, Int) -&gt; () the same as for `foo` and `bar`<br></p><p>&gt;<br>&gt; Scott _______________________________________________ swift-evolution<br>&gt; mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>June 30, 2016 at 01:00:00pm</p></header><div class="content"><p>As with the original proposal, your examples here don&#39;t obey the Naming Guidelines.<br></p><p>If we&#39;re going to pretend that Swift is C, we wouldn&#39;t have a distinction between argument labels and parameter names in the first place!<br></p><p>Is there an example of two functions, obeying the naming guidelines, which have different argument labels (not parameter names) for parameters of the same type, where it makes sense to cross-call them?<br></p><p>Scott<br></p><p>&gt; On Jun 30, 2016, at 1:11 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; On 30.06.2016 21:56, Scott James Remnant via swift-evolution wrote:<br>&gt;&gt;&gt; They already *are* type compatible. This works right now:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var a : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage a =<br>&gt;&gt;&gt; sinkBattleship // ??? a(ofHits: 1, forRuns: 2)<br>&gt;&gt; <br>&gt;&gt; Your proposal does not make it clear that this works (which is<br>&gt;&gt; surprising to me).<br>&gt;&gt; <br>&gt;&gt; I would argue the proposal the other way: that there should be an error<br>&gt;&gt; on line 2, and this should not be permitted implicitly.<br>&gt; <br>&gt; I&#39;m not sure if this is a definitely bad thing. Let&#39;s assume I have a number of funcs with similar but different labels and I want to define a function variable with another labels and assign one of these funcs:<br>&gt; <br>&gt; func foo(one: Int, two: Int) {..}<br>&gt; func bar(first: Int, second: Int) {..}<br>&gt; <br>&gt; var a : (alfa: Int, betta: Int) -&gt; () = foo<br>&gt; a(alfa: 1, betta: 2)<br>&gt; a = bar<br>&gt; a(alfa: 1, betta: 2)<br>&gt; <br>&gt; But the type of `a` is still (Int, Int) -&gt; () the same as for `foo` and `bar`<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Scott _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Jun 30, 2016 at 3:30 PM, Scott James Remnant via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As with the original proposal, your examples here don&#39;t obey the Naming<br>&gt; Guidelines.<br>&gt;<br>&gt; If we&#39;re going to pretend that Swift is C, we wouldn&#39;t have a distinction<br>&gt; between argument labels and parameter names in the first place!<br>&gt;<br>&gt; Is there an example of two functions, obeying the naming guidelines, which<br>&gt; have different argument labels (not parameter names) for parameters of the<br>&gt; same type, where it makes sense to cross-call them?<br>&gt;<br></p><p>Sure there are. For example, `adding(_:)` and `multiplied(by:)` in the new<br>Integer protocol.<br></p><p><br>&gt;<br>&gt; Scott<br>&gt;<br>&gt; &gt; On Jun 30, 2016, at 1:11 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On 30.06.2016 21:56, Scott James Remnant via swift-evolution wrote:<br>&gt; &gt;&gt;&gt; They already *are* type compatible. This works right now:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; var a : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage a =<br>&gt; &gt;&gt;&gt; sinkBattleship // ??? a(ofHits: 1, forRuns: 2)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Your proposal does not make it clear that this works (which is<br>&gt; &gt;&gt; surprising to me).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would argue the proposal the other way: that there should be an error<br>&gt; &gt;&gt; on line 2, and this should not be permitted implicitly.<br>&gt; &gt;<br>&gt; &gt; I&#39;m not sure if this is a definitely bad thing. Let&#39;s assume I have a<br>&gt; number of funcs with similar but different labels and I want to define a<br>&gt; function variable with another labels and assign one of these funcs:<br>&gt; &gt;<br>&gt; &gt; func foo(one: Int, two: Int) {..}<br>&gt; &gt; func bar(first: Int, second: Int) {..}<br>&gt; &gt;<br>&gt; &gt; var a : (alfa: Int, betta: Int) -&gt; () = foo<br>&gt; &gt; a(alfa: 1, betta: 2)<br>&gt; &gt; a = bar<br>&gt; &gt; a(alfa: 1, betta: 2)<br>&gt; &gt;<br>&gt; &gt; But the type of `a` is still (Int, Int) -&gt; () the same as for `foo` and<br>&gt; `bar`<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Scott _______________________________________________ swift-evolution<br>&gt; &gt;&gt; mailing list swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/d9ddc796/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>June 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Is there an example of two functions, obeying the naming guidelines, which have different argument labels (not parameter names) for parameters of the same type, where it makes sense to cross-call them?<br>&gt; <br>&gt; Sure there are. For example, `adding(_:)` and `multiplied(by:)` in the new Integer protocol.<br></p><p>These have quite different results!<br></p><p>I’m pretty convinced that Swift shouldn’t implicitly allow you to assign multiplied(by:) to the same member as you could assign adding(_:) - explicit is fine, with some syntax e.g. through a closure, but not implicit!<br></p><p>To correct my goofy pre-coffee not-quite-following-the-naming-guidelines suggestion, that would be equivalent of allowing these two to be interchangeable:<br></p><p>  func drawLineTo(x: Float, y: Float)<br>  func drawLineWith(angle: Float, distance: Float)<br></p><p>Which is clearly not something you would expect to be allowed implicitly.<br></p><p><br>I’m definitely for the concept of the proposal that this is inconsistent, but I’m also definitely for making this explicitly disallowed everywhere, not allowed everywhere.<br></p><p>I think Erica makes a good point about syntax too, we’ve been assuming:<br></p><p>  // compatible types<br>  var x = drawLineTo<br>  x = drawLineWith<br></p><p>but really this isn’t Swifty syntax, the full argument labels provide more clarity here; and I’d even be in favor of disallowing the above shortening.<br></p><p>Scott<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/6490f4c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 30, 2016 at 08:00:00pm</p></header><div class="content"><p>On Thu, Jun 30, 2016 at 7:02 PM, Scott James Remnant &lt;scott at netsplit.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Is there an example of two functions, obeying the naming guidelines, which<br>&gt;&gt; have different argument labels (not parameter names) for parameters of the<br>&gt;&gt; same type, where it makes sense to cross-call them?<br>&gt;<br>&gt;<br>&gt; Sure there are. For example, `adding(_:)` and `multiplied(by:)` in the new<br>&gt; Integer protocol.<br>&gt;<br>&gt;<br>&gt; These have quite different results!<br>&gt;<br></p><p>Of course they have different results. What&#39;s the point of two different<br>functions that yield the same results? I don&#39;t see your point here.<br>Anywhere I can supply `adding(_:)` as a predicate, I expect to be able to<br>supply `multiplied(by:)`. Both of these methods take one number and return<br>another; there is nothing about the label `by` inherent to what the latter<br>method does; it&#39;s entirely an accident of the English language.<br></p><p><br>&gt;<br>&gt; I’m pretty convinced that Swift shouldn’t implicitly allow you to assign<br>&gt; multiplied(by:) to the same member as you could assign adding(_:) -<br>&gt; explicit is fine, with some syntax e.g. through a closure, but not implicit!<br>&gt;<br></p><p>But adding(_:) and subtracting(_:) are OK? The point is, with Swift<br>guidelines, argument labels can differ due to the vagaries of the English<br>language; it is not a proxy for whether two functions are &quot;not very<br>different,&quot; &quot;somewhat different,&quot; or &quot;very different.&quot;<br></p><p><br>&gt; To correct my goofy pre-coffee not-quite-following-the-naming-guidelines<br>&gt; suggestion, that would be equivalent of allowing these two to be<br>&gt; interchangeable:<br>&gt;<br>&gt;   func drawLineTo(x: Float, y: Float)<br>&gt;   func drawLineWith(angle: Float, distance: Float)<br>&gt;<br>&gt; Which is clearly not something you would expect to be allowed implicitly.<br>&gt;<br></p><p>Why not? It is not clear to me.<br></p><p><br>&gt; I’m definitely for the concept of the proposal that this is inconsistent,<br>&gt; but I’m also definitely for making this explicitly disallowed everywhere,<br>&gt; not allowed everywhere.<br>&gt;<br>&gt; I think Erica makes a good point about syntax too, we’ve been assuming:<br>&gt;<br>&gt;   // compatible types<br>&gt;   var x = drawLineTo<br>&gt;   x = drawLineWith<br>&gt;<br>&gt; but really this isn’t Swifty syntax, the full argument labels provide more<br>&gt; clarity here; and I’d even be in favor of disallowing the above shortening.<br>&gt;<br>&gt; Scott<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/ebd715a1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 30, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 1:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Jun 30, 2016 at 11:43 AM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; -1<br>&gt; <br>&gt; This proposal doesn’t even use Swift naming style to make its point, as soon as you do, the reason why Swift considers argument labels to be part of the type signature becomes apparent.<br>&gt; <br>&gt; The author of the proposal uses the following example:<br>&gt; <br>&gt;   func doSomething(x: Int, y: Int) -&gt; Bool<br>&gt; <br>&gt; <br>&gt; This is just not Swift-y, a much better example would be:<br>&gt; <br>&gt;   func sinkBattleship(atX x: Int, y: Int) -&gt; Bool<br>&gt; <br>&gt; the proposal states that the argument labels be then stripped from the type, which would make this method type-compatible with:<br>&gt; <br>&gt;   func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool<br>&gt; <br>&gt; They already *are* type compatible. This works right now:<br>&gt; <br>&gt; var a : (ofHits: Int, forRuns: Int) -&gt; Bool = meetsBattingAverage<br>&gt; a = sinkBattleship<br>&gt; // ???<br>&gt; a(ofHits: 1, forRuns: 2)<br></p><p>I’d prefer to tighten the system so that the above no longer compiles, rather than make it even more permissive.<br></p><p>-1.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/00395c9e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 11:43 AM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1<br>&gt; <br>&gt; This proposal doesn’t even use Swift naming style to make its point, as soon as you do, the reason why Swift considers argument labels to be part of the type signature becomes apparent. <br>&gt; <br>&gt; The author of the proposal uses the following example:<br>&gt; <br>&gt;  func doSomething(x: Int, y: Int) -&gt; Bool<br>&gt; <br>&gt; <br>&gt; This is just not Swift-y, a much better example would be:<br>&gt; <br>&gt;  func sinkBattleship(atX x: Int, y: Int) -&gt; Bool<br>&gt; <br></p><p>&lt;pedanticism&gt;<br>If you want to talk about pedantic following of API naming guidelines for example code, then I believe that your example also runs afoul. It would be:<br></p><p>func sinkBattleshipAt(x: Int, y: Int) -&gt; Bool<br></p><p>Due to a special case where the preposition covers multiple arguments. This arrises mostly from flatten-ed structs as parameters, e.g. from old C APIs predating struct literal syntax. See:<br></p><p>An exception arises when the first two arguments represent parts of a single abstraction.<br></p><p>a.move(toX: b, y: c)<br>a.fade(fromRed: b, green: c, blue: d)<br>In such cases, begin the argument label after the preposition, to keep the abstraction clear.<br></p><p>a.moveTo(x: b, y: c)<br>a.fadeFrom(red: b, green: c, blue: d)<br></p><p>&lt;/pedanticism&gt;<br></p><p><br></p><p><br>&gt; the proposal states that the argument labels be then stripped from the type, which would make this method type-compatible with:<br>&gt; <br>&gt;  func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool<br>&gt; <br>&gt; <br>&gt; I don’t think it’s desirable for this to work at all… Argument labels are not parameter names, they are a first class part of Swift’s type system, and always meaningful when employed properly.<br>&gt; <br>&gt; <br>&gt; Scott<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/06c98dd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>I would think that the naming guidelines are an argument for reducing the<br>role of argument labels, if any.<br></p><p>This labeled tuple makes sense, because &#39;x&#39; and &#39;y&#39; describe the semantic<br>meaning of each element (Int which represents an x-coordinate):<br></p><p>let myTuple: (x: Int, y: Int)<br></p><p>This also makes sense, because &#39;hits&#39; and &#39;runs&#39; describe the semantic<br>meaning of each argument (Int which represents number of hits):<br></p><p>let a : (hits: Int, runs: Int) -&gt; Bool<br></p><p>This makes absolutely no sense to me:<br></p><p>let b: (ofHits: Int, forRuns: Int) -&gt; Bool<br></p><p>In fact, &#39;b&#39; is a better example than the average, because of the naming<br>guideline point to spell out the semantics of weakly typed arguments in the<br>argument label.<br></p><p>func getWidget(for provider: Provider, with manifest: ShippingManifest) -&gt;<br>Widget { /* ... */ }<br></p><p>let widgetGetter : (for: Provider, with: ShippingManifest) = getWidget<br></p><p>At this point, the labels are completely superfluous. They make no sense<br>except in the context of a method name, because they are prepositional<br>phrases. Knowing that the Provider is &quot;for&quot; something and something does<br>something &quot;with&quot; the ShippingManifest is absolutely useless to anyone<br>reading the code where the method name those labels are part of isn&#39;t<br>immediately obvious.<br></p><p>Austin<br></p><p>On Thu, Jun 30, 2016 at 3:33 PM, Michael Ilseman via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 30, 2016, at 11:43 AM, Scott James Remnant via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; -1<br>&gt;<br>&gt; This proposal doesn’t even use Swift naming style to make its point, as<br>&gt; soon as you do, the reason why Swift considers argument labels to be part<br>&gt; of the type signature becomes apparent.<br>&gt;<br>&gt; The author of the proposal uses the following example:<br>&gt;<br>&gt;  func doSomething(x: Int, y: Int) -&gt; Bool<br>&gt;<br>&gt;<br>&gt; This is just not Swift-y, a much better example would be:<br>&gt;<br>&gt;  func sinkBattleship(atX x: Int, y: Int) -&gt; Bool<br>&gt;<br>&gt;<br>&gt; &lt;pedanticism&gt;<br>&gt; If you want to talk about pedantic following of API naming guidelines for<br>&gt; example code, then I believe that your example also runs afoul. It would be:<br>&gt;<br>&gt; func sinkBattleshipAt(x: Int, y: Int) -&gt; Bool<br>&gt;<br>&gt; Due to a special case where the preposition covers multiple arguments.<br>&gt; This arrises mostly from flatten-ed structs as parameters, e.g. from old C<br>&gt; APIs predating struct literal syntax. See:<br>&gt;<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    An exception arises when the first two arguments represent parts of a<br>&gt;    single abstraction.<br>&gt;<br>&gt;    a.move(*toX:* b, *y:* c)<br>&gt;    a.fade(*fromRed:* b, *green:* c, *blue:* d)<br>&gt;<br>&gt;    In such cases, begin the argument label *after* the preposition, to<br>&gt;    keep the abstraction clear.<br>&gt;<br>&gt;    a.moveTo(*x:* b, *y:* c)<br>&gt;    a.fadeFrom(*red:* b, *green:* c, *blue:* d)<br>&gt;<br>&gt;<br>&gt;<br>&gt; &lt;/pedanticism&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; the proposal states that the argument labels be then stripped from the<br>&gt; type, which would make this method type-compatible with:<br>&gt;<br>&gt;  func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool<br>&gt;<br>&gt;<br>&gt; I don’t think it’s desirable for this to work at all… Argument labels are<br>&gt; not parameter names, they are a first class part of Swift’s type system,<br>&gt; and always meaningful when employed properly.<br>&gt;<br>&gt;<br>&gt; Scott<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/48e95e5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>I didn’t see the pre-proposal, and I apologize if this has come up elsewhere on this list, but did you consider the alternative where you must use the compound name to refer to a function? That is:<br></p><p>func foo(a: A, b: B) -&gt; C<br>func bar(from: A, using: B) -&gt; C<br>let higherOrderABToC: (A, B) -&gt; C = foo(a:b:)<br>higherOrderABToC = bar(from:using:)<br></p><p>That is, “foo” by itself is an incomplete name, and you must provide the full compound name. This will penalize convenience of references to functions, though you will simplify the overloading logic of functions: two functions are not overloaded if their full compound names differ. This can be thought of as taking SE0021 and running wild, enforcing that all naming of functions use the compound name.<br></p><p>The notion of providing the name of a function with a full compound name is increasingly common in Swift, with SE0021 generalized naming, improvements to swift_name, SE0044 import-as-member, etc.<br></p><p>To modify the example from later in the proposal:<br></p><p>func doSomething(x: Int, y: Int) -&gt; Bool {<br>    return x == y<br>}<br></p><p>func somethingElse(a: Int, b: Int) -&gt; Bool {<br>    return a &gt; b<br>}<br></p><p>// fn2&#39;s type is (Int, Int) -&gt; Bool<br>var fn2 = doSomething(x:y:)<br></p><p>// Okay<br>fn2(1, 2)<br></p><p>// Okay<br>fn2 = somethingElse(a:b:)<br></p><p>The notion here, is that we’re not just dropping argument labels from the type system, but instead we’re hoisting such concerns into the syntax by making them an intrinsic part of the name. Then, if you bind to it with a value, that value of course wouldn’t be called with labels because labels are not part of its name.<br></p><p>If this is unwieldy, then it’s worth stating how this behaves in the presence of functions overloaded based on argument label alone, as Erica mentions.<br></p><p><br>&gt; On Jun 30, 2016, at 3:43 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I would think that the naming guidelines are an argument for reducing the role of argument labels, if any.<br>&gt; <br>&gt; This labeled tuple makes sense, because &#39;x&#39; and &#39;y&#39; describe the semantic meaning of each element (Int which represents an x-coordinate):<br>&gt; <br>&gt; let myTuple: (x: Int, y: Int)<br>&gt; <br>&gt; This also makes sense, because &#39;hits&#39; and &#39;runs&#39; describe the semantic meaning of each argument (Int which represents number of hits):<br>&gt; <br>&gt; let a : (hits: Int, runs: Int) -&gt; Bool<br>&gt; <br>&gt; This makes absolutely no sense to me:<br>&gt; <br>&gt; let b: (ofHits: Int, forRuns: Int) -&gt; Bool<br>&gt; <br>&gt; In fact, &#39;b&#39; is a better example than the average, because of the naming guideline point to spell out the semantics of weakly typed arguments in the argument label.<br>&gt; <br>&gt; func getWidget(for provider: Provider, with manifest: ShippingManifest) -&gt; Widget { /* ... */ }<br>&gt; <br>&gt; let widgetGetter : (for: Provider, with: ShippingManifest) = getWidget<br>&gt; <br>&gt; At this point, the labels are completely superfluous. They make no sense except in the context of a method name, because they are prepositional phrases. Knowing that the Provider is &quot;for&quot; something and something does something &quot;with&quot; the ShippingManifest is absolutely useless to anyone reading the code where the method name those labels are part of isn&#39;t immediately obvious.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Thu, Jun 30, 2016 at 3:33 PM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 11:43 AM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1<br>&gt;&gt; <br>&gt;&gt; This proposal doesn’t even use Swift naming style to make its point, as soon as you do, the reason why Swift considers argument labels to be part of the type signature becomes apparent. <br>&gt;&gt; <br>&gt;&gt; The author of the proposal uses the following example:<br>&gt;&gt; <br>&gt;&gt;  func doSomething(x: Int, y: Int) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is just not Swift-y, a much better example would be:<br>&gt;&gt; <br>&gt;&gt;  func sinkBattleship(atX x: Int, y: Int) -&gt; Bool<br>&gt;&gt; <br>&gt; <br>&gt; &lt;pedanticism&gt;<br>&gt; If you want to talk about pedantic following of API naming guidelines for example code, then I believe that your example also runs afoul. It would be:<br>&gt; <br>&gt; func sinkBattleshipAt(x: Int, y: Int) -&gt; Bool<br>&gt; <br>&gt; Due to a special case where the preposition covers multiple arguments. This arrises mostly from flatten-ed structs as parameters, e.g. from old C APIs predating struct literal syntax. See:<br>&gt; <br>&gt; An exception arises when the first two arguments represent parts of a single abstraction.<br>&gt; <br>&gt; a.move(toX: b, y: c)<br>&gt; a.fade(fromRed: b, green: c, blue: d)<br>&gt; In such cases, begin the argument label after the preposition, to keep the abstraction clear.<br>&gt; <br>&gt; a.moveTo(x: b, y: c)<br>&gt; a.fadeFrom(red: b, green: c, blue: d)<br>&gt; <br>&gt; &lt;/pedanticism&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; the proposal states that the argument labels be then stripped from the type, which would make this method type-compatible with:<br>&gt;&gt; <br>&gt;&gt;  func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I don’t think it’s desirable for this to work at all… Argument labels are not parameter names, they are a first class part of Swift’s type system, and always meaningful when employed properly.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Scott<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/ff4b4a66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>As an addendum to this:<br></p><p>If it’s important that the variable be invoked with argument labels, that can be provided by having argument labels as part of the variable’s name:<br></p><p>func foo(a: A, b: B) -&gt; C<br>func bar(from: A, using: B) -&gt; C<br>// ...<br>let myA : A = …<br>let myB : B = ...<br>var higherOrderABToC(with:until:) : (A, B) -&gt; C = foo(a:b:)<br>var myC = higherOrderABToC(with: myA, until: myB)<br>higherOrderABToC = bar(from:using:)<br>myC = higherOrderABToC(with: myA, until: myB)<br></p><p><br></p><p>&gt; On Jun 30, 2016, at 4:16 PM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I didn’t see the pre-proposal, and I apologize if this has come up elsewhere on this list, but did you consider the alternative where you must use the compound name to refer to a function? That is:<br>&gt; <br>&gt; func foo(a: A, b: B) -&gt; C<br>&gt; func bar(from: A, using: B) -&gt; C<br>&gt; let higherOrderABToC: (A, B) -&gt; C = foo(a:b:)<br>&gt; higherOrderABToC = bar(from:using:)<br>&gt; <br>&gt; That is, “foo” by itself is an incomplete name, and you must provide the full compound name. This will penalize convenience of references to functions, though you will simplify the overloading logic of functions: two functions are not overloaded if their full compound names differ. This can be thought of as taking SE0021 and running wild, enforcing that all naming of functions use the compound name.<br>&gt; <br>&gt; The notion of providing the name of a function with a full compound name is increasingly common in Swift, with SE0021 generalized naming, improvements to swift_name, SE0044 import-as-member, etc.<br>&gt; <br>&gt; To modify the example from later in the proposal:<br>&gt; <br>&gt; func doSomething(x: Int, y: Int) -&gt; Bool {<br>&gt;     return x == y<br>&gt; }<br>&gt; <br>&gt; func somethingElse(a: Int, b: Int) -&gt; Bool {<br>&gt;     return a &gt; b<br>&gt; }<br>&gt; <br>&gt; // fn2&#39;s type is (Int, Int) -&gt; Bool<br>&gt; var fn2 = doSomething(x:y:)<br>&gt; <br>&gt; // Okay<br>&gt; fn2(1, 2)<br>&gt; <br>&gt; // Okay<br>&gt; fn2 = somethingElse(a:b:)<br>&gt; <br>&gt; The notion here, is that we’re not just dropping argument labels from the type system, but instead we’re hoisting such concerns into the syntax by making them an intrinsic part of the name. Then, if you bind to it with a value, that value of course wouldn’t be called with labels because labels are not part of its name.<br>&gt; <br>&gt; If this is unwieldy, then it’s worth stating how this behaves in the presence of functions overloaded based on argument label alone, as Erica mentions.<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 3:43 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would think that the naming guidelines are an argument for reducing the role of argument labels, if any.<br>&gt;&gt; <br>&gt;&gt; This labeled tuple makes sense, because &#39;x&#39; and &#39;y&#39; describe the semantic meaning of each element (Int which represents an x-coordinate):<br>&gt;&gt; <br>&gt;&gt; let myTuple: (x: Int, y: Int)<br>&gt;&gt; <br>&gt;&gt; This also makes sense, because &#39;hits&#39; and &#39;runs&#39; describe the semantic meaning of each argument (Int which represents number of hits):<br>&gt;&gt; <br>&gt;&gt; let a : (hits: Int, runs: Int) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; This makes absolutely no sense to me:<br>&gt;&gt; <br>&gt;&gt; let b: (ofHits: Int, forRuns: Int) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; In fact, &#39;b&#39; is a better example than the average, because of the naming guideline point to spell out the semantics of weakly typed arguments in the argument label.<br>&gt;&gt; <br>&gt;&gt; func getWidget(for provider: Provider, with manifest: ShippingManifest) -&gt; Widget { /* ... */ }<br>&gt;&gt; <br>&gt;&gt; let widgetGetter : (for: Provider, with: ShippingManifest) = getWidget<br>&gt;&gt; <br>&gt;&gt; At this point, the labels are completely superfluous. They make no sense except in the context of a method name, because they are prepositional phrases. Knowing that the Provider is &quot;for&quot; something and something does something &quot;with&quot; the ShippingManifest is absolutely useless to anyone reading the code where the method name those labels are part of isn&#39;t immediately obvious.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 30, 2016 at 3:33 PM, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 11:43 AM, Scott James Remnant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal doesn’t even use Swift naming style to make its point, as soon as you do, the reason why Swift considers argument labels to be part of the type signature becomes apparent. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The author of the proposal uses the following example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func doSomething(x: Int, y: Int) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is just not Swift-y, a much better example would be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func sinkBattleship(atX x: Int, y: Int) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &lt;pedanticism&gt;<br>&gt;&gt; If you want to talk about pedantic following of API naming guidelines for example code, then I believe that your example also runs afoul. It would be:<br>&gt;&gt; <br>&gt;&gt; func sinkBattleshipAt(x: Int, y: Int) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; Due to a special case where the preposition covers multiple arguments. This arrises mostly from flatten-ed structs as parameters, e.g. from old C APIs predating struct literal syntax. See:<br>&gt;&gt; <br>&gt;&gt; An exception arises when the first two arguments represent parts of a single abstraction.<br>&gt;&gt; <br>&gt;&gt; a.move(toX: b, y: c)<br>&gt;&gt; a.fade(fromRed: b, green: c, blue: d)<br>&gt;&gt; In such cases, begin the argument label after the preposition, to keep the abstraction clear.<br>&gt;&gt; <br>&gt;&gt; a.moveTo(x: b, y: c)<br>&gt;&gt; a.fadeFrom(red: b, green: c, blue: d)<br>&gt;&gt; <br>&gt;&gt; &lt;/pedanticism&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; the proposal states that the argument labels be then stripped from the type, which would make this method type-compatible with:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func meetsBattingAverage(ofHits hits: Int, forRuns runs: Int) -&gt; Bool<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think it’s desirable for this to work at all… Argument labels are not parameter names, they are a first class part of Swift’s type system, and always meaningful when employed properly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Scott<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/95f199c2/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 30 Jun 2016, at 20:26, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>-1<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, but I do not think that the proposed solution is the correct one. Rather, one should aim for designing a proper tuple type. Right now, tuples seem more like an afterthought even though they play a significant role in the language.  Proper tuple casting/extensions/tuple algebra will solve the issues pointed out in this proposal, among other useful applications. <br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I do not believe so<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A glance<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 30, 2016 at 02:00:00pm</p></header><div class="content"><p>On Thu, Jun 30, 2016 at 2:14 PM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 30 Jun 2016, at 20:26, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt; available here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; -1<br>&gt;<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; Yes, but I do not think that the proposed solution is the correct one.<br>&gt; Rather, one should aim for designing a proper tuple type. Right now, tuples<br>&gt; seem more like an afterthought even though they play a significant role in<br>&gt; the language.  Proper tuple casting/extensions/tuple algebra will solve the<br>&gt; issues pointed out in this proposal, among other useful applications.<br>&gt;<br></p><p>Taras, I don&#39;t believe this proposal touches tuples in any way. IIUC,<br>argument lists are no longer tuples and have not been for a long time, and<br>there is no intention on the part of the core team to return to that state<br>of affairs.<br></p><p><br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; I do not believe so<br>&gt;<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; A glance<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/0ff88089/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 30 Jun 2016, at 21:20, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Jun 30, 2016 at 2:14 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On 30 Jun 2016, at 20:26, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt; &gt;<br>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt; <br>&gt; -1<br>&gt; <br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, but I do not think that the proposed solution is the correct one. Rather, one should aim for designing a proper tuple type. Right now, tuples seem more like an afterthought even though they play a significant role in the language.  Proper tuple casting/extensions/tuple algebra will solve the issues pointed out in this proposal, among other useful applications.<br>&gt; <br>&gt; Taras, I don&#39;t believe this proposal touches tuples in any way. IIUC, argument lists are no longer tuples and have not been for a long time, and there is no intention on the part of the core team to return to that state of affairs.<br></p><p>Still, there is a clear correspondence between tuples and argument lists. I though that the model of functions as maps from tuples to tuples was very elegant, but I understand why this model was dropped. However tuples seem to be somehow misplaced right now, and this fact resonates through the entire language system (function types, enums, pattern matching etc.). I think one should stop and reconsider tuple status first to get a sense of a ‚grand strategy‘ for Swift. I am worried that small changes like this proposal attempt to deal with the ripples cast by a much deeper problem instead of the problem itself. As far as I am considered, there are two basic options. Either say, well, tuples were a nice idea, but it doesn’t really work out — and then consistently apply this to the entire language. Or, reinstate that tuples are a modelling construct on which a lot of language concepts are based and try to fix the underlaying limitations. Function arguments don’t need to be tuples formally. However, why not have a casting system that allows one to transform between function signatures and tuple types?  That would certainly solve the deficients Swift is experiencing now as well as allow greater flexibility in the future. <br></p><p>And orthogonally to the tuple topic, I think that argument labels carry meaningful semantics and are much more than just cosmetic devices. Accepting this proposal would make the language weird. The deeper connection between the semantics of the argument list and the exposed type would be disturbed. <br></p><p>Hope any of this has made any sense :)<br></p><p>&gt;  <br>&gt; <br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; I do not believe so<br>&gt; <br>&gt; &gt;       * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; A glance<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/8f16b1d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 30, 2016 at 01:00:00pm</p></header><div class="content"><p>This is a false dichotomy. The language can support tuples without<br>requiring that function application be modeled in terms of tuples. That<br>ship has sailed long ago, and there is no reason to revisit it without a<br>compelling reason (and &quot;function argument lists look sort of like tuples&quot;<br>is not to me compelling).<br></p><p>As for the label semantics, Swift&#39;s current behavior is actively<br>misleading, please see the example in the prior email. There are no<br>meaningful semantics in the label, because implicit conversion between<br>differently-labeled function types means that there is no way to usefully<br>enforce these invariants to begin with.<br></p><p>On Thu, Jun 30, 2016 at 12:42 PM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 30 Jun 2016, at 21:20, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Thu, Jun 30, 2016 at 2:14 PM, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On 30 Jun 2016, at 20:26, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello Swift community,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt; available here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; -1<br>&gt;&gt;<br>&gt;&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?<br>&gt;&gt;<br>&gt;&gt; Yes, but I do not think that the proposed solution is the correct one.<br>&gt;&gt; Rather, one should aim for designing a proper tuple type. Right now, tuples<br>&gt;&gt; seem more like an afterthought even though they play a significant role in<br>&gt;&gt; the language.  Proper tuple casting/extensions/tuple algebra will solve the<br>&gt;&gt; issues pointed out in this proposal, among other useful applications.<br>&gt;&gt;<br>&gt;<br>&gt; Taras, I don&#39;t believe this proposal touches tuples in any way. IIUC,<br>&gt; argument lists are no longer tuples and have not been for a long time, and<br>&gt; there is no intention on the part of the core team to return to that state<br>&gt; of affairs.<br>&gt;<br>&gt;<br>&gt; Still, there is a clear correspondence between tuples and argument lists.<br>&gt; I though that the model of functions as maps from tuples to tuples was very<br>&gt; elegant, but I understand why this model was dropped. However tuples seem<br>&gt; to be somehow misplaced right now, and this fact resonates through the<br>&gt; entire language system (function types, enums, pattern matching etc.). I<br>&gt; think one should stop and reconsider tuple status first to get a sense of a<br>&gt; ‚grand strategy‘ for Swift. I am worried that small changes like this<br>&gt; proposal attempt to deal with the ripples cast by a much deeper problem<br>&gt; instead of the problem itself. As far as I am considered, there are two<br>&gt; basic options. Either say, well, tuples were a nice idea, but it doesn’t<br>&gt; really work out — and then consistently apply this to the entire language.<br>&gt; Or, reinstate that tuples are a modelling construct on which a lot of<br>&gt; language concepts are based and try to fix the underlaying limitations.<br>&gt; Function arguments don’t need to be tuples formally. However, why not have<br>&gt; a casting system that allows one to transform between function signatures<br>&gt; and tuple types?  That would certainly solve the deficients Swift is<br>&gt; experiencing now as well as allow greater flexibility in the future.<br>&gt;<br>&gt; And orthogonally to the tuple topic, I think that argument labels carry<br>&gt; meaningful semantics and are much more than just cosmetic devices.<br>&gt; Accepting this proposal would make the language weird. The deeper<br>&gt; connection between the semantics of the argument list and the exposed type<br>&gt; would be disturbed.<br>&gt;<br>&gt; Hope any of this has made any sense :)<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of<br>&gt;&gt; Swift?<br>&gt;&gt;<br>&gt;&gt; I do not believe so<br>&gt;&gt;<br>&gt;&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; A glance<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/4ff391c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>June 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; As for the label semantics, Swift&#39;s current behavior is actively misleading, please see the example in the prior email. There are no meaningful semantics in the label, because implicit conversion between differently-labeled function types means that there is no way to usefully enforce these invariants to begin with.<br></p><p>That is a good point. I admit to not knowing this (I strongly expected that labels would be semantically meaningful). But what exactly is the status of the argument labels than in Swift? Just a documentation device  for the programmer and a  hint for the compiler to do function dispatch? But if the compiler indeed does dispatch on argument labels, then they are not completely void of semantics, are they?  As I mentioned before, I think the problem here is much deeper. <br></p><p>The state of affairs I would prefer is something along these lines:<br></p><p>1. Labels are semantically meaningful<br>2. There is an explicit casting system for function signatures<br>3. This casting system should be in close correspondence to tuples. The &quot;function argument lists look sort of like tuples“ is a very compelling reason actually, because of the principle of the least surprise. If I have two things in the language that look very similar, then its very confusing if they  exhibit very different behaviour. Again, I am not proposing that one goes back to model functions in terms of tuples. But as long as there is a surface resemblance (and an obvious morphisms between the two), at least some aspects of their design should be kept in sync. <br></p><p>But again, this touches on some deep design decisions for the language, so I — as an amateur — don’t feel in my plate discussing this here. I believe that there currently might be some inconsistencies in the language design that should be sealed with (but maybe they are no inconsistencies at all and I simply have false expectations). <br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; <br>&gt; On Thu, Jun 30, 2016 at 12:42 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 30 Jun 2016, at 21:20, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 30, 2016 at 2:14 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On 30 Jun 2016, at 20:26, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello Swift community,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; -1<br>&gt;&gt; <br>&gt;&gt; &gt;       * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, but I do not think that the proposed solution is the correct one. Rather, one should aim for designing a proper tuple type. Right now, tuples seem more like an afterthought even though they play a significant role in the language.  Proper tuple casting/extensions/tuple algebra will solve the issues pointed out in this proposal, among other useful applications.<br>&gt;&gt; <br>&gt;&gt; Taras, I don&#39;t believe this proposal touches tuples in any way. IIUC, argument lists are no longer tuples and have not been for a long time, and there is no intention on the part of the core team to return to that state of affairs.<br>&gt; <br>&gt; Still, there is a clear correspondence between tuples and argument lists. I though that the model of functions as maps from tuples to tuples was very elegant, but I understand why this model was dropped. However tuples seem to be somehow misplaced right now, and this fact resonates through the entire language system (function types, enums, pattern matching etc.). I think one should stop and reconsider tuple status first to get a sense of a ‚grand strategy‘ for Swift. I am worried that small changes like this proposal attempt to deal with the ripples cast by a much deeper problem instead of the problem itself. As far as I am considered, there are two basic options. Either say, well, tuples were a nice idea, but it doesn’t really work out — and then consistently apply this to the entire language. Or, reinstate that tuples are a modelling construct on which a lot of language concepts are based and try to fix the underlaying limitations. Function arguments don’t need to be tuples formally. However, why not have a casting system that allows one to transform between function signatures and tuple types?  That would certainly solve the deficients Swift is experiencing now as well as allow greater flexibility in the future. <br>&gt; <br>&gt; And orthogonally to the tuple topic, I think that argument labels carry meaningful semantics and are much more than just cosmetic devices. Accepting this proposal would make the language weird. The deeper connection between the semantics of the argument list and the exposed type would be disturbed. <br>&gt; <br>&gt; Hope any of this has made any sense :)<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; I do not believe so<br>&gt;&gt; <br>&gt;&gt; &gt;       * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; A glance<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/b672c7b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 30, 2016 at 01:00:00pm</p></header><div class="content"><p>You might like the alternative I added (<br>https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md).<br>It basically goes the other way: keep the semantic significance of labels,<br>and make them mean something by prohibiting converting between different<br>function types with the same types but different labels.<br></p><p>On Thu, Jun 30, 2016 at 1:36 PM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; As for the label semantics, Swift&#39;s current behavior is actively<br>&gt; misleading, please see the example in the prior email. There are no<br>&gt; meaningful semantics in the label, because implicit conversion between<br>&gt; differently-labeled function types means that there is no way to usefully<br>&gt; enforce these invariants to begin with.<br>&gt;<br>&gt;<br>&gt; That is a good point. I admit to not knowing this (I strongly expected<br>&gt; that labels would be semantically meaningful). But what exactly is the<br>&gt; status of the argument labels than in Swift? Just a documentation device<br>&gt;  for the programmer and a  hint for the compiler to do function dispatch?<br>&gt; But if the compiler indeed does dispatch on argument labels, then they are<br>&gt; not completely void of semantics, are they?  As I mentioned before, I think<br>&gt; the problem here is much deeper.<br>&gt;<br>&gt; The state of affairs I would prefer is something along these lines:<br>&gt;<br>&gt; 1. Labels are semantically meaningful<br>&gt; 2. There is an explicit casting system for function signatures<br>&gt; 3. This casting system should be in close correspondence to tuples. The<br>&gt; &quot;function argument lists look sort of like tuples“ is a very compelling<br>&gt; reason actually, because of the principle of the least surprise. If I have<br>&gt; two things in the language that look very similar, then its very confusing<br>&gt; if they  exhibit very different behaviour. Again, I am not proposing that<br>&gt; one goes back to model functions in terms of tuples. But as long as there<br>&gt; is a surface resemblance (and an obvious morphisms between the two), at<br>&gt; least some aspects of their design should be kept in sync.<br>&gt;<br>&gt; But again, this touches on some deep design decisions for the language, so<br>&gt; I — as an amateur — don’t feel in my plate discussing this here. I believe<br>&gt; that there currently might be some inconsistencies in the language design<br>&gt; that should be sealed with (but maybe they are no inconsistencies at all<br>&gt; and I simply have false expectations).<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 30, 2016 at 12:42 PM, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 30 Jun 2016, at 21:20, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 30, 2016 at 2:14 PM, Taras Zakharko via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On 30 Jun 2016, at 20:26, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Hello Swift community,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt; available here:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, but I do not think that the proposed solution is the correct one.<br>&gt;&gt;&gt; Rather, one should aim for designing a proper tuple type. Right now, tuples<br>&gt;&gt;&gt; seem more like an afterthought even though they play a significant role in<br>&gt;&gt;&gt; the language.  Proper tuple casting/extensions/tuple algebra will solve the<br>&gt;&gt;&gt; issues pointed out in this proposal, among other useful applications.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Taras, I don&#39;t believe this proposal touches tuples in any way. IIUC,<br>&gt;&gt; argument lists are no longer tuples and have not been for a long time, and<br>&gt;&gt; there is no intention on the part of the core team to return to that state<br>&gt;&gt; of affairs.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Still, there is a clear correspondence between tuples and argument lists.<br>&gt;&gt; I though that the model of functions as maps from tuples to tuples was very<br>&gt;&gt; elegant, but I understand why this model was dropped. However tuples seem<br>&gt;&gt; to be somehow misplaced right now, and this fact resonates through the<br>&gt;&gt; entire language system (function types, enums, pattern matching etc.). I<br>&gt;&gt; think one should stop and reconsider tuple status first to get a sense of a<br>&gt;&gt; ‚grand strategy‘ for Swift. I am worried that small changes like this<br>&gt;&gt; proposal attempt to deal with the ripples cast by a much deeper problem<br>&gt;&gt; instead of the problem itself. As far as I am considered, there are two<br>&gt;&gt; basic options. Either say, well, tuples were a nice idea, but it doesn’t<br>&gt;&gt; really work out — and then consistently apply this to the entire language.<br>&gt;&gt; Or, reinstate that tuples are a modelling construct on which a lot of<br>&gt;&gt; language concepts are based and try to fix the underlaying limitations.<br>&gt;&gt; Function arguments don’t need to be tuples formally. However, why not have<br>&gt;&gt; a casting system that allows one to transform between function signatures<br>&gt;&gt; and tuple types?  That would certainly solve the deficients Swift is<br>&gt;&gt; experiencing now as well as allow greater flexibility in the future.<br>&gt;&gt;<br>&gt;&gt; And orthogonally to the tuple topic, I think that argument labels carry<br>&gt;&gt; meaningful semantics and are much more than just cosmetic devices.<br>&gt;&gt; Accepting this proposal would make the language weird. The deeper<br>&gt;&gt; connection between the semantics of the argument list and the exposed type<br>&gt;&gt; would be disturbed.<br>&gt;&gt;<br>&gt;&gt; Hope any of this has made any sense :)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of<br>&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I do not believe so<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a<br>&gt;&gt;&gt; quick reading, or an in-depth study?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A glance<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/6081bc42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>June 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 30 Jun 2016, at 22:38, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; You might like the alternative I added (https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;). It basically goes the other way: keep the semantic significance of labels, and make them mean something by prohibiting converting between different function types with the same types but different labels.<br></p><p>Yes, thats what I would vote for! I would also add the possibility of explicitly converting between different labels, as long as the types match, e.g.:<br></p><p>battingAveragePredicate = sinkBattleship as ((ofHits: Int, forRuns: Int) -&gt; Bool)<br></p><p>or <br></p><p>battingAveragePredicate = sinkBattleship as typeof(battlingAveragePredicate)<br></p><p><br>(whatever the correct syntax for this would be).<br></p><p><br>Best, <br></p><p> t. <br></p><p><br></p><p><br>&gt; On Thu, Jun 30, 2016 at 1:36 PM, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As for the label semantics, Swift&#39;s current behavior is actively misleading, please see the example in the prior email. There are no meaningful semantics in the label, because implicit conversion between differently-labeled function types means that there is no way to usefully enforce these invariants to begin with.<br>&gt; <br>&gt; That is a good point. I admit to not knowing this (I strongly expected that labels would be semantically meaningful). But what exactly is the status of the argument labels than in Swift? Just a documentation device  for the programmer and a  hint for the compiler to do function dispatch? But if the compiler indeed does dispatch on argument labels, then they are not completely void of semantics, are they?  As I mentioned before, I think the problem here is much deeper. <br>&gt; <br>&gt; The state of affairs I would prefer is something along these lines:<br>&gt; <br>&gt; 1. Labels are semantically meaningful<br>&gt; 2. There is an explicit casting system for function signatures<br>&gt; 3. This casting system should be in close correspondence to tuples. The &quot;function argument lists look sort of like tuples“ is a very compelling reason actually, because of the principle of the least surprise. If I have two things in the language that look very similar, then its very confusing if they  exhibit very different behaviour. Again, I am not proposing that one goes back to model functions in terms of tuples. But as long as there is a surface resemblance (and an obvious morphisms between the two), at least some aspects of their design should be kept in sync. <br>&gt; <br>&gt; But again, this touches on some deep design decisions for the language, so I — as an amateur — don’t feel in my plate discussing this here. I believe that there currently might be some inconsistencies in the language design that should be sealed with (but maybe they are no inconsistencies at all and I simply have false expectations). <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 30, 2016 at 12:42 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Jun 2016, at 21:20, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 30, 2016 at 2:14 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On 30 Jun 2016, at 20:26, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Hello Swift community,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;       * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but I do not think that the proposed solution is the correct one. Rather, one should aim for designing a proper tuple type. Right now, tuples seem more like an afterthought even though they play a significant role in the language.  Proper tuple casting/extensions/tuple algebra will solve the issues pointed out in this proposal, among other useful applications.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Taras, I don&#39;t believe this proposal touches tuples in any way. IIUC, argument lists are no longer tuples and have not been for a long time, and there is no intention on the part of the core team to return to that state of affairs.<br>&gt;&gt; <br>&gt;&gt; Still, there is a clear correspondence between tuples and argument lists. I though that the model of functions as maps from tuples to tuples was very elegant, but I understand why this model was dropped. However tuples seem to be somehow misplaced right now, and this fact resonates through the entire language system (function types, enums, pattern matching etc.). I think one should stop and reconsider tuple status first to get a sense of a ‚grand strategy‘ for Swift. I am worried that small changes like this proposal attempt to deal with the ripples cast by a much deeper problem instead of the problem itself. As far as I am considered, there are two basic options. Either say, well, tuples were a nice idea, but it doesn’t really work out — and then consistently apply this to the entire language. Or, reinstate that tuples are a modelling construct on which a lot of language concepts are based and try to fix the underlaying limitations. Function arguments don’t need to be tuples formally. However, why not have a casting system that allows one to transform between function signatures and tuple types?  That would certainly solve the deficients Swift is experiencing now as well as allow greater flexibility in the future. <br>&gt;&gt; <br>&gt;&gt; And orthogonally to the tuple topic, I think that argument labels carry meaningful semantics and are much more than just cosmetic devices. Accepting this proposal would make the language weird. The deeper connection between the semantics of the argument list and the exposed type would be disturbed. <br>&gt;&gt; <br>&gt;&gt; Hope any of this has made any sense :)<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do not believe so<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;       * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; &gt;       * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A glance<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/d93473e8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 30, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 13:36, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As for the label semantics, Swift&#39;s current behavior is actively misleading, please see the example in the prior email. There are no meaningful semantics in the label, because implicit conversion between differently-labeled function types means that there is no way to usefully enforce these invariants to begin with.<br>&gt; <br>&gt; That is a good point. I admit to not knowing this (I strongly expected that labels would be semantically meaningful). But what exactly is the status of the argument labels than in Swift? Just a documentation device  for the programmer and a  hint for the compiler to do function dispatch? But if the compiler indeed does dispatch on argument labels, then they are not completely void of semantics, are they?  As I mentioned before, I think the problem here is much deeper. <br>&gt; <br>&gt; The state of affairs I would prefer is something along these lines:<br>&gt; <br>&gt; 1. Labels are semantically meaningful<br>&gt; 2. There is an explicit casting system for function signatures<br>&gt; 3. This casting system should be in close correspondence to tuples. The &quot;function argument lists look sort of like tuples“ is a very compelling reason actually, because of the principle of the least surprise. If I have two things in the language that look very similar, then its very confusing if they  exhibit very different behaviour. Again, I am not proposing that one goes back to model functions in terms of tuples. But as long as there is a surface resemblance (and an obvious morphisms between the two), at least some aspects of their design should be kept in sync. <br>&gt; <br>&gt; But again, this touches on some deep design decisions for the language, so I — as an amateur — don’t feel in my plate discussing this here. I believe that there currently might be some inconsistencies in the language design that should be sealed with (but maybe they are no inconsistencies at all and I simply have false expectations). <br></p><p>Language history, a.k.a. story time!<br></p><p>We started out with the “perfect” model of a function type being a map from a tuple to a tuple. Different argument labels were just overloads. It really was quite a simple model, other than not having 1-tuples. Well, and variadics and default values and trailing closures didn’t make sense anywhere but in functions, but still. Very simple.<br></p><p>(And inout. And autoclosure. And maybe a few more.)<br></p><p>Then we hit a snag: naming guidelines. We wanted argument labels to be something people felt comfortable using, something that would be encouraged over a sea of unlabeled arguments. But even before the Swift 3 naming conventions were hammered out, the natural names for argument labels didn’t seem to match the names you’d want to use in the function. So we split the names of parameters off from the names of tuple elements.<br></p><p>(This was precipitated by wanting to import Objective-C methods, but I think it would have come up regardless.)<br></p><p>As seen earlier in the thread, argument labels don’t make for good tuple element labels. Especially with the Swift 3 guidelines, argument labels usually don’t make sense without the context provided by the base name, and two methods that happen to share argument labels might not actually be very similar, while two methods that are duals of each other might have different argument labels due to, well, English (e.g. &#39;add(to:)&#39; vs. &#39;remove(from:)’).<br></p><p>The real blow, however, came with that very first idea: that we could treat methods with different argument labels as simple overloads in type. This led to poor diagnostics where the compiler couldn’t decide whether to believe the types or the argument labels, and might tell you you have the wrong argument labels rather than a type mismatch. For pretty much every Apple API, this was the wrong decision. On top of all that, it was really hard to refer to a method when you didn’t want to call it. (Most methods with the same base name still have unique labels, so you don’t need the types to disambiguate.)<br></p><p>So we introduced the notion of “full names”, which are the things you see written as ‘move(from:to:)` (and which are represented by DeclName in the compiler). Almost immediately diagnostics got better, testing optional protocol requirements got shorter, and a lot of compiler implementation got simpler.<br></p><p>And then we kind of got stuck here. We have full names used throughout the compiler, but tuple labels still appear in types. They’re still used in mangling. We got rid of the “tuple splat” feature, but still model out-of-order arguments as “tuple shuffles”. And we allow a number of conversions that look like they should be invalid, but aren’t.<br></p><p>(And it’s important that we continue allowing them, or at least some of them, because we want to be able to pass existing functions to things like map and reduce without worrying about conflicting labels.)<br></p><p>So we’ve given up the perfect ideal of tuple-to-tuple. But we did it because we value other things more than that ideal: variadics, default values, trailing closures, inout, autoclosure, distinct argument labels and parameter names, referencing a function by full name, and diagnostics that better match the user’s likely intent (particularly given the naming guidelines and existing libraries). I think that’s a worthwhile trade.<br></p><p>Jordan<br></p><p>P.S. Anyone is allowed to think this is not a worthwhile trade! But part of the purpose of this story is to show that we’re already 90% of the way towards making tuples and function arguments completely separate, even if they have similar syntax. This proposal gets us to maybe 95%.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/348ada16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July  1, 2016 at 08:00:00am</p></header><div class="content"><p>Great story! What gets us from 95% to 100%? :)<br></p><p>&gt; On 1 Jul 2016, at 05:33, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 13:36, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for the label semantics, Swift&#39;s current behavior is actively misleading, please see the example in the prior email. There are no meaningful semantics in the label, because implicit conversion between differently-labeled function types means that there is no way to usefully enforce these invariants to begin with.<br>&gt;&gt; <br>&gt;&gt; That is a good point. I admit to not knowing this (I strongly expected that labels would be semantically meaningful). But what exactly is the status of the argument labels than in Swift? Just a documentation device  for the programmer and a  hint for the compiler to do function dispatch? But if the compiler indeed does dispatch on argument labels, then they are not completely void of semantics, are they?  As I mentioned before, I think the problem here is much deeper. <br>&gt;&gt; <br>&gt;&gt; The state of affairs I would prefer is something along these lines:<br>&gt;&gt; <br>&gt;&gt; 1. Labels are semantically meaningful<br>&gt;&gt; 2. There is an explicit casting system for function signatures<br>&gt;&gt; 3. This casting system should be in close correspondence to tuples. The &quot;function argument lists look sort of like tuples“ is a very compelling reason actually, because of the principle of the least surprise. If I have two things in the language that look very similar, then its very confusing if they  exhibit very different behaviour. Again, I am not proposing that one goes back to model functions in terms of tuples. But as long as there is a surface resemblance (and an obvious morphisms between the two), at least some aspects of their design should be kept in sync. <br>&gt;&gt; <br>&gt;&gt; But again, this touches on some deep design decisions for the language, so I — as an amateur — don’t feel in my plate discussing this here. I believe that there currently might be some inconsistencies in the language design that should be sealed with (but maybe they are no inconsistencies at all and I simply have false expectations). <br>&gt; <br>&gt; Language history, a.k.a. story time!<br>&gt; <br>&gt; We started out with the “perfect” model of a function type being a map from a tuple to a tuple. Different argument labels were just overloads. It really was quite a simple model, other than not having 1-tuples. Well, and variadics and default values and trailing closures didn’t make sense anywhere but in functions, but still. Very simple.<br>&gt; <br>&gt; (And inout. And autoclosure. And maybe a few more.)<br>&gt; <br>&gt; Then we hit a snag: naming guidelines. We wanted argument labels to be something people felt comfortable using, something that would be encouraged over a sea of unlabeled arguments. But even before the Swift 3 naming conventions were hammered out, the natural names for argument labels didn’t seem to match the names you’d want to use in the function. So we split the names of parameters off from the names of tuple elements.<br>&gt; <br>&gt; (This was precipitated by wanting to import Objective-C methods, but I think it would have come up regardless.)<br>&gt; <br>&gt; As seen earlier in the thread, argument labels don’t make for good tuple element labels. Especially with the Swift 3 guidelines, argument labels usually don’t make sense without the context provided by the base name, and two methods that happen to share argument labels might not actually be very similar, while two methods that are duals of each other might have different argument labels due to, well, English (e.g. &#39;add(to:)&#39; vs. &#39;remove(from:)’).<br>&gt; <br>&gt; The real blow, however, came with that very first idea: that we could treat methods with different argument labels as simple overloads in type. This led to poor diagnostics where the compiler couldn’t decide whether to believe the types or the argument labels, and might tell you you have the wrong argument labels rather than a type mismatch. For pretty much every Apple API, this was the wrong decision. On top of all that, it was really hard to refer to a method when you didn’t want to call it. (Most methods with the same base name still have unique labels, so you don’t need the types to disambiguate.)<br>&gt; <br>&gt; So we introduced the notion of “full names”, which are the things you see written as ‘move(from:to:)` (and which are represented by DeclName in the compiler). Almost immediately diagnostics got better, testing optional protocol requirements got shorter, and a lot of compiler implementation got simpler.<br>&gt; <br>&gt; And then we kind of got stuck here. We have full names used throughout the compiler, but tuple labels still appear in types. They’re still used in mangling. We got rid of the “tuple splat” feature, but still model out-of-order arguments as “tuple shuffles”. And we allow a number of conversions that look like they should be invalid, but aren’t.<br>&gt; <br>&gt; (And it’s important that we continue allowing them, or at least some of them, because we want to be able to pass existing functions to things like map and reduce without worrying about conflicting labels.)<br>&gt; <br>&gt; So we’ve given up the perfect ideal of tuple-to-tuple. But we did it because we value other things more than that ideal: variadics, default values, trailing closures, inout, autoclosure, distinct argument labels and parameter names, referencing a function by full name, and diagnostics that better match the user’s likely intent (particularly given the naming guidelines and existing libraries). I think that’s a worthwhile trade.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. Anyone is allowed to think this is not a worthwhile trade! But part of the purpose of this story is to show that we’re already 90% of the way towards making tuples and function arguments completely separate, even if they have similar syntax. This proposal gets us to maybe 95%.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/90988d74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>Mostly I was just hedging my bets, but the main one I can think of is that enum cases still use tuples, which means they don’t have distinct argument labels and preserve the labels in switches. There’s also a bunch of implementation improvements we can make (like fixing mangling and printing of function types), but that’s not something swift-evolution cares about so much.<br></p><p>There are also some related things about how function arguments work that are probably better done the further we get here:<br>- Forwarding variadic parameters<br>- Generalized argument forwarding? That works with inout?<br>- Variadic generics<br></p><p>Someday!<br>Jordan<br></p><p><br>&gt; On Jun 30, 2016, at 23:18, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Great story! What gets us from 95% to 100%? :)<br>&gt; <br>&gt; On 1 Jul 2016, at 05:33, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 13:36, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for the label semantics, Swift&#39;s current behavior is actively misleading, please see the example in the prior email. There are no meaningful semantics in the label, because implicit conversion between differently-labeled function types means that there is no way to usefully enforce these invariants to begin with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is a good point. I admit to not knowing this (I strongly expected that labels would be semantically meaningful). But what exactly is the status of the argument labels than in Swift? Just a documentation device  for the programmer and a  hint for the compiler to do function dispatch? But if the compiler indeed does dispatch on argument labels, then they are not completely void of semantics, are they?  As I mentioned before, I think the problem here is much deeper. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The state of affairs I would prefer is something along these lines:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Labels are semantically meaningful<br>&gt;&gt;&gt; 2. There is an explicit casting system for function signatures<br>&gt;&gt;&gt; 3. This casting system should be in close correspondence to tuples. The &quot;function argument lists look sort of like tuples“ is a very compelling reason actually, because of the principle of the least surprise. If I have two things in the language that look very similar, then its very confusing if they  exhibit very different behaviour. Again, I am not proposing that one goes back to model functions in terms of tuples. But as long as there is a surface resemblance (and an obvious morphisms between the two), at least some aspects of their design should be kept in sync. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But again, this touches on some deep design decisions for the language, so I — as an amateur — don’t feel in my plate discussing this here. I believe that there currently might be some inconsistencies in the language design that should be sealed with (but maybe they are no inconsistencies at all and I simply have false expectations). <br>&gt;&gt; <br>&gt;&gt; Language history, a.k.a. story time!<br>&gt;&gt; <br>&gt;&gt; We started out with the “perfect” model of a function type being a map from a tuple to a tuple. Different argument labels were just overloads. It really was quite a simple model, other than not having 1-tuples. Well, and variadics and default values and trailing closures didn’t make sense anywhere but in functions, but still. Very simple.<br>&gt;&gt; <br>&gt;&gt; (And inout. And autoclosure. And maybe a few more.)<br>&gt;&gt; <br>&gt;&gt; Then we hit a snag: naming guidelines. We wanted argument labels to be something people felt comfortable using, something that would be encouraged over a sea of unlabeled arguments. But even before the Swift 3 naming conventions were hammered out, the natural names for argument labels didn’t seem to match the names you’d want to use in the function. So we split the names of parameters off from the names of tuple elements.<br>&gt;&gt; <br>&gt;&gt; (This was precipitated by wanting to import Objective-C methods, but I think it would have come up regardless.)<br>&gt;&gt; <br>&gt;&gt; As seen earlier in the thread, argument labels don’t make for good tuple element labels. Especially with the Swift 3 guidelines, argument labels usually don’t make sense without the context provided by the base name, and two methods that happen to share argument labels might not actually be very similar, while two methods that are duals of each other might have different argument labels due to, well, English (e.g. &#39;add(to:)&#39; vs. &#39;remove(from:)’).<br>&gt;&gt; <br>&gt;&gt; The real blow, however, came with that very first idea: that we could treat methods with different argument labels as simple overloads in type. This led to poor diagnostics where the compiler couldn’t decide whether to believe the types or the argument labels, and might tell you you have the wrong argument labels rather than a type mismatch. For pretty much every Apple API, this was the wrong decision. On top of all that, it was really hard to refer to a method when you didn’t want to call it. (Most methods with the same base name still have unique labels, so you don’t need the types to disambiguate.)<br>&gt;&gt; <br>&gt;&gt; So we introduced the notion of “full names”, which are the things you see written as ‘move(from:to:)` (and which are represented by DeclName in the compiler). Almost immediately diagnostics got better, testing optional protocol requirements got shorter, and a lot of compiler implementation got simpler.<br>&gt;&gt; <br>&gt;&gt; And then we kind of got stuck here. We have full names used throughout the compiler, but tuple labels still appear in types. They’re still used in mangling. We got rid of the “tuple splat” feature, but still model out-of-order arguments as “tuple shuffles”. And we allow a number of conversions that look like they should be invalid, but aren’t.<br>&gt;&gt; <br>&gt;&gt; (And it’s important that we continue allowing them, or at least some of them, because we want to be able to pass existing functions to things like map and reduce without worrying about conflicting labels.)<br>&gt;&gt; <br>&gt;&gt; So we’ve given up the perfect ideal of tuple-to-tuple. But we did it because we value other things more than that ideal: variadics, default values, trailing closures, inout, autoclosure, distinct argument labels and parameter names, referencing a function by full name, and diagnostics that better match the user’s likely intent (particularly given the naming guidelines and existing libraries). I think that’s a worthwhile trade.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. Anyone is allowed to think this is not a worthwhile trade! But part of the purpose of this story is to show that we’re already 90% of the way towards making tuples and function arguments completely separate, even if they have similar syntax. This proposal gets us to maybe 95%.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/f86be491/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>Jordan, Thanks for the very insightful explanation! It all makes a lot of sense in perspective. <br></p><p>Apparently I was thinking about this issue a bit while I was sleeping, and now it seems to me that part of the problem is because one strives for the function signature to be linguistically meaningful (as in natural language meaningful). It was mentioned that argument labels often don’t make much sense when detached from the function name, and that some function seem to have semantically compatible signatures and some don’t, e.g. the example of  drawLineTo(x: Float, y: Float) and drawLineWith(angle: Float, distance: Float)<br></p><p>So this is actually a linguistic problem. More precisely, its a problem of predicate frames/argument semantics. Consider verbs like ‚hit&#39; and ‚kill&#39;. In term of precise semantics, we can model them as something like<br></p><p>kill(killer:victim:)<br>hit(hitter:victim:)<br></p><p>However, the actual status of the arguments here is compatible. Both verbs describe asymmetric actions, with one argument playing an active role in (negatively) changing the state of the other , passive one. So both are compatible with a broad metatype (what we often call predicate type in linguistics)<br></p><p>P(agent:undergoer:)<br></p><p>However, there are plenty of verbs that are quite different. Like go(person:to). Also two arguments, but the semantic status of them is very different. <br></p><p>If that is really the case, then there is indeed no general solution which keeps the argument labels semantically meaningful. But there is still a potential conflict with the tuple/function signature labels.  <br>The only reasonable choice that comes to my mind is to completely drop argument labels in closure variables and just look at the argument type. Basically, by assigning function variables, we drop any semantics and just look at the overall structure (cardinality/argument types)<br></p><p> In more detail:<br></p><p>1. Maintain that argument labels are not part of the type, but merely hints for the function dispatch/programmer convenience<br>2. Disallow argument labels in closure variables.  I.e.:<br></p><p>    var fun = drawLineTo(x:y:) <br></p><p>   has type (Float, Float) -&gt; (), which makes the variable explicitly compatible with any  function of cardinality 2 that takes Float arguments. At the sae time, any declaration like <br></p><p>    var fun : (x: Float, y: Float) -&gt; () <br></p><p>   should be illegal. This further makes clear that tuples and functions are not the same thing. <br></p><p><br>3. In the long term, maybe consider removing labels from tuples. At the same time, there should be a new mechanism in place that allows one to elevate tuples to structs, with properties taking the role of the current tuple labels (like Python’s namedtuple)<br></p><p>An alternative, in order to keep the cake and eat it too, would be something along the lines of making predicate types explicit. E.g. creating some sort of function ‚semantic metatype‘ and declaring function conformance to this metatype. But I can’t imagine that it is a good idea. Natural languages are really not a good source of inspiration in this regard. <br></p><p>Best, <br></p><p> Taras<br></p><p><br>&gt; On 01 Jul 2016, at 05:33, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 30, 2016, at 13:36, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for the label semantics, Swift&#39;s current behavior is actively misleading, please see the example in the prior email. There are no meaningful semantics in the label, because implicit conversion between differently-labeled function types means that there is no way to usefully enforce these invariants to begin with.<br>&gt;&gt; <br>&gt;&gt; That is a good point. I admit to not knowing this (I strongly expected that labels would be semantically meaningful). But what exactly is the status of the argument labels than in Swift? Just a documentation device  for the programmer and a  hint for the compiler to do function dispatch? But if the compiler indeed does dispatch on argument labels, then they are not completely void of semantics, are they?  As I mentioned before, I think the problem here is much deeper. <br>&gt;&gt; <br>&gt;&gt; The state of affairs I would prefer is something along these lines:<br>&gt;&gt; <br>&gt;&gt; 1. Labels are semantically meaningful<br>&gt;&gt; 2. There is an explicit casting system for function signatures<br>&gt;&gt; 3. This casting system should be in close correspondence to tuples. The &quot;function argument lists look sort of like tuples“ is a very compelling reason actually, because of the principle of the least surprise. If I have two things in the language that look very similar, then its very confusing if they  exhibit very different behaviour. Again, I am not proposing that one goes back to model functions in terms of tuples. But as long as there is a surface resemblance (and an obvious morphisms between the two), at least some aspects of their design should be kept in sync. <br>&gt;&gt; <br>&gt;&gt; But again, this touches on some deep design decisions for the language, so I — as an amateur — don’t feel in my plate discussing this here. I believe that there currently might be some inconsistencies in the language design that should be sealed with (but maybe they are no inconsistencies at all and I simply have false expectations). <br>&gt; <br>&gt; Language history, a.k.a. story time!<br>&gt; <br>&gt; We started out with the “perfect” model of a function type being a map from a tuple to a tuple. Different argument labels were just overloads. It really was quite a simple model, other than not having 1-tuples. Well, and variadics and default values and trailing closures didn’t make sense anywhere but in functions, but still. Very simple.<br>&gt; <br>&gt; (And inout. And autoclosure. And maybe a few more.)<br>&gt; <br>&gt; Then we hit a snag: naming guidelines. We wanted argument labels to be something people felt comfortable using, something that would be encouraged over a sea of unlabeled arguments. But even before the Swift 3 naming conventions were hammered out, the natural names for argument labels didn’t seem to match the names you’d want to use in the function. So we split the names of parameters off from the names of tuple elements.<br>&gt; <br>&gt; (This was precipitated by wanting to import Objective-C methods, but I think it would have come up regardless.)<br>&gt; <br>&gt; As seen earlier in the thread, argument labels don’t make for good tuple element labels. Especially with the Swift 3 guidelines, argument labels usually don’t make sense without the context provided by the base name, and two methods that happen to share argument labels might not actually be very similar, while two methods that are duals of each other might have different argument labels due to, well, English (e.g. &#39;add(to:)&#39; vs. &#39;remove(from:)’).<br>&gt; <br>&gt; The real blow, however, came with that very first idea: that we could treat methods with different argument labels as simple overloads in type. This led to poor diagnostics where the compiler couldn’t decide whether to believe the types or the argument labels, and might tell you you have the wrong argument labels rather than a type mismatch. For pretty much every Apple API, this was the wrong decision. On top of all that, it was really hard to refer to a method when you didn’t want to call it. (Most methods with the same base name still have unique labels, so you don’t need the types to disambiguate.)<br>&gt; <br>&gt; So we introduced the notion of “full names”, which are the things you see written as ‘move(from:to:)` (and which are represented by DeclName in the compiler). Almost immediately diagnostics got better, testing optional protocol requirements got shorter, and a lot of compiler implementation got simpler.<br>&gt; <br>&gt; And then we kind of got stuck here. We have full names used throughout the compiler, but tuple labels still appear in types. They’re still used in mangling. We got rid of the “tuple splat” feature, but still model out-of-order arguments as “tuple shuffles”. And we allow a number of conversions that look like they should be invalid, but aren’t.<br>&gt; <br>&gt; (And it’s important that we continue allowing them, or at least some of them, because we want to be able to pass existing functions to things like map and reduce without worrying about conflicting labels.)<br>&gt; <br>&gt; So we’ve given up the perfect ideal of tuple-to-tuple. But we did it because we value other things more than that ideal: variadics, default values, trailing closures, inout, autoclosure, distinct argument labels and parameter names, referencing a function by full name, and diagnostics that better match the user’s likely intent (particularly given the naming guidelines and existing libraries). I think that’s a worthwhile trade.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; P.S. Anyone is allowed to think this is not a worthwhile trade! But part of the purpose of this story is to show that we’re already 90% of the way towards making tuples and function arguments completely separate, even if they have similar syntax. This proposal gets us to maybe 95%.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/3638acae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 1:30 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Jordan, Thanks for the very insightful explanation! It all makes a lot of sense in perspective. <br>&gt; <br>&gt; Apparently I was thinking about this issue a bit while I was sleeping, and now it seems to me that part of the problem is because one strives for the function signature to be linguistically meaningful (as in natural language meaningful). It was mentioned that argument labels often don’t make much sense when detached from the function name, and that some function seem to have semantically compatible signatures and some don’t, e.g. the example of  drawLineTo(x: Float, y: Float) and drawLineWith(angle: Float, distance: Float)<br>&gt; <br>&gt; So this is actually a linguistic problem. More precisely, its a problem of predicate frames/argument semantics. Consider verbs like ‚hit&#39; and ‚kill&#39;. In term of precise semantics, we can model them as something like<br>&gt; <br>&gt; kill(killer:victim:)<br>&gt; hit(hitter:victim:)<br>&gt; <br>&gt; However, the actual status of the arguments here is compatible. Both verbs describe asymmetric actions, with one argument playing an active role in (negatively) changing the state of the other , passive one. So both are compatible with a broad metatype (what we often call predicate type in linguistics)<br>&gt; <br>&gt; P(agent:undergoer:)<br>&gt; <br>&gt; However, there are plenty of verbs that are quite different. Like go(person:to). Also two arguments, but the semantic status of them is very different. <br>&gt; <br>&gt; If that is really the case, then there is indeed no general solution which keeps the argument labels semantically meaningful. But there is still a potential conflict with the tuple/function signature labels.  <br>&gt; The only reasonable choice that comes to my mind is to completely drop argument labels in closure variables and just look at the argument type. Basically, by assigning function variables, we drop any semantics and just look at the overall structure (cardinality/argument types)<br>&gt; <br>&gt;  In more detail:<br>&gt; <br>&gt; 1. Maintain that argument labels are not part of the type, but merely hints for the function dispatch/programmer convenience<br></p><p>They are not merely hints, they are part of the full name of the function. Functions with different names are different functions, even if they share the same base name. That is, they are syntactically meaningful.<br></p><p>&gt; 2. Disallow argument labels in closure variables.  I.e.:<br>&gt; <br>&gt;     var fun = drawLineTo(x:y:) <br>&gt; <br>&gt;    has type (Float, Float) -&gt; (), which makes the variable explicitly compatible with any  function of cardinality 2 that takes Float arguments. At the sae time, any declaration like <br>&gt; <br>&gt;     var fun : (x: Float, y: Float) -&gt; () <br>&gt; <br>&gt;    should be illegal. This further makes clear that tuples and functions are not the same thing. <br>&gt; <br>&gt; <br>&gt; 3. In the long term, maybe consider removing labels from tuples. At the same time, there should be a new mechanism in place that allows one to elevate tuples to structs, with properties taking the role of the current tuple labels (like Python’s namedtuple)<br>&gt; <br>&gt; An alternative, in order to keep the cake and eat it too, would be something along the lines of making predicate types explicit. E.g. creating some sort of function ‚semantic metatype‘ and declaring function conformance to this metatype. But I can’t imagine that it is a good idea. Natural languages are really not a good source of inspiration in this regard. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; <br>&gt;&gt; On 01 Jul 2016, at 05:33, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 13:36, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for the label semantics, Swift&#39;s current behavior is actively misleading, please see the example in the prior email. There are no meaningful semantics in the label, because implicit conversion between differently-labeled function types means that there is no way to usefully enforce these invariants to begin with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is a good point. I admit to not knowing this (I strongly expected that labels would be semantically meaningful). But what exactly is the status of the argument labels than in Swift? Just a documentation device  for the programmer and a  hint for the compiler to do function dispatch? But if the compiler indeed does dispatch on argument labels, then they are not completely void of semantics, are they?  As I mentioned before, I think the problem here is much deeper. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The state of affairs I would prefer is something along these lines:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Labels are semantically meaningful<br>&gt;&gt;&gt; 2. There is an explicit casting system for function signatures<br>&gt;&gt;&gt; 3. This casting system should be in close correspondence to tuples. The &quot;function argument lists look sort of like tuples“ is a very compelling reason actually, because of the principle of the least surprise. If I have two things in the language that look very similar, then its very confusing if they  exhibit very different behaviour. Again, I am not proposing that one goes back to model functions in terms of tuples. But as long as there is a surface resemblance (and an obvious morphisms between the two), at least some aspects of their design should be kept in sync. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But again, this touches on some deep design decisions for the language, so I — as an amateur — don’t feel in my plate discussing this here. I believe that there currently might be some inconsistencies in the language design that should be sealed with (but maybe they are no inconsistencies at all and I simply have false expectations). <br>&gt;&gt; <br>&gt;&gt; Language history, a.k.a. story time!<br>&gt;&gt; <br>&gt;&gt; We started out with the “perfect” model of a function type being a map from a tuple to a tuple. Different argument labels were just overloads. It really was quite a simple model, other than not having 1-tuples. Well, and variadics and default values and trailing closures didn’t make sense anywhere but in functions, but still. Very simple.<br>&gt;&gt; <br>&gt;&gt; (And inout. And autoclosure. And maybe a few more.)<br>&gt;&gt; <br>&gt;&gt; Then we hit a snag: naming guidelines. We wanted argument labels to be something people felt comfortable using, something that would be encouraged over a sea of unlabeled arguments. But even before the Swift 3 naming conventions were hammered out, the natural names for argument labels didn’t seem to match the names you’d want to use in the function. So we split the names of parameters off from the names of tuple elements.<br>&gt;&gt; <br>&gt;&gt; (This was precipitated by wanting to import Objective-C methods, but I think it would have come up regardless.)<br>&gt;&gt; <br>&gt;&gt; As seen earlier in the thread, argument labels don’t make for good tuple element labels. Especially with the Swift 3 guidelines, argument labels usually don’t make sense without the context provided by the base name, and two methods that happen to share argument labels might not actually be very similar, while two methods that are duals of each other might have different argument labels due to, well, English (e.g. &#39;add(to:)&#39; vs. &#39;remove(from:)’).<br>&gt;&gt; <br>&gt;&gt; The real blow, however, came with that very first idea: that we could treat methods with different argument labels as simple overloads in type. This led to poor diagnostics where the compiler couldn’t decide whether to believe the types or the argument labels, and might tell you you have the wrong argument labels rather than a type mismatch. For pretty much every Apple API, this was the wrong decision. On top of all that, it was really hard to refer to a method when you didn’t want to call it. (Most methods with the same base name still have unique labels, so you don’t need the types to disambiguate.)<br>&gt;&gt; <br>&gt;&gt; So we introduced the notion of “full names”, which are the things you see written as ‘move(from:to:)` (and which are represented by DeclName in the compiler). Almost immediately diagnostics got better, testing optional protocol requirements got shorter, and a lot of compiler implementation got simpler.<br>&gt;&gt; <br>&gt;&gt; And then we kind of got stuck here. We have full names used throughout the compiler, but tuple labels still appear in types. They’re still used in mangling. We got rid of the “tuple splat” feature, but still model out-of-order arguments as “tuple shuffles”. And we allow a number of conversions that look like they should be invalid, but aren’t.<br>&gt;&gt; <br>&gt;&gt; (And it’s important that we continue allowing them, or at least some of them, because we want to be able to pass existing functions to things like map and reduce without worrying about conflicting labels.)<br>&gt;&gt; <br>&gt;&gt; So we’ve given up the perfect ideal of tuple-to-tuple. But we did it because we value other things more than that ideal: variadics, default values, trailing closures, inout, autoclosure, distinct argument labels and parameter names, referencing a function by full name, and diagnostics that better match the user’s likely intent (particularly given the naming guidelines and existing libraries). I think that’s a worthwhile trade.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; P.S. Anyone is allowed to think this is not a worthwhile trade! But part of the purpose of this story is to show that we’re already 90% of the way towards making tuples and function arguments completely separate, even if they have similar syntax. This proposal gets us to maybe 95%.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/834c0e13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July  1, 2016 at 01:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>a reluctant +1<br>        * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br>Yes.<br>        * Does this proposal fit well with the feel and direction of Swift?<br>Yes.<br>        * If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br>It works well enough<br>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br>Read a few times over.<br></p><p>The point that actually tipped my opinion came from Jordan Rose &quot; Argument<br>labels are definitely part of the *name* of the function, but they aren’t<br>part of the *type*. A few functions happen to have argument labels &quot;<br></p><p>I am of the general opinion that argument labels are part of the type,<br>which helps explain `stride(to:by:)` vs `stride(through:by:)` in terms of<br>overloading instead of name lookup. While this proposal would render that<br>explanation invalid, I realize that I was conflating the ideas of name and<br>type. I wish we could have the tuple to tuple model but I see how it isn&#39;t<br>tractable when combined with other features.<br></p><p><br></p><p>On Fri, Jul 1, 2016 at 12:56 PM, Michael Ilseman via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 1, 2016, at 1:30 AM, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Jordan, Thanks for the very insightful explanation! It all makes a lot of<br>&gt; sense in perspective.<br>&gt;<br>&gt; Apparently I was thinking about this issue a bit while I was sleeping, and<br>&gt; now it seems to me that part of the problem is because one strives for the<br>&gt; function signature to be linguistically meaningful (as in natural language<br>&gt; meaningful). It was mentioned that argument labels often don’t make much<br>&gt; sense when detached from the function name, and that some function seem to<br>&gt; have semantically compatible signatures and some don’t, e.g. the example of<br>&gt;  drawLineTo(x: Float, y: Float) and drawLineWith(angle: Float, distance:<br>&gt; Float)<br>&gt;<br>&gt; So this is actually a linguistic problem. More precisely, its a problem of<br>&gt; predicate frames/argument semantics. Consider verbs like ‚hit&#39; and ‚kill&#39;.<br>&gt; In term of precise semantics, we can model them as something like<br>&gt;<br>&gt; kill(killer:victim:)<br>&gt; hit(hitter:victim:)<br>&gt;<br>&gt; However, the actual status of the arguments here is compatible. Both verbs<br>&gt; describe asymmetric actions, with one argument playing an active role in<br>&gt; (negatively) changing the state of the other , passive one. So both are<br>&gt; compatible with a broad metatype (what we often call predicate type in<br>&gt; linguistics)<br>&gt;<br>&gt; P(agent:undergoer:)<br>&gt;<br>&gt; However, there are plenty of verbs that are quite different. Like<br>&gt; go(person:to). Also two arguments, but the semantic status of them is very<br>&gt; different.<br>&gt;<br>&gt; If that is really the case, then there is indeed no general solution which<br>&gt; keeps the argument labels semantically meaningful. But there is still a<br>&gt; potential conflict with the tuple/function signature labels.<br>&gt; The only reasonable choice that comes to my mind is to completely drop<br>&gt; argument labels in closure variables and just look at the argument type.<br>&gt; Basically, by assigning function variables, we drop any semantics and just<br>&gt; look at the overall structure (cardinality/argument types)<br>&gt;<br>&gt;  In more detail:<br>&gt;<br>&gt; 1. Maintain that argument labels are not part of the type, but merely<br>&gt; hints for the function dispatch/programmer convenience<br>&gt;<br>&gt;<br>&gt; They are not merely hints, they are part of the full name of the function.<br>&gt; Functions with different names are different functions, even if they share<br>&gt; the same base name. That is, they are syntactically meaningful.<br>&gt;<br>&gt; 2. *Disallow* argument labels in closure variables.  I.e.:<br>&gt;<br>&gt;     var fun = drawLineTo(x:y:)<br>&gt;<br>&gt;    has type (Float, Float) -&gt; (), which makes the variable explicitly<br>&gt; compatible with any  function of cardinality 2 that takes Float arguments.<br>&gt; At the sae time, any declaration like<br>&gt;<br>&gt;     var fun : (x: Float, y: Float) -&gt; ()<br>&gt;<br>&gt;    should be illegal. This further makes clear that tuples and functions<br>&gt; are not the same thing.<br>&gt;<br>&gt;<br>&gt; 3. In the long term, maybe consider *removing* *labels from tuples*. At<br>&gt; the same time, there should be a new mechanism in place that allows one to<br>&gt; elevate tuples to structs, with properties taking the role of the current<br>&gt; tuple labels (like Python’s namedtuple)<br>&gt;<br>&gt; An alternative, in order to keep the cake and eat it too, would be<br>&gt; something along the lines of making predicate types explicit. E.g. creating<br>&gt; some sort of function ‚semantic metatype‘ and declaring function<br>&gt; conformance to this metatype. But I can’t imagine that it is a good idea.<br>&gt; Natural languages are really not a good source of inspiration in this<br>&gt; regard.<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt;<br>&gt; On 01 Jul 2016, at 05:33, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jun 30, 2016, at 13:36, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 30 Jun 2016, at 22:11, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; As for the label semantics, Swift&#39;s current behavior is actively<br>&gt; misleading, please see the example in the prior email. There are no<br>&gt; meaningful semantics in the label, because implicit conversion between<br>&gt; differently-labeled function types means that there is no way to usefully<br>&gt; enforce these invariants to begin with.<br>&gt;<br>&gt;<br>&gt; That is a good point. I admit to not knowing this (I strongly expected<br>&gt; that labels would be semantically meaningful). But what exactly is the<br>&gt; status of the argument labels than in Swift? Just a documentation device<br>&gt;  for the programmer and a  hint for the compiler to do function dispatch?<br>&gt; But if the compiler indeed does dispatch on argument labels, then they are<br>&gt; not completely void of semantics, are they?  As I mentioned before, I think<br>&gt; the problem here is much deeper.<br>&gt;<br>&gt; The state of affairs I would prefer is something along these lines:<br>&gt;<br>&gt; 1. Labels are semantically meaningful<br>&gt; 2. There is an explicit casting system for function signatures<br>&gt; 3. This casting system should be in close correspondence to tuples. The<br>&gt; &quot;function argument lists look sort of like tuples“ is a very compelling<br>&gt; reason actually, because of the principle of the least surprise. If I have<br>&gt; two things in the language that look very similar, then its very confusing<br>&gt; if they  exhibit very different behaviour. Again, I am not proposing that<br>&gt; one goes back to model functions in terms of tuples. But as long as there<br>&gt; is a surface resemblance (and an obvious morphisms between the two), at<br>&gt; least some aspects of their design should be kept in sync.<br>&gt;<br>&gt; But again, this touches on some deep design decisions for the language, so<br>&gt; I — as an amateur — don’t feel in my plate discussing this here. I believe<br>&gt; that there currently might be some inconsistencies in the language design<br>&gt; that should be sealed with (but maybe they are no inconsistencies at all<br>&gt; and I simply have false expectations).<br>&gt;<br>&gt;<br>&gt; Language history, a.k.a. story time!<br>&gt;<br>&gt; We started out with the “perfect” model of a function type being a map<br>&gt; from a tuple to a tuple. Different argument labels were just overloads. It<br>&gt; really was quite a simple model, other than not having 1-tuples. Well, and<br>&gt; variadics and default values and trailing closures didn’t make sense<br>&gt; anywhere but in functions, but still. Very simple.<br>&gt;<br>&gt; (And inout. And autoclosure. And maybe a few more.)<br>&gt;<br>&gt; Then we hit a snag: naming guidelines. We wanted argument labels to be<br>&gt; something people felt comfortable using, something that would be encouraged<br>&gt; over a sea of unlabeled arguments. But even before the Swift 3 naming<br>&gt; conventions were hammered out, the natural names for argument labels didn’t<br>&gt; seem to match the names you’d want to use in the function. So we split the<br>&gt; names of parameters off from the names of tuple elements.<br>&gt;<br>&gt; (This was precipitated by wanting to import Objective-C methods, but I<br>&gt; think it would have come up regardless.)<br>&gt;<br>&gt; As seen earlier in the thread, argument labels don’t make for good tuple<br>&gt; element labels. Especially with the Swift 3 guidelines, argument labels<br>&gt; usually don’t make sense without the context provided by the base name, and<br>&gt; two methods that happen to share argument labels might not actually be very<br>&gt; similar, while two methods that are duals of each other might have<br>&gt; different argument labels due to, well, English (e.g. &#39;add(to:)&#39; vs.<br>&gt; &#39;remove(from:)’).<br>&gt;<br>&gt; The real blow, however, came with that very first idea: that we could<br>&gt; treat methods with different argument labels as simple overloads in type.<br>&gt; This led to poor diagnostics where the compiler couldn’t decide whether to<br>&gt; believe the types or the argument labels, and might tell you you have the<br>&gt; wrong argument labels rather than a type mismatch. For pretty much every<br>&gt; Apple API, this was the wrong decision. On top of all that, it was really<br>&gt; hard to refer to a method when you *didn’t* want to call it. (Most<br>&gt; methods with the same base name still have unique labels, so you don’t need<br>&gt; the types to disambiguate.)<br>&gt;<br>&gt; So we introduced the notion of “full names”, which are the things you see<br>&gt; written as ‘move(from:to:)` (and which are represented by DeclName in the<br>&gt; compiler). Almost immediately diagnostics got better, testing optional<br>&gt; protocol requirements got shorter, and a lot of compiler implementation got<br>&gt; simpler.<br>&gt;<br>&gt; And then we kind of got stuck here. We have full names used throughout the<br>&gt; compiler, but tuple labels still appear in types. They’re still used in<br>&gt; mangling. We got rid of the “tuple splat” feature, but still model<br>&gt; out-of-order arguments as “tuple shuffles”. And we allow a number of<br>&gt; conversions that *look* like they should be invalid, but aren’t.<br>&gt;<br>&gt; (And it’s important that we continue allowing them, or at least some of<br>&gt; them, because we want to be able to pass existing functions to things like<br>&gt; map and reduce without worrying about conflicting labels.)<br>&gt;<br>&gt; So we’ve given up the perfect ideal of tuple-to-tuple. But we did it<br>&gt; because we value other things more than that ideal: variadics, default<br>&gt; values, trailing closures, inout, autoclosure, distinct argument labels and<br>&gt; parameter names, referencing a function by full name, and diagnostics that<br>&gt; better match the user’s likely intent (particularly given the naming<br>&gt; guidelines and existing libraries). I think that’s a worthwhile trade.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; P.S. Anyone is allowed to think this is *not* a worthwhile trade! But<br>&gt; part of the purpose of this story is to show that we’re already 90% of the<br>&gt; way towards making tuples and function arguments completely separate, even<br>&gt; if they have similar syntax. This proposal gets us to maybe 95%.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/e5abf71f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1.  When the review began I though I preferred something along the lines of the “prohibit implicit subtyping” alternative.  However, I have followed the review thread closely and given deeper thought to the issue and I have become convinced that labels should not have a place in the Swift type system.  <br></p><p>Labels often become nonsensical when disconnected from the root name of the function they originated in.  It only makes sense for labels to be part of the type if the names of the labels are designed to stand alone.  <br></p><p>However, this is rarely going to be the case.  All functions and methods *must* have a root name.   Argument labels are optional, and if supplied leverage the context provided by the root name.  <br></p><p>Function parameters and properties withe function types that have labels still have an argument or property name (and possibly an external label name in the case of parameters).  That name is at a distance from any labels in the function type but still provides context that programmers are likely to use (like it or not) when designing the names of the labels.<br></p><p>In all of the preceding cases the names in the type are heavily depending on the context of the declaration and do not really stand alone in a way that makes sense to include them as part of the type.<br></p><p>The only case I can think of where the labels are truly independent of something resembling a root name that could be used to call the function is in the case of a typealias:<br></p><p>typealias Predicate&lt;T&gt; = (value: T) -&gt; Bool<br></p><p>(This is a bad example because you would not use a label here)<br></p><p>When you define a typealias like this there is no context providing additional meaning to the labels.  In this case if you do allow them and include them in the type at least you don’t lose meaning and are likely to have labels that make some sense.  <br></p><p>However, this is a narrow corner of the language.  If this is the only place you can introduce labels without a high likelihood that they produce a type that has nonsense labels on its own (without the context in which the type was written) they are going to lead to far more confusion than they will provide value.  <br></p><p>We should remove this feature for Swift 3.  If this leads to less elegance or clarity in some use cases we should consider them carefully and see if a less fragile feature can be designed to support them.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Absolutely.  There are a lot of rough edges to this feature and we are removing rough edges in Swift 3.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Nothing similar enough to be worth mentioning.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In depth study.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July  1, 2016 at 11:00:00pm</p></header><div class="content"><p>On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt; available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>+1. I&#39;m in agreement with others in this thread who say that the labels are<br>parts of the *name* of the function, not parts of its *type*. If I<br>understand the other discussions regarding the evolution of Swift&#39;s<br>function arguments model, the similarity to tuples with labeled components<br>is a historical artifact and now merely coincidental.<br></p><p>The analogy to Objective-C here is obvious, where you have selectors<br>instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>contains all of the parts, not just the base name.<br></p><p>Swift function names to me are like German separable verbs. Even when<br>they&#39;re split across the sentence with multiple words in-between, the<br>prefix is still considered part of that verb, not a separate word/concept.<br></p><p><br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br></p><p>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>of argument names to differentiate between overloads with the same argument<br>types at the same positions. To me, this is another admission that the<br>labels are part of the function&#39;s *name*.<br></p><p><br></p><p>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>have named/keyword arguments (like Python) are dynamic languages that treat<br>the incoming argument list as a dictionary; in that case, the language<br>design is significantly different and I can&#39;t draw an analogy between them.<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>Read the proposal and loosely followed the discussion.<br></p><p><br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/ea48c15e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 04:00:00am</p></header><div class="content"><p>I&#39;ve made a separate topic discussing the possible consequences of this change, but I don&#39;t think the implications are really worth it. Parameter lists and tuples are fundamentally similar, and that&#39;s why we&#39;re getting all of these confusing edge cases.<br></p><p>Ultimately, this come down to two problems:<br></p><p>• Casting between functions of different labels is confusing. We&#39;ve discussed removing argument labels from function types for this reason. However, tuples have this exact same problem. We should solve this generally, for tuples and functions. A solution applicable to one is applicable to the other. If tuples were only in the languages because they were meant to model a function&#39;s arguments, I believe they still do in Swift 2.<br></p><p>Perhaps a tuple&#39;s argument labels should be in the name of it&#39;s containing variable, like we plan for function types?<br></p><p>• Parameter lists have distinct annotations, which are unsuitable for full exposure to the type system. However, I think this can be resolved through something similar to the @noescape annotation, but for tuples, to restrict them to ‘pure, nonescaping’ functional contexts (IE direct application to a function).<br></p><p>For example:<br></p><p>apply&lt;A, B&gt;(in: @params A, function: A -&gt; B) -&gt; B {<br>    return function(in)<br>}<br></p><p>//since we know the tuple cannot escape,<br>//only be passed to more functions with the exact parameter list represented by A,<br>//we can safely use it with parameter decorations in a strictly functional context:<br></p><p>apply(in: (&amp;mutable, other), function: aFunction)<br></p><p>//or more practically:<br></p><p>(&amp;mutable, other) =&gt; aFunction<br></p><p>Any return value is naturally escaping, meaning a returned tuple cannot have modifiers such as @noescape and inout, since it can&#39;t provide that guarantee. I think this addresses the problem much more directly.<br></p><p>There are inherently parallels between parameter lists and tuples, and that&#39;s why functional programming languages rely on them. Swift actually has quite a limited number of parameter list modifiers, so I think it&#39;s worth exploring alternatives to fit these into the existing, much more generalised system, before removing the parallel between parameter lists and tuples in favour of something already known to be less flexible.<br></p><p>My review is inline.<br></p><p>&gt; On 30 Jun 2016, at 19:26, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br></p><p>Strongly against, for the reasons described.<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, but we should explore the alternatives.<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Absolutely not, we will lose fundamental to Swift something by making this change. We&#39;ve already seen it by ‘removing’ tuple splat, and finding it to be only surface-level. This is something already deeply ingrained in the type system, and which provides a good deal of flexibility to functional code. The addition of Never in favour of @noreturn shows how powerful the type system can be, and I don&#39;t think we should walk this path half-heartedly.<br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I got started programming back in Objective-C, but most of my programming experience is with Swift. In the various other (admittedly older) imperative languages I&#39;ve tried, I have been disappointed by the inflexibility of things such as:<br></p><p>• Lack of tuple support, for straightforward return of &gt;1 value where a formal type is overkill.<br>• Lack of explicit optionals, or tacked-on optional support which interacts poorly with generics and existing libraries.<br>• Lack of equal support for value-types, to varying degrees.<br>• Generics aren&#39;t actually generic, often requiring overloads for value-types, due to their ‘defaulting’ behaviour.<br></p><p>The one thing these all have in common is the type system. There seems to be real progress to be made by generalizing the type system as Swift has, so far.<br></p><p>Swift&#39;s functional generics system is incredible, largely thanks to the modelling of parameter lists as a type, namely tuples. While this model has fallen behind language advances, I think it can and should be brought up to speed.<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br></p><p>A lot of thought, while working with Swift and other languages.<br></p><p>Thanks for reading.<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 04:00:00am</p></header><div class="content"><p>Sorry, this was meant to be in response to:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0110-distingish-single-tuple-arg.md<br></p><p>From James F<br></p><p>&gt; On 2 Jul 2016, at 04:02, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve made a separate topic discussing the possible consequences of this change, but I don&#39;t think the implications are really worth it. Parameter lists and tuples are fundamentally similar, and that&#39;s why we&#39;re getting all of these confusing edge cases.<br>&gt; <br>&gt; Ultimately, this come down to two problems:<br>&gt; <br>&gt; • Casting between functions of different labels is confusing. We&#39;ve discussed removing argument labels from function types for this reason. However, tuples have this exact same problem. We should solve this generally, for tuples and functions. A solution applicable to one is applicable to the other. If tuples were only in the languages because they were meant to model a function&#39;s arguments, I believe they still do in Swift 2.<br>&gt; <br>&gt; Perhaps a tuple&#39;s argument labels should be in the name of it&#39;s containing variable, like we plan for function types?<br>&gt; <br>&gt; • Parameter lists have distinct annotations, which are unsuitable for full exposure to the type system. However, I think this can be resolved through something similar to the @noescape annotation, but for tuples, to restrict them to ‘pure, nonescaping’ functional contexts (IE direct application to a function).<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; apply&lt;A, B&gt;(in: @params A, function: A -&gt; B) -&gt; B {<br>&gt;    return function(in)<br>&gt; }<br>&gt; <br>&gt; //since we know the tuple cannot escape,<br>&gt; //only be passed to more functions with the exact parameter list represented by A,<br>&gt; //we can safely use it with parameter decorations in a strictly functional context:<br>&gt; <br>&gt; apply(in: (&amp;mutable, other), function: aFunction)<br>&gt; <br>&gt; //or more practically:<br>&gt; <br>&gt; (&amp;mutable, other) =&gt; aFunction<br>&gt; <br>&gt; Any return value is naturally escaping, meaning a returned tuple cannot have modifiers such as @noescape and inout, since it can&#39;t provide that guarantee. I think this addresses the problem much more directly.<br>&gt; <br>&gt; There are inherently parallels between parameter lists and tuples, and that&#39;s why functional programming languages rely on them. Swift actually has quite a limited number of parameter list modifiers, so I think it&#39;s worth exploring alternatives to fit these into the existing, much more generalised system, before removing the parallel between parameter lists and tuples in favour of something already known to be less flexible.<br>&gt; <br>&gt; My review is inline.<br>&gt; <br>&gt;&gt; On 30 Jun 2016, at 19:26, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt;   * What is your evaluation of the proposal?<br>&gt; <br>&gt; Strongly against, for the reasons described.<br>&gt; <br>&gt;&gt;   * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, but we should explore the alternatives.<br>&gt; <br>&gt;&gt;   * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Absolutely not, we will lose fundamental to Swift something by making this change. We&#39;ve already seen it by ‘removing’ tuple splat, and finding it to be only surface-level. This is something already deeply ingrained in the type system, and which provides a good deal of flexibility to functional code. The addition of Never in favour of @noreturn shows how powerful the type system can be, and I don&#39;t think we should walk this path half-heartedly.<br>&gt; <br>&gt;&gt;   * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I got started programming back in Objective-C, but most of my programming experience is with Swift. In the various other (admittedly older) imperative languages I&#39;ve tried, I have been disappointed by the inflexibility of things such as:<br>&gt; <br>&gt; • Lack of tuple support, for straightforward return of &gt;1 value where a formal type is overkill.<br>&gt; • Lack of explicit optionals, or tacked-on optional support which interacts poorly with generics and existing libraries.<br>&gt; • Lack of equal support for value-types, to varying degrees.<br>&gt; • Generics aren&#39;t actually generic, often requiring overloads for value-types, due to their ‘defaulting’ behaviour.<br>&gt; <br>&gt; The one thing these all have in common is the type system. There seems to be real progress to be made by generalizing the type system as Swift has, so far.<br>&gt; <br>&gt; Swift&#39;s functional generics system is incredible, largely thanks to the modelling of parameter lists as a type, namely tuples. While this model has fallen behind language advances, I think it can and should be brought up to speed.<br>&gt; <br>&gt;&gt;   * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt; <br>&gt; A lot of thought, while working with Swift and other languages.<br>&gt; <br>&gt; Thanks for reading.<br>&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt; swift-evolution-announce at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/1ac1320e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 30 Jun 2016, Chris Lattner wrote:<br>&gt; <br>&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt; What is your evaluation of the proposal?<br></p><p>+1. With the way the community has settled using argument labels, it seems clear to me that argument labels are part of a function&#39;s name and should not affect its type.<br></p><p>What we currently have technically works because the compiler is quite lenient in type conversions between different argument labels. But since there are corner cases lurking where labels in the function type matter (as demonstrated in the proposal), it&#39;s best we get rid of them entirely for clarity. As it has been pointed out, the status quo also complicates the overload resolution process and causes confusing error messages when the compiler can&#39;t tell if your argument labels are wrong or argument types. We&#39;re better without that complexity.<br></p><p>Further, I think removing this oddity could make function application with tuples feasible again (a.k.a the simple form of &quot;tuple splatting&quot; with all arguments in the tuple) by requiring to fully name the function before passing the arguments tuple:<br></p><p>    func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>    func doSomething(any: Any) -&gt; Bool { return false } // This can&#39;t possibly be considered below.<br>    <br>    let args = (1, 2)<br>    let named = (x: 1, y: 2)<br>    let f = doSomething(x:y:)<br>    f(args)                 // Unambiguous call, if the syntax is made legal (again).<br>    doSomething(x:y:)(args) // So is this.<br>    doSomething(args)       // This would still be an error as per SE-0029 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md&gt;.<br>    let tuples = [(1, 2), (3, 4), (5, 6)]<br>    print(tuples.map(f)) // This would be allowed. (Confusingly it already works despite SE-0029!)<br></p><p>In particular, you couldn&#39;t apply a `func` function with a tuple (which was what SE-0029 removed) but you could apply a qualified function reference (SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt;) as well as a function value (i.e. a named closure) with a tuple, because both of them have set in stone their argument list length before the tuple application and thus suffer from none of the disadvantages listed in the motivation for SE-0029 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md#motivation&gt;. That would of course need a separate proposal and can be delayed until Swift 3 has been released.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>I think so.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Well, we&#39;ve had argument labels in Objective-C but since it&#39;s not a strongly typed language I don&#39;t think it applies for comparison. However, I naturally feel argument labels in Objective-C as well are part of the function&#39;s name rather than its type.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More than a quick reading. I&#39;ve suggested a similar idea before but didn&#39;t motivate it well enough to gain interest back then. Big thanks to Austin for driving it forward this time!<br></p><p>— Pyry<br></p><p>PS. Can anybody explain why the last example in my code above turned out to be allowed even though SE-0029 seems to prohibit it? Here&#39;s a more comprehensive test which made me positively surprised that it still worked after SE-0029:<br></p><p>    let f: (Int, Int) -&gt; Int = (+)<br>    let x = (1, 2)<br>    let x, y = (3, 4)<br>    f(1, 2) //=&gt; 3<br>    // f((1, 2))                          // Does not compile, as expected (SE-0029).<br>    // f(x)                               // Does not compile, as expected.<br>    [x, y].map(f) //=&gt; [3, 7]             // Surprisingly compiles, but why?<br>    let g: ((Int, Int)) -&gt; Int = f        // Huh? So `f` can coerce to a `(tuple) -&gt; Int`?<br>    g(x) //=&gt; 3                           // So this is what made `map` work above.<br>    (f as ((Int, Int)) -&gt; Int)(x) //=&gt; 3  // This works too, didn&#39;t expect it to.<br>    [x, y].map(+)  //=&gt; [3, 7]            // Finally, why is this allowed despite SE-0029?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160703/8a5738e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  4, 2016 at 12:00:00am</p></header><div class="content"><p>Ever considered looking at how typescript handles argument names in object literal deconstruction?<br></p><p>Regards<br>(From mobile)<br></p><p>On Jul 3, 2016, at 10:36 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On 30 Jun 2016, Chris Lattner wrote:<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; +1. With the way the community has settled using argument labels, it seems clear to me that argument labels are part of a function&#39;s name and should not affect its type.<br>&gt; <br>&gt; What we currently have technically works because the compiler is quite lenient in type conversions between different argument labels. But since there are corner cases lurking where labels in the function type matter (as demonstrated in the proposal), it&#39;s best we get rid of them entirely for clarity. As it has been pointed out, the status quo also complicates the overload resolution process and causes confusing error messages when the compiler can&#39;t tell if your argument labels are wrong or argument types. We&#39;re better without that complexity.<br>&gt; <br>&gt; Further, I think removing this oddity could make function application with tuples feasible again (a.k.a the simple form of &quot;tuple splatting&quot; with all arguments in the tuple) by requiring to fully name the function before passing the arguments tuple:<br>&gt; <br>&gt;     func doSomething(x: Int, y: Int) -&gt; Bool { return true }<br>&gt;     func doSomething(any: Any) -&gt; Bool { return false } // This can&#39;t possibly be considered below.<br>&gt;     <br>&gt;     let args = (1, 2)<br>&gt;     let named = (x: 1, y: 2)<br>&gt;     let f = doSomething(x:y:)<br>&gt;     f(args)                 // Unambiguous call, if the syntax is made legal (again).<br>&gt;     doSomething(x:y:)(args) // So is this.<br>&gt;     doSomething(args)       // This would still be an error as per SE-0029.<br>&gt;     let tuples = [(1, 2), (3, 4), (5, 6)]<br>&gt;     print(tuples.map(f)) // This would be allowed. (Confusingly it already works despite SE-0029!)<br>&gt; <br>&gt; In particular, you couldn&#39;t apply a `func` function with a tuple (which was what SE-0029 removed) but you could apply a qualified function reference (SE-0021) as well as a function value (i.e. a named closure) with a tuple, because both of them have set in stone their argument list length before the tuple application and thus suffer from none of the disadvantages listed in the motivation for SE-0029. That would of course need a separate proposal and can be delayed until Swift 3 has been released.<br>&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; I think so.<br>&gt; <br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Well, we&#39;ve had argument labels in Objective-C but since it&#39;s not a strongly typed language I don&#39;t think it applies for comparison. However, I naturally feel argument labels in Objective-C as well are part of the function&#39;s name rather than its type.<br>&gt; <br>&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More than a quick reading. I&#39;ve suggested a similar idea before but didn&#39;t motivate it well enough to gain interest back then. Big thanks to Austin for driving it forward this time!<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; PS. Can anybody explain why the last example in my code above turned out to be allowed even though SE-0029 seems to prohibit it? Here&#39;s a more comprehensive test which made me positively surprised that it still worked after SE-0029:<br>&gt; <br>&gt;     let f: (Int, Int) -&gt; Int = (+)<br>&gt;     let x = (1, 2)<br>&gt;     let x, y = (3, 4)<br>&gt;     f(1, 2) //=&gt; 3<br>&gt;     // f((1, 2))                          // Does not compile, as expected (SE-0029).<br>&gt;     // f(x)                               // Does not compile, as expected.<br>&gt;     [x, y].map(f) //=&gt; [3, 7]             // Surprisingly compiles, but why?<br>&gt;     let g: ((Int, Int)) -&gt; Int = f        // Huh? So `f` can coerce to a `(tuple) -&gt; Int`?<br>&gt;     g(x) //=&gt; 3                           // So this is what made `map` work above.<br>&gt;     (f as ((Int, Int)) -&gt; Int)(x) //=&gt; 3  // This works too, didn&#39;t expect it to.<br>&gt;     [x, y].map(+)  //=&gt; [3, 7]            // Finally, why is this allowed despite SE-0029?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160704/edd09be7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  4, 2016 at 08:00:00am</p></header><div class="content"><p>Overall, -1.<br></p><p>I agree that labels should not affect the type, but imho the current status (Swift 2.3 — I haven&#39;t checked Version 3) is fine, and the proposal doesn&#39;t achieve what it says in the title:<br>For me, that is no question of types at all, but only of names:<br></p><p>var a: (Int, z: Int) -&gt; Void = t<br>var b: (y: Int, z: Int) -&gt; Void = t<br></p><p>a = b<br></p><p>This works, because a and b are both of type (Int, Int) -&gt; Void, and the labels aren&#39;t significant.<br></p><p>So the proposal merely disallows labels in the declaration of function variables, which I consider bad, because labels convey the meaning of parameters. Why should something that is widely seen as a good feature of functions be removed from function variables?<br></p><p>If you share the opinion that labels are part of the name, the battleship example no good argument against labels:<br>No one stops you from doing<br></p><p>let minimum: (Int, Int) -&gt; Int = max<br>Which is confusing as well.<br></p><p>Best regards,<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160704/73f35ada/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 3, 2016, at 11:50 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Overall, -1.<br>&gt; <br>&gt; I agree that labels should not affect the type, but imho the current status (Swift 2.3 — I haven&#39;t checked Version 3) is fine, and the proposal doesn&#39;t achieve what it says in the title:<br>&gt; For me, that is no question of types at all, but only of names:<br>&gt; <br>&gt; var a: (Int, z: Int) -&gt; Void = t<br>&gt; var b: (y: Int, z: Int) -&gt; Void = t<br>&gt; <br>&gt; a = b<br>&gt; <br>&gt; This works, because a and b are both of type (Int, Int) -&gt; Void, and the labels aren&#39;t significant.<br></p><p>The point of the behavior is to remove the subtyping relationships from the type system which make the above work, which is a very real change.<br></p><p>&gt; <br>&gt; So the proposal merely disallows labels in the declaration of function variables, which I consider bad, because labels convey the meaning of parameters. Why should something that is widely seen as a good feature of functions be removed from function variables?<br></p><p>As has been discussed exhaustively in this thread, Swift 3 function labels don&#39;t convey the meaning of parameters, they are almost always prepositional phrases that don&#39;t make sense apart from the primary function name they are attached to.<br></p><p>&gt; <br>&gt; If you share the opinion that labels are part of the name, the battleship example no good argument against labels:<br>&gt; No one stops you from doing<br>&gt; <br>&gt; let minimum: (Int, Int) -&gt; Int = max<br>&gt; Which is confusing as well.<br>&gt; <br>&gt; Best regards,<br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160703/b4538019/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; As has been discussed exhaustively in this thread, Swift 3 function labels don&#39;t convey the meaning of parameters, they are almost always prepositional phrases that don&#39;t make sense apart from the primary function name they are attached to.<br></p><p>Why should there be different rules for closures and regular functions?<br>If labels are considered useful, they are useful in both contexts, and it should not be forbidden to have labels for closure parameters.<br></p><p>The only thing I don&#39;t like now is that labels are added when the type is inferred; imho that doesn&#39;t make sense in deed, and it would be more consistent to strip them (when labels are part of the name, this is like silently changing variable names to match Hungarian notation ;-).<br></p><p>I&#39;d hardly oppose anything that simplifies the type system, so I agree with Brent that it is ok to remove them first to re-introduce them in a better form later.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160704/764d67d9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  4, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I agree that the current situation is incoherent. If the type system doesn&#39;t care about the labels, the labels probably shouldn&#39;t be in the type.<br></p><p>In the long run, it must be possible to label the parameters of a closure. But that labeling does not *necessarily* belong on the type; it could go on the name:<br></p><p>	// Old and busted<br>	let completion: (records: [Record]?, error: Error?) -&gt; Void<br>	// New hotness<br>	let completion(records:error:): ([Record]?, Error?) -&gt; Void<br></p><p>And I don&#39;t think it would be terrible to remove the labels from the type before we add them to the name.<br></p><p>On the other hand, we could go the other direction and make the labels significant. Or—to address the `remove(from:)`/`add(to:)` critique—we could perhaps make the *internal* names significant, while considering the internal labels as part of the variable name. (Presumably both `remove(from:)` and `add(to:)` would be of type `(collection: WidgetCollection) -&gt; Void`.)<br></p><p>Both options are sensible; the status quo is not. We should choose a direction and start going that way.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. The type system is being a bit nonsensical here.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. Swift 3, breaking everything now, etc.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Can&#39;t really think of much that&#39;s comparable.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  4, 2016 at 02:00:00pm</p></header><div class="content"><p>On 04.07.2016 14:17, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;<br>&gt; I agree that the current situation is incoherent. If the type system doesn&#39;t care about the labels, the labels probably shouldn&#39;t be in the type.<br>&gt;<br>&gt; In the long run, it must be possible to label the parameters of a closure. But that labeling does not *necessarily* belong on the type; it could go on the name:<br>&gt;<br>&gt; 	// Old and busted<br>&gt; 	let completion: (records: [Record]?, error: Error?) -&gt; Void<br>&gt; 	// New hotness<br>&gt; 	let completion(records:error:): ([Record]?, Error?) -&gt; Void<br>&gt;<br></p><p>I really like this idea. Clearly separated &quot;name&quot; and &quot;type&quot; of the <br>function/closure just like for like for any other &quot;simple&quot; variable like <br>`let value: Int`<br>The only note : I believe we should be still allowed to define func <br>variable without labels, if I don&#39;t care about them.<br></p><p>let completion: ([Record]?, Error?) -&gt; Void<br></p><p>&gt; And I don&#39;t think it would be terrible to remove the labels from the type before we add them to the name.<br>&gt;<br></p><p>Support. But it will be great if we&#39;ll have both at the same time.<br></p><p>&gt; On the other hand, we could go the other direction and make the labels significant. Or—to address the `remove(from:)`/`add(to:)` critique—we could perhaps make the *internal* names significant, while considering the internal labels as part of the variable name. (Presumably both `remove(from:)` and `add(to:)` would be of type `(collection: WidgetCollection) -&gt; Void`.)<br></p><p>I don&#39;t feel like this is correct direction. For me parameter labels <br>definitely belongs to name of func variable, not to type.<br></p><p>&gt;<br>&gt; Both options are sensible; the status quo is not. We should choose a direction and start going that way.<br>&gt;<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;<br>&gt; Yes. The type system is being a bit nonsensical here.<br>&gt;<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes. Swift 3, breaking everything now, etc.<br>&gt;<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; Can&#39;t really think of much that&#39;s comparable.<br>&gt;<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;<br>&gt; Quick reading.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 4, 2016, at 1:36 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 04.07.2016 14:17, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I agree that the current situation is incoherent. If the type system doesn&#39;t care about the labels, the labels probably shouldn&#39;t be in the type.<br>&gt;&gt; <br>&gt;&gt; In the long run, it must be possible to label the parameters of a closure. But that labeling does not *necessarily* belong on the type; it could go on the name:<br>&gt;&gt; <br>&gt;&gt; 	// Old and busted<br>&gt;&gt; 	let completion: (records: [Record]?, error: Error?) -&gt; Void<br>&gt;&gt; 	// New hotness<br>&gt;&gt; 	let completion(records:error:): ([Record]?, Error?) -&gt; Void<br>&gt;&gt; <br>&gt; <br>&gt; I really like this idea. Clearly separated &quot;name&quot; and &quot;type&quot; of the function/closure just like for like for any other &quot;simple&quot; variable like `let value: Int`<br>&gt; The only note : I believe we should be still allowed to define func variable without labels, if I don&#39;t care about them.<br>&gt; <br>&gt; let completion: ([Record]?, Error?) -&gt; Void<br>&gt; <br>&gt;&gt; And I don&#39;t think it would be terrible to remove the labels from the type before we add them to the name.<br>&gt;&gt; <br>&gt; <br>&gt; Support. But it will be great if we&#39;ll have both at the same time.<br></p><p>The question is how is this affecting current code base? Remove the labels for Swift 3 and then adding them back in subsequent Swift release - but the labels are already removed from the code... Is this really something we need to have *right now*, instead of waiting for a bit and adding an automatic migration?<br></p><p>I know it&#39;s a code-breaking change, but I don&#39;t think Swift 3.x or Swift 4 will be completely 100% code-compatible, even though it&#39;s one of the goals of Swift 3 to make as many code-breaking changes as possible...<br></p><p>&gt; <br>&gt;&gt; On the other hand, we could go the other direction and make the labels significant. Or—to address the `remove(from:)`/`add(to:)` critique—we could perhaps make the *internal* names significant, while considering the internal labels as part of the variable name. (Presumably both `remove(from:)` and `add(to:)` would be of type `(collection: WidgetCollection) -&gt; Void`.)<br>&gt; <br>&gt; I don&#39;t feel like this is correct direction. For me parameter labels definitely belongs to name of func variable, not to type.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Both options are sensible; the status quo is not. We should choose a direction and start going that way.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes. The type system is being a bit nonsensical here.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes. Swift 3, breaking everything now, etc.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; Can&#39;t really think of much that&#39;s comparable.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Quick reading.<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July  4, 2016 at 04:00:00pm</p></header><div class="content"><p>How does this proposal agree with tuple labels? Compare:<br></p><p>func find(array: [Int], value: Int) -&gt; (index: Int, value: Int)<br>let result = find(...)<br>result.index  //=&gt; 0<br></p><p>func getHandler(for kind: EventKind) -&gt; (event: Event, parent: Widget) -&gt; ()<br>let result = getHandler(...)<br>result(event: ..., parent: ...)<br></p><p>We are going to prohibit second without removing the first; how is that<br>consistent?<br></p><p>2016-07-04 14:17 GMT+03:00 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt; I agree that the current situation is incoherent. If the type system<br>&gt; doesn&#39;t care about the labels, the labels probably shouldn&#39;t be in the type.<br>&gt;<br>&gt; In the long run, it must be possible to label the parameters of a closure.<br>&gt; But that labeling does not *necessarily* belong on the type; it could go on<br>&gt; the name:<br>&gt;<br>&gt;         // Old and busted<br>&gt;         let completion: (records: [Record]?, error: Error?) -&gt; Void<br>&gt;         // New hotness<br>&gt;         let completion(records:error:): ([Record]?, Error?) -&gt; Void<br>&gt;<br>&gt; And I don&#39;t think it would be terrible to remove the labels from the type<br>&gt; before we add them to the name.<br>&gt;<br>&gt; On the other hand, we could go the other direction and make the labels<br>&gt; significant. Or—to address the `remove(from:)`/`add(to:)` critique—we could<br>&gt; perhaps make the *internal* names significant, while considering the<br>&gt; internal labels as part of the variable name. (Presumably both<br>&gt; `remove(from:)` and `add(to:)` would be of type `(collection:<br>&gt; WidgetCollection) -&gt; Void`.)<br>&gt;<br>&gt; Both options are sensible; the status quo is not. We should choose a<br>&gt; direction and start going that way.<br>&gt;<br>&gt; &gt;       * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br>&gt; Yes. The type system is being a bit nonsensical here.<br>&gt;<br>&gt; &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt; Yes. Swift 3, breaking everything now, etc.<br>&gt;<br>&gt; &gt;       * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt; Can&#39;t really think of much that&#39;s comparable.<br>&gt;<br>&gt; &gt;       * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; Quick reading.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160704/4d39d97b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  4, 2016 at 08:00:00pm</p></header><div class="content"><p>On 04.07.2016 16:33, Anton Zhilin via swift-evolution wrote:<br>&gt; How does this proposal agree with tuple labels? Compare:<br>&gt;<br>&gt; func find(array: [Int], value: Int) -&gt; (index: Int, value: Int)<br>&gt; let result = find(...)<br>&gt; result.index  //=&gt; 0<br>&gt;<br>&gt; func getHandler(for kind: EventKind) -&gt; (event: Event, parent: Widget) -&gt; ()<br>&gt; let result = getHandler(...)<br>&gt; result(event: ..., parent: ...)<br>&gt;<br>&gt; We are going to prohibit second without removing the first; how is that<br>&gt; consistent?<br></p><p>I don&#39;t expect this will be changed, and expect this will work similar as <br>for tuples, i.e. for me labels for arguments is just for declaration(for <br>syntax), not for type of returned value: (Swift Ver. 3.0 (Jun 20, 2016))<br></p><p>func f() -&gt; (index: Int, value: Int) { return (index: 1, value: 2) }<br></p><p>let result1 = f()<br>let result2 : (Int, Int) = f()<br></p><p>print(result1, result2) // (1, 2) (1, 2)<br>print(result1.index, result2.0) // 1 1<br>print(result1.dynamicType) // (Int, Int)<br>print(result1.dynamicType == result2.dynamicType) // true<br></p><p>typealias MyTuple = (x: Int, y: Int)<br></p><p>print(MyTuple.self == result1.dynamicType) // true<br></p><p>print(&quot;--------&quot;)<br></p><p>func getHandler(for kind: Int) -&gt; (event: String, parent: String) -&gt; () {<br>     return { event, parent in print(event, parent) }<br>}<br></p><p>var handler1 : (String, String) -&gt; () = {_, _ in }<br>handler1 = getHandler(for: 0)<br>handler1(&quot;event1&quot;, &quot;parent1&quot;)<br></p><p>let handler2 = getHandler(for: 0)<br>handler2(event: &quot;event2&quot;, parent: &quot;parent2&quot;)<br></p><p>print(handler1.dynamicType) // ((String, String)) -&gt; ()<br>print(handler1.dynamicType == handler2.dynamicType) // true<br></p><p><br>func someFunc(name n: String, description d: String) {<br>     print(&quot;name/desc: &quot;, n, d)<br>}<br></p><p>print(someFunc.dynamicType) // ((String, String)) -&gt; ()<br></p><p>print(handler1.dynamicType == someFunc.dynamicType) // true<br></p><p><br>&gt;<br>&gt; 2016-07-04 14:17 GMT+03:00 Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;<br>&gt;     &gt;       * What is your evaluation of the proposal?<br>&gt;<br>&gt;     I agree that the current situation is incoherent. If the type system<br>&gt;     doesn&#39;t care about the labels, the labels probably shouldn&#39;t be in the<br>&gt;     type.<br>&gt;<br>&gt;     In the long run, it must be possible to label the parameters of a<br>&gt;     closure. But that labeling does not *necessarily* belong on the type;<br>&gt;     it could go on the name:<br>&gt;<br>&gt;             // Old and busted<br>&gt;             let completion: (records: [Record]?, error: Error?) -&gt; Void<br>&gt;             // New hotness<br>&gt;             let completion(records:error:): ([Record]?, Error?) -&gt; Void<br>&gt;<br>&gt;     And I don&#39;t think it would be terrible to remove the labels from the<br>&gt;     type before we add them to the name.<br>&gt;<br>&gt;     On the other hand, we could go the other direction and make the labels<br>&gt;     significant. Or—to address the `remove(from:)`/`add(to:)` critique—we<br>&gt;     could perhaps make the *internal* names significant, while considering<br>&gt;     the internal labels as part of the variable name. (Presumably both<br>&gt;     `remove(from:)` and `add(to:)` would be of type `(collection:<br>&gt;     WidgetCollection) -&gt; Void`.)<br>&gt;<br>&gt;     Both options are sensible; the status quo is not. We should choose a<br>&gt;     direction and start going that way.<br>&gt;<br>&gt;     &gt;       * Is the problem being addressed significant enough to warrant<br>&gt;     a change to Swift?<br>&gt;<br>&gt;     Yes. The type system is being a bit nonsensical here.<br>&gt;<br>&gt;     &gt;       * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;     Yes. Swift 3, breaking everything now, etc.<br>&gt;<br>&gt;     &gt;       * If you have used other languages or libraries with a similar<br>&gt;     feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt;     Can&#39;t really think of much that&#39;s comparable.<br>&gt;<br>&gt;     &gt;       * How much effort did you put into your review? A glance, a<br>&gt;     quick reading, or an in-depth study?<br>&gt;<br>&gt;     Quick reading.<br>&gt;<br>&gt;     --<br>&gt;     Brent Royal-Gordon<br>&gt;     Architechies<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  4, 2016 at 08:00:00pm</p></header><div class="content"><p>An interesting take on arg label/name, granted this is including destructuring of obj literals (so one level down from the method sig, but which is not without analogy to what could be done to tuples with named fields). The main point of comparison is what the type of f1 and f2 are. <br></p><p>This is in typescript, where the signatures ultimately have to translate down to javascript where everything maps to <br>f(p,q,r,s,t) {<br>  var p1 = arguments.0; // is p or this<br>   ...<br>}<br>last week i was back to writing lots of ts 1.8 code and i find the type system incredibly precise and flexible (P|Q... yeah)<br></p><p>// Type of f1 is (arg?: { x?: number, y?: number }) =&gt; void <br>function f1({ x = 0, y = 0 } = {}) { } <br></p><p>// And can be called as: <br>f1(); <br>f1({}); <br>f1({ x: 1 }); <br>f1({ y: 1 }); <br>f1({ x: 1, y: 1 }); <br></p><p>// Type of f2 is (arg?: (x: number, y?: number) =&gt; void <br>function f2({ x, y = 0 } = { x: 0 }) { } <br>f2(); <br>f2({});                 // Error, x not optional <br>f2({ x: 1 }); <br>f2({ y: 1 });          // Error, x not optional <br>f2({ x: 1, y: 1 });<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 30, 2016, at 8:26 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0111: Remove type system significance of function argument labels&quot; begins now and runs through July 4. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160704/eafac5db/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
