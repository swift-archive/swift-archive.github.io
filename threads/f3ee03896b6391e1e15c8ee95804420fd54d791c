<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 03:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt; the objection that when using withUnsafePointer with a global, there<br>&gt; is an expectation that you’ll get the same address every<br>&gt; time. Removing inout would cause the argument to be passed by value<br>&gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt; have a version of withUnsafePointer that does not require an inout<br>&gt; argument.<br>&gt;<br>&gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt; no reason to have both withUnsafePointer and<br>&gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt; will be an implicit conversion to make it work. I discussed this with<br>&gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt; an UnsafeMutablePointer.<br></p><p>Very much in favor of Option 1.<br></p><p>&gt;<br>&gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt; other not. This would address the inconvenience of not being able to<br>&gt; use withUnsafePointer with immutable values, while still supporting<br>&gt; the existing behavior. The question then would be what to call these<br>&gt; two functions.<br></p><p>We do not need to support new use-cases in this release, and this would<br>be unsatisfying because the “address of a global” property that Jordan<br>argued for would not hold for the immutable version.<br></p><p>&gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt; a new name for the non-inout version, e.g.,<br>&gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt; old function. (That particular name doesn’t work very well when<br>&gt; dealing with references to objects, since the object itself would not<br>&gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt; advantage of this approach is that we would not need to rush the new<br>&gt; function into Swift 3 since it would be an additive change.<br></p><p>Not rushing that into Swift 3 is the same as Option 1.<br></p><p>&gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt; where you care about the getting the same address. Change<br>&gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt; we could have the migrator convert all existing uses on<br>&gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt; Swift 3, but I’m not sure how well that would work.<br></p><p>That&#39;s exactly the same outcome, with respect to the language/library<br>surface, as Option 2 AFAICT.  Can we simplify this list of options?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 5:06 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt; &gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt; &gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt; &gt; the objection that when using withUnsafePointer with a global, there<br>&gt; &gt; is an expectation that you’ll get the same address every<br>&gt; &gt; time. Removing inout would cause the argument to be passed by value<br>&gt; &gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt; &gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt; &gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt; &gt; have a version of withUnsafePointer that does not require an inout<br>&gt; &gt; argument.<br>&gt; &gt;<br>&gt; &gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt; &gt; no reason to have both withUnsafePointer and<br>&gt; &gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt; &gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt; &gt; will be an implicit conversion to make it work. I discussed this with<br>&gt; &gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt; &gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt; &gt; an UnsafeMutablePointer.<br>&gt;<br>&gt; Very much in favor of Option 1.<br>&gt;<br></p><p>Ditto, except that I think there is some value in keeping both (i.e. doing<br>nothing): allowing the user to document intent. It would be inconsistent<br>and potentially confusing to call the function that returns an<br>`UnsafeMutablePointer` `withUnsafePointer`. It&#39;s rarely used enough, and<br>the shorter name needlessly raises the question of where I&#39;m really<br>&quot;supposed to be&quot; mutating the pointee. I&#39;ve not had to use these functions<br>much, but the distinction between `Array.withUnsafeBufferPointer(_:)` and<br>`Array.withUnsafeMutableBufferPointer(_:)` has conditioned me to mutate the<br>pointee using only &quot;mutable&quot; functions.<br></p><p><br>&gt; &gt;<br>&gt; &gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt; &gt; other not. This would address the inconvenience of not being able to<br>&gt; &gt; use withUnsafePointer with immutable values, while still supporting<br>&gt; &gt; the existing behavior. The question then would be what to call these<br>&gt; &gt; two functions.<br>&gt;<br>&gt; We do not need to support new use-cases in this release, and this would<br>&gt; be unsatisfying because the “address of a global” property that Jordan<br>&gt; argued for would not hold for the immutable version.<br>&gt;<br>&gt; &gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt; &gt; a new name for the non-inout version, e.g.,<br>&gt; &gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt; &gt; old function. (That particular name doesn’t work very well when<br>&gt; &gt; dealing with references to objects, since the object itself would not<br>&gt; &gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt; &gt; advantage of this approach is that we would not need to rush the new<br>&gt; &gt; function into Swift 3 since it would be an additive change.<br>&gt;<br>&gt; Not rushing that into Swift 3 is the same as Option 1.<br>&gt;<br>&gt; &gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt; &gt; where you care about the getting the same address. Change<br>&gt; &gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt; &gt; we could have the migrator convert all existing uses on<br>&gt; &gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt; &gt; Swift 3, but I’m not sure how well that would work.<br>&gt;<br>&gt; That&#39;s exactly the same outcome, with respect to the language/library<br>&gt; surface, as Option 2 AFAICT.  Can we simplify this list of options?<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/8fb18917/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
