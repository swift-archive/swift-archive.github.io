<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>KÃ¡roly LÅ‘rentey</string> &lt;karoly at lorentey.hu&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>On 2016-07-21 15:33:37 +0000, Chris Lattner via swift-evolution said:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I gave enthusiastic thumbs up to the previous two proposals. I agree<br>wholeheartedly with the underlying goal, and I love the new Motivation<br>section. I&#39;m OK with the idea of making &quot;open&quot; imply &quot;public&quot; by<br>default, which seems to be the gist of the new design.<br></p><p>However, reading the actual details in this third revision made me<br>uncomfortable. I expected the specification to be bulletproof by now;<br>but the actual text of the &quot;Proposed design&quot; section seems to be even<br>less coherent than the previous two.<br></p><p>I understand there&#39;s a (self-imposed) deadline, but this one could&#39;ve<br>really used a little more time in the oven.<br></p><p>While I am still strongly in favor of the direction and high-level<br>design of the proposal, I cannot in good conscience argue in favor<br>of such ill-defined details in a _third_review_. So I&#39;m giving<br>this specific revision -1 in protest. ðŸ˜¢<br></p><p>Here are some of my problems with the text:<br></p><p>1. The proposal offers two separate design approaches for `open` <br>classes, listing<br>   arguments for both. Please excuse my bluntness, but this is now the <br>third attempt<br>   to push this through: With all due respect, would you please make up <br>your mind?<br></p><p><br>2. The option to get rid of sealed classes is brand new with SE-0117rev3.<br>   Did someone argue for it in review #2?<br></p><p>   (I&#39;m all for adding better support for sealed class hierarchies, so <br>I prefer plan A.)<br></p><p>   It&#39;s nice that we&#39;re given the option of reducing language <br>complexity, but then<br>   it&#39;s bizarre that the idea of eliminating sealed _members_ isn&#39;t <br>mentioned at all.<br></p><p>   Although, a literal reading of &quot;plan B&quot; does in fact seem to imply <br>that any member<br>   that is not explicitly marked open would not even be _internally_ <br>overridable:<br></p><p>      &quot;The second design says that there is no such thing as an open <br>class because<br>      all classes are subclassable unless made final. Note that its <br>direct methods<br>      would still not be overridable unless individually made open, <br>although its<br>      inherited open methods could still be overridden.&quot;<br></p><p>   There is no mention of &quot;public&quot;, and no mention of module boundaries.<br>   Thus, plan B basically proposes to make *all members* in *all <br>classes* `final` by default.<br>   This seems inconsistent with the rest of the proposal, so I&#39;ll <br>assume this is a<br>   mistake in wording, not the actual design intent. (Or is it?)<br></p><p>   Let&#39;s assume the intent was to keep members internally overridable <br>by default.<br>   But then why not go the full way? We can achieve the proposal&#39;s <br>goals by just tweaking<br>   existing defaults -- there&#39;s no need to introduce complicated new <br>overridability levels:<br></p><p>   &quot;This proposal does not change the rules of class subclassibility. <br>However, it introduces the<br>   (previously implicit) &quot;open&quot; qualifier to explicitly declare an <br>overridable member,<br>   and changes the rules of default overridability as follows:<br>     - Members of public classes are now final by default.<br>     - Members of internal and private classes remain overridable <br>(&quot;open&quot;) by default.&quot;<br></p><p>   I prefer plan A, but I&#39;d also be OK with this bare-bones proposal.<br></p><p>   I&#39;m strongly opposed to plan B (either as stated in the proposal or <br>what (I assume<br>   above) is the intent behind it.)<br></p><p><br>3. The code examples are needlessly complicated by trying to describe <br>both sub-proposals.<br>   I find this is confusing and it obscures the actual effect of both variants.<br></p><p>   The examples are also inconsistent with the text: e.g., AFAICT, <br>property `size` below<br>   is still intended to be overridable inside the module that defines<br>   `SubclassableParentClass`.<br></p><p>       open class SubclassableParentClass {<br>         // This property is not overridable.<br>         public var size : Int<br>         ...<br>       }<br></p><p>4. The previous revisions ignored dynamic members, which wasn&#39;t great. <br>The current<br>   document acknowleges that &quot;dynamic&quot; members exists, but then *prohibits*<br>   them from being overridden across a module boundary!<br></p><p>      &quot;`open` is not permitted on declarations that are explicitly <br>`final` or `dynamic`.&quot;<br>      &quot;A class member that is not `open` cannot be overridden outside <br>of the current module.&quot;<br></p><p>   If this was intentional, I&#39;d love to see the reasoning behind this decision.<br>   Otherwise the wording should be fixed:<br></p><p>      &quot;A class member that is not `open` or `dynamic` cannot be <br>overridden outside<br>      of the current module.&quot;<br></p><p><br>5. It seems strangely inconsistent that `open` now implies `public` by default,<br>   but `final` doesn&#39;t. The proposal fails to explain this inconsistency.<br>   Was this point considered and dismissed, or was it not considered at all?<br></p><p>   Changing `final` to imply `public` later would be a source-breaking change.<br>   Given that SE-0117 is one of the last proposals where maintaining source<br>   compatibility isn&#39;t a major consideration, it&#39;s unclear if we&#39;ll <br>ever have an<br>   opportunity to fix such minor inconsistencies.<br></p><p>   The same argument also applies to `dynamic`. If it&#39;s OK for `open func` to<br>   imply public visibility, wouldn&#39;t it follow from same logic that we should<br>   treat `final func` and `dynamic func` the same way?<br></p><p><br>6. The proposal does not suggest an explicit spelling for the new default level<br>   of internal-only overridability for public classes and members.<br></p><p>   We can add an optional contextual keyword later, in an additive proposal.<br>   However, failing to mention this point makes me question if it was <br>intentionally<br>   omitted to prevent bikeshedding, or just forgotten.<br></p><p><br>7. &quot;`open` is permitted only on class declarations and overridable <br>class members<br>   (i.e. var, func, and subscript).&quot;<br></p><p>   Presumably this list is to be taken to include `class func`, but not <br>`static func`.<br>   Or would `class func` remain open by default?<br></p><p><br>8. The opening clause in the &quot;open class members&quot; section makes no sense to me.<br></p><p>      &quot;A class member that overrides an open class member must be <br>explicitly declared open<br>      unless it is explicitly final or it is a member of a final or <br>non-public class.<br>      In any case, it is considered open.&quot;<br></p><p>   So, AFAICU, when a public member of a public open class overrides a <br>superclass member,<br>   we will have to write either &quot;open override&quot; or &quot;final override&quot;. <br>Temporary restriction, fine.<br>   (Shouldn&#39;t &quot;dynamic override&quot; be a thing, though?)<br></p><p>   But if these are &quot;considered open in any case&quot;, why force us to add <br>misleading boilerplate?<br>   What does it mean for a member of a final class to be &quot;considered open&quot;?<br></p><p><br>9. I have trouble interpreting the parenthesized statement in the <br>following clause:<br></p><p>      &quot;`open` is not permitted on declarations that are explicitly <br>`final` or `dynamic`.<br>      (Note that it&#39;s okay if one or both of the modifiers are <br>implicitly inferred.)&quot;<br></p><p>   Can &quot;dynamic&quot; ever be implicitly inferred? Can both &quot;dynamic&quot; and <br>&quot;final&quot; ever apply at<br>   once? I assume &quot;it&#39;s okay&quot; here means `open` is allowed but ignored, <br>in either case.<br>   Is that right?<br></p><p><br></p><p>Ayayay, so much drama!<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a <br>&gt; change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar <br>&gt; feature, how do you feel that this proposal compares to those?<br></p><p>See previous reviews.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick <br>&gt; reading, or an in-depth study?<br></p><p>Probably more than it deserves? ;-)<br></p><p>-- <br>KÃ¡roly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 9:09 AM, KÃ¡roly LÅ‘rentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 2016-07-21 15:33:37 +0000, Chris Lattner via swift-evolution said:<br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I gave enthusiastic thumbs up to the previous two proposals. I agree<br>&gt; wholeheartedly with the underlying goal, and I love the new Motivation<br>&gt; section. I&#39;m OK with the idea of making &quot;open&quot; imply &quot;public&quot; by<br>&gt; default, which seems to be the gist of the new design.<br>&gt; <br>&gt; However, reading the actual details in this third revision made me<br>&gt; uncomfortable. I expected the specification to be bulletproof by now;<br>&gt; but the actual text of the &quot;Proposed design&quot; section seems to be even<br>&gt; less coherent than the previous two.<br>&gt; <br>&gt; I understand there&#39;s a (self-imposed) deadline, but this one could&#39;ve<br>&gt; really used a little more time in the oven.<br>&gt; <br>&gt; While I am still strongly in favor of the direction and high-level<br>&gt; design of the proposal, I cannot in good conscience argue in favor<br>&gt; of such ill-defined details in a _third_review_. So I&#39;m giving<br>&gt; this specific revision -1 in protest. ðŸ˜¢<br></p><p>I&#39;m sorry if my drafting wasn&#39;t up to snuff.  In my defense, I needed to get it out quickly,<br>and I had a lot to rewrite.  I was pretty tired by the time I actually finished the motivation<br>section.<br></p><p>&gt; Here are some of my problems with the text:<br>&gt; <br>&gt; 1. The proposal offers two separate design approaches for `open` classes, listing<br>&gt;  arguments for both. Please excuse my bluntness, but this is now the third attempt<br>&gt;  to push this through: With all due respect, would you please make up your mind?<br></p><p>Most of the proposal has been &quot;pushed through&quot;, frankly.  We are looking for feedback<br>on this specific question.  I agree that the proposal framework is an awkward fit for<br>this kind of discussion prompt.<br></p><p>&gt; 2. The option to get rid of sealed classes is brand new with SE-0117rev3.<br>&gt;  Did someone argue for it in review #2?<br>&gt; <br>&gt;  (I&#39;m all for adding better support for sealed class hierarchies, so I prefer plan A.)<br>&gt; <br>&gt;  It&#39;s nice that we&#39;re given the option of reducing language complexity, but then<br>&gt;  it&#39;s bizarre that the idea of eliminating sealed _members_ isn&#39;t mentioned at all.<br></p><p>Because it was settled in the core-team review.<br></p><p>&gt;  Although, a literal reading of &quot;plan B&quot; does in fact seem to imply that any member<br>&gt;  that is not explicitly marked open would not even be _internally_ overridable:<br>&gt; <br>&gt;     &quot;The second design says that there is no such thing as an open class because<br>&gt;     all classes are subclassable unless made final. Note that its direct methods<br>&gt;     would still not be overridable unless individually made open, although its<br>&gt;     inherited open methods could still be overridden.&quot;<br>&gt; <br>&gt;  There is no mention of &quot;public&quot;, and no mention of module boundaries.<br>&gt;  Thus, plan B basically proposes to make *all members* in *all classes* `final` by default.<br>&gt;  This seems inconsistent with the rest of the proposal, so I&#39;ll assume this is a<br>&gt;  mistake in wording, not the actual design intent. (Or is it?)<br></p><p>It is a mistake in wording.<br></p><p>&gt;  Let&#39;s assume the intent was to keep members internally overridable by default.<br>&gt;  But then why not go the full way? We can achieve the proposal&#39;s goals by just tweaking<br>&gt;  existing defaults -- there&#39;s no need to introduce complicated new overridability levels:<br>&gt; <br>&gt;  &quot;This proposal does not change the rules of class subclassibility. However, it introduces the<br>&gt;  (previously implicit) &quot;open&quot; qualifier to explicitly declare an overridable member,<br>&gt;  and changes the rules of default overridability as follows:<br>&gt;    - Members of public classes are now final by default.<br>&gt;    - Members of internal and private classes remain overridable (&quot;open&quot;) by default.&quot;<br>&gt; <br>&gt;  I prefer plan A, but I&#39;d also be OK with this bare-bones proposal.<br>&gt; <br>&gt;  I&#39;m strongly opposed to plan B (either as stated in the proposal or what (I assume<br>&gt;  above) is the intent behind it.)<br></p><p>Thank you, that&#39;s what we&#39;re looking for.<br></p><p>&gt; 3. The code examples are needlessly complicated by trying to describe both sub-proposals.<br>&gt;  I find this is confusing and it obscures the actual effect of both variants.<br></p><p>I&#39;m sorry, I didn&#39;t have much of a choice about this.  Perhaps I could have broken it out<br>into two completely different code examples.<br></p><p>&gt;  The examples are also inconsistent with the text: e.g., AFAICT, property `size` below<br>&gt;  is still intended to be overridable inside the module that defines<br>&gt;  `SubclassableParentClass`.<br>&gt; <br>&gt;      open class SubclassableParentClass {<br>&gt;        // This property is not overridable.<br>&gt;        public var size : Int<br>&gt;        ...<br>&gt;      }<br></p><p>Yes, this should read &quot;not overridable outside of the current module&quot;.<br></p><p>&gt; 4. The previous revisions ignored dynamic members, which wasn&#39;t great. The current<br>&gt;  document acknowleges that &quot;dynamic&quot; members exists, but then *prohibits*<br>&gt;  them from being overridden across a module boundary!<br>&gt; <br>&gt;     &quot;`open` is not permitted on declarations that are explicitly `final` or `dynamic`.&quot;<br>&gt;     &quot;A class member that is not `open` cannot be overridden outside of the current module.&quot;<br>&gt; <br>&gt;  If this was intentional, I&#39;d love to see the reasoning behind this decision.<br>&gt;  Otherwise the wording should be fixed:<br>&gt; <br>&gt;     &quot;A class member that is not `open` or `dynamic` cannot be overridden outside<br>&gt;     of the current module.&quot;<br></p><p>Yes, sorry, this was a drafting error again.<br></p><p>&gt; 5. It seems strangely inconsistent that `open` now implies `public` by default,<br>&gt;  but `final` doesn&#39;t. The proposal fails to explain this inconsistency.<br>&gt;  Was this point considered and dismissed, or was it not considered at all?<br></p><p>I think the best model of thinking about &quot;open&quot; is that it is an access level above &quot;public&quot;.<br>The idea of allowing &quot;internal open&quot; came out of discussion but in retrospect does not<br>seem to hold its own.<br></p><p>&gt;  Changing `final` to imply `public` later would be a source-breaking change.<br>&gt;  Given that SE-0117 is one of the last proposals where maintaining source<br>&gt;  compatibility isn&#39;t a major consideration, it&#39;s unclear if we&#39;ll ever have an<br>&gt;  opportunity to fix such minor inconsistencies.<br>&gt; <br>&gt;  The same argument also applies to `dynamic`. If it&#39;s OK for `open func` to<br>&gt;  imply public visibility, wouldn&#39;t it follow from same logic that we should<br>&gt;  treat `final func` and `dynamic func` the same way?<br>&gt; <br>&gt; <br>&gt; 6. The proposal does not suggest an explicit spelling for the new default level<br>&gt;  of internal-only overridability for public classes and members.<br>&gt; <br>&gt;  We can add an optional contextual keyword later, in an additive proposal.<br>&gt;  However, failing to mention this point makes me question if it was intentionally<br>&gt;  omitted to prevent bikeshedding, or just forgotten.<br>&gt; <br>&gt; <br>&gt; 7. &quot;`open` is permitted only on class declarations and overridable class members<br>&gt;  (i.e. var, func, and subscript).&quot;<br>&gt; <br>&gt;  Presumably this list is to be taken to include `class func`, but not `static func`.<br>&gt;  Or would `class func` remain open by default?<br></p><p>&quot;class&quot; members are still members.  The model for &quot;static&quot; on class members has always<br>been that they are implicitly final.<br></p><p>&gt; 8. The opening clause in the &quot;open class members&quot; section makes no sense to me.<br>&gt; <br>&gt;     &quot;A class member that overrides an open class member must be explicitly declared open<br>&gt;     unless it is explicitly final or it is a member of a final or non-public class.<br>&gt;     In any case, it is considered open.&quot;<br>&gt; <br>&gt;  So, AFAICU, when a public member of a public open class overrides a superclass member,<br>&gt;  we will have to write either &quot;open override&quot; or &quot;final override&quot;. Temporary restriction, fine.<br>&gt;  (Shouldn&#39;t &quot;dynamic override&quot; be a thing, though?)<br>&gt; <br>&gt;  But if these are &quot;considered open in any case&quot;, why force us to add misleading boilerplate?<br>&gt;  What does it mean for a member of a final class to be &quot;considered open&quot;?<br></p><p>Today, you would have to write &quot;public override&quot; on such a member.  It is not added<br>boilerplate to say that you have to instead write &quot;open override&quot; unless your intent is to<br>close off overriding (in which case you have to write &quot;public final override&quot;).<br></p><p>&gt; 9. I have trouble interpreting the parenthesized statement in the following clause:<br>&gt; <br>&gt;     &quot;`open` is not permitted on declarations that are explicitly `final` or `dynamic`.<br>&gt;     (Note that it&#39;s okay if one or both of the modifiers are implicitly inferred.)&quot;<br>&gt; <br>&gt;  Can &quot;dynamic&quot; ever be implicitly inferred?<br></p><p>It&#39;s inherited.  I can&#39;t remember if we require it to be explicit on the override.<br></p><p>&gt; Can both &quot;dynamic&quot; and &quot;final&quot; ever apply at once?<br></p><p>This is currently forbidden when explicit, but you can declare a dynamic member of a final class.<br></p><p>&gt; I assume &quot;it&#39;s okay&quot; here means `open` is allowed but ignored, in either case.<br>&gt;  Is that right?<br></p><p>Probably the right rule is that open can be subsumed by dynamic, so that you can override<br>an open member and make it dynamic.  I&#39;m not sure whether you should be able to say just<br>&quot;open&quot; on an override of a dynamic member when it clearly remains dynamic.<br></p><p>Inherited open-ness will be ignored on a final class or member.<br></p><p>Honestly, this is why I don&#39;t like to include this level of detail in proposals.  People complain if<br>it&#39;s not there, but including it just invites a bunch of complaints about every detail and distracts<br>from the important parts of the discussion.<br></p><p>John.<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; Ayayay, so much drama!<br>&gt; <br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; See previous reviews.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Probably more than it deserves? ;-)<br>&gt; <br>&gt; -- <br>&gt; KÃ¡roly<br>&gt; @lorentey<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>KÃ¡roly LÅ‘rentey</string> &lt;karoly at lorentey.hu&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>Thank you very much for clarifying these! My position is now of course back in favor of the proposal. +1<br></p><p>(Sorry for being a stickler; I know what deadlines are like. I hope the team gets a bit of time to rest.)<br></p><p>&lt;3,<br>-- <br>KÃ¡roly<br>@lorentey<br></p><p>&gt; On 2016-07-22, at 18:36, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 22, 2016, at 9:09 AM, KÃ¡roly LÅ‘rentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 2016-07-21 15:33:37 +0000, Chris Lattner via swift-evolution said:<br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I gave enthusiastic thumbs up to the previous two proposals. I agree<br>&gt;&gt; wholeheartedly with the underlying goal, and I love the new Motivation<br>&gt;&gt; section. I&#39;m OK with the idea of making &quot;open&quot; imply &quot;public&quot; by<br>&gt;&gt; default, which seems to be the gist of the new design.<br>&gt;&gt; <br>&gt;&gt; However, reading the actual details in this third revision made me<br>&gt;&gt; uncomfortable. I expected the specification to be bulletproof by now;<br>&gt;&gt; but the actual text of the &quot;Proposed design&quot; section seems to be even<br>&gt;&gt; less coherent than the previous two.<br>&gt;&gt; <br>&gt;&gt; I understand there&#39;s a (self-imposed) deadline, but this one could&#39;ve<br>&gt;&gt; really used a little more time in the oven.<br>&gt;&gt; <br>&gt;&gt; While I am still strongly in favor of the direction and high-level<br>&gt;&gt; design of the proposal, I cannot in good conscience argue in favor<br>&gt;&gt; of such ill-defined details in a _third_review_. So I&#39;m giving<br>&gt;&gt; this specific revision -1 in protest. ðŸ˜¢<br>&gt; <br>&gt; I&#39;m sorry if my drafting wasn&#39;t up to snuff.  In my defense, I needed to get it out quickly,<br>&gt; and I had a lot to rewrite.  I was pretty tired by the time I actually finished the motivation<br>&gt; section.<br>&gt; <br>&gt;&gt; Here are some of my problems with the text:<br>&gt;&gt; <br>&gt;&gt; 1. The proposal offers two separate design approaches for `open` classes, listing<br>&gt;&gt; arguments for both. Please excuse my bluntness, but this is now the third attempt<br>&gt;&gt; to push this through: With all due respect, would you please make up your mind?<br>&gt; <br>&gt; Most of the proposal has been &quot;pushed through&quot;, frankly.  We are looking for feedback<br>&gt; on this specific question.  I agree that the proposal framework is an awkward fit for<br>&gt; this kind of discussion prompt.<br>&gt; <br>&gt;&gt; 2. The option to get rid of sealed classes is brand new with SE-0117rev3.<br>&gt;&gt; Did someone argue for it in review #2?<br>&gt;&gt; <br>&gt;&gt; (I&#39;m all for adding better support for sealed class hierarchies, so I prefer plan A.)<br>&gt;&gt; <br>&gt;&gt; It&#39;s nice that we&#39;re given the option of reducing language complexity, but then<br>&gt;&gt; it&#39;s bizarre that the idea of eliminating sealed _members_ isn&#39;t mentioned at all.<br>&gt; <br>&gt; Because it was settled in the core-team review.<br>&gt; <br>&gt;&gt; Although, a literal reading of &quot;plan B&quot; does in fact seem to imply that any member<br>&gt;&gt; that is not explicitly marked open would not even be _internally_ overridable:<br>&gt;&gt; <br>&gt;&gt;    &quot;The second design says that there is no such thing as an open class because<br>&gt;&gt;    all classes are subclassable unless made final. Note that its direct methods<br>&gt;&gt;    would still not be overridable unless individually made open, although its<br>&gt;&gt;    inherited open methods could still be overridden.&quot;<br>&gt;&gt; <br>&gt;&gt; There is no mention of &quot;public&quot;, and no mention of module boundaries.<br>&gt;&gt; Thus, plan B basically proposes to make *all members* in *all classes* `final` by default.<br>&gt;&gt; This seems inconsistent with the rest of the proposal, so I&#39;ll assume this is a<br>&gt;&gt; mistake in wording, not the actual design intent. (Or is it?)<br>&gt; <br>&gt; It is a mistake in wording.<br>&gt; <br>&gt;&gt; Let&#39;s assume the intent was to keep members internally overridable by default.<br>&gt;&gt; But then why not go the full way? We can achieve the proposal&#39;s goals by just tweaking<br>&gt;&gt; existing defaults -- there&#39;s no need to introduce complicated new overridability levels:<br>&gt;&gt; <br>&gt;&gt; &quot;This proposal does not change the rules of class subclassibility. However, it introduces the<br>&gt;&gt; (previously implicit) &quot;open&quot; qualifier to explicitly declare an overridable member,<br>&gt;&gt; and changes the rules of default overridability as follows:<br>&gt;&gt;   - Members of public classes are now final by default.<br>&gt;&gt;   - Members of internal and private classes remain overridable (&quot;open&quot;) by default.&quot;<br>&gt;&gt; <br>&gt;&gt; I prefer plan A, but I&#39;d also be OK with this bare-bones proposal.<br>&gt;&gt; <br>&gt;&gt; I&#39;m strongly opposed to plan B (either as stated in the proposal or what (I assume<br>&gt;&gt; above) is the intent behind it.)<br>&gt; <br>&gt; Thank you, that&#39;s what we&#39;re looking for.<br>&gt; <br>&gt;&gt; 3. The code examples are needlessly complicated by trying to describe both sub-proposals.<br>&gt;&gt; I find this is confusing and it obscures the actual effect of both variants.<br>&gt; <br>&gt; I&#39;m sorry, I didn&#39;t have much of a choice about this.  Perhaps I could have broken it out<br>&gt; into two completely different code examples.<br>&gt; <br>&gt;&gt; The examples are also inconsistent with the text: e.g., AFAICT, property `size` below<br>&gt;&gt; is still intended to be overridable inside the module that defines<br>&gt;&gt; `SubclassableParentClass`.<br>&gt;&gt; <br>&gt;&gt;     open class SubclassableParentClass {<br>&gt;&gt;       // This property is not overridable.<br>&gt;&gt;       public var size : Int<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt; <br>&gt; Yes, this should read &quot;not overridable outside of the current module&quot;.<br>&gt; <br>&gt;&gt; 4. The previous revisions ignored dynamic members, which wasn&#39;t great. The current<br>&gt;&gt; document acknowleges that &quot;dynamic&quot; members exists, but then *prohibits*<br>&gt;&gt; them from being overridden across a module boundary!<br>&gt;&gt; <br>&gt;&gt;    &quot;`open` is not permitted on declarations that are explicitly `final` or `dynamic`.&quot;<br>&gt;&gt;    &quot;A class member that is not `open` cannot be overridden outside of the current module.&quot;<br>&gt;&gt; <br>&gt;&gt; If this was intentional, I&#39;d love to see the reasoning behind this decision.<br>&gt;&gt; Otherwise the wording should be fixed:<br>&gt;&gt; <br>&gt;&gt;    &quot;A class member that is not `open` or `dynamic` cannot be overridden outside<br>&gt;&gt;    of the current module.&quot;<br>&gt; <br>&gt; Yes, sorry, this was a drafting error again.<br>&gt; <br>&gt;&gt; 5. It seems strangely inconsistent that `open` now implies `public` by default,<br>&gt;&gt; but `final` doesn&#39;t. The proposal fails to explain this inconsistency.<br>&gt;&gt; Was this point considered and dismissed, or was it not considered at all?<br>&gt; <br>&gt; I think the best model of thinking about &quot;open&quot; is that it is an access level above &quot;public&quot;.<br>&gt; The idea of allowing &quot;internal open&quot; came out of discussion but in retrospect does not<br>&gt; seem to hold its own.<br>&gt; <br>&gt;&gt; Changing `final` to imply `public` later would be a source-breaking change.<br>&gt;&gt; Given that SE-0117 is one of the last proposals where maintaining source<br>&gt;&gt; compatibility isn&#39;t a major consideration, it&#39;s unclear if we&#39;ll ever have an<br>&gt;&gt; opportunity to fix such minor inconsistencies.<br>&gt;&gt; <br>&gt;&gt; The same argument also applies to `dynamic`. If it&#39;s OK for `open func` to<br>&gt;&gt; imply public visibility, wouldn&#39;t it follow from same logic that we should<br>&gt;&gt; treat `final func` and `dynamic func` the same way?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 6. The proposal does not suggest an explicit spelling for the new default level<br>&gt;&gt; of internal-only overridability for public classes and members.<br>&gt;&gt; <br>&gt;&gt; We can add an optional contextual keyword later, in an additive proposal.<br>&gt;&gt; However, failing to mention this point makes me question if it was intentionally<br>&gt;&gt; omitted to prevent bikeshedding, or just forgotten.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 7. &quot;`open` is permitted only on class declarations and overridable class members<br>&gt;&gt; (i.e. var, func, and subscript).&quot;<br>&gt;&gt; <br>&gt;&gt; Presumably this list is to be taken to include `class func`, but not `static func`.<br>&gt;&gt; Or would `class func` remain open by default?<br>&gt; <br>&gt; &quot;class&quot; members are still members.  The model for &quot;static&quot; on class members has always<br>&gt; been that they are implicitly final.<br>&gt; <br>&gt;&gt; 8. The opening clause in the &quot;open class members&quot; section makes no sense to me.<br>&gt;&gt; <br>&gt;&gt;    &quot;A class member that overrides an open class member must be explicitly declared open<br>&gt;&gt;    unless it is explicitly final or it is a member of a final or non-public class.<br>&gt;&gt;    In any case, it is considered open.&quot;<br>&gt;&gt; <br>&gt;&gt; So, AFAICU, when a public member of a public open class overrides a superclass member,<br>&gt;&gt; we will have to write either &quot;open override&quot; or &quot;final override&quot;. Temporary restriction, fine.<br>&gt;&gt; (Shouldn&#39;t &quot;dynamic override&quot; be a thing, though?)<br>&gt;&gt; <br>&gt;&gt; But if these are &quot;considered open in any case&quot;, why force us to add misleading boilerplate?<br>&gt;&gt; What does it mean for a member of a final class to be &quot;considered open&quot;?<br>&gt; <br>&gt; Today, you would have to write &quot;public override&quot; on such a member.  It is not added<br>&gt; boilerplate to say that you have to instead write &quot;open override&quot; unless your intent is to<br>&gt; close off overriding (in which case you have to write &quot;public final override&quot;).<br>&gt; <br>&gt;&gt; 9. I have trouble interpreting the parenthesized statement in the following clause:<br>&gt;&gt; <br>&gt;&gt;    &quot;`open` is not permitted on declarations that are explicitly `final` or `dynamic`.<br>&gt;&gt;    (Note that it&#39;s okay if one or both of the modifiers are implicitly inferred.)&quot;<br>&gt;&gt; <br>&gt;&gt; Can &quot;dynamic&quot; ever be implicitly inferred?<br>&gt; <br>&gt; It&#39;s inherited.  I can&#39;t remember if we require it to be explicit on the override.<br>&gt; <br>&gt;&gt; Can both &quot;dynamic&quot; and &quot;final&quot; ever apply at once?<br>&gt; <br>&gt; This is currently forbidden when explicit, but you can declare a dynamic member of a final class.<br>&gt; <br>&gt;&gt; I assume &quot;it&#39;s okay&quot; here means `open` is allowed but ignored, in either case.<br>&gt;&gt; Is that right?<br>&gt; <br>&gt; Probably the right rule is that open can be subsumed by dynamic, so that you can override<br>&gt; an open member and make it dynamic.  I&#39;m not sure whether you should be able to say just<br>&gt; &quot;open&quot; on an override of a dynamic member when it clearly remains dynamic.<br>&gt; <br>&gt; Inherited open-ness will be ignored on a final class or member.<br>&gt; <br>&gt; Honestly, this is why I don&#39;t like to include this level of detail in proposals.  People complain if<br>&gt; it&#39;s not there, but including it just invites a bunch of complaints about every detail and distracts<br>&gt; from the important parts of the discussion.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Ayayay, so much drama!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; See previous reviews.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Probably more than it deserves? ;-)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; KÃ¡roly<br>&gt;&gt; @lorentey<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
