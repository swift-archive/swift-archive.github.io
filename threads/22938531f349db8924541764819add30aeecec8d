<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 10, 2016 at 11:00:00am</p></header><div class="content"><p>on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’m not sure whether you’ve read the conclusion of my mail since<br>&gt; you’ve only commented on the introductory part. In the conclusion I<br>&gt; wrote that a possible approach for the replacement of ObjC-style<br>&gt; optional protocol methods would be:<br>&gt;<br>&gt; 1) the default implementation of a protocol method must be defined in<br>&gt; the protocol (so just like in native Swift protocols today).<br></p><p>? They can and must be defined in protocol extensions today.<br></p><p>&gt;<br>&gt; 2) we add a way for a protocol provider to check whether the protocol<br>&gt; adopter has provided an “override” of the default method.<br></p><p>I object to this part.<br></p><p>&gt; 3) we improve the Xcode interface generator so that it clearly shows<br>&gt; whether a protocol method comes with a default or whether it doesn’t.<br></p><p>Obvious goodness, long overdue.<br></p><p>&gt; (1) should address your main concern since it would guarantee that the<br>&gt; protocol provider is always able to call the protocol method without<br>&gt; having to do any checks. (2) would address the main concern of<br>&gt; protocol providers who need to guarantee that the protocol using type<br>&gt; achieves a certain minimum speed and does not use more than a certain<br>&gt; amount of memory for its internal book-keeping.<br></p><p>I don&#39;t how (2) can possibly help with that.<br>&gt;<br>&gt; (3) is important because it would fix one of the many aspects that<br>&gt; make Swift protocols confusing for people who are new to the language.<br>&gt;<br>&gt; Finally, let me restate that the goal should really be that we<br>&gt; completely remove the syntactical differences between @objc and native<br>&gt; Swift protocols. There should be one concept of protocol in Swift and<br>&gt; we should be able to cover the use cases of formal and informal ObjC<br>&gt; Protocols with them. The use case of formal protocols is already<br>&gt; covered today. The use case of informal protocols could be covered<br>&gt; with the approach above.<br>&gt;<br>&gt; So is this an approach that would be acceptable to you?<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Dietmar Planitzer<br>&gt;<br>&gt;&gt; <br>&gt;&gt; On Apr 10, 2016, at 10:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Apr 08 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The biggest missing part with this model is that we are still not able<br>&gt;&gt;&gt; to enable macro-level optimizations in the delegating type by checking<br>&gt;&gt;&gt; whether the delegate does provide his own implementation of an<br>&gt;&gt;&gt; optional method or doesn’t. However, this is an important advantage of<br>&gt;&gt;&gt; the ObjC model that we should not lose.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe it’s time to take a big step back and ignore the question of how<br>&gt;&gt;&gt; to implement things for a moment and to instead focus on the question<br>&gt;&gt;&gt; of what the conceptual differences are between ObjC protocols with<br>&gt;&gt;&gt; optional methods and Swift protocols with default<br>&gt;&gt;&gt; implementations. There are two relevant viewpoints here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) From the viewpoint of a protocol adaptor:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1a) adopter may provide his own implementation of the protocol method,<br>&gt;&gt;&gt; but he is no required to.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1b) adopter can see in the protocol declaration for which methods he<br>&gt;&gt;&gt; must provide an implementation. Those methods do not have the<br>&gt;&gt;&gt; “optional” keyword in front of them while optional methods do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1c) same as (1a).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1d) opening a binary-only Swift file in Xcode with a protocol<br>&gt;&gt;&gt; definition in it which contains methods with default implementations<br>&gt;&gt;&gt; will not give any indication of which method has a default<br>&gt;&gt;&gt; implementation and which doesn’t. It’s only possible to see a<br>&gt;&gt;&gt; difference on the syntax level if you have access to the sources.<br>&gt;&gt; <br>&gt;&gt; This visibility problem is something we aim to correct in Swift, but<br>&gt;&gt; that is a question of syntax, documentation, and “header” generation,<br>&gt;&gt; and really orthogonal to what&#39;s fundamental about “optional<br>&gt;&gt; requirements:” <br>&gt;&gt; <br>&gt;&gt; 1. The ability to “conform” to the protocol without a<br>&gt;&gt;   default implementation of the requirement have been provided<br>&gt;&gt;   anywhere.<br>&gt;&gt; <br>&gt;&gt; 2. The ability to dynamically query whether a type actually provides the<br>&gt;&gt;   requirement.<br>&gt;&gt; <br>&gt;&gt; Both of these “features,” IMO, are actually bugs.<br>&gt;&gt; <br>&gt;&gt;&gt; So from the viewpoint of the protocol adopter, there isn’t much of a<br>&gt;&gt;&gt; difference. The only relevant difference is that its always possible<br>&gt;&gt;&gt; in ObjC to tell whether a protocol method must be implemented by the<br>&gt;&gt;&gt; adopter or whether a method already has a default behavior. We<br>&gt;&gt;&gt; shouldn’t actually have to change anything on the syntax-level in<br>&gt;&gt;&gt; Swift to fix this problem. It should be sufficient to improve the<br>&gt;&gt;&gt; Swift interface generator in Xcode so that it gives an indication<br>&gt;&gt;&gt; whether a protocol method has a default implementation or doesn’t. Eg<br>&gt;&gt;&gt; if we want to ensure that the generated interface is valid syntax then<br>&gt;&gt;&gt; we could do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func void bar() -&gt; Int /* has default */<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or if we say that it is fine that the generated interface is not valid<br>&gt;&gt;&gt; syntax (I think it already shows &quot;= default” for function arguments<br>&gt;&gt;&gt; with a default value which I don’t think is valid syntax), then we<br>&gt;&gt;&gt; could do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func void bar() -&gt; Int {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now on to the other side of the equation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) From the viewpoint of the protocol provider (the person who defines<br>&gt;&gt;&gt; the protocol and the type that will invoke the protocol methods):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2a) provider has freedom in deciding where to put the default<br>&gt;&gt;&gt; implementation and he can put the default implementation in a single<br>&gt;&gt;&gt; place or spread it out if necessary over multiple places. So has the<br>&gt;&gt;&gt; freedom to choose whatever makes the most sense for the problem at<br>&gt;&gt;&gt; hand.<br>&gt;&gt; <br>&gt;&gt; But freedom for protocol implementors reduces predictability for protocol<br>&gt;&gt; clients and adopters.<br>&gt;&gt; <br>&gt;&gt;&gt; 2b) provider can detect whether the adopter provides his own protocol<br>&gt;&gt;&gt; method implementation without compromising the definition of the<br>&gt;&gt;&gt; protocol (compromising here means making return values optional when<br>&gt;&gt;&gt; they should not be optional based on the natural definition of the<br>&gt;&gt;&gt; API). This enables the provider to implement macro-level optimizations<br>&gt;&gt;&gt; (eg table view can understand whether fixed or variable row heights<br>&gt;&gt;&gt; are desired).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2c) provider is forced to put the default implementation in a specific<br>&gt;&gt;&gt; place.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2d) provider has no way to detect whether the adopter has provided his<br>&gt;&gt;&gt; own implementation of the protocol method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do think that (2a) would be nice to have but we can probably do<br>&gt;&gt;&gt; without it if it helps us to make progress with this topic. However,<br>&gt;&gt;&gt; the ability to detect whether a protocol adopter provides his own<br>&gt;&gt;&gt; implementation of a protocol method which comes with a default is a<br>&gt;&gt;&gt; useful and important feature which helps us in optimizing the<br>&gt;&gt;&gt; implementation of types and which allows us to keep the API surface<br>&gt;&gt;&gt; smaller than it would be without this ability. Just go and compare eg<br>&gt;&gt;&gt; UITableView to the Android ListView / RecyclerView to see the<br>&gt;&gt;&gt; consequences of not having that ability and how it inflates the API<br>&gt;&gt;&gt; surface (and keep in mind that the Android equivalents provide a<br>&gt;&gt;&gt; fraction of the UITableView functionality).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The important point about (2b) is actually that we are able to detect<br>&gt;&gt;&gt; whether an “override” (I’ll just call this overriding for now) of the<br>&gt;&gt;&gt; default implementation exists or does not exist. <br>&gt;&gt; <br>&gt;&gt; IMO the important point about (2b) is that it leads to protocol designs<br>&gt;&gt; that create work and complexity for clients of the protocol, and being<br>&gt;&gt; constrained to make your protocol work so that clients don&#39;t have to do<br>&gt;&gt; these kinds of checks is a Very Good Thing™.<br>&gt;&gt; <br>&gt;&gt;&gt; In ObjC we make this distinction by checking whether an implementation<br>&gt;&gt;&gt; of the method exists at all. But we don’t have to do it that way. An<br>&gt;&gt;&gt; alternative approach could be based on a check that sees whether the<br>&gt;&gt;&gt; dispatch table of the delegate contains a pointer to the default<br>&gt;&gt;&gt; implementation of the protocol method or to some other method. So<br>&gt;&gt;&gt; conceptually what we want is an operation like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func void useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   if has_override(delegate, tableView(_:, heightOfRow:)) { // ask the<br>&gt;&gt;&gt; delegate how many rows it has // allocate the geometry cache // fill<br>&gt;&gt;&gt; in the geometry cache by calling tableView(_:, heightForRow:) for each<br>&gt;&gt;&gt; row } else { // nothing to do here } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which would get the job done but doesn’t look good. Maybe someone has<br>&gt;&gt;&gt; a better idea of how the syntax such an operator could look.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So my point here is that what we care about is the ability to detect<br>&gt;&gt;&gt; whether the adopter provides an implementation of a protocol method<br>&gt;&gt;&gt; which comes with a default implementation. The point is not that Swift<br>&gt;&gt;&gt; protocols should work the exact same way that ObjC protocols have been<br>&gt;&gt;&gt; working under the hood. But I do think that we want to eventually get<br>&gt;&gt;&gt; to a point where the @objc attribute disappears and that we get a<br>&gt;&gt;&gt; truly unified language on the syntactical level. An approach where:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I) we accept that the default behavior of a protocol method has to be<br>&gt;&gt;&gt; provided by the protocol itself<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; II) the language is extended with a mechanism that makes it possible<br>&gt;&gt;&gt; for a protocol provider to detect whether the adopter has “overridden”<br>&gt;&gt;&gt; the default implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; III) we improve the Xcode Swift interface generator so that it gives a<br>&gt;&gt;&gt; clear indication whether a protocol method does come with a default<br>&gt;&gt;&gt; implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would give us all the relevant advantages of ObjC-style optional<br>&gt;&gt;&gt; protocol methods and it should allow us to create a unified syntax<br>&gt;&gt;&gt; where there is no longer a visible difference between an optional<br>&gt;&gt;&gt; protocol method that was imported from ObjC and a native Swift<br>&gt;&gt;&gt; protocol with default implementations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dietmar Planitzer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Optional protocol requirements in Swift have the restriction that<br>&gt;&gt;&gt;&gt; they only work in @objc protocols, a topic that’s come up a number<br>&gt;&gt;&gt;&gt; of times. The start of these threads imply that optional<br>&gt;&gt;&gt;&gt; requirements should be available for all protocols in Swift. While<br>&gt;&gt;&gt;&gt; this direction is implementable, each time this is discussed there<br>&gt;&gt;&gt;&gt; is significant feedback that optional requirements are not a feature<br>&gt;&gt;&gt;&gt; we want in Swift. They overlap almost completely with default<br>&gt;&gt;&gt;&gt; implementations of protocol requirements, which is a more general<br>&gt;&gt;&gt;&gt; feature, and people seem to feel that designs based around default<br>&gt;&gt;&gt;&gt; implementations and refactoring of protocol hierarchies are overall<br>&gt;&gt;&gt;&gt; better.<br>&gt;&gt;&gt;&gt; The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A Non-Workable Solution: Import as optional property requirements One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @protocol NSTableViewDelegate @optional - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row; @end<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; currently comes in as<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would come in as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get } var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; one would have to write something like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = { … except you can’t refer to self in here unless you make it lazy ...  } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) { if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type // I can call getView here }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  if let getHeight = delegate.tableView(_:heightOfRow:) { // I can call getHeight here } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? { let view = delegate.tableView(tableView, viewFor: column, row: row) let height = delegate.tableView(tableView, heightOfRow: row) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension NSTableViewDelegate { @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) { // call the @objc instance method with the selector tableView:viewForTableColumn:row: } else { // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) Only the callers to these requirements have to deal with the lack<br>&gt;&gt;&gt;&gt; of default implementations. This was already the case for optional<br>&gt;&gt;&gt;&gt; requirements, so it’s not an extra burden in principle, and it’s<br>&gt;&gt;&gt;&gt; generally going to be easier to write one defaulted implementation<br>&gt;&gt;&gt;&gt; than deal with it in several different places. Additionally, most of<br>&gt;&gt;&gt;&gt; these callers are probably in the Cocoa frameworks, not application<br>&gt;&gt;&gt;&gt; code, so the overall impact should be small.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>April 10, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 10, 2016, at 11:46, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’m not sure whether you’ve read the conclusion of my mail since<br>&gt;&gt; you’ve only commented on the introductory part. In the conclusion I<br>&gt;&gt; wrote that a possible approach for the replacement of ObjC-style<br>&gt;&gt; optional protocol methods would be:<br>&gt;&gt; <br>&gt;&gt; 1) the default implementation of a protocol method must be defined in<br>&gt;&gt; the protocol (so just like in native Swift protocols today).<br>&gt; <br>&gt; ? They can and must be defined in protocol extensions today.<br></p><p>I know.<br></p><p>&gt;&gt; <br>&gt;&gt; 2) we add a way for a protocol provider to check whether the protocol<br>&gt;&gt; adopter has provided an “override” of the default method.<br>&gt; <br>&gt; I object to this part.<br></p><p>You object why? I do understand why you object to the ObjC model since there is not necessarily an implementation of the protocol method and thus the protocol provider has to guard every call with an existence check. But in this model here we would be guaranteed that there would be an implementation of the protocol method and thus guarding the call wouldn’t be necessary.<br></p><p>&gt;&gt; 3) we improve the Xcode interface generator so that it clearly shows<br>&gt;&gt; whether a protocol method comes with a default or whether it doesn’t.<br>&gt; <br>&gt; Obvious goodness, long overdue.<br>&gt; <br>&gt;&gt; (1) should address your main concern since it would guarantee that the<br>&gt;&gt; protocol provider is always able to call the protocol method without<br>&gt;&gt; having to do any checks. (2) would address the main concern of<br>&gt;&gt; protocol providers who need to guarantee that the protocol using type<br>&gt;&gt; achieves a certain minimum speed and does not use more than a certain<br>&gt;&gt; amount of memory for its internal book-keeping.<br>&gt; <br>&gt; I don&#39;t how (2) can possibly help with that.<br></p><p>It helps because it allows the protocol provider to *understand* whether the protocol adopter is actually using a certain feature or isn’t. Here is the table view example again:<br></p><p>func useDelegate(delegate: NSTableViewDelegate) {<br></p><p>  if has_override(delegate, tableView(_:, heightForRow:)) {<br>     // call tableViewNumberOfRows() on the delegate<br>     // allocate the geometry cache (1 entry per row)<br>     // call tableView(_:, heightForRow:) for each row<br>  } else {<br>    // nothing to do here since here all rows have the same height<br>   }<br>}<br></p><p><br>Note that has_override() is just a placeholder syntax because I’ve not had a good idea yet of how to express this in a Swiftier way.<br></p><p>In this example the table view is able to check whether the protocol adopter has actually “overriden” the default implementation of tableView(_:, heightForRow:). If the adopter did, then the table view knows that the adopter wants variable row heights and thus the table view can now create a cache of row heights and it can enable the layouting code that knows how to lay out rows with different heights. If however the adopter did not provide its own implementation of this method then the table view does not need to create a geometry cache and it can switch over to the simpler fixed-row-height layout code. The reason why we want to cache the row heights in the table view is because computing those heights can be nontrivial and the layout code needs to access those height values in every layoutSubviews() call. And layoutSubviews() is invoked 60 times per second while the user is scrolling. Also keep in mind that, if we would not cache the row heights, then the row height computation would end up competing for CPU cycles with the code that properly configures the views for each row.<br></p><p>Without the ability to do this check on the protocol provider side, we are forced to increase the API surface so that the protocol adopter can explicitly tell us which layouting model he wants. But this also means that the protocol adopter now has to remember that he needs to configure the layouting option correctly in order to get a working and efficiently working table view. So the end result would be a table view that’s hard to use correctly.<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p>&gt;&gt; <br>&gt;&gt; (3) is important because it would fix one of the many aspects that<br>&gt;&gt; make Swift protocols confusing for people who are new to the language.<br>&gt;&gt; <br>&gt;&gt; Finally, let me restate that the goal should really be that we<br>&gt;&gt; completely remove the syntactical differences between @objc and native<br>&gt;&gt; Swift protocols. There should be one concept of protocol in Swift and<br>&gt;&gt; we should be able to cover the use cases of formal and informal ObjC<br>&gt;&gt; Protocols with them. The use case of formal protocols is already<br>&gt;&gt; covered today. The use case of informal protocols could be covered<br>&gt;&gt; with the approach above.<br>&gt;&gt; <br>&gt;&gt; So is this an approach that would be acceptable to you?<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; <br>&gt;&gt; Dietmar Planitzer<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 10, 2016, at 10:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Apr 08 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The biggest missing part with this model is that we are still not able<br>&gt;&gt;&gt;&gt; to enable macro-level optimizations in the delegating type by checking<br>&gt;&gt;&gt;&gt; whether the delegate does provide his own implementation of an<br>&gt;&gt;&gt;&gt; optional method or doesn’t. However, this is an important advantage of<br>&gt;&gt;&gt;&gt; the ObjC model that we should not lose.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe it’s time to take a big step back and ignore the question of how<br>&gt;&gt;&gt;&gt; to implement things for a moment and to instead focus on the question<br>&gt;&gt;&gt;&gt; of what the conceptual differences are between ObjC protocols with<br>&gt;&gt;&gt;&gt; optional methods and Swift protocols with default<br>&gt;&gt;&gt;&gt; implementations. There are two relevant viewpoints here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) From the viewpoint of a protocol adaptor:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1a) adopter may provide his own implementation of the protocol method,<br>&gt;&gt;&gt;&gt; but he is no required to.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1b) adopter can see in the protocol declaration for which methods he<br>&gt;&gt;&gt;&gt; must provide an implementation. Those methods do not have the<br>&gt;&gt;&gt;&gt; “optional” keyword in front of them while optional methods do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1c) same as (1a).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1d) opening a binary-only Swift file in Xcode with a protocol<br>&gt;&gt;&gt;&gt; definition in it which contains methods with default implementations<br>&gt;&gt;&gt;&gt; will not give any indication of which method has a default<br>&gt;&gt;&gt;&gt; implementation and which doesn’t. It’s only possible to see a<br>&gt;&gt;&gt;&gt; difference on the syntax level if you have access to the sources.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This visibility problem is something we aim to correct in Swift, but<br>&gt;&gt;&gt; that is a question of syntax, documentation, and “header” generation,<br>&gt;&gt;&gt; and really orthogonal to what&#39;s fundamental about “optional<br>&gt;&gt;&gt; requirements:” <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The ability to “conform” to the protocol without a<br>&gt;&gt;&gt;  default implementation of the requirement have been provided<br>&gt;&gt;&gt;  anywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. The ability to dynamically query whether a type actually provides the<br>&gt;&gt;&gt;  requirement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Both of these “features,” IMO, are actually bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So from the viewpoint of the protocol adopter, there isn’t much of a<br>&gt;&gt;&gt;&gt; difference. The only relevant difference is that its always possible<br>&gt;&gt;&gt;&gt; in ObjC to tell whether a protocol method must be implemented by the<br>&gt;&gt;&gt;&gt; adopter or whether a method already has a default behavior. We<br>&gt;&gt;&gt;&gt; shouldn’t actually have to change anything on the syntax-level in<br>&gt;&gt;&gt;&gt; Swift to fix this problem. It should be sufficient to improve the<br>&gt;&gt;&gt;&gt; Swift interface generator in Xcode so that it gives an indication<br>&gt;&gt;&gt;&gt; whether a protocol method has a default implementation or doesn’t. Eg<br>&gt;&gt;&gt;&gt; if we want to ensure that the generated interface is valid syntax then<br>&gt;&gt;&gt;&gt; we could do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func void bar() -&gt; Int /* has default */<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or if we say that it is fine that the generated interface is not valid<br>&gt;&gt;&gt;&gt; syntax (I think it already shows &quot;= default” for function arguments<br>&gt;&gt;&gt;&gt; with a default value which I don’t think is valid syntax), then we<br>&gt;&gt;&gt;&gt; could do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func void bar() -&gt; Int {…}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now on to the other side of the equation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) From the viewpoint of the protocol provider (the person who defines<br>&gt;&gt;&gt;&gt; the protocol and the type that will invoke the protocol methods):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2a) provider has freedom in deciding where to put the default<br>&gt;&gt;&gt;&gt; implementation and he can put the default implementation in a single<br>&gt;&gt;&gt;&gt; place or spread it out if necessary over multiple places. So has the<br>&gt;&gt;&gt;&gt; freedom to choose whatever makes the most sense for the problem at<br>&gt;&gt;&gt;&gt; hand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But freedom for protocol implementors reduces predictability for protocol<br>&gt;&gt;&gt; clients and adopters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2b) provider can detect whether the adopter provides his own protocol<br>&gt;&gt;&gt;&gt; method implementation without compromising the definition of the<br>&gt;&gt;&gt;&gt; protocol (compromising here means making return values optional when<br>&gt;&gt;&gt;&gt; they should not be optional based on the natural definition of the<br>&gt;&gt;&gt;&gt; API). This enables the provider to implement macro-level optimizations<br>&gt;&gt;&gt;&gt; (eg table view can understand whether fixed or variable row heights<br>&gt;&gt;&gt;&gt; are desired).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2c) provider is forced to put the default implementation in a specific<br>&gt;&gt;&gt;&gt; place.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2d) provider has no way to detect whether the adopter has provided his<br>&gt;&gt;&gt;&gt; own implementation of the protocol method.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I do think that (2a) would be nice to have but we can probably do<br>&gt;&gt;&gt;&gt; without it if it helps us to make progress with this topic. However,<br>&gt;&gt;&gt;&gt; the ability to detect whether a protocol adopter provides his own<br>&gt;&gt;&gt;&gt; implementation of a protocol method which comes with a default is a<br>&gt;&gt;&gt;&gt; useful and important feature which helps us in optimizing the<br>&gt;&gt;&gt;&gt; implementation of types and which allows us to keep the API surface<br>&gt;&gt;&gt;&gt; smaller than it would be without this ability. Just go and compare eg<br>&gt;&gt;&gt;&gt; UITableView to the Android ListView / RecyclerView to see the<br>&gt;&gt;&gt;&gt; consequences of not having that ability and how it inflates the API<br>&gt;&gt;&gt;&gt; surface (and keep in mind that the Android equivalents provide a<br>&gt;&gt;&gt;&gt; fraction of the UITableView functionality).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The important point about (2b) is actually that we are able to detect<br>&gt;&gt;&gt;&gt; whether an “override” (I’ll just call this overriding for now) of the<br>&gt;&gt;&gt;&gt; default implementation exists or does not exist. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO the important point about (2b) is that it leads to protocol designs<br>&gt;&gt;&gt; that create work and complexity for clients of the protocol, and being<br>&gt;&gt;&gt; constrained to make your protocol work so that clients don&#39;t have to do<br>&gt;&gt;&gt; these kinds of checks is a Very Good Thing™.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In ObjC we make this distinction by checking whether an implementation<br>&gt;&gt;&gt;&gt; of the method exists at all. But we don’t have to do it that way. An<br>&gt;&gt;&gt;&gt; alternative approach could be based on a check that sees whether the<br>&gt;&gt;&gt;&gt; dispatch table of the delegate contains a pointer to the default<br>&gt;&gt;&gt;&gt; implementation of the protocol method or to some other method. So<br>&gt;&gt;&gt;&gt; conceptually what we want is an operation like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func void useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  if has_override(delegate, tableView(_:, heightOfRow:)) { // ask the<br>&gt;&gt;&gt;&gt; delegate how many rows it has // allocate the geometry cache // fill<br>&gt;&gt;&gt;&gt; in the geometry cache by calling tableView(_:, heightForRow:) for each<br>&gt;&gt;&gt;&gt; row } else { // nothing to do here } }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which would get the job done but doesn’t look good. Maybe someone has<br>&gt;&gt;&gt;&gt; a better idea of how the syntax such an operator could look.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So my point here is that what we care about is the ability to detect<br>&gt;&gt;&gt;&gt; whether the adopter provides an implementation of a protocol method<br>&gt;&gt;&gt;&gt; which comes with a default implementation. The point is not that Swift<br>&gt;&gt;&gt;&gt; protocols should work the exact same way that ObjC protocols have been<br>&gt;&gt;&gt;&gt; working under the hood. But I do think that we want to eventually get<br>&gt;&gt;&gt;&gt; to a point where the @objc attribute disappears and that we get a<br>&gt;&gt;&gt;&gt; truly unified language on the syntactical level. An approach where:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I) we accept that the default behavior of a protocol method has to be<br>&gt;&gt;&gt;&gt; provided by the protocol itself<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; II) the language is extended with a mechanism that makes it possible<br>&gt;&gt;&gt;&gt; for a protocol provider to detect whether the adopter has “overridden”<br>&gt;&gt;&gt;&gt; the default implementation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; III) we improve the Xcode Swift interface generator so that it gives a<br>&gt;&gt;&gt;&gt; clear indication whether a protocol method does come with a default<br>&gt;&gt;&gt;&gt; implementation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would give us all the relevant advantages of ObjC-style optional<br>&gt;&gt;&gt;&gt; protocol methods and it should allow us to create a unified syntax<br>&gt;&gt;&gt;&gt; where there is no longer a visible difference between an optional<br>&gt;&gt;&gt;&gt; protocol method that was imported from ObjC and a native Swift<br>&gt;&gt;&gt;&gt; protocol with default implementations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dietmar Planitzer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Optional protocol requirements in Swift have the restriction that<br>&gt;&gt;&gt;&gt;&gt; they only work in @objc protocols, a topic that’s come up a number<br>&gt;&gt;&gt;&gt;&gt; of times. The start of these threads imply that optional<br>&gt;&gt;&gt;&gt;&gt; requirements should be available for all protocols in Swift. While<br>&gt;&gt;&gt;&gt;&gt; this direction is implementable, each time this is discussed there<br>&gt;&gt;&gt;&gt;&gt; is significant feedback that optional requirements are not a feature<br>&gt;&gt;&gt;&gt;&gt; we want in Swift. They overlap almost completely with default<br>&gt;&gt;&gt;&gt;&gt; implementations of protocol requirements, which is a more general<br>&gt;&gt;&gt;&gt;&gt; feature, and people seem to feel that designs based around default<br>&gt;&gt;&gt;&gt;&gt; implementations and refactoring of protocol hierarchies are overall<br>&gt;&gt;&gt;&gt;&gt; better.<br>&gt;&gt;&gt;&gt;&gt; The main concern with removing optional requirements from Swift is their impact on Cocoa: Objective-C protocols, especially for delegates and data sources, make heavy use of optional requirements. Moreover, there are no default implementations for any of these optional requirements: each caller effectively checks for the presence of the method explicitly, and implements its own logic if the method isn’t there.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A Non-Workable Solution: Import as optional property requirements One suggestion that’s come up to map an optional requirement to a property with optional type, were “nil” indicates that the requirement was not satisfied. For example,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @protocol NSTableViewDelegate @optional - (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row; - (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row; @end<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; currently comes in as<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { optional func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  optional func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would come in as:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get } var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; with a default implementation of “nil” for each. However, this isn’t practical for a number of reasons:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a) We would end up overloading the property name “tableView” a couple dozen times, which doesn’t actually work.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; b) You can no longer refer to the member with a compound name, e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because the name of the property is “tableView”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; c) Implementers of the protocol now need to provide a read-only property that returns a closure. So instead of<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; one would have to write something like<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { var tableView: ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = { … except you can’t refer to self in here unless you make it lazy ...  } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; d) We’ve seriously considered eliminating argument labels on function types, because they’re a complexity in the type system that doesn’t serve much of a purpose.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing compound (function-like) names like tableView(_:viewFor:row:) for properties, and work around (c) by allowing a method to satisfy the requirement for a read-only property, but at this point you’ve invented more language hacks than the existing @objc-only optional requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Default implementations and optional requirements differ most on the caller side. For example, let’s use NSTableView delegate as it’s imported today:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) { if let getView = delegate.tableView(_:viewFor:row:) { // since the requirement is optional, a reference to the method produces a value of optional function type // I can call getView here }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let getHeight = delegate.tableView(_:heightOfRow:) { // I can call getHeight here } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute (let’s call it @__caller_default_implementation) that gets places on Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { @__caller_default_implementation func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  @__caller_default_implementation func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And “optional” disappears from the language. Now, there’s no optionality left, so our useDelegate example tries to just do correct calls:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? { let view = delegate.tableView(tableView, viewFor: column, row: row) let height = delegate.tableView(tableView, heightOfRow: row) }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Of course, the code above will fail if the actual delegate doesn’t implement both methods. We need some kind of default implementation to fall back on in that case. I propose that the code above produce a compiler error on both lines *unless* there is a “default implementation” visible. So, to make the code above compile without error, one would have to add:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension NSTableViewDelegate { @nonobjc func tableView(_: NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat { return 17 } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now, the useDelegate example compiles. If the actual delegate implements the optional requirement, we’ll use that implementation. Otherwise, the caller will use the default (Swift-only) implementation it sees. From an implementation standpoint, the compiler would effectively produce the following for the first of these calls:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if delegate.responds(to: #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) { // call the @objc instance method with the selector tableView:viewForTableColumn:row: } else { // call the Swift-only implementation of tableView(_:viewFor:row:) in the protocol extension above }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the language. For classes that are adopting the NSTableViewDelegate protocol, it is as if these requirements had default implementations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2) Only the callers to these requirements have to deal with the lack<br>&gt;&gt;&gt;&gt;&gt; of default implementations. This was already the case for optional<br>&gt;&gt;&gt;&gt;&gt; requirements, so it’s not an extra burden in principle, and it’s<br>&gt;&gt;&gt;&gt;&gt; generally going to be easier to write one defaulted implementation<br>&gt;&gt;&gt;&gt;&gt; than deal with it in several different places. Additionally, most of<br>&gt;&gt;&gt;&gt;&gt; these callers are probably in the Cocoa frameworks, not application<br>&gt;&gt;&gt;&gt;&gt; code, so the overall impact should be small.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 11, 2016 at 10:00:00am</p></header><div class="content"><p>on Sun Apr 10 2016, Dietmar Planitzer &lt;dplanitzer-AT-q.com&gt; wrote:<br></p><p>&gt;&gt; On Apr 10, 2016, at 11:46, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’m not sure whether you’ve read the conclusion of my mail since<br>&gt;&gt;&gt; you’ve only commented on the introductory part. In the conclusion I<br>&gt;&gt;&gt; wrote that a possible approach for the replacement of ObjC-style<br>&gt;&gt;&gt; optional protocol methods would be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) the default implementation of a protocol method must be defined<br>&gt; in<br>&gt;&gt;&gt; the protocol (so just like in native Swift protocols today).<br>&gt;&gt; <br>&gt;&gt; ? They can and must be defined in protocol extensions today.<br>&gt;<br>&gt; I know.<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) we add a way for a protocol provider to check whether the<br>&gt; protocol<br>&gt;&gt;&gt; adopter has provided an “override” of the default method.<br>&gt;&gt; <br>&gt;&gt; I object to this part.<br>&gt;<br>&gt; You object why? I do understand why you object to the ObjC model since<br>&gt; there is not necessarily an implementation of the protocol method and<br>&gt; thus the protocol provider has to guard every call with an existence<br>&gt; check. But in this model here we would be guaranteed that there would<br>&gt; be an implementation of the protocol method and thus guarding the call<br>&gt; wouldn’t be necessary.<br></p><p>Because it&#39;s a needless complication that will encourage protocol and<br>algorithm designers to create inefficient programs because they know the<br>user can fall back on this hack.  Nobody thinks that classes need the<br>ability to check whether a given method is overridden.  Why should this<br>be needed for protocols?<br></p><p>&gt;&gt;&gt; 3) we improve the Xcode interface generator so that it clearly shows<br>&gt;&gt;&gt; whether a protocol method comes with a default or whether it<br>&gt;&gt;&gt; doesn’t.<br>&gt;&gt; <br>&gt;&gt; Obvious goodness, long overdue.<br>&gt;&gt; <br>&gt;&gt;&gt; (1) should address your main concern since it would guarantee that<br>&gt;&gt;&gt; the protocol provider is always able to call the protocol method<br>&gt;&gt;&gt; without having to do any checks. (2) would address the main concern<br>&gt;&gt;&gt; of protocol providers who need to guarantee that the protocol using<br>&gt;&gt;&gt; type achieves a certain minimum speed and does not use more than a<br>&gt;&gt;&gt; certain amount of memory for its internal book-keeping.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t how (2) can possibly help with that.<br>&gt;<br>&gt; It helps because it allows the protocol provider to *understand*<br>&gt; whether the protocol adopter is actually using a certain feature or<br>&gt; isn’t. <br></p><p>If they need to understand that, they can make the indicator of that<br>fact a separate protocol requirement.<br></p><p>&gt; Here is the table view example again:<br>&gt;<br>&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;<br>&gt;   if has_override(delegate, tableView(_:, heightForRow:)) {<br>&gt;      // call tableViewNumberOfRows() on the delegate<br>&gt;      // allocate the geometry cache (1 entry per row)<br>&gt;      // call tableView(_:, heightForRow:) for each row<br>&gt;   } else {<br>&gt;     // nothing to do here since here all rows have the same height<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; Note that has_override() is just a placeholder syntax because I’ve not<br>&gt; had a good idea yet of how to express this in a Swiftier way.<br></p><p>   if delegate.hasVariableSizedRows { ... }<br></p><p>   if !(delegate is NSUniformTableViewDelegate) { ... }<br></p><p>etc.<br>&gt;<br>&gt; In this example the table view is able to check whether the protocol<br>&gt; adopter has actually “overriden” the default implementation of<br>&gt; tableView(_:, heightForRow:). <br></p><p>Which, IMO, is a terrible way to indicate that a view has variable row<br>heights.  It&#39;s indirect and maybe even inaccurate (I can imagine a table<br>view that is uniform and has its height set up once at construction<br>time, therefore it needs to override heightForRow).<br></p><p>&gt; If the adopter did, then the table view knows that the adopter wants<br>&gt; variable row heights and thus the table view can now create a cache of<br>&gt; row heights and it can enable the layouting code that knows how to lay<br>&gt; out rows with different heights. If however the adopter did not<br>&gt; provide its own implementation of this method then the table view does<br>&gt; not need to create a geometry cache and it can switch over to the<br>&gt; simpler fixed-row-height layout code. The reason why we want to cache<br>&gt; the row heights in the table view is because computing those heights<br>&gt; can be nontrivial and the layout code needs to access those height<br>&gt; values in every layoutSubviews() call. And layoutSubviews() is invoked<br>&gt; 60 times per second while the user is scrolling. Also keep in mind<br>&gt; that, if we would not cache the row heights, then the row height<br>&gt; computation would end up competing for CPU cycles with the code that<br>&gt; properly configures the views for each row.<br>&gt;<br>&gt; Without the ability to do this check on the protocol provider side, we<br>&gt; are forced to increase the API surface so that the protocol adopter<br>&gt; can explicitly tell us which layouting model he wants. <br></p><p>That&#39;s exactly what one should do.  If layout model is an important<br>feature, the adopter should be explicit abou tit.<br></p><p>&gt; But this also means that the protocol adopter now has to remember that<br>&gt; he needs to configure the layouting option correctly in order to get a<br>&gt; working and efficiently working table view. So the end result would be<br>&gt; a table view that’s hard to use correctly.<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Dietmar Planitzer<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (3) is important because it would fix one of the many aspects that<br>&gt;&gt;&gt; make Swift protocols confusing for people who are new to the<br>&gt; language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, let me restate that the goal should really be that we<br>&gt;&gt;&gt; completely remove the syntactical differences between @objc and<br>&gt; native<br>&gt;&gt;&gt; Swift protocols. There should be one concept of protocol in Swift<br>&gt; and<br>&gt;&gt;&gt; we should be able to cover the use cases of formal and informal<br>&gt; ObjC<br>&gt;&gt;&gt; Protocols with them. The use case of formal protocols is already<br>&gt;&gt;&gt; covered today. The use case of informal protocols could be covered<br>&gt;&gt;&gt; with the approach above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So is this an approach that would be acceptable to you?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dietmar Planitzer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 10, 2016, at 10:29, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Apr 08 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The biggest missing part with this model is that we are still not<br>&gt; able<br>&gt;&gt;&gt;&gt;&gt; to enable macro-level optimizations in the delegating type by<br>&gt; checking<br>&gt;&gt;&gt;&gt;&gt; whether the delegate does provide his own implementation of an<br>&gt;&gt;&gt;&gt;&gt; optional method or doesn’t. However, this is an important<br>&gt; advantage of<br>&gt;&gt;&gt;&gt;&gt; the ObjC model that we should not lose.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe it’s time to take a big step back and ignore the question<br>&gt; of how<br>&gt;&gt;&gt;&gt;&gt; to implement things for a moment and to instead focus on the<br>&gt; question<br>&gt;&gt;&gt;&gt;&gt; of what the conceptual differences are between ObjC protocols<br>&gt; with<br>&gt;&gt;&gt;&gt;&gt; optional methods and Swift protocols with default<br>&gt;&gt;&gt;&gt;&gt; implementations. There are two relevant viewpoints here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) From the viewpoint of a protocol adaptor:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1a) adopter may provide his own implementation of the protocol<br>&gt; method,<br>&gt;&gt;&gt;&gt;&gt; but he is no required to.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1b) adopter can see in the protocol declaration for which methods<br>&gt; he<br>&gt;&gt;&gt;&gt;&gt; must provide an implementation. Those methods do not have the<br>&gt;&gt;&gt;&gt;&gt; “optional” keyword in front of them while optional methods do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1c) same as (1a).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1d) opening a binary-only Swift file in Xcode with a protocol<br>&gt;&gt;&gt;&gt;&gt; definition in it which contains methods with default<br>&gt; implementations<br>&gt;&gt;&gt;&gt;&gt; will not give any indication of which method has a default<br>&gt;&gt;&gt;&gt;&gt; implementation and which doesn’t. It’s only possible to see a<br>&gt;&gt;&gt;&gt;&gt; difference on the syntax level if you have access to the sources.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This visibility problem is something we aim to correct in Swift,<br>&gt; but<br>&gt;&gt;&gt;&gt; that is a question of syntax, documentation, and “header”<br>&gt; generation,<br>&gt;&gt;&gt;&gt; and really orthogonal to what&#39;s fundamental about “optional<br>&gt;&gt;&gt;&gt; requirements:” <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. The ability to “conform” to the protocol without a<br>&gt;&gt;&gt;&gt;  default implementation of the requirement have been provided<br>&gt;&gt;&gt;&gt;  anywhere.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. The ability to dynamically query whether a type actually<br>&gt; provides the<br>&gt;&gt;&gt;&gt;  requirement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Both of these “features,” IMO, are actually bugs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So from the viewpoint of the protocol adopter, there isn’t much<br>&gt; of a<br>&gt;&gt;&gt;&gt;&gt; difference. The only relevant difference is that its always<br>&gt; possible<br>&gt;&gt;&gt;&gt;&gt; in ObjC to tell whether a protocol method must be implemented by<br>&gt; the<br>&gt;&gt;&gt;&gt;&gt; adopter or whether a method already has a default behavior. We<br>&gt;&gt;&gt;&gt;&gt; shouldn’t actually have to change anything on the syntax-level in<br>&gt;&gt;&gt;&gt;&gt; Swift to fix this problem. It should be sufficient to improve the<br>&gt;&gt;&gt;&gt;&gt; Swift interface generator in Xcode so that it gives an indication<br>&gt;&gt;&gt;&gt;&gt; whether a protocol method has a default implementation or<br>&gt; doesn’t. Eg<br>&gt;&gt;&gt;&gt;&gt; if we want to ensure that the generated interface is valid syntax<br>&gt; then<br>&gt;&gt;&gt;&gt;&gt; we could do this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  func void bar() -&gt; Int /* has default */<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or if we say that it is fine that the generated interface is not<br>&gt; valid<br>&gt;&gt;&gt;&gt;&gt; syntax (I think it already shows &quot;= default” for function<br>&gt; arguments<br>&gt;&gt;&gt;&gt;&gt; with a default value which I don’t think is valid syntax), then<br>&gt; we<br>&gt;&gt;&gt;&gt;&gt; could do this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  func void bar() -&gt; Int {…}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now on to the other side of the equation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2) From the viewpoint of the protocol provider (the person who<br>&gt; defines<br>&gt;&gt;&gt;&gt;&gt; the protocol and the type that will invoke the protocol methods):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2a) provider has freedom in deciding where to put the default<br>&gt;&gt;&gt;&gt;&gt; implementation and he can put the default implementation in a<br>&gt; single<br>&gt;&gt;&gt;&gt;&gt; place or spread it out if necessary over multiple places. So has<br>&gt; the<br>&gt;&gt;&gt;&gt;&gt; freedom to choose whatever makes the most sense for the problem<br>&gt; at<br>&gt;&gt;&gt;&gt;&gt; hand.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But freedom for protocol implementors reduces predictability for<br>&gt; protocol<br>&gt;&gt;&gt;&gt; clients and adopters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2b) provider can detect whether the adopter provides his own<br>&gt; protocol<br>&gt;&gt;&gt;&gt;&gt; method implementation without compromising the definition of the<br>&gt;&gt;&gt;&gt;&gt; protocol (compromising here means making return values optional<br>&gt; when<br>&gt;&gt;&gt;&gt;&gt; they should not be optional based on the natural definition of<br>&gt; the<br>&gt;&gt;&gt;&gt;&gt; API). This enables the provider to implement macro-level<br>&gt; optimizations<br>&gt;&gt;&gt;&gt;&gt; (eg table view can understand whether fixed or variable row<br>&gt; heights<br>&gt;&gt;&gt;&gt;&gt; are desired).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2c) provider is forced to put the default implementation in a<br>&gt; specific<br>&gt;&gt;&gt;&gt;&gt; place.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2d) provider has no way to detect whether the adopter has<br>&gt; provided his<br>&gt;&gt;&gt;&gt;&gt; own implementation of the protocol method.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I do think that (2a) would be nice to have but we can probably do<br>&gt;&gt;&gt;&gt;&gt; without it if it helps us to make progress with this<br>&gt; topic. However,<br>&gt;&gt;&gt;&gt;&gt; the ability to detect whether a protocol adopter provides his own<br>&gt;&gt;&gt;&gt;&gt; implementation of a protocol method which comes with a default is<br>&gt; a<br>&gt;&gt;&gt;&gt;&gt; useful and important feature which helps us in optimizing the<br>&gt;&gt;&gt;&gt;&gt; implementation of types and which allows us to keep the API<br>&gt; surface<br>&gt;&gt;&gt;&gt;&gt; smaller than it would be without this ability. Just go and<br>&gt; compare eg<br>&gt;&gt;&gt;&gt;&gt; UITableView to the Android ListView / RecyclerView to see the<br>&gt;&gt;&gt;&gt;&gt; consequences of not having that ability and how it inflates the<br>&gt; API<br>&gt;&gt;&gt;&gt;&gt; surface (and keep in mind that the Android equivalents provide a<br>&gt;&gt;&gt;&gt;&gt; fraction of the UITableView functionality).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The important point about (2b) is actually that we are able to<br>&gt; detect<br>&gt;&gt;&gt;&gt;&gt; whether an “override” (I’ll just call this overriding for now) of<br>&gt; the<br>&gt;&gt;&gt;&gt;&gt; default implementation exists or does not exist. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO the important point about (2b) is that it leads to protocol<br>&gt; designs<br>&gt;&gt;&gt;&gt; that create work and complexity for clients of the protocol, and<br>&gt; being<br>&gt;&gt;&gt;&gt; constrained to make your protocol work so that clients don&#39;t have<br>&gt; to do<br>&gt;&gt;&gt;&gt; these kinds of checks is a Very Good Thing™.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In ObjC we make this distinction by checking whether an<br>&gt; implementation<br>&gt;&gt;&gt;&gt;&gt; of the method exists at all. But we don’t have to do it that<br>&gt; way. An<br>&gt;&gt;&gt;&gt;&gt; alternative approach could be based on a check that sees whether<br>&gt; the<br>&gt;&gt;&gt;&gt;&gt; dispatch table of the delegate contains a pointer to the default<br>&gt;&gt;&gt;&gt;&gt; implementation of the protocol method or to some other method. So<br>&gt;&gt;&gt;&gt;&gt; conceptually what we want is an operation like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func void useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if has_override(delegate, tableView(_:, heightOfRow:)) { // ask<br>&gt; the<br>&gt;&gt;&gt;&gt;&gt; delegate how many rows it has // allocate the geometry cache //<br>&gt; fill<br>&gt;&gt;&gt;&gt;&gt; in the geometry cache by calling tableView(_:, heightForRow:) for<br>&gt; each<br>&gt;&gt;&gt;&gt;&gt; row } else { // nothing to do here } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Which would get the job done but doesn’t look good. Maybe someone<br>&gt; has<br>&gt;&gt;&gt;&gt;&gt; a better idea of how the syntax such an operator could look.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So my point here is that what we care about is the ability to<br>&gt; detect<br>&gt;&gt;&gt;&gt;&gt; whether the adopter provides an implementation of a protocol<br>&gt; method<br>&gt;&gt;&gt;&gt;&gt; which comes with a default implementation. The point is not that<br>&gt; Swift<br>&gt;&gt;&gt;&gt;&gt; protocols should work the exact same way that ObjC protocols have<br>&gt; been<br>&gt;&gt;&gt;&gt;&gt; working under the hood. But I do think that we want to eventually<br>&gt; get<br>&gt;&gt;&gt;&gt;&gt; to a point where the @objc attribute disappears and that we get a<br>&gt;&gt;&gt;&gt;&gt; truly unified language on the syntactical level. An approach<br>&gt; where:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I) we accept that the default behavior of a protocol method has<br>&gt; to be<br>&gt;&gt;&gt;&gt;&gt; provided by the protocol itself<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; II) the language is extended with a mechanism that makes it<br>&gt; possible<br>&gt;&gt;&gt;&gt;&gt; for a protocol provider to detect whether the adopter has<br>&gt; “overridden”<br>&gt;&gt;&gt;&gt;&gt; the default implementation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; III) we improve the Xcode Swift interface generator so that it<br>&gt; gives a<br>&gt;&gt;&gt;&gt;&gt; clear indication whether a protocol method does come with a<br>&gt; default<br>&gt;&gt;&gt;&gt;&gt; implementation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would give us all the relevant advantages of ObjC-style optional<br>&gt;&gt;&gt;&gt;&gt; protocol methods and it should allow us to create a unified<br>&gt; syntax<br>&gt;&gt;&gt;&gt;&gt; where there is no longer a visible difference between an optional<br>&gt;&gt;&gt;&gt;&gt; protocol method that was imported from ObjC and a native Swift<br>&gt;&gt;&gt;&gt;&gt; protocol with default implementations.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Dietmar Planitzer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Optional protocol requirements in Swift have the restriction<br>&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt; they only work in @objc protocols, a topic that’s come up a<br>&gt; number<br>&gt;&gt;&gt;&gt;&gt;&gt; of times. The start of these threads imply that optional<br>&gt;&gt;&gt;&gt;&gt;&gt; requirements should be available for all protocols in<br>&gt; Swift. While<br>&gt;&gt;&gt;&gt;&gt;&gt; this direction is implementable, each time this is discussed<br>&gt; there<br>&gt;&gt;&gt;&gt;&gt;&gt; is significant feedback that optional requirements are not a<br>&gt; feature<br>&gt;&gt;&gt;&gt;&gt;&gt; we want in Swift. They overlap almost completely with default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations of protocol requirements, which is a more<br>&gt; general<br>&gt;&gt;&gt;&gt;&gt;&gt; feature, and people seem to feel that designs based around<br>&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations and refactoring of protocol hierarchies are<br>&gt; overall<br>&gt;&gt;&gt;&gt;&gt;&gt; better.<br>&gt;&gt;&gt;&gt;&gt;&gt; The main concern with removing optional requirements from Swift<br>&gt; is their impact on Cocoa: Objective-C protocols, especially for<br>&gt; delegates and data sources, make heavy use of optional<br>&gt; requirements. Moreover, there are no default implementations for any<br>&gt; of these optional requirements: each caller effectively checks for the<br>&gt; presence of the method explicitly, and implements its own logic if the<br>&gt; method isn’t there.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A Non-Workable Solution: Import as optional property<br>&gt; requirements One suggestion that’s come up to map an optional<br>&gt; requirement to a property with optional type, were “nil” indicates<br>&gt; that the requirement was not satisfied. For example,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; @protocol NSTableViewDelegate @optional - (nullable NSView<br>&gt; *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn<br>&gt; *)tableColumn row:(NSInteger)row; - (CGFloat)tableView:(NSTableView<br>&gt; *)tableView heightOfRow:(NSInteger)row; @end<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; currently comes in as<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { optional func tableView(_:<br>&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  optional<br>&gt; func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would come in as:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { var tableView:<br>&gt; ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>&gt; var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; with a default implementation of “nil” for each. However, this<br>&gt; isn’t practical for a number of reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; a) We would end up overloading the property name “tableView” a<br>&gt; couple dozen times, which doesn’t actually work.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; b) You can no longer refer to the member with a compound name,<br>&gt; e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because<br>&gt; the name of the property is “tableView”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; c) Implementers of the protocol now need to provide a read-only<br>&gt; property that returns a closure. So instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { func tableView(_:<br>&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; one would have to write something like<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { var tableView:<br>&gt; ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = { …<br>&gt; except you can’t refer to self in here unless you make it lazy ...  }<br>&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; d) We’ve seriously considered eliminating argument labels on<br>&gt; function types, because they’re a complexity in the type system that<br>&gt; doesn’t serve much of a purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing<br>&gt; compound (function-like) names like tableView(_:viewFor:row:) for<br>&gt; properties, and work around (c) by allowing a method to satisfy the<br>&gt; requirement for a read-only property, but at this point you’ve<br>&gt; invented more language hacks than the existing @objc-only optional<br>&gt; requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Default implementations and optional requirements differ most on<br>&gt; the caller side. For example, let’s use NSTableView delegate as it’s<br>&gt; imported today:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) { if let getView<br>&gt; = delegate.tableView(_:viewFor:row:) { // since the requirement is<br>&gt; optional, a reference to the method produces a value of optional<br>&gt; function type // I can call getView here }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if let getHeight = delegate.tableView(_:heightOfRow:) { // I can<br>&gt; call getHeight here } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute<br>&gt; (let’s call it @__caller_default_implementation) that gets places on<br>&gt; Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt; @__caller_default_implementation func tableView(_: NSTableView,<br>&gt; viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt; @__caller_default_implementation func tableView(_: NSTableView,<br>&gt; heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And “optional” disappears from the language. Now, there’s no<br>&gt; optionality left, so our useDelegate example tries to just do correct<br>&gt; calls:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? { let<br>&gt; view = delegate.tableView(tableView, viewFor: column, row: row) let<br>&gt; height = delegate.tableView(tableView, heightOfRow: row) }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Of course, the code above will fail if the actual delegate<br>&gt; doesn’t implement both methods. We need some kind of default<br>&gt; implementation to fall back on in that case. I propose that the code<br>&gt; above produce a compiler error on both lines *unless* there is a<br>&gt; “default implementation” visible. So, to make the code above compile<br>&gt; without error, one would have to add:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension NSTableViewDelegate { @nonobjc func tableView(_:<br>&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil<br>&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt;<br>&gt; CGFloat { return 17 } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now, the useDelegate example compiles. If the actual delegate<br>&gt; implements the optional requirement, we’ll use that<br>&gt; implementation. Otherwise, the caller will use the default<br>&gt; (Swift-only) implementation it sees. From an implementation<br>&gt; standpoint, the compiler would effectively produce the following for<br>&gt; the first of these calls:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if delegate.responds(to:<br>&gt; #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) { // call<br>&gt; the @objc instance method with the selector<br>&gt; tableView:viewForTableColumn:row: } else { // call the Swift-only<br>&gt; implementation of tableView(_:viewFor:row:) in the protocol extension<br>&gt; above }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the<br>&gt; language. For classes that are adopting the NSTableViewDelegate<br>&gt; protocol, it is as if these requirements had default implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2) Only the callers to these requirements have to deal with the<br>&gt; lack<br>&gt;&gt;&gt;&gt;&gt;&gt; of default implementations. This was already the case for<br>&gt; optional<br>&gt;&gt;&gt;&gt;&gt;&gt; requirements, so it’s not an extra burden in principle, and it’s<br>&gt;&gt;&gt;&gt;&gt;&gt; generally going to be easier to write one defaulted<br>&gt; implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; than deal with it in several different places. Additionally,<br>&gt; most of<br>&gt;&gt;&gt;&gt;&gt;&gt; these callers are probably in the Cocoa frameworks, not<br>&gt; application<br>&gt;&gt;&gt;&gt;&gt;&gt; code, so the overall impact should be small.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 11, 2016, at 12:03 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;dplanitzer-AT-q.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Apr 10, 2016, at 11:46, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure whether you’ve read the conclusion of my mail since<br>&gt;&gt;&gt;&gt; you’ve only commented on the introductory part. In the conclusion I<br>&gt;&gt;&gt;&gt; wrote that a possible approach for the replacement of ObjC-style<br>&gt;&gt;&gt;&gt; optional protocol methods would be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) the default implementation of a protocol method must be defined<br>&gt;&gt; in<br>&gt;&gt;&gt;&gt; the protocol (so just like in native Swift protocols today).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ? They can and must be defined in protocol extensions today.<br>&gt;&gt; <br>&gt;&gt; I know.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) we add a way for a protocol provider to check whether the<br>&gt;&gt; protocol<br>&gt;&gt;&gt;&gt; adopter has provided an “override” of the default method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I object to this part.<br>&gt;&gt; <br>&gt;&gt; You object why? I do understand why you object to the ObjC model since<br>&gt;&gt; there is not necessarily an implementation of the protocol method and<br>&gt;&gt; thus the protocol provider has to guard every call with an existence<br>&gt;&gt; check. But in this model here we would be guaranteed that there would<br>&gt;&gt; be an implementation of the protocol method and thus guarding the call<br>&gt;&gt; wouldn’t be necessary.<br>&gt; <br>&gt; Because it&#39;s a needless complication that will encourage protocol and<br>&gt; algorithm designers to create inefficient programs because they know the<br>&gt; user can fall back on this hack.  Nobody thinks that classes need the<br>&gt; ability to check whether a given method is overridden.  Why should this<br>&gt; be needed for protocols?<br>&gt; <br>&gt;&gt;&gt;&gt; 3) we improve the Xcode interface generator so that it clearly shows<br>&gt;&gt;&gt;&gt; whether a protocol method comes with a default or whether it<br>&gt;&gt;&gt;&gt; doesn’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obvious goodness, long overdue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (1) should address your main concern since it would guarantee that<br>&gt;&gt;&gt;&gt; the protocol provider is always able to call the protocol method<br>&gt;&gt;&gt;&gt; without having to do any checks. (2) would address the main concern<br>&gt;&gt;&gt;&gt; of protocol providers who need to guarantee that the protocol using<br>&gt;&gt;&gt;&gt; type achieves a certain minimum speed and does not use more than a<br>&gt;&gt;&gt;&gt; certain amount of memory for its internal book-keeping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t how (2) can possibly help with that.<br>&gt;&gt; <br>&gt;&gt; It helps because it allows the protocol provider to *understand*<br>&gt;&gt; whether the protocol adopter is actually using a certain feature or<br>&gt;&gt; isn’t. <br>&gt; <br>&gt; If they need to understand that, they can make the indicator of that<br>&gt; fact a separate protocol requirement.<br>&gt; <br>&gt;&gt; Here is the table view example again:<br>&gt;&gt; <br>&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt; <br>&gt;&gt;  if has_override(delegate, tableView(_:, heightForRow:)) {<br>&gt;&gt;     // call tableViewNumberOfRows() on the delegate<br>&gt;&gt;     // allocate the geometry cache (1 entry per row)<br>&gt;&gt;     // call tableView(_:, heightForRow:) for each row<br>&gt;&gt;  } else {<br>&gt;&gt;    // nothing to do here since here all rows have the same height<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that has_override() is just a placeholder syntax because I’ve not<br>&gt;&gt; had a good idea yet of how to express this in a Swiftier way.<br>&gt; <br>&gt;   if delegate.hasVariableSizedRows { ... }<br>&gt; <br>&gt;   if !(delegate is NSUniformTableViewDelegate) { ... }<br>&gt; <br>&gt; etc.<br>&gt;&gt; <br>&gt;&gt; In this example the table view is able to check whether the protocol<br>&gt;&gt; adopter has actually “overriden” the default implementation of<br>&gt;&gt; tableView(_:, heightForRow:). <br>&gt; <br>&gt; Which, IMO, is a terrible way to indicate that a view has variable row<br>&gt; heights.  It&#39;s indirect and maybe even inaccurate (I can imagine a table<br>&gt; view that is uniform and has its height set up once at construction<br>&gt; time, therefore it needs to override heightForRow).<br>&gt; <br>&gt;&gt; If the adopter did, then the table view knows that the adopter wants<br>&gt;&gt; variable row heights and thus the table view can now create a cache of<br>&gt;&gt; row heights and it can enable the layouting code that knows how to lay<br>&gt;&gt; out rows with different heights. If however the adopter did not<br>&gt;&gt; provide its own implementation of this method then the table view does<br>&gt;&gt; not need to create a geometry cache and it can switch over to the<br>&gt;&gt; simpler fixed-row-height layout code. The reason why we want to cache<br>&gt;&gt; the row heights in the table view is because computing those heights<br>&gt;&gt; can be nontrivial and the layout code needs to access those height<br>&gt;&gt; values in every layoutSubviews() call. And layoutSubviews() is invoked<br>&gt;&gt; 60 times per second while the user is scrolling. Also keep in mind<br>&gt;&gt; that, if we would not cache the row heights, then the row height<br>&gt;&gt; computation would end up competing for CPU cycles with the code that<br>&gt;&gt; properly configures the views for each row.<br>&gt;&gt; <br>&gt;&gt; Without the ability to do this check on the protocol provider side, we<br>&gt;&gt; are forced to increase the API surface so that the protocol adopter<br>&gt;&gt; can explicitly tell us which layouting model he wants. <br>&gt; <br>&gt; That&#39;s exactly what one should do.  If layout model is an important<br>&gt; feature, the adopter should be explicit abou tit.<br></p><p>+1.  I have found the UITableView design frustrating at times.  In Objective-C we can implement respondsToSelector in a delegate to modify behavior as necessary (by returning false when queried about heightForRow).  I have had the need to do that occasionally.  It is obviously a terrible hack that isn&#39;t possible in Swift and is indicative of a design problem as Dave points out.<br></p><p>&gt; <br>&gt;&gt; But this also means that the protocol adopter now has to remember that<br>&gt;&gt; he needs to configure the layouting option correctly in order to get a<br>&gt;&gt; working and efficiently working table view. So the end result would be<br>&gt;&gt; a table view that’s hard to use correctly.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; <br>&gt;&gt; Dietmar Planitzer<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (3) is important because it would fix one of the many aspects that<br>&gt;&gt;&gt;&gt; make Swift protocols confusing for people who are new to the<br>&gt;&gt; language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, let me restate that the goal should really be that we<br>&gt;&gt;&gt;&gt; completely remove the syntactical differences between @objc and<br>&gt;&gt; native<br>&gt;&gt;&gt;&gt; Swift protocols. There should be one concept of protocol in Swift<br>&gt;&gt; and<br>&gt;&gt;&gt;&gt; we should be able to cover the use cases of formal and informal<br>&gt;&gt; ObjC<br>&gt;&gt;&gt;&gt; Protocols with them. The use case of formal protocols is already<br>&gt;&gt;&gt;&gt; covered today. The use case of informal protocols could be covered<br>&gt;&gt;&gt;&gt; with the approach above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So is this an approach that would be acceptable to you?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dietmar Planitzer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 10, 2016, at 10:29, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Apr 08 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The biggest missing part with this model is that we are still not<br>&gt;&gt; able<br>&gt;&gt;&gt;&gt;&gt;&gt; to enable macro-level optimizations in the delegating type by<br>&gt;&gt; checking<br>&gt;&gt;&gt;&gt;&gt;&gt; whether the delegate does provide his own implementation of an<br>&gt;&gt;&gt;&gt;&gt;&gt; optional method or doesn’t. However, this is an important<br>&gt;&gt; advantage of<br>&gt;&gt;&gt;&gt;&gt;&gt; the ObjC model that we should not lose.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe it’s time to take a big step back and ignore the question<br>&gt;&gt; of how<br>&gt;&gt;&gt;&gt;&gt;&gt; to implement things for a moment and to instead focus on the<br>&gt;&gt; question<br>&gt;&gt;&gt;&gt;&gt;&gt; of what the conceptual differences are between ObjC protocols<br>&gt;&gt; with<br>&gt;&gt;&gt;&gt;&gt;&gt; optional methods and Swift protocols with default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations. There are two relevant viewpoints here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) From the viewpoint of a protocol adaptor:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1a) adopter may provide his own implementation of the protocol<br>&gt;&gt; method,<br>&gt;&gt;&gt;&gt;&gt;&gt; but he is no required to.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1b) adopter can see in the protocol declaration for which methods<br>&gt;&gt; he<br>&gt;&gt;&gt;&gt;&gt;&gt; must provide an implementation. Those methods do not have the<br>&gt;&gt;&gt;&gt;&gt;&gt; “optional” keyword in front of them while optional methods do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1c) same as (1a).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1d) opening a binary-only Swift file in Xcode with a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; definition in it which contains methods with default<br>&gt;&gt; implementations<br>&gt;&gt;&gt;&gt;&gt;&gt; will not give any indication of which method has a default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation and which doesn’t. It’s only possible to see a<br>&gt;&gt;&gt;&gt;&gt;&gt; difference on the syntax level if you have access to the sources.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This visibility problem is something we aim to correct in Swift,<br>&gt;&gt; but<br>&gt;&gt;&gt;&gt;&gt; that is a question of syntax, documentation, and “header”<br>&gt;&gt; generation,<br>&gt;&gt;&gt;&gt;&gt; and really orthogonal to what&#39;s fundamental about “optional<br>&gt;&gt;&gt;&gt;&gt; requirements:” <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. The ability to “conform” to the protocol without a<br>&gt;&gt;&gt;&gt;&gt; default implementation of the requirement have been provided<br>&gt;&gt;&gt;&gt;&gt; anywhere.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. The ability to dynamically query whether a type actually<br>&gt;&gt; provides the<br>&gt;&gt;&gt;&gt;&gt; requirement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Both of these “features,” IMO, are actually bugs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So from the viewpoint of the protocol adopter, there isn’t much<br>&gt;&gt; of a<br>&gt;&gt;&gt;&gt;&gt;&gt; difference. The only relevant difference is that its always<br>&gt;&gt; possible<br>&gt;&gt;&gt;&gt;&gt;&gt; in ObjC to tell whether a protocol method must be implemented by<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; adopter or whether a method already has a default behavior. We<br>&gt;&gt;&gt;&gt;&gt;&gt; shouldn’t actually have to change anything on the syntax-level in<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift to fix this problem. It should be sufficient to improve the<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift interface generator in Xcode so that it gives an indication<br>&gt;&gt;&gt;&gt;&gt;&gt; whether a protocol method has a default implementation or<br>&gt;&gt; doesn’t. Eg<br>&gt;&gt;&gt;&gt;&gt;&gt; if we want to ensure that the generated interface is valid syntax<br>&gt;&gt; then<br>&gt;&gt;&gt;&gt;&gt;&gt; we could do this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func void bar() -&gt; Int /* has default */<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or if we say that it is fine that the generated interface is not<br>&gt;&gt; valid<br>&gt;&gt;&gt;&gt;&gt;&gt; syntax (I think it already shows &quot;= default” for function<br>&gt;&gt; arguments<br>&gt;&gt;&gt;&gt;&gt;&gt; with a default value which I don’t think is valid syntax), then<br>&gt;&gt; we<br>&gt;&gt;&gt;&gt;&gt;&gt; could do this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func void bar() -&gt; Int {…}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now on to the other side of the equation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2) From the viewpoint of the protocol provider (the person who<br>&gt;&gt; defines<br>&gt;&gt;&gt;&gt;&gt;&gt; the protocol and the type that will invoke the protocol methods):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2a) provider has freedom in deciding where to put the default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation and he can put the default implementation in a<br>&gt;&gt; single<br>&gt;&gt;&gt;&gt;&gt;&gt; place or spread it out if necessary over multiple places. So has<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; freedom to choose whatever makes the most sense for the problem<br>&gt;&gt; at<br>&gt;&gt;&gt;&gt;&gt;&gt; hand.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But freedom for protocol implementors reduces predictability for<br>&gt;&gt; protocol<br>&gt;&gt;&gt;&gt;&gt; clients and adopters.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2b) provider can detect whether the adopter provides his own<br>&gt;&gt; protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; method implementation without compromising the definition of the<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol (compromising here means making return values optional<br>&gt;&gt; when<br>&gt;&gt;&gt;&gt;&gt;&gt; they should not be optional based on the natural definition of<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; API). This enables the provider to implement macro-level<br>&gt;&gt; optimizations<br>&gt;&gt;&gt;&gt;&gt;&gt; (eg table view can understand whether fixed or variable row<br>&gt;&gt; heights<br>&gt;&gt;&gt;&gt;&gt;&gt; are desired).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2c) provider is forced to put the default implementation in a<br>&gt;&gt; specific<br>&gt;&gt;&gt;&gt;&gt;&gt; place.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2d) provider has no way to detect whether the adopter has<br>&gt;&gt; provided his<br>&gt;&gt;&gt;&gt;&gt;&gt; own implementation of the protocol method.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I do think that (2a) would be nice to have but we can probably do<br>&gt;&gt;&gt;&gt;&gt;&gt; without it if it helps us to make progress with this<br>&gt;&gt; topic. However,<br>&gt;&gt;&gt;&gt;&gt;&gt; the ability to detect whether a protocol adopter provides his own<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of a protocol method which comes with a default is<br>&gt;&gt; a<br>&gt;&gt;&gt;&gt;&gt;&gt; useful and important feature which helps us in optimizing the<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of types and which allows us to keep the API<br>&gt;&gt; surface<br>&gt;&gt;&gt;&gt;&gt;&gt; smaller than it would be without this ability. Just go and<br>&gt;&gt; compare eg<br>&gt;&gt;&gt;&gt;&gt;&gt; UITableView to the Android ListView / RecyclerView to see the<br>&gt;&gt;&gt;&gt;&gt;&gt; consequences of not having that ability and how it inflates the<br>&gt;&gt; API<br>&gt;&gt;&gt;&gt;&gt;&gt; surface (and keep in mind that the Android equivalents provide a<br>&gt;&gt;&gt;&gt;&gt;&gt; fraction of the UITableView functionality).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The important point about (2b) is actually that we are able to<br>&gt;&gt; detect<br>&gt;&gt;&gt;&gt;&gt;&gt; whether an “override” (I’ll just call this overriding for now) of<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; default implementation exists or does not exist. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO the important point about (2b) is that it leads to protocol<br>&gt;&gt; designs<br>&gt;&gt;&gt;&gt;&gt; that create work and complexity for clients of the protocol, and<br>&gt;&gt; being<br>&gt;&gt;&gt;&gt;&gt; constrained to make your protocol work so that clients don&#39;t have<br>&gt;&gt; to do<br>&gt;&gt;&gt;&gt;&gt; these kinds of checks is a Very Good Thing™.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In ObjC we make this distinction by checking whether an<br>&gt;&gt; implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; of the method exists at all. But we don’t have to do it that<br>&gt;&gt; way. An<br>&gt;&gt;&gt;&gt;&gt;&gt; alternative approach could be based on a check that sees whether<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; dispatch table of the delegate contains a pointer to the default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of the protocol method or to some other method. So<br>&gt;&gt;&gt;&gt;&gt;&gt; conceptually what we want is an operation like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func void useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if has_override(delegate, tableView(_:, heightOfRow:)) { // ask<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; delegate how many rows it has // allocate the geometry cache //<br>&gt;&gt; fill<br>&gt;&gt;&gt;&gt;&gt;&gt; in the geometry cache by calling tableView(_:, heightForRow:) for<br>&gt;&gt; each<br>&gt;&gt;&gt;&gt;&gt;&gt; row } else { // nothing to do here } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Which would get the job done but doesn’t look good. Maybe someone<br>&gt;&gt; has<br>&gt;&gt;&gt;&gt;&gt;&gt; a better idea of how the syntax such an operator could look.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So my point here is that what we care about is the ability to<br>&gt;&gt; detect<br>&gt;&gt;&gt;&gt;&gt;&gt; whether the adopter provides an implementation of a protocol<br>&gt;&gt; method<br>&gt;&gt;&gt;&gt;&gt;&gt; which comes with a default implementation. The point is not that<br>&gt;&gt; Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; protocols should work the exact same way that ObjC protocols have<br>&gt;&gt; been<br>&gt;&gt;&gt;&gt;&gt;&gt; working under the hood. But I do think that we want to eventually<br>&gt;&gt; get<br>&gt;&gt;&gt;&gt;&gt;&gt; to a point where the @objc attribute disappears and that we get a<br>&gt;&gt;&gt;&gt;&gt;&gt; truly unified language on the syntactical level. An approach<br>&gt;&gt; where:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I) we accept that the default behavior of a protocol method has<br>&gt;&gt; to be<br>&gt;&gt;&gt;&gt;&gt;&gt; provided by the protocol itself<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; II) the language is extended with a mechanism that makes it<br>&gt;&gt; possible<br>&gt;&gt;&gt;&gt;&gt;&gt; for a protocol provider to detect whether the adopter has<br>&gt;&gt; “overridden”<br>&gt;&gt;&gt;&gt;&gt;&gt; the default implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; III) we improve the Xcode Swift interface generator so that it<br>&gt;&gt; gives a<br>&gt;&gt;&gt;&gt;&gt;&gt; clear indication whether a protocol method does come with a<br>&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would give us all the relevant advantages of ObjC-style optional<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol methods and it should allow us to create a unified<br>&gt;&gt; syntax<br>&gt;&gt;&gt;&gt;&gt;&gt; where there is no longer a visible difference between an optional<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol method that was imported from ObjC and a native Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol with default implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Dietmar Planitzer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Optional protocol requirements in Swift have the restriction<br>&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they only work in @objc protocols, a topic that’s come up a<br>&gt;&gt; number<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of times. The start of these threads imply that optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements should be available for all protocols in<br>&gt;&gt; Swift. While<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this direction is implementable, each time this is discussed<br>&gt;&gt; there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is significant feedback that optional requirements are not a<br>&gt;&gt; feature<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we want in Swift. They overlap almost completely with default<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations of protocol requirements, which is a more<br>&gt;&gt; general<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature, and people seem to feel that designs based around<br>&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations and refactoring of protocol hierarchies are<br>&gt;&gt; overall<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; better.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main concern with removing optional requirements from Swift<br>&gt;&gt; is their impact on Cocoa: Objective-C protocols, especially for<br>&gt;&gt; delegates and data sources, make heavy use of optional<br>&gt;&gt; requirements. Moreover, there are no default implementations for any<br>&gt;&gt; of these optional requirements: each caller effectively checks for the<br>&gt;&gt; presence of the method explicitly, and implements its own logic if the<br>&gt;&gt; method isn’t there.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A Non-Workable Solution: Import as optional property<br>&gt;&gt; requirements One suggestion that’s come up to map an optional<br>&gt;&gt; requirement to a property with optional type, were “nil” indicates<br>&gt;&gt; that the requirement was not satisfied. For example,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @protocol NSTableViewDelegate @optional - (nullable NSView<br>&gt;&gt; *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn<br>&gt;&gt; *)tableColumn row:(NSInteger)row; - (CGFloat)tableView:(NSTableView<br>&gt;&gt; *)tableView heightOfRow:(NSInteger)row; @end<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; currently comes in as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { optional func tableView(_:<br>&gt;&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  optional<br>&gt;&gt; func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would come in as:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { var tableView:<br>&gt;&gt; ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>&gt;&gt; var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with a default implementation of “nil” for each. However, this<br>&gt;&gt; isn’t practical for a number of reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a) We would end up overloading the property name “tableView” a<br>&gt;&gt; couple dozen times, which doesn’t actually work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; b) You can no longer refer to the member with a compound name,<br>&gt;&gt; e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because<br>&gt;&gt; the name of the property is “tableView”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; c) Implementers of the protocol now need to provide a read-only<br>&gt;&gt; property that returns a closure. So instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { func tableView(_:<br>&gt;&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; one would have to write something like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { var tableView:<br>&gt;&gt; ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = { …<br>&gt;&gt; except you can’t refer to self in here unless you make it lazy ...  }<br>&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; d) We’ve seriously considered eliminating argument labels on<br>&gt;&gt; function types, because they’re a complexity in the type system that<br>&gt;&gt; doesn’t serve much of a purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing<br>&gt;&gt; compound (function-like) names like tableView(_:viewFor:row:) for<br>&gt;&gt; properties, and work around (c) by allowing a method to satisfy the<br>&gt;&gt; requirement for a read-only property, but at this point you’ve<br>&gt;&gt; invented more language hacks than the existing @objc-only optional<br>&gt;&gt; requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Default implementations and optional requirements differ most on<br>&gt;&gt; the caller side. For example, let’s use NSTableView delegate as it’s<br>&gt;&gt; imported today:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) { if let getView<br>&gt;&gt; = delegate.tableView(_:viewFor:row:) { // since the requirement is<br>&gt;&gt; optional, a reference to the method produces a value of optional<br>&gt;&gt; function type // I can call getView here }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let getHeight = delegate.tableView(_:heightOfRow:) { // I can<br>&gt;&gt; call getHeight here } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute<br>&gt;&gt; (let’s call it @__caller_default_implementation) that gets places on<br>&gt;&gt; Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt; @__caller_default_implementation func tableView(_: NSTableView,<br>&gt;&gt; viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;&gt; @__caller_default_implementation func tableView(_: NSTableView,<br>&gt;&gt; heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And “optional” disappears from the language. Now, there’s no<br>&gt;&gt; optionality left, so our useDelegate example tries to just do correct<br>&gt;&gt; calls:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? { let<br>&gt;&gt; view = delegate.tableView(tableView, viewFor: column, row: row) let<br>&gt;&gt; height = delegate.tableView(tableView, heightOfRow: row) }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Of course, the code above will fail if the actual delegate<br>&gt;&gt; doesn’t implement both methods. We need some kind of default<br>&gt;&gt; implementation to fall back on in that case. I propose that the code<br>&gt;&gt; above produce a compiler error on both lines *unless* there is a<br>&gt;&gt; “default implementation” visible. So, to make the code above compile<br>&gt;&gt; without error, one would have to add:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension NSTableViewDelegate { @nonobjc func tableView(_:<br>&gt;&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil<br>&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt;<br>&gt;&gt; CGFloat { return 17 } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now, the useDelegate example compiles. If the actual delegate<br>&gt;&gt; implements the optional requirement, we’ll use that<br>&gt;&gt; implementation. Otherwise, the caller will use the default<br>&gt;&gt; (Swift-only) implementation it sees. From an implementation<br>&gt;&gt; standpoint, the compiler would effectively produce the following for<br>&gt;&gt; the first of these calls:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if delegate.responds(to:<br>&gt;&gt; #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) { // call<br>&gt;&gt; the @objc instance method with the selector<br>&gt;&gt; tableView:viewForTableColumn:row: } else { // call the Swift-only<br>&gt;&gt; implementation of tableView(_:viewFor:row:) in the protocol extension<br>&gt;&gt; above }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the<br>&gt;&gt; language. For classes that are adopting the NSTableViewDelegate<br>&gt;&gt; protocol, it is as if these requirements had default implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) Only the callers to these requirements have to deal with the<br>&gt;&gt; lack<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of default implementations. This was already the case for<br>&gt;&gt; optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements, so it’s not an extra burden in principle, and it’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; generally going to be easier to write one defaulted<br>&gt;&gt; implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; than deal with it in several different places. Additionally,<br>&gt;&gt; most of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; these callers are probably in the Cocoa frameworks, not<br>&gt;&gt; application<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; code, so the overall impact should be small.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 12:03 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;dplanitzer-AT-q.com &lt;http://dplanitzer-at-q.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Apr 10, 2016, at 11:46, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure whether you’ve read the conclusion of my mail since<br>&gt;&gt;&gt;&gt; you’ve only commented on the introductory part. In the conclusion I<br>&gt;&gt;&gt;&gt; wrote that a possible approach for the replacement of ObjC-style<br>&gt;&gt;&gt;&gt; optional protocol methods would be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) the default implementation of a protocol method must be defined<br>&gt;&gt; in<br>&gt;&gt;&gt;&gt; the protocol (so just like in native Swift protocols today).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ? They can and must be defined in protocol extensions today.<br>&gt;&gt; <br>&gt;&gt; I know.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) we add a way for a protocol provider to check whether the<br>&gt;&gt; protocol<br>&gt;&gt;&gt;&gt; adopter has provided an “override” of the default method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I object to this part.<br>&gt;&gt; <br>&gt;&gt; You object why? I do understand why you object to the ObjC model since<br>&gt;&gt; there is not necessarily an implementation of the protocol method and<br>&gt;&gt; thus the protocol provider has to guard every call with an existence<br>&gt;&gt; check. But in this model here we would be guaranteed that there would<br>&gt;&gt; be an implementation of the protocol method and thus guarding the call<br>&gt;&gt; wouldn’t be necessary.<br>&gt; <br>&gt; Because it&#39;s a needless complication that will encourage protocol and<br>&gt; algorithm designers to create inefficient programs because they know the<br>&gt; user can fall back on this hack.  Nobody thinks that classes need the<br>&gt; ability to check whether a given method is overridden.  Why should this<br>&gt; be needed for protocols?<br></p><p><br>Actually, Apple’s frameworks have often contained code to check whether given methods are overridden, and this has allowed them to deprecate override points and replace them with better API without breaking source or binary compatibility. The most obvious example that comes to mind is NSDocument; when they introduced the newer override points such as -readFromURL:ofType:error: that used NSURLs instead of paths and allowed returning an NSError, they added code in the default implementation to check whether the subclass overrode the older -readFromFile:ofType: method and if it did, called that method. Otherwise, it would call the modern methods. This way, older applications that were still overriding -readFromFile:ofType: would continue to work correctly.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/cf73348b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 11, 2016 at 11:00:00am</p></header><div class="content"><p>on Mon Apr 11 2016, Charles Srstka &lt;cocoadev-AT-charlessoft.com&gt; wrote:<br></p><p>&gt;     On Apr 11, 2016, at 12:03 PM, Dave Abrahams via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Sun Apr 10 2016, Dietmar Planitzer &lt;dplanitzer-AT-q.com&gt; wrote:<br>&gt;<br>&gt;                 On Apr 10, 2016, at 11:46, Dave Abrahams via swift-evolution<br>&gt;<br>&gt;         &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;             on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt;<br>&gt;         wrote:<br>&gt;<br>&gt;                         I’m not sure whether you’ve read the conclusion of my<br>&gt;                 mail since<br>&gt;                 you’ve only commented on the introductory part. In the<br>&gt;                 conclusion I<br>&gt;                 wrote that a possible approach for the replacement of ObjC-style<br>&gt;                 optional protocol methods would be:<br>&gt;<br>&gt;                 1) the default implementation of a protocol method must be<br>&gt;                 defined<br>&gt;<br>&gt;         in<br>&gt;<br>&gt;                     the protocol (so just like in native Swift protocols today).<br>&gt;<br>&gt;             ? They can and must be defined in protocol extensions today.<br>&gt;<br>&gt;         I know.<br>&gt;<br>&gt;                 2) we add a way for a protocol provider to check whether the<br>&gt;<br>&gt;         protocol<br>&gt;<br>&gt;                     adopter has provided an “override” of the default method.<br>&gt;<br>&gt;             I object to this part.<br>&gt;<br>&gt;         You object why? I do understand why you object to the ObjC model since<br>&gt;         there is not necessarily an implementation of the protocol method and<br>&gt;         thus the protocol provider has to guard every call with an existence<br>&gt;         check. But in this model here we would be guaranteed that there would<br>&gt;         be an implementation of the protocol method and thus guarding the call<br>&gt;         wouldn’t be necessary.<br>&gt;<br>&gt;     Because it&#39;s a needless complication that will encourage protocol and<br>&gt;     algorithm designers to create inefficient programs because they know the<br>&gt;     user can fall back on this hack. Nobody thinks that classes need the<br>&gt;     ability to check whether a given method is overridden. Why should this<br>&gt;     be needed for protocols?<br>&gt;<br>&gt; Actually, Apple’s frameworks have often contained code to check whether given<br>&gt; methods are overridden, and this has allowed them to deprecate override points<br>&gt; and replace them with better API without breaking source or binary<br>&gt; compatibility. The most obvious example that comes to mind is NSDocument; when<br>&gt; they introduced the newer override points such as -readFromURL:ofType:error:<br>&gt; that used NSURLs instead of paths and allowed returning an NSError, they added<br>&gt; code in the default implementation to check whether the subclass overrode the<br>&gt; older -readFromFile:ofType: method and if it did, called that method. Otherwise,<br>&gt; it would call the modern methods. This way, older applications that were still<br>&gt; overriding -readFromFile:ofType: would continue to work correctly.<br></p><p>I don&#39;t believe we&#39;re aiming to support this kind of evolution in Swift,<br>but others understand our resilience plans better than I, so we should<br>probably let them comment.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 11:41 , Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Apr 11 2016, Charles Srstka &lt;cocoadev-AT-charlessoft.com &lt;http://cocoadev-at-charlessoft.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;    On Apr 11, 2016, at 12:03 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    on Sun Apr 10 2016, Dietmar Planitzer &lt;dplanitzer-AT-q.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;                On Apr 10, 2016, at 11:46, Dave Abrahams via swift-evolution<br>&gt;&gt; <br>&gt;&gt;        &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;            on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; <br>&gt;&gt;        wrote:<br>&gt;&gt; <br>&gt;&gt;                        I’m not sure whether you’ve read the conclusion of my<br>&gt;&gt;                mail since<br>&gt;&gt;                you’ve only commented on the introductory part. In the<br>&gt;&gt;                conclusion I<br>&gt;&gt;                wrote that a possible approach for the replacement of ObjC-style<br>&gt;&gt;                optional protocol methods would be:<br>&gt;&gt; <br>&gt;&gt;                1) the default implementation of a protocol method must be<br>&gt;&gt;                defined<br>&gt;&gt; <br>&gt;&gt;        in<br>&gt;&gt; <br>&gt;&gt;                    the protocol (so just like in native Swift protocols today).<br>&gt;&gt; <br>&gt;&gt;            ? They can and must be defined in protocol extensions today.<br>&gt;&gt; <br>&gt;&gt;        I know.<br>&gt;&gt; <br>&gt;&gt;                2) we add a way for a protocol provider to check whether the<br>&gt;&gt; <br>&gt;&gt;        protocol<br>&gt;&gt; <br>&gt;&gt;                    adopter has provided an “override” of the default method.<br>&gt;&gt; <br>&gt;&gt;            I object to this part.<br>&gt;&gt; <br>&gt;&gt;        You object why? I do understand why you object to the ObjC model since<br>&gt;&gt;        there is not necessarily an implementation of the protocol method and<br>&gt;&gt;        thus the protocol provider has to guard every call with an existence<br>&gt;&gt;        check. But in this model here we would be guaranteed that there would<br>&gt;&gt;        be an implementation of the protocol method and thus guarding the call<br>&gt;&gt;        wouldn’t be necessary.<br>&gt;&gt; <br>&gt;&gt;    Because it&#39;s a needless complication that will encourage protocol and<br>&gt;&gt;    algorithm designers to create inefficient programs because they know the<br>&gt;&gt;    user can fall back on this hack. Nobody thinks that classes need the<br>&gt;&gt;    ability to check whether a given method is overridden. Why should this<br>&gt;&gt;    be needed for protocols?<br>&gt;&gt; <br>&gt;&gt; Actually, Apple’s frameworks have often contained code to check whether given<br>&gt;&gt; methods are overridden, and this has allowed them to deprecate override points<br>&gt;&gt; and replace them with better API without breaking source or binary<br>&gt;&gt; compatibility. The most obvious example that comes to mind is NSDocument; when<br>&gt;&gt; they introduced the newer override points such as -readFromURL:ofType:error:<br>&gt;&gt; that used NSURLs instead of paths and allowed returning an NSError, they added<br>&gt;&gt; code in the default implementation to check whether the subclass overrode the<br>&gt;&gt; older -readFromFile:ofType: method and if it did, called that method. Otherwise,<br>&gt;&gt; it would call the modern methods. This way, older applications that were still<br>&gt;&gt; overriding -readFromFile:ofType: would continue to work correctly.<br>&gt; <br>&gt; I don&#39;t believe we&#39;re aiming to support this kind of evolution in Swift,<br>&gt; but others understand our resilience plans better than I, so we should<br>&gt; probably let them comment.<br></p><p>It&#39;s a useful enough pattern that I wouldn&#39;t want to rule it out entirely, but it&#39;s rare enough that it could be some strange runtime call. (Also, in many cases there&#39;s a simpler implementation, like &quot;call the old method unilaterally&quot;.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/6bf60d0b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d1af757c2ce75a92193ad0c34bc62af1?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Dietmar Planitzer</string> &lt;dplanitzer at q.com&gt;<p>April 12, 2016 at 02:00:00pm</p></header><div class="content"><p>Inline.<br></p><p>&gt; On Apr 11, 2016, at 10:03, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;dplanitzer-AT-q.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Apr 10, 2016, at 11:46, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure whether you’ve read the conclusion of my mail since<br>&gt;&gt;&gt;&gt; you’ve only commented on the introductory part. In the conclusion I<br>&gt;&gt;&gt;&gt; wrote that a possible approach for the replacement of ObjC-style<br>&gt;&gt;&gt;&gt; optional protocol methods would be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) the default implementation of a protocol method must be defined<br>&gt;&gt; in<br>&gt;&gt;&gt;&gt; the protocol (so just like in native Swift protocols today).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ? They can and must be defined in protocol extensions today.<br>&gt;&gt; <br>&gt;&gt; I know.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) we add a way for a protocol provider to check whether the<br>&gt;&gt; protocol<br>&gt;&gt;&gt;&gt; adopter has provided an “override” of the default method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I object to this part.<br>&gt;&gt; <br>&gt;&gt; You object why? I do understand why you object to the ObjC model since<br>&gt;&gt; there is not necessarily an implementation of the protocol method and<br>&gt;&gt; thus the protocol provider has to guard every call with an existence<br>&gt;&gt; check. But in this model here we would be guaranteed that there would<br>&gt;&gt; be an implementation of the protocol method and thus guarding the call<br>&gt;&gt; wouldn’t be necessary.<br>&gt; <br>&gt; Because it&#39;s a needless complication that will encourage protocol and<br>&gt; algorithm designers to create inefficient programs because they know the<br>&gt; user can fall back on this hack.<br></p><p>It’s not clear why you think that the ability to check whether a protocol adopter implements a method or doesn’t would make programs inefficient. The fact that the protocol provider can check whether an adopter actually wants a feature or not (optional method is implemented -&gt; adopter wants the feature; otherwise he clearly doesn’t) is what enables us to create more efficient implementations.<br></p><p>&gt;  Nobody thinks that classes need the<br>&gt; ability to check whether a given method is overridden.  Why should this<br>&gt; be needed for protocols?<br></p><p>Various Mac OS X frameworks have been using this technique for a long time to enable:<br></p><p>a) binary backward compatibility: eg NSDocument or NSBrowser in the AppKit have dramatically changed their respective implementations over the past 10 to 20 years and they have changed their subclassing APIs in some cases. The implementation does check whether an app is overriding the old methods and if so the classes enable backward compatibility functionality as needed while still providing as many of the new pieces of functionality as possible.<br></p><p>b) optimizations: eg the AppKit text system for example is very powerful, Unicode compliant and it offers a lot of customization hooks for app developers. However customization hooks are sometimes only enabled if they are actually used by an app (if the app overrides them in a subclass). Otherwise they are disabled and bypassed to enable faster standard text processing.<br></p><p>&gt;&gt;&gt;&gt; 3) we improve the Xcode interface generator so that it clearly shows<br>&gt;&gt;&gt;&gt; whether a protocol method comes with a default or whether it<br>&gt;&gt;&gt;&gt; doesn’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obvious goodness, long overdue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (1) should address your main concern since it would guarantee that<br>&gt;&gt;&gt;&gt; the protocol provider is always able to call the protocol method<br>&gt;&gt;&gt;&gt; without having to do any checks. (2) would address the main concern<br>&gt;&gt;&gt;&gt; of protocol providers who need to guarantee that the protocol using<br>&gt;&gt;&gt;&gt; type achieves a certain minimum speed and does not use more than a<br>&gt;&gt;&gt;&gt; certain amount of memory for its internal book-keeping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t how (2) can possibly help with that.<br>&gt;&gt; <br>&gt;&gt; It helps because it allows the protocol provider to *understand*<br>&gt;&gt; whether the protocol adopter is actually using a certain feature or<br>&gt;&gt; isn’t. <br>&gt; <br>&gt; If they need to understand that, they can make the indicator of that<br>&gt; fact a separate protocol requirement.<br>&gt; <br>&gt;&gt; Here is the table view example again:<br>&gt;&gt; <br>&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt; <br>&gt;&gt;  if has_override(delegate, tableView(_:, heightForRow:)) {<br>&gt;&gt;     // call tableViewNumberOfRows() on the delegate<br>&gt;&gt;     // allocate the geometry cache (1 entry per row)<br>&gt;&gt;     // call tableView(_:, heightForRow:) for each row<br>&gt;&gt;  } else {<br>&gt;&gt;    // nothing to do here since here all rows have the same height<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that has_override() is just a placeholder syntax because I’ve not<br>&gt;&gt; had a good idea yet of how to express this in a Swiftier way.<br>&gt; <br>&gt;   if delegate.hasVariableSizedRows { … }<br></p><p>This means that we not only increase the surface of the API, it also means that we make it now possible for the protocol adopter to provide conflicting information to the caller of the protocol methods. At the same time, the caller of the protocol methods still needs to guard every call of tableView(heightForRow:) with a call to hasVariableSizedRows(). So by the end of the day, this solution doesn’t improve anything. It just adds new complexity and sources of bugs.<br></p><p>The surface of the API increases because the protocol adopter now has to learn 2 methods instead of 1 and he has to provide up to 2 implementations instead of just one. It makes it more likely that the protocol adopter writes buggy software and gets confused by the behavior of the table view. Eg it is safe to assume that both hasVariableSizedRows() and heightForRow() would come with a default implementation (keep in mind that those features didn’t even exist for the first couple years of the NSTableView’s life). So I could write this in my delegate:<br></p><p>func heightForRow(row: Int) -&gt; Float {<br>   return (i % 2) == 0 ? 60 : 30<br>}<br></p><p>and then when I compile my app and run it - I don’t get alternate row heights because if forgot to provide my own implementation of hasVariableSizedRows() (and the default implementation returns false for binary backward combat reasons). Or I write this:<br></p><p>func hasVariableSizedRows() -&gt; Boolean {<br>   return true<br>}<br></p><p>func heigthForRow(row: Int) -&gt; Float {<br>   return (i % 2) == 0 ? 60 : 30<br>}<br></p><p>Compile it - and again the table view doesn’t work “thanks” to the fact that the protocol comes with default implementations AND because Swift does not require that a method which overrides a default protocol implementation must be marked with the “override” (or some other) keyword. Eg this:<br></p><p>override func hasVariableSizedRows() -&gt; Boolean {<br>   return true<br>}<br></p><p>override func heigthForRow(row: Int) -&gt; Float {<br>   return (i % 2) == 0 ? 60 : 30<br>}<br></p><p>Here at least the compiler would have been able to tell me that something is wrong and that I’m not actually replacing the default protocol method implementation as I thought I would. Yes the ObjC variant of optional protocol methods also suffers from the misspelling problem - but that’s not an argument against the concept of optional protocol methods. It is only an argument against the way that they are implemented in ObjC. One of my hopes, when Swift was revealed to the public as “an Objc without the C part”, was actually that this would have been one of the things that it would have fixed. But it didn’t. Instead it gave us a similar problem with its particular combination of default protocol methods and the way they are supposed to be overriden / shadowed in conforming types.<br></p><p>So, no. Your proposed solution is not an improvement. Especially considering the way that protocols work in Swift today.<br></p><p><br>Your model also allows a protocol adopter to provide conflicting information because he can now do this:<br></p><p>func hasVariableSizedRows() -&gt; Boolean {<br>   return false<br>}<br></p><p>func heightForRow(row: Int) -&gt; Float {<br>   return 8<br>}<br></p><p>or he can do this:<br></p><p>func hasVariableSizedRows() -&gt; Boolean {<br>   return true<br>}<br></p><p>func heightForRow(row: Int) -&gt; Float {<br>   return 0<br>}<br></p><p>and then the question is: what should the table view do? Does the return value of hasVariableSizeRows() represent the truth or is it the return value of heightForRow()? It’s possible to argue either way. But no matter how we decide to handle this, we now need to write code in the protocol using type that detects these conflicts and does something about them. Even if that something is just to kill the app, we still need to write that code correctly. If we miss a case and it just so happens that an app that returns conflicting information to us gets away with it and the table view ends up producing something that looks right to the app vendor, then we are now forever bound to keep this special case intact since breaking an app with a OS update is not an option.<br></p><p>Finally, this model didn’t actually make anything safer from the viewpoint of the protocol provider because we still need to guard every call to heightForRow(). Nothing has improved on that front:<br></p><p>if delegate.hasVariableSizeRows() {<br>   return delegate.heightForRow(row)<br>} else {<br>   return rowHeight<br>}<br></p><p>is not better than this:<br></p><p>if has_override(delegate, heightForRow) {<br>   return delegate.heightForRow()<br>} else {<br>   return rowHeight<br>}<br></p><p>in fact it is worse. Because we now need to introduce this “guarding predicate” for every single use case. Each and every use case will require yet another guarding call that we have to design, implement, test and that our users have to learn about. It is much better to solve this problem once and then to reuse this solution for all use cases since it is universally applicable.<br></p><p>What this is fundamentally about, and allows us to do:<br></p><p>if delegate.respondsToSelector(#selector(tableView(:heightForRow:)) {<br>   delegate.tableView(self, heightForRow: row)<br>}<br></p><p>in ObjC is the idea that the NSTableView is a component which offers a set of features:<br></p><p>- fixed row heights<br>- variable row heights<br>- drag &amp; drop<br>- old style pasteboard support<br>- new style pasteboard support<br>- old style table cells<br>- new style table cell views<br>- etc, pp<br></p><p>and then the delegate simply picks the features that it wants to use. It simply does this by implementing the corresponding methods and by NOT implementing the methods of a feature it doesn’t care about:<br></p><p>- delegate wants feature X -&gt; implement the method for feature X<br></p><p>- delegate does not want feature X -&gt; nothing to do<br></p><p>and this is why the concept of optional protocol methods captures this idea precisely: I don’t need to write code for feature X if I don’t want it. Why should I write code for something I don’t want? Wouldn’t make sense.<br></p><p><br>&gt;   if !(delegate is NSUniformTableViewDelegate) { … }<br></p><p>I don’t think that replacing 1 protocol with a dozen or more protocols is a good idea or a step forward. Beside that we would actually have to introduce hundreds of new protocols since the optional protocol method feature is used all over the place in public Mac OS X frameworks and also in private ones.<br></p><p>&gt; etc.<br>&gt;&gt; <br>&gt;&gt; In this example the table view is able to check whether the protocol<br>&gt;&gt; adopter has actually “overriden” the default implementation of<br>&gt;&gt; tableView(_:, heightForRow:). <br>&gt; <br>&gt; Which, IMO, is a terrible way to indicate that a view has variable row<br>&gt; heights.  It&#39;s indirect and maybe even inaccurate (I can imagine a table<br>&gt; view that is uniform and has its height set up once at construction<br>&gt; time, therefore it needs to override heightForRow).<br></p><p>I don’t see how it is indirect. I want the feature -&gt; I implement the corresponding method; I don’t want the feature -&gt; I don’t write code for it. This captures exactly the nature of the problem and it really can’t get any simpler than that for the protocol user. Yes, it makes life a bit harder for the protocol provider. But that is absolutely fine and in fact that is what we want since for every protocol provider, there are dozens to hundreds to thousands of developers who are going to write code which adopts the protocol. So naturally we want to focus the complexity of the implementation on the side of the protocol provider while making the life for protocol adopters as easy and safe as possible.<br></p><p>It’s not clear how the optional protocol method concept can cause inaccuracy except that a protocol provider decides to misuse it. If I want a table view with a fixed row height then I just set the row height on the table view like this:<br></p><p>tableView.rowHeight = 16<br></p><p>and I simply don’t provide a heightForRow() implementation since all I want is a single height for all rows. So parameterizing the row height is not necessary and writing code for that would be a waste of time and just be an unnecessary source of bugs and potential confusion.<br></p><p><br>Regards,<br></p><p>Dietmar Planitzer<br></p><p>&gt;&gt; If the adopter did, then the table view knows that the adopter wants<br>&gt;&gt; variable row heights and thus the table view can now create a cache of<br>&gt;&gt; row heights and it can enable the layouting code that knows how to lay<br>&gt;&gt; out rows with different heights. If however the adopter did not<br>&gt;&gt; provide its own implementation of this method then the table view does<br>&gt;&gt; not need to create a geometry cache and it can switch over to the<br>&gt;&gt; simpler fixed-row-height layout code. The reason why we want to cache<br>&gt;&gt; the row heights in the table view is because computing those heights<br>&gt;&gt; can be nontrivial and the layout code needs to access those height<br>&gt;&gt; values in every layoutSubviews() call. And layoutSubviews() is invoked<br>&gt;&gt; 60 times per second while the user is scrolling. Also keep in mind<br>&gt;&gt; that, if we would not cache the row heights, then the row height<br>&gt;&gt; computation would end up competing for CPU cycles with the code that<br>&gt;&gt; properly configures the views for each row.<br>&gt;&gt; <br>&gt;&gt; Without the ability to do this check on the protocol provider side, we<br>&gt;&gt; are forced to increase the API surface so that the protocol adopter<br>&gt;&gt; can explicitly tell us which layouting model he wants. <br>&gt; <br>&gt; That&#39;s exactly what one should do.  If layout model is an important<br>&gt; feature, the adopter should be explicit abou tit.<br>&gt; <br>&gt;&gt; But this also means that the protocol adopter now has to remember that<br>&gt;&gt; he needs to configure the layouting option correctly in order to get a<br>&gt;&gt; working and efficiently working table view. So the end result would be<br>&gt;&gt; a table view that’s hard to use correctly.<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; <br>&gt;&gt; Dietmar Planitzer<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (3) is important because it would fix one of the many aspects that<br>&gt;&gt;&gt;&gt; make Swift protocols confusing for people who are new to the<br>&gt;&gt; language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, let me restate that the goal should really be that we<br>&gt;&gt;&gt;&gt; completely remove the syntactical differences between @objc and<br>&gt;&gt; native<br>&gt;&gt;&gt;&gt; Swift protocols. There should be one concept of protocol in Swift<br>&gt;&gt; and<br>&gt;&gt;&gt;&gt; we should be able to cover the use cases of formal and informal<br>&gt;&gt; ObjC<br>&gt;&gt;&gt;&gt; Protocols with them. The use case of formal protocols is already<br>&gt;&gt;&gt;&gt; covered today. The use case of informal protocols could be covered<br>&gt;&gt;&gt;&gt; with the approach above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So is this an approach that would be acceptable to you?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dietmar Planitzer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 10, 2016, at 10:29, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Apr 08 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The biggest missing part with this model is that we are still not<br>&gt;&gt; able<br>&gt;&gt;&gt;&gt;&gt;&gt; to enable macro-level optimizations in the delegating type by<br>&gt;&gt; checking<br>&gt;&gt;&gt;&gt;&gt;&gt; whether the delegate does provide his own implementation of an<br>&gt;&gt;&gt;&gt;&gt;&gt; optional method or doesn’t. However, this is an important<br>&gt;&gt; advantage of<br>&gt;&gt;&gt;&gt;&gt;&gt; the ObjC model that we should not lose.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe it’s time to take a big step back and ignore the question<br>&gt;&gt; of how<br>&gt;&gt;&gt;&gt;&gt;&gt; to implement things for a moment and to instead focus on the<br>&gt;&gt; question<br>&gt;&gt;&gt;&gt;&gt;&gt; of what the conceptual differences are between ObjC protocols<br>&gt;&gt; with<br>&gt;&gt;&gt;&gt;&gt;&gt; optional methods and Swift protocols with default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations. There are two relevant viewpoints here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) From the viewpoint of a protocol adaptor:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1a) adopter may provide his own implementation of the protocol<br>&gt;&gt; method,<br>&gt;&gt;&gt;&gt;&gt;&gt; but he is no required to.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1b) adopter can see in the protocol declaration for which methods<br>&gt;&gt; he<br>&gt;&gt;&gt;&gt;&gt;&gt; must provide an implementation. Those methods do not have the<br>&gt;&gt;&gt;&gt;&gt;&gt; “optional” keyword in front of them while optional methods do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1c) same as (1a).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1d) opening a binary-only Swift file in Xcode with a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; definition in it which contains methods with default<br>&gt;&gt; implementations<br>&gt;&gt;&gt;&gt;&gt;&gt; will not give any indication of which method has a default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation and which doesn’t. It’s only possible to see a<br>&gt;&gt;&gt;&gt;&gt;&gt; difference on the syntax level if you have access to the sources.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This visibility problem is something we aim to correct in Swift,<br>&gt;&gt; but<br>&gt;&gt;&gt;&gt;&gt; that is a question of syntax, documentation, and “header”<br>&gt;&gt; generation,<br>&gt;&gt;&gt;&gt;&gt; and really orthogonal to what&#39;s fundamental about “optional<br>&gt;&gt;&gt;&gt;&gt; requirements:” <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. The ability to “conform” to the protocol without a<br>&gt;&gt;&gt;&gt;&gt; default implementation of the requirement have been provided<br>&gt;&gt;&gt;&gt;&gt; anywhere.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. The ability to dynamically query whether a type actually<br>&gt;&gt; provides the<br>&gt;&gt;&gt;&gt;&gt; requirement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Both of these “features,” IMO, are actually bugs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So from the viewpoint of the protocol adopter, there isn’t much<br>&gt;&gt; of a<br>&gt;&gt;&gt;&gt;&gt;&gt; difference. The only relevant difference is that its always<br>&gt;&gt; possible<br>&gt;&gt;&gt;&gt;&gt;&gt; in ObjC to tell whether a protocol method must be implemented by<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; adopter or whether a method already has a default behavior. We<br>&gt;&gt;&gt;&gt;&gt;&gt; shouldn’t actually have to change anything on the syntax-level in<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift to fix this problem. It should be sufficient to improve the<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift interface generator in Xcode so that it gives an indication<br>&gt;&gt;&gt;&gt;&gt;&gt; whether a protocol method has a default implementation or<br>&gt;&gt; doesn’t. Eg<br>&gt;&gt;&gt;&gt;&gt;&gt; if we want to ensure that the generated interface is valid syntax<br>&gt;&gt; then<br>&gt;&gt;&gt;&gt;&gt;&gt; we could do this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func void bar() -&gt; Int /* has default */<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or if we say that it is fine that the generated interface is not<br>&gt;&gt; valid<br>&gt;&gt;&gt;&gt;&gt;&gt; syntax (I think it already shows &quot;= default” for function<br>&gt;&gt; arguments<br>&gt;&gt;&gt;&gt;&gt;&gt; with a default value which I don’t think is valid syntax), then<br>&gt;&gt; we<br>&gt;&gt;&gt;&gt;&gt;&gt; could do this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func void bar() -&gt; Int {…}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now on to the other side of the equation.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2) From the viewpoint of the protocol provider (the person who<br>&gt;&gt; defines<br>&gt;&gt;&gt;&gt;&gt;&gt; the protocol and the type that will invoke the protocol methods):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ObjC:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2a) provider has freedom in deciding where to put the default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation and he can put the default implementation in a<br>&gt;&gt; single<br>&gt;&gt;&gt;&gt;&gt;&gt; place or spread it out if necessary over multiple places. So has<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; freedom to choose whatever makes the most sense for the problem<br>&gt;&gt; at<br>&gt;&gt;&gt;&gt;&gt;&gt; hand.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But freedom for protocol implementors reduces predictability for<br>&gt;&gt; protocol<br>&gt;&gt;&gt;&gt;&gt; clients and adopters.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2b) provider can detect whether the adopter provides his own<br>&gt;&gt; protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; method implementation without compromising the definition of the<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol (compromising here means making return values optional<br>&gt;&gt; when<br>&gt;&gt;&gt;&gt;&gt;&gt; they should not be optional based on the natural definition of<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; API). This enables the provider to implement macro-level<br>&gt;&gt; optimizations<br>&gt;&gt;&gt;&gt;&gt;&gt; (eg table view can understand whether fixed or variable row<br>&gt;&gt; heights<br>&gt;&gt;&gt;&gt;&gt;&gt; are desired).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2c) provider is forced to put the default implementation in a<br>&gt;&gt; specific<br>&gt;&gt;&gt;&gt;&gt;&gt; place.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2d) provider has no way to detect whether the adopter has<br>&gt;&gt; provided his<br>&gt;&gt;&gt;&gt;&gt;&gt; own implementation of the protocol method.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I do think that (2a) would be nice to have but we can probably do<br>&gt;&gt;&gt;&gt;&gt;&gt; without it if it helps us to make progress with this<br>&gt;&gt; topic. However,<br>&gt;&gt;&gt;&gt;&gt;&gt; the ability to detect whether a protocol adopter provides his own<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of a protocol method which comes with a default is<br>&gt;&gt; a<br>&gt;&gt;&gt;&gt;&gt;&gt; useful and important feature which helps us in optimizing the<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of types and which allows us to keep the API<br>&gt;&gt; surface<br>&gt;&gt;&gt;&gt;&gt;&gt; smaller than it would be without this ability. Just go and<br>&gt;&gt; compare eg<br>&gt;&gt;&gt;&gt;&gt;&gt; UITableView to the Android ListView / RecyclerView to see the<br>&gt;&gt;&gt;&gt;&gt;&gt; consequences of not having that ability and how it inflates the<br>&gt;&gt; API<br>&gt;&gt;&gt;&gt;&gt;&gt; surface (and keep in mind that the Android equivalents provide a<br>&gt;&gt;&gt;&gt;&gt;&gt; fraction of the UITableView functionality).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The important point about (2b) is actually that we are able to<br>&gt;&gt; detect<br>&gt;&gt;&gt;&gt;&gt;&gt; whether an “override” (I’ll just call this overriding for now) of<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; default implementation exists or does not exist. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO the important point about (2b) is that it leads to protocol<br>&gt;&gt; designs<br>&gt;&gt;&gt;&gt;&gt; that create work and complexity for clients of the protocol, and<br>&gt;&gt; being<br>&gt;&gt;&gt;&gt;&gt; constrained to make your protocol work so that clients don&#39;t have<br>&gt;&gt; to do<br>&gt;&gt;&gt;&gt;&gt; these kinds of checks is a Very Good Thing™.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In ObjC we make this distinction by checking whether an<br>&gt;&gt; implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; of the method exists at all. But we don’t have to do it that<br>&gt;&gt; way. An<br>&gt;&gt;&gt;&gt;&gt;&gt; alternative approach could be based on a check that sees whether<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; dispatch table of the delegate contains a pointer to the default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of the protocol method or to some other method. So<br>&gt;&gt;&gt;&gt;&gt;&gt; conceptually what we want is an operation like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func void useDelegate(delegate: NSTableViewDelegate) {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if has_override(delegate, tableView(_:, heightOfRow:)) { // ask<br>&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt; delegate how many rows it has // allocate the geometry cache //<br>&gt;&gt; fill<br>&gt;&gt;&gt;&gt;&gt;&gt; in the geometry cache by calling tableView(_:, heightForRow:) for<br>&gt;&gt; each<br>&gt;&gt;&gt;&gt;&gt;&gt; row } else { // nothing to do here } }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Which would get the job done but doesn’t look good. Maybe someone<br>&gt;&gt; has<br>&gt;&gt;&gt;&gt;&gt;&gt; a better idea of how the syntax such an operator could look.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So my point here is that what we care about is the ability to<br>&gt;&gt; detect<br>&gt;&gt;&gt;&gt;&gt;&gt; whether the adopter provides an implementation of a protocol<br>&gt;&gt; method<br>&gt;&gt;&gt;&gt;&gt;&gt; which comes with a default implementation. The point is not that<br>&gt;&gt; Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; protocols should work the exact same way that ObjC protocols have<br>&gt;&gt; been<br>&gt;&gt;&gt;&gt;&gt;&gt; working under the hood. But I do think that we want to eventually<br>&gt;&gt; get<br>&gt;&gt;&gt;&gt;&gt;&gt; to a point where the @objc attribute disappears and that we get a<br>&gt;&gt;&gt;&gt;&gt;&gt; truly unified language on the syntactical level. An approach<br>&gt;&gt; where:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I) we accept that the default behavior of a protocol method has<br>&gt;&gt; to be<br>&gt;&gt;&gt;&gt;&gt;&gt; provided by the protocol itself<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; II) the language is extended with a mechanism that makes it<br>&gt;&gt; possible<br>&gt;&gt;&gt;&gt;&gt;&gt; for a protocol provider to detect whether the adopter has<br>&gt;&gt; “overridden”<br>&gt;&gt;&gt;&gt;&gt;&gt; the default implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; III) we improve the Xcode Swift interface generator so that it<br>&gt;&gt; gives a<br>&gt;&gt;&gt;&gt;&gt;&gt; clear indication whether a protocol method does come with a<br>&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would give us all the relevant advantages of ObjC-style optional<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol methods and it should allow us to create a unified<br>&gt;&gt; syntax<br>&gt;&gt;&gt;&gt;&gt;&gt; where there is no longer a visible difference between an optional<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol method that was imported from ObjC and a native Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol with default implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Dietmar Planitzer<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 7, 2016, at 17:12, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Optional protocol requirements in Swift have the restriction<br>&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they only work in @objc protocols, a topic that’s come up a<br>&gt;&gt; number<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of times. The start of these threads imply that optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements should be available for all protocols in<br>&gt;&gt; Swift. While<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this direction is implementable, each time this is discussed<br>&gt;&gt; there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is significant feedback that optional requirements are not a<br>&gt;&gt; feature<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we want in Swift. They overlap almost completely with default<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations of protocol requirements, which is a more<br>&gt;&gt; general<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature, and people seem to feel that designs based around<br>&gt;&gt; default<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations and refactoring of protocol hierarchies are<br>&gt;&gt; overall<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; better.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The main concern with removing optional requirements from Swift<br>&gt;&gt; is their impact on Cocoa: Objective-C protocols, especially for<br>&gt;&gt; delegates and data sources, make heavy use of optional<br>&gt;&gt; requirements. Moreover, there are no default implementations for any<br>&gt;&gt; of these optional requirements: each caller effectively checks for the<br>&gt;&gt; presence of the method explicitly, and implements its own logic if the<br>&gt;&gt; method isn’t there.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A Non-Workable Solution: Import as optional property<br>&gt;&gt; requirements One suggestion that’s come up to map an optional<br>&gt;&gt; requirement to a property with optional type, were “nil” indicates<br>&gt;&gt; that the requirement was not satisfied. For example,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @protocol NSTableViewDelegate @optional - (nullable NSView<br>&gt;&gt; *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn<br>&gt;&gt; *)tableColumn row:(NSInteger)row; - (CGFloat)tableView:(NSTableView<br>&gt;&gt; *)tableView heightOfRow:(NSInteger)row; @end<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; currently comes in as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { optional func tableView(_:<br>&gt;&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?  optional<br>&gt;&gt; func tableView(_: NSTableView, heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would come in as:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate { var tableView:<br>&gt;&gt; ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? { get }<br>&gt;&gt; var tableView: ((NSTableView, heightOfRow: Int) -&gt; CGFloat)? { get } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with a default implementation of “nil” for each. However, this<br>&gt;&gt; isn’t practical for a number of reasons:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a) We would end up overloading the property name “tableView” a<br>&gt;&gt; couple dozen times, which doesn’t actually work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; b) You can no longer refer to the member with a compound name,<br>&gt;&gt; e.g., “delegate.tableView(_:viewFor:row:)” no longer works, because<br>&gt;&gt; the name of the property is “tableView”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; c) Implementers of the protocol now need to provide a read-only<br>&gt;&gt; property that returns a closure. So instead of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { func tableView(_:<br>&gt;&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { … } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; one would have to write something like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class MyDelegate : NSTableViewDelegate { var tableView:<br>&gt;&gt; ((NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView?)? = { …<br>&gt;&gt; except you can’t refer to self in here unless you make it lazy ...  }<br>&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; d) We’ve seriously considered eliminating argument labels on<br>&gt;&gt; function types, because they’re a complexity in the type system that<br>&gt;&gt; doesn’t serve much of a purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One could perhaps work around (a), (b), and (d) by allowing<br>&gt;&gt; compound (function-like) names like tableView(_:viewFor:row:) for<br>&gt;&gt; properties, and work around (c) by allowing a method to satisfy the<br>&gt;&gt; requirement for a read-only property, but at this point you’ve<br>&gt;&gt; invented more language hacks than the existing @objc-only optional<br>&gt;&gt; requirements. So, I don’t think there is a solution here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposed Solution: Caller-side default implementations<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Default implementations and optional requirements differ most on<br>&gt;&gt; the caller side. For example, let’s use NSTableView delegate as it’s<br>&gt;&gt; imported today:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) { if let getView<br>&gt;&gt; = delegate.tableView(_:viewFor:row:) { // since the requirement is<br>&gt;&gt; optional, a reference to the method produces a value of optional<br>&gt;&gt; function type // I can call getView here }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let getHeight = delegate.tableView(_:heightOfRow:) { // I can<br>&gt;&gt; call getHeight here } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With my proposal, we’d have some compiler-synthesized attribute<br>&gt;&gt; (let’s call it @__caller_default_implementation) that gets places on<br>&gt;&gt; Objective-C optional requirements when they get imported, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @objc protocol NSTableViewDelegate {<br>&gt;&gt; @__caller_default_implementation func tableView(_: NSTableView,<br>&gt;&gt; viewFor: NSTableColumn, row: Int) -&gt; NSView?<br>&gt;&gt; @__caller_default_implementation func tableView(_: NSTableView,<br>&gt;&gt; heightOfRow: Int) -&gt; CGFloat }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And “optional” disappears from the language. Now, there’s no<br>&gt;&gt; optionality left, so our useDelegate example tries to just do correct<br>&gt;&gt; calls:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func useDelegate(delegate: NSTableViewDelegate) -&gt; NSView? { let<br>&gt;&gt; view = delegate.tableView(tableView, viewFor: column, row: row) let<br>&gt;&gt; height = delegate.tableView(tableView, heightOfRow: row) }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Of course, the code above will fail if the actual delegate<br>&gt;&gt; doesn’t implement both methods. We need some kind of default<br>&gt;&gt; implementation to fall back on in that case. I propose that the code<br>&gt;&gt; above produce a compiler error on both lines *unless* there is a<br>&gt;&gt; “default implementation” visible. So, to make the code above compile<br>&gt;&gt; without error, one would have to add:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension NSTableViewDelegate { @nonobjc func tableView(_:<br>&gt;&gt; NSTableView, viewFor: NSTableColumn, row: Int) -&gt; NSView? { return nil<br>&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @nonobjc func tableView(_: NSTableView, heightOfRow: Int) -&gt;<br>&gt;&gt; CGFloat { return 17 } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now, the useDelegate example compiles. If the actual delegate<br>&gt;&gt; implements the optional requirement, we’ll use that<br>&gt;&gt; implementation. Otherwise, the caller will use the default<br>&gt;&gt; (Swift-only) implementation it sees. From an implementation<br>&gt;&gt; standpoint, the compiler would effectively produce the following for<br>&gt;&gt; the first of these calls:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if delegate.responds(to:<br>&gt;&gt; #selector(NSTableViewDelegate.tableView(_:viewFor:row:))) { // call<br>&gt;&gt; the @objc instance method with the selector<br>&gt;&gt; tableView:viewForTableColumn:row: } else { // call the Swift-only<br>&gt;&gt; implementation of tableView(_:viewFor:row:) in the protocol extension<br>&gt;&gt; above }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are a number of reasons why I like this approach:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) It eliminates the notion of ‘optional’ requirements from the<br>&gt;&gt; language. For classes that are adopting the NSTableViewDelegate<br>&gt;&gt; protocol, it is as if these requirements had default implementations.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) Only the callers to these requirements have to deal with the<br>&gt;&gt; lack<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of default implementations. This was already the case for<br>&gt;&gt; optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements, so it’s not an extra burden in principle, and it’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; generally going to be easier to write one defaulted<br>&gt;&gt; implementation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; than deal with it in several different places. Additionally,<br>&gt;&gt; most of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; these callers are probably in the Cocoa frameworks, not<br>&gt;&gt; application<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; code, so the overall impact should be small.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] How to eliminate &#39;optional&#39; protocol requirements</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 12, 2016, at 2:32 PM, Dietmar Planitzer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Inline.<br>&gt; <br>&gt;&gt; On Apr 11, 2016, at 10:03, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;dplanitzer-AT-q.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 10, 2016, at 11:46, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sun Apr 10 2016, Dietmar Planitzer &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure whether you’ve read the conclusion of my mail since<br>&gt;&gt;&gt;&gt;&gt; you’ve only commented on the introductory part. In the conclusion I<br>&gt;&gt;&gt;&gt;&gt; wrote that a possible approach for the replacement of ObjC-style<br>&gt;&gt;&gt;&gt;&gt; optional protocol methods would be:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) the default implementation of a protocol method must be defined<br>&gt;&gt;&gt; in<br>&gt;&gt;&gt;&gt;&gt; the protocol (so just like in native Swift protocols today).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ? They can and must be defined in protocol extensions today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2) we add a way for a protocol provider to check whether the<br>&gt;&gt;&gt; protocol<br>&gt;&gt;&gt;&gt;&gt; adopter has provided an “override” of the default method.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I object to this part.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You object why? I do understand why you object to the ObjC model since<br>&gt;&gt;&gt; there is not necessarily an implementation of the protocol method and<br>&gt;&gt;&gt; thus the protocol provider has to guard every call with an existence<br>&gt;&gt;&gt; check. But in this model here we would be guaranteed that there would<br>&gt;&gt;&gt; be an implementation of the protocol method and thus guarding the call<br>&gt;&gt;&gt; wouldn’t be necessary.<br>&gt;&gt; <br>&gt;&gt; Because it&#39;s a needless complication that will encourage protocol and<br>&gt;&gt; algorithm designers to create inefficient programs because they know the<br>&gt;&gt; user can fall back on this hack.<br>&gt; <br>&gt; It’s not clear why you think that the ability to check whether a protocol adopter implements a method or doesn’t would make programs inefficient. The fact that the protocol provider can check whether an adopter actually wants a feature or not (optional method is implemented -&gt; adopter wants the feature; otherwise he clearly doesn’t) is what enables us to create more efficient implementations.<br></p><p>Allowing a user of a protocol to dynamically check whether the type conforming to the protocol requests some bit of custom functionality allows fast paths for non-customized behavior. The primary mechanism for that check in Objective-C is -respondsToSelector:, but that does not imply that it is the right mechanism for Swift.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that has_override() is just a placeholder syntax because I’ve not<br>&gt;&gt;&gt; had a good idea yet of how to express this in a Swiftier way.<br>&gt;&gt; <br>&gt;&gt;  if delegate.hasVariableSizedRows { … }<br>&gt; <br>&gt; This means that we not only increase the surface of the API, it also means that we make it now possible for the protocol adopter to provide conflicting information to the caller of the protocol methods. At the same time, the caller of the protocol methods still needs to guard every call of tableView(heightForRow:) with a call to hasVariableSizedRows(). So by the end of the day, this solution doesn’t improve anything. It just adds new complexity and sources of bugs.<br></p><p>This particular API has been discussed numerous times. For example, here’s a potentially-more-Swifty approach to it:<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13608<br></p><p>The approach eliminates the coupling between, e.g., hasVariableSizedRows and heightForRow and makes it far more clear (IMO) that you’re choosing among several behaviors. <br></p><p>&gt; in ObjC is the idea that the NSTableView is a component which offers a set of features:<br>&gt; <br>&gt; - fixed row heights<br>&gt; - variable row heights<br>&gt; - drag &amp; drop<br>&gt; - old style pasteboard support<br>&gt; - new style pasteboard support<br>&gt; - old style table cells<br>&gt; - new style table cell views<br>&gt; - etc, pp<br></p><p>That’s a lot of disparate functionality in one very large protocol. Again, referring to the other thread, Brent started dividing this delegate into a number of related protocols:<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.evolution/13347/focus=13601<br></p><p><br></p><p>&gt; and then the delegate simply picks the features that it wants to use. It simply does this by implementing the corresponding methods and by NOT implementing the methods of a feature it doesn’t care about:<br>&gt; <br>&gt; - delegate wants feature X -&gt; implement the method for feature X<br>&gt; <br>&gt; - delegate does not want feature X -&gt; nothing to do<br>&gt; <br>&gt; and this is why the concept of optional protocol methods captures this idea precisely: I don’t need to write code for feature X if I don’t want it. Why should I write code for something I don’t want? Wouldn’t make sense.<br></p><p>Everything you say in the above snippet applies equally to default implementations of protocol members.<br></p><p>&gt;&gt;  if !(delegate is NSUniformTableViewDelegate) { … }<br>&gt; <br>&gt; I don’t think that replacing 1 protocol with a dozen or more protocols is a good idea or a step forward. Beside that we would actually have to introduce hundreds of new protocols since the optional protocol method feature is used all over the place in public Mac OS X frameworks and also in private ones.<br></p><p>I might agree with that statement, but the same complexity is there whether you split a large protocol into several related protocols or not: having multiple protocols merely acknowledges and groups that functionality in code rather than in documentation. Note how the documentation for NSTableViewDelegate has to be split into numerous groups of methods because it’s covering a number of different aspects of table views:<br></p><p>	https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSTableViewDelegate_Protocol/<br></p><p><br>&gt;&gt; etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this example the table view is able to check whether the protocol<br>&gt;&gt;&gt; adopter has actually “overriden” the default implementation of<br>&gt;&gt;&gt; tableView(_:, heightForRow:). <br>&gt;&gt; <br>&gt;&gt; Which, IMO, is a terrible way to indicate that a view has variable row<br>&gt;&gt; heights.  It&#39;s indirect and maybe even inaccurate (I can imagine a table<br>&gt;&gt; view that is uniform and has its height set up once at construction<br>&gt;&gt; time, therefore it needs to override heightForRow).<br>&gt; <br>&gt; I don’t see how it is indirect. I want the feature -&gt; I implement the corresponding method; I don’t want the feature -&gt; I don’t write code for it.<br></p><p>“I want the feature -&gt; I implement the corresponding protocol” is nearly identical, but ties the action specifically to a named entity in the language. It’s also how one *always* deals with protocols.<br></p><p>&gt; This captures exactly the nature of the problem and it really can’t get any simpler than that for the protocol user. <br></p><p>From the perspective of the person making their type conform to a protocol (what you’re calling a protocol “user”), there is absolutely no difference between “has a default implementation” and “is an optional requirement”.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/71af5b7c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
