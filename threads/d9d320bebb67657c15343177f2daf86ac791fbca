<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Allow optional binding of instance variables in constructors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 11, 2016 at 09:00:00am</p></header><div class="content"><p>One place where I find myself using the guard statement a lot is state initialisation. E.g. in init()<br></p><p>guard let<br>           device   = MTLCreateSystemDefaultDevice(),<br>           library  = device.newDefaultLibrary()<br>else {<br>   fatalError(“Could not initiallize Metal, aborting”)<br>}<br></p><p>Here, the two variables device and library are intended to be instance variables of an engine backbone system. However, because optional binding in guard can only introduce new local statements, one needs to add additional boilerplate in the end, e.g.:<br></p><p>self.device = device<br>self.library  = library<br></p><p>What I want to propose is a very simple QOL enhancement: allow optional binding to be used with instance variables in the constructors. If the binding fails, the instance construction cannot proceed (the relevant scope is the instance). The syntax would be <br></p><p>guard  device   = MTLCreateSystemDefaultDevice(),<br>           library  = device.newDefaultLibrary()<br>else {<br>   fatalError(“Could not initiallize Metal, aborting”) // or return nil<br>}<br></p><p><br>Few notes:<br></p><p>- This would only apply to guard statement, because binding in the if statement only applies to the internal if scope by definition<br>- One could also ask for instance optional binding in any context where instance assignment is legal. However, this would make guard inconsistent, as it won’t be able to prevent inconsistent state from being invisible to the app. Therefore its best to restrict this to cases where state is being constructed, and fail the construction if the guard fails (hence init() )<br></p><p>Best, <br></p><p> Taras<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Allow optional binding of instance variables in constructors</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 11, 2016 at 01:00:00am</p></header><div class="content"><p>Clarifying questions as comments:<br></p><p>    guard device = MTLCreateSystemDefaultDevice() else {<br>        fatalError()<br>    }<br>    device = nil   *// Is this still allowed here?*<br>    device.newDefaultLibrary()  *// Is this allowed without optional<br>chaining?*<br></p><p>Also, I don&#39;t see any reason this idea should be restricted to instance<br>variables. It could work for any variable, I think, but in any case it gets<br>tricky if the value is mutated again afterwards.<br></p><p>Jacob<br></p><p>On Mon, Apr 11, 2016 at 12:31 AM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One place where I find myself using the guard statement a lot is state<br>&gt; initialisation. E.g. in init()<br>&gt;<br>&gt; guard let<br>&gt;            device   = MTLCreateSystemDefaultDevice(),<br>&gt;            library  = device.newDefaultLibrary()<br>&gt; else {<br>&gt;    fatalError(“Could not initiallize Metal, aborting”)<br>&gt; }<br>&gt;<br>&gt; Here, the two variables device and library are intended to be instance<br>&gt; variables of an engine backbone system. However, because optional binding<br>&gt; in guard can only introduce new local statements, one needs to add<br>&gt; additional boilerplate in the end, e.g.:<br>&gt;<br>&gt; self.device = device<br>&gt; self.library  = library<br>&gt;<br>&gt; What I want to propose is a very simple QOL enhancement: allow optional<br>&gt; binding to be used with instance variables in the constructors. If the<br>&gt; binding fails, the instance construction cannot proceed (the relevant scope<br>&gt; is the instance). The syntax would be<br>&gt;<br>&gt; guard  device   = MTLCreateSystemDefaultDevice(),<br>&gt;            library  = device.newDefaultLibrary()<br>&gt; else {<br>&gt;    fatalError(“Could not initiallize Metal, aborting”) // or return nil<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Few notes:<br>&gt;<br>&gt; - This would only apply to guard statement, because binding in the if<br>&gt; statement only applies to the internal if scope by definition<br>&gt; - One could also ask for instance optional binding in any context where<br>&gt; instance assignment is legal. However, this would make guard inconsistent,<br>&gt; as it won’t be able to prevent inconsistent state from being invisible to<br>&gt; the app. Therefore its best to restrict this to cases where state is being<br>&gt; constructed, and fail the construction if the guard fails (hence init() )<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/b262ba95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Allow optional binding of instance variables in constructors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 11 Apr 2016, at 10:05, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Clarifying questions as comments:<br>&gt; <br>&gt;     guard device = MTLCreateSystemDefaultDevice() else {<br>&gt;         fatalError()<br>&gt;     }<br>&gt;     device = nil   // Is this still allowed here?<br></p><p>Device instance variable is not an optional — so, no. The entire point of this would be to init potentially failable substate without having to deal with forcibly unwrapped optionals or having guards every time when substate needs to be accessed etc. <br></p><p>&gt;     device.newDefaultLibrary()  // Is this allowed without optional chaining?<br></p><p>Sure<br></p><p>&gt; <br>&gt; Also, I don&#39;t see any reason this idea should be restricted to instance variables. It could work for any variable, I think, but in any case it gets tricky if the value is mutated again afterwards.<br></p><p>The problem as I see it is that guard enforces state consistency. If the guard fails, any code that access the guarded state becomes invalid. This is why guard else clause requires one to leave the enclosing scope — to ensure that the guarded variables cannot be accesses in valid code. If one extends the binding to other variables, one runs into the problem that these variables can be accessed from outside. This is why I am suggesting to restrict guard to constructors only and fail the object construction if the guard fails. <br></p><p>— Taras<br></p><p>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Mon, Apr 11, 2016 at 12:31 AM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; One place where I find myself using the guard statement a lot is state initialisation. E.g. in init()<br>&gt; <br>&gt; guard let<br>&gt;            device   = MTLCreateSystemDefaultDevice(),<br>&gt;            library  = device.newDefaultLibrary()<br>&gt; else {<br>&gt;    fatalError(“Could not initiallize Metal, aborting”)<br>&gt; }<br>&gt; <br>&gt; Here, the two variables device and library are intended to be instance variables of an engine backbone system. However, because optional binding in guard can only introduce new local statements, one needs to add additional boilerplate in the end, e.g.:<br>&gt; <br>&gt; self.device = device<br>&gt; self.library  = library<br>&gt; <br>&gt; What I want to propose is a very simple QOL enhancement: allow optional binding to be used with instance variables in the constructors. If the binding fails, the instance construction cannot proceed (the relevant scope is the instance). The syntax would be<br>&gt; <br>&gt; guard  device   = MTLCreateSystemDefaultDevice(),<br>&gt;            library  = device.newDefaultLibrary()<br>&gt; else {<br>&gt;    fatalError(“Could not initiallize Metal, aborting”) // or return nil<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Few notes:<br>&gt; <br>&gt; - This would only apply to guard statement, because binding in the if statement only applies to the internal if scope by definition<br>&gt; - One could also ask for instance optional binding in any context where instance assignment is legal. However, this would make guard inconsistent, as it won’t be able to prevent inconsistent state from being invisible to the app. Therefore its best to restrict this to cases where state is being constructed, and fail the construction if the guard fails (hence init() )<br>&gt; <br>&gt; Best,<br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/1957bf6b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
