<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Optional values pervade Swift code and so there is a significant part of the language dedicated to manipulating them and using them safely.  An optional value may be conditionally let-bound, guarded, pattern-matched on, given a default value with ??, or used with higher-order functions like map and flatMap without having to interact with partiality.  A corner case, however, remains in the form of the postfix-! force-unwrap operator.  At the term level, there is little reason to unwrap given the syntactic constructs above, and indeed code that does becomes brittle and, by its very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping an optional value&quot; error (our very own NullPointerException).  In addition, bang is incredibly hard to spot in code bases that use it because it blends in with Boolean negation (which, in itself, is notoriously hard to spot in other C-like-languages), harming readability and making code review more difficult.  Finally, if the authors of a piece of code have such confidence in the existence of a value that they feel it safe to use force unwrapping, they should simply use a non-optional value and cut out a level of indirection and avoid the dangers of bang in the first place. <br></p><p>Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br></p><p>Thanks all,<br></p><p>~Robert Widmann<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85f69dcee523ea5b90eb4ca8e6751c6a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Andrew Clissold</string> &lt;andrewclissold at gmail.com&gt;<p>February 28, 2016 at 06:00:00pm</p></header><div class="content"><p>I absolutely agree that force-unwrapping is ugly and dangerous, but I think it&#39;s still strongly needed for convenience when working with Objective-C APIs that haven&#39;t been audited for nullability. Of which there are still a very large amount :)<br></p><p>No new Swift code should make use of force unwrapping, but that should remain a developer convention rather than a compiler requirement for the time being.<br></p><p>Andrew<br></p><p>&gt; On Feb 28, 2016, at 11:53 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Optional values pervade Swift code and so there is a significant part of the language dedicated to manipulating them and using them safely.  An optional value may be conditionally let-bound, guarded, pattern-matched on, given a default value with ??, or used with higher-order functions like map and flatMap without having to interact with partiality.  A corner case, however, remains in the form of the postfix-! force-unwrap operator.  At the term level, there is little reason to unwrap given the syntactic constructs above, and indeed code that does becomes brittle and, by its very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping an optional value&quot; error (our very own NullPointerException).  In addition, bang is incredibly hard to spot in code bases that use it because it blends in with Boolean negation (which, in itself, is notoriously hard to spot in other C-like-languages), harming readability and making code review more difficult.  Finally, if the authors of a piece of code have such confidence in the existence of a value that they feel it safe to use force unwrapping, they should simply use a non-optional value and cut out a level of indirection and avoid the dangers of bang in the first place. <br>&gt; <br>&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; Thanks all,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 29, 2016 at 08:00:00am</p></header><div class="content"><p>There are some cases where it’s still very useful even in pure Swift code. For example, say I have an array of optional values, and want to trip nils, then perform a transform on the result, I would do something like:<br></p><p>	let theResult = myArrayOfOptions.filter({ $0 != nil }).map({ doSomethingTo($0!) })<br></p><p>I could use if let inside the second closure, but it’d be messy; in fact, both that and using the ?? operator would require me to provide some kind of default, which isn’t possible if I have elements of arbitrary type. I could create a removeNils() method that returns a non-optional array (or lazy collection) but I’m not actually sure how to do that, and it’d definitely be more work than just using the exclamation point to tell the compiler “actually there are no optionals left at this point”.<br></p><p>&gt; On 29 Feb 2016, at 02:54, Andrew Clissold via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I absolutely agree that force-unwrapping is ugly and dangerous, but I think it&#39;s still strongly needed for convenience when working with Objective-C APIs that haven&#39;t been audited for nullability. Of which there are still a very large amount :)<br>&gt; <br>&gt; No new Swift code should make use of force unwrapping, but that should remain a developer convention rather than a compiler requirement for the time being.<br>&gt; <br>&gt; Andrew<br>&gt; <br>&gt;&gt; On Feb 28, 2016, at 11:53 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Optional values pervade Swift code and so there is a significant part of the language dedicated to manipulating them and using them safely.  An optional value may be conditionally let-bound, guarded, pattern-matched on, given a default value with ??, or used with higher-order functions like map and flatMap without having to interact with partiality.  A corner case, however, remains in the form of the postfix-! force-unwrap operator.  At the term level, there is little reason to unwrap given the syntactic constructs above, and indeed code that does becomes brittle and, by its very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping an optional value&quot; error (our very own NullPointerException).  In addition, bang is incredibly hard to spot in code bases that use it because it blends in with Boolean negation (which, in itself, is notoriously hard to spot in other C-like-languages), harming readability and making code review more difficult.  Finally, if the authors of a piece of code have such confidence in the existence of a value that they feel it safe to use force unwrapping, they should simply use a non-optional value and cut out a level of indirection and avoid the dangers of bang in the first place. <br>&gt;&gt; <br>&gt;&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February 29, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 2:33 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There are some cases where it’s still very useful even in pure Swift code. For example, say I have an array of optional values, and want to trip nils, then perform a transform on the result, I would do something like:<br>&gt; <br>&gt; 	let theResult = myArrayOfOptions.filter({ $0 != nil }).map({ doSomethingTo($0!) })<br></p><p>Not that I disagree that force-unwrapping is sometimes necessary (especially when working with Cocoa idioms that pretty much require it, such as NSDocument and anything involving NIB outlets), but for this particular example, you can just use flatMap to do this:<br></p><p>let theResult = myArrayOfOptions.flatMap { $0 }.map { doSomethingTo($0) }<br></p><p>You could even combine the two into one flatMap with a nil test in it, although it ends up looking pretty ugly (but should perform better).<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/a37b387d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 29, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br></p><p>I could not disagree more strongly.<br></p><p>Swift takes the position that assertions are good and that it&#39;s better to crash in an unexpected state than to limp on. Force unwrapping is an example of that philosophy. A force unwrap is a &quot;this is not nil&quot; assertion.<br></p><p>That assertion often is not appropriate—namely, in code that tests for `nil`—and so we provide, by my count, five general ways to test-and-use nils (pattern matching, optional binding, optional chaining, defaulting, and mapping) without force unwrapping. These features are all great and, with *very* few exceptions, you should always use one of them rather than test-and-force-unwrap.<br></p><p>But where it *is* appropriate to assert non-nil, *we want you to force unwrap*. If, as you write your code, you are certain a value cannot be nil, we want your code to say so. That way, the code will crash if you&#39;re wrong, at the exact point where you made the mistake, where the problem will be easiest to diagnose. We do *not* want you to use a test-and-use construct in a place where you believe the test will always succeed, because you will probably not give any particular attention to the test-failed behavior, so it will probably be wrong.<br></p><p>In other words, making force unwrapping more difficult will not make people correctly handle unexpected nils—it will make them write code that *undetectably* does the wrong thing by skipping code that wasn&#39;t actually meant to be skipped. You&#39;ll see fewer crashes but more bugs. That runs counter to Swift&#39;s formulation of safety, and I think it would be a serious mistake.<br></p><p>I recently had the pleasure of debugging some force unwrap crashes in a view controller I hadn&#39;t touched in a while. The force unwraps I used very quickly demonstrated to me that my ideas about the code&#39;s lifecycle were wrong: for instance, I thought it would never be called before a certain property was set, but it turned out it sometimes was. If I had used a conditional construct without thinking through the consequences, that would have manifested as a mysteriously empty menu which I would have had trouble debugging. By stating explicitly in my code that I believed those values could not be nil, Swift quickly disproved my belief, showed me exactly what was wrong, and prompted me to correct it. That&#39;s the best thing it could have done for me in this situation.<br></p><p>I often see Swift style guides suggest that force-unwrapping is a strong code smell and should always be avoided, but I think that&#39;s wrongheaded. Test-and-force-unwrap *is* a code smell, and force-unwrap-when-you&#39;re-not-really-sure is incorrect too. But when you *are* sure, force unwrap is the very best way to write your code, because it will make any mistakes immediately obvious.<br></p><p>That&#39;s a feature, not a bug.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>February 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 29 Feb 2016, at 10:40, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.<br>&gt; <br>&gt; I could not disagree more strongly.<br>&gt; <br>&gt; Swift takes the position that assertions are good and that it&#39;s better to crash in an unexpected state than to limp on. Force unwrapping is an example of that philosophy. A force unwrap is a &quot;this is not nil&quot; assertion.<br></p><p><br>+(0.5 + 0.5). I think both of you have a point.<br></p><p>To me, even after soon two years of Swift, it&#39;s still extremely hard to visually see where forced unwrapping happens. I do not think we should recommend unsafeUnwrap though because we&#39;d then trade a guaranteed crash for undefined behaviour on nil, which is definitely the wrong choice at least 95% of time.<br></p><p>Unless we&#39;re getting an option in Xcode to make the exclamation point U+0021 render as something like ❗️ (U+2757 U+FE0F), I think it would be more sensible to rather have a standard member function on Optional that does the same but more explicitly:<br></p><p>extension Optional {<br>  func unwrap() -&gt; Wrapped {<br>    guard let value = self else {<br>      fatalError(&quot;unexpectedly found nil where unwrapping an \(Optional.self) value&quot;)<br>    }<br>    return value<br>  }<br>}<br></p><p>var x: String?<br>if x != nil { print(x.unwrap()) }<br></p><p>Indeed, with Optional.unwrap as a member function, we could even report where the assertion failed, which could be a big help when debugging errors that slipped into production:<br></p><p>extension Optional {<br>  func unwrap(file file: StaticString = #file, line: UInt = #line) -&gt; Wrapped { ... }<br>}<br></p><p>print(x.unwrap())<br>fatal error: unexpectedly found nil where unwrapping an Optional&lt;String&gt; value: file /path/to/endless/swift-evolution/this-email-message.swift, line 36<br></p><p>There could be compiler magic to replace calls to Optional.unwrap with unsafeUnwrap in -Ounchecked builds.<br></p><p>Naming alternatives considered: forceUnwrap, forcedUnwrap, unwrapValue, assertUnwrap.<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/42f4241e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 4:26 AM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To me, even after soon two years of Swift, it&#39;s still extremely hard to visually see where forced unwrapping happens. I do not think we should recommend unsafeUnwrap though because we&#39;d then trade a guaranteed crash for undefined behaviour on nil, which is definitely the wrong choice at least 95% of time.<br>&gt; <br>&gt; <br></p><p>For starters, the interface builder generates code that uses forced unwrapping.<br></p><p>-Patrick<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/11b7ada2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 08:00:00am</p></header><div class="content"><p>That&#39;s certainly an interesting stance to take on the issue.  I recently went through a rather large refactoring myself involving mechanically-ported code that had hundreds of force-unwraps left over from Objective-C.  It delighted me to no end to spend days removing them and refactoring the code.  To my mind, each represented an opportunity to explore an alternative means of expressing something very old hat because I would rather not deal with partiality in any way, shape, or form if I didn&#39;t have to.  In the end, it was a tough refactoring job because ! was so hard to spot and was a pain to wrestle out of the codebase in some spots.  By the time I merged, there were still spots where it was necessary to use !, but I ended up removing and refactoring hundreds of instances of improperly applied &quot;assumptions&quot; about my code.  Bang, as you said, showed me these cases as false preconditions, but I guess I can&#39;t understand why that would be a desirable feature when compared to simply writing the code with other primitives I listed.  Especially because I was working with a library written entirely with objects, what &quot;assertions&quot; we&#39;re left still make me incredibly uneasy.<br></p><p>Yes, occasionally you will get cleaner code just making the assertion that something is non-nil, but does that occasion necessitate language-level syntax rather than a stdlib function?  Why not have an unwrap function over an unwrap language feature [because surely the wide range of assertion operators already present in stdlib could use a new counterpart]?<br></p><p>~Robert Widmann<br></p><p>2016/02/29 3:40、Brent Royal-Gordon &lt;brent at architechies.com&gt; のメッセージ:<br></p><p>&gt;&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; I could not disagree more strongly.<br>&gt; <br>&gt; Swift takes the position that assertions are good and that it&#39;s better to crash in an unexpected state than to limp on. Force unwrapping is an example of that philosophy. A force unwrap is a &quot;this is not nil&quot; assertion.<br>&gt; <br>&gt; That assertion often is not appropriate―namely, in code that tests for `nil`―and so we provide, by my count, five general ways to test-and-use nils (pattern matching, optional binding, optional chaining, defaulting, and mapping) without force unwrapping. These features are all great and, with *very* few exceptions, you should always use one of them rather than test-and-force-unwrap.<br>&gt; <br>&gt; But where it *is* appropriate to assert non-nil, *we want you to force unwrap*. If, as you write your code, you are certain a value cannot be nil, we want your code to say so. That way, the code will crash if you&#39;re wrong, at the exact point where you made the mistake, where the problem will be easiest to diagnose. We do *not* want you to use a test-and-use construct in a place where you believe the test will always succeed, because you will probably not give any particular attention to the test-failed behavior, so it will probably be wrong.<br>&gt; <br>&gt; In other words, making force unwrapping more difficult will not make people correctly handle unexpected nils―it will make them write code that *undetectably* does the wrong thing by skipping code that wasn&#39;t actually meant to be skipped. You&#39;ll see fewer crashes but more bugs. That runs counter to Swift&#39;s formulation of safety, and I think it would be a serious mistake.<br>&gt; <br>&gt; I recently had the pleasure of debugging some force unwrap crashes in a view controller I hadn&#39;t touched in a while. The force unwraps I used very quickly demonstrated to me that my ideas about the code&#39;s lifecycle were wrong: for instance, I thought it would never be called before a certain property was set, but it turned out it sometimes was. If I had used a conditional construct without thinking through the consequences, that would have manifested as a mysteriously empty menu which I would have had trouble debugging. By stating explicitly in my code that I believed those values could not be nil, Swift quickly disproved my belief, showed me exactly what was wrong, and prompted me to correct it. That&#39;s the best thing it could have done for me in this situation.<br>&gt; <br>&gt; I often see Swift style guides suggest that force-unwrapping is a strong code smell and should always be avoided, but I think that&#39;s wrongheaded. Test-and-force-unwrap *is* a code smell, and force-unwrap-when-you&#39;re-not-really-sure is incorrect too. But when you *are* sure, force unwrap is the very best way to write your code, because it will make any mistakes immediately obvious.<br>&gt; <br>&gt; That&#39;s a feature, not a bug.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 29, 2016 at 03:00:00pm</p></header><div class="content"><p>I agree with Brent&#39;s position on this. Simply put, there are use cases that forced unwrapping is necessary.<br></p><p>-Patrick<br></p><p>&gt; On Feb 29, 2016, at 3:40 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; I could not disagree more strongly.<br>&gt; <br>&gt; Swift takes the position that assertions are good and that it&#39;s better to crash in an unexpected state than to limp on. Force unwrapping is an example of that philosophy. A force unwrap is a &quot;this is not nil&quot; assertion.<br>&gt; <br>&gt; That assertion often is not appropriate—namely, in code that tests for `nil`—and so we provide, by my count, five general ways to test-and-use nils (pattern matching, optional binding, optional chaining, defaulting, and mapping) without force unwrapping. These features are all great and, with *very* few exceptions, you should always use one of them rather than test-and-force-unwrap.<br>&gt; <br>&gt; But where it *is* appropriate to assert non-nil, *we want you to force unwrap*. If, as you write your code, you are certain a value cannot be nil, we want your code to say so. That way, the code will crash if you&#39;re wrong, at the exact point where you made the mistake, where the problem will be easiest to diagnose. We do *not* want you to use a test-and-use construct in a place where you believe the test will always succeed, because you will probably not give any particular attention to the test-failed behavior, so it will probably be wrong.<br>&gt; <br>&gt; In other words, making force unwrapping more difficult will not make people correctly handle unexpected nils—it will make them write code that *undetectably* does the wrong thing by skipping code that wasn&#39;t actually meant to be skipped. You&#39;ll see fewer crashes but more bugs. That runs counter to Swift&#39;s formulation of safety, and I think it would be a serious mistake.<br>&gt; <br>&gt; I recently had the pleasure of debugging some force unwrap crashes in a view controller I hadn&#39;t touched in a while. The force unwraps I used very quickly demonstrated to me that my ideas about the code&#39;s lifecycle were wrong: for instance, I thought it would never be called before a certain property was set, but it turned out it sometimes was. If I had used a conditional construct without thinking through the consequences, that would have manifested as a mysteriously empty menu which I would have had trouble debugging. By stating explicitly in my code that I believed those values could not be nil, Swift quickly disproved my belief, showed me exactly what was wrong, and prompted me to correct it. That&#39;s the best thing it could have done for me in this situation.<br>&gt; <br>&gt; I often see Swift style guides suggest that force-unwrapping is a strong code smell and should always be avoided, but I think that&#39;s wrongheaded. Test-and-force-unwrap *is* a code smell, and force-unwrap-when-you&#39;re-not-really-sure is incorrect too. But when you *are* sure, force unwrap is the very best way to write your code, because it will make any mistakes immediately obvious.<br>&gt; <br>&gt; That&#39;s a feature, not a bug.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 29, 2016 at 01:00:00pm</p></header><div class="content"><p>-1<br></p><p>One word: Playgrounds<br></p><p>-- E<br></p><p>&gt; On Feb 29, 2016, at 1:01 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with Brent&#39;s position on this. Simply put, there are use cases that forced unwrapping is necessary.<br>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 29, 2016, at 3:40 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt;&gt; <br>&gt;&gt; I could not disagree more strongly.<br>&gt;&gt; <br>&gt;&gt; Swift takes the position that assertions are good and that it&#39;s better to crash in an unexpected state than to limp on. Force unwrapping is an example of that philosophy. A force unwrap is a &quot;this is not nil&quot; assertion.<br>&gt;&gt; <br>&gt;&gt; That assertion often is not appropriate—namely, in code that tests for `nil`—and so we provide, by my count, five general ways to test-and-use nils (pattern matching, optional binding, optional chaining, defaulting, and mapping) without force unwrapping. These features are all great and, with *very* few exceptions, you should always use one of them rather than test-and-force-unwrap.<br>&gt;&gt; <br>&gt;&gt; But where it *is* appropriate to assert non-nil, *we want you to force unwrap*. If, as you write your code, you are certain a value cannot be nil, we want your code to say so. That way, the code will crash if you&#39;re wrong, at the exact point where you made the mistake, where the problem will be easiest to diagnose. We do *not* want you to use a test-and-use construct in a place where you believe the test will always succeed, because you will probably not give any particular attention to the test-failed behavior, so it will probably be wrong.<br>&gt;&gt; <br>&gt;&gt; In other words, making force unwrapping more difficult will not make people correctly handle unexpected nils—it will make them write code that *undetectably* does the wrong thing by skipping code that wasn&#39;t actually meant to be skipped. You&#39;ll see fewer crashes but more bugs. That runs counter to Swift&#39;s formulation of safety, and I think it would be a serious mistake.<br>&gt;&gt; <br>&gt;&gt; I recently had the pleasure of debugging some force unwrap crashes in a view controller I hadn&#39;t touched in a while. The force unwraps I used very quickly demonstrated to me that my ideas about the code&#39;s lifecycle were wrong: for instance, I thought it would never be called before a certain property was set, but it turned out it sometimes was. If I had used a conditional construct without thinking through the consequences, that would have manifested as a mysteriously empty menu which I would have had trouble debugging. By stating explicitly in my code that I believed those values could not be nil, Swift quickly disproved my belief, showed me exactly what was wrong, and prompted me to correct it. That&#39;s the best thing it could have done for me in this situation.<br>&gt;&gt; <br>&gt;&gt; I often see Swift style guides suggest that force-unwrapping is a strong code smell and should always be avoided, but I think that&#39;s wrongheaded. Test-and-force-unwrap *is* a code smell, and force-unwrap-when-you&#39;re-not-really-sure is incorrect too. But when you *are* sure, force unwrap is the very best way to write your code, because it will make any mistakes immediately obvious.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a feature, not a bug.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 03:00:00pm</p></header><div class="content"><p>And for those cases there will be a standard library function or something more obvious than bang to make up for the deprecated operator.  Force unwrapping will not go away (that&#39;s a terribly unproductive idea), but the goal is to make a dangerous operation more obvious[ly dangerous].  <br></p><p>~Robert Widmann<br></p><p>2016/02/29 15:01、Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; のメッセージ:<br></p><p>&gt; I agree with Brent&#39;s position on this. Simply put, there are use cases that forced unwrapping is necessary.<br>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt;&gt; On Feb 29, 2016, at 3:40 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt;&gt; <br>&gt;&gt; I could not disagree more strongly.<br>&gt;&gt; <br>&gt;&gt; Swift takes the position that assertions are good and that it&#39;s better to crash in an unexpected state than to limp on. Force unwrapping is an example of that philosophy. A force unwrap is a &quot;this is not nil&quot; assertion.<br>&gt;&gt; <br>&gt;&gt; That assertion often is not appropriate―namely, in code that tests for `nil`―and so we provide, by my count, five general ways to test-and-use nils (pattern matching, optional binding, optional chaining, defaulting, and mapping) without force unwrapping. These features are all great and, with *very* few exceptions, you should always use one of them rather than test-and-force-unwrap.<br>&gt;&gt; <br>&gt;&gt; But where it *is* appropriate to assert non-nil, *we want you to force unwrap*. If, as you write your code, you are certain a value cannot be nil, we want your code to say so. That way, the code will crash if you&#39;re wrong, at the exact point where you made the mistake, where the problem will be easiest to diagnose. We do *not* want you to use a test-and-use construct in a place where you believe the test will always succeed, because you will probably not give any particular attention to the test-failed behavior, so it will probably be wrong.<br>&gt;&gt; <br>&gt;&gt; In other words, making force unwrapping more difficult will not make people correctly handle unexpected nils―it will make them write code that *undetectably* does the wrong thing by skipping code that wasn&#39;t actually meant to be skipped. You&#39;ll see fewer crashes but more bugs. That runs counter to Swift&#39;s formulation of safety, and I think it would be a serious mistake.<br>&gt;&gt; <br>&gt;&gt; I recently had the pleasure of debugging some force unwrap crashes in a view controller I hadn&#39;t touched in a while. The force unwraps I used very quickly demonstrated to me that my ideas about the code&#39;s lifecycle were wrong: for instance, I thought it would never be called before a certain property was set, but it turned out it sometimes was. If I had used a conditional construct without thinking through the consequences, that would have manifested as a mysteriously empty menu which I would have had trouble debugging. By stating explicitly in my code that I believed those values could not be nil, Swift quickly disproved my belief, showed me exactly what was wrong, and prompted me to correct it. That&#39;s the best thing it could have done for me in this situation.<br>&gt;&gt; <br>&gt;&gt; I often see Swift style guides suggest that force-unwrapping is a strong code smell and should always be avoided, but I think that&#39;s wrongheaded. Test-and-force-unwrap *is* a code smell, and force-unwrap-when-you&#39;re-not-really-sure is incorrect too. But when you *are* sure, force unwrap is the very best way to write your code, because it will make any mistakes immediately obvious.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a feature, not a bug.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 2:24 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And for those cases there will be a standard library function or something more obvious than bang to make up for the deprecated operator.  Force unwrapping will not go away (that&#39;s a terribly unproductive idea), but the goal is to make a dangerous operation more obvious[ly dangerous].  <br></p><p>Like this?<br>enum OptionalUnwrappingError : ErrorType {<br>    case unexpectedlyFoundNil<br>}<br>enum Optional&lt;T&gt; {<br>    typealias Wrapped = T<br>    case None<br>    case Some(Wrapped)<br>    ...<br>    func unwrap() throws -&gt; Wrapped {<br>        switch self {<br>        case .None: throw OptionalError.unexpectedlyFoundNil<br>        case .Some(let value): return value<br>        }<br>    }<br>}<br></p><p>It’s hard to get more obvious than the compiler complaining that you haven’t wrapped a throwing function in a try block<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/25fc1c0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 04:00:00pm</p></header><div class="content"><p>I was thinking something more like<br></p><p>func unsafeUnwrap&lt;T&gt;(opt : Optional&lt;T&gt;) -&gt; T {<br>    switch opt {<br>        case let .Some(val):<br>            return val<br>        default:<br>             fatalError(&quot;Unexpectedly found nil while unwrapping optional value&quot;)<br>    }<br>}<br></p><p>Bang doesn&#39;t go away, it just becomes more obvious that you&#39;re making a leap of logic (as it were).<br></p><p>~Robert Widmann<br></p><p>2016/02/29 15:59、davesweeris at mac.com のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Feb 29, 2016, at 2:24 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And for those cases there will be a standard library function or something more obvious than bang to make up for the deprecated operator.  Force unwrapping will not go away (that&#39;s a terribly unproductive idea), but the goal is to make a dangerous operation more obvious[ly dangerous].  <br>&gt; <br>&gt; Like this?<br>&gt; enum OptionalUnwrappingError : ErrorType {<br>&gt;     case unexpectedlyFoundNil<br>&gt; }<br>&gt; enum Optional&lt;T&gt; {<br>&gt;     typealias Wrapped = T<br>&gt;     case None<br>&gt;     case Some(Wrapped)<br>&gt;     ...<br>&gt;     func unwrap() throws -&gt; Wrapped {<br>&gt;         switch self {<br>&gt;         case .None: throw OptionalError.unexpectedlyFoundNil<br>&gt;         case .Some(let value): return value<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; It’s hard to get more obvious than the compiler complaining that you haven’t wrapped a throwing function in a try block<br>&gt; <br>&gt; - Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/31aebdbb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February 29, 2016 at 02:00:00pm</p></header><div class="content"><p>unsafeUnwrap already exists, though with a slightly different meaning (no<br>check is performed in -O builds).  I think it may be turning into an<br>&quot;unsafelyUnwrapped&quot; property in the future.<br></p><p>Generally I&#39;m +1 on this. I do share others&#39; concerns about things like<br>playgrounds and xibs.<br></p><p>I suppose the existence of xibs requires us to keep the<br>ImplicitlyUnwrappedOptional type if we don&#39;t want to require people use &quot;if<br>let&quot; *everywhere*, unless we somehow move the setting of IBOutlets into a<br>special throwing initializer.<br></p><p>For writing quick code in playgrounds, something like &quot;.unsafelyUnwrapped&quot;<br>is probably fine, if a bit wordy. Or if, as Dave Sweeris suggests, you make<br>&quot;unwrap() throws&quot;, then playgrounds can just use &quot;try! x.unwrap()&quot; for<br>unwrapping. (Or did you want to propose removing try! too?)<br></p><p>Jacob<br></p><p>On Mon, Feb 29, 2016 at 1:26 PM, Developer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I was thinking something more like<br>&gt;<br>&gt; func unsafeUnwrap&lt;T&gt;(opt : Optional&lt;T&gt;) -&gt; T {<br>&gt;     switch opt {<br>&gt;         case let .Some(val):<br>&gt;             return val<br>&gt;         default:<br>&gt;              fatalError(&quot;Unexpectedly found nil while unwrapping optional<br>&gt; value&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Bang doesn&#39;t go away, it just becomes more obvious that you&#39;re making a<br>&gt; leap of logic (as it were).<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/02/29 15:59、davesweeris at mac.com のメッセージ:<br>&gt;<br>&gt;<br>&gt; On Feb 29, 2016, at 2:24 PM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; And for those cases there will be a standard library function or something<br>&gt; more obvious than bang to make up for the deprecated operator.  Force<br>&gt; unwrapping will not go away (that&#39;s a terribly unproductive idea), but the<br>&gt; goal is to make a dangerous operation more obvious[ly dangerous].<br>&gt;<br>&gt;<br>&gt; Like this?<br>&gt; enum OptionalUnwrappingError : ErrorType {<br>&gt;     case unexpectedlyFoundNil<br>&gt; }<br>&gt; enum Optional&lt;T&gt; {<br>&gt;     typealias Wrapped = T<br>&gt;     case None<br>&gt;     case Some(Wrapped)<br>&gt;     ...<br>&gt;     func unwrap() throws -&gt; Wrapped {<br>&gt;         switch self {<br>&gt;         case .None: throw OptionalError.unexpectedlyFoundNil<br>&gt;         case .Some(let value): return value<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; It’s hard to get more obvious than the compiler complaining that you<br>&gt; haven’t wrapped a throwing function in a try block<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/11a44b2a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47dd6e088b6ba4fb06a7030dda8b7122?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>marc hoffman</string> &lt;mh at remobjects.com&gt;<p>March  2, 2016 at 07:00:00am</p></header><div class="content"><p>This!<br></p><p>&gt; On Feb 29, 2016, at 4:40 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; I could not disagree more strongly.<br>&gt; <br>&gt; Swift takes the position that assertions are good and that it&#39;s better to crash in an unexpected state than to limp on. Force unwrapping is an example of that philosophy. A force unwrap is a &quot;this is not nil&quot; assertion.<br>&gt; <br>&gt; That assertion often is not appropriate—namely, in code that tests for `nil`—and so we provide, by my count, five general ways to test-and-use nils (pattern matching, optional binding, optional chaining, defaulting, and mapping) without force unwrapping. These features are all great and, with *very* few exceptions, you should always use one of them rather than test-and-force-unwrap.<br>&gt; <br>&gt; But where it *is* appropriate to assert non-nil, *we want you to force unwrap*. If, as you write your code, you are certain a value cannot be nil, we want your code to say so. That way, the code will crash if you&#39;re wrong, at the exact point where you made the mistake, where the problem will be easiest to diagnose. We do *not* want you to use a test-and-use construct in a place where you believe the test will always succeed, because you will probably not give any particular attention to the test-failed behavior, so it will probably be wrong.<br>&gt; <br>&gt; In other words, making force unwrapping more difficult will not make people correctly handle unexpected nils—it will make them write code that *undetectably* does the wrong thing by skipping code that wasn&#39;t actually meant to be skipped. You&#39;ll see fewer crashes but more bugs. That runs counter to Swift&#39;s formulation of safety, and I think it would be a serious mistake.<br>&gt; <br>&gt; I recently had the pleasure of debugging some force unwrap crashes in a view controller I hadn&#39;t touched in a while. The force unwraps I used very quickly demonstrated to me that my ideas about the code&#39;s lifecycle were wrong: for instance, I thought it would never be called before a certain property was set, but it turned out it sometimes was. If I had used a conditional construct without thinking through the consequences, that would have manifested as a mysteriously empty menu which I would have had trouble debugging. By stating explicitly in my code that I believed those values could not be nil, Swift quickly disproved my belief, showed me exactly what was wrong, and prompted me to correct it. That&#39;s the best thing it could have done for me in this situation.<br>&gt; <br>&gt; I often see Swift style guides suggest that force-unwrapping is a strong code smell and should always be avoided, but I think that&#39;s wrongheaded. Test-and-force-unwrap *is* a code smell, and force-unwrap-when-you&#39;re-not-really-sure is incorrect too. But when you *are* sure, force unwrap is the very best way to write your code, because it will make any mistakes immediately obvious.<br>&gt; <br>&gt; That&#39;s a feature, not a bug.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>February 29, 2016 at 10:00:00am</p></header><div class="content"><p>As you point out there are there are circumstances where force unwrapping is required. Off the top of my head:<br></p><p>1) Implementation of flatMap and other similar safe functions requires it or similar.<br>2) Performance - in hot loops the conditionality may be a real performance penalty and other checks or outside knowledge may let you know that it is safe. <br>3) Some people prefer to assert and crash in production and this is a valid option. <br></p><p>Personally I only use the force unwrapping in test code where crashes are just untidy failures if they fail. <br></p><p>If it is removed from the stdlib it could be implemented as a custom operator by those that want it but there would be a performance hit for calls from other modules as I don&#39;t think it could currently be inlined. <br></p><p>I&#39;m fairly neutral about whether this happens.<br></p><p>Joseph<br></p><p>&gt; On Feb 28, 2016, at 7:53 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Optional values pervade Swift code and so there is a significant part of the language dedicated to manipulating them and using them safely.  An optional value may be conditionally let-bound, guarded, pattern-matched on, given a default value with ??, or used with higher-order functions like map and flatMap without having to interact with partiality.  A corner case, however, remains in the form of the postfix-! force-unwrap operator.  At the term level, there is little reason to unwrap given the syntactic constructs above, and indeed code that does becomes brittle and, by its very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping an optional value&quot; error (our very own NullPointerException).  In addition, bang is incredibly hard to spot in code bases that use it because it blends in with Boolean negation (which, in itself, is notoriously hard to spot in other C-like-languages), harming readability and making code review more difficult.  Finally, if the authors of a piece of code have such confidence in the existence of a value that they feel it safe to use force unwrapping, they should simply use a non-optional value and cut out a level of indirection and avoid the dangers of bang in the first place. <br>&gt; <br>&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; Thanks all,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1faea18be9eb2d50c4edcd223f2d685?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Seth Friedman</string> &lt;sethfri at gmail.com&gt;<p>February 29, 2016 at 11:00:00am</p></header><div class="content"><p>I think Brent beautifully captured opinions I share on force unwrapping. It<br>has proven useful time and time again in helping me identify incorrect<br>assumptions I&#39;ve made.<br></p><p>Strong -1 to this proposal<br></p><p>Thanks,<br>Seth<br>On Mon, Feb 29, 2016 at 2:43 AM Joseph Lord via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As you point out there are there are circumstances where force unwrapping<br>&gt; is required. Off the top of my head:<br>&gt;<br>&gt; 1) Implementation of flatMap and other similar safe functions requires it<br>&gt; or similar.<br>&gt; 2) Performance - in hot loops the conditionality may be a real performance<br>&gt; penalty and other checks or outside knowledge may let you know that it is<br>&gt; safe.<br>&gt; 3) Some people prefer to assert and crash in production and this is a<br>&gt; valid option.<br>&gt;<br>&gt; Personally I only use the force unwrapping in test code where crashes are<br>&gt; just untidy failures if they fail.<br>&gt;<br>&gt; If it is removed from the stdlib it could be implemented as a custom<br>&gt; operator by those that want it but there would be a performance hit for<br>&gt; calls from other modules as I don&#39;t think it could currently be inlined.<br>&gt;<br>&gt; I&#39;m fairly neutral about whether this happens.<br>&gt;<br>&gt; Joseph<br>&gt;<br>&gt; &gt; On Feb 28, 2016, at 7:53 PM, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Optional values pervade Swift code and so there is a significant part of<br>&gt; the language dedicated to manipulating them and using them safely.  An<br>&gt; optional value may be conditionally let-bound, guarded, pattern-matched on,<br>&gt; given a default value with ??, or used with higher-order functions like map<br>&gt; and flatMap without having to interact with partiality.  A corner case,<br>&gt; however, remains in the form of the postfix-! force-unwrap operator.  At<br>&gt; the term level, there is little reason to unwrap given the syntactic<br>&gt; constructs above, and indeed code that does becomes brittle and, by its<br>&gt; very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping<br>&gt; an optional value&quot; error (our very own NullPointerException).  In addition,<br>&gt; bang is incredibly hard to spot in code bases that use it because it blends<br>&gt; in with Boolean negation (which, in itself, is notoriously hard to spot in<br>&gt; other C-like-languages), harming readability and making code review more<br>&gt; difficult.  Finally, if the authors of a piece of code have such confidence<br>&gt; in the existence of a value that they feel it safe to use force unwrapping,<br>&gt; they should simply use a non-optional value and cut out a level of<br>&gt; indirection and avoid the dangers of bang in the first place.<br>&gt; &gt;<br>&gt; &gt; Because of the above, I&#39;d like to start a discussion about its<br>&gt; deprecation and eventual removal in favor of either an unsafeUnwrap<br>&gt; function or other extra-syntactic constructs.  I don&#39;t intend for<br>&gt; force-unwrapping as a concept to go away, as there will always be corner<br>&gt; cases where it is necessary, but I don&#39;t believe it deserves to be so easy<br>&gt; to do in a language that holds safety as a core tenant.<br>&gt; &gt;<br>&gt; &gt; Thanks all,<br>&gt; &gt;<br>&gt; &gt; ~Robert Widmann<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/3a72f8f3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 29, 2016 at 01:00:00pm</p></header><div class="content"><p>So:<br></p><p>a) I agree force-unwrapping is often overused and abused, especially by Swift beginners<br>b) I also agree with Brent that it’s a useful feature, and while not terribly often used, by me at least, important to have<br></p><p>Given that, I agree that having a simple to use `!` postfix operator might push people to abuse it. If it’s so simple to use, it means it’s important and should be used often. If it was harder to reach, it wouldn’t be used as often, because it would be relatively easier to do the right thing. <br></p><p>But. While `!` is perhaps too easy to type, it’s also very easy to spot while looking at code. It shouts at you “hey, do you really need me here?!”. `unsafeUnwrap` is harder to spot.<br></p><p>Also: `!` can be chained nicely like so:<br></p><p>  5&gt; struct A {<br>  6.     var x: Int<br>  7. }<br>  8&gt; struct B {<br>  9.     var a: A?<br> 10. }<br> 11&gt; var a = B(a: A(x: 10))<br> 12&gt; a.a!.x = 20<br></p><p>You can’t do that with a function or a method. Though you could do it with a property, I think, like `a.a.forceUnwrapped.x = 20`.<br></p><p>— Radek<br></p><p>&gt; On 28 Feb 2016, at 20:53, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Optional values pervade Swift code and so there is a significant part of the language dedicated to manipulating them and using them safely.  An optional value may be conditionally let-bound, guarded, pattern-matched on, given a default value with ??, or used with higher-order functions like map and flatMap without having to interact with partiality.  A corner case, however, remains in the form of the postfix-! force-unwrap operator.  At the term level, there is little reason to unwrap given the syntactic constructs above, and indeed code that does becomes brittle and, by its very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping an optional value&quot; error (our very own NullPointerException).  In addition, bang is incredibly hard to spot in code bases that use it because it blends in with Boolean negation (which, in itself, is notoriously hard to spot in other C-like-languages), harming readability and making code review more difficult.  Finally, if the authors of a piece of code have such confidence in the existence of a value that they feel it safe to use force unwrapping, they should simply use a non-optional value and cut out a level of indirection and avoid the dangers of bang in the first place. <br>&gt; <br>&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; Thanks all,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 09:00:00am</p></header><div class="content"><p>I have to clarify here: I am not taking about .!, as!, as?, ?, etc.  I am taking about making naked bang-unwrapping more difficult.  That is, those cases when you write<br></p><p>let thing = optVal!<br></p><p>These are equivalent to naked unguarded dereferences in C-like languages and are, we can all agree, a code smell, not a feature.  One would not ever recommend to a user of such languages that * or -&gt; be used before checking that an object or region of memory was non-NULL.  So, too, should we discourage this case by removing postfix-! from the language itself (notice it isn&#39;t even an operator, it is actually a part of the language).<br></p><p>~Robert Widmann<br></p><p>2016/02/28 14:53、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br></p><p>&gt; Optional values pervade Swift code and so there is a significant part of the language dedicated to manipulating them and using them safely.  An optional value may be conditionally let-bound, guarded, pattern-matched on, given a default value with ??, or used with higher-order functions like map and flatMap without having to interact with partiality.  A corner case, however, remains in the form of the postfix-! force-unwrap operator.  At the term level, there is little reason to unwrap given the syntactic constructs above, and indeed code that does becomes brittle and, by its very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping an optional value&quot; error (our very own NullPointerException).  In addition, bang is incredibly hard to spot in code bases that use it because it blends in with Boolean negation (which, in itself, is notoriously hard to spot in other C-like-languages), harming readability and making code review more difficult.  Finally, if the authors of a piece of code have such confidence in the existence of a value that they feel it safe to use force unwrapping, they should simply use a non-optional value and cut out a level of indirection and avoid the dangers of bang in the first place. <br>&gt; <br>&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; Thanks all,<br>&gt; <br>&gt; ~Robert Widmann<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 6:54 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have to clarify here: I am not taking about .!, as!, as?, ?, etc.  I am taking about making naked bang-unwrapping more difficult.  That is, those cases when you write<br>&gt; <br>&gt; let thing = optVal!<br>&gt; <br>&gt; These are equivalent to naked unguarded dereferences in C-like languages and are, we can all agree, a code smell, not a feature.  One would not ever recommend to a user of such languages that * or -&gt; be used before checking that an object or region of memory was non-NULL.  So, too, should we discourage this case by removing postfix-! from the language itself (notice it isn&#39;t even an operator, it is actually a part of the language).<br></p><p>I don&#39;t agree with this assertion. There are _many_ cases where you don&#39;t check for the pointer being null before accessing it. Those are programmer errors when the data is null. If there is no graceful way for the program to handle that case, what&#39;s the point of silently failing? Maybe later you come along because something keeps coming up with a null problem that you can&#39;t track down so you build something around it to recover.<br></p><p>I also don&#39;t see `let thing = unwrap(optVal)` or `let thing = optVal.unwrap()` as significantly better. The functionality still needs to be there, and this version is only slightly easier to grep vs. !.<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 01:00:00pm</p></header><div class="content"><p>The point is there *are* graceful ways of handling this that aren&#39;t unwrapping.  See all the language features I mentioned in the original.  There is really very little excuse to use a dereference operator all the same without a guard, precondition, or other static guarantee, and the language has given you the tools, many times over, to write those kinds of sanity checks.<br></p><p>Which is why I don&#39;t follow the logic for keeping ! around.  In C and Objective-C, it is _never_ safe to dereference memory, even in cases where you have reasonable certainty about its validity.  It seems to me making it more explicit where that logic gap is covered by intuition leads to higher quality code. <br></p><p>~Robert Widmann<br></p><p>2016/02/29 12:08、David Owens II &lt;david at owensd.io&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Feb 29, 2016, at 6:54 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have to clarify here: I am not taking about .!, as!, as?, ?, etc.  I am taking about making naked bang-unwrapping more difficult.  That is, those cases when you write<br>&gt;&gt; <br>&gt;&gt; let thing = optVal!<br>&gt;&gt; <br>&gt;&gt; These are equivalent to naked unguarded dereferences in C-like languages and are, we can all agree, a code smell, not a feature.  One would not ever recommend to a user of such languages that * or -&gt; be used before checking that an object or region of memory was non-NULL.  So, too, should we discourage this case by removing postfix-! from the language itself (notice it isn&#39;t even an operator, it is actually a part of the language).<br>&gt; <br>&gt; I don&#39;t agree with this assertion. There are _many_ cases where you don&#39;t check for the pointer being null before accessing it. Those are programmer errors when the data is null. If there is no graceful way for the program to handle that case, what&#39;s the point of silently failing? Maybe later you come along because something keeps coming up with a null problem that you can&#39;t track down so you build something around it to recover.<br>&gt; <br>&gt; I also don&#39;t see `let thing = unwrap(optVal)` or `let thing = optVal.unwrap()` as significantly better. The functionality still needs to be there, and this version is only slightly easier to grep vs. !.<br>&gt; <br>&gt; -David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Whoops, I meant &quot;it is never safe in general to dereference arbitrary memory&quot;. <br></p><p>~Robert Widmann<br></p><p>2016/02/29 13:50、Developer &lt;devteam.codafi at gmail.com&gt; のメッセージ:<br></p><p>&gt; The point is there *are* graceful ways of handling this that aren&#39;t unwrapping.  See all the language features I mentioned in the original.  There is really very little excuse to use a dereference operator all the same without a guard, precondition, or other static guarantee, and the language has given you the tools, many times over, to write those kinds of sanity checks.<br>&gt; <br>&gt; Which is why I don&#39;t follow the logic for keeping ! around.  In C and Objective-C, it is _never_ safe to dereference memory, even in cases where you have reasonable certainty about its validity.  It seems to me making it more explicit where that logic gap is covered by intuition leads to higher quality code. <br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/02/29 12:08、David Owens II &lt;david at owensd.io&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 29, 2016, at 6:54 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have to clarify here: I am not taking about .!, as!, as?, ?, etc.  I am taking about making naked bang-unwrapping more difficult.  That is, those cases when you write<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let thing = optVal!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These are equivalent to naked unguarded dereferences in C-like languages and are, we can all agree, a code smell, not a feature.  One would not ever recommend to a user of such languages that * or -&gt; be used before checking that an object or region of memory was non-NULL.  So, too, should we discourage this case by removing postfix-! from the language itself (notice it isn&#39;t even an operator, it is actually a part of the language).<br>&gt;&gt; <br>&gt;&gt; I don&#39;t agree with this assertion. There are _many_ cases where you don&#39;t check for the pointer being null before accessing it. Those are programmer errors when the data is null. If there is no graceful way for the program to handle that case, what&#39;s the point of silently failing? Maybe later you come along because something keeps coming up with a null problem that you can&#39;t track down so you build something around it to recover.<br>&gt;&gt; <br>&gt;&gt; I also don&#39;t see `let thing = unwrap(optVal)` or `let thing = optVal.unwrap()` as significantly better. The functionality still needs to be there, and this version is only slightly easier to grep vs. !.<br>&gt;&gt; <br>&gt;&gt; -David<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; These are equivalent to naked unguarded dereferences in C-like languages and are, we can all agree, a code smell, not a feature.<br></p><p>I previously wrote a 463-word post in this thread arguing that these are *not* code smells. Maybe you don&#39;t agree with that position, but if you really think &quot;we can all agree&quot; it&#39;s a code smell, you&#39;re not actually listening to the arguments against you.<br></p><p>I also object to the idea that these are &quot;unguarded&quot; dereferences. `!` *is* guarded by code which always reliably causes a crash if the value is nil. If this unwrap is guarded:<br></p><p>	guard let foo = foo else {<br>		fatalError(&quot;foo is nil!&quot;)<br>	}<br>	doSomething(foo)<br></p><p>Then so is this:<br></p><p>	doSomething(foo!)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 07:00:00pm</p></header><div class="content"><p>It is guarded in the same way that *(NULL) is guarded by an EXC_BAD_ACCESS.  It is all partiality in the end and beside the point I wished to make at the root of the discussion.  <br></p><p>Bang isn’t going anywhere under the original scheme, its usage is merely getting more obvious.  If you’ll excuse the pun, it’s a sin-tax on the usage of bang that I want, nothing more.  You can always reach for that hammer should you choose, but you will have to pay for it by using a function.  The language shouldn’t encourage thinking with partiality by baking it into its syntax so explicitly.<br></p><p>&gt; On Feb 29, 2016, at 6:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; These are equivalent to naked unguarded dereferences in C-like languages and are, we can all agree, a code smell, not a feature.<br>&gt; <br>&gt; I previously wrote a 463-word post in this thread arguing that these are *not* code smells. Maybe you don&#39;t agree with that position, but if you really think &quot;we can all agree&quot; it&#39;s a code smell, you&#39;re not actually listening to the arguments against you.<br>&gt; <br>&gt; I also object to the idea that these are &quot;unguarded&quot; dereferences. `!` *is* guarded by code which always reliably causes a crash if the value is nil. If this unwrap is guarded:<br>&gt; <br>&gt; 	guard let foo = foo else {<br>&gt; 		fatalError(&quot;foo is nil!&quot;)<br>&gt; 	}<br>&gt; 	doSomething(foo)<br>&gt; <br>&gt; Then so is this:<br>&gt; <br>&gt; 	doSomething(foo!)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 4:04 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It is guarded in the same way that *(NULL) is guarded by an EXC_BAD_ACCESS.  It is all partiality in the end and beside the point I wished to make at the root of the discussion.  <br></p><p>Random ultra pedantic point, but dereferencing a null pointer in C (or an nil UnsafePointer in Swift) is actually undefined behavior, it is not guarded by a deterministic trap (as it is in Java).<br></p><p>Details here:<br>http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4002684831b0a89736f4837d2e60f66a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Pierre Monod-Broca</string> &lt;pierremonodbroca at gmail.com&gt;<p>March  1, 2016 at 07:00:00am</p></header><div class="content"><p>Proposal: -1<br>Chris: +1<br>Brent: +1<br>Charles: +1<br></p><p>And it&#39;s still better than the iconic NullPointerException, because it will mostly happen sooner, making it easier to understand<br></p><p>Pierre<br></p><p>&gt; Le 1 mars 2016 à 06:58, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 29, 2016, at 4:04 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is guarded in the same way that *(NULL) is guarded by an EXC_BAD_ACCESS.  It is all partiality in the end and beside the point I wished to make at the root of the discussion. <br>&gt; <br>&gt; Random ultra pedantic point, but dereferencing a null pointer in C (or an nil UnsafePointer in Swift) is actually undefined behavior, it is not guarded by a deterministic trap (as it is in Java).<br>&gt; <br>&gt; Details here:<br>&gt; http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March  2, 2016 at 11:00:00am</p></header><div class="content"><p>Strong -1.<br></p><p>My UI code has hundreds of these force-unwraps, mostly on resource<br>access like UIImage(named: &quot;something&quot;)!, to catch naming mistakes and<br>the like. Making it a method will increase the visual noise<br>significantly, and I can&#39;t even imagine using let&#39;s for this.<br></p><p>In general, I consider ! an assertion, and definitely NOT a code smell.<br>There are many cases where generic code may legitimately return nil, but<br>I as a developer know that it will never happen in my particular case.<br></p><p>A.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/6a6e076f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>March  1, 2016 at 10:00:00pm</p></header><div class="content"><p>I’m not sure it is a good idea to make the language syntax more verbose (and less convenient) in an attempt to suggest best practice. If nothing else force-unwrapping is useful in test code and making test code more verbose is definitely a negative.<br></p><p>As mentioned previously in this thread, I think it would be preferable to consider compiler options for warning/restricting its usage in production code - potentially even eventually moving to force-unwrapping being disabled for production code by default.<br></p><p>-Simon<br></p><p><br>&gt; On 1 Mar 2016, at 9:30 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Strong -1.<br>&gt;  <br>&gt; My UI code has hundreds of these force-unwraps, mostly on resource access like UIImage(named: &quot;something&quot;)!, to catch naming mistakes and the like. Making it a method will increase the visual noise significantly, and I can&#39;t even imagine using let&#39;s for this.<br>&gt;  <br>&gt; In general, I consider ! an assertion, and definitely NOT a code smell. There are many cases where generic code may legitimately return nil, but I as a developer know that it will never happen in my particular case.<br>&gt;  <br>&gt; A.<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/483bd1fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  2, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; As mentioned previously in this thread, I think it would be preferable to consider compiler options for warning/restricting its usage in production code - potentially even eventually moving to force-unwrapping being disabled for production code by default.<br></p><p>This sounds like exactly the sort of style concern we&#39;ve previously decided to leave to linters.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 29, 2016 at 07:00:00pm</p></header><div class="content"><p>To move the discussion forward, perhaps a better analogy is not pointers, but casting.  C++ uses the well-known const_cast, static_cast, and reinterpret_cast, primitives as a sin-tax on the usage of casting.  It makes a fundamentally unsafe operation incredibly obvious, and makes the programmer think twice about asking C++ to violate its internal consistency checks in the name of a “leap of logic” made by the programmer.  While it is possible to use casting safely, just as it is possible to use bang safely, the language makes it clear it doesn’t wish to encourage a bad pattern.  Casting didn’t go away here, casting didn’t get “harder”, but casting in C++ versus C got syntactically heavier and thus makes the programmer pause, if only for a second longer, to consider other options.<br></p><p>&gt; On Feb 29, 2016, at 6:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; These are equivalent to naked unguarded dereferences in C-like languages and are, we can all agree, a code smell, not a feature.<br>&gt; <br>&gt; I previously wrote a 463-word post in this thread arguing that these are *not* code smells. Maybe you don&#39;t agree with that position, but if you really think &quot;we can all agree&quot; it&#39;s a code smell, you&#39;re not actually listening to the arguments against you.<br>&gt; <br>&gt; I also object to the idea that these are &quot;unguarded&quot; dereferences. `!` *is* guarded by code which always reliably causes a crash if the value is nil. If this unwrap is guarded:<br>&gt; <br>&gt; 	guard let foo = foo else {<br>&gt; 		fatalError(&quot;foo is nil!&quot;)<br>&gt; 	}<br>&gt; 	doSomething(foo)<br>&gt; <br>&gt; Then so is this:<br>&gt; <br>&gt; 	doSomething(foo!)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 29, 2016 at 10:00:00pm</p></header><div class="content"><p>-1 for the deprecation.<br></p><p>-Van<br></p><p>On Mon, Feb 29, 2016 at 9:41 PM, Developer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; To move the discussion forward, perhaps a better analogy is not pointers,<br>&gt; but casting.  C++ uses the well-known const_cast, static_cast, and<br>&gt; reinterpret_cast, primitives as a sin-tax on the usage of casting.  It<br>&gt; makes a fundamentally unsafe operation incredibly obvious, and makes the<br>&gt; programmer think twice about asking C++ to violate its internal consistency<br>&gt; checks in the name of a “leap of logic” made by the programmer.  While it<br>&gt; is possible to use casting safely, just as it is possible to use bang<br>&gt; safely, the language makes it clear it doesn’t wish to encourage a bad<br>&gt; pattern.  Casting didn’t go away here, casting didn’t get “harder”, but<br>&gt; casting in C++ versus C got syntactically heavier and thus makes the<br>&gt; programmer pause, if only for a second longer, to consider other options.<br>&gt;<br>&gt; &gt; On Feb 29, 2016, at 6:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; These are equivalent to naked unguarded dereferences in C-like<br>&gt; languages and are, we can all agree, a code smell, not a feature.<br>&gt; &gt;<br>&gt; &gt; I previously wrote a 463-word post in this thread arguing that these are<br>&gt; *not* code smells. Maybe you don&#39;t agree with that position, but if you<br>&gt; really think &quot;we can all agree&quot; it&#39;s a code smell, you&#39;re not actually<br>&gt; listening to the arguments against you.<br>&gt; &gt;<br>&gt; &gt; I also object to the idea that these are &quot;unguarded&quot; dereferences. `!`<br>&gt; *is* guarded by code which always reliably causes a crash if the value is<br>&gt; nil. If this unwrap is guarded:<br>&gt; &gt;<br>&gt; &gt;       guard let foo = foo else {<br>&gt; &gt;               fatalError(&quot;foo is nil!&quot;)<br>&gt; &gt;       }<br>&gt; &gt;       doSomething(foo)<br>&gt; &gt;<br>&gt; &gt; Then so is this:<br>&gt; &gt;<br>&gt; &gt;       doSomething(foo!)<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/61b05fbb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 29, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 4:41 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To move the discussion forward, perhaps a better analogy is not pointers, but casting.  C++ uses the well-known const_cast, static_cast, and reinterpret_cast, primitives as a sin-tax on the usage of casting.  It makes a fundamentally unsafe operation incredibly obvious, and makes the programmer think twice about asking C++ to violate its internal consistency checks in the name of a “leap of logic” made by the programmer.  While it is possible to use casting safely, just as it is possible to use bang safely, the language makes it clear it doesn’t wish to encourage a bad pattern.  Casting didn’t go away here, casting didn’t get “harder”, but casting in C++ versus C got syntactically heavier and thus makes the programmer pause, if only for a second longer, to consider other options.<br></p><p>To me, the use of an exclamation point for forced unwrapping is a great choice. It suggests caution, just as it does when it appears on warning signs. I already feel apprehensive on the rare occasions when I use forced unwrapping, even though I know it’s the proper choice.<br></p><p>—CK<br></p><p>&gt; <br>&gt;&gt; On Feb 29, 2016, at 6:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; These are equivalent to naked unguarded dereferences in C-like languages and are, we can all agree, a code smell, not a feature.<br>&gt;&gt; <br>&gt;&gt; I previously wrote a 463-word post in this thread arguing that these are *not* code smells. Maybe you don&#39;t agree with that position, but if you really think &quot;we can all agree&quot; it&#39;s a code smell, you&#39;re not actually listening to the arguments against you.<br>&gt;&gt; <br>&gt;&gt; I also object to the idea that these are &quot;unguarded&quot; dereferences. `!` *is* guarded by code which always reliably causes a crash if the value is nil. If this unwrap is guarded:<br>&gt;&gt; <br>&gt;&gt; 	guard let foo = foo else {<br>&gt;&gt; 		fatalError(&quot;foo is nil!&quot;)<br>&gt;&gt; 	}<br>&gt;&gt; 	doSomething(foo)<br>&gt;&gt; <br>&gt;&gt; Then so is this:<br>&gt;&gt; <br>&gt;&gt; 	doSomething(foo!)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>February 29, 2016 at 11:00:00am</p></header><div class="content"><p>I strongly agree with this. The main goal of optionals is to help eliminate null pointer exceptions, yet there is a common mechanism to put them back into your code. This doesn’t make much sense to me.<br></p><p>Not having forced unwrapping makes you take care of the cases where you might run into null, and will push the language in a direction where dealing with the null is just as easy as risking a null pointer exception is today.<br></p><p>-Kenny<br></p><p><br>&gt; On Feb 28, 2016, at 11:53 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Optional values pervade Swift code and so there is a significant part of the language dedicated to manipulating them and using them safely.  An optional value may be conditionally let-bound, guarded, pattern-matched on, given a default value with ??, or used with higher-order functions like map and flatMap without having to interact with partiality.  A corner case, however, remains in the form of the postfix-! force-unwrap operator.  At the term level, there is little reason to unwrap given the syntactic constructs above, and indeed code that does becomes brittle and, by its very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping an optional value&quot; error (our very own NullPointerException).  In addition, bang is incredibly hard to spot in code bases that use it because it blends in with Boolean negation (which, in itself, is notoriously hard to spot in other C-like-languages), harming readability and making code review more difficult.  Finally, if the authors of a piece of code have such confidence in the existence of a value that they feel it safe to use force unwrapping, they should simply use a non-optional value and cut out a level of indirection and avoid the dangers of bang in the first place. <br>&gt; <br>&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; Thanks all,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0cfe9bf4dd7fbabba043597960b120d?s=50"></div><header><strong>[Discussion]: Deprecate !-Unwrapping of Optionals</strong> from <string>Joel Lopes Da Silva</string> &lt;lopesdasilva at apple.com&gt;<p>February 29, 2016 at 12:00:00pm</p></header><div class="content"><p>I’m not sure about deprecating force unwrapping altogether; it might be too early for that.<br></p><p>But I think it would be a good idea to create a new opt-in compiler warning flag that would point to any code that relies on force unwrapping (whether explicitly, or with implicitly wrapped optionals).<br></p><p>-- <br>Joel Lopes Da Silva<br></p><p><br>&gt; On Feb 28, 2016, at 11:53 AM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Optional values pervade Swift code and so there is a significant part of the language dedicated to manipulating them and using them safely.  An optional value may be conditionally let-bound, guarded, pattern-matched on, given a default value with ??, or used with higher-order functions like map and flatMap without having to interact with partiality.  A corner case, however, remains in the form of the postfix-! force-unwrap operator.  At the term level, there is little reason to unwrap given the syntactic constructs above, and indeed code that does becomes brittle and, by its very nature, open to the dreaded &quot;unexpectedly found nil while unwrapping an optional value&quot; error (our very own NullPointerException).  In addition, bang is incredibly hard to spot in code bases that use it because it blends in with Boolean negation (which, in itself, is notoriously hard to spot in other C-like-languages), harming readability and making code review more difficult.  Finally, if the authors of a piece of code have such confidence in the existence of a value that they feel it safe to use force unwrapping, they should simply use a non-optional value and cut out a level of indirection and avoid the dangers of bang in the first place. <br>&gt; <br>&gt; Because of the above, I&#39;d like to start a discussion about its deprecation and eventual removal in favor of either an unsafeUnwrap function or other extra-syntactic constructs.  I don&#39;t intend for force-unwrapping as a concept to go away, as there will always be corner cases where it is necessary, but I don&#39;t believe it deserves to be so easy to do in a language that holds safety as a core tenant.<br>&gt; <br>&gt; Thanks all,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
