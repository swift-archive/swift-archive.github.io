<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7c5a136ef7c35133369072926fbd4626?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Uwe Falck</string> &lt;uwefalck at mac.com&gt;<p>January 19, 2016 at 09:00:00pm</p></header><div class="content"><p>I’m looking for feedback on this request if its worth to start an evolution proposal.<br></p><p> <br>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br></p><p> ####<br></p><p> Introduction<br></p><p> ####<br></p><p>Consider two loops. The first loop iterator will return an empty range and will not be executed. The second loop throws an error. I would like to see the range iterator always returning an empty range if end index &lt; start index. <br></p><p>for i in 3..&lt;3 <br>{ print(i) }<br></p><p>for i in 3…2<br>{ print(i) }<br></p><p><br> ####<br></p><p> Motivation<br></p><p> ####<br></p><p>The two expressions above are mathematically equivalent and I would like them to return the same result for consistency.<br></p><p>Furthermore, and more important: if C-style for loops are gone with Swift 3.0, programmers may translate <br></p><p>func fibonacci(n: Int) -&gt; Int {                            // works for n&gt;=0<br>	var memo = [0,1]<br>	for var i = 2; i &lt;= n; i++ {<br>		memo.append(memo[i-1] + memo[i-2])<br>	}<br>	return memo[n]<br>}<br></p><p>probably into<br></p><p>func fibonacci(n: Int) -&gt; Int {				// works only for n&gt;=2!<br>	var memo = [0,1]<br>	for i in 2...n {<br>		memo.append(memo[i-1] + memo[i-2])<br>	}<br>	return memo[n]<br>}<br></p><p>This example is from Stackoverflow[1] with two suggested solutions to prevent the runtime error for 0 and 1<br></p><p>let startIndex = 2<br>let endIndex = n<br>for i in startIndex.stride(through: endIndex, by: 1) {<br>	memo.append(memo[i-1] + memo[i-2])<br>}<br></p><p>…and another one uses the empty range generate by  ..&lt;<br></p><p>for i in 2 ..&lt; max(2, n+1) {<br>	memo.append(memo[i-1] + memo[i-2])<br>}<br></p><p>Clearly the not-working-solution looks most logical. All other control flow elements, like while, will just not execute if their condition is not met on loop entry.<br></p><p><br> #####<br></p><p> Proposed solution<br></p><p> #####<br></p><p>Let both range iterators return emtpy ranges, if end index &lt; start index, and not only for a..&lt;b with a==b.<br> <br> #####<br></p><p> Impact on existing code<br></p><p> #####<br></p><p> None.<br></p><p> ####<br></p><p> Alternatives considered<br></p><p> ####<br></p><p> If range operators will allow downward variants this idea becomes pointless.<br></p><p> ####<br></p><p> Open questions<br></p><p> ####<br></p><p> None.<br></p><p><br> [1] http://stackoverflow.com/questions/34323227/a-concise-way-to-not-execute-a-loop-now-that-c-style-for-loops-are-going-to-be-r?lq=1<br> <br></p><p> Thanks,<br></p><p><br> --<br></p><p> Uwe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 19, 2016 at 07:00:00pm</p></header><div class="content"><p>I don&#39;t have a strong opinion on this, but maybe there could be a ..&lt;?/...? operator for ranges that may or may not be well-formed? This solution can be implemented &quot;at home&quot; too.<br></p><p>I&#39;d love to see where and how developers use ranges. It may be more helpful than it looks like. For instance, if you use a range to get an array slice, would your rather have an empty slice if your range underflows instead of the current error behavior?<br></p><p>Félix<br></p><p>&gt; Le 19 janv. 2016 à 15:46:00, Uwe Falck via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I’m looking for feedback on this request if its worth to start an evolution proposal.<br>&gt; <br>&gt; <br>&gt; Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br>&gt; <br>&gt; ####<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; ####<br>&gt; <br>&gt; Consider two loops. The first loop iterator will return an empty range and will not be executed. The second loop throws an error. I would like to see the range iterator always returning an empty range if end index &lt; start index. <br>&gt; <br>&gt; for i in 3..&lt;3 <br>&gt; { print(i) }<br>&gt; <br>&gt; for i in 3…2<br>&gt; { print(i) }<br>&gt; <br>&gt; <br>&gt; ####<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; ####<br>&gt; <br>&gt; The two expressions above are mathematically equivalent and I would like them to return the same result for consistency.<br>&gt; <br>&gt; Furthermore, and more important: if C-style for loops are gone with Swift 3.0, programmers may translate <br>&gt; <br>&gt; func fibonacci(n: Int) -&gt; Int {                            // works for n&gt;=0<br>&gt; 	var memo = [0,1]<br>&gt; 	for var i = 2; i &lt;= n; i++ {<br>&gt; 		memo.append(memo[i-1] + memo[i-2])<br>&gt; 	}<br>&gt; 	return memo[n]<br>&gt; }<br>&gt; <br>&gt; probably into<br>&gt; <br>&gt; func fibonacci(n: Int) -&gt; Int {				// works only for n&gt;=2!<br>&gt; 	var memo = [0,1]<br>&gt; 	for i in 2...n {<br>&gt; 		memo.append(memo[i-1] + memo[i-2])<br>&gt; 	}<br>&gt; 	return memo[n]<br>&gt; }<br>&gt; <br>&gt; This example is from Stackoverflow[1] with two suggested solutions to prevent the runtime error for 0 and 1<br>&gt; <br>&gt; let startIndex = 2<br>&gt; let endIndex = n<br>&gt; for i in startIndex.stride(through: endIndex, by: 1) {<br>&gt; 	memo.append(memo[i-1] + memo[i-2])<br>&gt; }<br>&gt; <br>&gt; …and another one uses the empty range generate by  ..&lt;<br>&gt; <br>&gt; for i in 2 ..&lt; max(2, n+1) {<br>&gt; 	memo.append(memo[i-1] + memo[i-2])<br>&gt; }<br>&gt; <br>&gt; Clearly the not-working-solution looks most logical. All other control flow elements, like while, will just not execute if their condition is not met on loop entry.<br>&gt; <br>&gt; <br>&gt; #####<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; #####<br>&gt; <br>&gt; Let both range iterators return emtpy ranges, if end index &lt; start index, and not only for a..&lt;b with a==b.<br>&gt; <br>&gt; #####<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; #####<br>&gt; <br>&gt; None.<br>&gt; <br>&gt; ####<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; ####<br>&gt; <br>&gt; If range operators will allow downward variants this idea becomes pointless.<br>&gt; <br>&gt; ####<br>&gt; <br>&gt; Open questions<br>&gt; <br>&gt; ####<br>&gt; <br>&gt; None.<br>&gt; <br>&gt; <br>&gt; [1] http://stackoverflow.com/questions/34323227/a-concise-way-to-not-execute-a-loop-now-that-c-style-for-loops-are-going-to-be-r?lq=1<br>&gt; <br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; <br>&gt; --<br>&gt; <br>&gt; Uwe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/1cb82bb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 20, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 from me. I have been caught by this. In the degenerate case I didn&#39;t<br>want the loop to be processed, but instead I got a runtime error. I solved<br>the problem by changing to a C style for loop, but with the removal of C<br>style for loops this will be more of a problem.<br></p><p>This could be solved with a library function as already suggested, however<br>having `...`, `..&lt;`, `...?`, and `..&lt;?` seems excessive. Therefore my<br>suggestion is to make `...` &amp; `..&lt;` behave as proposed (i.e. return empty<br>ranges when limits mean nothing enclosed by range).<br></p><p>On Wednesday, 20 January 2016, Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; I don&#39;t have a strong opinion on this, but maybe there could be a<br>&gt; ..&lt;?/...? operator for ranges that may or may not be well-formed? This<br>&gt; solution can be implemented &quot;at home&quot; too.<br>&gt;<br>&gt; I&#39;d love to see where and how developers use ranges. It may be more<br>&gt; helpful than it looks like. For instance, if you use a range to get an<br>&gt; array slice, would your rather have an empty slice if your range underflows<br>&gt; instead of the current error behavior?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 19 janv. 2016 à 15:46:00, Uwe Falck via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;<br>&gt; I’m looking for feedback on this request if its worth to start an<br>&gt; evolution proposal.<br>&gt;<br>&gt;<br>&gt; Let range operators always return empty ranges if the upper bound is<br>&gt; smaller than the lower bound.<br>&gt;<br>&gt; ####<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; ####<br>&gt;<br>&gt; Consider two loops. The first loop iterator will return an empty range and<br>&gt; will not be executed. The second loop throws an error. I would like to see<br>&gt; the range iterator always returning an empty range if end index &lt; start<br>&gt; index.<br>&gt;<br>&gt; for i in 3..&lt;3<br>&gt; { print(i) }<br>&gt;<br>&gt; for i in 3…2<br>&gt; { print(i) }<br>&gt;<br>&gt;<br>&gt; ####<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; ####<br>&gt;<br>&gt; The two expressions above are mathematically equivalent and I would like<br>&gt; them to return the same result for consistency.<br>&gt;<br>&gt; Furthermore, and more important: if C-style for loops are gone with Swift<br>&gt; 3.0, programmers may translate<br>&gt;<br>&gt; func fibonacci(n: Int) -&gt; Int {                            // works for<br>&gt; n&gt;=0<br>&gt; var memo = [0,1]<br>&gt; for var i = 2; i &lt;= n; i++ {<br>&gt; memo.append(memo[i-1] + memo[i-2])<br>&gt; }<br>&gt; return memo[n]<br>&gt; }<br>&gt;<br>&gt; probably into<br>&gt;<br>&gt; func fibonacci(n: Int) -&gt; Int { // works only for n&gt;=2!<br>&gt; var memo = [0,1]<br>&gt; for i in 2...n {<br>&gt; memo.append(memo[i-1] + memo[i-2])<br>&gt; }<br>&gt; return memo[n]<br>&gt; }<br>&gt;<br>&gt; This example is from Stackoverflow[1] with two suggested solutions to<br>&gt; prevent the runtime error for 0 and 1<br>&gt;<br>&gt; let startIndex = 2<br>&gt; let endIndex = n<br>&gt; for i in startIndex.stride(through: endIndex, by: 1) {<br>&gt; memo.append(memo[i-1] + memo[i-2])<br>&gt; }<br>&gt;<br>&gt; …and another one uses the empty range generate by  ..&lt;<br>&gt;<br>&gt; for i in 2 ..&lt; max(2, n+1) {<br>&gt; memo.append(memo[i-1] + memo[i-2])<br>&gt; }<br>&gt;<br>&gt; Clearly the not-working-solution looks most logical. All other control<br>&gt; flow elements, like while, will just not execute if their condition is not<br>&gt; met on loop entry.<br>&gt;<br>&gt;<br>&gt; #####<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; #####<br>&gt;<br>&gt; Let both range iterators return emtpy ranges, if end index &lt; start index,<br>&gt; and not only for a..&lt;b with a==b.<br>&gt;<br>&gt; #####<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; #####<br>&gt;<br>&gt; None.<br>&gt;<br>&gt; ####<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; ####<br>&gt;<br>&gt; If range operators will allow downward variants this idea becomes<br>&gt; pointless.<br>&gt;<br>&gt; ####<br>&gt;<br>&gt; Open questions<br>&gt;<br>&gt; ####<br>&gt;<br>&gt; None.<br>&gt;<br>&gt;<br>&gt; [1]<br>&gt; http://stackoverflow.com/questions/34323227/a-concise-way-to-not-execute-a-loop-now-that-c-style-for-loops-are-going-to-be-r?lq=1<br>&gt;<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; Uwe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/6a8d46a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>+1 from me<br>Ondrej Barina<br></p><p>On Wed, Jan 20, 2016 at 2:32 AM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 from me. I have been caught by this. In the degenerate case I didn&#39;t<br>&gt; want the loop to be processed, but instead I got a runtime error. I solved<br>&gt; the problem by changing to a C style for loop, but with the removal of C<br>&gt; style for loops this will be more of a problem.<br>&gt;<br>&gt; This could be solved with a library function as already suggested, however<br>&gt; having `...`, `..&lt;`, `...?`, and `..&lt;?` seems excessive. Therefore my<br>&gt; suggestion is to make `...` &amp; `..&lt;` behave as proposed (i.e. return empty<br>&gt; ranges when limits mean nothing enclosed by range).<br>&gt;<br>&gt;<br>&gt; On Wednesday, 20 January 2016, Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t have a strong opinion on this, but maybe there could be a<br>&gt;&gt; ..&lt;?/...? operator for ranges that may or may not be well-formed? This<br>&gt;&gt; solution can be implemented &quot;at home&quot; too.<br>&gt;&gt;<br>&gt;&gt; I&#39;d love to see where and how developers use ranges. It may be more<br>&gt;&gt; helpful than it looks like. For instance, if you use a range to get an<br>&gt;&gt; array slice, would your rather have an empty slice if your range underflows<br>&gt;&gt; instead of the current error behavior?<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 19 janv. 2016 à 15:46:00, Uwe Falck via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; I’m looking for feedback on this request if its worth to start an<br>&gt;&gt; evolution proposal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Let range operators always return empty ranges if the upper bound is<br>&gt;&gt; smaller than the lower bound.<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt;<br>&gt;&gt; Consider two loops. The first loop iterator will return an empty range<br>&gt;&gt; and will not be executed. The second loop throws an error. I would like to<br>&gt;&gt; see the range iterator always returning an empty range if end index &lt; start<br>&gt;&gt; index.<br>&gt;&gt;<br>&gt;&gt; for i in 3..&lt;3<br>&gt;&gt; { print(i) }<br>&gt;&gt;<br>&gt;&gt; for i in 3…2<br>&gt;&gt; { print(i) }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt;<br>&gt;&gt; The two expressions above are mathematically equivalent and I would like<br>&gt;&gt; them to return the same result for consistency.<br>&gt;&gt;<br>&gt;&gt; Furthermore, and more important: if C-style for loops are gone with Swift<br>&gt;&gt; 3.0, programmers may translate<br>&gt;&gt;<br>&gt;&gt; func fibonacci(n: Int) -&gt; Int {                            // works for<br>&gt;&gt; n&gt;=0<br>&gt;&gt; var memo = [0,1]<br>&gt;&gt; for var i = 2; i &lt;= n; i++ {<br>&gt;&gt; memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt; }<br>&gt;&gt; return memo[n]<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; probably into<br>&gt;&gt;<br>&gt;&gt; func fibonacci(n: Int) -&gt; Int { // works only for n&gt;=2!<br>&gt;&gt; var memo = [0,1]<br>&gt;&gt; for i in 2...n {<br>&gt;&gt; memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt; }<br>&gt;&gt; return memo[n]<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This example is from Stackoverflow[1] with two suggested solutions to<br>&gt;&gt; prevent the runtime error for 0 and 1<br>&gt;&gt;<br>&gt;&gt; let startIndex = 2<br>&gt;&gt; let endIndex = n<br>&gt;&gt; for i in startIndex.stride(through: endIndex, by: 1) {<br>&gt;&gt; memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; …and another one uses the empty range generate by  ..&lt;<br>&gt;&gt;<br>&gt;&gt; for i in 2 ..&lt; max(2, n+1) {<br>&gt;&gt; memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Clearly the not-working-solution looks most logical. All other control<br>&gt;&gt; flow elements, like while, will just not execute if their condition is not<br>&gt;&gt; met on loop entry.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; #####<br>&gt;&gt;<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; #####<br>&gt;&gt;<br>&gt;&gt; Let both range iterators return emtpy ranges, if end index &lt; start index,<br>&gt;&gt; and not only for a..&lt;b with a==b.<br>&gt;&gt;<br>&gt;&gt; #####<br>&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; #####<br>&gt;&gt;<br>&gt;&gt; None.<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt;<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt;<br>&gt;&gt; If range operators will allow downward variants this idea becomes<br>&gt;&gt; pointless.<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt;<br>&gt;&gt; Open questions<br>&gt;&gt;<br>&gt;&gt; ####<br>&gt;&gt;<br>&gt;&gt; None.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; [1]<br>&gt;&gt; http://stackoverflow.com/questions/34323227/a-concise-way-to-not-execute-a-loop-now-that-c-style-for-loops-are-going-to-be-r?lq=1<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; Uwe<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/7068fc02/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>+1<br></p><p>-Thorsten <br></p><p>&gt; Am 20.01.2016 um 02:32 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; +1 from me. I have been caught by this. In the degenerate case I didn&#39;t want the loop to be processed, but instead I got a runtime error. I solved the problem by changing to a C style for loop, but with the removal of C style for loops this will be more of a problem. <br>&gt; <br>&gt; This could be solved with a library function as already suggested, however having `...`, `..&lt;`, `...?`, and `..&lt;?` seems excessive. Therefore my suggestion is to make `...` &amp; `..&lt;` behave as proposed (i.e. return empty ranges when limits mean nothing enclosed by range).<br>&gt; <br>&gt;&gt; On Wednesday, 20 January 2016, Félix Cloutier &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I don&#39;t have a strong opinion on this, but maybe there could be a ..&lt;?/...? operator for ranges that may or may not be well-formed? This solution can be implemented &quot;at home&quot; too.<br>&gt;&gt; <br>&gt;&gt; I&#39;d love to see where and how developers use ranges. It may be more helpful than it looks like. For instance, if you use a range to get an array slice, would your rather have an empty slice if your range underflows instead of the current error behavior?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 19 janv. 2016 à 15:46:00, Uwe Falck via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m looking for feedback on this request if its worth to start an evolution proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider two loops. The first loop iterator will return an empty range and will not be executed. The second loop throws an error. I would like to see the range iterator always returning an empty range if end index &lt; start index. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for i in 3..&lt;3 <br>&gt;&gt;&gt; { print(i) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for i in 3…2<br>&gt;&gt;&gt; { print(i) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The two expressions above are mathematically equivalent and I would like them to return the same result for consistency.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore, and more important: if C-style for loops are gone with Swift 3.0, programmers may translate <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func fibonacci(n: Int) -&gt; Int {                            // works for n&gt;=0<br>&gt;&gt;&gt; 	var memo = [0,1]<br>&gt;&gt;&gt; 	for var i = 2; i &lt;= n; i++ {<br>&gt;&gt;&gt; 		memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	return memo[n]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; probably into<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func fibonacci(n: Int) -&gt; Int {				// works only for n&gt;=2!<br>&gt;&gt;&gt; 	var memo = [0,1]<br>&gt;&gt;&gt; 	for i in 2...n {<br>&gt;&gt;&gt; 		memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	return memo[n]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This example is from Stackoverflow[1] with two suggested solutions to prevent the runtime error for 0 and 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let startIndex = 2<br>&gt;&gt;&gt; let endIndex = n<br>&gt;&gt;&gt; for i in startIndex.stride(through: endIndex, by: 1) {<br>&gt;&gt;&gt; 	memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …and another one uses the empty range generate by  ..&lt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for i in 2 ..&lt; max(2, n+1) {<br>&gt;&gt;&gt; 	memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Clearly the not-working-solution looks most logical. All other control flow elements, like while, will just not execute if their condition is not met on loop entry.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let both range iterators return emtpy ranges, if end index &lt; start index, and not only for a..&lt;b with a==b.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If range operators will allow downward variants this idea becomes pointless.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1] http://stackoverflow.com/questions/34323227/a-concise-way-to-not-execute-a-loop-now-that-c-style-for-loops-are-going-to-be-r?lq=1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Uwe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/a3e5e6e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e860a1e0d21a7ae5467aacfe1d9c6a78?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Denis Nikitenko</string> &lt;d.nikitenko at icloud.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>Another hearty +1 from me as well.  I’ve run into this recently and used the stride-based work-round.  However, using <br></p><p>for i in startIndex.stride(through: endIndex, by: 1){<br>...<br>} <br></p><p>instead of <br></p><p>for i in startIndex…endIndex{<br>…<br>}<br></p><p>solely so that the body of the loop never executes if startIndex &gt; endIndex seems unnecessary - especially since <br></p><p>for i in startIndex…&lt;endIndex+1{<br>…<br>}<br></p><p>works perfectly fine.  It would make sense to make `…` and `..&lt;` consistent with each other and return an empty range in this case - which would also be consistent with the overall behaviour of stride().<br></p><p>Denis<br></p><p><br>&gt; On Jan 20, 2016, at 3:55 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 20.01.2016 um 02:32 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; +1 from me. I have been caught by this. In the degenerate case I didn&#39;t want the loop to be processed, but instead I got a runtime error. I solved the problem by changing to a C style for loop, but with the removal of C style for loops this will be more of a problem. <br>&gt;&gt; <br>&gt;&gt; This could be solved with a library function as already suggested, however having `...`, `..&lt;`, `...?`, and `..&lt;?` seems excessive. Therefore my suggestion is to make `...` &amp; `..&lt;` behave as proposed (i.e. return empty ranges when limits mean nothing enclosed by range).<br>&gt;&gt; <br>&gt;&gt; On Wednesday, 20 January 2016, Félix Cloutier &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I don&#39;t have a strong opinion on this, but maybe there could be a ..&lt;?/...? operator for ranges that may or may not be well-formed? This solution can be implemented &quot;at home&quot; too.<br>&gt;&gt; <br>&gt;&gt; I&#39;d love to see where and how developers use ranges. It may be more helpful than it looks like. For instance, if you use a range to get an array slice, would your rather have an empty slice if your range underflows instead of the current error behavior?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 19 janv. 2016 à 15:46:00, Uwe Falck via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m looking for feedback on this request if its worth to start an evolution proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider two loops. The first loop iterator will return an empty range and will not be executed. The second loop throws an error. I would like to see the range iterator always returning an empty range if end index &lt; start index. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for i in 3..&lt;3 <br>&gt;&gt;&gt; { print(i) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for i in 3…2<br>&gt;&gt;&gt; { print(i) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The two expressions above are mathematically equivalent and I would like them to return the same result for consistency.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore, and more important: if C-style for loops are gone with Swift 3.0, programmers may translate <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func fibonacci(n: Int) -&gt; Int {                            // works for n&gt;=0<br>&gt;&gt;&gt; 	var memo = [0,1]<br>&gt;&gt;&gt; 	for var i = 2; i &lt;= n; i++ {<br>&gt;&gt;&gt; 		memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	return memo[n]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; probably into<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func fibonacci(n: Int) -&gt; Int {				// works only for n&gt;=2!<br>&gt;&gt;&gt; 	var memo = [0,1]<br>&gt;&gt;&gt; 	for i in 2...n {<br>&gt;&gt;&gt; 		memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	return memo[n]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This example is from Stackoverflow[1] with two suggested solutions to prevent the runtime error for 0 and 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let startIndex = 2<br>&gt;&gt;&gt; let endIndex = n<br>&gt;&gt;&gt; for i in startIndex.stride(through: endIndex, by: 1) {<br>&gt;&gt;&gt; 	memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …and another one uses the empty range generate by  ..&lt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for i in 2 ..&lt; max(2, n+1) {<br>&gt;&gt;&gt; 	memo.append(memo[i-1] + memo[i-2])<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Clearly the not-working-solution looks most logical. All other control flow elements, like while, will just not execute if their condition is not met on loop entry.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let both range iterators return emtpy ranges, if end index &lt; start index, and not only for a..&lt;b with a==b.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If range operators will allow downward variants this idea becomes pointless.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Open questions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ####<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1] http://stackoverflow.com/questions/34323227/a-concise-way-to-not-execute-a-loop-now-that-c-style-for-loops-are-going-to-be-r?lq=1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Uwe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 20, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m a minor -1; it feels like this is in the same family as nil-messaging in that it can silently treat invalid input as a no-op. I&#39;m not convinced that &quot;upper bound less than the lower bound&quot; is a strong enough signal for &quot;empty&quot; rather than &quot;logic error&quot;. But it seems I&#39;m in the minority.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 19, 2016, at 12:46, Uwe Falck via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m looking for feedback on this request if its worth to start an evolution proposal.<br>&gt; <br>&gt; <br>&gt; Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 20, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m a minor -1 as well. I think there&#39;s value in catching logic errors like this. I&#39;d rather see a ..&lt;? or ...? operator that introduces this behavior.<br></p><p>FWIW, the Range type doesn&#39;t actually test this at all. You can say `Range(start: 2, end: 1)` just fine, since Range can be used with elements that aren&#39;t Comparable. It&#39;s just an overload on ... and ..&lt; for Comparable elements that adds the check.<br></p><p>Also, if we change Range, we&#39;ll also need to change ClosedInterval and HalfOpenInterval (both of which include the end &gt;= start check in their initializer, since they maintain an invariant that end &gt;= start, rather than checking in the ... / ..&lt; operators). But unfortunately, this means that the only way to make `2...1` work for ClosedInterval is to relax the invariant that says that end &gt;= start, and I don&#39;t feel comfortable doing that. I think that invariant is important to maintain.<br></p><p>The end result of all this is I think we can safely introduce ..&lt;? / ...? operators for Range that require a Comparable element, which make the end of the range equal to the start if it would otherwise be less (because `Range(start: 2, end: 1)` isn&#39;t actually empty, instead it contains all values starting at two and incrementing until wraparound hits 1). But the operators wouldn&#39;t be able to produce intervals, and wouldn&#39;t work for non-comparable elements (the normal ..&lt; / ... operators work just fine on non-comparable elements already). Basically, something like<br></p><p>public func ..&lt; &lt;Pos : ForwardIndexType where Pos : Comparable&gt;(start: Pos, end: Pos) -&gt; Range&lt;Pos&gt; {<br>  return Range(start: start, end: max(start, end))<br>}<br></p><p>public func ... &lt;Pos : ForwardIndexType where Pos : Comparable&gt;(start: Pos, end: Pos) -&gt; Range&lt;Pos&gt; {<br>  let end = max(start, end)<br>  _precondition(end.successor() &gt; end, &quot;Range end index has no valid successor&quot;)<br>  return Range(start: start, end: end.successor())<br>}<br></p><p>-Kevin Ballard<br></p><p>On Wed, Jan 20, 2016, at 11:42 AM, Jordan Rose via swift-evolution wrote:<br>&gt; I&#39;m a minor -1; it feels like this is in the same family as nil-messaging in that it can silently treat invalid input as a no-op. I&#39;m not convinced that &quot;upper bound less than the lower bound&quot; is a strong enough signal for &quot;empty&quot; rather than &quot;logic error&quot;. But it seems I&#39;m in the minority.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; &gt; On Jan 19, 2016, at 12:46, Uwe Falck via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I’m looking for feedback on this request if its worth to start an evolution proposal.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/32ed5b32826658f01df18fa220fa090e?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Haravikk</string> &lt;me at haravikk.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>I’m inclined to agree though I’m pretty uncertain all round.<br></p><p>To me it seems like the only cases where someone seems likely to end up with an end index lower than their start index is either from input (in which case the value should be tested first), or some kind of logic error, in which case silently failing isn’t going to help resolve that issue (or detect it).<br></p><p>Personally I’d much prefer the opposite solution, which would be to have stride throw an error if the range given is invalid; this would still mean both cases are consistent, but without the risk of silent failures ruining your program.<br></p><p>- Haravikk<br></p><p>&gt; On 20 Jan 2016, at 19:42, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m a minor -1; it feels like this is in the same family as nil-messaging in that it can silently treat invalid input as a no-op. I&#39;m not convinced that &quot;upper bound less than the lower bound&quot; is a strong enough signal for &quot;empty&quot; rather than &quot;logic error&quot;. But it seems I&#39;m in the minority.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 12:46, Uwe Falck via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m looking for feedback on this request if its worth to start an evolution proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 1567 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/8cc15969/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 20, 2016 at 01:00:00pm</p></header><div class="content"><p>Mm. The reason &#39;..&lt;&#39; doesn&#39;t have this behavior, though, is because you get the useful property that &quot;collection[collection.startIndex..&lt;collection.endIndex]&quot; contains the same elements as &quot;collection&quot; itself. It&#39;s definitely useful to be able to represent an empty slice at a particular position (say, for replacing with another slice). It&#39;s a lot rarer to use &#39;...&#39; for slicing.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 20, 2016, at 13:17 , Haravikk &lt;me at haravikk.com&gt; wrote:<br>&gt; <br>&gt; I’m inclined to agree though I’m pretty uncertain all round.<br>&gt; <br>&gt; To me it seems like the only cases where someone seems likely to end up with an end index lower than their start index is either from input (in which case the value should be tested first), or some kind of logic error, in which case silently failing isn’t going to help resolve that issue (or detect it).<br>&gt; <br>&gt; Personally I’d much prefer the opposite solution, which would be to have stride throw an error if the range given is invalid; this would still mean both cases are consistent, but without the risk of silent failures ruining your program.<br>&gt; <br>&gt; - Haravikk<br>&gt; <br>&gt;&gt; On 20 Jan 2016, at 19:42, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m a minor -1; it feels like this is in the same family as nil-messaging in that it can silently treat invalid input as a no-op. I&#39;m not convinced that &quot;upper bound less than the lower bound&quot; is a strong enough signal for &quot;empty&quot; rather than &quot;logic error&quot;. But it seems I&#39;m in the minority.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 12:46, Uwe Falck via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m looking for feedback on this request if its worth to start an evolution proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 21, 2016 at 10:00:00am</p></header><div class="content"><p>I agree with Kevin/Jordan, I also expect this to always be true:<br></p><p>    Range&lt;Int&gt;(start: a, end: b).startIndex == a<br>    Range&lt;Int&gt;(start: a, end: b).endIndex == b<br></p><p>Possibly you could adjust Range to be something like this:<br></p><p>    struct Range&lt;T: ForwardIndexType&gt; {<br></p><p>        var start: T, end: T<br></p><p>    }<br></p><p>Ensuring that this is true:<br>    Range&lt;Int&gt;(start: a, end: b).start == a<br>    Range&lt;Int&gt;(start: a, end: b).end == b<br></p><p>Then startIndex and endIndex are simply for CollectionType conformance.<br></p><p>    extension Range: CollectionType {<br></p><p>        var startIndex: T { return start }<br>        var endIndex: T { return start &lt; end ? end : start }<br>    }<br></p><p>You can still test the validity of the range:<br>    assert(range.start &lt; range.end)<br></p><p><br>On Thu, Jan 21, 2016 at 8:23 AM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Mm. The reason &#39;..&lt;&#39; doesn&#39;t have this behavior, though, is because you<br>&gt; get the useful property that<br>&gt; &quot;collection[collection.startIndex..&lt;collection.endIndex]&quot; contains the same<br>&gt; elements as &quot;collection&quot; itself. It&#39;s definitely useful to be able to<br>&gt; represent an empty slice at a particular position (say, for replacing with<br>&gt; another slice). It&#39;s a lot rarer to use &#39;...&#39; for slicing.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; &gt; On Jan 20, 2016, at 13:17 , Haravikk &lt;me at haravikk.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I’m inclined to agree though I’m pretty uncertain all round.<br>&gt; &gt;<br>&gt; &gt; To me it seems like the only cases where someone seems likely to end up<br>&gt; with an end index lower than their start index is either from input (in<br>&gt; which case the value should be tested first), or some kind of logic error,<br>&gt; in which case silently failing isn’t going to help resolve that issue (or<br>&gt; detect it).<br>&gt; &gt;<br>&gt; &gt; Personally I’d much prefer the opposite solution, which would be to have<br>&gt; stride throw an error if the range given is invalid; this would still mean<br>&gt; both cases are consistent, but without the risk of silent failures ruining<br>&gt; your program.<br>&gt; &gt;<br>&gt; &gt; - Haravikk<br>&gt; &gt;<br>&gt; &gt;&gt; On 20 Jan 2016, at 19:42, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m a minor -1; it feels like this is in the same family as<br>&gt; nil-messaging in that it can silently treat invalid input as a no-op. I&#39;m<br>&gt; not convinced that &quot;upper bound less than the lower bound&quot; is a strong<br>&gt; enough signal for &quot;empty&quot; rather than &quot;logic error&quot;. But it seems I&#39;m in<br>&gt; the minority.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Jordan<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jan 19, 2016, at 12:46, Uwe Falck via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I’m looking for feedback on this request if its worth to start an<br>&gt; evolution proposal.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Let range operators always return empty ranges if the upper bound is<br>&gt; smaller than the lower bound.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/5bea81f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fc40f95a5c6b063df44b3bc136d764b?s=50"></div><header><strong>Let range operators always return empty ranges if the upper bound is smaller than the lower bound.</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.com&gt;<p>January 21, 2016 at 04:00:00pm</p></header><div class="content"><p>The tricky thing with ranges at the moment is that they can’t actually represent a full range of an integer type, for example a Range&lt;UInt8&gt; can only represent a range from 0 to 254 (endIndex is 255 but is exclusive). This actually means that a collection type that used a UInt8 for indexes is limited to 255 entries, not 256 as you would expect, which is unfortunate if the collection type allocates storage in powers of two.<br></p><p>I think this means that if ranges were changed to have an inclusive end index then collections would need to be modified to function on the same principal, otherwise we could end up with a range that represents an upper limit that collections cannot, or alternatively we have to artificially limit the supported values for .end, i.e- for a UInt8 .end would be limited to a value of 254, so that .endIndex can be set to 255.<br></p><p>For use with collections I’d love to use inclusive rather than exclusive end indexes for this reason, as while 1 inaccessible element doesn’t seem like much, it still annoys me an unreasonable amount. But would this change the meaning of a range? i.e- 1 ..&lt; 4 isn’t necessarily the same as 1 … 3, it’s only functionally equivalent when dealing with integers since there are no stages in between.<br></p><p>&gt; On 20 Jan 2016, at 23:19, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with Kevin/Jordan, I also expect this to always be true:<br>&gt; <br>&gt;     Range&lt;Int&gt;(start: a, end: b).startIndex == a<br>&gt;     Range&lt;Int&gt;(start: a, end: b).endIndex == b<br>&gt; <br>&gt; Possibly you could adjust Range to be something like this:<br>&gt; <br>&gt;     struct Range&lt;T: ForwardIndexType&gt; {<br>&gt;         var start: T, end: T<br>&gt;     }<br>&gt; <br>&gt; Ensuring that this is true:<br>&gt;     Range&lt;Int&gt;(start: a, end: b).start == a<br>&gt;     Range&lt;Int&gt;(start: a, end: b).end == b<br>&gt; <br>&gt; Then startIndex and endIndex are simply for CollectionType conformance.<br>&gt; <br>&gt;     extension Range: CollectionType {<br>&gt;         var startIndex: T { return start }<br>&gt;         var endIndex: T { return start &lt; end ? end : start }<br>&gt;     }<br>&gt; <br>&gt; You can still test the validity of the range:<br>&gt;     assert(range.start &lt; range.end)<br>&gt; <br>&gt; <br>&gt; On Thu, Jan 21, 2016 at 8:23 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Mm. The reason &#39;..&lt;&#39; doesn&#39;t have this behavior, though, is because you get the useful property that &quot;collection[collection.startIndex..&lt;collection.endIndex]&quot; contains the same elements as &quot;collection&quot; itself. It&#39;s definitely useful to be able to represent an empty slice at a particular position (say, for replacing with another slice). It&#39;s a lot rarer to use &#39;...&#39; for slicing.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; &gt; On Jan 20, 2016, at 13:17 , Haravikk &lt;me at haravikk.com &lt;mailto:me at haravikk.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I’m inclined to agree though I’m pretty uncertain all round.<br>&gt; &gt;<br>&gt; &gt; To me it seems like the only cases where someone seems likely to end up with an end index lower than their start index is either from input (in which case the value should be tested first), or some kind of logic error, in which case silently failing isn’t going to help resolve that issue (or detect it).<br>&gt; &gt;<br>&gt; &gt; Personally I’d much prefer the opposite solution, which would be to have stride throw an error if the range given is invalid; this would still mean both cases are consistent, but without the risk of silent failures ruining your program.<br>&gt; &gt;<br>&gt; &gt; - Haravikk<br>&gt; &gt;<br>&gt; &gt;&gt; On 20 Jan 2016, at 19:42, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m a minor -1; it feels like this is in the same family as nil-messaging in that it can silently treat invalid input as a no-op. I&#39;m not convinced that &quot;upper bound less than the lower bound&quot; is a strong enough signal for &quot;empty&quot; rather than &quot;logic error&quot;. But it seems I&#39;m in the minority.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Jordan<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jan 19, 2016, at 12:46, Uwe Falck via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I’m looking for feedback on this request if its worth to start an evolution proposal.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Let range operators always return empty ranges if the upper bound is smaller than the lower bound.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/46766acd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
