<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Checking whether an object is uniquely referenced, using a weak reference to it</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>June 28, 2016 at 03:00:00am</p></header><div class="content"><p>Thanks for your reply. It didn’t clear up everything, though. The official documentation says &quot;Weak references do not affect the result of this function.”, which suggests that weak (and unowned) references intentionally aren’t counted. The docs only mention the implementation of copy-on-write behaviour as a use case (which also happens to be what I’m using it for).<br></p><p>Couldn’t there just a be a function that returns the reference count of a given object as an Int? It would make everything a lot easier (i.e. it wouldn’t need inout because it can just create a reference to that object, find the reference count, then subtract 1).<br></p><p>&gt; Hi, Tim. The purpose of the isUniquelyReferenced checks is to see whether any changes to the properties of the object can be observed from elsewhere in this program. Therefore, I wouldexpectit to return ‘false’ when there are weak (or unowned) references present, i.e. I think the bug is that we don’t consider weak or unowned references to count for this check.<br>&gt; <br>&gt; If my understanding of the intended behavior is correct, then it doesn’t make sense to check for a uniquely-referenced object through a weak (or unowned) reference, because if that were the only reference, then the object would have already been deallocated.<br>&gt; <br>&gt; The particular technical reason for the check failing is related to the inout, as you say: in order to pass the reference to the function inout, it has to be loaded into a strong reference first. The reason the inout is there at all is because otherwise the check would fail: there would be a reference from outside the function in addition to the one for the argument.<br>&gt; <br>&gt; Hope that clears things up, and if you agree with my interpretation about weak and unowned references, please file a bug atbugs.swift.org(http://bugs.swift.org)!<br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 27, 2016, at 17:14, Tim Vermeulen via swift-users&lt;swift-users at swift.org(mailto:swift-users at swift.org)&gt;wrote:<br>&gt; &gt; classEmptyClass {}<br>&gt; &gt; <br>&gt; &gt; varstrongReference =EmptyClass()<br>&gt; &gt; weakvarweakReference =strongReference<br>&gt; &gt; <br>&gt; &gt; print(isUniquelyReferencedNonObjC(&amp;strongReference))// true<br>&gt; &gt; print(isUniquelyReferencedNonObjC(&amp;weakReference))// false<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; I expected both print statements to print true.<br>&gt; &gt; <br>&gt; &gt; I realise that this is probably a known limitation of this function. After all, if it worked with weak references too, there’s no point for the parameter to be inout:<br>&gt; &gt; <br>&gt; &gt; funcwrappedIsUniquelyReferencedNonObjC&lt;T:AnyObject&gt;(_object:T) -&gt;Bool{<br>&gt; &gt; weakvarweakObject = object<br>&gt; &gt; returnisUniquelyReferencedNonObjC(&amp;weakObject)<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; So the fact that this function takes an inout parameter hints at the fact that it doesn’t work with weak references. If my reasoning is correct, it would be nice if the docs stated that it only works with strong references to objects. :)<br>&gt; &gt; <br>&gt; &gt; My question is, is it possible at all to use a weak reference to check whether an object is uniquely referenced or not? Since this approach doesn’t seem to work, I guess it is impossible?_______________________________________________<br>&gt; &gt; swift-users mailing list<br>&gt; &gt; swift-users at swift.org(mailto:swift-users at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Checking whether an object is uniquely referenced, using a weak reference to it</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 18:52, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt; <br>&gt; Thanks for your reply. It didn’t clear up everything, though. The official documentation says &quot;Weak references do not affect the result of this function.”, which suggests that weak (and unowned) references intentionally aren’t counted. The docs only mention the implementation of copy-on-write behaviour as a use case (which also happens to be what I’m using it for).<br></p><p>I would expect that weak references are important to count for COW, since you can observe changes through them. Dave?<br></p><p><br>&gt; <br>&gt; Couldn’t there just a be a function that returns the reference count of a given object as an Int? It would make everything a lot easier (i.e. it wouldn’t need inout because it can just create a reference to that object, find the reference count, then subtract 1).<br></p><p>As we’ve said for a long time in Objective-C, asking for the reference count of an object is meaningless. isUniquelyReferenced only works because it’s conservative: because it only checks for “exactly 1”, it’s safe from threading issues and autorelease pools. We do not plan to add a -retainCount equivalent to Swift.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Checking whether an object is uniquely referenced, using a weak reference to it</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>on Tue Jun 28 2016, Jordan Rose &lt;jordan_rose-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 18:52, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for your reply. It didn’t clear up everything, though. The<br>&gt;&gt; official documentation says &quot;Weak references do not affect the<br>&gt;&gt; result of this function.”, which suggests that weak (and unowned)<br>&gt;&gt; references intentionally aren’t counted. The docs only mention the<br>&gt;&gt; implementation of copy-on-write behaviour as a use case (which also<br>&gt;&gt; happens to be what I’m using it for).<br>&gt;<br>&gt; I would expect that weak references are important to count for COW,<br>&gt; since you can observe changes through them. Dave?<br></p><p>I can try to address this thread, but not immediately I&#39;m afraid.  I&#39;m<br>just swamped at the moment.<br></p><p>Sorry,<br>-- <br>Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Checking whether an object is uniquely referenced, using a weak reference to it</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:32 AM, Jordan Rose via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 18:52, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for your reply. It didn’t clear up everything, though. The official documentation says &quot;Weak references do not affect the result of this function.”, which suggests that weak (and unowned) references intentionally aren’t counted. The docs only mention the implementation of copy-on-write behaviour as a use case (which also happens to be what I’m using it for).<br>&gt; <br>&gt; I would expect that weak references are important to count for COW, since you can observe changes through them. Dave?<br></p><p>Passing a weak reference inout goes through a strong optional shadow copy. It wouldn&#39;t be safe to directly address the weak reference.<br></p><p>-Joe<br></p><p>&gt;&gt; <br>&gt;&gt; Couldn’t there just a be a function that returns the reference count of a given object as an Int? It would make everything a lot easier (i.e. it wouldn’t need inout because it can just create a reference to that object, find the reference count, then subtract 1).<br>&gt; <br>&gt; As we’ve said for a long time in Objective-C, asking for the reference count of an object is meaningless. isUniquelyReferenced only works because it’s conservative: because it only checks for “exactly 1”, it’s safe from threading issues and autorelease pools. We do not plan to add a -retainCount equivalent to Swift.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Checking whether an object is uniquely referenced, using a weak reference to it</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>June 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:32 AM, Jordan Rose via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 18:52, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for your reply. It didn’t clear up everything, though. The official documentation says &quot;Weak references do not affect the result of this function.”, which suggests that weak (and unowned) references intentionally aren’t counted. The docs only mention the implementation of copy-on-write behaviour as a use case (which also happens to be what I’m using it for).<br>&gt; <br>&gt; I would expect that weak references are important to count for COW, since you can observe changes through them. Dave?<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Couldn’t there just a be a function that returns the reference count of a given object as an Int? It would make everything a lot easier (i.e. it wouldn’t need inout because it can just create a reference to that object, find the reference count, then subtract 1).<br>&gt; <br>&gt; As we’ve said for a long time in Objective-C, asking for the reference count of an object is meaningless. isUniquelyReferenced only works because it’s conservative: because it only checks for “exactly 1”, it’s safe from threading issues and autorelease pools. We do not plan to add a -retainCount equivalent to Swift.<br>&gt; <br>&gt; Jordan<br></p><p>Specifically, isUniquelyReferenced guarantees “exactly 1” if it returns ‘true’. It does not guarantee ‘&gt; 1’ by returning ‘false’. In other words, the implementation reserves the right to return ‘false’ whenever it feels like it. The user can’t directly control the number of local references that exist. So, although it’s critical for optimization, you shouldn’t build any visible program behavior around isUniquelyReferenced.<br></p><p>I don’t have a good answer on the weak reference semantics, but I *suspect* that considering weak references in the count is neither feasible for objc-style weak references, nor useful since we don’t expose weak references to CoW storage.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Checking whether an object is uniquely referenced, using a weak reference to it</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 06:00:00pm</p></header><div class="content"><p>on Tue Jun 28 2016, Andrew Trick &lt;atrick-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 28, 2016, at 9:32 AM, Jordan Rose via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 18:52, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Thanks for your reply. It didn’t clear up everything, though. The<br>&gt;&gt;&gt; official documentation says &quot;Weak references do not affect the<br>&gt;&gt;&gt; result of this function.”, which suggests that weak (and unowned)<br>&gt;&gt;&gt; references intentionally aren’t counted. The docs only mention the<br>&gt;&gt;&gt; implementation of copy-on-write behaviour as a use case (which also<br>&gt;&gt;&gt; happens to be what I’m using it for).<br>&gt;&gt; <br>&gt;&gt; I would expect that weak references are important to count for COW,<br>&gt;&gt; since you can observe changes through them. Dave?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Couldn’t there just a be a function that returns the reference<br>&gt;&gt;&gt; count of a given object as an Int? It would make everything a lot<br>&gt;&gt;&gt; easier (i.e. it wouldn’t need inout because it can just create a<br>&gt;&gt;&gt; reference to that object, find the reference count, then subtract<br>&gt;&gt;&gt; 1).<br>&gt;&gt; <br>&gt;&gt; As we’ve said for a long time in Objective-C, asking for the<br>&gt;&gt; reference count of an object is meaningless. isUniquelyReferenced<br>&gt;&gt; only works because it’s conservative: because it only checks for<br>&gt;&gt; “exactly 1”, it’s safe from threading issues and autorelease<br>&gt;&gt; pools. We do not plan to add a -retainCount equivalent to Swift.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;<br>&gt; Specifically, isUniquelyReferenced guarantees “exactly 1” if it<br>&gt; returns ‘true’. It does not guarantee ‘&gt; 1’ by returning ‘false’. In<br>&gt; other words, the implementation reserves the right to return ‘false’<br>&gt; whenever it feels like it. The user can’t directly control the number<br>&gt; of local references that exist. So, although it’s critical for<br>&gt; optimization, you shouldn’t build any visible program behavior around<br>&gt; isUniquelyReferenced.<br>&gt;<br>&gt; I don’t have a good answer on the weak reference semantics, but I<br>&gt; *suspect* that considering weak references in the count is neither<br>&gt; feasible for objc-style weak references, nor useful since we don’t<br>&gt; expose weak references to CoW storage.<br></p><p>We have a race in this case:<br></p><p>  class X {}<br>  var a = [X()]<br>  weak var b = a as NSArray<br>  async {<br>    // Reads the buffer through the weak reference in another thread.<br>    print(b!.object(at: 0))<br>  }<br>  // Sees that a&#39;s buffer is uniquely referenced and begins to modify it<br>  // in place.<br>  a[0] = X()<br></p><p>So yes, isUniquelyReferenced should always be false if the weak<br>reference count is nonzero.  We can read the weak and strong reference<br>counts together with a single instruction so this should be easily<br>implementable.  We just haven&#39;t done it. &lt;rdar://problem/27070378&gt; <br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Checking whether an object is uniquely referenced, using a weak reference to it</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 18, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Jun 28 2016, Jordan Rose &lt;jordan_rose-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 18:52, Tim Vermeulen &lt;tvermeulen at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for your reply. It didn’t clear up everything, though. The<br>&gt;&gt; official documentation says &quot;Weak references do not affect the<br>&gt;&gt; result of this function.”, which suggests that weak (and unowned)<br>&gt;&gt; references intentionally aren’t counted. The docs only mention the<br>&gt;&gt; implementation of copy-on-write behaviour as a use case (which also<br>&gt;&gt; happens to be what I’m using it for).<br>&gt;<br>&gt; I would expect that weak references are important to count for COW,<br>&gt; since you can observe changes through them. Dave?<br></p><p>This sort of depends on what you expect the semantics of your weak<br>reference to be.  It&#39;s not possible to take a weak reference to an<br>Array; you can only take a weak reference to the NSArray it uses as a<br>backing store.  That&#39;s an Objective-C-only idea.<br></p><p>Given an arbitrary NSArray on the Objective-C side, it might turn out to<br>be an NSMutableArray, so if you want to avoid observing changes to it,<br>in principle you need to copy it.  So I think it&#39;s possible to argue<br>that the weak reference count is not an issue here.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
